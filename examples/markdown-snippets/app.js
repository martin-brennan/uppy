(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Adapted from https://github.com/Flet/prettier-bytes/
// Changing 1000 bytes to 1024, so we can keep uppercase KB vs kB
// ISC License (c) Dan Flettre https://github.com/Flet/prettier-bytes/blob/master/LICENSE
module.exports = function prettierBytes (num) {
  if (typeof num !== 'number' || isNaN(num)) {
    throw new TypeError('Expected a number, got ' + typeof num)
  }

  var neg = num < 0
  var units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']

  if (neg) {
    num = -num
  }

  if (num < 1) {
    return (neg ? '-' : '') + num + ' B'
  }

  var exponent = Math.min(Math.floor(Math.log(num) / Math.log(1024)), units.length - 1)
  num = Number(num / Math.pow(1024, exponent))
  var unit = units[exponent]

  if (num >= 10 || num % 1 === 0) {
    // Do not show decimals when the number is two-digit, or if the number has no
    // decimal component.
    return (neg ? '-' : '') + num.toFixed(0) + ' ' + unit
  } else {
    return (neg ? '-' : '') + num.toFixed(1) + ' ' + unit
  }
}

},{}],2:[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],3:[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],4:[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],5:[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();

},{}],6:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],7:[function(require,module,exports){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
  typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :
  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : 
  false;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  return ary.map(function(chunk) {
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      return buf;
    }

    return chunk;
  });
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary).forEach(function(part) {
    bb.append(part);
  });

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  return new Blob(mapArrayBufferViews(ary), options || {});
};

if (typeof Blob !== 'undefined') {
  BlobBuilderConstructor.prototype = Blob.prototype;
  BlobConstructor.prototype = Blob.prototype;
}

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

},{}],8:[function(require,module,exports){

},{}],9:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":6,"buffer":9,"ieee754":27}],10:[function(require,module,exports){
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString === Object.prototype.toString) {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				} else {
					classes.push(arg.toString());
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],11:[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],12:[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],13:[function(require,module,exports){
/**
 * cuid.js
 * Collision-resistant UID generator for browsers and node.
 * Sequential for fast db lookups and recency sorting.
 * Safe for element IDs and server-side lookups.
 *
 * Extracted from CLCTR
 *
 * Copyright (c) Eric Elliott 2012
 * MIT License
 */

var fingerprint = require('./lib/fingerprint.js');
var pad = require('./lib/pad.js');
var getRandomValue = require('./lib/getRandomValue.js');

var c = 0,
  blockSize = 4,
  base = 36,
  discreteValues = Math.pow(base, blockSize);

function randomBlock () {
  return pad((getRandomValue() *
    discreteValues << 0)
    .toString(base), blockSize);
}

function safeCounter () {
  c = c < discreteValues ? c : 0;
  c++; // this is not subliminal
  return c - 1;
}

function cuid () {
  // Starting with a lowercase letter makes
  // it HTML element ID friendly.
  var letter = 'c', // hard-coded allows for sequential access

    // timestamp
    // warning: this exposes the exact date and time
    // that the uid was created.
    timestamp = (new Date().getTime()).toString(base),

    // Prevent same-machine collisions.
    counter = pad(safeCounter().toString(base), blockSize),

    // A few chars to generate distinct ids for different
    // clients (so different computers are far less
    // likely to generate the same id)
    print = fingerprint(),

    // Grab some more chars from Math.random()
    random = randomBlock() + randomBlock();

  return letter + timestamp + counter + print + random;
}

cuid.slug = function slug () {
  var date = new Date().getTime().toString(36),
    counter = safeCounter().toString(36).slice(-4),
    print = fingerprint().slice(0, 1) +
      fingerprint().slice(-1),
    random = randomBlock().slice(-2);

  return date.slice(-2) +
    counter + print + random;
};

cuid.isCuid = function isCuid (stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  if (stringToCheck.startsWith('c')) return true;
  return false;
};

cuid.isSlug = function isSlug (stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  var stringLength = stringToCheck.length;
  if (stringLength >= 7 && stringLength <= 10) return true;
  return false;
};

cuid.fingerprint = fingerprint;

module.exports = cuid;

},{"./lib/fingerprint.js":14,"./lib/getRandomValue.js":15,"./lib/pad.js":16}],14:[function(require,module,exports){
var pad = require('./pad.js');

var env = typeof window === 'object' ? window : self;
var globalCount = Object.keys(env).length;
var mimeTypesLength = navigator.mimeTypes ? navigator.mimeTypes.length : 0;
var clientId = pad((mimeTypesLength +
  navigator.userAgent.length).toString(36) +
  globalCount.toString(36), 4);

module.exports = function fingerprint () {
  return clientId;
};

},{"./pad.js":16}],15:[function(require,module,exports){

var getRandomValue;

var crypto = typeof window !== 'undefined' &&
  (window.crypto || window.msCrypto) ||
  typeof self !== 'undefined' &&
  self.crypto;

if (crypto) {
    var lim = Math.pow(2, 32) - 1;
    getRandomValue = function () {
        return Math.abs(crypto.getRandomValues(new Uint32Array(1))[0] / lim);
    };
} else {
    getRandomValue = Math.random;
}

module.exports = getRandomValue;

},{}],16:[function(require,module,exports){
module.exports = function pad (num, size) {
  var s = '000000000' + num;
  return s.substr(s.length - size);
};

},{}],17:[function(require,module,exports){
module.exports = dragDrop

var flatten = require('flatten')
var parallel = require('run-parallel')

function dragDrop (elem, listeners) {
  if (typeof elem === 'string') {
    var selector = elem
    elem = window.document.querySelector(elem)
    if (!elem) {
      throw new Error('"' + selector + '" does not match any HTML elements')
    }
  }

  if (!elem) {
    throw new Error('"' + elem + '" is not a valid HTML element')
  }

  if (typeof listeners === 'function') {
    listeners = { onDrop: listeners }
  }

  var timeout

  elem.addEventListener('dragenter', onDragEnter, false)
  elem.addEventListener('dragover', onDragOver, false)
  elem.addEventListener('dragleave', onDragLeave, false)
  elem.addEventListener('drop', onDrop, false)

  // Function to remove drag-drop listeners
  return function remove () {
    removeDragClass()
    elem.removeEventListener('dragenter', onDragEnter, false)
    elem.removeEventListener('dragover', onDragOver, false)
    elem.removeEventListener('dragleave', onDragLeave, false)
    elem.removeEventListener('drop', onDrop, false)
  }

  function onDragEnter (e) {
    if (listeners.onDragEnter) {
      listeners.onDragEnter(e)
    }

    // Prevent event
    e.stopPropagation()
    e.preventDefault()
    return false
  }

  function onDragOver (e) {
    e.stopPropagation()
    e.preventDefault()

    if (listeners.onDragOver) {
      listeners.onDragOver(e)
    }

    if (e.dataTransfer.items) {
      // Only add "drag" class when `items` contains items that are able to be
      // handled by the registered listeners (files vs. text)
      var items = Array.from(e.dataTransfer.items)
      var fileItems = items.filter(function (item) { return item.kind === 'file' })
      var textItems = items.filter(function (item) { return item.kind === 'string' })

      if (fileItems.length === 0 && !listeners.onDropText) return
      if (textItems.length === 0 && !listeners.onDrop) return
      if (fileItems.length === 0 && textItems.length === 0) return
    }

    elem.classList.add('drag')
    clearTimeout(timeout)

    e.dataTransfer.dropEffect = 'copy'

    return false
  }

  function onDragLeave (e) {
    e.stopPropagation()
    e.preventDefault()

    if (listeners.onDragLeave) {
      listeners.onDragLeave(e)
    }

    clearTimeout(timeout)
    timeout = setTimeout(removeDragClass, 50)

    return false
  }

  function onDrop (e) {
    e.stopPropagation()
    e.preventDefault()

    if (listeners.onDragLeave) {
      listeners.onDragLeave(e)
    }

    clearTimeout(timeout)
    removeDragClass()

    var pos = {
      x: e.clientX,
      y: e.clientY
    }

    // text drop support
    var text = e.dataTransfer.getData('text')
    if (text && listeners.onDropText) {
      listeners.onDropText(text, pos)
    }

    // File drop support. The `dataTransfer.items` API supports directories, so we
    // use it instead of `dataTransfer.files`, even though it's much more
    // complicated to use.
    // See: https://github.com/feross/drag-drop/issues/39
    if (listeners.onDrop && e.dataTransfer.items) {
      var fileList = e.dataTransfer.files

      // Handle directories in Chrome using the proprietary FileSystem API
      var items = Array.from(e.dataTransfer.items).filter(function (item) {
        return item.kind === 'file'
      })

      if (items.length === 0) return

      parallel(items.map(function (item) {
        return function (cb) {
          processEntry(item.webkitGetAsEntry(), cb)
        }
      }), function (err, results) {
        // This catches permission errors with file:// in Chrome. This should never
        // throw in production code, so the user does not need to use try-catch.
        if (err) throw err

        var entries = flatten(results)

        var files = entries.filter(function (item) {
          return item.isFile
        })

        var directories = entries.filter(function (item) {
          return item.isDirectory
        })

        listeners.onDrop(files, pos, fileList, directories)
      })
    }

    return false
  }

  function removeDragClass () {
    elem.classList.remove('drag')
  }
}

function processEntry (entry, cb) {
  var entries = []

  if (entry.isFile) {
    entry.file(function (file) {
      file.fullPath = entry.fullPath // preserve pathing for consumer
      file.isFile = true
      file.isDirectory = false
      cb(null, file)
    }, function (err) {
      cb(err)
    })
  } else if (entry.isDirectory) {
    var reader = entry.createReader()
    readEntries()
  }

  function readEntries () {
    reader.readEntries(function (entries_) {
      if (entries_.length > 0) {
        entries = entries.concat(Array.from(entries_))
        readEntries() // continue reading entries until `readEntries` returns no more
      } else {
        doneEntries()
      }
    })
  }

  function doneEntries () {
    parallel(entries.map(function (entry) {
      return function (cb) {
        processEntry(entry, cb)
      }
    }), function (err, results) {
      if (err) {
        cb(err)
      } else {
        results.push({
          fullPath: entry.fullPath,
          name: entry.name,
          isFile: false,
          isDirectory: true
        })
        cb(null, results)
      }
    })
  }
}

},{"flatten":18,"run-parallel":43}],18:[function(require,module,exports){
module.exports = function flatten(list, depth) {
  depth = (typeof depth == 'number') ? depth : Infinity;

  if (!depth) {
    if (Array.isArray(list)) {
      return list.map(function(i) { return i; });
    }
    return list;
  }

  return _flatten(list, 1);

  function _flatten(list, d) {
    return list.reduce(function (acc, item) {
      if (Array.isArray(item) && d < depth) {
        return acc.concat(_flatten(item, d + 1));
      }
      else {
        return acc.concat(item);
      }
    }, []);
  }
};

},{}],19:[function(require,module,exports){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary2');
var sliceBuffer = require('arraybuffer.slice');
var after = require('after');
var utf8 = require('./utf8');

var base64encoder;
if (typeof ArrayBuffer !== 'undefined') {
  base64encoder = require('base64-arraybuffer');
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

},{"./keys":20,"./utf8":21,"after":2,"arraybuffer.slice":3,"base64-arraybuffer":5,"blob":7,"has-binary2":24}],20:[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],21:[function(require,module,exports){
/*! https://mths.be/utf8js v2.1.2 by @mathias */

var stringFromCharCode = String.fromCharCode;

// Taken from https://mths.be/punycode
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	var value;
	var extra;
	while (counter < length) {
		value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// high surrogate, and there is a next character
			extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // low surrogate
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// unmatched surrogate; only append this code unit, in case the next
				// code unit is the high surrogate of a surrogate pair
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

// Taken from https://mths.be/punycode
function ucs2encode(array) {
	var length = array.length;
	var index = -1;
	var value;
	var output = '';
	while (++index < length) {
		value = array[index];
		if (value > 0xFFFF) {
			value -= 0x10000;
			output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
			value = 0xDC00 | value & 0x3FF;
		}
		output += stringFromCharCode(value);
	}
	return output;
}

function checkScalarValue(codePoint, strict) {
	if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
		if (strict) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
		return false;
	}
	return true;
}
/*--------------------------------------------------------------------------*/

function createByte(codePoint, shift) {
	return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
}

function encodeCodePoint(codePoint, strict) {
	if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
		return stringFromCharCode(codePoint);
	}
	var symbol = '';
	if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
		symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
	}
	else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
		if (!checkScalarValue(codePoint, strict)) {
			codePoint = 0xFFFD;
		}
		symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
		symbol += createByte(codePoint, 6);
	}
	else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
		symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
		symbol += createByte(codePoint, 12);
		symbol += createByte(codePoint, 6);
	}
	symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
	return symbol;
}

function utf8encode(string, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	var codePoints = ucs2decode(string);
	var length = codePoints.length;
	var index = -1;
	var codePoint;
	var byteString = '';
	while (++index < length) {
		codePoint = codePoints[index];
		byteString += encodeCodePoint(codePoint, strict);
	}
	return byteString;
}

/*--------------------------------------------------------------------------*/

function readContinuationByte() {
	if (byteIndex >= byteCount) {
		throw Error('Invalid byte index');
	}

	var continuationByte = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	if ((continuationByte & 0xC0) == 0x80) {
		return continuationByte & 0x3F;
	}

	// If we end up here, its not a continuation byte
	throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
	var byte1;
	var byte2;
	var byte3;
	var byte4;
	var codePoint;

	if (byteIndex > byteCount) {
		throw Error('Invalid byte index');
	}

	if (byteIndex == byteCount) {
		return false;
	}

	// Read first byte
	byte1 = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	// 1-byte sequence (no continuation bytes)
	if ((byte1 & 0x80) == 0) {
		return byte1;
	}

	// 2-byte sequence
	if ((byte1 & 0xE0) == 0xC0) {
		byte2 = readContinuationByte();
		codePoint = ((byte1 & 0x1F) << 6) | byte2;
		if (codePoint >= 0x80) {
			return codePoint;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 3-byte sequence (may include unpaired surrogates)
	if ((byte1 & 0xF0) == 0xE0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
		if (codePoint >= 0x0800) {
			return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 4-byte sequence
	if ((byte1 & 0xF8) == 0xF0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		byte4 = readContinuationByte();
		codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
			(byte3 << 0x06) | byte4;
		if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
			return codePoint;
		}
	}

	throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	byteArray = ucs2decode(byteString);
	byteCount = byteArray.length;
	byteIndex = 0;
	var codePoints = [];
	var tmp;
	while ((tmp = decodeSymbol(strict)) !== false) {
		codePoints.push(tmp);
	}
	return ucs2encode(codePoints);
}

module.exports = {
	version: '2.1.2',
	encode: utf8encode,
	decode: utf8decode
};

},{}],22:[function(require,module,exports){
(function (process,global,Buffer){(function (){
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define("exifr",["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).exifr={})}(this,(function(e){"use strict";function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function r(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}});var n=["prototype","__proto__","caller","arguments","length","name"];Object.getOwnPropertyNames(t).forEach((function(r){-1===n.indexOf(r)&&e[r]!==t[r]&&(e[r]=t[r])})),t&&u(e,t)}function s(e){return(s=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function u(e,t){return(u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function o(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function f(e,t,n){return(f=o()?Reflect.construct:function(e,t,n){var r=[null];r.push.apply(r,t);var i=new(Function.bind.apply(e,r));return n&&u(i,n.prototype),i}).apply(null,arguments)}function c(e){var t="function"==typeof Map?new Map:void 0;return(c=function(e){if(null===e||(n=e,-1===Function.toString.call(n).indexOf("[native code]")))return e;var n;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,r)}function r(){return f(e,arguments,s(this).constructor)}return r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),u(r,e)})(e)}function h(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function l(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?h(e):t}function d(e){var t=o();return function(){var n,r=s(e);if(t){var i=s(this).constructor;n=Reflect.construct(r,arguments,i)}else n=r.apply(this,arguments);return l(this,n)}}function v(e,t,n){return(v="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var r=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=s(e)););return e}(e,t);if(r){var i=Object.getOwnPropertyDescriptor(r,t);return i.get?i.get.call(n):i.value}})(e,t,n||e)}var p=Object.values||function(e){var t=[];for(var n in e)t.push(e[n]);return t},y=Object.entries||function(e){var t=[];for(var n in e)t.push([n,e[n]]);return t},g=Object.assign||function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return n.forEach((function(t){for(var n in t)e[n]=t[n]})),e},k=Object.fromEntries||function(e){var t={};return m(e).forEach((function(e){var n=e[0],r=e[1];t[n]=r})),t},m=Array.from||function(e){if(e instanceof P){var t=[];return e.forEach((function(e,n){return t.push([n,e])})),t}return Array.prototype.slice.call(e)};function b(e){return-1!==this.indexOf(e)}Array.prototype.includes||(Array.prototype.includes=b),String.prototype.includes||(String.prototype.includes=b),String.prototype.startsWith||(String.prototype.startsWith=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.substring(t,t+e.length)===e}),String.prototype.endsWith||(String.prototype.endsWith=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.length;return this.substring(t-e.length,t)===e});var A="undefined"!=typeof self?self:global,w=A.fetch||function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new Promise((function(n,r){var i=new XMLHttpRequest;if(i.open("get",e,!0),i.responseType="arraybuffer",i.onerror=r,t.headers)for(var a in t.headers)i.setRequestHeader(a,t.headers[a]);i.onload=function(){n({ok:i.status>=200&&i.status<300,status:i.status,arrayBuffer:function(){return Promise.resolve(i.response)}})},i.send(null)}))},O=function(e){var t=[];if(Object.defineProperties(t,{size:{get:function(){return this.length}},has:{value:function(e){return-1!==this.indexOf(e)}},add:{value:function(e){this.has(e)||this.push(e)}},delete:{value:function(e){if(this.has(e)){var t=this.indexOf(e);this.splice(t,1)}}}}),Array.isArray(e))for(var n=0;n<e.length;n++)t.add(e[n]);return t},S=function(e){return new P(e)},P=void 0!==A.Map&&void 0!==A.Map.prototype.keys?A.Map:function(){function e(n){if(t(this,e),this.clear(),n)for(var r=0;r<n.length;r++)this.set(n[r][0],n[r][1])}return r(e,[{key:"clear",value:function(){this._map={},this._keys=[]}},{key:"size",get:function(){return this._keys.length}},{key:"get",value:function(e){return this._map["map_"+e]}},{key:"set",value:function(e,t){return this._map["map_"+e]=t,this._keys.indexOf(e)<0&&this._keys.push(e),this}},{key:"has",value:function(e){return this._keys.indexOf(e)>=0}},{key:"delete",value:function(e){var t=this._keys.indexOf(e);return!(t<0)&&(delete this._map["map_"+e],this._keys.splice(t,1),!0)}},{key:"keys",value:function(){return this._keys.slice(0)}},{key:"values",value:function(){var e=this;return this._keys.map((function(t){return e.get(t)}))}},{key:"entries",value:function(){var e=this;return this._keys.map((function(t){return[t,e.get(t)]}))}},{key:"forEach",value:function(e,t){for(var n=0;n<this._keys.length;n++)e.call(t,this._map["map_"+this._keys[n]],this._keys[n],this)}}]),e}(),U="undefined"!=typeof self?self:global,x="undefined"!=typeof navigator,C=x&&"undefined"==typeof HTMLImageElement,B=!("undefined"==typeof global||"undefined"==typeof process||!process.versions||!process.versions.node),j=U.Buffer,_=!!j;var V=function(e){return void 0!==e};function I(e){return void 0===e||(e instanceof P?0===e.size:0===p(e).filter(V).length)}function L(e){var t=new Error(e);throw delete t.stack,t}function T(e){var t=function(e){var t=0;return e.ifd0.enabled&&(t+=1024),e.exif.enabled&&(t+=2048),e.makerNote&&(t+=2048),e.userComment&&(t+=1024),e.gps.enabled&&(t+=512),e.interop.enabled&&(t+=100),e.ifd1.enabled&&(t+=1024),t+2048}(e);return e.jfif.enabled&&(t+=50),e.xmp.enabled&&(t+=2e4),e.iptc.enabled&&(t+=14e3),e.icc.enabled&&(t+=6e3),t}var z=function(e){return String.fromCharCode.apply(null,e)},F="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):void 0;function E(e){return F?F.decode(e):_?Buffer.from(e).toString("utf8"):decodeURIComponent(escape(z(e)))}var D=function(){function e(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(t(this,e),"boolean"==typeof a&&(this.le=a),Array.isArray(n)&&(n=new Uint8Array(n)),0===n)this.byteOffset=0,this.byteLength=0;else if(n instanceof ArrayBuffer){void 0===i&&(i=n.byteLength-r);var s=new DataView(n,r,i);this._swapDataView(s)}else if(n instanceof Uint8Array||n instanceof DataView||n instanceof e){void 0===i&&(i=n.byteLength-r),(r+=n.byteOffset)+i>n.byteOffset+n.byteLength&&L("Creating view outside of available memory in ArrayBuffer");var u=new DataView(n.buffer,r,i);this._swapDataView(u)}else if("number"==typeof n){var o=new DataView(new ArrayBuffer(n));this._swapDataView(o)}else L("Invalid input argument for BufferView: "+n)}return r(e,[{key:"_swapArrayBuffer",value:function(e){this._swapDataView(new DataView(e))}},{key:"_swapBuffer",value:function(e){this._swapDataView(new DataView(e.buffer,e.byteOffset,e.byteLength))}},{key:"_swapDataView",value:function(e){this.dataView=e,this.buffer=e.buffer,this.byteOffset=e.byteOffset,this.byteLength=e.byteLength}},{key:"_lengthToEnd",value:function(e){return this.byteLength-e}},{key:"set",value:function(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;t instanceof DataView||t instanceof e?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t instanceof ArrayBuffer&&(t=new Uint8Array(t)),t instanceof Uint8Array||L("BufferView.set(): Invalid data argument.");var i=this.toUint8();return i.set(t,n),new r(this,n,t.byteLength)}},{key:"subarray",value:function(t,n){return new e(this,t,n=n||this._lengthToEnd(t))}},{key:"toUint8",value:function(){return new Uint8Array(this.buffer,this.byteOffset,this.byteLength)}},{key:"getUint8Array",value:function(e,t){return new Uint8Array(this.buffer,this.byteOffset+e,t)}},{key:"getString",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength,n=this.getUint8Array(e,t);return E(n)}},{key:"getLatin1String",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength,n=this.getUint8Array(e,t);return z(n)}},{key:"getUnicodeString",value:function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength,n=[],r=0;r<t&&e+r<this.byteLength;r+=2)n.push(this.getUint16(e+r));return z(n)}},{key:"getInt8",value:function(e){return this.dataView.getInt8(e)}},{key:"getUint8",value:function(e){return this.dataView.getUint8(e)}},{key:"getInt16",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getInt16(e,t)}},{key:"getInt32",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getInt32(e,t)}},{key:"getUint16",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getUint16(e,t)}},{key:"getUint32",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getUint32(e,t)}},{key:"getFloat32",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat32(e,t)}},{key:"getFloat64",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat64(e,t)}},{key:"getFloat",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat32(e,t)}},{key:"getDouble",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat64(e,t)}},{key:"getUintBytes",value:function(e,t,n){switch(t){case 1:return this.getUint8(e,n);case 2:return this.getUint16(e,n);case 4:return this.getUint32(e,n);case 8:return this.getUint64&&this.getUint64(e,n)}}},{key:"getUint",value:function(e,t,n){switch(t){case 8:return this.getUint8(e,n);case 16:return this.getUint16(e,n);case 32:return this.getUint32(e,n);case 64:return this.getUint64&&this.getUint64(e,n)}}},{key:"toString",value:function(e){return this.dataView.toString(e,this.constructor.name)}},{key:"ensureChunk",value:function(){}}],[{key:"from",value:function(t,n){return t instanceof this&&t.le===n?t:new e(t,void 0,void 0,n)}}]),e}();function R(e,t){L("".concat(e," '").concat(t,"' was not loaded, try using full build of exifr."))}var N=function(e){a(i,e);var n=d(i);function i(e){var r;return t(this,i),(r=n.call(this)).kind=e,r}return r(i,[{key:"get",value:function(e,t){return this.has(e)||R(this.kind,e),t&&(e in t||function(e,t){L("Unknown ".concat(e," '").concat(t,"'."))}(this.kind,e),t[e].enabled||R(this.kind,e)),v(s(i.prototype),"get",this).call(this,e)}},{key:"keyList",value:function(){return m(this.keys())}}]),i}(c(P)),M=new N("file parser"),W=new N("segment parser"),K=new N("file reader");function H(e){return function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];try{return Promise.resolve(e.apply(this,t))}catch(e){return Promise.reject(e)}}}function X(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}var Y=H((function(e){return new Promise((function(t,n){var r=new FileReader;r.onloadend=function(){return t(r.result||new ArrayBuffer)},r.onerror=n,r.readAsArrayBuffer(e)}))})),G=H((function(e){return w(e).then((function(e){return e.arrayBuffer()}))})),J=H((function(e,t){return X(t(e),(function(e){return new D(e)}))})),q=H((function(e,t,n){var r=new(K.get(n))(e,t);return X(r.read(),(function(){return r}))})),Q=H((function(e,t,n,r){return K.has(n)?q(e,t,n):r?J(e,r):(L("Parser ".concat(n," is not loaded")),X())})),Z="Invalid input argument";function $(e,t){return(n=e).startsWith("data:")||n.length>1e4?q(e,t,"base64"):x?Q(e,t,"url",G):B?q(e,t,"fs"):void L(Z);var n}var ee=function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"tagKeys",get:function(){return this.allKeys||(this.allKeys=m(this.keys())),this.allKeys}},{key:"tagValues",get:function(){return this.allValues||(this.allValues=m(this.values())),this.allValues}}]),i}(c(P));function te(e,t,n){var r=new ee,i=n;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++){var s=i[a],u=s[0],o=s[1];r.set(u,o)}if(Array.isArray(t)){var f=t;Array.isArray(f)||("function"==typeof f.entries&&(f=f.entries()),f=m(f));for(var c=0;c<f.length;c++){var h=f[c];e.set(h,r)}}else e.set(t,r);return r}function ne(e,t,n){var r,i=e.get(t),a=n;Array.isArray(a)||("function"==typeof a.entries&&(a=a.entries()),a=m(a));for(var s=0;s<a.length;s++)r=a[s],i.set(r[0],r[1])}var re=S(),ie=S(),ae=S(),se=37500,ue=37510,oe=33723,fe=34675,ce=34665,he=34853,le=40965,de=["chunked","firstChunkSize","firstChunkSizeNode","firstChunkSizeBrowser","chunkSize","chunkLimit"],ve=["jfif","xmp","icc","iptc","ihdr"],pe=["tiff"].concat(ve),ye=["ifd0","ifd1","exif","gps","interop"],ge=[].concat(pe,ye),ke=["makerNote","userComment"],me=["translateKeys","translateValues","reviveValues","multiSegment"],be=[].concat(me,["sanitize","mergeOutput","silentErrors"]),Ae=function(){function e(){t(this,e)}return r(e,[{key:"translate",get:function(){return this.translateKeys||this.translateValues||this.reviveValues}}]),e}(),we=function(e){a(s,e);var n=d(s);function s(e,r,a,u){var o;if(t(this,s),i(h(o=n.call(this)),"enabled",!1),i(h(o),"skip",O()),i(h(o),"pick",O()),i(h(o),"deps",O()),i(h(o),"translateKeys",!1),i(h(o),"translateValues",!1),i(h(o),"reviveValues",!1),o.key=e,o.enabled=r,o.parse=o.enabled,o.applyInheritables(u),o.canBeFiltered=ye.includes(e),o.canBeFiltered&&(o.dict=re.get(e)),void 0!==a)if(Array.isArray(a))o.parse=o.enabled=!0,o.canBeFiltered&&a.length>0&&o.translateTagSet(a,o.pick);else if("object"==typeof a){if(o.enabled=!0,o.parse=!1!==a.parse,o.canBeFiltered){var f=a.pick,c=a.skip;f&&f.length>0&&o.translateTagSet(f,o.pick),c&&c.length>0&&o.translateTagSet(c,o.skip)}o.applyInheritables(a)}else!0===a||!1===a?o.parse=o.enabled=a:L("Invalid options argument: ".concat(a));return o}return r(s,[{key:"needed",get:function(){return this.enabled||this.deps.size>0}},{key:"applyInheritables",value:function(e){var t,n,r=me;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++)void 0!==(n=e[t=r[i]])&&(this[t]=n)}},{key:"translateTagSet",value:function(e,t){if(this.dict){var n,r,i=this.dict,a=i.tagKeys,s=i.tagValues,u=e;Array.isArray(u)||("function"==typeof u.entries&&(u=u.entries()),u=m(u));for(var o=0;o<u.length;o++)"string"==typeof(n=u[o])?(-1===(r=s.indexOf(n))&&(r=a.indexOf(Number(n))),-1!==r&&t.add(Number(a[r]))):t.add(n)}else{var f=e;Array.isArray(f)||("function"==typeof f.entries&&(f=f.entries()),f=m(f));for(var c=0;c<f.length;c++){var h=f[c];t.add(h)}}}},{key:"finalizeFilters",value:function(){!this.enabled&&this.deps.size>0?(this.enabled=!0,Ce(this.pick,this.deps)):this.enabled&&this.pick.size>0&&Ce(this.pick,this.deps)}}]),s}(Ae),Oe={jfif:!1,tiff:!0,xmp:!1,icc:!1,iptc:!1,ifd0:!0,ifd1:!1,exif:!0,gps:!0,interop:!1,ihdr:void 0,makerNote:!1,userComment:!1,multiSegment:!1,skip:[],pick:[],translateKeys:!0,translateValues:!0,reviveValues:!0,sanitize:!0,mergeOutput:!0,silentErrors:!0,chunked:!0,firstChunkSize:void 0,firstChunkSizeNode:512,firstChunkSizeBrowser:65536,chunkSize:65536,chunkLimit:5},Se=S(),Pe=function(e){a(i,e);var n=d(i);function i(e){var r;return t(this,i),r=n.call(this),!0===e?r.setupFromTrue():void 0===e?r.setupFromUndefined():Array.isArray(e)?r.setupFromArray(e):"object"==typeof e?r.setupFromObject(e):L("Invalid options argument ".concat(e)),void 0===r.firstChunkSize&&(r.firstChunkSize=x?r.firstChunkSizeBrowser:r.firstChunkSizeNode),r.mergeOutput&&(r.ifd1.enabled=!1),r.filterNestedSegmentTags(),r.traverseTiffDependencyTree(),r.checkLoadedPlugins(),r}return r(i,[{key:"setupFromUndefined",value:function(){var e,t=de;Array.isArray(t)||("function"==typeof t.entries&&(t=t.entries()),t=m(t));for(var n=0;n<t.length;n++)this[e=t[n]]=Oe[e];var r=be;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++)this[e=r[i]]=Oe[e];var a=ke;Array.isArray(a)||("function"==typeof a.entries&&(a=a.entries()),a=m(a));for(var s=0;s<a.length;s++)this[e=a[s]]=Oe[e];var u=ge;Array.isArray(u)||("function"==typeof u.entries&&(u=u.entries()),u=m(u));for(var o=0;o<u.length;o++)this[e=u[o]]=new we(e,Oe[e],void 0,this)}},{key:"setupFromTrue",value:function(){var e,t=de;Array.isArray(t)||("function"==typeof t.entries&&(t=t.entries()),t=m(t));for(var n=0;n<t.length;n++)this[e=t[n]]=Oe[e];var r=be;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++)this[e=r[i]]=Oe[e];var a=ke;Array.isArray(a)||("function"==typeof a.entries&&(a=a.entries()),a=m(a));for(var s=0;s<a.length;s++)this[e=a[s]]=!0;var u=ge;Array.isArray(u)||("function"==typeof u.entries&&(u=u.entries()),u=m(u));for(var o=0;o<u.length;o++)this[e=u[o]]=new we(e,!0,void 0,this)}},{key:"setupFromArray",value:function(e){var t,n=de;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++)this[t=n[r]]=Oe[t];var i=be;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++)this[t=i[a]]=Oe[t];var s=ke;Array.isArray(s)||("function"==typeof s.entries&&(s=s.entries()),s=m(s));for(var u=0;u<s.length;u++)this[t=s[u]]=Oe[t];var o=ge;Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++)this[t=o[f]]=new we(t,!1,void 0,this);this.setupGlobalFilters(e,void 0,ye)}},{key:"setupFromObject",value:function(e){var t;ye.ifd0=ye.ifd0||ye.image,ye.ifd1=ye.ifd1||ye.thumbnail,g(this,e);var n=de;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++)this[t=n[r]]=xe(e[t],Oe[t]);var i=be;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++)this[t=i[a]]=xe(e[t],Oe[t]);var s=ke;Array.isArray(s)||("function"==typeof s.entries&&(s=s.entries()),s=m(s));for(var u=0;u<s.length;u++)this[t=s[u]]=xe(e[t],Oe[t]);var o=pe;Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++)this[t=o[f]]=new we(t,Oe[t],e[t],this);var c=ye;Array.isArray(c)||("function"==typeof c.entries&&(c=c.entries()),c=m(c));for(var h=0;h<c.length;h++)this[t=c[h]]=new we(t,Oe[t],e[t],this.tiff);this.setupGlobalFilters(e.pick,e.skip,ye,ge),!0===e.tiff?this.batchEnableWithBool(ye,!0):!1===e.tiff?this.batchEnableWithUserValue(ye,e):Array.isArray(e.tiff)?this.setupGlobalFilters(e.tiff,void 0,ye):"object"==typeof e.tiff&&this.setupGlobalFilters(e.tiff.pick,e.tiff.skip,ye)}},{key:"batchEnableWithBool",value:function(e,t){var n=e;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){this[n[r]].enabled=t}}},{key:"batchEnableWithUserValue",value:function(e,t){var n=e;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r],a=t[i];this[i].enabled=!1!==a&&void 0!==a}}},{key:"setupGlobalFilters",value:function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n;if(e&&e.length){var i=r;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++){var s=i[a];this[s].enabled=!1}var u=Ue(e,n),o=u;Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++){var c=o[f],h=c[0],l=c[1];Ce(this[h].pick,l),this[h].enabled=!0}}else if(t&&t.length){var d=Ue(t,n),v=d;Array.isArray(v)||("function"==typeof v.entries&&(v=v.entries()),v=m(v));for(var p=0;p<v.length;p++){var y=v[p],g=y[0],k=y[1];Ce(this[g].skip,k)}}}},{key:"filterNestedSegmentTags",value:function(){var e=this.ifd0,t=this.exif,n=this.xmp,r=this.iptc,i=this.icc;this.makerNote?t.deps.add(se):t.skip.add(se),this.userComment?t.deps.add(ue):t.skip.add(ue),n.enabled||e.skip.add(700),r.enabled||e.skip.add(oe),i.enabled||e.skip.add(fe)}},{key:"traverseTiffDependencyTree",value:function(){var e=this,t=this.ifd0,n=this.exif,r=this.gps;this.interop.needed&&(n.deps.add(le),t.deps.add(le)),n.needed&&t.deps.add(ce),r.needed&&t.deps.add(he),this.tiff.enabled=ye.some((function(t){return!0===e[t].enabled}))||this.makerNote||this.userComment;var i=ye;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++){this[i[a]].finalizeFilters()}}},{key:"onlyTiff",get:function(){var e=this;return!ve.map((function(t){return e[t].enabled})).some((function(e){return!0===e}))&&this.tiff.enabled}},{key:"checkLoadedPlugins",value:function(){var e=pe;Array.isArray(e)||("function"==typeof e.entries&&(e=e.entries()),e=m(e));for(var t=0;t<e.length;t++){var n=e[t];this[n].enabled&&!W.has(n)&&R("segment parser",n)}}}],[{key:"useCached",value:function(e){var t=Se.get(e);return void 0!==t||(t=new this(e),Se.set(e,t)),t}}]),i}(Ae);function Ue(e,t){var n,r,i,a=[],s=t;Array.isArray(s)||("function"==typeof s.entries&&(s=s.entries()),s=m(s));for(var u=0;u<s.length;u++){r=s[u],n=[];var o=re.get(r);Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++)i=o[f],(e.includes(i[0])||e.includes(i[1]))&&n.push(i[0]);n.length&&a.push([r,n])}return a}function xe(e,t){return void 0!==e?e:void 0!==t?t:void 0}function Ce(e,t){var n=t;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r];e.add(i)}}function Be(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}function je(){}function _e(e,t){if(!t)return e&&e.then?e.then(je):Promise.resolve()}function Ve(e,t){var n=e();return n&&n.then?n.then(t):t(n)}i(Pe,"default",Oe);var Ie=function(){function e(n){t(this,e),i(this,"parsers",{}),this.options=Pe.useCached(n)}return r(e,[{key:"setup",value:function(){if(!this.fileParser){var e=this.file,t=e.getUint16(0),n=M;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r],a=i[0],s=i[1];if(s.canHandle(e,t))return this.fileParser=new s(this.options,this.file,this.parsers),e[a]=!0}L("Unknown file format")}}},{key:"read",value:function(e){try{var t=this;return Be(function(e,t){return"string"==typeof e?$(e,t):x&&!C&&e instanceof HTMLImageElement?$(e.src,t):e instanceof Uint8Array||e instanceof ArrayBuffer||e instanceof DataView?new D(e):x&&e instanceof Blob?Q(e,t,"blob",Y):void L(Z)}(e,t.options),(function(e){t.file=e}))}catch(e){return Promise.reject(e)}}},{key:"parse",value:function(){try{var e=this;e.setup();var t={},n=[];return Ve((function(){return e.options.silentErrors?Be(e.doParse(t,n).catch((function(e){return n.push(e)})),(function(){n.push.apply(n,e.fileParser.errors)})):_e(e.doParse(t,n))}),(function(){return e.file.close&&e.file.close(),e.options.silentErrors&&n.length>0&&(t.errors=n),I(r=t)?void 0:r;var r}))}catch(e){return Promise.reject(e)}}},{key:"doParse",value:function(e,t){try{var n=this;return Be(n.fileParser.parse(),(function(){var r,i=p(n.parsers).map((r=function(t){return Be(t.parse(),(function(n){t.assignToOutput(e,n)}))},function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];try{return Promise.resolve(r.apply(this,e))}catch(e){return Promise.reject(e)}}));if(n.options.silentErrors){var a=function(e){return t.push(e)};i=i.map((function(e){return e.catch(a)}))}return _e(Promise.all(i))}))}catch(e){return Promise.reject(e)}}},{key:"extractThumbnail",value:function(){try{var e=this;e.setup();var t,n=e.options,r=e.file,i=W.get("tiff",n);return Ve((function(){if(!r.tiff)return function(e){var t=e();if(t&&t.then)return t.then(je)}((function(){if(r.jpeg)return Be(e.fileParser.getOrFindSegment("tiff"),(function(e){t=e}))}));t={start:0,type:"tiff"}}),(function(){if(void 0!==t)return Be(e.fileParser.ensureSegmentChunk(t),(function(t){return Be((e.parsers.tiff=new i(t,n,r)).extractThumbnail(),(function(e){return r.close&&r.close(),e}))}))}))}catch(e){return Promise.reject(e)}}}]),e}();var Le,Te=(Le=function(e,t){var n,r,i,a=new Ie(t);return n=a.read(e),r=function(){return a.parse()},i?r?r(n):n:(n&&n.then||(n=Promise.resolve(n)),r?n.then(r):n)},function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];try{return Promise.resolve(Le.apply(this,e))}catch(e){return Promise.reject(e)}}),ze=Object.freeze({__proto__:null,parse:Te,Exifr:Ie,fileParsers:M,segmentParsers:W,fileReaders:K,tagKeys:re,tagValues:ie,tagRevivers:ae,createDictionary:te,extendDictionary:ne,fetchUrlAsArrayBuffer:G,readBlobAsArrayBuffer:Y,chunkedProps:de,otherSegments:ve,segments:pe,tiffBlocks:ye,segmentsAndBlocks:ge,tiffExtractables:ke,inheritables:me,allFormatters:be,Options:Pe});function Fe(){}var Ee=function(){function e(n,r,a){var s=this;t(this,e),i(this,"errors",[]),i(this,"ensureSegmentChunk",function(e){return function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];try{return Promise.resolve(e.apply(this,t))}catch(e){return Promise.reject(e)}}}((function(e){var t,n,r,i=e.start,a=e.size||65536;return t=function(){if(s.file.chunked)return function(e){var t=e();if(t&&t.then)return t.then(Fe)}((function(){if(!s.file.available(i,a))return function(e){if(e&&e.then)return e.then(Fe)}(function(e,t){try{var n=e()}catch(e){return t(e)}return n&&n.then?n.then(void 0,t):n}((function(){return t=s.file.readChunk(i,a),n=function(t){e.chunk=t},r?n?n(t):t:(t&&t.then||(t=Promise.resolve(t)),n?t.then(n):t);var t,n,r}),(function(t){L("Couldn't read segment: ".concat(JSON.stringify(e),". ").concat(t.message))})));e.chunk=s.file.subarray(i,a)}));s.file.byteLength>i+a?e.chunk=s.file.subarray(i,a):void 0===e.size?e.chunk=s.file.subarray(i):L("Segment unreachable: "+JSON.stringify(e))},n=function(){return e.chunk},(r=t())&&r.then?r.then(n):n(r)}))),this.extendOptions&&this.extendOptions(n),this.options=n,this.file=r,this.parsers=a}return r(e,[{key:"injectSegment",value:function(e,t){this.options[e].enabled&&this.createParser(e,t)}},{key:"createParser",value:function(e,t){var n=new(W.get(e))(t,this.options,this.file);return this.parsers[e]=n}},{key:"createParsers",value:function(e){var t=e;Array.isArray(t)||("function"==typeof t.entries&&(t=t.entries()),t=m(t));for(var n=0;n<t.length;n++){var r=t[n],i=r.type,a=r.chunk,s=this.options[i];if(s&&s.enabled){var u=this.parsers[i];u&&u.append||u||this.createParser(i,a)}}}},{key:"readSegments",value:function(e){try{var t=e.map(this.ensureSegmentChunk);return function(e,t){if(!t)return e&&e.then?e.then(Fe):Promise.resolve()}(Promise.all(t))}catch(e){return Promise.reject(e)}}}]),e}(),De=function(){function e(n){var r=this,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},s=arguments.length>2?arguments[2]:void 0;t(this,e),i(this,"errors",[]),i(this,"raw",S()),i(this,"handleError",(function(e){if(!r.options.silentErrors)throw e;r.errors.push(e.message)})),this.chunk=this.normalizeInput(n),this.file=s,this.type=this.constructor.type,this.globalOptions=this.options=a,this.localOptions=a[this.type],this.canTranslate=this.localOptions&&this.localOptions.translate}return r(e,[{key:"normalizeInput",value:function(e){return e instanceof D?e:new D(e)}},{key:"translate",value:function(){this.canTranslate&&(this.translated=this.translateBlock(this.raw,this.type))}},{key:"output",get:function(){return this.translated?this.translated:this.raw?k(this.raw):void 0}},{key:"translateBlock",value:function(e,t){var n=ae.get(t),r=ie.get(t),i=re.get(t),a=this.options[t],s=a.reviveValues&&!!n,u=a.translateValues&&!!r,o=a.translateKeys&&!!i,f={},c=e;Array.isArray(c)||("function"==typeof c.entries&&(c=c.entries()),c=m(c));for(var h=0;h<c.length;h++){var l=c[h],d=l[0],v=l[1];s&&n.has(d)?v=n.get(d)(v):u&&r.has(d)&&(v=this.translateValue(v,r.get(d))),o&&i.has(d)&&(d=i.get(d)||d),f[d]=v}return f}},{key:"translateValue",value:function(e,t){return t[e]||t.DEFAULT||e}},{key:"assignToOutput",value:function(e,t){this.assignObjectToOutput(e,this.constructor.type,t)}},{key:"assignObjectToOutput",value:function(e,t,n){if(this.globalOptions.mergeOutput)return g(e,n);e[t]?g(e[t],n):e[t]=n}}],[{key:"findPosition",value:function(e,t){var n=e.getUint16(t+2)+2,r="function"==typeof this.headerLength?this.headerLength(e,t,n):this.headerLength,i=t+r,a=n-r;return{offset:t,length:n,headerLength:r,start:i,size:a,end:i+a}}},{key:"parse",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=new Pe(i({},this.type,t)),r=new this(e,n);return r.parse()}}]),e}();function Re(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}i(De,"headerLength",4),i(De,"type",void 0),i(De,"multiSegment",!1),i(De,"canHandle",(function(){return!1}));function Ne(){}function Me(e,t){if(!t)return e&&e.then?e.then(Ne):Promise.resolve()}function We(e){var t=e();if(t&&t.then)return t.then(Ne)}function Ke(e,t){var n=e();return n&&n.then?n.then(t):t(n)}function He(e,t,n){if(!e.s){if(n instanceof Xe){if(!n.s)return void(n.o=He.bind(null,e,t));1&t&&(t=n.s),n=n.v}if(n&&n.then)return void n.then(He.bind(null,e,t),He.bind(null,e,2));e.s=t,e.v=n;var r=e.o;r&&r(e)}}var Xe=function(){function e(){}return e.prototype.then=function(t,n){var r=new e,i=this.s;if(i){var a=1&i?t:n;if(a){try{He(r,1,a(this.v))}catch(e){He(r,2,e)}return r}return this}return this.o=function(e){try{var i=e.v;1&e.s?He(r,1,t?t(i):i):n?He(r,1,n(i)):He(r,2,i)}catch(e){He(r,2,e)}},r},e}();function Ye(e){return e instanceof Xe&&1&e.s}function Ge(e,t,n){for(var r;;){var i=e();if(Ye(i)&&(i=i.v),!i)return a;if(i.then){r=0;break}var a=n();if(a&&a.then){if(!Ye(a)){r=1;break}a=a.s}if(t){var s=t();if(s&&s.then&&!Ye(s)){r=2;break}}}var u=new Xe,o=He.bind(null,u,2);return(0===r?i.then(c):1===r?a.then(f):s.then(h)).then(void 0,o),u;function f(r){a=r;do{if(t&&(s=t())&&s.then&&!Ye(s))return void s.then(h).then(void 0,o);if(!(i=e())||Ye(i)&&!i.v)return void He(u,1,a);if(i.then)return void i.then(c).then(void 0,o);Ye(a=n())&&(a=a.v)}while(!a||!a.then);a.then(f).then(void 0,o)}function c(e){e?(a=n())&&a.then?a.then(f).then(void 0,o):f(a):He(u,1,a)}function h(){(i=e())?i.then?i.then(c).then(void 0,o):c(i):He(u,1,a)}}function Je(e){return 192===e||194===e||196===e||219===e||221===e||218===e||254===e}function qe(e){return e>=224&&e<=239}function Qe(e,t,n){var r=W;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++){var a=r[i],s=a[0];if(a[1].canHandle(e,t,n))return s}}var Ze=function(e){a(s,e);var n=d(s);function s(){var e;t(this,s);for(var r=arguments.length,a=new Array(r),u=0;u<r;u++)a[u]=arguments[u];return i(h(e=n.call.apply(n,[this].concat(a))),"appSegments",[]),i(h(e),"jpegSegments",[]),i(h(e),"unknownSegments",[]),e}return r(s,[{key:"parse",value:function(){try{var e=this;return Re(e.findAppSegments(),(function(){return Re(e.readSegments(e.appSegments),(function(){e.mergeMultiSegments(),e.createParsers(e.mergedAppSegments||e.appSegments)}))}))}catch(e){return Promise.reject(e)}}},{key:"setupSegmentFinderArgs",value:function(e){var t=this;!0===e?(this.findAll=!0,this.wanted=O(W.keyList())):(e=void 0===e?W.keyList().filter((function(e){return t.options[e].enabled})):e.filter((function(e){return t.options[e].enabled&&W.has(e)})),this.findAll=!1,this.remaining=O(e),this.wanted=O(e)),this.unfinishedMultiSegment=!1}},{key:"findAppSegments",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1?arguments[1]:void 0;try{var n=this;n.setupSegmentFinderArgs(t);var r=n.file,i=n.findAll,a=n.wanted,s=n.remaining;return Ke((function(){if(!i&&n.file.chunked)return i=m(a).some((function(e){var t=W.get(e),r=n.options[e];return t.multiSegment&&r.multiSegment})),We((function(){if(i)return Me(n.file.readWhole())}))}),(function(){var t=!1;if(e=n.findAppSegmentsInRange(e,r.byteLength),!n.options.onlyTiff)return function(){if(r.chunked){var i=!1;return Ge((function(){return!t&&s.size>0&&!i&&(!!r.canReadNextChunk||!!n.unfinishedMultiSegment)}),void 0,(function(){var a=r.nextChunkOffset,s=n.appSegments.some((function(e){return!n.file.available(e.offset||e.start,e.length||e.size)}));return Ke((function(){return e>a&&!s?Re(r.readNextChunk(e),(function(e){i=!e})):Re(r.readNextChunk(a),(function(e){i=!e}))}),(function(){void 0===(e=n.findAppSegmentsInRange(e,r.byteLength))&&(t=!0)}))}))}}()}))}catch(e){return Promise.reject(e)}}},{key:"findAppSegmentsInRange",value:function(e,t){t-=2;for(var n,r,i,a,s,u,o=this.file,f=this.findAll,c=this.wanted,h=this.remaining,l=this.options;e<t;e++)if(255===o.getUint8(e))if(qe(n=o.getUint8(e+1))){if(r=o.getUint16(e+2),(i=Qe(o,e,r))&&c.has(i)&&(s=(a=W.get(i)).findPosition(o,e),u=l[i],s.type=i,this.appSegments.push(s),!f&&(a.multiSegment&&u.multiSegment?(this.unfinishedMultiSegment=s.chunkNumber<s.chunkCount,this.unfinishedMultiSegment||h.delete(i)):h.delete(i),0===h.size)))break;l.recordUnknownSegments&&((s=De.findPosition(o,e)).marker=n,this.unknownSegments.push(s)),e+=r+1}else if(Je(n)){if(r=o.getUint16(e+2),218===n&&!1!==l.stopAfterSos)return;l.recordJpegSegments&&this.jpegSegments.push({offset:e,length:r,marker:n}),e+=r+1}return e}},{key:"mergeMultiSegments",value:function(){var e=this;if(this.appSegments.some((function(e){return e.multiSegment}))){var t=function(e,t){for(var n,r,i,a=S(),s=0;s<e.length;s++)r=(n=e[s])[t],a.has(r)?i=a.get(r):a.set(r,i=[]),i.push(n);return m(a)}(this.appSegments,"type");this.mergedAppSegments=t.map((function(t){var n=t[0],r=t[1],i=W.get(n,e.options);return i.handleMultiSegments?{type:n,chunk:i.handleMultiSegments(r)}:r[0]}))}}},{key:"getSegment",value:function(e){return this.appSegments.find((function(t){return t.type===e}))}},{key:"getOrFindSegment",value:function(e){try{var t=this,n=t.getSegment(e);return Ke((function(){if(void 0===n)return Re(t.findAppSegments(0,[e]),(function(){n=t.getSegment(e)}))}),(function(){return n}))}catch(e){return Promise.reject(e)}}}],[{key:"canHandle",value:function(e,t){return 65496===t}}]),s}(Ee);function $e(){}i(Ze,"type","jpeg"),M.set("jpeg",Ze);function et(e,t){if(!t)return e&&e.then?e.then($e):Promise.resolve()}function tt(e,t){var n=e();return n&&n.then?n.then(t):t(n)}var nt=[void 0,1,1,2,4,8,1,1,2,4,8,4,8,4];var rt=function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"parse",value:function(){try{var e=this;e.parseHeader();var t=e.options;return tt((function(){if(t.ifd0.enabled)return et(e.parseIfd0Block())}),(function(){return tt((function(){if(t.exif.enabled)return et(e.safeParse("parseExifBlock"))}),(function(){return tt((function(){if(t.gps.enabled)return et(e.safeParse("parseGpsBlock"))}),(function(){return tt((function(){if(t.interop.enabled)return et(e.safeParse("parseInteropBlock"))}),(function(){return tt((function(){if(t.ifd1.enabled)return et(e.safeParse("parseThumbnailBlock"))}),(function(){return e.createOutput()}))}))}))}))}))}catch(e){return Promise.reject(e)}}},{key:"safeParse",value:function(e){var t=this[e]();return void 0!==t.catch&&(t=t.catch(this.handleError)),t}},{key:"findIfd0Offset",value:function(){void 0===this.ifd0Offset&&(this.ifd0Offset=this.chunk.getUint32(4))}},{key:"findIfd1Offset",value:function(){if(void 0===this.ifd1Offset){this.findIfd0Offset();var e=this.chunk.getUint16(this.ifd0Offset),t=this.ifd0Offset+2+12*e;this.ifd1Offset=this.chunk.getUint32(t)}}},{key:"parseBlock",value:function(e,t){var n=S();return this[t]=n,this.parseTags(e,t,n),n}},{key:"parseIfd0Block",value:function(){try{var e=this;if(e.ifd0)return;var t=e.file;return e.findIfd0Offset(),e.ifd0Offset<8&&L("Malformed EXIF data"),!t.chunked&&e.ifd0Offset>t.byteLength&&L("IFD0 offset points to outside of file.\nthis.ifd0Offset: ".concat(e.ifd0Offset,", file.byteLength: ").concat(t.byteLength)),tt((function(){if(t.tiff)return et(t.ensureChunk(e.ifd0Offset,T(e.options)))}),(function(){var t=e.parseBlock(e.ifd0Offset,"ifd0");if(0!==t.size)return e.exifOffset=t.get(ce),e.interopOffset=t.get(le),e.gpsOffset=t.get(he),e.xmp=t.get(700),e.iptc=t.get(oe),e.icc=t.get(fe),e.options.sanitize&&(t.delete(ce),t.delete(le),t.delete(he),t.delete(700),t.delete(oe),t.delete(fe)),t}))}catch(e){return Promise.reject(e)}}},{key:"parseExifBlock",value:function(){try{var e=this;if(e.exif)return;return tt((function(){if(!e.ifd0)return et(e.parseIfd0Block())}),(function(){if(void 0!==e.exifOffset)return tt((function(){if(e.file.tiff)return et(e.file.ensureChunk(e.exifOffset,T(e.options)))}),(function(){var t=e.parseBlock(e.exifOffset,"exif");return e.interopOffset||(e.interopOffset=t.get(le)),e.makerNote=t.get(se),e.userComment=t.get(ue),e.options.sanitize&&(t.delete(le),t.delete(se),t.delete(ue)),e.unpack(t,41728),e.unpack(t,41729),t}))}))}catch(e){return Promise.reject(e)}}},{key:"unpack",value:function(e,t){var n=e.get(t);n&&1===n.length&&e.set(t,n[0])}},{key:"parseGpsBlock",value:function(){try{var e=this;if(e.gps)return;return tt((function(){if(!e.ifd0)return et(e.parseIfd0Block())}),(function(){if(void 0!==e.gpsOffset){var t=e.parseBlock(e.gpsOffset,"gps");return t&&t.has(2)&&t.has(4)&&(t.set("latitude",it.apply(void 0,t.get(2).concat([t.get(1)]))),t.set("longitude",it.apply(void 0,t.get(4).concat([t.get(3)])))),t}}))}catch(e){return Promise.reject(e)}}},{key:"parseInteropBlock",value:function(){try{var e=this;if(e.interop)return;return tt((function(){if(!e.ifd0)return et(e.parseIfd0Block())}),(function(){return tt((function(){if(void 0===e.interopOffset&&!e.exif)return et(e.parseExifBlock())}),(function(){if(void 0!==e.interopOffset)return e.parseBlock(e.interopOffset,"interop")}))}))}catch(e){return Promise.reject(e)}}},{key:"parseThumbnailBlock",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];try{var t=this;if(t.ifd1||t.ifd1Parsed)return;if(t.options.mergeOutput&&!e)return;return t.findIfd1Offset(),t.ifd1Offset>0&&(t.parseBlock(t.ifd1Offset,"ifd1"),t.ifd1Parsed=!0),t.ifd1}catch(e){return Promise.reject(e)}}},{key:"extractThumbnail",value:function(){try{var e=this;return e.headerParsed||e.parseHeader(),tt((function(){if(!e.ifd1Parsed)return et(e.parseThumbnailBlock(!0))}),(function(){if(void 0!==e.ifd1){var t=e.ifd1.get(513),n=e.ifd1.get(514);return e.chunk.getUint8Array(t,n)}}))}catch(e){return Promise.reject(e)}}},{key:"image",get:function(){return this.ifd0}},{key:"thumbnail",get:function(){return this.ifd1}},{key:"createOutput",value:function(){var e,t,n,r={},i=ye;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++)if(!I(e=this[t=i[a]]))if(n=this.canTranslate?this.translateBlock(e,t):k(e),this.options.mergeOutput){if("ifd1"===t)continue;g(r,n)}else r[t]=n;return this.makerNote&&(r.makerNote=this.makerNote),this.userComment&&(r.userComment=this.userComment),r}},{key:"assignToOutput",value:function(e,t){if(this.globalOptions.mergeOutput)g(e,t);else{var n=y(t);Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r],a=i[0],s=i[1];this.assignObjectToOutput(e,a,s)}}}}],[{key:"canHandle",value:function(e,t){return 225===e.getUint8(t+1)&&1165519206===e.getUint32(t+4)&&0===e.getUint16(t+8)}}]),i}(function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"parseHeader",value:function(){var e=this.chunk.getUint16();18761===e?this.le=!0:19789===e&&(this.le=!1),this.chunk.le=this.le,this.headerParsed=!0}},{key:"parseTags",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:S(),r=this.options[t],i=r.pick,a=r.skip,s=(i=O(i)).size>0,u=0===a.size,o=this.chunk.getUint16(e);e+=2;for(var f=0;f<o;f++){var c=this.chunk.getUint16(e);if(s){if(i.has(c)&&(n.set(c,this.parseTag(e,c,t)),i.delete(c),0===i.size))break}else!u&&a.has(c)||n.set(c,this.parseTag(e,c,t));e+=12}return n}},{key:"parseTag",value:function(e,t,n){var r,i=this.chunk,a=i.getUint16(e+2),s=i.getUint32(e+4),u=nt[a];if(u*s<=4?e+=8:e=i.getUint32(e+8),(a<1||a>13)&&L("Invalid TIFF value type. block: ".concat(n.toUpperCase(),", tag: ").concat(t.toString(16),", type: ").concat(a,", offset ").concat(e)),e>i.byteLength&&L("Invalid TIFF value offset. block: ".concat(n.toUpperCase(),", tag: ").concat(t.toString(16),", type: ").concat(a,", offset ").concat(e," is outside of chunk size ").concat(i.byteLength)),1===a)return i.getUint8Array(e,s);if(2===a)return""===(r=function(e){for(;e.endsWith("\0");)e=e.slice(0,-1);return e}(r=i.getString(e,s)).trim())?void 0:r;if(7===a)return i.getUint8Array(e,s);if(1===s)return this.parseTagValue(a,e);for(var o=new(function(e){switch(e){case 1:return Uint8Array;case 3:return Uint16Array;case 4:return Uint32Array;case 5:return Array;case 6:return Int8Array;case 8:return Int16Array;case 9:return Int32Array;case 10:return Array;case 11:return Float32Array;case 12:return Float64Array;default:return Array}}(a))(s),f=u,c=0;c<s;c++)o[c]=this.parseTagValue(a,e),e+=f;return o}},{key:"parseTagValue",value:function(e,t){var n=this.chunk;switch(e){case 1:return n.getUint8(t);case 3:return n.getUint16(t);case 4:return n.getUint32(t);case 5:return n.getUint32(t)/n.getUint32(t+4);case 6:return n.getInt8(t);case 8:return n.getInt16(t);case 9:return n.getInt32(t);case 10:return n.getInt32(t)/n.getInt32(t+4);case 11:return n.getFloat(t);case 12:return n.getDouble(t);case 13:return n.getUint32(t);default:L("Invalid tiff type ".concat(e))}}}]),i}(De));function it(e,t,n,r){var i=e+t/60+n/3600;return"S"!==r&&"W"!==r||(i*=-1),i}i(rt,"type","tiff"),i(rt,"headerLength",10),W.set("tiff",rt);var at=Object.freeze({__proto__:null,default:ze,Exifr:Ie,fileParsers:M,segmentParsers:W,fileReaders:K,tagKeys:re,tagValues:ie,tagRevivers:ae,createDictionary:te,extendDictionary:ne,fetchUrlAsArrayBuffer:G,readBlobAsArrayBuffer:Y,chunkedProps:de,otherSegments:ve,segments:pe,tiffBlocks:ye,segmentsAndBlocks:ge,tiffExtractables:ke,inheritables:me,allFormatters:be,Options:Pe,parse:Te});function st(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}function ut(e){return function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];try{return Promise.resolve(e.apply(this,t))}catch(e){return Promise.reject(e)}}}var ot=ut((function(e){var t=new Ie(vt);return st(t.read(e),(function(){return st(t.parse(),(function(e){if(e&&e.ifd0)return e.ifd0[274]}))}))})),ft=ut((function(e){var t=new Ie(dt);return st(t.read(e),(function(){return st(t.parse(),(function(e){if(e&&e.gps){var t=e.gps;return{latitude:t.latitude,longitude:t.longitude}}}))}))})),ct=ut((function(e){return st(this.thumbnail(e),(function(e){if(void 0!==e){var t=new Blob([e]);return URL.createObjectURL(t)}}))})),ht=ut((function(e){var t=new Ie(pt);return st(t.read(e),(function(){return st(t.extractThumbnail(),(function(e){return e&&_?j.from(e):e}))}))})),lt={ifd0:!1,ifd1:!1,exif:!1,gps:!1,interop:!1,sanitize:!1,reviveValues:!0,translateKeys:!1,translateValues:!1,mergeOutput:!1},dt=g({},lt,{firstChunkSize:4e4,gps:[1,2,3,4]}),vt=g({},lt,{firstChunkSize:4e4,ifd0:[274]}),pt=g({},lt,{tiff:!1,ifd1:!0,mergeOutput:!1}),yt=Object.freeze({1:{dimensionSwapped:!1,scaleX:1,scaleY:1,deg:0,rad:0},2:{dimensionSwapped:!1,scaleX:-1,scaleY:1,deg:0,rad:0},3:{dimensionSwapped:!1,scaleX:1,scaleY:1,deg:180,rad:180*Math.PI/180},4:{dimensionSwapped:!1,scaleX:-1,scaleY:1,deg:180,rad:180*Math.PI/180},5:{dimensionSwapped:!0,scaleX:1,scaleY:-1,deg:90,rad:90*Math.PI/180},6:{dimensionSwapped:!0,scaleX:1,scaleY:1,deg:90,rad:90*Math.PI/180},7:{dimensionSwapped:!0,scaleX:1,scaleY:-1,deg:270,rad:270*Math.PI/180},8:{dimensionSwapped:!0,scaleX:1,scaleY:1,deg:270,rad:270*Math.PI/180}});if(e.rotateCanvas=!0,e.rotateCss=!0,"object"==typeof navigator){var gt=navigator.userAgent;if(gt.includes("iPad")||gt.includes("iPhone")){var kt=gt.match(/OS (\d+)_(\d+)/);if(kt){var mt=kt[1],bt=kt[2],At=Number(mt)+.1*Number(bt);e.rotateCanvas=At<13.4,e.rotateCss=!1}}else if(gt.includes("OS X 10")){var wt=gt.match(/OS X 10[_.](\d+)/)[1];e.rotateCanvas=e.rotateCss=Number(wt)<15}if(gt.includes("Chrome/")){var Ot=gt.match(/Chrome\/(\d+)/)[1];e.rotateCanvas=e.rotateCss=Number(Ot)<81}else if(gt.includes("Firefox/")){var St=gt.match(/Firefox\/(\d+)/)[1];e.rotateCanvas=e.rotateCss=Number(St)<77}}function Pt(){}var Ut=function(e){a(u,e);var n=d(u);function u(){var e;t(this,u);for(var r=arguments.length,a=new Array(r),s=0;s<r;s++)a[s]=arguments[s];return i(h(e=n.call.apply(n,[this].concat(a))),"ranges",new xt),0!==e.byteLength&&e.ranges.add(0,e.byteLength),e}return r(u,[{key:"_tryExtend",value:function(e,t,n){if(0===e&&0===this.byteLength&&n){var r=new DataView(n.buffer||n,n.byteOffset,n.byteLength);this._swapDataView(r)}else{var i=e+t;if(i>this.byteLength){var a=this._extend(i).dataView;this._swapDataView(a)}}}},{key:"_extend",value:function(e){var t;t=_?j.allocUnsafe(e):new Uint8Array(e);var n=new DataView(t.buffer,t.byteOffset,t.byteLength);return t.set(new Uint8Array(this.buffer,this.byteOffset,this.byteLength),0),{uintView:t,dataView:n}}},{key:"subarray",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return t=t||this._lengthToEnd(e),n&&this._tryExtend(e,t),this.ranges.add(e,t),v(s(u.prototype),"subarray",this).call(this,e,t)}},{key:"set",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];n&&this._tryExtend(t,e.byteLength,e);var r=v(s(u.prototype),"set",this).call(this,e,t);return this.ranges.add(t,r.byteLength),r}},{key:"ensureChunk",value:function(e,t){try{var n=this;if(!n.chunked)return;if(n.ranges.available(e,t))return;return function(e,t){if(!t)return e&&e.then?e.then(Pt):Promise.resolve()}(n.readChunk(e,t))}catch(e){return Promise.reject(e)}}},{key:"available",value:function(e,t){return this.ranges.available(e,t)}}]),u}(D),xt=function(){function e(){t(this,e),i(this,"list",[])}return r(e,[{key:"length",get:function(){return this.list.length}},{key:"add",value:function(e,t){var n=e+t,r=this.list.filter((function(t){return Ct(e,t.offset,n)||Ct(e,t.end,n)}));if(r.length>0){e=Math.min.apply(Math,[e].concat(r.map((function(e){return e.offset})))),t=(n=Math.max.apply(Math,[n].concat(r.map((function(e){return e.end})))))-e;var i=r.shift();i.offset=e,i.length=t,i.end=n,this.list=this.list.filter((function(e){return!r.includes(e)}))}else this.list.push({offset:e,length:t,end:n})}},{key:"available",value:function(e,t){var n=e+t;return this.list.some((function(t){return t.offset<=e&&n<=t.end}))}}]),e}();function Ct(e,t,n){return e<=t&&t<=n}function Bt(){}function jt(e,t){if(!t)return e&&e.then?e.then(Bt):Promise.resolve()}function _t(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}var Vt=function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"readWhole",value:function(){try{var e=this;return e.chunked=!1,_t(Y(e.input),(function(t){e._swapArrayBuffer(t)}))}catch(e){return Promise.reject(e)}}},{key:"readChunked",value:function(){return this.chunked=!0,this.size=this.input.size,v(s(i.prototype),"readChunked",this).call(this)}},{key:"_readChunk",value:function(e,t){try{var n=this,r=t?e+t:void 0,i=n.input.slice(e,r);return _t(Y(i),(function(t){return n.set(t,e,!0)}))}catch(e){return Promise.reject(e)}}}]),i}(function(e){a(s,e);var n=d(s);function s(e,r){var a;return t(this,s),i(h(a=n.call(this,0)),"chunksRead",0),a.input=e,a.options=r,a}return r(s,[{key:"readWhole",value:function(){try{var e=this;return e.chunked=!1,jt(e.readChunk(e.nextChunkOffset))}catch(e){return Promise.reject(e)}}},{key:"readChunked",value:function(){try{var e=this;return e.chunked=!0,jt(e.readChunk(0,e.options.firstChunkSize))}catch(e){return Promise.reject(e)}}},{key:"readNextChunk",value:function(e){try{var t=this;if(void 0===e&&(e=t.nextChunkOffset),t.fullyRead)return t.chunksRead++,!1;var n=t.options.chunkSize;return r=t.readChunk(e,n),i=function(e){return!!e&&e.byteLength===n},a?i?i(r):r:(r&&r.then||(r=Promise.resolve(r)),i?r.then(i):r)}catch(e){return Promise.reject(e)}var r,i,a}},{key:"readChunk",value:function(e,t){try{var n=this;if(n.chunksRead++,0===(t=n.safeWrapAddress(e,t)))return;return n._readChunk(e,t)}catch(e){return Promise.reject(e)}}},{key:"safeWrapAddress",value:function(e,t){return void 0!==this.size&&e+t>this.size?Math.max(0,this.size-e):t}},{key:"nextChunkOffset",get:function(){if(0!==this.ranges.list.length)return this.ranges.list[0].length}},{key:"canReadNextChunk",get:function(){return this.chunksRead<this.options.chunkLimit}},{key:"fullyRead",get:function(){return void 0!==this.size&&this.nextChunkOffset===this.size}},{key:"read",value:function(){return this.options.chunked?this.readChunked():this.readWhole()}},{key:"close",value:function(){}}]),s}(Ut));K.set("blob",Vt),e.Exifr=Ie,e.Options=Pe,e.allFormatters=be,e.chunkedProps=de,e.createDictionary=te,e.default=at,e.disableAllOptions=lt,e.extendDictionary=ne,e.fetchUrlAsArrayBuffer=G,e.fileParsers=M,e.fileReaders=K,e.gps=ft,e.gpsOnlyOptions=dt,e.inheritables=me,e.orientation=ot,e.orientationOnlyOptions=vt,e.otherSegments=ve,e.parse=Te,e.readBlobAsArrayBuffer=Y,e.rotation=function(t){return st(ot(t),(function(t){return g({canvas:e.rotateCanvas,css:e.rotateCss},yt[t])}))},e.rotations=yt,e.segmentParsers=W,e.segments=pe,e.segmentsAndBlocks=ge,e.tagKeys=re,e.tagRevivers=ae,e.tagValues=ie,e.thumbnail=ht,e.thumbnailOnlyOptions=pt,e.thumbnailUrl=ct,e.tiffBlocks=ye,e.tiffExtractables=ke,Object.defineProperty(e,"__esModule",{value:!0})}));

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"_process":37,"buffer":9}],23:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = getFormData;
exports.getFieldData = getFieldData;
var NODE_LIST_CLASSES = {
  '[object HTMLCollection]': true,
  '[object NodeList]': true,
  '[object RadioNodeList]': true

  // .type values for elements which can appear in .elements and should be ignored
};var IGNORED_ELEMENT_TYPES = {
  'button': true,
  'fieldset': true,
  'reset': true,
  'submit': true
};

var CHECKED_INPUT_TYPES = {
  'checkbox': true,
  'radio': true
};

var TRIM_RE = /^\s+|\s+$/g;

var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * @param {HTMLFormElement} form
 * @param {Object} options
 * @return {Object.<string,(string|Array.<string>)>} an object containing
 *   submittable value(s) held in the form's .elements collection, with
 *   properties named as per element names or ids.
 */

function getFormData(form) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { trim: false };

  if (!form) {
    throw new Error('A form is required by getFormData, was given form=' + form);
  }

  var data = {};
  var elementName = void 0;
  var elementNames = [];
  var elementNameLookup = {};

  // Get unique submittable element names for the form
  for (var i = 0, l = form.elements.length; i < l; i++) {
    var element = form.elements[i];
    if (IGNORED_ELEMENT_TYPES[element.type] || element.disabled) {
      continue;
    }
    elementName = element.name || element.id;
    if (elementName && !elementNameLookup[elementName]) {
      elementNames.push(elementName);
      elementNameLookup[elementName] = true;
    }
  }

  // Extract element data name-by-name for consistent handling of special cases
  // around elements which contain multiple inputs.
  for (var _i = 0, _l = elementNames.length; _i < _l; _i++) {
    elementName = elementNames[_i];
    var value = getFieldData(form, elementName, options);
    if (value != null) {
      data[elementName] = value;
    }
  }

  return data;
}

/**
 * @param {HTMLFormElement} form
 * @param {string} fieldName
 * @param {Object} options
 * @return {(string|Array.<string>)} submittable value(s) in the form for a
 *   named element from its .elements collection, or null if there was no
 *   element with that name or the element had no submittable value(s).
 */
function getFieldData(form, fieldName) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { trim: false };

  if (!form) {
    throw new Error('A form is required by getFieldData, was given form=' + form);
  }
  if (!fieldName && toString.call(fieldName) !== '[object String]') {
    throw new Error('A field name is required by getFieldData, was given fieldName=' + fieldName);
  }

  var element = form.elements[fieldName];
  if (!element || element.disabled) {
    return null;
  }

  if (!NODE_LIST_CLASSES[toString.call(element)]) {
    return getFormElementValue(element, options.trim);
  }

  // Deal with multiple form controls which have the same name
  var data = [];
  var allRadios = true;
  for (var i = 0, l = element.length; i < l; i++) {
    if (element[i].disabled) {
      continue;
    }
    if (allRadios && element[i].type !== 'radio') {
      allRadios = false;
    }
    var value = getFormElementValue(element[i], options.trim);
    if (value != null) {
      data = data.concat(value);
    }
  }

  // Special case for an element with multiple same-named inputs which were all
  // radio buttons: if there was a selected value, only return the value.
  if (allRadios && data.length === 1) {
    return data[0];
  }

  return data.length > 0 ? data : null;
}

/**
 * @param {HTMLElement} element a form element.
 * @param {booleam} trim should values for text entry inputs be trimmed?
 * @return {(string|Array.<string>|File|Array.<File>)} the element's submittable
 *   value(s), or null if it had none.
 */
function getFormElementValue(element, trim) {
  var value = null;
  var type = element.type;


  if (type === 'select-one') {
    if (element.options.length) {
      value = element.options[element.selectedIndex].value;
    }
    return value;
  }

  if (type === 'select-multiple') {
    value = [];
    for (var i = 0, l = element.options.length; i < l; i++) {
      if (element.options[i].selected) {
        value.push(element.options[i].value);
      }
    }
    if (value.length === 0) {
      value = null;
    }
    return value;
  }

  // If a file input doesn't have a files attribute, fall through to using its
  // value attribute.
  if (type === 'file' && 'files' in element) {
    if (element.multiple) {
      value = slice.call(element.files);
      if (value.length === 0) {
        value = null;
      }
    } else {
      // Should be null if not present, according to the spec
      value = element.files[0];
    }
    return value;
  }

  if (!CHECKED_INPUT_TYPES[type]) {
    value = trim ? element.value.replace(TRIM_RE, '') : element.value;
  } else if (element.checked) {
    value = element.value;
  }

  return value;
}

// For UMD build access to getFieldData
getFormData.getFieldData = getFieldData;
},{}],24:[function(require,module,exports){
(function (Buffer){(function (){
/* global Blob File */

/*
 * Module requirements.
 */

var isArray = require('isarray');

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob && obj instanceof Blob) ||
    (withNativeFile && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":9,"isarray":25}],25:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],26:[function(require,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],27:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],28:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],29:[function(require,module,exports){
module.exports = function isShallowEqual (a, b) {
  if (a === b) return true
  for (var i in a) if (!(i in b)) return false
  for (var i in b) if (a[i] !== b[i]) return false
  return true
}

},{}],30:[function(require,module,exports){
(function (global){(function (){
/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory(global)
        : typeof define === 'function' && define.amd
        ? define(factory) : factory(global)
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    global = global || {};
    var _Base64 = global.Base64;
    var version = "2.6.4";
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa && typeof global.btoa == 'function'
        ? function(b){ return global.btoa(b) } : function(b) {
        if (b.match(/[^\x00-\xFF]/)) throw new RangeError(
            'The string contains invalid characters.'
        );
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = function(u) {
        return btoa(utob(String(u)));
    };
    var mkUriSafe = function (b64) {
        return b64.replace(/[+\/]/g, function(m0) {
            return m0 == '+' ? '-' : '_';
        }).replace(/=/g, '');
    };
    var encode = function(u, urisafe) {
        return urisafe ? mkUriSafe(_encode(u)) : _encode(u);
    };
    var encodeURI = function(u) { return encode(u, true) };
    var fromUint8Array;
    if (global.Uint8Array) fromUint8Array = function(a, urisafe) {
        // return btoa(fromCharCode.apply(null, a));
        var b64 = '';
        for (var i = 0, l = a.length; i < l; i += 3) {
            var a0 = a[i], a1 = a[i+1], a2 = a[i+2];
            var ord = a0 << 16 | a1 << 8 | a2;
            b64 +=    b64chars.charAt( ord >>> 18)
                +     b64chars.charAt((ord >>> 12) & 63)
                + ( typeof a1 != 'undefined'
                    ? b64chars.charAt((ord >>>  6) & 63) : '=')
                + ( typeof a2 != 'undefined'
                    ? b64chars.charAt( ord         & 63) : '=');
        }
        return urisafe ? mkUriSafe(b64) : b64;
    };
    // decoder stuff
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = global.atob && typeof global.atob == 'function'
        ? function(a){ return global.atob(a) } : function(a){
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function(a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    var _decode = function(a) { return btou(_atob(a)) };
    var _fromURI = function(a) {
        return String(a).replace(/[-_]/g, function(m0) {
            return m0 == '-' ? '+' : '/'
        }).replace(/[^A-Za-z0-9\+\/]/g, '');
    };
    var decode = function(a){
        return _decode(_fromURI(a));
    };
    var toUint8Array;
    if (global.Uint8Array) toUint8Array = function(a) {
        return Uint8Array.from(atob(_fromURI(a)), function(c) {
            return c.charCodeAt(0);
        });
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        fromUint8Array: fromUint8Array,
        toUint8Array: toUint8Array
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function(){ return global.Base64 });
    }
    // that's it!
    return {Base64: global.Base64}
}));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],31:[function(require,module,exports){
(function (global){(function (){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],32:[function(require,module,exports){
(function (global){(function (){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = throttle;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],33:[function(require,module,exports){
'use strict';
module.exports = Math.log2 || function (x) {
	return Math.log(x) * Math.LOG2E;
};

},{}],34:[function(require,module,exports){
'use strict';

function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (newInputs[i] !== lastInputs[i]) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var lastThis;
    var lastArgs = [];
    var lastResult;
    var calledOnce = false;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
            return lastResult;
        }
        lastResult = resultFn.apply(this, newArgs);
        calledOnce = true;
        lastThis = this;
        lastArgs = newArgs;
        return lastResult;
    }
    return memoized;
}

module.exports = memoizeOne;

},{}],35:[function(require,module,exports){
var wildcard = require('wildcard');
var reMimePartSplit = /[\/\+\.]/;

/**
  # mime-match

  A simple function to checker whether a target mime type matches a mime-type
  pattern (e.g. image/jpeg matches image/jpeg OR image/*).

  ## Example Usage

  <<< example.js

**/
module.exports = function(target, pattern) {
  function test(pattern) {
    var result = wildcard(pattern, target, reMimePartSplit);

    // ensure that we have a valid mime type (should have two parts)
    return result && result.length >= 2;
  }

  return pattern ? test(pattern.split(';')[0]) : test;
};

},{"wildcard":60}],36:[function(require,module,exports){
/**
* Create an event emitter with namespaces
* @name createNamespaceEmitter
* @example
* var emitter = require('./index')()
*
* emitter.on('*', function () {
*   console.log('all events emitted', this.event)
* })
*
* emitter.on('example', function () {
*   console.log('example event emitted')
* })
*/
module.exports = function createNamespaceEmitter () {
  var emitter = {}
  var _fns = emitter._fns = {}

  /**
  * Emit an event. Optionally namespace the event. Handlers are fired in the order in which they were added with exact matches taking precedence. Separate the namespace and event with a `:`
  * @name emit
  * @param {String} event  the name of the event, with optional namespace
  * @param {...*} data  up to 6 arguments that are passed to the event listener
  * @example
  * emitter.emit('example')
  * emitter.emit('demo:test')
  * emitter.emit('data', { example: true}, 'a string', 1)
  */
  emitter.emit = function emit (event, arg1, arg2, arg3, arg4, arg5, arg6) {
    var toEmit = getListeners(event)

    if (toEmit.length) {
      emitAll(event, toEmit, [arg1, arg2, arg3, arg4, arg5, arg6])
    }
  }

  /**
  * Create en event listener.
  * @name on
  * @param {String} event
  * @param {Function} fn
  * @example
  * emitter.on('example', function () {})
  * emitter.on('demo', function () {})
  */
  emitter.on = function on (event, fn) {
    if (!_fns[event]) {
      _fns[event] = []
    }

    _fns[event].push(fn)
  }

  /**
  * Create en event listener that fires once.
  * @name once
  * @param {String} event
  * @param {Function} fn
  * @example
  * emitter.once('example', function () {})
  * emitter.once('demo', function () {})
  */
  emitter.once = function once (event, fn) {
    function one () {
      fn.apply(this, arguments)
      emitter.off(event, one)
    }
    this.on(event, one)
  }

  /**
  * Stop listening to an event. Stop all listeners on an event by only passing the event name. Stop a single listener by passing that event handler as a callback.
  * You must be explicit about what will be unsubscribed: `emitter.off('demo')` will unsubscribe an `emitter.on('demo')` listener,
  * `emitter.off('demo:example')` will unsubscribe an `emitter.on('demo:example')` listener
  * @name off
  * @param {String} event
  * @param {Function} [fn]  the specific handler
  * @example
  * emitter.off('example')
  * emitter.off('demo', function () {})
  */
  emitter.off = function off (event, fn) {
    var keep = []

    if (event && fn) {
      var fns = this._fns[event]
      var i = 0
      var l = fns ? fns.length : 0

      for (i; i < l; i++) {
        if (fns[i] !== fn) {
          keep.push(fns[i])
        }
      }
    }

    keep.length ? this._fns[event] = keep : delete this._fns[event]
  }

  function getListeners (e) {
    var out = _fns[e] ? _fns[e] : []
    var idx = e.indexOf(':')
    var args = (idx === -1) ? [e] : [e.substring(0, idx), e.substring(idx + 1)]

    var keys = Object.keys(_fns)
    var i = 0
    var l = keys.length

    for (i; i < l; i++) {
      var key = keys[i]
      if (key === '*') {
        out = out.concat(_fns[key])
      }

      if (args.length === 2 && args[0] === key) {
        out = out.concat(_fns[key])
        break
      }
    }

    return out
  }

  function emitAll (e, fns, args) {
    var i = 0
    var l = fns.length

    for (i; i < l; i++) {
      if (!fns[i]) break
      fns[i].event = e
      fns[i].apply(fns[i], args)
    }
  }

  return emitter
}

},{}],37:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],38:[function(require,module,exports){
var has = Object.prototype.hasOwnProperty

/**
 * Stringify an object for use in a query string.
 *
 * @param {Object} obj - The object.
 * @param {string} prefix - When nesting, the parent key.
 *     keys in `obj` will be stringified as `prefix[key]`.
 * @returns {string}
 */

module.exports = function queryStringify (obj, prefix) {
  var pairs = []
  for (var key in obj) {
    if (!has.call(obj, key)) {
      continue
    }

    var value = obj[key]
    var enkey = encodeURIComponent(key)
    var pair
    if (typeof value === 'object') {
      pair = queryStringify(value, prefix ? prefix + '[' + enkey + ']' : enkey)
    } else {
      pair = (prefix ? prefix + '[' + enkey + ']' : enkey) + '=' + encodeURIComponent(value)
    }
    pairs.push(pair)
  }
  return pairs.join('&')
}

},{}],39:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],40:[function(require,module,exports){
(function (global){(function (){
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise

module.exports = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0))

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],41:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],42:[function(require,module,exports){
(function (global){(function (){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ResizeObserver = factory());
}(this, (function () { 'use strict';

    /**
     * A collection of shims that provide minimal functionality of the ES6 collections.
     *
     * These implementations are not meant to be used outside of the ResizeObserver
     * modules as they cover only a limited range of use cases.
     */
    /* eslint-disable require-jsdoc, valid-jsdoc */
    var MapShim = (function () {
        if (typeof Map !== 'undefined') {
            return Map;
        }
        /**
         * Returns index in provided array that matches the specified key.
         *
         * @param {Array<Array>} arr
         * @param {*} key
         * @returns {number}
         */
        function getIndex(arr, key) {
            var result = -1;
            arr.some(function (entry, index) {
                if (entry[0] === key) {
                    result = index;
                    return true;
                }
                return false;
            });
            return result;
        }
        return /** @class */ (function () {
            function class_1() {
                this.__entries__ = [];
            }
            Object.defineProperty(class_1.prototype, "size", {
                /**
                 * @returns {boolean}
                 */
                get: function () {
                    return this.__entries__.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * @param {*} key
             * @returns {*}
             */
            class_1.prototype.get = function (key) {
                var index = getIndex(this.__entries__, key);
                var entry = this.__entries__[index];
                return entry && entry[1];
            };
            /**
             * @param {*} key
             * @param {*} value
             * @returns {void}
             */
            class_1.prototype.set = function (key, value) {
                var index = getIndex(this.__entries__, key);
                if (~index) {
                    this.__entries__[index][1] = value;
                }
                else {
                    this.__entries__.push([key, value]);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.delete = function (key) {
                var entries = this.__entries__;
                var index = getIndex(entries, key);
                if (~index) {
                    entries.splice(index, 1);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.has = function (key) {
                return !!~getIndex(this.__entries__, key);
            };
            /**
             * @returns {void}
             */
            class_1.prototype.clear = function () {
                this.__entries__.splice(0);
            };
            /**
             * @param {Function} callback
             * @param {*} [ctx=null]
             * @returns {void}
             */
            class_1.prototype.forEach = function (callback, ctx) {
                if (ctx === void 0) { ctx = null; }
                for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                    var entry = _a[_i];
                    callback.call(ctx, entry[1], entry[0]);
                }
            };
            return class_1;
        }());
    })();

    /**
     * Detects whether window and document objects are available in current environment.
     */
    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

    // Returns global object of a current environment.
    var global$1 = (function () {
        if (typeof global !== 'undefined' && global.Math === Math) {
            return global;
        }
        if (typeof self !== 'undefined' && self.Math === Math) {
            return self;
        }
        if (typeof window !== 'undefined' && window.Math === Math) {
            return window;
        }
        // eslint-disable-next-line no-new-func
        return Function('return this')();
    })();

    /**
     * A shim for the requestAnimationFrame which falls back to the setTimeout if
     * first one is not supported.
     *
     * @returns {number} Requests' identifier.
     */
    var requestAnimationFrame$1 = (function () {
        if (typeof requestAnimationFrame === 'function') {
            // It's required to use a bounded function because IE sometimes throws
            // an "Invalid calling object" error if rAF is invoked without the global
            // object on the left hand side.
            return requestAnimationFrame.bind(global$1);
        }
        return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
    })();

    // Defines minimum timeout before adding a trailing call.
    var trailingTimeout = 2;
    /**
     * Creates a wrapper function which ensures that provided callback will be
     * invoked only once during the specified delay period.
     *
     * @param {Function} callback - Function to be invoked after the delay period.
     * @param {number} delay - Delay after which to invoke callback.
     * @returns {Function}
     */
    function throttle (callback, delay) {
        var leadingCall = false, trailingCall = false, lastCallTime = 0;
        /**
         * Invokes the original callback function and schedules new invocation if
         * the "proxy" was called during current request.
         *
         * @returns {void}
         */
        function resolvePending() {
            if (leadingCall) {
                leadingCall = false;
                callback();
            }
            if (trailingCall) {
                proxy();
            }
        }
        /**
         * Callback invoked after the specified delay. It will further postpone
         * invocation of the original function delegating it to the
         * requestAnimationFrame.
         *
         * @returns {void}
         */
        function timeoutCallback() {
            requestAnimationFrame$1(resolvePending);
        }
        /**
         * Schedules invocation of the original function.
         *
         * @returns {void}
         */
        function proxy() {
            var timeStamp = Date.now();
            if (leadingCall) {
                // Reject immediately following calls.
                if (timeStamp - lastCallTime < trailingTimeout) {
                    return;
                }
                // Schedule new call to be in invoked when the pending one is resolved.
                // This is important for "transitions" which never actually start
                // immediately so there is a chance that we might miss one if change
                // happens amids the pending invocation.
                trailingCall = true;
            }
            else {
                leadingCall = true;
                trailingCall = false;
                setTimeout(timeoutCallback, delay);
            }
            lastCallTime = timeStamp;
        }
        return proxy;
    }

    // Minimum delay before invoking the update of observers.
    var REFRESH_DELAY = 20;
    // A list of substrings of CSS properties used to find transition events that
    // might affect dimensions of observed elements.
    var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
    // Check if MutationObserver is available.
    var mutationObserverSupported = typeof MutationObserver !== 'undefined';
    /**
     * Singleton controller class which handles updates of ResizeObserver instances.
     */
    var ResizeObserverController = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserverController.
         *
         * @private
         */
        function ResizeObserverController() {
            /**
             * Indicates whether DOM listeners have been added.
             *
             * @private {boolean}
             */
            this.connected_ = false;
            /**
             * Tells that controller has subscribed for Mutation Events.
             *
             * @private {boolean}
             */
            this.mutationEventsAdded_ = false;
            /**
             * Keeps reference to the instance of MutationObserver.
             *
             * @private {MutationObserver}
             */
            this.mutationsObserver_ = null;
            /**
             * A list of connected observers.
             *
             * @private {Array<ResizeObserverSPI>}
             */
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
        }
        /**
         * Adds observer to observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be added.
         * @returns {void}
         */
        ResizeObserverController.prototype.addObserver = function (observer) {
            if (!~this.observers_.indexOf(observer)) {
                this.observers_.push(observer);
            }
            // Add listeners if they haven't been added yet.
            if (!this.connected_) {
                this.connect_();
            }
        };
        /**
         * Removes observer from observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be removed.
         * @returns {void}
         */
        ResizeObserverController.prototype.removeObserver = function (observer) {
            var observers = this.observers_;
            var index = observers.indexOf(observer);
            // Remove observer if it's present in registry.
            if (~index) {
                observers.splice(index, 1);
            }
            // Remove listeners if controller has no connected observers.
            if (!observers.length && this.connected_) {
                this.disconnect_();
            }
        };
        /**
         * Invokes the update of observers. It will continue running updates insofar
         * it detects changes.
         *
         * @returns {void}
         */
        ResizeObserverController.prototype.refresh = function () {
            var changesDetected = this.updateObservers_();
            // Continue running updates if changes have been detected as there might
            // be future ones caused by CSS transitions.
            if (changesDetected) {
                this.refresh();
            }
        };
        /**
         * Updates every observer from observers list and notifies them of queued
         * entries.
         *
         * @private
         * @returns {boolean} Returns "true" if any observer has detected changes in
         *      dimensions of it's elements.
         */
        ResizeObserverController.prototype.updateObservers_ = function () {
            // Collect observers that have active observations.
            var activeObservers = this.observers_.filter(function (observer) {
                return observer.gatherActive(), observer.hasActive();
            });
            // Deliver notifications in a separate cycle in order to avoid any
            // collisions between observers, e.g. when multiple instances of
            // ResizeObserver are tracking the same element and the callback of one
            // of them changes content dimensions of the observed target. Sometimes
            // this may result in notifications being blocked for the rest of observers.
            activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
            return activeObservers.length > 0;
        };
        /**
         * Initializes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.connect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already added.
            if (!isBrowser || this.connected_) {
                return;
            }
            // Subscription to the "Transitionend" event is used as a workaround for
            // delayed transitions. This way it's possible to capture at least the
            // final state of an element.
            document.addEventListener('transitionend', this.onTransitionEnd_);
            window.addEventListener('resize', this.refresh);
            if (mutationObserverSupported) {
                this.mutationsObserver_ = new MutationObserver(this.refresh);
                this.mutationsObserver_.observe(document, {
                    attributes: true,
                    childList: true,
                    characterData: true,
                    subtree: true
                });
            }
            else {
                document.addEventListener('DOMSubtreeModified', this.refresh);
                this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
        };
        /**
         * Removes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.disconnect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already removed.
            if (!isBrowser || !this.connected_) {
                return;
            }
            document.removeEventListener('transitionend', this.onTransitionEnd_);
            window.removeEventListener('resize', this.refresh);
            if (this.mutationsObserver_) {
                this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
                document.removeEventListener('DOMSubtreeModified', this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
        };
        /**
         * "Transitionend" event handler.
         *
         * @private
         * @param {TransitionEvent} event
         * @returns {void}
         */
        ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
            var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
            // Detect whether transition may affect dimensions of an element.
            var isReflowProperty = transitionKeys.some(function (key) {
                return !!~propertyName.indexOf(key);
            });
            if (isReflowProperty) {
                this.refresh();
            }
        };
        /**
         * Returns instance of the ResizeObserverController.
         *
         * @returns {ResizeObserverController}
         */
        ResizeObserverController.getInstance = function () {
            if (!this.instance_) {
                this.instance_ = new ResizeObserverController();
            }
            return this.instance_;
        };
        /**
         * Holds reference to the controller's instance.
         *
         * @private {ResizeObserverController}
         */
        ResizeObserverController.instance_ = null;
        return ResizeObserverController;
    }());

    /**
     * Defines non-writable/enumerable properties of the provided target object.
     *
     * @param {Object} target - Object for which to define properties.
     * @param {Object} props - Properties to be defined.
     * @returns {Object} Target object.
     */
    var defineConfigurable = (function (target, props) {
        for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
            var key = _a[_i];
            Object.defineProperty(target, key, {
                value: props[key],
                enumerable: false,
                writable: false,
                configurable: true
            });
        }
        return target;
    });

    /**
     * Returns the global object associated with provided element.
     *
     * @param {Object} target
     * @returns {Object}
     */
    var getWindowOf = (function (target) {
        // Assume that the element is an instance of Node, which means that it
        // has the "ownerDocument" property from which we can retrieve a
        // corresponding global object.
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
        // Return the local global object if it's not possible extract one from
        // provided element.
        return ownerGlobal || global$1;
    });

    // Placeholder of an empty content rectangle.
    var emptyRect = createRectInit(0, 0, 0, 0);
    /**
     * Converts provided string to a number.
     *
     * @param {number|string} value
     * @returns {number}
     */
    function toFloat(value) {
        return parseFloat(value) || 0;
    }
    /**
     * Extracts borders size from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @param {...string} positions - Borders positions (top, right, ...)
     * @returns {number}
     */
    function getBordersSize(styles) {
        var positions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            positions[_i - 1] = arguments[_i];
        }
        return positions.reduce(function (size, position) {
            var value = styles['border-' + position + '-width'];
            return size + toFloat(value);
        }, 0);
    }
    /**
     * Extracts paddings sizes from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @returns {Object} Paddings box.
     */
    function getPaddings(styles) {
        var positions = ['top', 'right', 'bottom', 'left'];
        var paddings = {};
        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
            var position = positions_1[_i];
            var value = styles['padding-' + position];
            paddings[position] = toFloat(value);
        }
        return paddings;
    }
    /**
     * Calculates content rectangle of provided SVG element.
     *
     * @param {SVGGraphicsElement} target - Element content rectangle of which needs
     *      to be calculated.
     * @returns {DOMRectInit}
     */
    function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
    }
    /**
     * Calculates content rectangle of provided HTMLElement.
     *
     * @param {HTMLElement} target - Element for which to calculate the content rectangle.
     * @returns {DOMRectInit}
     */
    function getHTMLElementContentRect(target) {
        // Client width & height properties can't be
        // used exclusively as they provide rounded values.
        var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
        // By this condition we can catch all non-replaced inline, hidden and
        // detached elements. Though elements with width & height properties less
        // than 0.5 will be discarded as well.
        //
        // Without it we would need to implement separate methods for each of
        // those cases and it's not possible to perform a precise and performance
        // effective test for hidden elements. E.g. even jQuery's ':visible' filter
        // gives wrong results for elements with width & height less than 0.5.
        if (!clientWidth && !clientHeight) {
            return emptyRect;
        }
        var styles = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom;
        // Computed styles of width & height are being used because they are the
        // only dimensions available to JS that contain non-rounded values. It could
        // be possible to utilize the getBoundingClientRect if only it's data wasn't
        // affected by CSS transformations let alone paddings, borders and scroll bars.
        var width = toFloat(styles.width), height = toFloat(styles.height);
        // Width & height include paddings and borders when the 'border-box' box
        // model is applied (except for IE).
        if (styles.boxSizing === 'border-box') {
            // Following conditions are required to handle Internet Explorer which
            // doesn't include paddings and borders to computed CSS dimensions.
            //
            // We can say that if CSS dimensions + paddings are equal to the "client"
            // properties then it's either IE, and thus we don't need to subtract
            // anything, or an element merely doesn't have paddings/borders styles.
            if (Math.round(width + horizPad) !== clientWidth) {
                width -= getBordersSize(styles, 'left', 'right') + horizPad;
            }
            if (Math.round(height + vertPad) !== clientHeight) {
                height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
            }
        }
        // Following steps can't be applied to the document's root element as its
        // client[Width/Height] properties represent viewport area of the window.
        // Besides, it's as well not necessary as the <html> itself neither has
        // rendered scroll bars nor it can be clipped.
        if (!isDocumentElement(target)) {
            // In some browsers (only in Firefox, actually) CSS width & height
            // include scroll bars size which can be removed at this step as scroll
            // bars are the only difference between rounded dimensions + paddings
            // and "client" properties, though that is not always true in Chrome.
            var vertScrollbar = Math.round(width + horizPad) - clientWidth;
            var horizScrollbar = Math.round(height + vertPad) - clientHeight;
            // Chrome has a rather weird rounding of "client" properties.
            // E.g. for an element with content width of 314.2px it sometimes gives
            // the client width of 315px and for the width of 314.7px it may give
            // 314px. And it doesn't happen all the time. So just ignore this delta
            // as a non-relevant.
            if (Math.abs(vertScrollbar) !== 1) {
                width -= vertScrollbar;
            }
            if (Math.abs(horizScrollbar) !== 1) {
                height -= horizScrollbar;
            }
        }
        return createRectInit(paddings.left, paddings.top, width, height);
    }
    /**
     * Checks whether provided element is an instance of the SVGGraphicsElement.
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    var isSVGGraphicsElement = (function () {
        // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
        // interface.
        if (typeof SVGGraphicsElement !== 'undefined') {
            return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
        }
        // If it's so, then check that element is at least an instance of the
        // SVGElement and that it has the "getBBox" method.
        // eslint-disable-next-line no-extra-parens
        return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
            typeof target.getBBox === 'function'); };
    })();
    /**
     * Checks whether provided element is a document element (<html>).
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
    }
    /**
     * Calculates an appropriate content rectangle for provided html or svg element.
     *
     * @param {Element} target - Element content rectangle of which needs to be calculated.
     * @returns {DOMRectInit}
     */
    function getContentRect(target) {
        if (!isBrowser) {
            return emptyRect;
        }
        if (isSVGGraphicsElement(target)) {
            return getSVGContentRect(target);
        }
        return getHTMLElementContentRect(target);
    }
    /**
     * Creates rectangle with an interface of the DOMRectReadOnly.
     * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
     *
     * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
     * @returns {DOMRectReadOnly}
     */
    function createReadOnlyRect(_a) {
        var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        // If DOMRectReadOnly is available use it as a prototype for the rectangle.
        var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype);
        // Rectangle's properties are not writable and non-enumerable.
        defineConfigurable(rect, {
            x: x, y: y, width: width, height: height,
            top: y,
            right: x + width,
            bottom: height + y,
            left: x
        });
        return rect;
    }
    /**
     * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
     * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
     *
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} width - Rectangle's width.
     * @param {number} height - Rectangle's height.
     * @returns {DOMRectInit}
     */
    function createRectInit(x, y, width, height) {
        return { x: x, y: y, width: width, height: height };
    }

    /**
     * Class that is responsible for computations of the content rectangle of
     * provided DOM element and for keeping track of it's changes.
     */
    var ResizeObservation = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObservation.
         *
         * @param {Element} target - Element to be observed.
         */
        function ResizeObservation(target) {
            /**
             * Broadcasted width of content rectangle.
             *
             * @type {number}
             */
            this.broadcastWidth = 0;
            /**
             * Broadcasted height of content rectangle.
             *
             * @type {number}
             */
            this.broadcastHeight = 0;
            /**
             * Reference to the last observed content rectangle.
             *
             * @private {DOMRectInit}
             */
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
        }
        /**
         * Updates content rectangle and tells whether it's width or height properties
         * have changed since the last broadcast.
         *
         * @returns {boolean}
         */
        ResizeObservation.prototype.isActive = function () {
            var rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return (rect.width !== this.broadcastWidth ||
                rect.height !== this.broadcastHeight);
        };
        /**
         * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
         * from the corresponding properties of the last observed content rectangle.
         *
         * @returns {DOMRectInit} Last observed content rectangle.
         */
        ResizeObservation.prototype.broadcastRect = function () {
            var rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
        };
        return ResizeObservation;
    }());

    var ResizeObserverEntry = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObserverEntry.
         *
         * @param {Element} target - Element that is being observed.
         * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
         */
        function ResizeObserverEntry(target, rectInit) {
            var contentRect = createReadOnlyRect(rectInit);
            // According to the specification following properties are not writable
            // and are also not enumerable in the native implementation.
            //
            // Property accessors are not being used as they'd require to define a
            // private WeakMap storage which may cause memory leaks in browsers that
            // don't support this type of collections.
            defineConfigurable(this, { target: target, contentRect: contentRect });
        }
        return ResizeObserverEntry;
    }());

    var ResizeObserverSPI = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback function that is invoked
         *      when one of the observed elements changes it's content dimensions.
         * @param {ResizeObserverController} controller - Controller instance which
         *      is responsible for the updates of observer.
         * @param {ResizeObserver} callbackCtx - Reference to the public
         *      ResizeObserver instance which will be passed to callback function.
         */
        function ResizeObserverSPI(callback, controller, callbackCtx) {
            /**
             * Collection of resize observations that have detected changes in dimensions
             * of elements.
             *
             * @private {Array<ResizeObservation>}
             */
            this.activeObservations_ = [];
            /**
             * Registry of the ResizeObservation instances.
             *
             * @private {Map<Element, ResizeObservation>}
             */
            this.observations_ = new MapShim();
            if (typeof callback !== 'function') {
                throw new TypeError('The callback provided as parameter 1 is not a function.');
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
        }
        /**
         * Starts observing provided element.
         *
         * @param {Element} target - Element to be observed.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.observe = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is already being observed.
            if (observations.has(target)) {
                return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            // Force the update of observations.
            this.controller_.refresh();
        };
        /**
         * Stops observing provided element.
         *
         * @param {Element} target - Element to stop observing.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.unobserve = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is not being observed.
            if (!observations.has(target)) {
                return;
            }
            observations.delete(target);
            if (!observations.size) {
                this.controller_.removeObserver(this);
            }
        };
        /**
         * Stops observing all elements.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.disconnect = function () {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
        };
        /**
         * Collects observation instances the associated element of which has changed
         * it's content rectangle.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.gatherActive = function () {
            var _this = this;
            this.clearActive();
            this.observations_.forEach(function (observation) {
                if (observation.isActive()) {
                    _this.activeObservations_.push(observation);
                }
            });
        };
        /**
         * Invokes initial callback function with a list of ResizeObserverEntry
         * instances collected from active resize observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.broadcastActive = function () {
            // Do nothing if observer doesn't have active observations.
            if (!this.hasActive()) {
                return;
            }
            var ctx = this.callbackCtx_;
            // Create ResizeObserverEntry instance for every active observation.
            var entries = this.activeObservations_.map(function (observation) {
                return new ResizeObserverEntry(observation.target, observation.broadcastRect());
            });
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
        };
        /**
         * Clears the collection of active observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.clearActive = function () {
            this.activeObservations_.splice(0);
        };
        /**
         * Tells whether observer has active observations.
         *
         * @returns {boolean}
         */
        ResizeObserverSPI.prototype.hasActive = function () {
            return this.activeObservations_.length > 0;
        };
        return ResizeObserverSPI;
    }());

    // Registry of internal observers. If WeakMap is not available use current shim
    // for the Map collection as it has all required methods and because WeakMap
    // can't be fully polyfilled anyway.
    var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
    /**
     * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
     * exposing only those methods and properties that are defined in the spec.
     */
    var ResizeObserver = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback that is invoked when
         *      dimensions of the observed elements change.
         */
        function ResizeObserver(callback) {
            if (!(this instanceof ResizeObserver)) {
                throw new TypeError('Cannot call a class as a function.');
            }
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            var controller = ResizeObserverController.getInstance();
            var observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
        }
        return ResizeObserver;
    }());
    // Expose public methods of ResizeObserver.
    [
        'observe',
        'unobserve',
        'disconnect'
    ].forEach(function (method) {
        ResizeObserver.prototype[method] = function () {
            var _a;
            return (_a = observers.get(this))[method].apply(_a, arguments);
        };
    });

    var index = (function () {
        // Export existing implementation if available.
        if (typeof global$1.ResizeObserver !== 'undefined') {
            return global$1.ResizeObserver;
        }
        return ResizeObserver;
    })();

    return index;

})));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],43:[function(require,module,exports){
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = runParallel

const queueMicrotask = require('queue-microtask')

function runParallel (tasks, cb) {
  let results, pending, keys
  let isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) queueMicrotask(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (--pending === 0 || err) {
      done(err)
    }
  }

  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result) })
    })
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result) })
    })
  }

  isSync = false
}

},{"queue-microtask":40}],44:[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

var _uriToBlob = _interopRequireDefault(require("./uriToBlob"));

var _isCordova = _interopRequireDefault(require("./isCordova"));

var _readAsByteArray = _interopRequireDefault(require("./readAsByteArray"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var FileSource = /*#__PURE__*/function () {
  // Make this.size a method
  function FileSource(file) {
    _classCallCheck(this, FileSource);

    this._file = file;
    this.size = file.size;
  }

  _createClass(FileSource, [{
    key: "slice",
    value: function slice(start, end) {
      // In Apache Cordova applications, a File must be resolved using
      // FileReader instances, see
      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file
      if ((0, _isCordova.default)()) {
        return (0, _readAsByteArray.default)(this._file.slice(start, end));
      }

      var value = this._file.slice(start, end);

      return Promise.resolve({
        value: value
      });
    }
  }, {
    key: "close",
    value: function close() {// Nothing to do here since we don't need to release any resources.
    }
  }]);

  return FileSource;
}();

var StreamSource = /*#__PURE__*/function () {
  function StreamSource(reader, chunkSize) {
    _classCallCheck(this, StreamSource);

    this._chunkSize = chunkSize;
    this._buffer = undefined;
    this._bufferOffset = 0;
    this._reader = reader;
    this._done = false;
  }

  _createClass(StreamSource, [{
    key: "slice",
    value: function slice(start, end) {
      if (start < this._bufferOffset) {
        return Promise.reject(new Error("Requested data is before the reader's current offset"));
      }

      return this._readUntilEnoughDataOrDone(start, end);
    }
  }, {
    key: "_readUntilEnoughDataOrDone",
    value: function _readUntilEnoughDataOrDone(start, end) {
      var _this = this;

      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);

      if (this._done || hasEnoughData) {
        var value = this._getDataFromBuffer(start, end);

        var done = value == null ? this._done : false;
        return Promise.resolve({
          value: value,
          done: done
        });
      }

      return this._reader.read().then(function (_ref) {
        var value = _ref.value,
            done = _ref.done;

        if (done) {
          _this._done = true;
        } else if (_this._buffer === undefined) {
          _this._buffer = value;
        } else {
          _this._buffer = concat(_this._buffer, value);
        }

        return _this._readUntilEnoughDataOrDone(start, end);
      });
    }
  }, {
    key: "_getDataFromBuffer",
    value: function _getDataFromBuffer(start, end) {
      // Remove data from buffer before `start`.
      // Data might be reread from the buffer if an upload fails, so we can only
      // safely delete data when it comes *before* what is currently being read.
      if (start > this._bufferOffset) {
        this._buffer = this._buffer.slice(start - this._bufferOffset);
        this._bufferOffset = start;
      } // If the buffer is empty after removing old data, all data has been read.


      var hasAllDataBeenRead = len(this._buffer) === 0;

      if (this._done && hasAllDataBeenRead) {
        return null;
      } // We already removed data before `start`, so we just return the first
      // chunk from the buffer.


      return this._buffer.slice(0, end - start);
    }
  }, {
    key: "close",
    value: function close() {
      if (this._reader.cancel) {
        this._reader.cancel();
      }
    }
  }]);

  return StreamSource;
}();

function len(blobOrArray) {
  if (blobOrArray === undefined) return 0;
  if (blobOrArray.size !== undefined) return blobOrArray.size;
  return blobOrArray.length;
}
/*
  Typed arrays and blobs don't have a concat method.
  This function helps StreamSource accumulate data to reach chunkSize.
*/


function concat(a, b) {
  if (a.concat) {
    // Is `a` an Array?
    return a.concat(b);
  }

  if (a instanceof Blob) {
    return new Blob([a, b], {
      type: a.type
    });
  }

  if (a.set) {
    // Is `a` a typed array?
    var c = new a.constructor(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
  }

  throw new Error("Unknown data type");
}

var FileReader = /*#__PURE__*/function () {
  function FileReader() {
    _classCallCheck(this, FileReader);
  }

  _createClass(FileReader, [{
    key: "openFile",
    value: function openFile(input, chunkSize) {
      // In React Native, when user selects a file, instead of a File or Blob,
      // you usually get a file object {} with a uri property that contains
      // a local path to the file. We use XMLHttpRequest to fetch
      // the file blob, before uploading with tus.
      if ((0, _isReactNative.default)() && input && typeof input.uri !== "undefined") {
        return (0, _uriToBlob.default)(input.uri).then(function (blob) {
          return new FileSource(blob);
        })["catch"](function (err) {
          throw new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. " + err);
        });
      } // Since we emulate the Blob type in our tests (not all target browsers
      // support it), we cannot use `instanceof` for testing whether the input value
      // can be handled. Instead, we simply check is the slice() function and the
      // size property are available.


      if (typeof input.slice === "function" && typeof input.size !== "undefined") {
        return Promise.resolve(new FileSource(input));
      }

      if (typeof input.read === "function") {
        chunkSize = +chunkSize;

        if (!isFinite(chunkSize)) {
          return Promise.reject(new Error("cannot create source for stream without a finite value for the `chunkSize` option"));
        }

        return Promise.resolve(new StreamSource(input, chunkSize));
      }

      return Promise.reject(new Error("source object may only be an instance of File, Blob, or Reader in this environment"));
    }
  }]);

  return FileReader;
}();

exports.default = FileReader;
},{"./isCordova":49,"./isReactNative":50,"./readAsByteArray":51,"./uriToBlob":52}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fingerprint;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: Differenciate between input types

/**
 * Generate a fingerprint for a file which will be used the store the endpoint
 *
 * @param {File} file
 * @param {Object} options
 * @param {Function} callback
 */
function fingerprint(file, options) {
  if ((0, _isReactNative.default)()) {
    return Promise.resolve(reactNativeFingerprint(file, options));
  }

  return Promise.resolve(["tus-br", file.name, file.type, file.size, file.lastModified, options.endpoint].join("-"));
}

function reactNativeFingerprint(file, options) {
  var exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : "noexif";
  return ["tus-rn", file.name || "noname", file.size || "nosize", exifHash, options.endpoint].join("/");
}

function hashCode(str) {
  // from https://stackoverflow.com/a/8831937/151666
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    var _char = str.charCodeAt(i);

    hash = (hash << 5) - hash + _char;
    hash = hash & hash; // Convert to 32bit integer
  }

  return hash;
}
},{"./isReactNative":50}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var XHRHttpStack = /*#__PURE__*/function () {
  function XHRHttpStack() {
    _classCallCheck(this, XHRHttpStack);
  }

  _createClass(XHRHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      return new Request(method, url);
    }
  }, {
    key: "getName",
    value: function getName() {
      return "XHRHttpStack";
    }
  }]);

  return XHRHttpStack;
}();

exports.default = XHRHttpStack;

var Request = /*#__PURE__*/function () {
  function Request(method, url) {
    _classCallCheck(this, Request);

    this._xhr = new XMLHttpRequest();

    this._xhr.open(method, url, true);

    this._method = method;
    this._url = url;
    this._headers = {};
  }

  _createClass(Request, [{
    key: "getMethod",
    value: function getMethod() {
      return this._method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this._url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this._xhr.setRequestHeader(header, value);

      this._headers[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._headers[header];
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      // Test support for progress events before attaching an event listener
      if (!("upload" in this._xhr)) {
        return;
      }

      this._xhr.upload.onprogress = function (e) {
        if (!e.lengthComputable) {
          return;
        }

        progressHandler(e.loaded);
      };
    }
  }, {
    key: "send",
    value: function send() {
      var _this = this;

      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return new Promise(function (resolve, reject) {
        _this._xhr.onload = function () {
          resolve(new Response(_this._xhr));
        };

        _this._xhr.onerror = function (err) {
          reject(err);
        };

        _this._xhr.send(body);
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      this._xhr.abort();

      return Promise.resolve();
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Request;
}();

var Response = /*#__PURE__*/function () {
  function Response(xhr) {
    _classCallCheck(this, Response);

    this._xhr = xhr;
  }

  _createClass(Response, [{
    key: "getStatus",
    value: function getStatus() {
      return this._xhr.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._xhr.getResponseHeader(header);
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._xhr.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Response;
}();
},{}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "enableDebugLog", {
  enumerable: true,
  get: function () {
    return _logger.enableDebugLog;
  }
});
Object.defineProperty(exports, "canStoreURLs", {
  enumerable: true,
  get: function () {
    return _urlStorage.canStoreURLs;
  }
});
exports.isSupported = exports.defaultOptions = exports.Upload = void 0;

var _upload = _interopRequireDefault(require("../upload"));

var _noopUrlStorage = _interopRequireDefault(require("../noopUrlStorage"));

var _logger = require("../logger");

var _urlStorage = require("./urlStorage");

var _httpStack = _interopRequireDefault(require("./httpStack"));

var _fileReader = _interopRequireDefault(require("./fileReader"));

var _fingerprint = _interopRequireDefault(require("./fingerprint"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/* global window */


var defaultOptions = _objectSpread({}, _upload.default.defaultOptions, {
  httpStack: new _httpStack.default(),
  fileReader: new _fileReader.default(),
  urlStorage: _urlStorage.canStoreURLs ? new _urlStorage.WebStorageUrlStorage() : new _noopUrlStorage.default(),
  fingerprint: _fingerprint.default
});

exports.defaultOptions = defaultOptions;

var Upload = /*#__PURE__*/function (_BaseUpload) {
  _inherits(Upload, _BaseUpload);

  var _super = _createSuper(Upload);

  function Upload() {
    var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Upload);

    options = _objectSpread({}, defaultOptions, {}, options);
    return _super.call(this, file, options);
  }

  _createClass(Upload, null, [{
    key: "terminate",
    value: function terminate(url, options, cb) {
      options = _objectSpread({}, defaultOptions, {}, options);
      return _upload.default.terminate(url, options, cb);
    }
  }]);

  return Upload;
}(_upload.default);

exports.Upload = Upload;
var _window = window,
    XMLHttpRequest = _window.XMLHttpRequest,
    Blob = _window.Blob;
var isSupported = XMLHttpRequest && Blob && typeof Blob.prototype.slice === "function";
exports.isSupported = isSupported;
},{"../logger":55,"../noopUrlStorage":56,"../upload":57,"./fileReader":45,"./fingerprint":46,"./httpStack":47,"./urlStorage":53}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var isCordova = function isCordova() {
  return typeof window != "undefined" && (typeof window.PhoneGap != "undefined" || typeof window.Cordova != "undefined" || typeof window.cordova != "undefined");
};

var _default = isCordova;
exports.default = _default;
},{}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var isReactNative = function isReactNative() {
  return typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
};

var _default = isReactNative;
exports.default = _default;
},{}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = readAsByteArray;

/**
 * readAsByteArray converts a File object to a Uint8Array.
 * This function is only used on the Apache Cordova platform.
 * See https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file/index.html#read-a-file
 */
function readAsByteArray(chunk) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();

    reader.onload = function () {
      var value = new Uint8Array(reader.result);
      resolve({
        value: value
      });
    };

    reader.onerror = function (err) {
      reject(err);
    };

    reader.readAsArrayBuffer(chunk);
  });
}
},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = uriToBlob;

/**
 * uriToBlob resolves a URI to a Blob object. This is used for
 * React Native to retrieve a file (identified by a file://
 * URI) as a blob.
 */
function uriToBlob(uri) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.responseType = "blob";

    xhr.onload = function () {
      var blob = xhr.response;
      resolve(blob);
    };

    xhr.onerror = function (err) {
      reject(err);
    };

    xhr.open("GET", uri);
    xhr.send();
  });
}
},{}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebStorageUrlStorage = exports.canStoreURLs = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window, localStorage */


var hasStorage = false;

try {
  hasStorage = "localStorage" in window; // Attempt to store and read entries from the local storage to detect Private
  // Mode on Safari on iOS (see #49)

  var key = "tusSupport";
  localStorage.setItem(key, localStorage.getItem(key));
} catch (e) {
  // If we try to access localStorage inside a sandboxed iframe, a SecurityError
  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is
  // thrown (see #49)
  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {
    hasStorage = false;
  } else {
    throw e;
  }
}

var canStoreURLs = hasStorage;
exports.canStoreURLs = canStoreURLs;

var WebStorageUrlStorage = /*#__PURE__*/function () {
  function WebStorageUrlStorage() {
    _classCallCheck(this, WebStorageUrlStorage);
  }

  _createClass(WebStorageUrlStorage, [{
    key: "findAllUploads",
    value: function findAllUploads() {
      var results = this._findEntries("tus::");

      return Promise.resolve(results);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      var results = this._findEntries("tus::".concat(fingerprint, "::"));

      return Promise.resolve(results);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      localStorage.removeItem(urlStorageKey);
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      var id = Math.round(Math.random() * 1e12);
      var key = "tus::".concat(fingerprint, "::").concat(id);
      localStorage.setItem(key, JSON.stringify(upload));
      return Promise.resolve(key);
    }
  }, {
    key: "_findEntries",
    value: function _findEntries(prefix) {
      var results = [];

      for (var i = 0; i < localStorage.length; i++) {
        var _key = localStorage.key(i);

        if (_key.indexOf(prefix) !== 0) continue;

        try {
          var upload = JSON.parse(localStorage.getItem(_key));
          upload.urlStorageKey = _key;
          results.push(upload);
        } catch (e) {// The JSON parse error is intentionally ignored here, so a malformed
          // entry in the storage cannot prevent an upload.
        }
      }

      return results;
    }
  }]);

  return WebStorageUrlStorage;
}();

exports.WebStorageUrlStorage = WebStorageUrlStorage;
},{}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

var DetailedError = /*#__PURE__*/function (_Error) {
  _inherits(DetailedError, _Error);

  var _super = _createSuper(DetailedError);

  function DetailedError(message) {
    var _this;

    var causingErr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var req = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var res = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, DetailedError);

    _this = _super.call(this, message);
    _this.originalRequest = req;
    _this.originalResponse = res;
    _this.causingError = causingErr;

    if (causingErr != null) {
      message += ", caused by ".concat(causingErr.toString());
    }

    if (req != null) {
      var requestId = req.getHeader("X-Request-ID") || "n/a";
      var method = req.getMethod();
      var url = req.getURL();
      var status = res ? res.getStatus() : "n/a";
      var body = res ? res.getBody() || "" : "n/a";
      message += ", originated from request (method: ".concat(method, ", url: ").concat(url, ", response code: ").concat(status, ", response text: ").concat(body, ", request id: ").concat(requestId, ")");
    }

    _this.message = message;
    return _this;
  }

  return DetailedError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var _default = DetailedError;
exports.default = _default;
},{}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enableDebugLog = enableDebugLog;
exports.log = log;

/* eslint no-console: "off" */
var isEnabled = false;

function enableDebugLog() {
  isEnabled = true;
}

function log(msg) {
  if (!isEnabled) return;
  console.log(msg);
}
},{}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* eslint no-unused-vars: "off" */


var NoopUrlStorage = /*#__PURE__*/function () {
  function NoopUrlStorage() {
    _classCallCheck(this, NoopUrlStorage);
  }

  _createClass(NoopUrlStorage, [{
    key: "listAllUploads",
    value: function listAllUploads() {
      return Promise.resolve([]);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      return Promise.resolve([]);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      return Promise.resolve(null);
    }
  }]);

  return NoopUrlStorage;
}();

exports.default = NoopUrlStorage;
},{}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _error = _interopRequireDefault(require("./error"));

var _uuid = _interopRequireDefault(require("./uuid"));

var _jsBase = require("js-base64");

var _urlParse = _interopRequireDefault(require("url-parse"));

var _logger = require("./logger");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var defaultOptions = {
  endpoint: null,
  uploadUrl: null,
  metadata: {},
  fingerprint: null,
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  _onUploadUrlAvailable: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  onBeforeRequest: null,
  onAfterResponse: null,
  chunkSize: Infinity,
  retryDelays: [0, 1000, 3000, 5000],
  parallelUploads: 1,
  storeFingerprintForResuming: true,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false,
  urlStorage: null,
  fileReader: null,
  httpStack: null
};

var BaseUpload = /*#__PURE__*/function () {
  function BaseUpload(file, options) {
    _classCallCheck(this, BaseUpload); // Warn about removed options from previous versions


    if ("resume" in options) {
      console.log("tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead."); // eslint-disable-line no-console
    } // The default options will already be added from the wrapper classes.


    this.options = options; // The storage module used to store URLs

    this._urlStorage = this.options.urlStorage; // The underlying File/Blob object

    this.file = file; // The URL against which the file will be uploaded

    this.url = null; // The underlying request object for the current PATCH request

    this._req = null; // The fingerpinrt for the current file (set after start())

    this._fingerprint = null; // The key that the URL storage returned when saving an URL with a fingerprint,

    this._urlStorageKey = null; // The offset used in the current PATCH request

    this._offset = null; // True if the current PATCH request has been aborted

    this._aborted = false; // The file's size in bytes

    this._size = null; // The Source object which will wrap around the given file and provides us
    // with a unified interface for getting its size and slice chunks from its
    // content allowing us to easily handle Files, Blobs, Buffers and Streams.

    this._source = null; // The current count of attempts which have been made. Zero indicates none.

    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry

    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.

    this._offsetBeforeRetry = 0; // An array of BaseUpload instances which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploads = null; // An array of upload URLs which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploadUrls = null;
  }
  /**
   * Use the Termination extension to delete an upload from the server by sending a DELETE
   * request to the specified upload URL. This is only possible if the server supports the
   * Termination extension. If the `options.retryDelays` property is set, the method will
   * also retry if an error ocurrs.
   *
   * @param {String} url The upload's URL which will be terminated.
   * @param {object} options Optional options for influencing HTTP requests.
   * @return {Promise} The Promise will be resolved/rejected when the requests finish.
   */


  _createClass(BaseUpload, [{
    key: "findPreviousUploads",
    value: function findPreviousUploads() {
      var _this = this;

      return this.options.fingerprint(this.file, this.options).then(function (fingerprint) {
        return _this._urlStorage.findUploadsByFingerprint(fingerprint);
      });
    }
  }, {
    key: "resumeFromPreviousUpload",
    value: function resumeFromPreviousUpload(previousUpload) {
      this.url = previousUpload.uploadUrl || null;
      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;
      this._urlStorageKey = previousUpload.urlStorageKey;
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var file = this.file;

      if (!file) {
        this._emitError(new Error("tus: no file or stream to upload provided"));

        return;
      }

      if (!this.options.endpoint && !this.options.uploadUrl) {
        this._emitError(new Error("tus: neither an endpoint or an upload URL is provided"));

        return;
      }

      var retryDelays = this.options.retryDelays;

      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== "[object Array]") {
        this._emitError(new Error("tus: the `retryDelays` option must either be an array or null"));

        return;
      }

      if (this.options.parallelUploads > 1) {
        // Test which options are incompatible with parallel uploads.
        ["uploadUrl", "uploadSize", "uploadLengthDeferred"].forEach(function (optionName) {
          if (_this2.options[optionName]) {
            _this2._emitError(new Error("tus: cannot use the ".concat(optionName, " option when parallelUploads is enabled")));
          }
        });
      }

      this.options.fingerprint(file, this.options).then(function (fingerprint) {
        if (fingerprint == null) {
          (0, _logger.log)("No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.");
        } else {
          (0, _logger.log)("Calculated fingerprint: ".concat(fingerprint));
        }

        _this2._fingerprint = fingerprint;

        if (_this2._source) {
          return _this2._source;
        } else {
          return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);
        }
      }).then(function (source) {
        _this2._source = source; // If the upload was configured to use multiple requests or if we resume from
        // an upload which used multiple requests, we start a parallel upload.

        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {
          _this2._startParallelUpload();
        } else {
          _this2._startSingleUpload();
        }
      })["catch"](function (err) {
        _this2._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a parallelized upload, where one file is split into
     * multiple request which are run in parallel.
     *
     * @api private
     */

  }, {
    key: "_startParallelUpload",
    value: function _startParallelUpload() {
      var _this3 = this;

      var totalSize = this._size = this._source.size;
      var totalProgress = 0;
      this._parallelUploads = [];
      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads; // The input file will be split into multiple slices which are uploaded in separate
      // requests. Here we generate the start and end position for the slices.

      var parts = splitSizeIntoParts(this._source.size, partCount, this._parallelUploadUrls); // Create an empty list for storing the upload URLs

      this._parallelUploadUrls = new Array(parts.length); // Generate a promise for each slice that will be resolve if the respective
      // upload is completed.

      var uploads = parts.map(function (part, index) {
        var lastPartProgress = 0;
        return _this3._source.slice(part.start, part.end).then(function (_ref) {
          var value = _ref.value;
          return new Promise(function (resolve, reject) {
            // Merge with the user supplied options but overwrite some values.
            var options = _objectSpread({}, _this3.options, {
              // If available, the partial upload should be resumed from a previous URL.
              uploadUrl: part.uploadUrl || null,
              // We take manually care of resuming for partial uploads, so they should
              // not be stored in the URL storage.
              storeFingerprintForResuming: false,
              removeFingerprintOnSuccess: false,
              // Reset the parallelUploads option to not cause recursion.
              parallelUploads: 1,
              metadata: {},
              // Add the header to indicate the this is a partial upload.
              headers: _objectSpread({}, _this3.options.headers, {
                "Upload-Concat": "partial"
              }),
              // Reject or resolve the promise if the upload errors or completes.
              onSuccess: resolve,
              onError: reject,
              // Based in the progress for this partial upload, calculate the progress
              // for the entire final upload.
              onProgress: function onProgress(newPartProgress) {
                totalProgress = totalProgress - lastPartProgress + newPartProgress;
                lastPartProgress = newPartProgress;

                _this3._emitProgress(totalProgress, totalSize);
              },
              // Wait until every partial upload has an upload URL, so we can add
              // them to the URL storage.
              _onUploadUrlAvailable: function _onUploadUrlAvailable() {
                _this3._parallelUploadUrls[index] = upload.url; // Test if all uploads have received an URL

                if (_this3._parallelUploadUrls.filter(function (u) {
                  return !!u;
                }).length === parts.length) {
                  _this3._saveUploadInUrlStorage();
                }
              }
            });

            var upload = new BaseUpload(value, options);
            upload.start(); // Store the upload in an array, so we can later abort them if necessary.

            _this3._parallelUploads.push(upload);
          });
        });
      });
      var req; // Wait until all partial uploads are finished and we can send the POST request for
      // creating the final upload.

      Promise.all(uploads).then(function () {
        req = _this3._openRequest("POST", _this3.options.endpoint);
        req.setHeader("Upload-Concat", "final;".concat(_this3._parallelUploadUrls.join(" "))); // Add metadata if values have been added

        var metadata = encodeMetadata(_this3.options.metadata);

        if (metadata !== "") {
          req.setHeader("Upload-Metadata", metadata);
        }

        return _this3._sendRequest(req, null);
      }).then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this3._emitHttpError(req, res, "tus: unexpected response while creating upload");

          return;
        }

        var location = res.getHeader("Location");

        if (location == null) {
          _this3._emitHttpError(req, res, "tus: invalid or missing Location header");

          return;
        }

        _this3.url = resolveUrl(_this3.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this3.url));

        _this3._emitSuccess();
      })["catch"](function (err) {
        _this3._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is
     * uploaded in a sequential matter.
     *
     * @api private
     */

  }, {
    key: "_startSingleUpload",
    value: function _startSingleUpload() {
      // First, we look at the uploadLengthDeferred option.
      // Next, we check if the caller has supplied a manual upload size.
      // Finally, we try to use the calculated size from the source object.
      if (this.options.uploadLengthDeferred) {
        this._size = null;
      } else if (this.options.uploadSize != null) {
        this._size = +this.options.uploadSize;

        if (isNaN(this._size)) {
          this._emitError(new Error("tus: cannot convert `uploadSize` option into a number"));

          return;
        }
      } else {
        this._size = this._source.size;

        if (this._size == null) {
          this._emitError(new Error("tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option"));

          return;
        }
      } // Reset the aborted flag when the upload is started or else the
      // _performUpload will stop before sending a request if the upload has been
      // aborted previously.


      this._aborted = false; // The upload had been started previously and we should reuse this URL.

      if (this.url != null) {
        (0, _logger.log)("Resuming upload from previous URL: ".concat(this.url));

        this._resumeUpload();

        return;
      } // A URL has manually been specified, so we try to resume


      if (this.options.uploadUrl != null) {
        (0, _logger.log)("Resuming upload from provided URL: ".concat(this.options.url));
        this.url = this.options.uploadUrl;

        this._resumeUpload();

        return;
      } // An upload has not started for the file yet, so we start a new one


      (0, _logger.log)("Creating a new upload");

      this._createUpload();
    }
    /**
     * Abort any running request and stop the current upload. After abort is called, no event
     * handler will be invoked anymore. You can use the `start` method to resume the upload
     * again.
     * If `shouldTerminate` is true, the `terminate` function will be called to remove the
     * current upload from the server.
     *
     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.
     * @return {Promise} The Promise will be resolved/rejected when the requests finish.
     */

  }, {
    key: "abort",
    value: function abort(shouldTerminate, cb) {
      var _this4 = this;

      if (typeof cb === "function") {
        throw new Error("tus: the abort function does not accept a callback since v2 anymore; please use the returned Promise instead");
      } // Stop any parallel partial uploads, that have been started in _startParallelUploads.


      if (this._parallelUploads != null) {
        this._parallelUploads.forEach(function (upload) {
          upload.abort(shouldTerminate);
        });
      } // Stop any current running request.


      if (this._req !== null) {
        this._req.abort();

        this._source.close();
      }

      this._aborted = true; // Stop any timeout used for initiating a retry.

      if (this._retryTimeout != null) {
        clearTimeout(this._retryTimeout);
        this._retryTimeout = null;
      }

      if (!shouldTerminate || this.url == null) {
        return Promise.resolve();
      }

      return BaseUpload.terminate(this.url, this.options) // Remove entry from the URL storage since the upload URL is no longer valid.
      .then(function () {
        return _this4._removeFromUrlStorage();
      });
    }
  }, {
    key: "_emitHttpError",
    value: function _emitHttpError(req, res, message, causingErr) {
      this._emitError(new _error.default(message, causingErr, req, res));
    }
  }, {
    key: "_emitError",
    value: function _emitError(err) {
      var _this5 = this; // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.


      if (this._aborted) return; // Check if we should retry, when enabled, before sending the error to the user.

      if (this.options.retryDelays != null) {
        // We will reset the attempt counter if
        // - we were already able to connect to the server (offset != null) and
        // - we were able to upload a small chunk of data to the server
        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;

        if (shouldResetDelays) {
          this._retryAttempt = 0;
        }

        if (shouldRetry(err, this._retryAttempt, this.options)) {
          var delay = this.options.retryDelays[this._retryAttempt++];
          this._offsetBeforeRetry = this._offset;
          this._retryTimeout = setTimeout(function () {
            _this5.start();
          }, delay);
          return;
        }
      }

      if (typeof this.options.onError === "function") {
        this.options.onError(err);
      } else {
        throw err;
      }
    }
    /**
     * Publishes notification if the upload has been successfully completed.
     *
     * @api private
     */

  }, {
    key: "_emitSuccess",
    value: function _emitSuccess() {
      if (this.options.removeFingerprintOnSuccess) {
        // Remove stored fingerprint and corresponding endpoint. This causes
        // new uploads of the same file to be treated as a different file.
        this._removeFromUrlStorage();
      }

      if (typeof this.options.onSuccess === "function") {
        this.options.onSuccess();
      }
    }
    /**
     * Publishes notification when data has been sent to the server. This
     * data may not have been accepted by the server yet.
     *
     * @param {number} bytesSent  Number of bytes sent to the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitProgress",
    value: function _emitProgress(bytesSent, bytesTotal) {
      if (typeof this.options.onProgress === "function") {
        this.options.onProgress(bytesSent, bytesTotal);
      }
    }
    /**
     * Publishes notification when a chunk of data has been sent to the server
     * and accepted by the server.
     * @param {number} chunkSize  Size of the chunk that was accepted by the server.
     * @param {number} bytesAccepted Total number of bytes that have been
     *                                accepted by the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitChunkComplete",
    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
      if (typeof this.options.onChunkComplete === "function") {
        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
      }
    }
    /**
     * Create a new upload using the creation extension by sending a POST
     * request to the endpoint. After successful creation the file will be
     * uploaded
     *
     * @api private
     */

  }, {
    key: "_createUpload",
    value: function _createUpload() {
      var _this6 = this;

      if (!this.options.endpoint) {
        this._emitError(new Error("tus: unable to create upload because no endpoint is provided"));

        return;
      }

      var req = this._openRequest("POST", this.options.endpoint);

      if (this.options.uploadLengthDeferred) {
        req.setHeader("Upload-Defer-Length", 1);
      } else {
        req.setHeader("Upload-Length", this._size);
      } // Add metadata if values have been added


      var metadata = encodeMetadata(this.options.metadata);

      if (metadata !== "") {
        req.setHeader("Upload-Metadata", metadata);
      }

      var promise;

      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {
        this._offset = 0;
        promise = this._addChunkToRequest(req);
      } else {
        promise = this._sendRequest(req, null);
      }

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this6._emitHttpError(req, res, "tus: unexpected response while creating upload");

          return;
        }

        var location = res.getHeader("Location");

        if (location == null) {
          _this6._emitHttpError(req, res, "tus: invalid or missing Location header");

          return;
        }

        _this6.url = resolveUrl(_this6.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this6.url));

        if (typeof _this6.options._onUploadUrlAvailable === "function") {
          _this6.options._onUploadUrlAvailable();
        }

        if (_this6._size === 0) {
          // Nothing to upload and file was successfully created
          _this6._emitSuccess();

          _this6._source.close();

          return;
        }

        _this6._saveUploadInUrlStorage();

        if (_this6.options.uploadDataDuringCreation) {
          _this6._handleUploadResponse(req, res);
        } else {
          _this6._offset = 0;

          _this6._performUpload();
        }
      })["catch"](function (err) {
        _this6._emitHttpError(req, null, "tus: failed to create upload", err);
      });
    }
    /*
     * Try to resume an existing upload. First a HEAD request will be sent
     * to retrieve the offset. If the request fails a new upload will be
     * created. In the case of a successful response the file will be uploaded.
     *
     * @api private
     */

  }, {
    key: "_resumeUpload",
    value: function _resumeUpload() {
      var _this7 = this;

      var req = this._openRequest("HEAD", this.url);

      var promise = this._sendRequest(req, null);

      promise.then(function (res) {
        var status = res.getStatus();

        if (!inStatusCategory(status, 200)) {
          if (inStatusCategory(status, 400)) {
            // Remove stored fingerprint and corresponding endpoint,
            // on client errors since the file can not be found
            _this7._removeFromUrlStorage();
          } // If the upload is locked (indicated by the 423 Locked status code), we
          // emit an error instead of directly starting a new upload. This way the
          // retry logic can catch the error and will retry the upload. An upload
          // is usually locked for a short period of time and will be available
          // afterwards.


          if (status === 423) {
            _this7._emitHttpError(req, res, "tus: upload is currently locked; retry later");

            return;
          }

          if (!_this7.options.endpoint) {
            // Don't attempt to create a new upload if no endpoint is provided.
            _this7._emitHttpError(req, res, "tus: unable to resume upload (new upload cannot be created without an endpoint)");

            return;
          } // Try to create a new upload


          _this7.url = null;

          _this7._createUpload();

          return;
        }

        var offset = parseInt(res.getHeader("Upload-Offset"), 10);

        if (isNaN(offset)) {
          _this7._emitHttpError(req, res, "tus: invalid or missing offset value");

          return;
        }

        var length = parseInt(res.getHeader("Upload-Length"), 10);

        if (isNaN(length) && !_this7.options.uploadLengthDeferred) {
          _this7._emitHttpError(req, res, "tus: invalid or missing length value");

          return;
        }

        if (typeof _this7.options._onUploadUrlAvailable === "function") {
          _this7.options._onUploadUrlAvailable();
        } // Upload has already been completed and we do not need to send additional
        // data to the server


        if (offset === length) {
          _this7._emitProgress(length, length);

          _this7._emitSuccess();

          return;
        }

        _this7._offset = offset;

        _this7._performUpload();
      })["catch"](function (err) {
        _this7._emitHttpError(req, null, "tus: failed to resume upload", err);
      });
    }
    /**
     * Start uploading the file using PATCH requests. The file will be divided
     * into chunks as specified in the chunkSize option. During the upload
     * the onProgress event handler may be invoked multiple times.
     *
     * @api private
     */

  }, {
    key: "_performUpload",
    value: function _performUpload() {
      var _this8 = this; // If the upload has been aborted, we will not send the next PATCH request.
      // This is important if the abort method was called during a callback, such
      // as onChunkComplete or onProgress.


      if (this._aborted) {
        return;
      }

      var req; // Some browser and servers may not support the PATCH method. For those
      // cases, you can tell tus-js-client to use a POST request with the
      // X-HTTP-Method-Override header for simulating a PATCH request.

      if (this.options.overridePatchMethod) {
        req = this._openRequest("POST", this.url);
        req.setHeader("X-HTTP-Method-Override", "PATCH");
      } else {
        req = this._openRequest("PATCH", this.url);
      }

      req.setHeader("Upload-Offset", this._offset);

      var promise = this._addChunkToRequest(req);

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this8._emitHttpError(req, res, "tus: unexpected response while uploading chunk");

          return;
        }

        _this8._handleUploadResponse(req, res);
      })["catch"](function (err) {
        // Don't emit an error if the upload was aborted manually
        if (_this8._aborted) {
          return;
        }

        _this8._emitHttpError(req, null, "tus: failed to upload chunk at offset " + _this8._offset, err);
      });
    }
    /**
     * _addChunktoRequest reads a chunk from the source and sends it using the
     * supplied request object. It will not handle the response.
     *
     * @api private
     */

  }, {
    key: "_addChunkToRequest",
    value: function _addChunkToRequest(req) {
      var _this9 = this;

      var start = this._offset;
      var end = this._offset + this.options.chunkSize;
      req.setProgressHandler(function (bytesSent) {
        _this9._emitProgress(start + bytesSent, _this9._size);
      });
      req.setHeader("Content-Type", "application/offset+octet-stream"); // The specified chunkSize may be Infinity or the calcluated end position
      // may exceed the file's size. In both cases, we limit the end position to
      // the input's total size for simpler calculations and correctness.

      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {
        end = this._size;
      }

      return this._source.slice(start, end).then(function (_ref2) {
        var value = _ref2.value,
            done = _ref2.done; // If the upload length is deferred, the upload size was not specified during
        // upload creation. So, if the file reader is done reading, we know the total
        // upload size and can tell the tus server.

        if (_this9.options.uploadLengthDeferred && done) {
          _this9._size = _this9._offset + (value && value.size ? value.size : 0);
          req.setHeader("Upload-Length", _this9._size);
        }

        if (value === null) {
          return _this9._sendRequest(req);
        } else {
          _this9._emitProgress(_this9._offset, _this9._size);

          return _this9._sendRequest(req, value);
        }
      });
    }
    /**
     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest
     * and already have received a response.
     *
     * @api private
     */

  }, {
    key: "_handleUploadResponse",
    value: function _handleUploadResponse(req, res) {
      var offset = parseInt(res.getHeader("Upload-Offset"), 10);

      if (isNaN(offset)) {
        this._emitHttpError(req, res, "tus: invalid or missing offset value");

        return;
      }

      this._emitProgress(offset, this._size);

      this._emitChunkComplete(offset - this._offset, offset, this._size);

      this._offset = offset;

      if (offset == this._size) {
        // Yay, finally done :)
        this._emitSuccess();

        this._source.close();

        return;
      }

      this._performUpload();
    }
    /**
     * Create a new HTTP request object with the given method and URL.
     *
     * @api private
     */

  }, {
    key: "_openRequest",
    value: function _openRequest(method, url) {
      var req = openRequest(method, url, this.options);
      this._req = req;
      return req;
    }
    /**
     * Remove the entry in the URL storage, if it has been saved before.
     *
     * @api private
     */

  }, {
    key: "_removeFromUrlStorage",
    value: function _removeFromUrlStorage() {
      var _this10 = this;

      if (!this._urlStorageKey) return;

      this._urlStorage.removeUpload(this._urlStorageKey)["catch"](function (err) {
        _this10._emitError(err);
      });

      this._urlStorageKey = null;
    }
    /**
     * Add the upload URL to the URL storage, if possible.
     *
     * @api private
     */

  }, {
    key: "_saveUploadInUrlStorage",
    value: function _saveUploadInUrlStorage() {
      var _this11 = this; // Only if a fingerprint was calculated for the input (i.e. not a stream), we can store the upload URL.


      if (!this.options.storeFingerprintForResuming || !this._fingerprint) {
        return;
      }

      var storedUpload = {
        size: this._size,
        metadata: this.options.metadata,
        creationTime: new Date().toString()
      };

      if (this._parallelUploads) {
        // Save multiple URLs if the parallelUploads option is used ...
        storedUpload.parallelUploadUrls = this._parallelUploadUrls;
      } else {
        // ... otherwise we just save the one available URL.
        storedUpload.uploadUrl = this.url;
      }

      this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function (urlStorageKey) {
        return _this11._urlStorageKey = urlStorageKey;
      })["catch"](function (err) {
        _this11._emitError(err);
      });
    }
    /**
     * Send a request with the provided body while invoking the onBeforeRequest
     * and onAfterResponse callbacks.
     *
     * @api private
     */

  }, {
    key: "_sendRequest",
    value: function _sendRequest(req) {
      var _this12 = this;

      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (typeof this.options.onBeforeRequest === "function") {
        this.options.onBeforeRequest(req);
      }

      return req.send(body).then(function (res) {
        if (typeof _this12.options.onAfterResponse === "function") {
          _this12.options.onAfterResponse(req, res);
        }

        return res;
      });
    }
  }], [{
    key: "terminate",
    value: function terminate(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cb = arguments.length > 2 ? arguments[2] : undefined;

      if (typeof options === "function" || typeof cb === "function") {
        throw new Error("tus: the terminate function does not accept a callback since v2 anymore; please use the returned Promise instead");
      }

      var req = openRequest("DELETE", url, options);
      var promise = req.send();
      return promise.then(function (res) {
        // A 204 response indicates a successfull request
        if (res.getStatus() === 204) {
          return;
        }

        throw new _error.default("tus: unexpected response while terminating upload", null, req, res);
      })["catch"](function (err) {
        if (!(err instanceof _error.default)) {
          err = new _error.default("tus: failed to terminate upload", err, req, null);
        }

        if (!shouldRetry(err, 0, options)) {
          throw err;
        } // Instead of keeping track of the retry attempts, we remove the first element from the delays
        // array. If the array is empty, all retry attempts are used up and we will bubble up the error.
        // We recursively call the terminate function will removing elements from the retryDelays array.


        var delay = options.retryDelays[0];
        var remainingDelays = options.retryDelays.slice(1);

        var newOptions = _objectSpread({}, options, {
          retryDelays: remainingDelays
        });

        return new Promise(function (resolve) {
          return setTimeout(resolve, delay);
        }).then(function () {
          return BaseUpload.terminate(url, newOptions);
        });
      });
    }
  }]);

  return BaseUpload;
}();

function encodeMetadata(metadata) {
  var encoded = [];

  for (var key in metadata) {
    encoded.push(key + " " + _jsBase.Base64.encode(metadata[key]));
  }

  return encoded.join(",");
}
/**
 * Checks whether a given status is in the range of the expected category.
 * For example, only a status between 200 and 299 will satisfy the category 200.
 *
 * @api private
 */


function inStatusCategory(status, category) {
  return status >= category && status < category + 100;
}
/**
 * Create a new HTTP request with the specified method and URL.
 * The necessary headers that are included in every request
 * will be added, including the request ID.
 *
 * @api private
 */


function openRequest(method, url, options) {
  var req = options.httpStack.createRequest(method, url);
  req.setHeader("Tus-Resumable", "1.0.0");
  var headers = options.headers || {};

  for (var name in headers) {
    req.setHeader(name, headers[name]);
  }

  if (options.addRequestId) {
    var requestId = (0, _uuid.default)();
    req.setHeader("X-Request-ID", requestId);
  }

  return req;
}
/**
 * Checks whether the browser running this code has internet access.
 * This function will always return true in the node.js environment
 *
 * @api private
 */


function isOnline() {
  var online = true;

  if (typeof window !== "undefined" && "navigator" in window && window.navigator.onLine === false) {
    online = false;
  }

  return online;
}
/**
 * Checks whether or not it is ok to retry a request.
 * @param {Error} err the error returned from the last request
 * @param {number} retryAttempt the number of times the request has already been retried
 * @param {object} options tus Upload options
 *
 * @api private
 */


function shouldRetry(err, retryAttempt, options) {
  // We only attempt a retry if
  // - retryDelays option is set
  // - we didn't exceed the maxium number of retries, yet, and
  // - this error was caused by a request or it's response and
  // - the error is server error (i.e. no a status 4xx or a 409 or 423) and
  // - the browser does not indicate that we are offline
  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;
  var isServerError = !inStatusCategory(status, 400) || status === 409 || status === 423;
  return options.retryDelays != null && retryAttempt < options.retryDelays.length && err.originalRequest != null && isServerError && isOnline();
}
/**
 * Resolve a relative link given the origin as source. For example,
 * if a HTTP request to http://example.com/files/ returns a Location
 * header with the value /upload/abc, the resolved URL will be:
 * http://example.com/upload/abc
 */


function resolveUrl(origin, link) {
  return new _urlParse.default(link, origin).toString();
}
/**
 * Calculate the start and end positions for the parts if an upload
 * is split into multiple parallel requests.
 *
 * @param {number} totalSize The byte size of the upload, which will be split.
 * @param {number} partCount The number in how many parts the upload will be split.
 * @param {string[]} previousUrls The upload URLs for previous parts.
 * @return {object[]}
 * @api private
 */


function splitSizeIntoParts(totalSize, partCount, previousUrls) {
  var partSize = Math.floor(totalSize / partCount);
  var parts = [];

  for (var i = 0; i < partCount; i++) {
    parts.push({
      start: partSize * i,
      end: partSize * (i + 1)
    });
  }

  parts[partCount - 1].end = totalSize; // Attach URLs from previous uploads, if available.

  if (previousUrls) {
    parts.forEach(function (part, index) {
      part.uploadUrl = previousUrls[index] || null;
    });
  }

  return parts;
}

BaseUpload.defaultOptions = defaultOptions;
var _default = BaseUpload;
exports.default = _default;
},{"./error":54,"./logger":55,"./uuid":58,"js-base64":30,"url-parse":59}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = uuid;

/**
 * Generate a UUID v4 based on random numbers. We intentioanlly use the less
 * secure Math.random function here since the more secure crypto.getRandomNumbers
 * is not available on all platforms.
 * This is not a problem for us since we use the UUID only for generating a
 * request ID, so we can correlate server logs to client errors.
 *
 * This function is taken from following site:
 * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 *
 * @return {string} The generate UUID
 */
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == "x" ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
},{}],59:[function(require,module,exports){
(function (global){(function (){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:[\\/]+/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?([\\/]{1,})?([\S\s]*)/i
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  address = trimLeft(address);

  var match = protocolre.exec(address)
    , protocol = match[1] ? match[1].toLowerCase() : ''
    , slashes = !!(match[2] && match[2].length >= 2)
    , rest =  match[2] && match[2].length === 1 ? '/' + match[3] : match[3];

  return {
    protocol: protocol,
    slashes: slashes,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && url.hostname) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":39,"requires-port":41}],60:[function(require,module,exports){
/* jshint node: true */
'use strict';

/**
  # wildcard

  Very simple wildcard matching, which is designed to provide the same
  functionality that is found in the
  [eve](https://github.com/adobe-webplatform/eve) eventing library.

  ## Usage

  It works with strings:

  <<< examples/strings.js

  Arrays:

  <<< examples/arrays.js

  Objects (matching against keys):

  <<< examples/objects.js

  While the library works in Node, if you are are looking for file-based
  wildcard matching then you should have a look at:

  <https://github.com/isaacs/node-glob>
**/

function WildcardMatcher(text, separator) {
  this.text = text = text || '';
  this.hasWild = ~text.indexOf('*');
  this.separator = separator;
  this.parts = text.split(separator);
}

WildcardMatcher.prototype.match = function(input) {
  var matches = true;
  var parts = this.parts;
  var ii;
  var partsCount = parts.length;
  var testParts;

  if (typeof input == 'string' || input instanceof String) {
    if (!this.hasWild && this.text != input) {
      matches = false;
    } else {
      testParts = (input || '').split(this.separator);
      for (ii = 0; matches && ii < partsCount; ii++) {
        if (parts[ii] === '*')  {
          continue;
        } else if (ii < testParts.length) {
          matches = parts[ii] === testParts[ii];
        } else {
          matches = false;
        }
      }

      // If matches, then return the component parts
      matches = matches && testParts;
    }
  }
  else if (typeof input.splice == 'function') {
    matches = [];

    for (ii = input.length; ii--; ) {
      if (this.match(input[ii])) {
        matches[matches.length] = input[ii];
      }
    }
  }
  else if (typeof input == 'object') {
    matches = {};

    for (var key in input) {
      if (this.match(key)) {
        matches[key] = input[key];
      }
    }
  }

  return matches;
};

module.exports = function(text, test, separator) {
  var matcher = new WildcardMatcher(text, separator || /[\/\.]/);
  if (typeof test != 'undefined') {
    return matcher.match(test);
  }

  return matcher;
};

},{}],61:[function(require,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}],62:[function(require,module,exports){
module.exports={
  "name": "@uppy/companion-client",
  "description": "Client library for communication with Companion. Intended for use in Uppy plugins.",
  "version": "1.10.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "companion",
    "provider"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "namespace-emitter": "^2.0.1",
    "qs-stringify": "^1.1.0",
    "url-parse": "^1.4.7"
  }
}

},{}],63:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var AuthError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(AuthError, _Error);

  function AuthError() {
    var _this;

    _this = _Error.call(this, 'Authorization required') || this;
    _this.name = 'AuthError';
    _this.isAuthError = true;
    return _this;
  }

  return AuthError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

module.exports = AuthError;

},{}],64:[function(require,module,exports){
'use strict';

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var qsStringify = require('qs-stringify');

var URL = require('url-parse');

var RequestClient = require('./RequestClient');

var tokenStorage = require('./tokenStorage');

var _getName = function _getName(id) {
  return id.split('-').map(function (s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }).join(' ');
};

module.exports = /*#__PURE__*/function (_RequestClient) {
  _inheritsLoose(Provider, _RequestClient);

  function Provider(uppy, opts) {
    var _this;

    _this = _RequestClient.call(this, uppy, opts) || this;
    _this.provider = opts.provider;
    _this.id = _this.provider;
    _this.name = _this.opts.name || _getName(_this.id);
    _this.pluginId = _this.opts.pluginId;
    _this.tokenKey = "companion-" + _this.pluginId + "-auth-token";
    _this.companionKeysParams = _this.opts.companionKeysParams;
    _this.preAuthToken = null;
    return _this;
  }

  var _proto = Provider.prototype;

  _proto.headers = function headers() {
    var _this2 = this;

    return Promise.all([_RequestClient.prototype.headers.call(this), this.getAuthToken()]).then(function (_ref) {
      var headers = _ref[0],
          token = _ref[1];
      var authHeaders = {};

      if (token) {
        authHeaders['uppy-auth-token'] = token;
      }

      if (_this2.companionKeysParams) {
        authHeaders['uppy-credentials-params'] = btoa(JSON.stringify({
          params: _this2.companionKeysParams
        }));
      }

      return _extends({}, headers, authHeaders);
    });
  };

  _proto.onReceiveResponse = function onReceiveResponse(response) {
    response = _RequestClient.prototype.onReceiveResponse.call(this, response);
    var plugin = this.uppy.getPlugin(this.pluginId);
    var oldAuthenticated = plugin.getPluginState().authenticated;
    var authenticated = oldAuthenticated ? response.status !== 401 : response.status < 400;
    plugin.setPluginState({
      authenticated: authenticated
    });
    return response;
  } // @todo(i.olarewaju) consider whether or not this method should be exposed
  ;

  _proto.setAuthToken = function setAuthToken(token) {
    return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, token);
  };

  _proto.getAuthToken = function getAuthToken() {
    return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey);
  };

  _proto.authUrl = function authUrl(queries) {
    if (queries === void 0) {
      queries = {};
    }

    if (this.preAuthToken) {
      queries.uppyPreAuthToken = this.preAuthToken;
    }

    var strigifiedQueries = qsStringify(queries);
    strigifiedQueries = strigifiedQueries ? "?" + strigifiedQueries : strigifiedQueries;
    return this.hostname + "/" + this.id + "/connect" + strigifiedQueries;
  };

  _proto.fileUrl = function fileUrl(id) {
    return this.hostname + "/" + this.id + "/get/" + id;
  };

  _proto.fetchPreAuthToken = function fetchPreAuthToken() {
    var _this3 = this;

    if (!this.companionKeysParams) {
      return Promise.resolve();
    }

    return this.post(this.id + "/preauth/", {
      params: this.companionKeysParams
    }).then(function (res) {
      _this3.preAuthToken = res.token;
    }).catch(function (err) {
      _this3.uppy.log("[CompanionClient] unable to fetch preAuthToken " + err, 'warning');
    });
  };

  _proto.list = function list(directory) {
    return this.get(this.id + "/list/" + (directory || ''));
  };

  _proto.logout = function logout() {
    var _this4 = this;

    return this.get(this.id + "/logout").then(function (response) {
      return Promise.all([response, _this4.uppy.getPlugin(_this4.pluginId).storage.removeItem(_this4.tokenKey)]);
    }).then(function (_ref2) {
      var response = _ref2[0];
      return response;
    });
  };

  Provider.initPlugin = function initPlugin(plugin, opts, defaultOpts) {
    plugin.type = 'acquirer';
    plugin.files = [];

    if (defaultOpts) {
      plugin.opts = _extends({}, defaultOpts, opts);
    }

    if (opts.serverUrl || opts.serverPattern) {
      throw new Error('`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`');
    }

    if (opts.companionAllowedHosts) {
      var pattern = opts.companionAllowedHosts; // validate companionAllowedHosts param

      if (typeof pattern !== 'string' && !Array.isArray(pattern) && !(pattern instanceof RegExp)) {
        throw new TypeError(plugin.id + ": the option \"companionAllowedHosts\" must be one of string, Array, RegExp");
      }

      plugin.opts.companionAllowedHosts = pattern;
    } else {
      // does not start with https://
      if (/^(?!https?:\/\/).*$/i.test(opts.companionUrl)) {
        plugin.opts.companionAllowedHosts = "https://" + opts.companionUrl.replace(/^\/\//, '');
      } else {
        plugin.opts.companionAllowedHosts = new URL(opts.companionUrl).origin;
      }
    }

    plugin.storage = plugin.opts.storage || tokenStorage;
  };

  return Provider;
}(RequestClient);

},{"./RequestClient":65,"./tokenStorage":69,"qs-stringify":38,"url-parse":59}],65:[function(require,module,exports){
'use strict';

var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AuthError = require('./AuthError');

var fetchWithNetworkError = require('./../../utils/lib/fetchWithNetworkError'); // Remove the trailing slash so we can always safely append /xyz.


function stripSlash(url) {
  return url.replace(/\/$/, '');
}

module.exports = (_temp = _class = /*#__PURE__*/function () {
  function RequestClient(uppy, opts) {
    this.uppy = uppy;
    this.opts = opts;
    this.onReceiveResponse = this.onReceiveResponse.bind(this);
    this.allowedHeaders = ['accept', 'content-type', 'uppy-auth-token'];
    this.preflightDone = false;
  }

  var _proto = RequestClient.prototype;

  _proto.headers = function headers() {
    var userHeaders = this.opts.companionHeaders || this.opts.serverHeaders || {};
    return Promise.resolve(_extends({}, this.defaultHeaders, userHeaders));
  };

  _proto._getPostResponseFunc = function _getPostResponseFunc(skip) {
    var _this = this;

    return function (response) {
      if (!skip) {
        return _this.onReceiveResponse(response);
      }

      return response;
    };
  };

  _proto.onReceiveResponse = function onReceiveResponse(response) {
    var state = this.uppy.getState();
    var companion = state.companion || {};
    var host = this.opts.companionUrl;
    var headers = response.headers; // Store the self-identified domain name for the Companion instance we just hit.

    if (headers.has('i-am') && headers.get('i-am') !== companion[host]) {
      var _extends2;

      this.uppy.setState({
        companion: _extends({}, companion, (_extends2 = {}, _extends2[host] = headers.get('i-am'), _extends2))
      });
    }

    return response;
  };

  _proto._getUrl = function _getUrl(url) {
    if (/^(https?:|)\/\//.test(url)) {
      return url;
    }

    return this.hostname + "/" + url;
  };

  _proto._json = function _json(res) {
    if (res.status === 401) {
      throw new AuthError();
    }

    if (res.status < 200 || res.status > 300) {
      var errMsg = "Failed request with status: " + res.status + ". " + res.statusText;
      return res.json().then(function (errData) {
        errMsg = errData.message ? errMsg + " message: " + errData.message : errMsg;
        errMsg = errData.requestId ? errMsg + " request-Id: " + errData.requestId : errMsg;
        throw new Error(errMsg);
      }).catch(function () {
        throw new Error(errMsg);
      });
    }

    return res.json();
  };

  _proto.preflight = function preflight(path) {
    var _this2 = this;

    if (this.preflightDone) {
      return Promise.resolve(this.allowedHeaders.slice());
    }

    return fetch(this._getUrl(path), {
      method: 'OPTIONS'
    }).then(function (response) {
      if (response.headers.has('access-control-allow-headers')) {
        _this2.allowedHeaders = response.headers.get('access-control-allow-headers').split(',').map(function (headerName) {
          return headerName.trim().toLowerCase();
        });
      }

      _this2.preflightDone = true;
      return _this2.allowedHeaders.slice();
    }).catch(function (err) {
      _this2.uppy.log("[CompanionClient] unable to make preflight request " + err, 'warning');

      _this2.preflightDone = true;
      return _this2.allowedHeaders.slice();
    });
  };

  _proto.preflightAndHeaders = function preflightAndHeaders(path) {
    var _this3 = this;

    return Promise.all([this.preflight(path), this.headers()]).then(function (_ref) {
      var allowedHeaders = _ref[0],
          headers = _ref[1];
      // filter to keep only allowed Headers
      Object.keys(headers).forEach(function (header) {
        if (allowedHeaders.indexOf(header.toLowerCase()) === -1) {
          _this3.uppy.log("[CompanionClient] excluding unallowed header " + header);

          delete headers[header];
        }
      });
      return headers;
    });
  };

  _proto.get = function get(path, skipPostResponse) {
    var _this4 = this;

    return this.preflightAndHeaders(path).then(function (headers) {
      return fetchWithNetworkError(_this4._getUrl(path), {
        method: 'get',
        headers: headers,
        credentials: _this4.opts.companionCookiesRule || 'same-origin'
      });
    }).then(this._getPostResponseFunc(skipPostResponse)).then(function (res) {
      return _this4._json(res);
    }).catch(function (err) {
      if (!err.isAuthError) {
        err.message = "Could not get " + _this4._getUrl(path) + ". " + err.message;
      }

      return Promise.reject(err);
    });
  };

  _proto.post = function post(path, data, skipPostResponse) {
    var _this5 = this;

    return this.preflightAndHeaders(path).then(function (headers) {
      return fetchWithNetworkError(_this5._getUrl(path), {
        method: 'post',
        headers: headers,
        credentials: _this5.opts.companionCookiesRule || 'same-origin',
        body: JSON.stringify(data)
      });
    }).then(this._getPostResponseFunc(skipPostResponse)).then(function (res) {
      return _this5._json(res);
    }).catch(function (err) {
      if (!err.isAuthError) {
        err.message = "Could not post " + _this5._getUrl(path) + ". " + err.message;
      }

      return Promise.reject(err);
    });
  };

  _proto.delete = function _delete(path, data, skipPostResponse) {
    var _this6 = this;

    return this.preflightAndHeaders(path).then(function (headers) {
      return fetchWithNetworkError(_this6.hostname + "/" + path, {
        method: 'delete',
        headers: headers,
        credentials: _this6.opts.companionCookiesRule || 'same-origin',
        body: data ? JSON.stringify(data) : null
      });
    }).then(this._getPostResponseFunc(skipPostResponse)).then(function (res) {
      return _this6._json(res);
    }).catch(function (err) {
      if (!err.isAuthError) {
        err.message = "Could not delete " + _this6._getUrl(path) + ". " + err.message;
      }

      return Promise.reject(err);
    });
  };

  _createClass(RequestClient, [{
    key: "hostname",
    get: function get() {
      var _this$uppy$getState = this.uppy.getState(),
          companion = _this$uppy$getState.companion;

      var host = this.opts.companionUrl;
      return stripSlash(companion && companion[host] ? companion[host] : host);
    }
  }, {
    key: "defaultHeaders",
    get: function get() {
      return {
        Accept: 'application/json',
        'Content-Type': 'application/json',
        'Uppy-Versions': "@uppy/companion-client=" + RequestClient.VERSION
      };
    }
  }]);

  return RequestClient;
}(), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":62,"./../../utils/lib/fetchWithNetworkError":216,"./AuthError":63}],66:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var RequestClient = require('./RequestClient');

var _getName = function _getName(id) {
  return id.split('-').map(function (s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }).join(' ');
};

module.exports = /*#__PURE__*/function (_RequestClient) {
  _inheritsLoose(SearchProvider, _RequestClient);

  function SearchProvider(uppy, opts) {
    var _this;

    _this = _RequestClient.call(this, uppy, opts) || this;
    _this.provider = opts.provider;
    _this.id = _this.provider;
    _this.name = _this.opts.name || _getName(_this.id);
    _this.pluginId = _this.opts.pluginId;
    return _this;
  }

  var _proto = SearchProvider.prototype;

  _proto.fileUrl = function fileUrl(id) {
    return this.hostname + "/search/" + this.id + "/get/" + id;
  };

  _proto.search = function search(text, queries) {
    queries = queries ? "&" + queries : '';
    return this.get("search/" + this.id + "/list?q=" + encodeURIComponent(text) + queries);
  };

  return SearchProvider;
}(RequestClient);

},{"./RequestClient":65}],67:[function(require,module,exports){
var ee = require('namespace-emitter');

module.exports = /*#__PURE__*/function () {
  function UppySocket(opts) {
    this.opts = opts;
    this._queued = [];
    this.isOpen = false;
    this.emitter = ee();
    this._handleMessage = this._handleMessage.bind(this);
    this.close = this.close.bind(this);
    this.emit = this.emit.bind(this);
    this.on = this.on.bind(this);
    this.once = this.once.bind(this);
    this.send = this.send.bind(this);

    if (!opts || opts.autoOpen !== false) {
      this.open();
    }
  }

  var _proto = UppySocket.prototype;

  _proto.open = function open() {
    var _this = this;

    this.socket = new WebSocket(this.opts.target);

    this.socket.onopen = function (e) {
      _this.isOpen = true;

      while (_this._queued.length > 0 && _this.isOpen) {
        var first = _this._queued[0];

        _this.send(first.action, first.payload);

        _this._queued = _this._queued.slice(1);
      }
    };

    this.socket.onclose = function (e) {
      _this.isOpen = false;
    };

    this.socket.onmessage = this._handleMessage;
  };

  _proto.close = function close() {
    if (this.socket) {
      this.socket.close();
    }
  };

  _proto.send = function send(action, payload) {
    // attach uuid
    if (!this.isOpen) {
      this._queued.push({
        action: action,
        payload: payload
      });

      return;
    }

    this.socket.send(JSON.stringify({
      action: action,
      payload: payload
    }));
  };

  _proto.on = function on(action, handler) {
    this.emitter.on(action, handler);
  };

  _proto.emit = function emit(action, payload) {
    this.emitter.emit(action, payload);
  };

  _proto.once = function once(action, handler) {
    this.emitter.once(action, handler);
  };

  _proto._handleMessage = function _handleMessage(e) {
    try {
      var message = JSON.parse(e.data);
      this.emit(message.action, message.payload);
    } catch (err) {
      console.log(err);
    }
  };

  return UppySocket;
}();

},{"namespace-emitter":36}],68:[function(require,module,exports){
'use strict';
/**
 * Manages communications with Companion
 */

var RequestClient = require('./RequestClient');

var Provider = require('./Provider');

var SearchProvider = require('./SearchProvider');

var Socket = require('./Socket');

module.exports = {
  RequestClient: RequestClient,
  Provider: Provider,
  SearchProvider: SearchProvider,
  Socket: Socket
};

},{"./Provider":64,"./RequestClient":65,"./SearchProvider":66,"./Socket":67}],69:[function(require,module,exports){
'use strict';
/**
 * This module serves as an Async wrapper for LocalStorage
 */

module.exports.setItem = function (key, value) {
  return new Promise(function (resolve) {
    localStorage.setItem(key, value);
    resolve();
  });
};

module.exports.getItem = function (key) {
  return Promise.resolve(localStorage.getItem(key));
};

module.exports.removeItem = function (key) {
  return new Promise(function (resolve) {
    localStorage.removeItem(key);
    resolve();
  });
};

},{}],70:[function(require,module,exports){
!function() {
    'use strict';
    function VNode() {}
    function h(nodeName, attributes) {
        var lastSimple, child, simple, i, children = EMPTY_CHILDREN;
        for (i = arguments.length; i-- > 2; ) stack.push(arguments[i]);
        if (attributes && null != attributes.children) {
            if (!stack.length) stack.push(attributes.children);
            delete attributes.children;
        }
        while (stack.length) if ((child = stack.pop()) && void 0 !== child.pop) for (i = child.length; i--; ) stack.push(child[i]); else {
            if ('boolean' == typeof child) child = null;
            if (simple = 'function' != typeof nodeName) if (null == child) child = ''; else if ('number' == typeof child) child = String(child); else if ('string' != typeof child) simple = !1;
            if (simple && lastSimple) children[children.length - 1] += child; else if (children === EMPTY_CHILDREN) children = [ child ]; else children.push(child);
            lastSimple = simple;
        }
        var p = new VNode();
        p.nodeName = nodeName;
        p.children = children;
        p.attributes = null == attributes ? void 0 : attributes;
        p.key = null == attributes ? void 0 : attributes.key;
        if (void 0 !== options.vnode) options.vnode(p);
        return p;
    }
    function extend(obj, props) {
        for (var i in props) obj[i] = props[i];
        return obj;
    }
    function cloneElement(vnode, props) {
        return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
    }
    function enqueueRender(component) {
        if (!component.__d && (component.__d = !0) && 1 == items.push(component)) (options.debounceRendering || defer)(rerender);
    }
    function rerender() {
        var p, list = items;
        items = [];
        while (p = list.pop()) if (p.__d) renderComponent(p);
    }
    function isSameNodeType(node, vnode, hydrating) {
        if ('string' == typeof vnode || 'number' == typeof vnode) return void 0 !== node.splitText;
        if ('string' == typeof vnode.nodeName) return !node._componentConstructor && isNamedNode(node, vnode.nodeName); else return hydrating || node._componentConstructor === vnode.nodeName;
    }
    function isNamedNode(node, nodeName) {
        return node.__n === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
    }
    function getNodeProps(vnode) {
        var props = extend({}, vnode.attributes);
        props.children = vnode.children;
        var defaultProps = vnode.nodeName.defaultProps;
        if (void 0 !== defaultProps) for (var i in defaultProps) if (void 0 === props[i]) props[i] = defaultProps[i];
        return props;
    }
    function createNode(nodeName, isSvg) {
        var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
        node.__n = nodeName;
        return node;
    }
    function removeNode(node) {
        var parentNode = node.parentNode;
        if (parentNode) parentNode.removeChild(node);
    }
    function setAccessor(node, name, old, value, isSvg) {
        if ('className' === name) name = 'class';
        if ('key' === name) ; else if ('ref' === name) {
            if (old) old(null);
            if (value) value(node);
        } else if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {
            if (!value || 'string' == typeof value || 'string' == typeof old) node.style.cssText = value || '';
            if (value && 'object' == typeof value) {
                if ('string' != typeof old) for (var i in old) if (!(i in value)) node.style[i] = '';
                for (var i in value) node.style[i] = 'number' == typeof value[i] && !1 === IS_NON_DIMENSIONAL.test(i) ? value[i] + 'px' : value[i];
            }
        } else if ('dangerouslySetInnerHTML' === name) {
            if (value) node.innerHTML = value.__html || '';
        } else if ('o' == name[0] && 'n' == name[1]) {
            var useCapture = name !== (name = name.replace(/Capture$/, ''));
            name = name.toLowerCase().substring(2);
            if (value) {
                if (!old) node.addEventListener(name, eventProxy, useCapture);
            } else node.removeEventListener(name, eventProxy, useCapture);
            (node.__l || (node.__l = {}))[name] = value;
        } else if ('list' !== name && 'type' !== name && !isSvg && name in node) {
            setProperty(node, name, null == value ? '' : value);
            if (null == value || !1 === value) node.removeAttribute(name);
        } else {
            var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));
            if (null == value || !1 === value) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase()); else node.removeAttribute(name); else if ('function' != typeof value) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value); else node.setAttribute(name, value);
        }
    }
    function setProperty(node, name, value) {
        try {
            node[name] = value;
        } catch (e) {}
    }
    function eventProxy(e) {
        return this.__l[e.type](options.event && options.event(e) || e);
    }
    function flushMounts() {
        var c;
        while (c = mounts.pop()) {
            if (options.afterMount) options.afterMount(c);
            if (c.componentDidMount) c.componentDidMount();
        }
    }
    function diff(dom, vnode, context, mountAll, parent, componentRoot) {
        if (!diffLevel++) {
            isSvgMode = null != parent && void 0 !== parent.ownerSVGElement;
            hydrating = null != dom && !('__preactattr_' in dom);
        }
        var ret = idiff(dom, vnode, context, mountAll, componentRoot);
        if (parent && ret.parentNode !== parent) parent.appendChild(ret);
        if (!--diffLevel) {
            hydrating = !1;
            if (!componentRoot) flushMounts();
        }
        return ret;
    }
    function idiff(dom, vnode, context, mountAll, componentRoot) {
        var out = dom, prevSvgMode = isSvgMode;
        if (null == vnode || 'boolean' == typeof vnode) vnode = '';
        if ('string' == typeof vnode || 'number' == typeof vnode) {
            if (dom && void 0 !== dom.splitText && dom.parentNode && (!dom._component || componentRoot)) {
                if (dom.nodeValue != vnode) dom.nodeValue = vnode;
            } else {
                out = document.createTextNode(vnode);
                if (dom) {
                    if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                    recollectNodeTree(dom, !0);
                }
            }
            out.__preactattr_ = !0;
            return out;
        }
        var vnodeName = vnode.nodeName;
        if ('function' == typeof vnodeName) return buildComponentFromVNode(dom, vnode, context, mountAll);
        isSvgMode = 'svg' === vnodeName ? !0 : 'foreignObject' === vnodeName ? !1 : isSvgMode;
        vnodeName = String(vnodeName);
        if (!dom || !isNamedNode(dom, vnodeName)) {
            out = createNode(vnodeName, isSvgMode);
            if (dom) {
                while (dom.firstChild) out.appendChild(dom.firstChild);
                if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                recollectNodeTree(dom, !0);
            }
        }
        var fc = out.firstChild, props = out.__preactattr_, vchildren = vnode.children;
        if (null == props) {
            props = out.__preactattr_ = {};
            for (var a = out.attributes, i = a.length; i--; ) props[a[i].name] = a[i].value;
        }
        if (!hydrating && vchildren && 1 === vchildren.length && 'string' == typeof vchildren[0] && null != fc && void 0 !== fc.splitText && null == fc.nextSibling) {
            if (fc.nodeValue != vchildren[0]) fc.nodeValue = vchildren[0];
        } else if (vchildren && vchildren.length || null != fc) innerDiffNode(out, vchildren, context, mountAll, hydrating || null != props.dangerouslySetInnerHTML);
        diffAttributes(out, vnode.attributes, props);
        isSvgMode = prevSvgMode;
        return out;
    }
    function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
        var j, c, f, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren ? vchildren.length : 0;
        if (0 !== len) for (var i = 0; i < len; i++) {
            var _child = originalChildren[i], props = _child.__preactattr_, key = vlen && props ? _child._component ? _child._component.__k : props.key : null;
            if (null != key) {
                keyedLen++;
                keyed[key] = _child;
            } else if (props || (void 0 !== _child.splitText ? isHydrating ? _child.nodeValue.trim() : !0 : isHydrating)) children[childrenLen++] = _child;
        }
        if (0 !== vlen) for (var i = 0; i < vlen; i++) {
            vchild = vchildren[i];
            child = null;
            var key = vchild.key;
            if (null != key) {
                if (keyedLen && void 0 !== keyed[key]) {
                    child = keyed[key];
                    keyed[key] = void 0;
                    keyedLen--;
                }
            } else if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) if (void 0 !== children[j] && isSameNodeType(c = children[j], vchild, isHydrating)) {
                child = c;
                children[j] = void 0;
                if (j === childrenLen - 1) childrenLen--;
                if (j === min) min++;
                break;
            }
            child = idiff(child, vchild, context, mountAll);
            f = originalChildren[i];
            if (child && child !== dom && child !== f) if (null == f) dom.appendChild(child); else if (child === f.nextSibling) removeNode(f); else dom.insertBefore(child, f);
        }
        if (keyedLen) for (var i in keyed) if (void 0 !== keyed[i]) recollectNodeTree(keyed[i], !1);
        while (min <= childrenLen) if (void 0 !== (child = children[childrenLen--])) recollectNodeTree(child, !1);
    }
    function recollectNodeTree(node, unmountOnly) {
        var component = node._component;
        if (component) unmountComponent(component); else {
            if (null != node.__preactattr_ && node.__preactattr_.ref) node.__preactattr_.ref(null);
            if (!1 === unmountOnly || null == node.__preactattr_) removeNode(node);
            removeChildren(node);
        }
    }
    function removeChildren(node) {
        node = node.lastChild;
        while (node) {
            var next = node.previousSibling;
            recollectNodeTree(node, !0);
            node = next;
        }
    }
    function diffAttributes(dom, attrs, old) {
        var name;
        for (name in old) if ((!attrs || null == attrs[name]) && null != old[name]) setAccessor(dom, name, old[name], old[name] = void 0, isSvgMode);
        for (name in attrs) if (!('children' === name || 'innerHTML' === name || name in old && attrs[name] === ('value' === name || 'checked' === name ? dom[name] : old[name]))) setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
    }
    function collectComponent(component) {
        var name = component.constructor.name;
        (components[name] || (components[name] = [])).push(component);
    }
    function createComponent(Ctor, props, context) {
        var inst, list = components[Ctor.name];
        if (Ctor.prototype && Ctor.prototype.render) {
            inst = new Ctor(props, context);
            Component.call(inst, props, context);
        } else {
            inst = new Component(props, context);
            inst.constructor = Ctor;
            inst.render = doRender;
        }
        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {
            inst.__b = list[i].__b;
            list.splice(i, 1);
            break;
        }
        return inst;
    }
    function doRender(props, state, context) {
        return this.constructor(props, context);
    }
    function setComponentProps(component, props, opts, context, mountAll) {
        if (!component.__x) {
            component.__x = !0;
            if (component.__r = props.ref) delete props.ref;
            if (component.__k = props.key) delete props.key;
            if (!component.base || mountAll) {
                if (component.componentWillMount) component.componentWillMount();
            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);
            if (context && context !== component.context) {
                if (!component.__c) component.__c = component.context;
                component.context = context;
            }
            if (!component.__p) component.__p = component.props;
            component.props = props;
            component.__x = !1;
            if (0 !== opts) if (1 === opts || !1 !== options.syncComponentUpdates || !component.base) renderComponent(component, 1, mountAll); else enqueueRender(component);
            if (component.__r) component.__r(component);
        }
    }
    function renderComponent(component, opts, mountAll, isChild) {
        if (!component.__x) {
            var rendered, inst, cbase, props = component.props, state = component.state, context = component.context, previousProps = component.__p || props, previousState = component.__s || state, previousContext = component.__c || context, isUpdate = component.base, nextBase = component.__b, initialBase = isUpdate || nextBase, initialChildComponent = component._component, skip = !1;
            if (isUpdate) {
                component.props = previousProps;
                component.state = previousState;
                component.context = previousContext;
                if (2 !== opts && component.shouldComponentUpdate && !1 === component.shouldComponentUpdate(props, state, context)) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);
                component.props = props;
                component.state = state;
                component.context = context;
            }
            component.__p = component.__s = component.__c = component.__b = null;
            component.__d = !1;
            if (!skip) {
                rendered = component.render(props, state, context);
                if (component.getChildContext) context = extend(extend({}, context), component.getChildContext());
                var toUnmount, base, childComponent = rendered && rendered.nodeName;
                if ('function' == typeof childComponent) {
                    var childProps = getNodeProps(rendered);
                    inst = initialChildComponent;
                    if (inst && inst.constructor === childComponent && childProps.key == inst.__k) setComponentProps(inst, childProps, 1, context, !1); else {
                        toUnmount = inst;
                        component._component = inst = createComponent(childComponent, childProps, context);
                        inst.__b = inst.__b || nextBase;
                        inst.__u = component;
                        setComponentProps(inst, childProps, 0, context, !1);
                        renderComponent(inst, 1, mountAll, !0);
                    }
                    base = inst.base;
                } else {
                    cbase = initialBase;
                    toUnmount = initialChildComponent;
                    if (toUnmount) cbase = component._component = null;
                    if (initialBase || 1 === opts) {
                        if (cbase) cbase._component = null;
                        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, !0);
                    }
                }
                if (initialBase && base !== initialBase && inst !== initialChildComponent) {
                    var baseParent = initialBase.parentNode;
                    if (baseParent && base !== baseParent) {
                        baseParent.replaceChild(base, initialBase);
                        if (!toUnmount) {
                            initialBase._component = null;
                            recollectNodeTree(initialBase, !1);
                        }
                    }
                }
                if (toUnmount) unmountComponent(toUnmount);
                component.base = base;
                if (base && !isChild) {
                    var componentRef = component, t = component;
                    while (t = t.__u) (componentRef = t).base = base;
                    base._component = componentRef;
                    base._componentConstructor = componentRef.constructor;
                }
            }
            if (!isUpdate || mountAll) mounts.unshift(component); else if (!skip) {
                if (component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);
                if (options.afterUpdate) options.afterUpdate(component);
            }
            if (null != component.__h) while (component.__h.length) component.__h.pop().call(component);
            if (!diffLevel && !isChild) flushMounts();
        }
    }
    function buildComponentFromVNode(dom, vnode, context, mountAll) {
        var c = dom && dom._component, originalComponent = c, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);
        while (c && !isOwner && (c = c.__u)) isOwner = c.constructor === vnode.nodeName;
        if (c && isOwner && (!mountAll || c._component)) {
            setComponentProps(c, props, 3, context, mountAll);
            dom = c.base;
        } else {
            if (originalComponent && !isDirectOwner) {
                unmountComponent(originalComponent);
                dom = oldDom = null;
            }
            c = createComponent(vnode.nodeName, props, context);
            if (dom && !c.__b) {
                c.__b = dom;
                oldDom = null;
            }
            setComponentProps(c, props, 1, context, mountAll);
            dom = c.base;
            if (oldDom && dom !== oldDom) {
                oldDom._component = null;
                recollectNodeTree(oldDom, !1);
            }
        }
        return dom;
    }
    function unmountComponent(component) {
        if (options.beforeUnmount) options.beforeUnmount(component);
        var base = component.base;
        component.__x = !0;
        if (component.componentWillUnmount) component.componentWillUnmount();
        component.base = null;
        var inner = component._component;
        if (inner) unmountComponent(inner); else if (base) {
            if (base.__preactattr_ && base.__preactattr_.ref) base.__preactattr_.ref(null);
            component.__b = base;
            removeNode(base);
            collectComponent(component);
            removeChildren(base);
        }
        if (component.__r) component.__r(null);
    }
    function Component(props, context) {
        this.__d = !0;
        this.context = context;
        this.props = props;
        this.state = this.state || {};
    }
    function render(vnode, parent, merge) {
        return diff(merge, vnode, {}, !1, parent, !1);
    }
    var options = {};
    var stack = [];
    var EMPTY_CHILDREN = [];
    var defer = 'function' == typeof Promise ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;
    var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    var items = [];
    var mounts = [];
    var diffLevel = 0;
    var isSvgMode = !1;
    var hydrating = !1;
    var components = {};
    extend(Component.prototype, {
        setState: function(state, callback) {
            var s = this.state;
            if (!this.__s) this.__s = extend({}, s);
            extend(s, 'function' == typeof state ? state(s, this.props) : state);
            if (callback) (this.__h = this.__h || []).push(callback);
            enqueueRender(this);
        },
        forceUpdate: function(callback) {
            if (callback) (this.__h = this.__h || []).push(callback);
            renderComponent(this, 2);
        },
        render: function() {}
    });
    var preact = {
        h: h,
        createElement: h,
        cloneElement: cloneElement,
        Component: Component,
        render: render,
        rerender: rerender,
        options: options
    };
    if ('undefined' != typeof module) module.exports = preact; else self.preact = preact;
}();

},{}],71:[function(require,module,exports){
module.exports={
  "name": "@uppy/core",
  "description": "Core module for the extensible JavaScript file upload widget with support for drag&drop, resumable uploads, previews, restrictions, file processing/encoding, remote providers like Instagram, Dropbox, Google Drive, S3 and more :dog:",
  "version": "1.19.2",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@transloadit/prettier-bytes": "0.0.7",
    "@uppy/store-default": "file:../store-default",
    "@uppy/utils": "file:../utils",
    "cuid": "^2.1.1",
    "lodash.throttle": "^4.1.1",
    "mime-match": "^1.0.2",
    "namespace-emitter": "^2.0.1",
    "preact": "8.2.9"
  }
}

},{}],72:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var preact = require('preact');

var findDOMElement = require('./../../utils/lib/findDOMElement');
/**
 * Defer a frequent call to the microtask queue.
 */


function debounce(fn) {
  var calling = null;
  var latestArgs = null;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    latestArgs = args;

    if (!calling) {
      calling = Promise.resolve().then(function () {
        calling = null; // At this point `args` may be different from the most
        // recent state, if multiple calls happened since this task
        // was queued. So we use the `latestArgs`, which definitely
        // is the most recent call.

        return fn.apply(void 0, latestArgs);
      });
    }

    return calling;
  };
}
/**
 * Boilerplate that all Plugins share - and should not be used
 * directly. It also shows which methods final plugins should implement/override,
 * this deciding on structure.
 *
 * @param {object} main Uppy core object
 * @param {object} object with plugin options
 * @returns {Array|string} files or success/fail message
 */


module.exports = /*#__PURE__*/function () {
  function Plugin(uppy, opts) {
    this.uppy = uppy;
    this.opts = opts || {};
    this.update = this.update.bind(this);
    this.mount = this.mount.bind(this);
    this.install = this.install.bind(this);
    this.uninstall = this.uninstall.bind(this);
  }

  var _proto = Plugin.prototype;

  _proto.getPluginState = function getPluginState() {
    var _this$uppy$getState = this.uppy.getState(),
        plugins = _this$uppy$getState.plugins;

    return plugins[this.id] || {};
  };

  _proto.setPluginState = function setPluginState(update) {
    var _extends2;

    var _this$uppy$getState2 = this.uppy.getState(),
        plugins = _this$uppy$getState2.plugins;

    this.uppy.setState({
      plugins: _extends({}, plugins, (_extends2 = {}, _extends2[this.id] = _extends({}, plugins[this.id], update), _extends2))
    });
  };

  _proto.setOptions = function setOptions(newOpts) {
    this.opts = _extends({}, this.opts, newOpts);
    this.setPluginState(); // so that UI re-renders with new options
  };

  _proto.update = function update(state) {
    if (typeof this.el === 'undefined') {
      return;
    }

    if (this._updateUI) {
      this._updateUI(state);
    }
  } // Called after every state update, after everything's mounted. Debounced.
  ;

  _proto.afterUpdate = function afterUpdate() {}
  /**
   * Called when plugin is mounted, whether in DOM or into another plugin.
   * Needed because sometimes plugins are mounted separately/after `install`,
   * so this.el and this.parent might not be available in `install`.
   * This is the case with @uppy/react plugins, for example.
   */
  ;

  _proto.onMount = function onMount() {}
  /**
   * Check if supplied `target` is a DOM element or an `object`.
   * If its an object  target is a plugin, and we search `plugins`
   * for a plugin with same name and return its target.
   *
   * @param {string|object} target
   *
   */
  ;

  _proto.mount = function mount(target, plugin) {
    var _this = this;

    var callerPluginName = plugin.id;
    var targetElement = findDOMElement(target);

    if (targetElement) {
      this.isTargetDOMEl = true; // API for plugins that require a synchronous rerender.

      this.rerender = function (state) {
        // plugin could be removed, but this.rerender is debounced below,
        // so it could still be called even after uppy.removePlugin or uppy.close
        // hence the check
        if (!_this.uppy.getPlugin(_this.id)) return;
        _this.el = preact.render(_this.render(state), targetElement, _this.el);

        _this.afterUpdate();
      };

      this._updateUI = debounce(this.rerender);
      this.uppy.log("Installing " + callerPluginName + " to a DOM element '" + target + "'"); // clear everything inside the target container

      if (this.opts.replaceTargetContent) {
        targetElement.innerHTML = '';
      }

      this.el = preact.render(this.render(this.uppy.getState()), targetElement);
      this.onMount();
      return this.el;
    }

    var targetPlugin;

    if (typeof target === 'object' && target instanceof Plugin) {
      // Targeting a plugin *instance*
      targetPlugin = target;
    } else if (typeof target === 'function') {
      // Targeting a plugin type
      var Target = target; // Find the target plugin instance.

      this.uppy.iteratePlugins(function (plugin) {
        if (plugin instanceof Target) {
          targetPlugin = plugin;
          return false;
        }
      });
    }

    if (targetPlugin) {
      this.uppy.log("Installing " + callerPluginName + " to " + targetPlugin.id);
      this.parent = targetPlugin;
      this.el = targetPlugin.addTarget(plugin);
      this.onMount();
      return this.el;
    }

    this.uppy.log("Not installing " + callerPluginName);
    var message = "Invalid target option given to " + callerPluginName + ".";

    if (typeof target === 'function') {
      message += ' The given target is not a Plugin class. ' + 'Please check that you\'re not specifying a React Component instead of a plugin. ' + 'If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: ' + 'run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly.';
    } else {
      message += 'If you meant to target an HTML element, please make sure that the element exists. ' + 'Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. ' + '(see https://github.com/transloadit/uppy/issues/1042)\n\n' + 'If you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.';
    }

    throw new Error(message);
  };

  _proto.render = function render(state) {
    throw new Error('Extend the render method to add your plugin to a DOM element');
  };

  _proto.addTarget = function addTarget(plugin) {
    throw new Error('Extend the addTarget method to add your plugin to another plugin\'s target');
  };

  _proto.unmount = function unmount() {
    if (this.isTargetDOMEl && this.el && this.el.parentNode) {
      this.el.parentNode.removeChild(this.el);
    }
  };

  _proto.install = function install() {};

  _proto.uninstall = function uninstall() {
    this.unmount();
  };

  return Plugin;
}();

},{"./../../utils/lib/findDOMElement":218,"preact":70}],73:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* global AggregateError */
var Translator = require('./../../utils/lib/Translator');

var ee = require('namespace-emitter');

var cuid = require('cuid');

var throttle = require('lodash.throttle');

var prettierBytes = require('@transloadit/prettier-bytes');

var match = require('mime-match');

var DefaultStore = require('./../../store-default');

var getFileType = require('./../../utils/lib/getFileType');

var getFileNameAndExtension = require('./../../utils/lib/getFileNameAndExtension');

var generateFileID = require('./../../utils/lib/generateFileID');

var findIndex = require('./../../utils/lib/findIndex');

var supportsUploadProgress = require('./supportsUploadProgress');

var _require = require('./loggers'),
    justErrorsLogger = _require.justErrorsLogger,
    debugLogger = _require.debugLogger;

var Plugin = require('./Plugin');

var _require2 = require('../package.json'),
    version = _require2.version; // Exported from here.


var RestrictionError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(RestrictionError, _Error);

  function RestrictionError() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Error.call.apply(_Error, [this].concat(args)) || this;
    _this.isRestriction = true;
    return _this;
  }

  return RestrictionError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Uppy Core module.
 * Manages plugins, state updates, acts as an event bus,
 * adds/removes files and metadata.
 */


var Uppy = /*#__PURE__*/function () {
  /**
   * Instantiate Uppy
   *
   * @param {object} opts  Uppy options
   */
  function Uppy(opts) {
    var _this2 = this;

    this.defaultLocale = {
      strings: {
        addBulkFilesFailed: {
          0: 'Failed to add %{smart_count} file due to an internal error',
          1: 'Failed to add %{smart_count} files due to internal errors'
        },
        youCanOnlyUploadX: {
          0: 'You can only upload %{smart_count} file',
          1: 'You can only upload %{smart_count} files'
        },
        youHaveToAtLeastSelectX: {
          0: 'You have to select at least %{smart_count} file',
          1: 'You have to select at least %{smart_count} files'
        },
        // The default `exceedsSize2` string only combines the `exceedsSize` string (%{backwardsCompat}) with the size.
        // Locales can override `exceedsSize2` to specify a different word order. This is for backwards compat with
        // Uppy 1.9.x and below which did a naive concatenation of `exceedsSize2 + size` instead of using a locale-specific
        // substitution.
        // TODO: In 2.0 `exceedsSize2` should be removed in and `exceedsSize` updated to use substitution.
        exceedsSize2: '%{backwardsCompat} %{size}',
        exceedsSize: '%{file} exceeds maximum allowed size of',
        inferiorSize: 'This file is smaller than the allowed size of %{size}',
        youCanOnlyUploadFileTypes: 'You can only upload: %{types}',
        noNewAlreadyUploading: 'Cannot add new files: already uploading',
        noDuplicates: 'Cannot add the duplicate file \'%{fileName}\', it already exists',
        companionError: 'Connection with Companion failed',
        companionUnauthorizeHint: 'To unauthorize to your %{provider} account, please go to %{url}',
        failedToUpload: 'Failed to upload %{file}',
        noInternetConnection: 'No Internet connection',
        connectedToInternet: 'Connected to the Internet',
        // Strings for remote providers
        noFilesFound: 'You have no files or folders here',
        selectX: {
          0: 'Select %{smart_count}',
          1: 'Select %{smart_count}'
        },
        selectAllFilesFromFolderNamed: 'Select all files from folder %{name}',
        unselectAllFilesFromFolderNamed: 'Unselect all files from folder %{name}',
        selectFileNamed: 'Select file %{name}',
        unselectFileNamed: 'Unselect file %{name}',
        openFolderNamed: 'Open folder %{name}',
        cancel: 'Cancel',
        logOut: 'Log out',
        filter: 'Filter',
        resetFilter: 'Reset filter',
        loading: 'Loading...',
        authenticateWithTitle: 'Please authenticate with %{pluginName} to select files',
        authenticateWith: 'Connect to %{pluginName}',
        searchImages: 'Search for images',
        enterTextToSearch: 'Enter text to search for images',
        backToSearch: 'Back to Search',
        emptyFolderAdded: 'No files were added from empty folder',
        folderAdded: {
          0: 'Added %{smart_count} file from %{folder}',
          1: 'Added %{smart_count} files from %{folder}'
        }
      }
    };
    var defaultOptions = {
      id: 'uppy',
      autoProceed: false,
      allowMultipleUploads: true,
      debug: false,
      restrictions: {
        maxFileSize: null,
        minFileSize: null,
        maxTotalFileSize: null,
        maxNumberOfFiles: null,
        minNumberOfFiles: null,
        allowedFileTypes: null
      },
      meta: {},
      onBeforeFileAdded: function onBeforeFileAdded(currentFile) {
        return currentFile;
      },
      onBeforeUpload: function onBeforeUpload(files) {
        return files;
      },
      store: DefaultStore(),
      logger: justErrorsLogger,
      infoTimeout: 5000
    }; // Merge default options with the ones set by user,
    // making sure to merge restrictions too

    this.opts = _extends({}, defaultOptions, opts, {
      restrictions: _extends({}, defaultOptions.restrictions, opts && opts.restrictions)
    }); // Support debug: true for backwards-compatability, unless logger is set in opts
    // opts instead of this.opts to avoid comparing objects  we set logger: justErrorsLogger in defaultOptions

    if (opts && opts.logger && opts.debug) {
      this.log('You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.', 'warning');
    } else if (opts && opts.debug) {
      this.opts.logger = debugLogger;
    }

    this.log("Using Core v" + this.constructor.VERSION);

    if (this.opts.restrictions.allowedFileTypes && this.opts.restrictions.allowedFileTypes !== null && !Array.isArray(this.opts.restrictions.allowedFileTypes)) {
      throw new TypeError('`restrictions.allowedFileTypes` must be an array');
    }

    this.i18nInit(); // Container for different types of plugins

    this.plugins = {};
    this.getState = this.getState.bind(this);
    this.getPlugin = this.getPlugin.bind(this);
    this.setFileMeta = this.setFileMeta.bind(this);
    this.setFileState = this.setFileState.bind(this);
    this.log = this.log.bind(this);
    this.info = this.info.bind(this);
    this.hideInfo = this.hideInfo.bind(this);
    this.addFile = this.addFile.bind(this);
    this.removeFile = this.removeFile.bind(this);
    this.pauseResume = this.pauseResume.bind(this);
    this.validateRestrictions = this.validateRestrictions.bind(this); // ___Why throttle at 500ms?
    //    - We must throttle at >250ms for superfocus in Dashboard to work well
    //    (because animation takes 0.25s, and we want to wait for all animations to be over before refocusing).
    //    [Practical Check]: if thottle is at 100ms, then if you are uploading a file,
    //    and click 'ADD MORE FILES', - focus won't activate in Firefox.
    //    - We must throttle at around >500ms to avoid performance lags.
    //    [Practical Check] Firefox, try to upload a big file for a prolonged period of time. Laptop will start to heat up.

    this.calculateProgress = throttle(this.calculateProgress.bind(this), 500, {
      leading: true,
      trailing: true
    });
    this.updateOnlineStatus = this.updateOnlineStatus.bind(this);
    this.resetProgress = this.resetProgress.bind(this);
    this.pauseAll = this.pauseAll.bind(this);
    this.resumeAll = this.resumeAll.bind(this);
    this.retryAll = this.retryAll.bind(this);
    this.cancelAll = this.cancelAll.bind(this);
    this.retryUpload = this.retryUpload.bind(this);
    this.upload = this.upload.bind(this);
    this.emitter = ee();
    this.on = this.on.bind(this);
    this.off = this.off.bind(this);
    this.once = this.emitter.once.bind(this.emitter);
    this.emit = this.emitter.emit.bind(this.emitter);
    this.preProcessors = [];
    this.uploaders = [];
    this.postProcessors = [];
    this.store = this.opts.store;
    this.setState({
      plugins: {},
      files: {},
      currentUploads: {},
      allowNewUpload: true,
      capabilities: {
        uploadProgress: supportsUploadProgress(),
        individualCancellation: true,
        resumableUploads: false
      },
      totalProgress: 0,
      meta: _extends({}, this.opts.meta),
      info: {
        isHidden: true,
        type: 'info',
        message: ''
      },
      recoveredState: null
    });
    this.storeUnsubscribe = this.store.subscribe(function (prevState, nextState, patch) {
      _this2.emit('state-update', prevState, nextState, patch);

      _this2.updateAll(nextState);
    }); // Exposing uppy object on window for debugging and testing

    if (this.opts.debug && typeof window !== 'undefined') {
      window[this.opts.id] = this;
    }

    this.addListeners(); // Re-enable if well need some capabilities on boot, like isMobileDevice
    // this._setCapabilities()
  } // _setCapabilities = () => {
  //   const capabilities = {
  //     isMobileDevice: isMobileDevice()
  //   }
  //   this.setState({
  //     ...this.getState().capabilities,
  //     capabilities
  //   })
  // }


  var _proto = Uppy.prototype;

  _proto.on = function on(event, callback) {
    this.emitter.on(event, callback);
    return this;
  };

  _proto.off = function off(event, callback) {
    this.emitter.off(event, callback);
    return this;
  }
  /**
   * Iterate on all plugins and run `update` on them.
   * Called each time state changes.
   *
   */
  ;

  _proto.updateAll = function updateAll(state) {
    this.iteratePlugins(function (plugin) {
      plugin.update(state);
    });
  }
  /**
   * Updates state with a patch
   *
   * @param {object} patch {foo: 'bar'}
   */
  ;

  _proto.setState = function setState(patch) {
    this.store.setState(patch);
  }
  /**
   * Returns current state.
   *
   * @returns {object}
   */
  ;

  _proto.getState = function getState() {
    return this.store.getState();
  }
  /**
   * Back compat for when uppy.state is used instead of uppy.getState().
   */
  ;

  /**
   * Shorthand to set state for a specific file.
   */
  _proto.setFileState = function setFileState(fileID, state) {
    var _extends2;

    if (!this.getState().files[fileID]) {
      throw new Error("Can\u2019t set state for " + fileID + " (the file could have been removed)");
    }

    this.setState({
      files: _extends({}, this.getState().files, (_extends2 = {}, _extends2[fileID] = _extends({}, this.getState().files[fileID], state), _extends2))
    });
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.opts.locale]);
    this.locale = this.translator.locale;
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
  };

  _proto.setOptions = function setOptions(newOpts) {
    this.opts = _extends({}, this.opts, newOpts, {
      restrictions: _extends({}, this.opts.restrictions, newOpts && newOpts.restrictions)
    });

    if (newOpts.meta) {
      this.setMeta(newOpts.meta);
    }

    this.i18nInit();

    if (newOpts.locale) {
      this.iteratePlugins(function (plugin) {
        plugin.setOptions();
      });
    } // Note: this is not the preact `setState`, it's an internal function that has the same name.


    this.setState(); // so that UI re-renders with new options
  };

  _proto.resetProgress = function resetProgress() {
    var defaultProgress = {
      percentage: 0,
      bytesUploaded: 0,
      uploadComplete: false,
      uploadStarted: null
    };

    var files = _extends({}, this.getState().files);

    var updatedFiles = {};
    Object.keys(files).forEach(function (fileID) {
      var updatedFile = _extends({}, files[fileID]);

      updatedFile.progress = _extends({}, updatedFile.progress, defaultProgress);
      updatedFiles[fileID] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      totalProgress: 0
    });
    this.emit('reset-progress');
  };

  _proto.addPreProcessor = function addPreProcessor(fn) {
    this.preProcessors.push(fn);
  };

  _proto.removePreProcessor = function removePreProcessor(fn) {
    var i = this.preProcessors.indexOf(fn);

    if (i !== -1) {
      this.preProcessors.splice(i, 1);
    }
  };

  _proto.addPostProcessor = function addPostProcessor(fn) {
    this.postProcessors.push(fn);
  };

  _proto.removePostProcessor = function removePostProcessor(fn) {
    var i = this.postProcessors.indexOf(fn);

    if (i !== -1) {
      this.postProcessors.splice(i, 1);
    }
  };

  _proto.addUploader = function addUploader(fn) {
    this.uploaders.push(fn);
  };

  _proto.removeUploader = function removeUploader(fn) {
    var i = this.uploaders.indexOf(fn);

    if (i !== -1) {
      this.uploaders.splice(i, 1);
    }
  };

  _proto.setMeta = function setMeta(data) {
    var updatedMeta = _extends({}, this.getState().meta, data);

    var updatedFiles = _extends({}, this.getState().files);

    Object.keys(updatedFiles).forEach(function (fileID) {
      updatedFiles[fileID] = _extends({}, updatedFiles[fileID], {
        meta: _extends({}, updatedFiles[fileID].meta, data)
      });
    });
    this.log('Adding metadata:');
    this.log(data);
    this.setState({
      meta: updatedMeta,
      files: updatedFiles
    });
  };

  _proto.setFileMeta = function setFileMeta(fileID, data) {
    var updatedFiles = _extends({}, this.getState().files);

    if (!updatedFiles[fileID]) {
      this.log('Was trying to set metadata for a file that has been removed: ', fileID);
      return;
    }

    var newMeta = _extends({}, updatedFiles[fileID].meta, data);

    updatedFiles[fileID] = _extends({}, updatedFiles[fileID], {
      meta: newMeta
    });
    this.setState({
      files: updatedFiles
    });
  }
  /**
   * Get a file object.
   *
   * @param {string} fileID The ID of the file object to return.
   */
  ;

  _proto.getFile = function getFile(fileID) {
    return this.getState().files[fileID];
  }
  /**
   * Get all files in an array.
   */
  ;

  _proto.getFiles = function getFiles() {
    var _this$getState = this.getState(),
        files = _this$getState.files;

    return Object.keys(files).map(function (fileID) {
      return files[fileID];
    });
  }
  /**
   * A public wrapper for _checkRestrictions  checks if a file passes a set of restrictions.
   * For use in UI pluigins (like Providers), to disallow selecting files that wont pass restrictions.
   *
   * @param {object} file object to check
   * @param {Array} [files] array to check maxNumberOfFiles and maxTotalFileSize
   * @returns {object} { result: true/false, reason: why file didnt pass restrictions }
   */
  ;

  _proto.validateRestrictions = function validateRestrictions(file, files) {
    try {
      this.checkRestrictions(file, files);
      return {
        result: true
      };
    } catch (err) {
      return {
        result: false,
        reason: err.message
      };
    }
  }
  /**
   * Check if file passes a set of restrictions set in options: maxFileSize, minFileSize,
   * maxNumberOfFiles and allowedFileTypes.
   *
   * @param {object} file object to check
   * @param {Array} [files] array to check maxNumberOfFiles and maxTotalFileSize
   * @private
   */
  ;

  _proto.checkRestrictions = function checkRestrictions(file, files) {
    if (files === void 0) {
      files = this.getFiles();
    }

    var _this$opts$restrictio = this.opts.restrictions,
        maxFileSize = _this$opts$restrictio.maxFileSize,
        minFileSize = _this$opts$restrictio.minFileSize,
        maxTotalFileSize = _this$opts$restrictio.maxTotalFileSize,
        maxNumberOfFiles = _this$opts$restrictio.maxNumberOfFiles,
        allowedFileTypes = _this$opts$restrictio.allowedFileTypes;

    if (maxNumberOfFiles) {
      if (files.length + 1 > maxNumberOfFiles) {
        throw new RestrictionError("" + this.i18n('youCanOnlyUploadX', {
          smart_count: maxNumberOfFiles
        }));
      }
    }

    if (allowedFileTypes) {
      var isCorrectFileType = allowedFileTypes.some(function (type) {
        // check if this is a mime-type
        if (type.indexOf('/') > -1) {
          if (!file.type) return false;
          return match(file.type.replace(/;.*?$/, ''), type);
        } // otherwise this is likely an extension


        if (type[0] === '.' && file.extension) {
          return file.extension.toLowerCase() === type.substr(1).toLowerCase();
        }

        return false;
      });

      if (!isCorrectFileType) {
        var allowedFileTypesString = allowedFileTypes.join(', ');
        throw new RestrictionError(this.i18n('youCanOnlyUploadFileTypes', {
          types: allowedFileTypesString
        }));
      }
    } // We can't check maxTotalFileSize if the size is unknown.


    if (maxTotalFileSize && file.size != null) {
      var totalFilesSize = 0;
      totalFilesSize += file.size;
      files.forEach(function (f) {
        totalFilesSize += f.size;
      });

      if (totalFilesSize > maxTotalFileSize) {
        throw new RestrictionError(this.i18n('exceedsSize2', {
          backwardsCompat: this.i18n('exceedsSize'),
          size: prettierBytes(maxTotalFileSize),
          file: file.name
        }));
      }
    } // We can't check maxFileSize if the size is unknown.


    if (maxFileSize && file.size != null) {
      if (file.size > maxFileSize) {
        throw new RestrictionError(this.i18n('exceedsSize2', {
          backwardsCompat: this.i18n('exceedsSize'),
          size: prettierBytes(maxFileSize),
          file: file.name
        }));
      }
    } // We can't check minFileSize if the size is unknown.


    if (minFileSize && file.size != null) {
      if (file.size < minFileSize) {
        throw new RestrictionError(this.i18n('inferiorSize', {
          size: prettierBytes(minFileSize)
        }));
      }
    }
  }
  /**
   * Check if minNumberOfFiles restriction is reached before uploading.
   *
   * @private
   */
  ;

  _proto.checkMinNumberOfFiles = function checkMinNumberOfFiles(files) {
    var minNumberOfFiles = this.opts.restrictions.minNumberOfFiles;

    if (Object.keys(files).length < minNumberOfFiles) {
      throw new RestrictionError("" + this.i18n('youHaveToAtLeastSelectX', {
        smart_count: minNumberOfFiles
      }));
    }
  }
  /**
   * Logs an error, sets Informer message, then throws the error.
   * Emits a 'restriction-failed' event if its a restriction error
   *
   * @param {object | string} err  Error object or plain string message
   * @param {object} [options]
   * @param {boolean} [options.showInformer=true]  Sometimes developer might want to show Informer manually
   * @param {object} [options.file=null]  File object used to emit the restriction error
   * @param {boolean} [options.throwErr=true]  Errors shouldnt be thrown, for example, in `upload-error` event
   * @private
   */
  ;

  _proto.showOrLogErrorAndThrow = function showOrLogErrorAndThrow(err, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$showInformer = _ref.showInformer,
        showInformer = _ref$showInformer === void 0 ? true : _ref$showInformer,
        _ref$file = _ref.file,
        file = _ref$file === void 0 ? null : _ref$file,
        _ref$throwErr = _ref.throwErr,
        throwErr = _ref$throwErr === void 0 ? true : _ref$throwErr;

    var message = typeof err === 'object' ? err.message : err;
    var details = typeof err === 'object' && err.details ? err.details : ''; // Restriction errors should be logged, but not as errors,
    // as they are expected and shown in the UI.

    var logMessageWithDetails = message;

    if (details) {
      logMessageWithDetails += " " + details;
    }

    if (err.isRestriction) {
      this.log(logMessageWithDetails);
      this.emit('restriction-failed', file, err);
    } else {
      this.log(logMessageWithDetails, 'error');
    } // Sometimes informer has to be shown manually by the developer,
    // for example, in `onBeforeFileAdded`.


    if (showInformer) {
      this.info({
        message: message,
        details: details
      }, 'error', this.opts.infoTimeout);
    }

    if (throwErr) {
      throw typeof err === 'object' ? err : new Error(err);
    }
  };

  _proto.assertNewUploadAllowed = function assertNewUploadAllowed(file) {
    var _this$getState2 = this.getState(),
        allowNewUpload = _this$getState2.allowNewUpload;

    if (allowNewUpload === false) {
      this.showOrLogErrorAndThrow(new RestrictionError(this.i18n('noNewAlreadyUploading')), {
        file: file
      });
    }
  }
  /**
   * Create a file state object based on user-provided `addFile()` options.
   *
   * Note this is extremely side-effectful and should only be done when a file state object will be added to state immediately afterward!
   *
   * The `files` value is passed in because it may be updated by the caller without updating the store.
   */
  ;

  _proto.checkAndCreateFileStateObject = function checkAndCreateFileStateObject(files, f) {
    var fileType = getFileType(f);
    var file = f;
    file.type = fileType;
    var onBeforeFileAddedResult = this.opts.onBeforeFileAdded(file, files);

    if (onBeforeFileAddedResult === false) {
      // Dont show UI info for this error, as it should be done by the developer
      this.showOrLogErrorAndThrow(new RestrictionError('Cannot add the file because onBeforeFileAdded returned false.'), {
        showInformer: false,
        file: file
      });
    }

    if (typeof onBeforeFileAddedResult === 'object' && onBeforeFileAddedResult) {
      file = onBeforeFileAddedResult;
    }

    var fileName;

    if (file.name) {
      fileName = file.name;
    } else if (fileType.split('/')[0] === 'image') {
      fileName = fileType.split('/')[0] + "." + fileType.split('/')[1];
    } else {
      fileName = 'noname';
    }

    var fileExtension = getFileNameAndExtension(fileName).extension;
    var isRemote = file.isRemote || false;
    var fileID = generateFileID(file);

    if (files[fileID] && !files[fileID].isGhost) {
      this.showOrLogErrorAndThrow(new RestrictionError(this.i18n('noDuplicates', {
        fileName: fileName
      })), {
        file: file
      });
    }

    var meta = file.meta || {};
    meta.name = fileName;
    meta.type = fileType; // `null` means the size is unknown.

    var size = Number.isFinite(file.data.size) ? file.data.size : null;
    var newFile = {
      source: file.source || '',
      id: fileID,
      name: fileName,
      extension: fileExtension || '',
      meta: _extends({}, this.getState().meta, meta),
      type: fileType,
      data: file.data,
      progress: {
        percentage: 0,
        bytesUploaded: 0,
        bytesTotal: size,
        uploadComplete: false,
        uploadStarted: null
      },
      size: size,
      isRemote: isRemote,
      remote: file.remote || '',
      preview: file.preview
    };

    try {
      var filesArray = Object.keys(files).map(function (i) {
        return files[i];
      });
      this.checkRestrictions(newFile, filesArray);
    } catch (err) {
      this.showOrLogErrorAndThrow(err, {
        file: newFile
      });
    }

    return newFile;
  } // Schedule an upload if `autoProceed` is enabled.
  ;

  _proto.startIfAutoProceed = function startIfAutoProceed() {
    var _this3 = this;

    if (this.opts.autoProceed && !this.scheduledAutoProceed) {
      this.scheduledAutoProceed = setTimeout(function () {
        _this3.scheduledAutoProceed = null;

        _this3.upload().catch(function (err) {
          if (!err.isRestriction) {
            _this3.log(err.stack || err.message || err);
          }
        });
      }, 4);
    }
  }
  /**
   * Add a new file to `state.files`. This will run `onBeforeFileAdded`,
   * try to guess file type in a clever way, check file against restrictions,
   * and start an upload if `autoProceed === true`.
   *
   * @param {object} file object to add
   * @returns {string} id for the added file
   */
  ;

  _proto.addFile = function addFile(file) {
    var _extends3;

    this.assertNewUploadAllowed(file);

    var _this$getState3 = this.getState(),
        files = _this$getState3.files;

    var newFile = this.checkAndCreateFileStateObject(files, file); // Users are asked to re-select recovered files without data,
    // and to keep the progress, meta and everthing else, we only replace said data

    if (files[newFile.id] && files[newFile.id].isGhost) {
      newFile = _extends({}, files[newFile.id], {
        data: file.data,
        isGhost: false
      });
      this.log("Replaced the blob in the restored ghost file: " + newFile.name + ", " + newFile.id);
    }

    this.setState({
      files: _extends({}, files, (_extends3 = {}, _extends3[newFile.id] = newFile, _extends3))
    });
    this.emit('file-added', newFile);
    this.emit('files-added', [newFile]);
    this.log("Added file: " + newFile.name + ", " + newFile.id + ", mime type: " + newFile.type);
    this.startIfAutoProceed();
    return newFile.id;
  }
  /**
   * Add multiple files to `state.files`. See the `addFile()` documentation.
   *
   * If an error occurs while adding a file, it is logged and the user is notified.
   * This is good for UI plugins, but not for programmatic use.
   * Programmatic users should usually still use `addFile()` on individual files.
   */
  ;

  _proto.addFiles = function addFiles(fileDescriptors) {
    var _this4 = this;

    this.assertNewUploadAllowed(); // create a copy of the files object only once

    var files = _extends({}, this.getState().files);

    var newFiles = [];
    var errors = [];

    for (var i = 0; i < fileDescriptors.length; i++) {
      try {
        var newFile = this.checkAndCreateFileStateObject(files, fileDescriptors[i]); // Users are asked to re-select recovered files without data,
        // and to keep the progress, meta and everthing else, we only replace said data

        if (files[newFile.id] && files[newFile.id].isGhost) {
          newFile = _extends({}, files[newFile.id], {
            data: fileDescriptors[i].data,
            isGhost: false
          });
          this.log("Replaced blob in a ghost file: " + newFile.name + ", " + newFile.id);
        }

        files[newFile.id] = newFile;
        newFiles.push(newFile);
      } catch (err) {
        if (!err.isRestriction) {
          errors.push(err);
        }
      }
    }

    this.setState({
      files: files
    });
    newFiles.forEach(function (newFile) {
      _this4.emit('file-added', newFile);
    });
    this.emit('files-added', newFiles);

    if (newFiles.length > 5) {
      this.log("Added batch of " + newFiles.length + " files");
    } else {
      Object.keys(newFiles).forEach(function (fileID) {
        _this4.log("Added file: " + newFiles[fileID].name + "\n id: " + newFiles[fileID].id + "\n type: " + newFiles[fileID].type);
      });
    }

    if (newFiles.length > 0) {
      this.startIfAutoProceed();
    }

    if (errors.length > 0) {
      var message = 'Multiple errors occurred while adding files:\n';
      errors.forEach(function (subError) {
        message += "\n * " + subError.message;
      });
      this.info({
        message: this.i18n('addBulkFilesFailed', {
          smart_count: errors.length
        }),
        details: message
      }, 'error', this.opts.infoTimeout);

      if (typeof AggregateError === 'function') {
        throw new AggregateError(errors, message);
      } else {
        var err = new Error(message);
        err.errors = errors;
        throw err;
      }
    }
  };

  _proto.removeFiles = function removeFiles(fileIDs, reason) {
    var _this5 = this;

    var _this$getState4 = this.getState(),
        files = _this$getState4.files,
        currentUploads = _this$getState4.currentUploads;

    var updatedFiles = _extends({}, files);

    var updatedUploads = _extends({}, currentUploads);

    var removedFiles = Object.create(null);
    fileIDs.forEach(function (fileID) {
      if (files[fileID]) {
        removedFiles[fileID] = files[fileID];
        delete updatedFiles[fileID];
      }
    }); // Remove files from the `fileIDs` list in each upload.

    function fileIsNotRemoved(uploadFileID) {
      return removedFiles[uploadFileID] === undefined;
    }

    Object.keys(updatedUploads).forEach(function (uploadID) {
      var newFileIDs = currentUploads[uploadID].fileIDs.filter(fileIsNotRemoved); // Remove the upload if no files are associated with it anymore.

      if (newFileIDs.length === 0) {
        delete updatedUploads[uploadID];
        return;
      }

      updatedUploads[uploadID] = _extends({}, currentUploads[uploadID], {
        fileIDs: newFileIDs
      });
    });
    var stateUpdate = {
      currentUploads: updatedUploads,
      files: updatedFiles
    }; // If all files were removed - allow new uploads,
    // and clear recoveredState

    if (Object.keys(updatedFiles).length === 0) {
      stateUpdate.allowNewUpload = true;
      stateUpdate.error = null;
      stateUpdate.recoveredState = null;
    }

    this.setState(stateUpdate);
    this.calculateTotalProgress();
    var removedFileIDs = Object.keys(removedFiles);
    removedFileIDs.forEach(function (fileID) {
      _this5.emit('file-removed', removedFiles[fileID], reason);
    });

    if (removedFileIDs.length > 5) {
      this.log("Removed " + removedFileIDs.length + " files");
    } else {
      this.log("Removed files: " + removedFileIDs.join(', '));
    }
  };

  _proto.removeFile = function removeFile(fileID, reason) {
    if (reason === void 0) {
      reason = null;
    }

    this.removeFiles([fileID], reason);
  };

  _proto.pauseResume = function pauseResume(fileID) {
    if (!this.getState().capabilities.resumableUploads || this.getFile(fileID).uploadComplete) {
      return undefined;
    }

    var wasPaused = this.getFile(fileID).isPaused || false;
    var isPaused = !wasPaused;
    this.setFileState(fileID, {
      isPaused: isPaused
    });
    this.emit('upload-pause', fileID, isPaused);
    return isPaused;
  };

  _proto.pauseAll = function pauseAll() {
    var updatedFiles = _extends({}, this.getState().files);

    var inProgressUpdatedFiles = Object.keys(updatedFiles).filter(function (file) {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach(function (file) {
      var updatedFile = _extends({}, updatedFiles[file], {
        isPaused: true
      });

      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit('pause-all');
  };

  _proto.resumeAll = function resumeAll() {
    var updatedFiles = _extends({}, this.getState().files);

    var inProgressUpdatedFiles = Object.keys(updatedFiles).filter(function (file) {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach(function (file) {
      var updatedFile = _extends({}, updatedFiles[file], {
        isPaused: false,
        error: null
      });

      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit('resume-all');
  };

  _proto.retryAll = function retryAll() {
    var updatedFiles = _extends({}, this.getState().files);

    var filesToRetry = Object.keys(updatedFiles).filter(function (file) {
      return updatedFiles[file].error;
    });
    filesToRetry.forEach(function (file) {
      var updatedFile = _extends({}, updatedFiles[file], {
        isPaused: false,
        error: null
      });

      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      error: null
    });
    this.emit('retry-all', filesToRetry);

    if (filesToRetry.length === 0) {
      return Promise.resolve({
        successful: [],
        failed: []
      });
    }

    var uploadID = this.createUpload(filesToRetry, {
      forceAllowNewUpload: true // create new upload even if allowNewUpload: false

    });
    return this.runUpload(uploadID);
  };

  _proto.cancelAll = function cancelAll() {
    this.emit('cancel-all');

    var _this$getState5 = this.getState(),
        files = _this$getState5.files;

    var fileIDs = Object.keys(files);

    if (fileIDs.length) {
      this.removeFiles(fileIDs, 'cancel-all');
    }

    this.setState({
      totalProgress: 0,
      error: null,
      recoveredState: null
    });
  };

  _proto.retryUpload = function retryUpload(fileID) {
    this.setFileState(fileID, {
      error: null,
      isPaused: false
    });
    this.emit('upload-retry', fileID);
    var uploadID = this.createUpload([fileID], {
      forceAllowNewUpload: true // create new upload even if allowNewUpload: false

    });
    return this.runUpload(uploadID);
  };

  _proto.reset = function reset() {
    this.cancelAll();
  };

  _proto.logout = function logout() {
    this.iteratePlugins(function (plugin) {
      if (plugin.provider && plugin.provider.logout) {
        plugin.provider.logout();
      }
    });
  };

  _proto.calculateProgress = function calculateProgress(file, data) {
    if (!this.getFile(file.id)) {
      this.log("Not setting progress for a file that has been removed: " + file.id);
      return;
    } // bytesTotal may be null or zero; in that case we can't divide by it


    var canHavePercentage = Number.isFinite(data.bytesTotal) && data.bytesTotal > 0;
    this.setFileState(file.id, {
      progress: _extends({}, this.getFile(file.id).progress, {
        bytesUploaded: data.bytesUploaded,
        bytesTotal: data.bytesTotal,
        percentage: canHavePercentage // TODO(goto-bus-stop) flooring this should probably be the choice of the UI?
        // we get more accurate calculations if we don't round this at all.
        ? Math.round(data.bytesUploaded / data.bytesTotal * 100) : 0
      })
    });
    this.calculateTotalProgress();
  };

  _proto.calculateTotalProgress = function calculateTotalProgress() {
    // calculate total progress, using the number of files currently uploading,
    // multiplied by 100 and the summ of individual progress of each file
    var files = this.getFiles();
    var inProgress = files.filter(function (file) {
      return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;
    });

    if (inProgress.length === 0) {
      this.emit('progress', 0);
      this.setState({
        totalProgress: 0
      });
      return;
    }

    var sizedFiles = inProgress.filter(function (file) {
      return file.progress.bytesTotal != null;
    });
    var unsizedFiles = inProgress.filter(function (file) {
      return file.progress.bytesTotal == null;
    });

    if (sizedFiles.length === 0) {
      var progressMax = inProgress.length * 100;
      var currentProgress = unsizedFiles.reduce(function (acc, file) {
        return acc + file.progress.percentage;
      }, 0);

      var _totalProgress = Math.round(currentProgress / progressMax * 100);

      this.setState({
        totalProgress: _totalProgress
      });
      return;
    }

    var totalSize = sizedFiles.reduce(function (acc, file) {
      return acc + file.progress.bytesTotal;
    }, 0);
    var averageSize = totalSize / sizedFiles.length;
    totalSize += averageSize * unsizedFiles.length;
    var uploadedSize = 0;
    sizedFiles.forEach(function (file) {
      uploadedSize += file.progress.bytesUploaded;
    });
    unsizedFiles.forEach(function (file) {
      uploadedSize += averageSize * (file.progress.percentage || 0) / 100;
    });
    var totalProgress = totalSize === 0 ? 0 : Math.round(uploadedSize / totalSize * 100); // hot fix, because:
    // uploadedSize ended up larger than totalSize, resulting in 1325% total

    if (totalProgress > 100) {
      totalProgress = 100;
    }

    this.setState({
      totalProgress: totalProgress
    });
    this.emit('progress', totalProgress);
  }
  /**
   * Registers listeners for all global actions, like:
   * `error`, `file-removed`, `upload-progress`
   */
  ;

  _proto.addListeners = function addListeners() {
    var _this6 = this;

    /**
     * @param {Error} error
     * @param {object} [file]
     * @param {object} [response]
     */
    var errorHandler = function errorHandler(error, file, response) {
      var errorMsg = error.message || 'Unknown error';

      if (error.details) {
        errorMsg += " " + error.details;
      }

      _this6.setState({
        error: errorMsg
      }); // When a file is also given, we store the error on the file object.


      if (file != null && typeof file.id === 'string') {
        _this6.setFileState(file.id, {
          error: errorMsg,
          response: response
        });
      }
    };

    this.on('error', errorHandler);
    this.on('upload-error', function (file, error, response) {
      errorHandler(error, file, response);

      if (typeof error === 'object' && error.message) {
        var newError = new Error(error.message);
        newError.details = error.message;

        if (error.details) {
          newError.details += " " + error.details;
        }

        newError.message = _this6.i18n('failedToUpload', {
          file: file.name
        });

        _this6.showOrLogErrorAndThrow(newError, {
          throwErr: false
        });
      } else {
        _this6.showOrLogErrorAndThrow(error, {
          throwErr: false
        });
      }
    });
    this.on('upload', function () {
      _this6.setState({
        error: null
      });
    });
    this.on('upload-started', function (file) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      _this6.setFileState(file.id, {
        progress: {
          uploadStarted: Date.now(),
          uploadComplete: false,
          percentage: 0,
          bytesUploaded: 0,
          bytesTotal: file.size
        }
      });
    });
    this.on('upload-progress', this.calculateProgress);
    this.on('upload-success', function (file, uploadResp) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      var currentProgress = _this6.getFile(file.id).progress;

      _this6.setFileState(file.id, {
        progress: _extends({}, currentProgress, {
          postprocess: _this6.postProcessors.length > 0 ? {
            mode: 'indeterminate'
          } : null,
          uploadComplete: true,
          percentage: 100,
          bytesUploaded: currentProgress.bytesTotal
        }),
        response: uploadResp,
        uploadURL: uploadResp.uploadURL,
        isPaused: false
      });

      _this6.calculateTotalProgress();
    });
    this.on('preprocess-progress', function (file, progress) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      _this6.setFileState(file.id, {
        progress: _extends({}, _this6.getFile(file.id).progress, {
          preprocess: progress
        })
      });
    });
    this.on('preprocess-complete', function (file) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      var files = _extends({}, _this6.getState().files);

      files[file.id] = _extends({}, files[file.id], {
        progress: _extends({}, files[file.id].progress)
      });
      delete files[file.id].progress.preprocess;

      _this6.setState({
        files: files
      });
    });
    this.on('postprocess-progress', function (file, progress) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      _this6.setFileState(file.id, {
        progress: _extends({}, _this6.getState().files[file.id].progress, {
          postprocess: progress
        })
      });
    });
    this.on('postprocess-complete', function (file) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      var files = _extends({}, _this6.getState().files);

      files[file.id] = _extends({}, files[file.id], {
        progress: _extends({}, files[file.id].progress)
      });
      delete files[file.id].progress.postprocess; // TODO should we set some kind of `fullyComplete` property on the file object
      // so it's easier to see that the file is uploadfully completerather than
      // what we have to do now (`uploadComplete && !postprocess`)

      _this6.setState({
        files: files
      });
    });
    this.on('restored', function () {
      // Files may have changed--ensure progress is still accurate.
      _this6.calculateTotalProgress();
    }); // show informer if offline

    if (typeof window !== 'undefined' && window.addEventListener) {
      window.addEventListener('online', function () {
        return _this6.updateOnlineStatus();
      });
      window.addEventListener('offline', function () {
        return _this6.updateOnlineStatus();
      });
      setTimeout(function () {
        return _this6.updateOnlineStatus();
      }, 3000);
    }
  };

  _proto.updateOnlineStatus = function updateOnlineStatus() {
    var online = typeof window.navigator.onLine !== 'undefined' ? window.navigator.onLine : true;

    if (!online) {
      this.emit('is-offline');
      this.info(this.i18n('noInternetConnection'), 'error', 0);
      this.wasOffline = true;
    } else {
      this.emit('is-online');

      if (this.wasOffline) {
        this.emit('back-online');
        this.info(this.i18n('connectedToInternet'), 'success', 3000);
        this.wasOffline = false;
      }
    }
  };

  _proto.getID = function getID() {
    return this.opts.id;
  }
  /**
   * Registers a plugin with Core.
   *
   * @param {object} Plugin object
   * @param {object} [opts] object with options to be passed to Plugin
   * @returns {object} self for chaining
   */
  // eslint-disable-next-line no-shadow
  ;

  _proto.use = function use(Plugin, opts) {
    if (typeof Plugin !== 'function') {
      var msg = "Expected a plugin class, but got " + (Plugin === null ? 'null' : typeof Plugin) + "." + ' Please verify that the plugin was imported and spelled correctly.';
      throw new TypeError(msg);
    } // Instantiate


    var plugin = new Plugin(this, opts);
    var pluginId = plugin.id;
    this.plugins[plugin.type] = this.plugins[plugin.type] || [];

    if (!pluginId) {
      throw new Error('Your plugin must have an id');
    }

    if (!plugin.type) {
      throw new Error('Your plugin must have a type');
    }

    var existsPluginAlready = this.getPlugin(pluginId);

    if (existsPluginAlready) {
      var _msg = "Already found a plugin named '" + existsPluginAlready.id + "'. " + ("Tried to use: '" + pluginId + "'.\n") + 'Uppy plugins must have unique `id` options. See https://uppy.io/docs/plugins/#id.';

      throw new Error(_msg);
    }

    if (Plugin.VERSION) {
      this.log("Using " + pluginId + " v" + Plugin.VERSION);
    }

    this.plugins[plugin.type].push(plugin);
    plugin.install();
    return this;
  }
  /**
   * Find one Plugin by name.
   *
   * @param {string} id plugin id
   * @returns {object|boolean}
   */
  ;

  _proto.getPlugin = function getPlugin(id) {
    var foundPlugin = null;
    this.iteratePlugins(function (plugin) {
      if (plugin.id === id) {
        foundPlugin = plugin;
        return false;
      }
    });
    return foundPlugin;
  }
  /**
   * Iterate through all `use`d plugins.
   *
   * @param {Function} method that will be run on each plugin
   */
  ;

  _proto.iteratePlugins = function iteratePlugins(method) {
    var _this7 = this;

    Object.keys(this.plugins).forEach(function (pluginType) {
      _this7.plugins[pluginType].forEach(method);
    });
  }
  /**
   * Uninstall and remove a plugin.
   *
   * @param {object} instance The plugin instance to remove.
   */
  ;

  _proto.removePlugin = function removePlugin(instance) {
    var _extends4;

    this.log("Removing plugin " + instance.id);
    this.emit('plugin-remove', instance);

    if (instance.uninstall) {
      instance.uninstall();
    }

    var list = this.plugins[instance.type].slice(); // list.indexOf failed here, because Vue3 converted the plugin instance
    // to a Proxy object, which failed the strict comparison test:
    // obj !== objProxy

    var index = findIndex(list, function (item) {
      return item.id === instance.id;
    });

    if (index !== -1) {
      list.splice(index, 1);
      this.plugins[instance.type] = list;
    }

    var state = this.getState();
    var updatedState = {
      plugins: _extends({}, state.plugins, (_extends4 = {}, _extends4[instance.id] = undefined, _extends4))
    };
    this.setState(updatedState);
  }
  /**
   * Uninstall all plugins and close down this Uppy instance.
   */
  ;

  _proto.close = function close() {
    var _this8 = this;

    this.log("Closing Uppy instance " + this.opts.id + ": removing all files and uninstalling plugins");
    this.reset();
    this.storeUnsubscribe();
    this.iteratePlugins(function (plugin) {
      _this8.removePlugin(plugin);
    });
  }
  /**
   * Set info message in `state.info`, so that UI plugins like `Informer`
   * can display the message.
   *
   * @param {string | object} message Message to be displayed by the informer
   * @param {string} [type]
   * @param {number} [duration]
   */
  ;

  _proto.info = function info(message, type, duration) {
    if (type === void 0) {
      type = 'info';
    }

    if (duration === void 0) {
      duration = 3000;
    }

    var isComplexMessage = typeof message === 'object';
    this.setState({
      info: {
        isHidden: false,
        type: type,
        message: isComplexMessage ? message.message : message,
        details: isComplexMessage ? message.details : null
      }
    });
    this.emit('info-visible');
    clearTimeout(this.infoTimeoutID);

    if (duration === 0) {
      this.infoTimeoutID = undefined;
      return;
    } // hide the informer after `duration` milliseconds


    this.infoTimeoutID = setTimeout(this.hideInfo, duration);
  };

  _proto.hideInfo = function hideInfo() {
    var newInfo = _extends({}, this.getState().info, {
      isHidden: true
    });

    this.setState({
      info: newInfo
    });
    this.emit('info-hidden');
  }
  /**
   * Passes messages to a function, provided in `opts.logger`.
   * If `opts.logger: Uppy.debugLogger` or `opts.debug: true`, logs to the browser console.
   *
   * @param {string|object} message to log
   * @param {string} [type] optional `error` or `warning`
   */
  ;

  _proto.log = function log(message, type) {
    var logger = this.opts.logger;

    switch (type) {
      case 'error':
        logger.error(message);
        break;

      case 'warning':
        logger.warn(message);
        break;

      default:
        logger.debug(message);
        break;
    }
  }
  /**
   * Obsolete, event listeners are now added in the constructor.
   */
  ;

  _proto.run = function run() {
    this.log('Calling run() is no longer necessary.', 'warning');
    return this;
  }
  /**
   * Restore an upload by its ID.
   */
  ;

  _proto.restore = function restore(uploadID) {
    this.log("Core: attempting to restore upload \"" + uploadID + "\"");

    if (!this.getState().currentUploads[uploadID]) {
      this.removeUpload(uploadID);
      return Promise.reject(new Error('Nonexistent upload'));
    }

    return this.runUpload(uploadID);
  }
  /**
   * Create an upload for a bunch of files.
   *
   * @param {Array<string>} fileIDs File IDs to include in this upload.
   * @returns {string} ID of this upload.
   */
  ;

  _proto.createUpload = function createUpload(fileIDs, opts) {
    var _extends5;

    if (opts === void 0) {
      opts = {};
    }

    // uppy.retryAll sets this to true  when retrying we want to ignore `allowNewUpload: false`
    var _opts = opts,
        _opts$forceAllowNewUp = _opts.forceAllowNewUpload,
        forceAllowNewUpload = _opts$forceAllowNewUp === void 0 ? false : _opts$forceAllowNewUp;

    var _this$getState6 = this.getState(),
        allowNewUpload = _this$getState6.allowNewUpload,
        currentUploads = _this$getState6.currentUploads;

    if (!allowNewUpload && !forceAllowNewUpload) {
      throw new Error('Cannot create a new upload: already uploading.');
    }

    var uploadID = cuid();
    this.emit('upload', {
      id: uploadID,
      fileIDs: fileIDs
    });
    this.setState({
      allowNewUpload: this.opts.allowMultipleUploads !== false,
      currentUploads: _extends({}, currentUploads, (_extends5 = {}, _extends5[uploadID] = {
        fileIDs: fileIDs,
        step: 0,
        result: {}
      }, _extends5))
    });
    return uploadID;
  };

  _proto.getUpload = function getUpload(uploadID) {
    var _this$getState7 = this.getState(),
        currentUploads = _this$getState7.currentUploads;

    return currentUploads[uploadID];
  }
  /**
   * Add data to an upload's result object.
   *
   * @param {string} uploadID The ID of the upload.
   * @param {object} data Data properties to add to the result object.
   */
  ;

  _proto.addResultData = function addResultData(uploadID, data) {
    var _extends6;

    if (!this.getUpload(uploadID)) {
      this.log("Not setting result for an upload that has been removed: " + uploadID);
      return;
    }

    var _this$getState8 = this.getState(),
        currentUploads = _this$getState8.currentUploads;

    var currentUpload = _extends({}, currentUploads[uploadID], {
      result: _extends({}, currentUploads[uploadID].result, data)
    });

    this.setState({
      currentUploads: _extends({}, currentUploads, (_extends6 = {}, _extends6[uploadID] = currentUpload, _extends6))
    });
  }
  /**
   * Remove an upload, eg. if it has been canceled or completed.
   *
   * @param {string} uploadID The ID of the upload.
   */
  ;

  _proto.removeUpload = function removeUpload(uploadID) {
    var currentUploads = _extends({}, this.getState().currentUploads);

    delete currentUploads[uploadID];
    this.setState({
      currentUploads: currentUploads
    });
  }
  /**
   * Run an upload. This picks up where it left off in case the upload is being restored.
   *
   * @private
   */
  ;

  _proto.runUpload = function runUpload(uploadID) {
    var _this9 = this;

    var uploadData = this.getState().currentUploads[uploadID];
    var restoreStep = uploadData.step;
    var steps = [].concat(this.preProcessors, this.uploaders, this.postProcessors);
    var lastStep = Promise.resolve();
    steps.forEach(function (fn, step) {
      // Skip this step if we are restoring and have already completed this step before.
      if (step < restoreStep) {
        return;
      }

      lastStep = lastStep.then(function () {
        var _extends7;

        var _this9$getState = _this9.getState(),
            currentUploads = _this9$getState.currentUploads;

        var currentUpload = currentUploads[uploadID];

        if (!currentUpload) {
          return;
        }

        var updatedUpload = _extends({}, currentUpload, {
          step: step
        });

        _this9.setState({
          currentUploads: _extends({}, currentUploads, (_extends7 = {}, _extends7[uploadID] = updatedUpload, _extends7))
        }); // TODO give this the `updatedUpload` object as its only parameter maybe?
        // Otherwise when more metadata may be added to the upload this would keep getting more parameters
        // eslint-disable-next-line consistent-return


        return fn(updatedUpload.fileIDs, uploadID);
      }).then(function () {
        return null;
      });
    }); // Not returning the `catch`ed promise, because we still want to return a rejected
    // promise from this method if the upload failed.

    lastStep.catch(function (err) {
      _this9.emit('error', err);

      _this9.removeUpload(uploadID);
    });
    return lastStep.then(function () {
      // Set result data.
      var _this9$getState2 = _this9.getState(),
          currentUploads = _this9$getState2.currentUploads;

      var currentUpload = currentUploads[uploadID];

      if (!currentUpload) {
        return;
      } // Mark postprocessing step as complete if necessary; this addresses a case where we might get
      // stuck in the postprocessing UI while the upload is fully complete.
      // If the postprocessing steps do not do any work, they may not emit postprocessing events at
      // all, and never mark the postprocessing as complete. This is fine on its own but we
      // introduced code in the @uppy/core upload-success handler to prepare postprocessing progress
      // state if any postprocessors are registered. That is to avoid a "flash of completed state"
      // before the postprocessing plugins can emit events.
      //
      // So, just in case an upload with postprocessing plugins *has* completed *without* emitting
      // postprocessing completion, we do it instead.


      currentUpload.fileIDs.forEach(function (fileID) {
        var file = _this9.getFile(fileID);

        if (file && file.progress.postprocess) {
          _this9.emit('postprocess-complete', file);
        }
      });
      var files = currentUpload.fileIDs.map(function (fileID) {
        return _this9.getFile(fileID);
      });
      var successful = files.filter(function (file) {
        return !file.error;
      });
      var failed = files.filter(function (file) {
        return file.error;
      });

      _this9.addResultData(uploadID, {
        successful: successful,
        failed: failed,
        uploadID: uploadID
      });
    }).then(function () {
      // Emit completion events.
      // This is in a separate function so that the `currentUploads` variable
      // always refers to the latest state. In the handler right above it refers
      // to an outdated object without the `.result` property.
      var _this9$getState3 = _this9.getState(),
          currentUploads = _this9$getState3.currentUploads;

      if (!currentUploads[uploadID]) {
        return;
      }

      var currentUpload = currentUploads[uploadID];
      var result = currentUpload.result;

      _this9.emit('complete', result);

      _this9.removeUpload(uploadID); // eslint-disable-next-line consistent-return


      return result;
    }).then(function (result) {
      if (result == null) {
        _this9.log("Not setting result for an upload that has been removed: " + uploadID);
      }

      return result;
    });
  }
  /**
   * Start an upload for all the files that are not currently being uploaded.
   *
   * @returns {Promise}
   */
  ;

  _proto.upload = function upload() {
    var _this10 = this;

    if (!this.plugins.uploader) {
      this.log('No uploader type plugins are used', 'warning');
    }

    var _this$getState9 = this.getState(),
        files = _this$getState9.files;

    var onBeforeUploadResult = this.opts.onBeforeUpload(files);

    if (onBeforeUploadResult === false) {
      return Promise.reject(new Error('Not starting the upload because onBeforeUpload returned false'));
    }

    if (onBeforeUploadResult && typeof onBeforeUploadResult === 'object') {
      files = onBeforeUploadResult; // Updating files in state, because uploader plugins receive file IDs,
      // and then fetch the actual file object from state

      this.setState({
        files: files
      });
    }

    return Promise.resolve().then(function () {
      return _this10.checkMinNumberOfFiles(files);
    }).catch(function (err) {
      _this10.showOrLogErrorAndThrow(err);
    }).then(function () {
      var _this10$getState = _this10.getState(),
          currentUploads = _this10$getState.currentUploads; // get a list of files that are currently assigned to uploads


      var currentlyUploadingFiles = Object.keys(currentUploads).reduce(function (prev, curr) {
        return prev.concat(currentUploads[curr].fileIDs);
      }, []);
      var waitingFileIDs = [];
      Object.keys(files).forEach(function (fileID) {
        var file = _this10.getFile(fileID); // if the file hasn't started uploading and hasn't already been assigned to an upload..


        if (!file.progress.uploadStarted && currentlyUploadingFiles.indexOf(fileID) === -1) {
          waitingFileIDs.push(file.id);
        }
      });

      var uploadID = _this10.createUpload(waitingFileIDs);

      return _this10.runUpload(uploadID);
    }).catch(function (err) {
      _this10.showOrLogErrorAndThrow(err, {
        showInformer: false
      });
    });
  };

  _createClass(Uppy, [{
    key: "state",
    get: function get() {
      return this.getState();
    }
  }]);

  return Uppy;
}();

Uppy.VERSION = version;

module.exports = function core(opts) {
  return new Uppy(opts);
}; // Expose class constructor.


module.exports.Uppy = Uppy;
module.exports.Plugin = Plugin;
module.exports.debugLogger = debugLogger;

},{"../package.json":71,"./../../store-default":165,"./../../utils/lib/Translator":212,"./../../utils/lib/findIndex":219,"./../../utils/lib/generateFileID":220,"./../../utils/lib/getFileNameAndExtension":227,"./../../utils/lib/getFileType":228,"./Plugin":72,"./loggers":74,"./supportsUploadProgress":75,"@transloadit/prettier-bytes":1,"cuid":13,"lodash.throttle":32,"mime-match":35,"namespace-emitter":36}],74:[function(require,module,exports){
var getTimeStamp = require('./../../utils/lib/getTimeStamp'); // Swallow all logs, except errors.
// default if logger is not set or debug: false


var justErrorsLogger = {
  debug: function debug() {},
  warn: function warn() {},
  error: function error() {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_console = console).error.apply(_console, ["[Uppy] [" + getTimeStamp() + "]"].concat(args));
  }
}; // Print logs to console with namespace + timestamp,
// set by logger: Uppy.debugLogger or debug: true

var debugLogger = {
  debug: function debug() {
    // IE 10 doesnt support console.debug
    var debug = console.debug || console.log;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    debug.call.apply(debug, [console, "[Uppy] [" + getTimeStamp() + "]"].concat(args));
  },
  warn: function warn() {
    var _console2;

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return (_console2 = console).warn.apply(_console2, ["[Uppy] [" + getTimeStamp() + "]"].concat(args));
  },
  error: function error() {
    var _console3;

    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return (_console3 = console).error.apply(_console3, ["[Uppy] [" + getTimeStamp() + "]"].concat(args));
  }
};
module.exports = {
  justErrorsLogger: justErrorsLogger,
  debugLogger: debugLogger
};

},{"./../../utils/lib/getTimeStamp":233}],75:[function(require,module,exports){
// Edge 15.x does not fire 'progress' events on uploads.
// See https://github.com/transloadit/uppy/issues/945
// And https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12224510/
module.exports = function supportsUploadProgress(userAgent) {
  // Allow passing in userAgent for tests
  if (userAgent == null) {
    userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : null;
  } // Assume it works because basically everything supports progress events.


  if (!userAgent) return true;
  var m = /Edge\/(\d+\.\d+)/.exec(userAgent);
  if (!m) return true;
  var edgeVersion = m[1];

  var _edgeVersion$split = edgeVersion.split('.'),
      major = _edgeVersion$split[0],
      minor = _edgeVersion$split[1];

  major = parseInt(major, 10);
  minor = parseInt(minor, 10); // Worked before:
  // Edge 40.15063.0.0
  // Microsoft EdgeHTML 15.15063

  if (major < 15 || major === 15 && minor < 15063) {
    return true;
  } // Fixed in:
  // Microsoft EdgeHTML 18.18218


  if (major > 18 || major === 18 && minor >= 18218) {
    return true;
  } // other versions don't work.


  return false;
};

},{}],76:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],77:[function(require,module,exports){
module.exports={
  "name": "@uppy/dashboard",
  "description": "Universal UI plugin for Uppy.",
  "version": "1.20.2",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "dashboard",
    "ui"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@transloadit/prettier-bytes": "0.0.7",
    "@uppy/informer": "file:../informer",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/status-bar": "file:../status-bar",
    "@uppy/thumbnail-generator": "file:../thumbnail-generator",
    "@uppy/utils": "file:../utils",
    "classnames": "^2.2.6",
    "cuid": "^2.1.1",
    "is-shallow-equal": "^1.0.1",
    "lodash.debounce": "^4.0.8",
    "lodash.throttle": "^4.1.1",
    "memoize-one": "^5.0.4",
    "preact": "8.2.9",
    "resize-observer-polyfill": "^1.5.0"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],78:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var AddFiles = /*#__PURE__*/function (_Component) {
  _inheritsLoose(AddFiles, _Component);

  function AddFiles() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;

    _this.triggerFileInputClick = function () {
      _this.fileInput.click();
    };

    _this.triggerFolderInputClick = function () {
      _this.folderInput.click();
    };

    _this.onFileInputChange = function (event) {
      _this.props.handleInputChange(event); // We clear the input after a file is selected, because otherwise
      // change event is not fired in Chrome and Safari when a file
      // with the same name is selected.
      // ___Why not use value="" on <input/> instead?
      //    Because if we use that method of clearing the input,
      //    Chrome will not trigger change if we drop the same file twice (Issue #768).


      event.target.value = null;
    };

    _this.renderHiddenInput = function (isFolder, refCallback) {
      return h("input", {
        className: "uppy-Dashboard-input",
        hidden: true,
        "aria-hidden": "true",
        tabIndex: -1,
        webkitdirectory: isFolder,
        type: "file",
        name: "files[]",
        multiple: _this.props.maxNumberOfFiles !== 1,
        onChange: _this.onFileInputChange,
        accept: _this.props.allowedFileTypes,
        ref: refCallback
      });
    };

    _this.renderMyDeviceAcquirer = function () {
      return h("div", {
        className: "uppy-DashboardTab",
        role: "presentation",
        "data-uppy-acquirer-id": "MyDevice"
      }, h("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
        role: "tab",
        tabIndex: 0,
        "data-uppy-super-focusable": true,
        onClick: _this.triggerFileInputClick
      }, h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        width: "32",
        height: "32",
        rx: "16",
        fill: "#2275D7"
      }), h("path", {
        d: "M21.973 21.152H9.863l-1.108-5.087h14.464l-1.246 5.087zM9.935 11.37h3.958l.886 1.444a.673.673 0 0 0 .585.316h6.506v1.37H9.935v-3.13zm14.898 3.44a.793.793 0 0 0-.616-.31h-.978v-2.126c0-.379-.275-.613-.653-.613H15.75l-.886-1.445a.673.673 0 0 0-.585-.316H9.232c-.378 0-.667.209-.667.587V14.5h-.782a.793.793 0 0 0-.61.303.795.795 0 0 0-.155.663l1.45 6.633c.078.36.396.618.764.618h13.354c.36 0 .674-.246.76-.595l1.631-6.636a.795.795 0 0 0-.144-.675z",
        fill: "#FFF"
      }))), h("div", {
        className: "uppy-DashboardTab-name"
      }, _this.props.i18n('myDevice'))));
    };

    _this.renderBrowseButton = function (text, onClickFn) {
      var numberOfAcquirers = _this.props.acquirers.length;
      return h("button", {
        type: "button",
        className: "uppy-u-reset uppy-Dashboard-browse",
        onClick: onClickFn,
        "data-uppy-super-focusable": numberOfAcquirers === 0
      }, text);
    };

    _this.renderDropPasteBrowseTagline = function () {
      var numberOfAcquirers = _this.props.acquirers.length; // in order to keep the i18n CamelCase and options lower (as are defaults) we will want to transform a lower
      // to Camel

      var lowerFMSelectionType = _this.props.fileManagerSelectionType;
      var camelFMSelectionType = lowerFMSelectionType.charAt(0).toUpperCase() + lowerFMSelectionType.slice(1); // For backwards compatibility, we need to support both 'browse' and 'browseFiles'/'browseFolders' as strings here.

      var browseText = 'browse';
      var browseFilesText = 'browse';
      var browseFoldersText = 'browse';

      if (lowerFMSelectionType === 'files') {
        try {
          browseText = _this.props.i18n('browse');
          browseFilesText = _this.props.i18n('browse');
          browseFoldersText = _this.props.i18n('browse');
        } catch (_unused) {// Ignore, hopefully we can use the 'browseFiles' / 'browseFolders' strings
        }
      }

      try {
        browseFilesText = _this.props.i18n('browseFiles');
        browseFoldersText = _this.props.i18n('browseFolders');
      } catch (_unused2) {// Ignore, use the 'browse' string
      }

      var browse = _this.renderBrowseButton(browseText, _this.triggerFileInputClick);

      var browseFiles = _this.renderBrowseButton(browseFilesText, _this.triggerFileInputClick);

      var browseFolders = _this.renderBrowseButton(browseFoldersText, _this.triggerFolderInputClick); // Before the `fileManagerSelectionType` feature existed, we had two possible
      // strings here, but now we have six. We use the new-style strings by default:


      var titleText;

      if (numberOfAcquirers > 0) {
        titleText = _this.props.i18nArray("dropPasteImport" + camelFMSelectionType, {
          browseFiles: browseFiles,
          browseFolders: browseFolders,
          browse: browse
        });
      } else {
        titleText = _this.props.i18nArray("dropPaste" + camelFMSelectionType, {
          browseFiles: browseFiles,
          browseFolders: browseFolders,
          browse: browse
        });
      } // We use the old-style strings if available: this implies that the user has
      // manually specified them, so they should take precedence over the new-style
      // defaults.


      if (lowerFMSelectionType === 'files') {
        try {
          if (numberOfAcquirers > 0) {
            titleText = _this.props.i18nArray('dropPasteImport', {
              browse: browse
            });
          } else {
            titleText = _this.props.i18nArray('dropPaste', {
              browse: browse
            });
          }
        } catch (_unused3) {// Ignore, the new-style strings will be used.
        }
      }

      if (_this.props.disableLocalFiles) {
        titleText = _this.props.i18n('importFiles');
      }

      return h("div", {
        className: "uppy-Dashboard-AddFiles-title"
      }, titleText);
    };

    _this.renderAcquirer = function (acquirer) {
      return h("div", {
        className: "uppy-DashboardTab",
        role: "presentation",
        "data-uppy-acquirer-id": acquirer.id
      }, h("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
        role: "tab",
        tabIndex: 0,
        "aria-controls": "uppy-DashboardContent-panel--" + acquirer.id,
        "aria-selected": _this.props.activePickerPanel.id === acquirer.id,
        "data-uppy-super-focusable": true,
        onClick: function onClick() {
          return _this.props.showPanel(acquirer.id);
        }
      }, acquirer.icon(), h("div", {
        className: "uppy-DashboardTab-name"
      }, acquirer.name)));
    };

    _this.renderAcquirers = function (acquirers, disableLocalFiles) {
      // Group last two buttons, so we dont end up with
      // just one button on a new line
      var acquirersWithoutLastTwo = [].concat(acquirers);
      var lastTwoAcquirers = acquirersWithoutLastTwo.splice(acquirers.length - 2, acquirers.length);
      return h("div", {
        className: "uppy-Dashboard-AddFiles-list",
        role: "tablist"
      }, !disableLocalFiles && _this.renderMyDeviceAcquirer(), acquirersWithoutLastTwo.map(function (acquirer) {
        return _this.renderAcquirer(acquirer);
      }), h("span", {
        role: "presentation",
        style: "white-space: nowrap;"
      }, lastTwoAcquirers.map(function (acquirer) {
        return _this.renderAcquirer(acquirer);
      })));
    };

    return _this;
  }

  var _proto = AddFiles.prototype;

  _proto.renderPoweredByUppy = function renderPoweredByUppy() {
    var uppyBranding = h("span", null, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-Dashboard-poweredByIcon",
      width: "11",
      height: "11",
      viewBox: "0 0 11 11"
    }, h("path", {
      d: "M7.365 10.5l-.01-4.045h2.612L5.5.806l-4.467 5.65h2.604l.01 4.044h3.718z",
      fillRule: "evenodd"
    })), h("span", {
      className: "uppy-Dashboard-poweredByUppy"
    }, "Uppy")); // Support both the old word-order-insensitive string `poweredBy` and the new word-order-sensitive string `poweredBy2`

    var linkText = this.props.i18nArray('poweredBy2', {
      backwardsCompat: this.props.i18n('poweredBy'),
      uppy: uppyBranding
    });
    return h("a", {
      tabIndex: "-1",
      href: "https://uppy.io",
      rel: "noreferrer noopener",
      target: "_blank",
      className: "uppy-Dashboard-poweredBy"
    }, linkText);
  };

  _proto.render = function render() {
    var _this2 = this;

    return h("div", {
      className: "uppy-Dashboard-AddFiles"
    }, this.renderHiddenInput(false, function (ref) {
      _this2.fileInput = ref;
    }), this.renderHiddenInput(true, function (ref) {
      _this2.folderInput = ref;
    }), this.renderDropPasteBrowseTagline(), this.props.acquirers.length > 0 && this.renderAcquirers(this.props.acquirers, this.props.disableLocalFiles), h("div", {
      className: "uppy-Dashboard-AddFiles-info"
    }, this.props.note && h("div", {
      className: "uppy-Dashboard-note"
    }, this.props.note), this.props.proudlyDisplayPoweredByUppy && this.renderPoweredByUppy(this.props)));
  };

  return AddFiles;
}(Component);

module.exports = AddFiles;

},{"preact":76}],79:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

var AddFiles = require('./AddFiles');

var AddFilesPanel = function AddFilesPanel(props) {
  return h("div", {
    className: classNames('uppy-Dashboard-AddFilesPanel', props.className),
    "data-uppy-panelType": "AddFiles",
    "aria-hidden": props.showAddFilesPanel
  }, h("div", {
    className: "uppy-DashboardContent-bar"
  }, h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18n('addingMoreFiles')), h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: function onClick(ev) {
      return props.toggleAddFilesPanel(false);
    }
  }, props.i18n('back'))), h(AddFiles, props));
};

module.exports = AddFilesPanel;

},{"./AddFiles":78,"classnames":10,"preact":76}],80:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

var FileList = require('./FileList');

var AddFiles = require('./AddFiles');

var AddFilesPanel = require('./AddFilesPanel');

var PickerPanelContent = require('./PickerPanelContent');

var EditorPanel = require('./EditorPanel');

var PanelTopBar = require('./PickerPanelTopBar');

var FileCard = require('./FileCard');

var Slide = require('./Slide');

var isDragDropSupported = require('./../../../utils/lib/isDragDropSupported'); // http://dev.edenspiekermann.com/2016/02/11/introducing-accessible-modal-dialog
// https://github.com/ghosh/micromodal


var WIDTH_XL = 900;
var WIDTH_LG = 700;
var WIDTH_MD = 576;
var HEIGHT_MD = 400;

module.exports = function Dashboard(props) {
  var noFiles = props.totalFileCount === 0;
  var isSizeMD = props.containerWidth > WIDTH_MD;
  var wrapperClassName = classNames({
    'uppy-Root': props.isTargetDOMEl
  });
  var dashboardClassName = classNames({
    'uppy-Dashboard': true,
    'uppy-Dashboard--isDisabled': props.disabled,
    'uppy-Dashboard--animateOpenClose': props.animateOpenClose,
    'uppy-Dashboard--isClosing': props.isClosing,
    'uppy-Dashboard--isDraggingOver': props.isDraggingOver,
    'uppy-Dashboard--modal': !props.inline,
    'uppy-size--md': props.containerWidth > WIDTH_MD,
    'uppy-size--lg': props.containerWidth > WIDTH_LG,
    'uppy-size--xl': props.containerWidth > WIDTH_XL,
    'uppy-size--height-md': props.containerHeight > HEIGHT_MD,
    'uppy-Dashboard--isAddFilesPanelVisible': props.showAddFilesPanel,
    'uppy-Dashboard--isInnerWrapVisible': props.areInsidesReadyToBeVisible
  }); // Important: keep these in sync with the percent width values in `src/components/FileItem/index.scss`.

  var itemsPerRow = 1; // mobile

  if (props.containerWidth > WIDTH_XL) {
    itemsPerRow = 5;
  } else if (props.containerWidth > WIDTH_LG) {
    itemsPerRow = 4;
  } else if (props.containerWidth > WIDTH_MD) {
    itemsPerRow = 3;
  }

  var showFileList = props.showSelectedFiles && !noFiles;
  var numberOfFilesForRecovery = props.recoveredState ? Object.keys(props.recoveredState.files).length : null;
  var numberOfGhosts = props.files ? Object.keys(props.files).filter(function (fileID) {
    return props.files[fileID].isGhost;
  }).length : null;

  var renderRestoredText = function renderRestoredText() {
    if (numberOfGhosts > 0) {
      return props.i18n('recoveredXFiles', {
        smart_count: numberOfGhosts
      });
    }

    return props.i18n('recoveredAllFiles');
  };

  var dashboard = h("div", {
    className: dashboardClassName,
    "data-uppy-theme": props.theme,
    "data-uppy-num-acquirers": props.acquirers.length,
    "data-uppy-drag-drop-supported": !props.disableLocalFiles && isDragDropSupported(),
    "aria-hidden": props.inline ? 'false' : props.isHidden,
    "aria-disabled": props.disabled,
    "aria-label": !props.inline ? props.i18n('dashboardWindowTitle') : props.i18n('dashboardTitle'),
    onPaste: props.handlePaste,
    onDragOver: props.handleDragOver,
    onDragLeave: props.handleDragLeave,
    onDrop: props.handleDrop
  }, h("div", {
    className: "uppy-Dashboard-overlay",
    tabIndex: -1,
    onClick: props.handleClickOutside
  }), h("div", {
    className: "uppy-Dashboard-inner",
    "aria-modal": !props.inline && 'true',
    role: !props.inline && 'dialog',
    style: {
      width: props.inline && props.width ? props.width : '',
      height: props.inline && props.height ? props.height : ''
    }
  }, !props.inline ? h("button", {
    className: "uppy-u-reset uppy-Dashboard-close",
    type: "button",
    "aria-label": props.i18n('closeModal'),
    title: props.i18n('closeModal'),
    onClick: props.closeModal
  }, h("span", {
    "aria-hidden": "true"
  }, "\xD7")) : null, h("div", {
    className: "uppy-Dashboard-innerWrap"
  }, h("div", {
    className: "uppy-Dashboard-dropFilesHereHint"
  }, props.i18n('dropHint')), showFileList && h(PanelTopBar, props), numberOfFilesForRecovery && h("div", {
    className: "uppy-Dashboard-serviceMsg"
  }, h("svg", {
    className: "uppy-Dashboard-serviceMsg-icon",
    "aria-hidden": "true",
    focusable: "false",
    width: "21",
    height: "16",
    viewBox: "0 0 24 19"
  }, h("g", {
    transform: "translate(0 -1)",
    fill: "none",
    fillRule: "evenodd"
  }, h("path", {
    d: "M12.857 1.43l10.234 17.056A1 1 0 0122.234 20H1.766a1 1 0 01-.857-1.514L11.143 1.429a1 1 0 011.714 0z",
    fill: "#FFD300"
  }), h("path", {
    fill: "#000",
    d: "M11 6h2l-.3 8h-1.4z"
  }), h("circle", {
    fill: "#000",
    cx: "12",
    cy: "17",
    r: "1"
  }))), h("strong", {
    className: "uppy-Dashboard-serviceMsg-title"
  }, props.i18n('sessionRestored')), h("div", {
    class: "uppy-Dashboard-serviceMsg-text"
  }, renderRestoredText())), showFileList ? h(FileList, _extends({}, props, {
    itemsPerRow: itemsPerRow
  })) : h(AddFiles, _extends({}, props, {
    isSizeMD: isSizeMD
  })), h(Slide, null, props.showAddFilesPanel ? h(AddFilesPanel, _extends({
    key: "AddFiles"
  }, props, {
    isSizeMD: isSizeMD
  })) : null), h(Slide, null, props.fileCardFor ? h(FileCard, _extends({
    key: "FileCard"
  }, props)) : null), h(Slide, null, props.activePickerPanel ? h(PickerPanelContent, _extends({
    key: "Picker"
  }, props)) : null), h(Slide, null, props.showFileEditor ? h(EditorPanel, _extends({
    key: "Editor"
  }, props)) : null), h("div", {
    className: "uppy-Dashboard-progressindicators"
  }, props.progressindicators.map(function (target) {
    return props.getPlugin(target.id).render(props.state);
  })))));
  return (// Wrap it for RTL language support
    h("div", {
      className: wrapperClassName,
      dir: props.direction
    }, dashboard)
  );
};

},{"./../../../utils/lib/isDragDropSupported":236,"./AddFiles":78,"./AddFilesPanel":79,"./EditorPanel":81,"./FileCard":82,"./FileList":88,"./PickerPanelContent":90,"./PickerPanelTopBar":91,"./Slide":92,"classnames":10,"preact":76}],81:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

function EditorPanel(props) {
  var file = this.props.files[this.props.fileCardFor];
  return h("div", {
    className: classNames('uppy-DashboardContent-panel', props.className),
    role: "tabpanel",
    "data-uppy-panelType": "FileEditor",
    id: "uppy-DashboardContent-panel--editor"
  }, h("div", {
    className: "uppy-DashboardContent-bar"
  }, h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18nArray('editing', {
    file: h("span", {
      className: "uppy-DashboardContent-titleFile"
    }, file.meta ? file.meta.name : file.name)
  })), h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: props.hideAllPanels
  }, props.i18n('cancel')), h("button", {
    className: "uppy-DashboardContent-save",
    type: "button",
    onClick: props.saveFileEditor
  }, props.i18n('save'))), h("div", {
    className: "uppy-DashboardContent-panelBody"
  }, props.editors.map(function (target) {
    return props.getPlugin(target.id).render(props.state);
  })));
}

module.exports = EditorPanel;

},{"classnames":10,"preact":76}],82:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var classNames = require('classnames');

var getFileTypeIcon = require('../../utils/getFileTypeIcon');

var ignoreEvent = require('../../utils/ignoreEvent.js');

var FilePreview = require('../FilePreview');

var FileCard = /*#__PURE__*/function (_Component) {
  _inheritsLoose(FileCard, _Component);

  function FileCard(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.saveOnEnter = function (ev) {
      if (ev.keyCode === 13) {
        ev.stopPropagation();
        ev.preventDefault();
        var file = _this.props.files[_this.props.fileCardFor];

        _this.props.saveFileCard(_this.state.formState, file.id);
      }
    };

    _this.updateMeta = function (newVal, name) {
      var _extends2;

      _this.setState({
        formState: _extends({}, _this.state.formState, (_extends2 = {}, _extends2[name] = newVal, _extends2))
      });
    };

    _this.handleSave = function () {
      var fileID = _this.props.fileCardFor;

      _this.props.saveFileCard(_this.state.formState, fileID);
    };

    _this.handleCancel = function () {
      _this.props.toggleFileCard(false);
    };

    _this.renderMetaFields = function () {
      var metaFields = _this.getMetaFields() || [];
      var fieldCSSClasses = {
        text: 'uppy-u-reset uppy-c-textInput uppy-Dashboard-FileCard-input'
      };
      return metaFields.map(function (field) {
        var id = "uppy-Dashboard-FileCard-input-" + field.id;
        return h("fieldset", {
          key: field.id,
          className: "uppy-Dashboard-FileCard-fieldset"
        }, h("label", {
          className: "uppy-Dashboard-FileCard-label",
          htmlFor: id
        }, field.name), field.render !== undefined ? field.render({
          value: _this.state.formState[field.id],
          onChange: function onChange(newVal) {
            return _this.updateMeta(newVal, field.id);
          },
          fieldCSSClasses: fieldCSSClasses
        }, h) : h("input", {
          className: fieldCSSClasses.text,
          id: id,
          type: field.type || 'text',
          value: _this.state.formState[field.id],
          placeholder: field.placeholder,
          onKeyUp: _this.saveOnEnter,
          onKeyDown: _this.saveOnEnter,
          onKeyPress: _this.saveOnEnter,
          onInput: function onInput(ev) {
            return _this.updateMeta(ev.target.value, field.id);
          },
          "data-uppy-super-focusable": true
        }));
      });
    };

    var _file = _this.props.files[_this.props.fileCardFor];

    var _metaFields = _this.getMetaFields() || [];

    var storedMetaData = {};

    _metaFields.forEach(function (field) {
      storedMetaData[field.id] = _file.meta[field.id] || '';
    });

    _this.state = {
      formState: storedMetaData
    };
    return _this;
  }

  var _proto = FileCard.prototype;

  _proto.getMetaFields = function getMetaFields() {
    return typeof this.props.metaFields === 'function' ? this.props.metaFields(this.props.files[this.props.fileCardFor]) : this.props.metaFields;
  };

  _proto.render = function render() {
    var _this2 = this;

    var file = this.props.files[this.props.fileCardFor];
    var showEditButton = this.props.canEditFile(file);
    return h("div", {
      className: classNames('uppy-Dashboard-FileCard', this.props.className),
      "data-uppy-panelType": "FileCard",
      onDragOver: ignoreEvent,
      onDragLeave: ignoreEvent,
      onDrop: ignoreEvent,
      onPaste: ignoreEvent
    }, h("div", {
      className: "uppy-DashboardContent-bar"
    }, h("div", {
      className: "uppy-DashboardContent-title",
      role: "heading",
      "aria-level": "1"
    }, this.props.i18nArray('editing', {
      file: h("span", {
        className: "uppy-DashboardContent-titleFile"
      }, file.meta ? file.meta.name : file.name)
    })), h("button", {
      className: "uppy-DashboardContent-back",
      type: "button",
      title: this.props.i18n('finishEditingFile'),
      onClick: this.handleCancel
    }, this.props.i18n('cancel'))), h("div", {
      className: "uppy-Dashboard-FileCard-inner"
    }, h("div", {
      className: "uppy-Dashboard-FileCard-preview",
      style: {
        backgroundColor: getFileTypeIcon(file.type).color
      }
    }, h(FilePreview, {
      file: file
    }), showEditButton && h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn uppy-Dashboard-FileCard-edit",
      onClick: function onClick() {
        return _this2.props.openFileEditor(file);
      }
    }, this.props.i18n('editFile'))), h("div", {
      className: "uppy-Dashboard-FileCard-info"
    }, this.renderMetaFields()), h("div", {
      className: "uppy-Dashboard-FileCard-actions"
    }, h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Dashboard-FileCard-actionsBtn",
      type: "button",
      onClick: this.handleSave
    }, this.props.i18n('saveChanges')), h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-link uppy-Dashboard-FileCard-actionsBtn",
      type: "button",
      onClick: this.handleCancel
    }, this.props.i18n('cancel')))));
  };

  return FileCard;
}(Component);

module.exports = FileCard;

},{"../../utils/getFileTypeIcon":98,"../../utils/ignoreEvent.js":99,"../FilePreview":89,"classnames":10,"preact":76}],83:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var copyToClipboard = require('../../../utils/copyToClipboard');

function EditButton(_ref) {
  var file = _ref.file,
      uploadInProgressOrComplete = _ref.uploadInProgressOrComplete,
      metaFields = _ref.metaFields,
      canEditFile = _ref.canEditFile,
      i18n = _ref.i18n,
      _onClick = _ref.onClick;

  if (!uploadInProgressOrComplete && metaFields && metaFields.length > 0 || !uploadInProgressOrComplete && canEditFile(file)) {
    return h("button", {
      className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--edit",
      type: "button",
      "aria-label": i18n('editFile') + " " + file.meta.name,
      title: i18n('editFile'),
      onClick: function onClick() {
        return _onClick();
      }
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      width: "14",
      height: "14",
      viewBox: "0 0 14 14"
    }, h("g", {
      fillRule: "evenodd"
    }, h("path", {
      d: "M1.5 10.793h2.793A1 1 0 0 0 5 10.5L11.5 4a1 1 0 0 0 0-1.414L9.707.793a1 1 0 0 0-1.414 0l-6.5 6.5A1 1 0 0 0 1.5 8v2.793zm1-1V8L9 1.5l1.793 1.793-6.5 6.5H2.5z",
      fillRule: "nonzero"
    }), h("rect", {
      x: "1",
      y: "12.293",
      width: "11",
      height: "1",
      rx: ".5"
    }), h("path", {
      fillRule: "nonzero",
      d: "M6.793 2.5L9.5 5.207l.707-.707L7.5 1.793z"
    }))));
  }

  return null;
}

function RemoveButton(_ref2) {
  var i18n = _ref2.i18n,
      _onClick2 = _ref2.onClick;
  return h("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--remove",
    type: "button",
    "aria-label": i18n('removeFile'),
    title: i18n('removeFile'),
    onClick: function onClick() {
      return _onClick2();
    }
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "18",
    height: "18",
    viewBox: "0 0 18 18"
  }, h("path", {
    d: "M9 0C4.034 0 0 4.034 0 9s4.034 9 9 9 9-4.034 9-9-4.034-9-9-9z"
  }), h("path", {
    fill: "#FFF",
    d: "M13 12.222l-.778.778L9 9.778 5.778 13 5 12.222 8.222 9 5 5.778 5.778 5 9 8.222 12.222 5l.778.778L9.778 9z"
  })));
}

var copyLinkToClipboard = function copyLinkToClipboard(event, props) {
  copyToClipboard(props.file.uploadURL, props.i18n('copyLinkToClipboardFallback')).then(function () {
    props.log('Link copied to clipboard.');
    props.info(props.i18n('copyLinkToClipboardSuccess'), 'info', 3000);
  }).catch(props.log) // avoid losing focus
  .then(function () {
    return event.target.focus({
      preventScroll: true
    });
  });
};

function CopyLinkButton(props) {
  return h("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--copyLink",
    type: "button",
    "aria-label": props.i18n('copyLink'),
    title: props.i18n('copyLink'),
    onClick: function onClick(event) {
      return copyLinkToClipboard(event, props);
    }
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "14",
    height: "14",
    viewBox: "0 0 14 12"
  }, h("path", {
    d: "M7.94 7.703a2.613 2.613 0 0 1-.626 2.681l-.852.851a2.597 2.597 0 0 1-1.849.766A2.616 2.616 0 0 1 2.764 7.54l.852-.852a2.596 2.596 0 0 1 2.69-.625L5.267 7.099a1.44 1.44 0 0 0-.833.407l-.852.851a1.458 1.458 0 0 0 1.03 2.486c.39 0 .755-.152 1.03-.426l.852-.852c.231-.231.363-.522.406-.824l1.04-1.038zm4.295-5.937A2.596 2.596 0 0 0 10.387 1c-.698 0-1.355.272-1.849.766l-.852.851a2.614 2.614 0 0 0-.624 2.688l1.036-1.036c.041-.304.173-.6.407-.833l.852-.852c.275-.275.64-.426 1.03-.426a1.458 1.458 0 0 1 1.03 2.486l-.852.851a1.442 1.442 0 0 1-.824.406l-1.04 1.04a2.596 2.596 0 0 0 2.683-.628l.851-.85a2.616 2.616 0 0 0 0-3.697zm-6.88 6.883a.577.577 0 0 0 .82 0l3.474-3.474a.579.579 0 1 0-.819-.82L5.355 7.83a.579.579 0 0 0 0 .819z"
  })));
}

module.exports = function Buttons(props) {
  var file = props.file,
      uploadInProgressOrComplete = props.uploadInProgressOrComplete,
      canEditFile = props.canEditFile,
      metaFields = props.metaFields,
      showLinkToFileUploadResult = props.showLinkToFileUploadResult,
      showRemoveButton = props.showRemoveButton,
      i18n = props.i18n,
      removeFile = props.removeFile,
      toggleFileCard = props.toggleFileCard,
      openFileEditor = props.openFileEditor,
      log = props.log,
      info = props.info;

  var editAction = function editAction() {
    if (metaFields && metaFields.length > 0) {
      toggleFileCard(true, file.id);
    } else {
      openFileEditor(file);
    }
  };

  return h("div", {
    className: "uppy-Dashboard-Item-actionWrapper"
  }, h(EditButton, {
    i18n: i18n,
    file: file,
    uploadInProgressOrComplete: uploadInProgressOrComplete,
    canEditFile: canEditFile,
    metaFields: metaFields,
    onClick: editAction
  }), showLinkToFileUploadResult && file.uploadURL ? h(CopyLinkButton, {
    file: file,
    i18n: i18n,
    info: info,
    log: log
  }) : null, showRemoveButton ? h(RemoveButton, {
    i18n: i18n,
    info: props.info,
    log: props.log,
    onClick: function onClick() {
      return removeFile(file.id, 'removed-by-user');
    }
  }) : null);
};

},{"../../../utils/copyToClipboard":95,"preact":76}],84:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var prettierBytes = require('@transloadit/prettier-bytes');

var truncateString = require('./../../../../../utils/lib/truncateString');

var renderAcquirerIcon = function renderAcquirerIcon(acquirer, props) {
  return h("span", {
    title: props.i18n('fileSource', {
      name: acquirer.name
    })
  }, acquirer.icon());
};

var renderFileName = function renderFileName(props) {
  // Take up at most 2 lines on any screen
  var maxNameLength; // For very small mobile screens

  if (props.containerWidth <= 352) {
    maxNameLength = 35; // For regular mobile screens
  } else if (props.containerWidth <= 576) {
    maxNameLength = 60; // For desktops
  } else {
    maxNameLength = 30;
  }

  return h("div", {
    className: "uppy-Dashboard-Item-name",
    title: props.file.meta.name
  }, truncateString(props.file.meta.name, maxNameLength));
};

var renderFileSize = function renderFileSize(props) {
  return props.file.size && h("div", {
    className: "uppy-Dashboard-Item-statusSize"
  }, prettierBytes(props.file.size));
};

var ReSelectButton = function ReSelectButton(props) {
  return props.file.isGhost && h("span", null, " \u2022 ", h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-reSelect",
    type: "button",
    onClick: props.toggleAddFilesPanel
  }, props.i18n('reSelect')));
};

var ErrorButton = function ErrorButton(_ref) {
  var file = _ref.file,
      onClick = _ref.onClick;

  if (file.error) {
    return h("span", {
      className: "uppy-Dashboard-Item-errorDetails",
      "aria-label": file.error,
      "data-microtip-position": "bottom",
      "data-microtip-size": "medium",
      role: "tooltip",
      onClick: onClick
    }, "?");
  }

  return null;
};

module.exports = function FileInfo(props) {
  return h("div", {
    className: "uppy-Dashboard-Item-fileInfo",
    "data-uppy-file-source": props.file.source
  }, renderFileName(props), h("div", {
    className: "uppy-Dashboard-Item-status"
  }, renderFileSize(props), ReSelectButton(props), h(ErrorButton, {
    file: props.file,
    onClick: function onClick() {
      alert(props.file.error);
    }
  })));
};

},{"./../../../../../utils/lib/truncateString":246,"@transloadit/prettier-bytes":1,"preact":76}],85:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var FilePreview = require('../../FilePreview');

var getFileTypeIcon = require('../../../utils/getFileTypeIcon');

module.exports = function FilePreviewAndLink(props) {
  return h("div", {
    className: "uppy-Dashboard-Item-previewInnerWrap",
    style: {
      backgroundColor: getFileTypeIcon(props.file.type).color
    }
  }, props.showLinkToFileUploadResult && props.file.uploadURL && h("a", {
    className: "uppy-Dashboard-Item-previewLink",
    href: props.file.uploadURL,
    rel: "noreferrer noopener",
    target: "_blank",
    "aria-label": props.file.meta.name
  }), h(FilePreview, {
    file: props.file
  }));
};

},{"../../../utils/getFileTypeIcon":98,"../../FilePreview":89,"preact":76}],86:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function onPauseResumeCancelRetry(props) {
  if (props.isUploaded) return;

  if (props.error && !props.hideRetryButton) {
    props.retryUpload(props.file.id);
    return;
  }

  if (props.resumableUploads && !props.hidePauseResumeButton) {
    props.pauseUpload(props.file.id);
  } else if (props.individualCancellation && !props.hideCancelButton) {
    props.cancelUpload(props.file.id);
  }
}

function progressIndicatorTitle(props) {
  if (props.isUploaded) {
    return props.i18n('uploadComplete');
  }

  if (props.error) {
    return props.i18n('retryUpload');
  }

  if (props.resumableUploads) {
    if (props.file.isPaused) {
      return props.i18n('resumeUpload');
    }

    return props.i18n('pauseUpload');
  }

  if (props.individualCancellation) {
    return props.i18n('cancelUpload');
  }

  return '';
}

function ProgressIndicatorButton(props) {
  return h("div", {
    className: "uppy-Dashboard-Item-progress"
  }, h("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-progressIndicator",
    type: "button",
    "aria-label": progressIndicatorTitle(props),
    title: progressIndicatorTitle(props),
    onClick: function onClick() {
      return onPauseResumeCancelRetry(props);
    }
  }, props.children));
}

function ProgressCircleContainer(_ref) {
  var children = _ref.children;
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "70",
    height: "70",
    viewBox: "0 0 36 36",
    className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--circle"
  }, children);
}

function ProgressCircle(_ref2) {
  var progress = _ref2.progress;
  // circle length equals 2 * PI * R
  var circleLength = 2 * Math.PI * 15;
  return h("g", null, h("circle", {
    className: "uppy-Dashboard-Item-progressIcon--bg",
    r: "15",
    cx: "18",
    cy: "18",
    "stroke-width": "2",
    fill: "none"
  }), h("circle", {
    className: "uppy-Dashboard-Item-progressIcon--progress",
    r: "15",
    cx: "18",
    cy: "18",
    transform: "rotate(-90, 18, 18)",
    fill: "none",
    "stroke-width": "2",
    "stroke-dasharray": circleLength,
    "stroke-dashoffset": circleLength - circleLength / 100 * progress
  }));
}

module.exports = function FileProgress(props) {
  // Nothing if upload has not started
  if (!props.file.progress.uploadStarted) {
    return null;
  } // Green checkmark when complete


  if (props.isUploaded) {
    return h("div", {
      className: "uppy-Dashboard-Item-progress"
    }, h("div", {
      className: "uppy-Dashboard-Item-progressIndicator"
    }, h(ProgressCircleContainer, null, h("circle", {
      r: "15",
      cx: "18",
      cy: "18",
      fill: "#1bb240"
    }), h("polygon", {
      className: "uppy-Dashboard-Item-progressIcon--check",
      transform: "translate(2, 3)",
      points: "14 22.5 7 15.2457065 8.99985857 13.1732815 14 18.3547104 22.9729883 9 25 11.1005634"
    }))));
  }

  if (props.recoveredState) {
    return;
  } // Retry button for error


  if (props.error && !props.hideRetryButton) {
    return h(ProgressIndicatorButton, props, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--retry",
      width: "28",
      height: "31",
      viewBox: "0 0 16 19"
    }, h("path", {
      d: "M16 11a8 8 0 1 1-8-8v2a6 6 0 1 0 6 6h2z"
    }), h("path", {
      d: "M7.9 3H10v2H7.9z"
    }), h("path", {
      d: "M8.536.5l3.535 3.536-1.414 1.414L7.12 1.914z"
    }), h("path", {
      d: "M10.657 2.621l1.414 1.415L8.536 7.57 7.12 6.157z"
    })));
  } // Pause/resume button for resumable uploads


  if (props.resumableUploads && !props.hidePauseResumeButton) {
    return h(ProgressIndicatorButton, props, h(ProgressCircleContainer, null, h(ProgressCircle, {
      progress: props.file.progress.percentage
    }), props.file.isPaused ? h("polygon", {
      className: "uppy-Dashboard-Item-progressIcon--play",
      transform: "translate(3, 3)",
      points: "12 20 12 10 20 15"
    }) : h("g", {
      className: "uppy-Dashboard-Item-progressIcon--pause",
      transform: "translate(14.5, 13)"
    }, h("rect", {
      x: "0",
      y: "0",
      width: "2",
      height: "10",
      rx: "0"
    }), h("rect", {
      x: "5",
      y: "0",
      width: "2",
      height: "10",
      rx: "0"
    }))));
  } // Cancel button for non-resumable uploads if individualCancellation is supported (not bundled)


  if (!props.resumableUploads && props.individualCancellation && !props.hideCancelButton) {
    return h(ProgressIndicatorButton, props, h(ProgressCircleContainer, null, h(ProgressCircle, {
      progress: props.file.progress.percentage
    }), h("polygon", {
      className: "cancel",
      transform: "translate(2, 2)",
      points: "19.8856516 11.0625 16 14.9481516 12.1019737 11.0625 11.0625 12.1143484 14.9481516 16 11.0625 19.8980263 12.1019737 20.9375 16 17.0518484 19.8856516 20.9375 20.9375 19.8980263 17.0518484 16 20.9375 12"
    })));
  } // Just progress when buttons are disabled


  return h("div", {
    className: "uppy-Dashboard-Item-progress"
  }, h("div", {
    className: "uppy-Dashboard-Item-progressIndicator"
  }, h(ProgressCircleContainer, null, h(ProgressCircle, {
    progress: props.file.progress.percentage
  }))));
};

},{"preact":76}],87:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var classNames = require('classnames');

var shallowEqual = require('is-shallow-equal');

var FilePreviewAndLink = require('./FilePreviewAndLink');

var FileProgress = require('./FileProgress');

var FileInfo = require('./FileInfo');

var Buttons = require('./Buttons');

module.exports = /*#__PURE__*/function (_Component) {
  _inheritsLoose(FileItem, _Component);

  function FileItem() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = FileItem.prototype;

  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    return !shallowEqual(this.props, nextProps);
  };

  _proto.componentDidMount = function componentDidMount() {
    var file = this.props.file;

    if (!file.preview) {
      this.props.handleRequestThumbnail(file);
    }
  } // VirtualList mounts FileItems again and they emit `thumbnail:request`
  // Otherwise thumbnails are broken or missing after Golden Retriever restores files
  ;

  _proto.componentDidUpdate = function componentDidUpdate() {
    var file = this.props.file;

    if (!file.preview) {
      this.props.handleRequestThumbnail(file);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var file = this.props.file;

    if (!file.preview) {
      this.props.handleCancelThumbnail(file);
    }
  };

  _proto.render = function render() {
    var file = this.props.file;
    var isProcessing = file.progress.preprocess || file.progress.postprocess;
    var isUploaded = file.progress.uploadComplete && !isProcessing && !file.error;
    var uploadInProgressOrComplete = file.progress.uploadStarted || isProcessing;
    var uploadInProgress = file.progress.uploadStarted && !file.progress.uploadComplete || isProcessing;
    var error = file.error || false; // File that Golden Retriever was able to partly restore (only meta, not blob),
    // users still need to re-add it, so its a ghost

    var isGhost = file.isGhost;
    var showRemoveButton = this.props.individualCancellation ? !isUploaded : !uploadInProgress && !isUploaded;

    if (isUploaded && this.props.showRemoveButtonAfterComplete) {
      showRemoveButton = true;
    }

    var dashboardItemClass = classNames({
      'uppy-Dashboard-Item': true,
      'is-inprogress': uploadInProgress && !this.props.recoveredState,
      'is-processing': isProcessing,
      'is-complete': isUploaded,
      'is-error': !!error,
      'is-resumable': this.props.resumableUploads,
      'is-noIndividualCancellation': !this.props.individualCancellation,
      'is-ghost': isGhost
    });
    return h("div", {
      className: dashboardItemClass,
      id: "uppy_" + file.id,
      role: this.props.role
    }, h("div", {
      className: "uppy-Dashboard-Item-preview"
    }, h(FilePreviewAndLink, {
      file: file,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult
    }), h(FileProgress, {
      file: file,
      error: error,
      isUploaded: isUploaded,
      hideRetryButton: this.props.hideRetryButton,
      hideCancelButton: this.props.hideCancelButton,
      hidePauseResumeButton: this.props.hidePauseResumeButton,
      recoveredState: this.props.recoveredState,
      showRemoveButtonAfterComplete: this.props.showRemoveButtonAfterComplete,
      resumableUploads: this.props.resumableUploads,
      individualCancellation: this.props.individualCancellation,
      pauseUpload: this.props.pauseUpload,
      cancelUpload: this.props.cancelUpload,
      retryUpload: this.props.retryUpload,
      i18n: this.props.i18n
    })), h("div", {
      className: "uppy-Dashboard-Item-fileInfoAndButtons"
    }, h(FileInfo, {
      file: file,
      id: this.props.id,
      acquirers: this.props.acquirers,
      containerWidth: this.props.containerWidth,
      i18n: this.props.i18n,
      toggleAddFilesPanel: this.props.toggleAddFilesPanel
    }), h(Buttons, {
      file: file,
      metaFields: this.props.metaFields,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
      showRemoveButton: showRemoveButton,
      canEditFile: this.props.canEditFile,
      uploadInProgressOrComplete: uploadInProgressOrComplete,
      removeFile: this.props.removeFile,
      toggleFileCard: this.props.toggleFileCard,
      openFileEditor: this.props.openFileEditor,
      i18n: this.props.i18n,
      log: this.props.log,
      info: this.props.info
    })));
  };

  return FileItem;
}(Component);

},{"./Buttons":83,"./FileInfo":84,"./FilePreviewAndLink":85,"./FileProgress":86,"classnames":10,"is-shallow-equal":29,"preact":76}],88:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var FileItem = require('./FileItem/index.js');

var VirtualList = require('./VirtualList');

var classNames = require('classnames');

var _require = require('preact'),
    h = _require.h;

function chunks(list, size) {
  var chunked = [];
  var currentChunk = [];
  list.forEach(function (item, i) {
    if (currentChunk.length < size) {
      currentChunk.push(item);
    } else {
      chunked.push(currentChunk);
      currentChunk = [item];
    }
  });
  if (currentChunk.length) chunked.push(currentChunk);
  return chunked;
}

module.exports = function (props) {
  var noFiles = props.totalFileCount === 0;
  var dashboardFilesClass = classNames('uppy-Dashboard-files', {
    'uppy-Dashboard-files--noFiles': noFiles
  }); // It's not great that this is hardcoded!
  // It's ESPECIALLY not great that this is checking against `itemsPerRow`!

  var rowHeight = props.itemsPerRow === 1 // Mobile
  ? 71 // 190px height + 2 * 5px margin
  : 200;
  var fileProps = {
    // FIXME This is confusing, it's actually the Dashboard's plugin ID
    id: props.id,
    error: props.error,
    // TODO move this to context
    i18n: props.i18n,
    log: props.log,
    info: props.info,
    // features
    acquirers: props.acquirers,
    resumableUploads: props.resumableUploads,
    individualCancellation: props.individualCancellation,
    // visual options
    hideRetryButton: props.hideRetryButton,
    hidePauseResumeButton: props.hidePauseResumeButton,
    hideCancelButton: props.hideCancelButton,
    showLinkToFileUploadResult: props.showLinkToFileUploadResult,
    showRemoveButtonAfterComplete: props.showRemoveButtonAfterComplete,
    isWide: props.isWide,
    metaFields: props.metaFields,
    recoveredState: props.recoveredState,
    // callbacks
    retryUpload: props.retryUpload,
    pauseUpload: props.pauseUpload,
    cancelUpload: props.cancelUpload,
    toggleFileCard: props.toggleFileCard,
    removeFile: props.removeFile,
    handleRequestThumbnail: props.handleRequestThumbnail,
    handleCancelThumbnail: props.handleCancelThumbnail
  };

  var sortByGhostComesFirst = function sortByGhostComesFirst(file1, file2) {
    return props.files[file2].isGhost - props.files[file1].isGhost;
  }; // Sort files by file.isGhost, ghost files first, only if recoveredState is present


  var files = Object.keys(props.files);
  if (props.recoveredState) files.sort(sortByGhostComesFirst);
  var rows = chunks(files, props.itemsPerRow);

  function renderRow(row) {
    return (// The `role="presentation` attribute ensures that the list items are properly associated with the `VirtualList` element
      // We use the first file ID as the keythis should not change across scroll rerenders
      h("div", {
        role: "presentation",
        key: row[0]
      }, row.map(function (fileID) {
        return h(FileItem, _extends({
          key: fileID
        }, fileProps, {
          role: "listitem",
          openFileEditor: props.openFileEditor,
          canEditFile: props.canEditFile,
          toggleAddFilesPanel: props.toggleAddFilesPanel,
          file: props.files[fileID]
        }));
      }))
    );
  }

  return h(VirtualList, {
    class: dashboardFilesClass,
    role: "list",
    data: rows,
    renderRow: renderRow,
    rowHeight: rowHeight
  });
};

},{"./FileItem/index.js":87,"./VirtualList":93,"classnames":10,"preact":76}],89:[function(require,module,exports){
var getFileTypeIcon = require('../utils/getFileTypeIcon');

var _require = require('preact'),
    h = _require.h;

module.exports = function FilePreview(props) {
  var file = props.file;

  if (file.preview) {
    return h("img", {
      className: "uppy-Dashboard-Item-previewImg",
      alt: file.name,
      src: file.preview
    });
  }

  var _getFileTypeIcon = getFileTypeIcon(file.type),
      color = _getFileTypeIcon.color,
      icon = _getFileTypeIcon.icon;

  return h("div", {
    className: "uppy-Dashboard-Item-previewIconWrap"
  }, h("span", {
    className: "uppy-Dashboard-Item-previewIcon",
    style: {
      color: color
    }
  }, icon), h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-Dashboard-Item-previewIconBg",
    width: "58",
    height: "76",
    viewBox: "0 0 58 76"
  }, h("rect", {
    fill: "#FFF",
    width: "58",
    height: "76",
    rx: "3",
    fillRule: "evenodd"
  })));
};

},{"../utils/getFileTypeIcon":98,"preact":76}],90:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

var ignoreEvent = require('../utils/ignoreEvent.js');

function PickerPanelContent(props) {
  return h("div", {
    className: classNames('uppy-DashboardContent-panel', props.className),
    role: "tabpanel",
    "data-uppy-panelType": "PickerPanel",
    id: "uppy-DashboardContent-panel--" + props.activePickerPanel.id,
    onDragOver: ignoreEvent,
    onDragLeave: ignoreEvent,
    onDrop: ignoreEvent,
    onPaste: ignoreEvent
  }, h("div", {
    className: "uppy-DashboardContent-bar"
  }, h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18n('importFrom', {
    name: props.activePickerPanel.name
  })), h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: props.hideAllPanels
  }, props.i18n('cancel'))), h("div", {
    className: "uppy-DashboardContent-panelBody"
  }, props.getPlugin(props.activePickerPanel.id).render(props.state)));
}

module.exports = PickerPanelContent;

},{"../utils/ignoreEvent.js":99,"classnames":10,"preact":76}],91:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var uploadStates = {
  STATE_ERROR: 'error',
  STATE_WAITING: 'waiting',
  STATE_PREPROCESSING: 'preprocessing',
  STATE_UPLOADING: 'uploading',
  STATE_POSTPROCESSING: 'postprocessing',
  STATE_COMPLETE: 'complete',
  STATE_PAUSED: 'paused'
};

function getUploadingState(isAllErrored, isAllComplete, isAllPaused, files) {
  if (files === void 0) {
    files = {};
  }

  if (isAllErrored) {
    return uploadStates.STATE_ERROR;
  }

  if (isAllComplete) {
    return uploadStates.STATE_COMPLETE;
  }

  if (isAllPaused) {
    return uploadStates.STATE_PAUSED;
  }

  var state = uploadStates.STATE_WAITING;
  var fileIDs = Object.keys(files);

  for (var i = 0; i < fileIDs.length; i++) {
    var progress = files[fileIDs[i]].progress; // If ANY files are being uploaded right now, show the uploading state.

    if (progress.uploadStarted && !progress.uploadComplete) {
      return uploadStates.STATE_UPLOADING;
    } // If files are being preprocessed AND postprocessed at this time, we show the
    // preprocess state. If any files are being uploaded we show uploading.


    if (progress.preprocess && state !== uploadStates.STATE_UPLOADING) {
      state = uploadStates.STATE_PREPROCESSING;
    } // If NO files are being preprocessed or uploaded right now, but some files are
    // being postprocessed, show the postprocess state.


    if (progress.postprocess && state !== uploadStates.STATE_UPLOADING && state !== uploadStates.STATE_PREPROCESSING) {
      state = uploadStates.STATE_POSTPROCESSING;
    }
  }

  return state;
}

function UploadStatus(props) {
  var uploadingState = getUploadingState(props.isAllErrored, props.isAllComplete, props.isAllPaused, props.files);

  switch (uploadingState) {
    case 'uploading':
      return props.i18n('uploadingXFiles', {
        smart_count: props.inProgressNotPausedFiles.length
      });

    case 'preprocessing':
    case 'postprocessing':
      return props.i18n('processingXFiles', {
        smart_count: props.processingFiles.length
      });

    case 'paused':
      return props.i18n('uploadPaused');

    case 'waiting':
      return props.i18n('xFilesSelected', {
        smart_count: props.newFiles.length
      });

    case 'complete':
      return props.i18n('uploadComplete');
  }
}

function PanelTopBar(props) {
  var allowNewUpload = props.allowNewUpload; // TODO maybe this should be done in ../index.js, then just pass that down as `allowNewUpload`

  if (allowNewUpload && props.maxNumberOfFiles) {
    allowNewUpload = props.totalFileCount < props.maxNumberOfFiles;
  }

  return h("div", {
    className: "uppy-DashboardContent-bar"
  }, !props.isAllComplete && !props.hideCancelButton ? h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: props.cancelAll
  }, props.i18n('cancel')) : h("div", null), h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, h(UploadStatus, props)), allowNewUpload ? h("button", {
    className: "uppy-DashboardContent-addMore",
    type: "button",
    "aria-label": props.i18n('addMoreFiles'),
    title: props.i18n('addMoreFiles'),
    onClick: function onClick() {
      return props.toggleAddFilesPanel(true);
    }
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "15",
    height: "15",
    viewBox: "0 0 15 15"
  }, h("path", {
    d: "M8 6.5h6a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H8v6a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V8h-6a.5.5 0 0 1-.5-.5V7a.5.5 0 0 1 .5-.5h6v-6A.5.5 0 0 1 7 0h.5a.5.5 0 0 1 .5.5v6z"
  })), h("span", {
    className: "uppy-DashboardContent-addMoreCaption"
  }, props.i18n('addMore'))) : h("div", null));
}

module.exports = PanelTopBar;

},{"preact":76}],92:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    cloneElement = _require.cloneElement,
    Component = _require.Component;

var classNames = require('classnames');

var transitionName = 'uppy-transition-slideDownUp';
var duration = 250;
/**
 * Vertical slide transition.
 *
 * This can take a _single_ child component, which _must_ accept a `className` prop.
 *
 * Currently this is specific to the `uppy-transition-slideDownUp` transition,
 * but it should be simple to extend this for any type of single-element
 * transition by setting the CSS name and duration as props.
 */

var Slide = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Slide, _Component);

  function Slide(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.state = {
      cachedChildren: null,
      className: ''
    };
    return _this;
  }

  var _proto = Slide.prototype;

  _proto.componentWillUpdate = function componentWillUpdate(nextProps) {
    var _this2 = this;

    var cachedChildren = this.state.cachedChildren;
    var child = nextProps.children[0];
    if (cachedChildren === child) return;
    var patch = {
      cachedChildren: child
    }; // Enter transition

    if (child && !cachedChildren) {
      patch.className = transitionName + "-enter";
      cancelAnimationFrame(this.animationFrame);
      clearTimeout(this.leaveTimeout);
      this.leaveTimeout = undefined;
      this.animationFrame = requestAnimationFrame(function () {
        // Force it to render before we add the active class
        _this2.base.getBoundingClientRect();

        _this2.setState({
          className: transitionName + "-enter " + transitionName + "-enter-active"
        });

        _this2.enterTimeout = setTimeout(function () {
          _this2.setState({
            className: ''
          });
        }, duration);
      });
    } // Leave transition


    if (cachedChildren && !child && this.leaveTimeout === undefined) {
      patch.cachedChildren = cachedChildren;
      patch.className = transitionName + "-leave";
      cancelAnimationFrame(this.animationFrame);
      clearTimeout(this.enterTimeout);
      this.enterTimeout = undefined;
      this.animationFrame = requestAnimationFrame(function () {
        _this2.setState({
          className: transitionName + "-leave " + transitionName + "-leave-active"
        });

        _this2.leaveTimeout = setTimeout(function () {
          _this2.setState({
            cachedChildren: null,
            className: ''
          });
        }, duration);
      });
    }

    this.setState(patch);
  };

  _proto.render = function render() {
    var _this$state = this.state,
        cachedChildren = _this$state.cachedChildren,
        className = _this$state.className;

    if (!cachedChildren) {
      return null;
    }

    return cloneElement(cachedChildren, {
      className: classNames(className, cachedChildren.attributes.className)
    });
  };

  return Slide;
}(Component);

module.exports = Slide;

},{"classnames":10,"preact":76}],93:[function(require,module,exports){
var _excluded = ["data", "rowHeight", "renderRow", "overscanCount", "sync"];

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Adapted from preact-virtual-list: https://github.com/developit/preact-virtual-list
 *
 *  2016 Jason Miller
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Adaptations:
 * - Added role=presentation to helper elements
 * - Tweaked styles for Uppy's Dashboard use case
 */
var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var STYLE_INNER = {
  position: 'relative',
  // Disabled for our use case: the wrapper elements around FileList already deal with overflow,
  // and this additional property would hide things that we want to show.
  //
  // overflow: 'hidden',
  width: '100%',
  minHeight: '100%'
};
var STYLE_CONTENT = {
  position: 'absolute',
  top: 0,
  left: 0,
  // Because the `top` value gets set to some offset, this `height` being 100% would make the scrollbar
  // stretch far beyond the content. For our use case, the content div actually can get its height from
  // the elements inside it, so we don't need to specify a `height` property at all.
  //
  // height: '100%',
  width: '100%',
  overflow: 'visible'
};

var VirtualList = /*#__PURE__*/function (_Component) {
  _inheritsLoose(VirtualList, _Component);

  function VirtualList(props) {
    var _this;

    _this = _Component.call(this, props) || this; // The currently focused node, used to retain focus when the visible rows change.
    // To avoid update loops, this should not cause state updates, so it's kept as a plain property.

    _this.handleResize = function () {
      _this.resize();
    };

    _this.handleScroll = function () {
      _this.setState({
        offset: _this.base.scrollTop
      });

      if (_this.props.sync) {
        _this.forceUpdate();
      }
    };

    _this.focusElement = null;
    _this.state = {
      offset: 0,
      height: 0
    };
    return _this;
  }

  var _proto = VirtualList.prototype;

  _proto.resize = function resize() {
    if (this.state.height !== this.base.offsetHeight) {
      this.setState({
        height: this.base.offsetHeight
      });
    }
  };

  _proto.componentWillUpdate = function componentWillUpdate() {
    if (this.base.contains(document.activeElement)) {
      this.focusElement = document.activeElement;
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    // Maintain focus when rows are added and removed.
    if (this.focusElement && this.focusElement.parentNode && document.activeElement !== this.focusElement) {
      this.focusElement.focus();
    }

    this.focusElement = null;
    this.resize();
  };

  _proto.componentDidMount = function componentDidMount() {
    this.resize();
    window.addEventListener('resize', this.handleResize);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
  };

  _proto.render = function render(_ref) {
    var data = _ref.data,
        rowHeight = _ref.rowHeight,
        renderRow = _ref.renderRow,
        _ref$overscanCount = _ref.overscanCount,
        overscanCount = _ref$overscanCount === void 0 ? 10 : _ref$overscanCount,
        sync = _ref.sync,
        props = _objectWithoutPropertiesLoose(_ref, _excluded);

    var _this$state = this.state,
        offset = _this$state.offset,
        height = _this$state.height; // first visible row index

    var start = Math.floor(offset / rowHeight); // actual number of visible rows (without overscan)

    var visibleRowCount = Math.floor(height / rowHeight); // Overscan: render blocks of rows modulo an overscan row count
    // This dramatically reduces DOM writes during scrolling

    if (overscanCount) {
      start = Math.max(0, start - start % overscanCount);
      visibleRowCount += overscanCount;
    } // last visible + overscan row index + padding to allow keyboard focus to travel past the visible area


    var end = start + visibleRowCount + 4; // data slice currently in viewport plus overscan items

    var selection = data.slice(start, end);

    var styleInner = _extends({}, STYLE_INNER, {
      height: data.length * rowHeight
    });

    var styleContent = _extends({}, STYLE_CONTENT, {
      top: start * rowHeight
    }); // The `role="presentation"` attributes ensure that these wrapper elements are not treated as list
    // items by accessibility and outline tools.


    return h("div", _extends({
      onScroll: this.handleScroll
    }, props), h("div", {
      role: "presentation",
      style: styleInner
    }, h("div", {
      role: "presentation",
      style: styleContent
    }, selection.map(renderRow))));
  };

  return VirtualList;
}(Component);

module.exports = VirtualList;

},{"preact":76}],94:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h;

var _require2 = require('./../../core'),
    Plugin = _require2.Plugin;

var Translator = require('./../../utils/lib/Translator');

var DashboardUI = require('./components/Dashboard');

var StatusBar = require('./../../status-bar');

var Informer = require('./../../informer');

var ThumbnailGenerator = require('./../../thumbnail-generator');

var findAllDOMElements = require('./../../utils/lib/findAllDOMElements');

var toArray = require('./../../utils/lib/toArray');

var getDroppedFiles = require('./../../utils/lib/getDroppedFiles');

var getTextDirection = require('./../../utils/lib/getTextDirection');

var trapFocus = require('./utils/trapFocus');

var cuid = require('cuid');

var ResizeObserver = require('resize-observer-polyfill').default || require('resize-observer-polyfill');

var createSuperFocus = require('./utils/createSuperFocus');

var memoize = require('memoize-one').default || require('memoize-one');

var FOCUSABLE_ELEMENTS = require('./../../utils/lib/FOCUSABLE_ELEMENTS');

var TAB_KEY = 9;
var ESC_KEY = 27;

function createPromise() {
  var o = {};
  o.promise = new Promise(function (resolve, reject) {
    o.resolve = resolve;
    o.reject = reject;
  });
  return o;
}

function defaultPickerIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "30",
    height: "30",
    viewBox: "0 0 30 30"
  }, h("path", {
    d: "M15 30c8.284 0 15-6.716 15-15 0-8.284-6.716-15-15-15C6.716 0 0 6.716 0 15c0 8.284 6.716 15 15 15zm4.258-12.676v6.846h-8.426v-6.846H5.204l9.82-12.364 9.82 12.364H19.26z"
  }));
}
/**
 * Dashboard UI with previews, metadata editing, tabs for various services and more
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Dashboard, _Plugin);

  function Dashboard(uppy, _opts) {
    var _this;

    _this = _Plugin.call(this, uppy, _opts) || this;

    _this.setOptions = function (newOpts) {
      _Plugin.prototype.setOptions.call(_assertThisInitialized(_this), newOpts);

      _this.i18nInit();
    };

    _this.i18nInit = function () {
      _this.translator = new Translator([_this.defaultLocale, _this.uppy.locale, _this.opts.locale]);
      _this.i18n = _this.translator.translate.bind(_this.translator);
      _this.i18nArray = _this.translator.translateArray.bind(_this.translator);

      _this.setPluginState(); // so that UI re-renders and we see the updated locale

    };

    _this.removeTarget = function (plugin) {
      var pluginState = _this.getPluginState(); // filter out the one we want to remove


      var newTargets = pluginState.targets.filter(function (target) {
        return target.id !== plugin.id;
      });

      _this.setPluginState({
        targets: newTargets
      });
    };

    _this.addTarget = function (plugin) {
      var callerPluginId = plugin.id || plugin.constructor.name;
      var callerPluginName = plugin.title || callerPluginId;
      var callerPluginType = plugin.type;

      if (callerPluginType !== 'acquirer' && callerPluginType !== 'progressindicator' && callerPluginType !== 'editor') {
        var msg = 'Dashboard: can only be targeted by plugins of types: acquirer, progressindicator, editor';

        _this.uppy.log(msg, 'error');

        return;
      }

      var target = {
        id: callerPluginId,
        name: callerPluginName,
        type: callerPluginType
      };

      var state = _this.getPluginState();

      var newTargets = state.targets.slice();
      newTargets.push(target);

      _this.setPluginState({
        targets: newTargets
      });

      return _this.el;
    };

    _this.hideAllPanels = function () {
      var update = {
        activePickerPanel: false,
        showAddFilesPanel: false,
        activeOverlayType: null,
        fileCardFor: null,
        showFileEditor: false
      };

      var current = _this.getPluginState();

      if (current.activePickerPanel === update.activePickerPanel && current.showAddFilesPanel === update.showAddFilesPanel && current.showFileEditor === update.showFileEditor && current.activeOverlayType === update.activeOverlayType) {
        // avoid doing a state update if nothing changed
        return;
      }

      _this.setPluginState(update);
    };

    _this.showPanel = function (id) {
      var _this$getPluginState = _this.getPluginState(),
          targets = _this$getPluginState.targets;

      var activePickerPanel = targets.filter(function (target) {
        return target.type === 'acquirer' && target.id === id;
      })[0];

      _this.setPluginState({
        activePickerPanel: activePickerPanel,
        activeOverlayType: 'PickerPanel'
      });
    };

    _this.canEditFile = function (file) {
      var _this$getPluginState2 = _this.getPluginState(),
          targets = _this$getPluginState2.targets;

      var editors = _this._getEditors(targets);

      return editors.some(function (target) {
        return _this.uppy.getPlugin(target.id).canEditFile(file);
      });
    };

    _this.openFileEditor = function (file) {
      var _this$getPluginState3 = _this.getPluginState(),
          targets = _this$getPluginState3.targets;

      var editors = _this._getEditors(targets);

      _this.setPluginState({
        showFileEditor: true,
        fileCardFor: file.id || null,
        activeOverlayType: 'FileEditor'
      });

      editors.forEach(function (editor) {
        _this.uppy.getPlugin(editor.id).selectFile(file);
      });
    };

    _this.saveFileEditor = function () {
      var _this$getPluginState4 = _this.getPluginState(),
          targets = _this$getPluginState4.targets;

      var editors = _this._getEditors(targets);

      editors.forEach(function (editor) {
        _this.uppy.getPlugin(editor.id).save();
      });

      _this.hideAllPanels();
    };

    _this.openModal = function () {
      var _createPromise = createPromise(),
          promise = _createPromise.promise,
          resolve = _createPromise.resolve; // save scroll position


      _this.savedScrollPosition = window.pageYOffset; // save active element, so we can restore focus when modal is closed

      _this.savedActiveElement = document.activeElement;

      if (_this.opts.disablePageScrollWhenModalOpen) {
        document.body.classList.add('uppy-Dashboard-isFixed');
      }

      if (_this.opts.animateOpenClose && _this.getPluginState().isClosing) {
        var handler = function handler() {
          _this.setPluginState({
            isHidden: false
          });

          _this.el.removeEventListener('animationend', handler, false);

          resolve();
        };

        _this.el.addEventListener('animationend', handler, false);
      } else {
        _this.setPluginState({
          isHidden: false
        });

        resolve();
      }

      if (_this.opts.browserBackButtonClose) {
        _this.updateBrowserHistory();
      } // handle ESC and TAB keys in modal dialog


      document.addEventListener('keydown', _this.handleKeyDownInModal);

      _this.uppy.emit('dashboard:modal-open');

      return promise;
    };

    _this.closeModal = function (opts) {
      if (opts === void 0) {
        opts = {};
      }

      var _opts2 = opts,
          _opts2$manualClose = _opts2.manualClose,
          manualClose = _opts2$manualClose === void 0 ? true : _opts2$manualClose;

      var _this$getPluginState5 = _this.getPluginState(),
          isHidden = _this$getPluginState5.isHidden,
          isClosing = _this$getPluginState5.isClosing;

      if (isHidden || isClosing) {
        // short-circuit if animation is ongoing
        return;
      }

      var _createPromise2 = createPromise(),
          promise = _createPromise2.promise,
          resolve = _createPromise2.resolve;

      if (_this.opts.disablePageScrollWhenModalOpen) {
        document.body.classList.remove('uppy-Dashboard-isFixed');
      }

      if (_this.opts.animateOpenClose) {
        _this.setPluginState({
          isClosing: true
        });

        var handler = function handler() {
          _this.setPluginState({
            isHidden: true,
            isClosing: false
          });

          _this.superFocus.cancel();

          _this.savedActiveElement.focus();

          _this.el.removeEventListener('animationend', handler, false);

          resolve();
        };

        _this.el.addEventListener('animationend', handler, false);
      } else {
        _this.setPluginState({
          isHidden: true
        });

        _this.superFocus.cancel();

        _this.savedActiveElement.focus();

        resolve();
      } // handle ESC and TAB keys in modal dialog


      document.removeEventListener('keydown', _this.handleKeyDownInModal);

      if (manualClose) {
        if (_this.opts.browserBackButtonClose) {
          // Make sure that the latest entry in the history state is our modal name
          if (history.state && history.state[_this.modalName]) {
            // Go back in history to clear out the entry we created (ultimately closing the modal)
            history.go(-1);
          }
        }
      }

      _this.uppy.emit('dashboard:modal-closed');

      return promise;
    };

    _this.isModalOpen = function () {
      return !_this.getPluginState().isHidden || false;
    };

    _this.requestCloseModal = function () {
      if (_this.opts.onRequestCloseModal) {
        return _this.opts.onRequestCloseModal();
      }

      return _this.closeModal();
    };

    _this.setDarkModeCapability = function (isDarkModeOn) {
      var _this$uppy$getState = _this.uppy.getState(),
          capabilities = _this$uppy$getState.capabilities;

      _this.uppy.setState({
        capabilities: _extends({}, capabilities, {
          darkMode: isDarkModeOn
        })
      });
    };

    _this.handleSystemDarkModeChange = function (event) {
      var isDarkModeOnNow = event.matches;

      _this.uppy.log("[Dashboard] Dark mode is " + (isDarkModeOnNow ? 'on' : 'off'));

      _this.setDarkModeCapability(isDarkModeOnNow);
    };

    _this.toggleFileCard = function (show, fileID) {
      var file = _this.uppy.getFile(fileID);

      if (show) {
        _this.uppy.emit('dashboard:file-edit-start', file);
      } else {
        _this.uppy.emit('dashboard:file-edit-complete', file);
      }

      _this.setPluginState({
        fileCardFor: show ? fileID : null,
        activeOverlayType: show ? 'FileCard' : null
      });
    };

    _this.toggleAddFilesPanel = function (show) {
      _this.setPluginState({
        showAddFilesPanel: show,
        activeOverlayType: show ? 'AddFiles' : null
      });
    };

    _this.addFiles = function (files) {
      var descriptors = files.map(function (file) {
        return {
          source: _this.id,
          name: file.name,
          type: file.type,
          data: file,
          meta: {
            // path of the file relative to the ancestor directory the user selected.
            // e.g. 'docs/Old Prague/airbnb.pdf'
            relativePath: file.relativePath || null
          }
        };
      });

      try {
        _this.uppy.addFiles(descriptors);
      } catch (err) {
        _this.uppy.log(err);
      }
    };

    _this.startListeningToResize = function () {
      // Watch for Dashboard container (`.uppy-Dashboard-inner`) resize
      // and update containerWidth/containerHeight in plugin state accordingly.
      // Emits first event on initialization.
      _this.resizeObserver = new ResizeObserver(function (entries, observer) {
        var uppyDashboardInnerEl = entries[0];
        var _uppyDashboardInnerEl = uppyDashboardInnerEl.contentRect,
            width = _uppyDashboardInnerEl.width,
            height = _uppyDashboardInnerEl.height;

        _this.uppy.log("[Dashboard] resized: " + width + " / " + height, 'debug');

        _this.setPluginState({
          containerWidth: width,
          containerHeight: height,
          areInsidesReadyToBeVisible: true
        });
      });

      _this.resizeObserver.observe(_this.el.querySelector('.uppy-Dashboard-inner')); // If ResizeObserver fails to emit an event telling us what size to use - default to the mobile view


      _this.makeDashboardInsidesVisibleAnywayTimeout = setTimeout(function () {
        var pluginState = _this.getPluginState();

        var isModalAndClosed = !_this.opts.inline && pluginState.isHidden;

        if ( // if ResizeObserver hasn't yet fired,
        !pluginState.areInsidesReadyToBeVisible // and it's not due to the modal being closed
        && !isModalAndClosed) {
          _this.uppy.log("[Dashboard] resize event didn't fire on time: defaulted to mobile layout", 'debug');

          _this.setPluginState({
            areInsidesReadyToBeVisible: true
          });
        }
      }, 1000);
    };

    _this.stopListeningToResize = function () {
      _this.resizeObserver.disconnect();

      clearTimeout(_this.makeDashboardInsidesVisibleAnywayTimeout);
    };

    _this.recordIfFocusedOnUppyRecently = function (event) {
      if (_this.el.contains(event.target)) {
        _this.ifFocusedOnUppyRecently = true;
      } else {
        _this.ifFocusedOnUppyRecently = false; // ___Why run this.superFocus.cancel here when it already runs in superFocusOnEachUpdate?
        //    Because superFocus is debounced, when we move from Uppy to some other element on the page,
        //    previously run superFocus sometimes hits and moves focus back to Uppy.

        _this.superFocus.cancel();
      }
    };

    _this.disableAllFocusableElements = function (disable) {
      var focusableNodes = toArray(_this.el.querySelectorAll(FOCUSABLE_ELEMENTS));

      if (disable) {
        focusableNodes.forEach(function (node) {
          // save previous tabindex in a data-attribute, to restore when enabling
          var currentTabIndex = node.getAttribute('tabindex');

          if (currentTabIndex) {
            node.dataset.inertTabindex = currentTabIndex;
          }

          node.setAttribute('tabindex', '-1');
        });
      } else {
        focusableNodes.forEach(function (node) {
          if ('inertTabindex' in node.dataset) {
            node.setAttribute('tabindex', node.dataset.inertTabindex);
          } else {
            node.removeAttribute('tabindex');
          }
        });
      }

      _this.dashboardIsDisabled = disable;
    };

    _this.updateBrowserHistory = function () {
      // Ensure history state does not already contain our modal name to avoid double-pushing
      if (!history.state || !history.state[_this.modalName]) {
        var _extends2;

        // Push to history so that the page is not lost on browser back button press
        history.pushState(_extends({}, history.state, (_extends2 = {}, _extends2[_this.modalName] = true, _extends2)), '');
      } // Listen for back button presses


      window.addEventListener('popstate', _this.handlePopState, false);
    };

    _this.handlePopState = function (event) {
      // Close the modal if the history state no longer contains our modal name
      if (_this.isModalOpen() && (!event.state || !event.state[_this.modalName])) {
        _this.closeModal({
          manualClose: false
        });
      } // When the browser back button is pressed and uppy is now the latest entry in the history but the modal is closed, fix the history by removing the uppy history entry
      // This occurs when another entry is added into the history state while the modal is open, and then the modal gets manually closed
      // Solves PR #575 (https://github.com/transloadit/uppy/pull/575)


      if (!_this.isModalOpen() && event.state && event.state[_this.modalName]) {
        history.go(-1);
      }
    };

    _this.handleKeyDownInModal = function (event) {
      // close modal on esc key press
      if (event.keyCode === ESC_KEY) _this.requestCloseModal(event); // trap focus on tab key press

      if (event.keyCode === TAB_KEY) trapFocus.forModal(event, _this.getPluginState().activeOverlayType, _this.el);
    };

    _this.handleClickOutside = function () {
      if (_this.opts.closeModalOnClickOutside) _this.requestCloseModal();
    };

    _this.handlePaste = function (event) {
      // 1. Let any acquirer plugin (Url/Webcam/etc.) handle pastes to the root
      _this.uppy.iteratePlugins(function (plugin) {
        if (plugin.type === 'acquirer') {
          // Every Plugin with .type acquirer can define handleRootPaste(event)
          plugin.handleRootPaste && plugin.handleRootPaste(event);
        }
      }); // 2. Add all dropped files


      var files = toArray(event.clipboardData.files);

      _this.addFiles(files);
    };

    _this.handleInputChange = function (event) {
      event.preventDefault();
      var files = toArray(event.target.files);

      _this.addFiles(files);
    };

    _this.handleDragOver = function (event) {
      event.preventDefault();
      event.stopPropagation();

      if (_this.opts.disabled || _this.opts.disableLocalFiles) {
        return;
      } // 1. Add a small (+) icon on drop
      // (and prevent browsers from interpreting this as files being _moved_ into the browser, https://github.com/transloadit/uppy/issues/1978)


      event.dataTransfer.dropEffect = 'copy';
      clearTimeout(_this.removeDragOverClassTimeout);

      _this.setPluginState({
        isDraggingOver: true
      });
    };

    _this.handleDragLeave = function (event) {
      event.preventDefault();
      event.stopPropagation();

      if (_this.opts.disabled || _this.opts.disableLocalFiles) {
        return;
      }

      clearTimeout(_this.removeDragOverClassTimeout); // Timeout against flickering, this solution is taken from drag-drop library. Solution with 'pointer-events: none' didn't work across browsers.

      _this.removeDragOverClassTimeout = setTimeout(function () {
        _this.setPluginState({
          isDraggingOver: false
        });
      }, 50);
    };

    _this.handleDrop = function (event, dropCategory) {
      event.preventDefault();
      event.stopPropagation();

      if (_this.opts.disabled || _this.opts.disableLocalFiles) {
        return;
      }

      clearTimeout(_this.removeDragOverClassTimeout); // 2. Remove dragover class

      _this.setPluginState({
        isDraggingOver: false
      }); // 3. Let any acquirer plugin (Url/Webcam/etc.) handle drops to the root


      _this.uppy.iteratePlugins(function (plugin) {
        if (plugin.type === 'acquirer') {
          // Every Plugin with .type acquirer can define handleRootDrop(event)
          plugin.handleRootDrop && plugin.handleRootDrop(event);
        }
      }); // 4. Add all dropped files


      var executedDropErrorOnce = false;

      var logDropError = function logDropError(error) {
        _this.uppy.log(error, 'error'); // In practice all drop errors are most likely the same, so let's just show one to avoid overwhelming the user


        if (!executedDropErrorOnce) {
          _this.uppy.info(error.message, 'error');

          executedDropErrorOnce = true;
        }
      };

      getDroppedFiles(event.dataTransfer, {
        logDropError: logDropError
      }).then(function (files) {
        if (files.length > 0) {
          _this.uppy.log('[Dashboard] Files were dropped');

          _this.addFiles(files);
        }
      });
    };

    _this.handleRequestThumbnail = function (file) {
      if (!_this.opts.waitForThumbnailsBeforeUpload) {
        _this.uppy.emit('thumbnail:request', file);
      }
    };

    _this.handleCancelThumbnail = function (file) {
      if (!_this.opts.waitForThumbnailsBeforeUpload) {
        _this.uppy.emit('thumbnail:cancel', file);
      }
    };

    _this.handleKeyDownInInline = function (event) {
      // Trap focus on tab key press.
      if (event.keyCode === TAB_KEY) trapFocus.forInline(event, _this.getPluginState().activeOverlayType, _this.el);
    };

    _this.handlePasteOnBody = function (event) {
      var isFocusInOverlay = _this.el.contains(document.activeElement);

      if (isFocusInOverlay) {
        _this.handlePaste(event);
      }
    };

    _this.handleComplete = function (_ref) {
      var failed = _ref.failed;

      if (_this.opts.closeAfterFinish && failed.length === 0) {
        // All uploads are done
        _this.requestCloseModal();
      }
    };

    _this.handleCancelRestore = function () {
      _this.uppy.emit('restore-canceled');
    };

    _this._openFileEditorWhenFilesAdded = function (files) {
      var firstFile = files[0];

      if (_this.canEditFile(firstFile)) {
        _this.openFileEditor(firstFile);
      }
    };

    _this.initEvents = function () {
      // Modal open button
      if (_this.opts.trigger && !_this.opts.inline) {
        var showModalTrigger = findAllDOMElements(_this.opts.trigger);

        if (showModalTrigger) {
          showModalTrigger.forEach(function (trigger) {
            return trigger.addEventListener('click', _this.openModal);
          });
        } else {
          _this.uppy.log('Dashboard modal trigger not found. Make sure `trigger` is set in Dashboard options, unless you are planning to call `dashboard.openModal()` method yourself', 'warning');
        }
      }

      _this.startListeningToResize();

      document.addEventListener('paste', _this.handlePasteOnBody);

      _this.uppy.on('plugin-remove', _this.removeTarget);

      _this.uppy.on('file-added', _this.hideAllPanels);

      _this.uppy.on('dashboard:modal-closed', _this.hideAllPanels);

      _this.uppy.on('file-editor:complete', _this.hideAllPanels);

      _this.uppy.on('complete', _this.handleComplete); // ___Why fire on capture?
      //    Because this.ifFocusedOnUppyRecently needs to change before onUpdate() fires.


      document.addEventListener('focus', _this.recordIfFocusedOnUppyRecently, true);
      document.addEventListener('click', _this.recordIfFocusedOnUppyRecently, true);

      if (_this.opts.inline) {
        _this.el.addEventListener('keydown', _this.handleKeyDownInInline);
      }

      if (_this.opts.autoOpenFileEditor) {
        _this.uppy.on('files-added', _this._openFileEditorWhenFilesAdded);
      }
    };

    _this.removeEvents = function () {
      var showModalTrigger = findAllDOMElements(_this.opts.trigger);

      if (!_this.opts.inline && showModalTrigger) {
        showModalTrigger.forEach(function (trigger) {
          return trigger.removeEventListener('click', _this.openModal);
        });
      }

      _this.stopListeningToResize();

      document.removeEventListener('paste', _this.handlePasteOnBody);
      window.removeEventListener('popstate', _this.handlePopState, false);

      _this.uppy.off('plugin-remove', _this.removeTarget);

      _this.uppy.off('file-added', _this.hideAllPanels);

      _this.uppy.off('dashboard:modal-closed', _this.hideAllPanels);

      _this.uppy.off('file-editor:complete', _this.hideAllPanels);

      _this.uppy.off('complete', _this.handleComplete);

      document.removeEventListener('focus', _this.recordIfFocusedOnUppyRecently);
      document.removeEventListener('click', _this.recordIfFocusedOnUppyRecently);

      if (_this.opts.inline) {
        _this.el.removeEventListener('keydown', _this.handleKeyDownInInline);
      }

      if (_this.opts.autoOpenFileEditor) {
        _this.uppy.off('files-added', _this._openFileEditorWhenFilesAdded);
      }
    };

    _this.superFocusOnEachUpdate = function () {
      var isFocusInUppy = _this.el.contains(document.activeElement); // When focus is lost on the page (== focus is on body for most browsers, or focus is null for IE11)


      var isFocusNowhere = document.activeElement === document.body || document.activeElement === null;

      var isInformerHidden = _this.uppy.getState().info.isHidden;

      var isModal = !_this.opts.inline;

      if ( // If update is connected to showing the Informer - let the screen reader calmly read it.
      isInformerHidden && ( // If we are in a modal - always superfocus without concern for other elements on the page (user is unlikely to want to interact with the rest of the page)
      isModal // If we are already inside of Uppy, or
      || isFocusInUppy // If we are not focused on anything BUT we have already, at least once, focused on uppy
      //   1. We focus when isFocusNowhere, because when the element we were focused on disappears (e.g. an overlay), - focus gets lost. If user is typing something somewhere else on the page, - focus won't be 'nowhere'.
      //   2. We only focus when focus is nowhere AND this.ifFocusedOnUppyRecently, to avoid focus jumps if we do something else on the page.
      //   [Practical check] Without '&& this.ifFocusedOnUppyRecently', in Safari, in inline mode, when file is uploading, - navigate via tab to the checkbox, try to press space multiple times. Focus will jump to Uppy.
      || isFocusNowhere && _this.ifFocusedOnUppyRecently)) {
        _this.superFocus(_this.el, _this.getPluginState().activeOverlayType);
      } else {
        _this.superFocus.cancel();
      }
    };

    _this.afterUpdate = function () {
      if (_this.opts.disabled && !_this.dashboardIsDisabled) {
        _this.disableAllFocusableElements(true);

        return;
      }

      if (!_this.opts.disabled && _this.dashboardIsDisabled) {
        _this.disableAllFocusableElements(false);
      }

      _this.superFocusOnEachUpdate();
    };

    _this.cancelUpload = function (fileID) {
      _this.uppy.removeFile(fileID);
    };

    _this.saveFileCard = function (meta, fileID) {
      _this.uppy.setFileMeta(fileID, meta);

      _this.toggleFileCard(false, fileID);
    };

    _this._attachRenderFunctionToTarget = function (target) {
      var plugin = _this.uppy.getPlugin(target.id);

      return _extends({}, target, {
        icon: plugin.icon || _this.opts.defaultPickerIcon,
        render: plugin.render
      });
    };

    _this._isTargetSupported = function (target) {
      var plugin = _this.uppy.getPlugin(target.id); // If the plugin does not provide a `supported` check, assume the plugin works everywhere.


      if (typeof plugin.isSupported !== 'function') {
        return true;
      }

      return plugin.isSupported();
    };

    _this._getAcquirers = memoize(function (targets) {
      return targets.filter(function (target) {
        return target.type === 'acquirer' && _this._isTargetSupported(target);
      }).map(_this._attachRenderFunctionToTarget);
    });
    _this._getProgressIndicators = memoize(function (targets) {
      return targets.filter(function (target) {
        return target.type === 'progressindicator';
      }).map(_this._attachRenderFunctionToTarget);
    });
    _this._getEditors = memoize(function (targets) {
      return targets.filter(function (target) {
        return target.type === 'editor';
      }).map(_this._attachRenderFunctionToTarget);
    });

    _this.render = function (state) {
      var pluginState = _this.getPluginState();

      var files = state.files,
          capabilities = state.capabilities,
          allowNewUpload = state.allowNewUpload; // TODO: move this to Core, to share between Status Bar and Dashboard
      // (and any other plugin that might need it, too)

      var newFiles = Object.keys(files).filter(function (file) {
        return !files[file].progress.uploadStarted;
      });
      var uploadStartedFiles = Object.keys(files).filter(function (file) {
        return files[file].progress.uploadStarted;
      });
      var pausedFiles = Object.keys(files).filter(function (file) {
        return files[file].isPaused;
      });
      var completeFiles = Object.keys(files).filter(function (file) {
        return files[file].progress.uploadComplete;
      });
      var erroredFiles = Object.keys(files).filter(function (file) {
        return files[file].error;
      });
      var inProgressFiles = Object.keys(files).filter(function (file) {
        return !files[file].progress.uploadComplete && files[file].progress.uploadStarted;
      });
      var inProgressNotPausedFiles = inProgressFiles.filter(function (file) {
        return !files[file].isPaused;
      });
      var processingFiles = Object.keys(files).filter(function (file) {
        return files[file].progress.preprocess || files[file].progress.postprocess;
      });
      var isUploadStarted = uploadStartedFiles.length > 0;
      var isAllComplete = state.totalProgress === 100 && completeFiles.length === Object.keys(files).length && processingFiles.length === 0;
      var isAllErrored = isUploadStarted && erroredFiles.length === uploadStartedFiles.length;
      var isAllPaused = inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length;

      var acquirers = _this._getAcquirers(pluginState.targets);

      var progressindicators = _this._getProgressIndicators(pluginState.targets);

      var editors = _this._getEditors(pluginState.targets);

      var theme;

      if (_this.opts.theme === 'auto') {
        theme = capabilities.darkMode ? 'dark' : 'light';
      } else {
        theme = _this.opts.theme;
      }

      if (['files', 'folders', 'both'].indexOf(_this.opts.fileManagerSelectionType) < 0) {
        _this.opts.fileManagerSelectionType = 'files';
        console.error("Unsupported option for \"fileManagerSelectionType\". Using default of \"" + _this.opts.fileManagerSelectionType + "\".");
      }

      return DashboardUI({
        state: state,
        isHidden: pluginState.isHidden,
        files: files,
        newFiles: newFiles,
        uploadStartedFiles: uploadStartedFiles,
        completeFiles: completeFiles,
        erroredFiles: erroredFiles,
        inProgressFiles: inProgressFiles,
        inProgressNotPausedFiles: inProgressNotPausedFiles,
        processingFiles: processingFiles,
        isUploadStarted: isUploadStarted,
        isAllComplete: isAllComplete,
        isAllErrored: isAllErrored,
        isAllPaused: isAllPaused,
        totalFileCount: Object.keys(files).length,
        totalProgress: state.totalProgress,
        allowNewUpload: allowNewUpload,
        acquirers: acquirers,
        theme: theme,
        disabled: _this.opts.disabled,
        disableLocalFiles: _this.opts.disableLocalFiles,
        direction: _this.opts.direction,
        activePickerPanel: pluginState.activePickerPanel,
        showFileEditor: pluginState.showFileEditor,
        saveFileEditor: _this.saveFileEditor,
        disableAllFocusableElements: _this.disableAllFocusableElements,
        animateOpenClose: _this.opts.animateOpenClose,
        isClosing: pluginState.isClosing,
        getPlugin: _this.uppy.getPlugin,
        progressindicators: progressindicators,
        editors: editors,
        autoProceed: _this.uppy.opts.autoProceed,
        id: _this.id,
        closeModal: _this.requestCloseModal,
        handleClickOutside: _this.handleClickOutside,
        handleInputChange: _this.handleInputChange,
        handlePaste: _this.handlePaste,
        inline: _this.opts.inline,
        showPanel: _this.showPanel,
        hideAllPanels: _this.hideAllPanels,
        log: _this.uppy.log,
        i18n: _this.i18n,
        i18nArray: _this.i18nArray,
        removeFile: _this.uppy.removeFile,
        uppy: _this.uppy,
        info: _this.uppy.info,
        note: _this.opts.note,
        recoveredState: state.recoveredState,
        metaFields: pluginState.metaFields,
        resumableUploads: capabilities.resumableUploads || false,
        individualCancellation: capabilities.individualCancellation,
        isMobileDevice: capabilities.isMobileDevice,
        pauseUpload: _this.uppy.pauseResume,
        retryUpload: _this.uppy.retryUpload,
        cancelUpload: _this.cancelUpload,
        cancelAll: _this.uppy.cancelAll,
        fileCardFor: pluginState.fileCardFor,
        toggleFileCard: _this.toggleFileCard,
        toggleAddFilesPanel: _this.toggleAddFilesPanel,
        showAddFilesPanel: pluginState.showAddFilesPanel,
        saveFileCard: _this.saveFileCard,
        openFileEditor: _this.openFileEditor,
        canEditFile: _this.canEditFile,
        width: _this.opts.width,
        height: _this.opts.height,
        showLinkToFileUploadResult: _this.opts.showLinkToFileUploadResult,
        fileManagerSelectionType: _this.opts.fileManagerSelectionType,
        proudlyDisplayPoweredByUppy: _this.opts.proudlyDisplayPoweredByUppy,
        hideCancelButton: _this.opts.hideCancelButton,
        hideRetryButton: _this.opts.hideRetryButton,
        hidePauseResumeButton: _this.opts.hidePauseResumeButton,
        showRemoveButtonAfterComplete: _this.opts.showRemoveButtonAfterComplete,
        containerWidth: pluginState.containerWidth,
        containerHeight: pluginState.containerHeight,
        areInsidesReadyToBeVisible: pluginState.areInsidesReadyToBeVisible,
        isTargetDOMEl: _this.isTargetDOMEl,
        parentElement: _this.el,
        allowedFileTypes: _this.uppy.opts.restrictions.allowedFileTypes,
        maxNumberOfFiles: _this.uppy.opts.restrictions.maxNumberOfFiles,
        showSelectedFiles: _this.opts.showSelectedFiles,
        handleCancelRestore: _this.handleCancelRestore,
        handleRequestThumbnail: _this.handleRequestThumbnail,
        handleCancelThumbnail: _this.handleCancelThumbnail,
        // drag props
        isDraggingOver: pluginState.isDraggingOver,
        handleDragOver: _this.handleDragOver,
        handleDragLeave: _this.handleDragLeave,
        handleDrop: _this.handleDrop
      });
    };

    _this.discoverProviderPlugins = function () {
      _this.uppy.iteratePlugins(function (plugin) {
        if (plugin && !plugin.target && plugin.opts && plugin.opts.target === _this.constructor) {
          _this.addTarget(plugin);
        }
      });
    };

    _this.install = function () {
      // Set default state for Dashboard
      _this.setPluginState({
        isHidden: true,
        fileCardFor: null,
        activeOverlayType: null,
        showAddFilesPanel: false,
        activePickerPanel: false,
        showFileEditor: false,
        metaFields: _this.opts.metaFields,
        targets: [],
        // We'll make them visible once .containerWidth is determined
        areInsidesReadyToBeVisible: false,
        isDraggingOver: false
      });

      var _this$opts = _this.opts,
          inline = _this$opts.inline,
          closeAfterFinish = _this$opts.closeAfterFinish;

      if (inline && closeAfterFinish) {
        throw new Error('[Dashboard] `closeAfterFinish: true` cannot be used on an inline Dashboard, because an inline Dashboard cannot be closed at all. Either set `inline: false`, or disable the `closeAfterFinish` option.');
      }

      var allowMultipleUploads = _this.uppy.opts.allowMultipleUploads;

      if (allowMultipleUploads && closeAfterFinish) {
        _this.uppy.log('[Dashboard] When using `closeAfterFinish`, we recommended setting the `allowMultipleUploads` option to `false` in the Uppy constructor. See https://uppy.io/docs/uppy/#allowMultipleUploads-true', 'warning');
      }

      var target = _this.opts.target;

      if (target) {
        _this.mount(target, _assertThisInitialized(_this));
      }

      var plugins = _this.opts.plugins || [];
      plugins.forEach(function (pluginID) {
        var plugin = _this.uppy.getPlugin(pluginID);

        if (plugin) {
          plugin.mount(_assertThisInitialized(_this), plugin);
        }
      });

      if (!_this.opts.disableStatusBar) {
        _this.uppy.use(StatusBar, {
          id: _this.id + ":StatusBar",
          target: _assertThisInitialized(_this),
          hideUploadButton: _this.opts.hideUploadButton,
          hideRetryButton: _this.opts.hideRetryButton,
          hidePauseResumeButton: _this.opts.hidePauseResumeButton,
          hideCancelButton: _this.opts.hideCancelButton,
          showProgressDetails: _this.opts.showProgressDetails,
          hideAfterFinish: _this.opts.hideProgressAfterFinish,
          locale: _this.opts.locale,
          doneButtonHandler: _this.opts.doneButtonHandler
        });
      }

      if (!_this.opts.disableInformer) {
        _this.uppy.use(Informer, {
          id: _this.id + ":Informer",
          target: _assertThisInitialized(_this)
        });
      }

      if (!_this.opts.disableThumbnailGenerator) {
        _this.uppy.use(ThumbnailGenerator, {
          id: _this.id + ":ThumbnailGenerator",
          thumbnailWidth: _this.opts.thumbnailWidth,
          thumbnailType: _this.opts.thumbnailType,
          waitForThumbnailsBeforeUpload: _this.opts.waitForThumbnailsBeforeUpload,
          // If we don't block on thumbnails, we can lazily generate them
          lazy: !_this.opts.waitForThumbnailsBeforeUpload
        });
      } // Dark Mode / theme


      _this.darkModeMediaQuery = typeof window !== 'undefined' && window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
      var isDarkModeOnFromTheStart = _this.darkModeMediaQuery ? _this.darkModeMediaQuery.matches : false;

      _this.uppy.log("[Dashboard] Dark mode is " + (isDarkModeOnFromTheStart ? 'on' : 'off'));

      _this.setDarkModeCapability(isDarkModeOnFromTheStart);

      if (_this.opts.theme === 'auto') {
        _this.darkModeMediaQuery.addListener(_this.handleSystemDarkModeChange);
      }

      _this.discoverProviderPlugins();

      _this.initEvents();
    };

    _this.uninstall = function () {
      if (!_this.opts.disableInformer) {
        var informer = _this.uppy.getPlugin(_this.id + ":Informer"); // Checking if this plugin exists, in case it was removed by uppy-core
        // before the Dashboard was.


        if (informer) _this.uppy.removePlugin(informer);
      }

      if (!_this.opts.disableStatusBar) {
        var statusBar = _this.uppy.getPlugin(_this.id + ":StatusBar");

        if (statusBar) _this.uppy.removePlugin(statusBar);
      }

      if (!_this.opts.disableThumbnailGenerator) {
        var thumbnail = _this.uppy.getPlugin(_this.id + ":ThumbnailGenerator");

        if (thumbnail) _this.uppy.removePlugin(thumbnail);
      }

      var plugins = _this.opts.plugins || [];
      plugins.forEach(function (pluginID) {
        var plugin = _this.uppy.getPlugin(pluginID);

        if (plugin) plugin.unmount();
      });

      if (_this.opts.theme === 'auto') {
        _this.darkModeMediaQuery.removeListener(_this.handleSystemDarkModeChange);
      }

      _this.unmount();

      _this.removeEvents();
    };

    _this.id = _this.opts.id || 'Dashboard';
    _this.title = 'Dashboard';
    _this.type = 'orchestrator';
    _this.modalName = "uppy-Dashboard-" + cuid();
    _this.defaultLocale = {
      strings: {
        closeModal: 'Close Modal',
        importFrom: 'Import from %{name}',
        addingMoreFiles: 'Adding more files',
        addMoreFiles: 'Add more files',
        dashboardWindowTitle: 'File Uploader Window (Press escape to close)',
        dashboardTitle: 'File Uploader',
        copyLinkToClipboardSuccess: 'Link copied to clipboard',
        copyLinkToClipboardFallback: 'Copy the URL below',
        copyLink: 'Copy link',
        fileSource: 'File source: %{name}',
        back: 'Back',
        addMore: 'Add more',
        removeFile: 'Remove file',
        editFile: 'Edit file',
        editing: 'Editing %{file}',
        finishEditingFile: 'Finish editing file',
        save: 'Save',
        saveChanges: 'Save changes',
        cancel: 'Cancel',
        myDevice: 'My Device',
        dropPasteFiles: 'Drop files here or %{browseFiles}',
        dropPasteFolders: 'Drop files here or %{browseFolders}',
        dropPasteBoth: 'Drop files here, %{browseFiles} or %{browseFolders}',
        dropPasteImportFiles: 'Drop files here, %{browseFiles} or import from:',
        dropPasteImportFolders: 'Drop files here, %{browseFolders} or import from:',
        dropPasteImportBoth: 'Drop files here, %{browseFiles}, %{browseFolders} or import from:',
        importFiles: 'Import files from:',
        dropHint: 'Drop your files here',
        browseFiles: 'browse files',
        browseFolders: 'browse folders',
        uploadComplete: 'Upload complete',
        uploadPaused: 'Upload paused',
        resumeUpload: 'Resume upload',
        pauseUpload: 'Pause upload',
        retryUpload: 'Retry upload',
        cancelUpload: 'Cancel upload',
        xFilesSelected: {
          0: '%{smart_count} file selected',
          1: '%{smart_count} files selected'
        },
        uploadingXFiles: {
          0: 'Uploading %{smart_count} file',
          1: 'Uploading %{smart_count} files'
        },
        processingXFiles: {
          0: 'Processing %{smart_count} file',
          1: 'Processing %{smart_count} files'
        },
        recoveredXFiles: {
          0: 'We could not fully recover 1 file. Please re-select it and resume the upload.',
          1: 'We could not fully recover %{smart_count} files. Please re-select them and resume the upload.'
        },
        recoveredAllFiles: 'We restored all files. You can now resume the upload.',
        sessionRestored: 'Session restored',
        reSelect: 'Re-select',
        // The default `poweredBy2` string only combines the `poweredBy` string (%{backwardsCompat}) with the size.
        // Locales can override `poweredBy2` to specify a different word order. This is for backwards compat with
        // Uppy 1.9.x and below which did a naive concatenation of `poweredBy2 + size` instead of using a locale-specific
        // substitution.
        // TODO: In 2.0 `poweredBy2` should be removed in and `poweredBy` updated to use substitution.
        poweredBy2: '%{backwardsCompat} %{uppy}',
        poweredBy: 'Powered by'
      }
    }; // set default options

    var defaultOptions = {
      target: 'body',
      metaFields: [],
      trigger: '#uppy-select-files',
      inline: false,
      width: 750,
      height: 550,
      thumbnailWidth: 280,
      thumbnailType: 'image/jpeg',
      waitForThumbnailsBeforeUpload: false,
      defaultPickerIcon: defaultPickerIcon,
      showLinkToFileUploadResult: true,
      showProgressDetails: false,
      hideUploadButton: false,
      hideCancelButton: false,
      hideRetryButton: false,
      hidePauseResumeButton: false,
      hideProgressAfterFinish: false,
      doneButtonHandler: function doneButtonHandler() {
        _this.uppy.reset();

        _this.requestCloseModal();
      },
      note: null,
      closeModalOnClickOutside: false,
      closeAfterFinish: false,
      disableStatusBar: false,
      disableInformer: false,
      disableThumbnailGenerator: false,
      disablePageScrollWhenModalOpen: true,
      animateOpenClose: true,
      fileManagerSelectionType: 'files',
      proudlyDisplayPoweredByUppy: true,
      onRequestCloseModal: function onRequestCloseModal() {
        return _this.closeModal();
      },
      showSelectedFiles: true,
      showRemoveButtonAfterComplete: false,
      browserBackButtonClose: false,
      theme: 'light',
      autoOpenFileEditor: false,
      disabled: false,
      disableLocalFiles: false
    }; // merge default options with the ones set by user

    _this.opts = _extends({}, defaultOptions, _opts);

    _this.i18nInit();

    _this.superFocus = createSuperFocus();
    _this.ifFocusedOnUppyRecently = false; // Timeouts

    _this.makeDashboardInsidesVisibleAnywayTimeout = null;
    _this.removeDragOverClassTimeout = null;
    return _this;
  }

  var _proto = Dashboard.prototype;

  _proto.onMount = function onMount() {
    // Set the text direction if the page has not defined one.
    var element = this.el;
    var direction = getTextDirection(element);

    if (!direction) {
      element.dir = 'ltr';
    }
  };

  return Dashboard;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":77,"./../../core":73,"./../../informer":115,"./../../status-bar":163,"./../../thumbnail-generator":167,"./../../utils/lib/FOCUSABLE_ELEMENTS":209,"./../../utils/lib/Translator":212,"./../../utils/lib/findAllDOMElements":217,"./../../utils/lib/getDroppedFiles":222,"./../../utils/lib/getTextDirection":232,"./../../utils/lib/toArray":245,"./components/Dashboard":80,"./utils/createSuperFocus":96,"./utils/trapFocus":100,"cuid":13,"memoize-one":34,"preact":76,"resize-observer-polyfill":42}],95:[function(require,module,exports){
/**
 * Copies text to clipboard by creating an almost invisible textarea,
 * adding text there, then running execCommand('copy').
 * Falls back to prompt() when the easy way fails (hello, Safari!)
 * From http://stackoverflow.com/a/30810322
 *
 * @param {string} textToCopy
 * @param {string} fallbackString
 * @returns {Promise}
 */
module.exports = function copyToClipboard(textToCopy, fallbackString) {
  fallbackString = fallbackString || 'Copy the URL below';
  return new Promise(function (resolve) {
    var textArea = document.createElement('textarea');
    textArea.setAttribute('style', {
      position: 'fixed',
      top: 0,
      left: 0,
      width: '2em',
      height: '2em',
      padding: 0,
      border: 'none',
      outline: 'none',
      boxShadow: 'none',
      background: 'transparent'
    });
    textArea.value = textToCopy;
    document.body.appendChild(textArea);
    textArea.select();

    var magicCopyFailed = function magicCopyFailed() {
      document.body.removeChild(textArea);
      window.prompt(fallbackString, textToCopy);
      resolve();
    };

    try {
      var successful = document.execCommand('copy');

      if (!successful) {
        return magicCopyFailed('copy command unavailable');
      }

      document.body.removeChild(textArea);
      return resolve();
    } catch (err) {
      document.body.removeChild(textArea);
      return magicCopyFailed(err);
    }
  });
};

},{}],96:[function(require,module,exports){
var debounce = require('lodash.debounce');

var FOCUSABLE_ELEMENTS = require('./../../../utils/lib/FOCUSABLE_ELEMENTS');

var getActiveOverlayEl = require('./getActiveOverlayEl');
/*
  Focuses on some element in the currently topmost overlay.

  1. If there are some [data-uppy-super-focusable] elements rendered already - focuses on the first superfocusable element, and leaves focus up to the control of a user (until currently focused element disappears from the screen [which can happen when overlay changes, or, e.g., when we click on a folder in googledrive]).
  2. If there are no [data-uppy-super-focusable] elements yet (or ever) - focuses on the first focusable element, but switches focus if superfocusable elements appear on next render.
*/


module.exports = function createSuperFocus() {
  var lastFocusWasOnSuperFocusableEl = false;

  var superFocus = function superFocus(dashboardEl, activeOverlayType) {
    var overlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
    var isFocusInOverlay = overlayEl.contains(document.activeElement); // If focus is already in the topmost overlay, AND on last update we focused on the superfocusable element - then leave focus up to the user.
    // [Practical check] without this line, typing in the search input in googledrive overlay won't work.

    if (isFocusInOverlay && lastFocusWasOnSuperFocusableEl) return;
    var superFocusableEl = overlayEl.querySelector('[data-uppy-super-focusable]'); // If we are already in the topmost overlay, AND there are no super focusable elements yet, - leave focus up to the user.
    // [Practical check] without this line, if you are in an empty folder in google drive, and something's uploading in the bg, - focus will be jumping to Done all the time.

    if (isFocusInOverlay && !superFocusableEl) return;

    if (superFocusableEl) {
      superFocusableEl.focus({
        preventScroll: true
      });
      lastFocusWasOnSuperFocusableEl = true;
    } else {
      var firstEl = overlayEl.querySelector(FOCUSABLE_ELEMENTS);
      firstEl && firstEl.focus({
        preventScroll: true
      });
      lastFocusWasOnSuperFocusableEl = false;
    }
  }; // ___Why do we need to debounce?
  //    1. To deal with animations: overlay changes via animations, which results in the DOM updating AFTER plugin.update() already executed.
  //    [Practical check] without debounce, if we open the Url overlay, and click 'Done', Dashboard won't get focused again.
  //    [Practical check] if we delay 250ms instead of 260ms - IE11 won't get focused in same situation.
  //    2. Performance: there can be many state update()s in a second, and this function is called every time.


  return debounce(superFocus, 260);
};

},{"./../../../utils/lib/FOCUSABLE_ELEMENTS":209,"./getActiveOverlayEl":97,"lodash.debounce":31}],97:[function(require,module,exports){
/**
 * @returns {HTMLElement} - either dashboard element, or the overlay that's most on top
 */
module.exports = function getActiveOverlayEl(dashboardEl, activeOverlayType) {
  if (activeOverlayType) {
    var overlayEl = dashboardEl.querySelector("[data-uppy-paneltype=\"" + activeOverlayType + "\"]"); // if an overlay is already mounted

    if (overlayEl) return overlayEl;
  }

  return dashboardEl;
};

},{}],98:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function iconImage() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("g", {
    fill: "#686DE0",
    fillRule: "evenodd"
  }, h("path", {
    d: "M5 7v10h15V7H5zm0-1h15a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1z",
    fillRule: "nonzero"
  }), h("path", {
    d: "M6.35 17.172l4.994-5.026a.5.5 0 0 1 .707 0l2.16 2.16 3.505-3.505a.5.5 0 0 1 .707 0l2.336 2.31-.707.72-1.983-1.97-3.505 3.505a.5.5 0 0 1-.707 0l-2.16-2.159-3.938 3.939-1.409.026z",
    fillRule: "nonzero"
  }), h("circle", {
    cx: "7.5",
    cy: "9.5",
    r: "1.5"
  })));
}

function iconAudio() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M9.5 18.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V7.25a.5.5 0 0 1 .379-.485l9-2.25A.5.5 0 0 1 18.5 5v11.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V8.67l-8 2v7.97zm8-11v-2l-8 2v2l8-2zM7 19.64c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1zm9-2c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1z",
    fill: "#049BCF",
    fillRule: "nonzero"
  }));
}

function iconVideo() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M16 11.834l4.486-2.691A1 1 0 0 1 22 10v6a1 1 0 0 1-1.514.857L16 14.167V17a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2.834zM15 9H5v8h10V9zm1 4l5 3v-6l-5 3z",
    fill: "#19AF67",
    fillRule: "nonzero"
  }));
}

function iconPDF() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M9.766 8.295c-.691-1.843-.539-3.401.747-3.726 1.643-.414 2.505.938 2.39 3.299-.039.79-.194 1.662-.537 3.148.324.49.66.967 1.055 1.51.17.231.382.488.629.757 1.866-.128 3.653.114 4.918.655 1.487.635 2.192 1.685 1.614 2.84-.566 1.133-1.839 1.084-3.416.249-1.141-.604-2.457-1.634-3.51-2.707a13.467 13.467 0 0 0-2.238.426c-1.392 4.051-4.534 6.453-5.707 4.572-.986-1.58 1.38-4.206 4.914-5.375.097-.322.185-.656.264-1.001.08-.353.306-1.31.407-1.737-.678-1.059-1.2-2.031-1.53-2.91zm2.098 4.87c-.033.144-.068.287-.104.427l.033-.01-.012.038a14.065 14.065 0 0 1 1.02-.197l-.032-.033.052-.004a7.902 7.902 0 0 1-.208-.271c-.197-.27-.38-.526-.555-.775l-.006.028-.002-.003c-.076.323-.148.632-.186.8zm5.77 2.978c1.143.605 1.832.632 2.054.187.26-.519-.087-1.034-1.113-1.473-.911-.39-2.175-.608-3.55-.608.845.766 1.787 1.459 2.609 1.894zM6.559 18.789c.14.223.693.16 1.425-.413.827-.648 1.61-1.747 2.208-3.206-2.563 1.064-4.102 2.867-3.633 3.62zm5.345-10.97c.088-1.793-.351-2.48-1.146-2.28-.473.119-.564 1.05-.056 2.405.213.566.52 1.188.908 1.859.18-.858.268-1.453.294-1.984z",
    fill: "#E2514A",
    fillRule: "nonzero"
  }));
}

function iconArchive() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M10.45 2.05h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V2.55a.5.5 0 0 1 .5-.5zm2.05 1.024h1.05a.5.5 0 0 1 .5.5V3.6a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5v-.001zM10.45 0h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 3.074h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 1.024h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm-2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-1.656 3.074l-.82 5.946c.52.302 1.174.458 1.976.458.803 0 1.455-.156 1.975-.458l-.82-5.946h-2.311zm0-1.025h2.312c.512 0 .946.378 1.015.885l.82 5.946c.056.412-.142.817-.501 1.026-.686.398-1.515.597-2.49.597-.974 0-1.804-.199-2.49-.597a1.025 1.025 0 0 1-.5-1.026l.819-5.946c.07-.507.503-.885 1.015-.885zm.545 6.6a.5.5 0 0 1-.397-.561l.143-.999a.5.5 0 0 1 .495-.429h.74a.5.5 0 0 1 .495.43l.143.998a.5.5 0 0 1-.397.561c-.404.08-.819.08-1.222 0z",
    fill: "#00C469",
    fillRule: "nonzero"
  }));
}

function iconFile() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("g", {
    fill: "#A7AFB7",
    fillRule: "nonzero"
  }, h("path", {
    d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z"
  }), h("path", {
    d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z"
  })));
}

function iconText() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M4.5 7h13a.5.5 0 1 1 0 1h-13a.5.5 0 0 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h10a.5.5 0 1 1 0 1h-10a.5.5 0 1 1 0-1z",
    fill: "#5A5E69",
    fillRule: "nonzero"
  }));
}

module.exports = function getIconByMime(fileType) {
  var defaultChoice = {
    color: '#838999',
    icon: iconFile()
  };
  if (!fileType) return defaultChoice;
  var fileTypeGeneral = fileType.split('/')[0];
  var fileTypeSpecific = fileType.split('/')[1]; // Text

  if (fileTypeGeneral === 'text') {
    return {
      color: '#5a5e69',
      icon: iconText()
    };
  } // Image


  if (fileTypeGeneral === 'image') {
    return {
      color: '#686de0',
      icon: iconImage()
    };
  } // Audio


  if (fileTypeGeneral === 'audio') {
    return {
      color: '#068dbb',
      icon: iconAudio()
    };
  } // Video


  if (fileTypeGeneral === 'video') {
    return {
      color: '#19af67',
      icon: iconVideo()
    };
  } // PDF


  if (fileTypeGeneral === 'application' && fileTypeSpecific === 'pdf') {
    return {
      color: '#e25149',
      icon: iconPDF()
    };
  } // Archive


  var archiveTypes = ['zip', 'x-7z-compressed', 'x-rar-compressed', 'x-tar', 'x-gzip', 'x-apple-diskimage'];

  if (fileTypeGeneral === 'application' && archiveTypes.indexOf(fileTypeSpecific) !== -1) {
    return {
      color: '#00C469',
      icon: iconArchive()
    };
  }

  return defaultChoice;
};

},{"preact":76}],99:[function(require,module,exports){
// ignore drop/paste events if they are not in input or textarea 
// otherwise when Url plugin adds drop/paste listeners to this.el,
// draging UI elements or pasting anything into any field triggers those events 
// Url treats them as URLs that need to be imported
function ignoreEvent(ev) {
  var tagName = ev.target.tagName;

  if (tagName === 'INPUT' || tagName === 'TEXTAREA') {
    ev.stopPropagation();
    return;
  }

  ev.preventDefault();
  ev.stopPropagation();
}

module.exports = ignoreEvent;

},{}],100:[function(require,module,exports){
var toArray = require('./../../../utils/lib/toArray');

var getActiveOverlayEl = require('./getActiveOverlayEl');

var FOCUSABLE_ELEMENTS = require('./../../../utils/lib/FOCUSABLE_ELEMENTS');

function focusOnFirstNode(event, nodes) {
  var node = nodes[0];

  if (node) {
    node.focus();
    event.preventDefault();
  }
}

function focusOnLastNode(event, nodes) {
  var node = nodes[nodes.length - 1];

  if (node) {
    node.focus();
    event.preventDefault();
  }
} // ___Why not just use (focusedItemIndex === -1)?
//    Firefox thinks <ul> is focusable, but we don't have <ul>s in our FOCUSABLE_ELEMENTS. Which means that if we tab into the <ul>, code will think that we are not in the active overlay, and we should focusOnFirstNode() of the currently active overlay!
//    [Practical check] if we use (focusedItemIndex === -1), instagram provider in firefox will never get focus on its pics in the <ul>.


function isFocusInOverlay(activeOverlayEl) {
  return activeOverlayEl.contains(document.activeElement);
}

function trapFocus(event, activeOverlayType, dashboardEl) {
  var activeOverlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
  var focusableNodes = toArray(activeOverlayEl.querySelectorAll(FOCUSABLE_ELEMENTS));
  var focusedItemIndex = focusableNodes.indexOf(document.activeElement); // If we pressed tab, and focus is not yet within the current overlay - focus on the first element within the current overlay.
  // This is a safety measure (for when user returns from another tab e.g.), most plugins will try to focus on some important element as it loads.

  if (!isFocusInOverlay(activeOverlayEl)) {
    focusOnFirstNode(event, focusableNodes); // If we pressed shift + tab, and we're on the first element of a modal
  } else if (event.shiftKey && focusedItemIndex === 0) {
    focusOnLastNode(event, focusableNodes); // If we pressed tab, and we're on the last element of the modal
  } else if (!event.shiftKey && focusedItemIndex === focusableNodes.length - 1) {
    focusOnFirstNode(event, focusableNodes);
  }
}

module.exports = {
  // Traps focus inside of the currently open overlay (e.g. Dashboard, or e.g. Instagram), never lets focus disappear from the modal.
  forModal: function forModal(event, activeOverlayType, dashboardEl) {
    trapFocus(event, activeOverlayType, dashboardEl);
  },
  // Traps focus inside of the currently open overlay, unless overlay is null - then let the user tab away.
  forInline: function forInline(event, activeOverlayType, dashboardEl) {
    // ___When we're in the bare 'Drop files here, paste, browse or import from' screen
    if (activeOverlayType === null) {// Do nothing and let the browser handle it, user can tab away from Uppy to other elements on the page
      // ___When there is some overlay with 'Done' button
    } else {
      // Trap the focus inside this overlay!
      // User can close the overlay (click 'Done') if they want to travel away from Uppy.
      trapFocus(event, activeOverlayType, dashboardEl);
    }
  }
};

},{"./../../../utils/lib/FOCUSABLE_ELEMENTS":209,"./../../../utils/lib/toArray":245,"./getActiveOverlayEl":97}],101:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],102:[function(require,module,exports){
module.exports={
  "name": "@uppy/dropbox",
  "description": "Import files from Dropbox, into Uppy.",
  "version": "1.5.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "dropbox"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],103:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var _require3 = require('./../../provider-views'),
    ProviderViews = _require3.ProviderViews;

var _require4 = require('preact'),
    h = _require4.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Dropbox, _Plugin);

  function Dropbox(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Dropbox';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Dropbox';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        fill: "#0D2481",
        width: "32",
        height: "32",
        rx: "16"
      }), h("path", {
        d: "M11 8l5 3.185-5 3.186-5-3.186L11 8zm10 0l5 3.185-5 3.186-5-3.186L21 8zM6 17.556l5-3.185 5 3.185-5 3.186-5-3.186zm15-3.185l5 3.185-5 3.186-5-3.186 5-3.185zm-10 7.432l5-3.185 5 3.185-5 3.186-5-3.186z",
        fill: "#FFF",
        fillRule: "nonzero"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionKeysParams: _this.opts.companionKeysParams,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'dropbox',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Dropbox.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return Dropbox;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":102,"./../../companion-client":68,"./../../core":73,"./../../provider-views":145,"preact":101}],104:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],105:[function(require,module,exports){
module.exports={
  "name": "@uppy/facebook",
  "description": "Import files from Facebook, into Uppy.",
  "version": "1.2.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "facebook"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],106:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var _require3 = require('./../../provider-views'),
    ProviderViews = _require3.ProviderViews;

var _require4 = require('preact'),
    h = _require4.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Facebook, _Plugin);

  function Facebook(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Facebook';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Facebook';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        width: "32",
        height: "32",
        rx: "16",
        fill: "#3C5A99"
      }), h("path", {
        d: "M17.842 26v-8.667h2.653l.398-3.377h-3.051v-2.157c0-.978.248-1.644 1.527-1.644H21V7.132A19.914 19.914 0 0 0 18.623 7c-2.352 0-3.963 1.574-3.963 4.465v2.49H12v3.378h2.66V26h3.182z",
        fill: "#FFF",
        fillRule: "nonzero"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionKeysParams: _this.opts.companionKeysParams,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'facebook',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Facebook.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  };

  _proto.render = function render(state) {
    var viewOptions = {};

    if (this.getPluginState().files.length && !this.getPluginState().folders.length) {
      viewOptions.viewType = 'grid';
      viewOptions.showFilter = false;
      viewOptions.showTitles = false;
    }

    return this.view.render(state, viewOptions);
  };

  return Facebook;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":105,"./../../companion-client":68,"./../../core":73,"./../../provider-views":145,"preact":104}],107:[function(require,module,exports){
module.exports={
  "name": "@uppy/form",
  "description": "Connect Uppy to an existing HTML <form>.",
  "version": "1.3.31",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "form"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "get-form-data": "^2.0.0"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],108:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var findDOMElement = require('./../../utils/lib/findDOMElement');

var toArray = require('./../../utils/lib/toArray'); // Rollup uses get-form-data's ES modules build, and rollup-plugin-commonjs automatically resolves `.default`.
// So, if we are being built using rollup, this require() won't have a `.default` property.


var getFormData = require('get-form-data').default || require('get-form-data');
/**
 * Form
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Form, _Plugin);

  function Form(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.type = 'acquirer';
    _this.id = _this.opts.id || 'Form';
    _this.title = 'Form'; // set default options

    var defaultOptions = {
      target: null,
      resultName: 'uppyResult',
      getMetaFromForm: true,
      addResultToForm: true,
      multipleResults: false,
      submitOnSuccess: false,
      triggerUploadOnSubmit: false
    }; // merge default options with the ones set by user

    _this.opts = _extends({}, defaultOptions, opts);
    _this.handleFormSubmit = _this.handleFormSubmit.bind(_assertThisInitialized(_this));
    _this.handleUploadStart = _this.handleUploadStart.bind(_assertThisInitialized(_this));
    _this.handleSuccess = _this.handleSuccess.bind(_assertThisInitialized(_this));
    _this.addResultToForm = _this.addResultToForm.bind(_assertThisInitialized(_this));
    _this.getMetaFromForm = _this.getMetaFromForm.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Form.prototype;

  _proto.handleUploadStart = function handleUploadStart() {
    if (this.opts.getMetaFromForm) {
      this.getMetaFromForm();
    }
  };

  _proto.handleSuccess = function handleSuccess(result) {
    if (this.opts.addResultToForm) {
      this.addResultToForm(result);
    }

    if (this.opts.submitOnSuccess) {
      this.form.submit();
    }
  };

  _proto.handleFormSubmit = function handleFormSubmit(ev) {
    var _this2 = this;

    if (this.opts.triggerUploadOnSubmit) {
      ev.preventDefault();
      var elements = toArray(ev.target.elements);
      var disabledByUppy = [];
      elements.forEach(function (el) {
        var isButton = el.tagName === 'BUTTON' || el.tagName === 'INPUT' && el.type === 'submit';

        if (isButton && !el.disabled) {
          el.disabled = true;
          disabledByUppy.push(el);
        }
      });
      this.uppy.upload().then(function () {
        disabledByUppy.forEach(function (button) {
          button.disabled = false;
        });
      }, function (err) {
        disabledByUppy.forEach(function (button) {
          button.disabled = false;
        });
        return Promise.reject(err);
      }).catch(function (err) {
        _this2.uppy.log(err.stack || err.message || err);
      });
    }
  };

  _proto.addResultToForm = function addResultToForm(result) {
    this.uppy.log('[Form] Adding result to the original form:');
    this.uppy.log(result);
    var resultInput = this.form.querySelector("[name=\"" + this.opts.resultName + "\"]");

    if (resultInput) {
      if (this.opts.multipleResults) {
        // Append new result to the previous result array.
        // If the previous result is empty, or not an array,
        // set it to an empty array.
        var updatedResult;

        try {
          updatedResult = JSON.parse(resultInput.value);
        } catch (err) {// Nothing, since we check for array below anyway
        }

        if (!Array.isArray(updatedResult)) {
          updatedResult = [];
        }

        updatedResult.push(result);
        resultInput.value = JSON.stringify(updatedResult);
      } else {
        // Replace existing result with the newer result on `complete` event.
        // This behavior is not ideal, since you most likely want to always keep
        // all results in the input. This is kept for backwards compatability until 2.0.
        resultInput.value = JSON.stringify(result);
      }

      return;
    }

    resultInput = document.createElement('input');
    resultInput.name = this.opts.resultName;
    resultInput.type = 'hidden';

    if (this.opts.multipleResults) {
      // Wrap result in an array so we can have multiple results
      resultInput.value = JSON.stringify([result]);
    } else {
      // Result is an object, kept for backwards compatability until 2.0
      resultInput.value = JSON.stringify(result);
    }

    this.form.appendChild(resultInput);
  };

  _proto.getMetaFromForm = function getMetaFromForm() {
    var formMeta = getFormData(this.form); // We want to exclude meta the the Form plugin itself has added
    // See https://github.com/transloadit/uppy/issues/1637

    delete formMeta[this.opts.resultName];
    this.uppy.setMeta(formMeta);
  };

  _proto.install = function install() {
    this.form = findDOMElement(this.opts.target);

    if (!this.form || this.form.nodeName !== 'FORM') {
      this.uppy.log('Form plugin requires a <form> target element passed in options to operate, none was found', 'error');
      return;
    }

    this.form.addEventListener('submit', this.handleFormSubmit);
    this.uppy.on('upload', this.handleUploadStart);
    this.uppy.on('complete', this.handleSuccess);
  };

  _proto.uninstall = function uninstall() {
    this.form.removeEventListener('submit', this.handleFormSubmit);
    this.uppy.off('upload', this.handleUploadStart);
    this.uppy.off('complete', this.handleSuccess);
  };

  return Form;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":107,"./../../core":73,"./../../utils/lib/findDOMElement":218,"./../../utils/lib/toArray":245,"get-form-data":23}],109:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],110:[function(require,module,exports){
module.exports={
  "name": "@uppy/google-drive",
  "description": "The Google Drive plugin for Uppy lets users import files from their Google Drive account",
  "version": "1.7.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "google drive",
    "cloud storage",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],111:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../provider-views'),
    ProviderViews = _require.ProviderViews;

module.exports = /*#__PURE__*/function (_ProviderViews) {
  _inheritsLoose(DriveProviderViews, _ProviderViews);

  function DriveProviderViews() {
    return _ProviderViews.apply(this, arguments) || this;
  }

  var _proto = DriveProviderViews.prototype;

  _proto.toggleCheckbox = function toggleCheckbox(e, file) {
    e.stopPropagation();
    e.preventDefault(); // Shared Drives aren't selectable; for all else, defer to the base ProviderView.
    // @todo isTeamDrive is left for backward compatibility. We should remove it in the next
    // major release.

    if (!file.custom.isTeamDrive && !file.custom.isSharedDrive) {
      _ProviderViews.prototype.toggleCheckbox.call(this, e, file);
    }
  };

  return DriveProviderViews;
}(ProviderViews);

},{"./../../provider-views":145}],112:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var DriveProviderViews = require('./DriveProviderViews');

var _require3 = require('preact'),
    h = _require3.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(GoogleDrive, _Plugin);

  function GoogleDrive(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'GoogleDrive';
    _this.title = _this.opts.title || 'Google Drive';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Google Drive';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        fill: "#4285F4",
        width: "32",
        height: "32",
        rx: "16"
      }), h("path", {
        d: "M10.324 23.3l3-5.1H25l-3 5.1H10.324zM13 18.2l-3 5.1-3-5.1 5.839-9.924 2.999 5.1L13 18.2zm11.838-.276h-6L13 8h6l5.84 9.924h-.002z",
        fill: "#FFF"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionKeysParams: _this.opts.companionKeysParams,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'drive',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = GoogleDrive.prototype;

  _proto.install = function install() {
    this.view = new DriveProviderViews(this, {
      provider: this.provider
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder('root', '/')]);
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return GoogleDrive;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":110,"./../../companion-client":68,"./../../core":73,"./DriveProviderViews":111,"preact":109}],113:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],114:[function(require,module,exports){
module.exports={
  "name": "@uppy/informer",
  "description": "A notification and error pop-up bar for Uppy.",
  "version": "1.6.6",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "notification",
    "bar",
    "ui"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],115:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('preact'),
    h = _require2.h;
/**
 * Informer
 * Shows rad message bubbles
 * used like this: `uppy.info('hello world', 'info', 5000)`
 * or for errors: `uppy.info('Error uploading img.jpg', 'error', 5000)`
 *
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Informer, _Plugin);

  function Informer(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.render = function (state) {
      var _state$info = state.info,
          isHidden = _state$info.isHidden,
          message = _state$info.message,
          details = _state$info.details;

      function displayErrorAlert() {
        var errorMessage = message + " \n\n " + details;
        alert(errorMessage);
      }

      var handleMouseOver = function handleMouseOver() {
        clearTimeout(_this.uppy.infoTimeoutID);
      };

      var handleMouseLeave = function handleMouseLeave() {
        _this.uppy.infoTimeoutID = setTimeout(_this.uppy.hideInfo, 2000);
      };

      return h("div", {
        className: "uppy uppy-Informer",
        "aria-hidden": isHidden
      }, h("p", {
        role: "alert"
      }, message, ' ', details && h("span", {
        "aria-label": details,
        "data-microtip-position": "top-left",
        "data-microtip-size": "medium",
        role: "tooltip",
        onClick: displayErrorAlert,
        onMouseOver: handleMouseOver,
        onMouseLeave: handleMouseLeave
      }, "?")));
    };

    _this.type = 'progressindicator';
    _this.id = _this.opts.id || 'Informer';
    _this.title = 'Informer'; // set default options

    var defaultOptions = {}; // merge default options with the ones set by user

    _this.opts = _extends({}, defaultOptions, opts);
    return _this;
  }

  var _proto = Informer.prototype;

  _proto.install = function install() {
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  return Informer;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":114,"./../../core":73,"preact":113}],116:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],117:[function(require,module,exports){
module.exports={
  "name": "@uppy/instagram",
  "description": "Import photos and videos from Instagram, into Uppy.",
  "version": "1.5.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "instagram",
    "provider",
    "photos",
    "videos"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],118:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var _require3 = require('./../../provider-views'),
    ProviderViews = _require3.ProviderViews;

var _require4 = require('preact'),
    h = _require4.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Instagram, _Plugin);

  function Instagram(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Instagram';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Instagram';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        fill: "#E1306C",
        width: "32",
        height: "32",
        rx: "16"
      }), h("path", {
        d: "M16 8.622c2.403 0 2.688.009 3.637.052.877.04 1.354.187 1.67.31.392.144.745.374 1.036.673.299.29.529.644.673 1.035.123.317.27.794.31 1.671.043.95.052 1.234.052 3.637s-.009 2.688-.052 3.637c-.04.877-.187 1.354-.31 1.671a2.98 2.98 0 0 1-1.708 1.708c-.317.123-.794.27-1.671.31-.95.043-1.234.053-3.637.053s-2.688-.01-3.637-.053c-.877-.04-1.354-.187-1.671-.31a2.788 2.788 0 0 1-1.035-.673 2.788 2.788 0 0 1-.673-1.035c-.123-.317-.27-.794-.31-1.671-.043-.949-.052-1.234-.052-3.637s.009-2.688.052-3.637c.04-.877.187-1.354.31-1.67.144-.392.374-.745.673-1.036.29-.299.644-.529 1.035-.673.317-.123.794-.27 1.671-.31.95-.043 1.234-.052 3.637-.052zM16 7c-2.444 0-2.75.01-3.71.054-.959.044-1.613.196-2.185.419-.6.225-1.145.58-1.594 1.038-.458.45-.813.993-1.039 1.594-.222.572-.374 1.226-.418 2.184C7.01 13.25 7 13.556 7 16s.01 2.75.054 3.71c.044.959.196 1.613.419 2.185.226.6.58 1.145 1.038 1.594.45.458.993.813 1.594 1.038.572.223 1.227.375 2.184.419.96.044 1.267.054 3.711.054s2.75-.01 3.71-.054c.959-.044 1.613-.196 2.185-.419a4.602 4.602 0 0 0 2.632-2.632c.223-.572.375-1.226.419-2.184.044-.96.054-1.267.054-3.711s-.01-2.75-.054-3.71c-.044-.959-.196-1.613-.419-2.185A4.412 4.412 0 0 0 23.49 8.51a4.412 4.412 0 0 0-1.594-1.039c-.572-.222-1.226-.374-2.184-.418C18.75 7.01 18.444 7 16 7zm0 4.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9zm0 7.421a2.921 2.921 0 1 1 0-5.842 2.921 2.921 0 0 1 0 5.842zm4.875-6.671a1.125 1.125 0 1 1 0-2.25 1.125 1.125 0 0 1 0 2.25z",
        fill: "#FFF"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionKeysParams: _this.opts.companionKeysParams,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'instagram',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Instagram.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider,
      viewType: 'grid',
      showTitles: false,
      showFilter: false,
      showBreadcrumbs: false
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder('recent')]);
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return Instagram;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":117,"./../../companion-client":68,"./../../core":73,"./../../provider-views":145,"preact":116}],119:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],120:[function(require,module,exports){
module.exports={
  "name": "@uppy/onedrive",
  "description": "Import files from OneDrive, into Uppy.",
  "version": "1.2.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "onedrive"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],121:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var _require3 = require('./../../provider-views'),
    ProviderViews = _require3.ProviderViews;

var _require4 = require('preact'),
    h = _require4.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(OneDrive, _Plugin);

  function OneDrive(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'OneDrive';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'OneDrive';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        width: "32",
        height: "32",
        rx: "16",
        fill: "#0262C0"
      }), h("g", {
        fill: "#FFF",
        fillRule: "nonzero"
      }, h("path", {
        d: "M24.157 22s1.492-.205 1.79-1.655a2.624 2.624 0 0 0 .03-.878c-.22-1.64-1.988-2.01-1.988-2.01s.307-1.765-1.312-2.69c-1.62-.925-3.1 0-3.1 0S18.711 13 16.366 13c-3.016 0-3.519 3.448-3.519 3.448S10 16.618 10 19.14c0 2.523 2.597 2.86 2.597 2.86h11.56z"
      }), h("path", {
        d: "M9.421 19.246c0-2.197 1.606-3.159 2.871-3.472.44-1.477 1.654-3.439 4.135-3.439H16.445c1.721 0 2.79.823 3.368 1.476a3.99 3.99 0 0 1 1.147-.171h.01l.03.002C21.017 13.5 20.691 10 16.757 10c-2.69 0-3.639 2.345-3.639 2.345s-1.95-1.482-3.955.567c-1.028 1.052-.79 2.669-.79 2.669S6 15.824 6 18.412C6 20.757 8.452 21 8.452 21h1.372a3.77 3.77 0 0 1-.403-1.754z"
      }))));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'onedrive',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = OneDrive.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return OneDrive;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":120,"./../../companion-client":68,"./../../core":73,"./../../provider-views":145,"preact":119}],122:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],123:[function(require,module,exports){
module.exports={
  "name": "@uppy/provider-views",
  "description": "View library for Uppy remote provider plugins.",
  "version": "1.12.3",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "classnames": "^2.2.6",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],124:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h; // TODO use Fragment when upgrading to preact X


var Breadcrumb = function Breadcrumb(props) {
  return h("span", null, h("button", {
    type: "button",
    className: "uppy-u-reset",
    onClick: props.getFolder
  }, props.title), !props.isLast ? ' / ' : '');
};

module.exports = function (props) {
  return h("div", {
    className: "uppy-Provider-breadcrumbs"
  }, h("div", {
    className: "uppy-Provider-breadcrumbsIcon"
  }, props.breadcrumbsIcon), props.directories.map(function (directory, i) {
    return h(Breadcrumb, {
      key: directory.id,
      getFolder: function getFolder() {
        return props.getFolder(directory.id);
      },
      title: i === 0 ? props.title : directory.title,
      isLast: i + 1 === props.directories.length
    });
  }));
};

},{"preact":122}],125:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var classNames = require('classnames');

var Filter = require('./Filter');

var ItemList = require('./ItemList');

var FooterActions = require('./FooterActions');

var _require = require('preact'),
    h = _require.h;

var Browser = function Browser(props) {
  var currentSelection = props.currentSelection,
      folders = props.folders,
      files = props.files,
      uppyFiles = props.uppyFiles,
      filterItems = props.filterItems,
      filterInput = props.filterInput;
  var filteredFolders = folders;
  var filteredFiles = files;

  if (filterInput !== '') {
    filteredFolders = filterItems(folders);
    filteredFiles = filterItems(files);
  }

  var selected = currentSelection.length;
  return h("div", {
    className: classNames('uppy-ProviderBrowser', "uppy-ProviderBrowser-viewType--" + props.viewType)
  }, h("div", {
    className: "uppy-ProviderBrowser-header"
  }, h("div", {
    className: classNames('uppy-ProviderBrowser-headerBar', !props.showBreadcrumbs && 'uppy-ProviderBrowser-headerBar--simple')
  }, props.headerComponent)), props.showFilter && h(Filter, props), h(ItemList, {
    columns: [{
      name: 'Name',
      key: 'title'
    }],
    folders: filteredFolders,
    files: filteredFiles,
    sortByTitle: props.sortByTitle,
    sortByDate: props.sortByDate,
    isChecked: props.isChecked,
    handleFolderClick: props.getNextFolder,
    toggleCheckbox: props.toggleCheckbox,
    handleScroll: props.handleScroll,
    title: props.title,
    showTitles: props.showTitles,
    i18n: props.i18n,
    viewType: props.viewType,
    validateRestrictions: props.validateRestrictions,
    uppyFiles: uppyFiles,
    currentSelection: currentSelection
  }), selected > 0 && h(FooterActions, _extends({
    selected: selected
  }, props)));
};

module.exports = Browser;

},{"./Filter":127,"./FooterActions":128,"./ItemList":133,"classnames":10,"preact":122}],126:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    Component = _require.Component;

module.exports = /*#__PURE__*/function (_Component) {
  _inheritsLoose(CloseWrapper, _Component);

  function CloseWrapper() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = CloseWrapper.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.onUnmount();
  };

  _proto.render = function render() {
    return this.props.children[0];
  };

  return CloseWrapper;
}(Component);

},{"preact":122}],127:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

module.exports = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Filter, _Component);

  function Filter(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.preventEnterPress = _this.preventEnterPress.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Filter.prototype;

  _proto.preventEnterPress = function preventEnterPress(ev) {
    if (ev.keyCode === 13) {
      ev.stopPropagation();
      ev.preventDefault();
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    return h("div", {
      className: "uppy-ProviderBrowser-search"
    }, h("input", {
      className: "uppy-u-reset uppy-ProviderBrowser-searchInput",
      type: "text",
      placeholder: this.props.i18n('filter'),
      "aria-label": this.props.i18n('filter'),
      onKeyUp: this.preventEnterPress,
      onKeyDown: this.preventEnterPress,
      onKeyPress: this.preventEnterPress,
      onInput: function onInput(e) {
        return _this2.props.filterQuery(e);
      },
      value: this.props.filterInput
    }), h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-ProviderBrowser-searchIcon",
      width: "12",
      height: "12",
      viewBox: "0 0 12 12"
    }, h("path", {
      d: "M8.638 7.99l3.172 3.172a.492.492 0 1 1-.697.697L7.91 8.656a4.977 4.977 0 0 1-2.983.983C2.206 9.639 0 7.481 0 4.819 0 2.158 2.206 0 4.927 0c2.721 0 4.927 2.158 4.927 4.82a4.74 4.74 0 0 1-1.216 3.17zm-3.71.685c2.176 0 3.94-1.726 3.94-3.856 0-2.129-1.764-3.855-3.94-3.855C2.75.964.984 2.69.984 4.819c0 2.13 1.765 3.856 3.942 3.856z"
    })), this.props.filterInput && h("button", {
      className: "uppy-u-reset uppy-ProviderBrowser-searchClose",
      type: "button",
      "aria-label": this.props.i18n('resetFilter'),
      title: this.props.i18n('resetFilter'),
      onClick: this.props.filterQuery
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      viewBox: "0 0 19 19"
    }, h("path", {
      d: "M17.318 17.232L9.94 9.854 9.586 9.5l-.354.354-7.378 7.378h.707l-.62-.62v.706L9.318 9.94l.354-.354-.354-.354L1.94 1.854v.707l.62-.62h-.706l7.378 7.378.354.354.354-.354 7.378-7.378h-.707l.622.62v-.706L9.854 9.232l-.354.354.354.354 7.378 7.378.708-.707-7.38-7.378v.708l7.38-7.38.353-.353-.353-.353-.622-.622-.353-.353-.354.352-7.378 7.38h.708L2.56 1.23 2.208.88l-.353.353-.622.62-.353.355.352.353 7.38 7.38v-.708l-7.38 7.38-.353.353.352.353.622.622.353.353.354-.353 7.38-7.38h-.708l7.38 7.38z"
    }))));
  };

  return Filter;
}(Component);

},{"preact":122}],128:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("div", {
    className: "uppy-ProviderBrowser-footer"
  }, h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary",
    onClick: props.done
  }, props.i18n('selectX', {
    smart_count: props.selected
  })), h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-link",
    onClick: props.cancel
  }, props.i18n('cancel')));
};

},{"preact":122}],129:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h; // it could be a <li><button class="fake-checkbox"/> <button/></li>


module.exports = function (props) {
  return h("li", {
    className: props.className,
    title: props.isDisabled ? props.restrictionReason : null
  }, h("div", {
    "aria-hidden": true,
    className: "uppy-ProviderBrowserItem-fakeCheckbox " + (props.isChecked ? 'uppy-ProviderBrowserItem-fakeCheckbox--is-checked' : '')
  }), h("button", {
    type: "button",
    className: "uppy-u-reset uppy-ProviderBrowserItem-inner",
    onClick: props.toggleCheckbox,
    role: "option",
    "aria-label": props.isChecked ? props.i18n('unselectFileNamed', {
      name: props.title
    }) : props.i18n('selectFileNamed', {
      name: props.title
    }),
    "aria-selected": props.isChecked,
    "aria-disabled": props.isDisabled,
    disabled: props.isDisabled,
    "data-uppy-super-focusable": true
  }, props.itemIconEl, props.showTitles && props.title));
};

},{"preact":122}],130:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function FileIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: 11,
    height: 14.5,
    viewBox: "0 0 44 58"
  }, h("path", {
    d: "M27.437.517a1 1 0 0 0-.094.03H4.25C2.037.548.217 2.368.217 4.58v48.405c0 2.212 1.82 4.03 4.03 4.03H39.03c2.21 0 4.03-1.818 4.03-4.03V15.61a1 1 0 0 0-.03-.28 1 1 0 0 0 0-.093 1 1 0 0 0-.03-.032 1 1 0 0 0 0-.03 1 1 0 0 0-.032-.063 1 1 0 0 0-.03-.063 1 1 0 0 0-.032 0 1 1 0 0 0-.03-.063 1 1 0 0 0-.032-.03 1 1 0 0 0-.03-.063 1 1 0 0 0-.063-.062l-14.593-14a1 1 0 0 0-.062-.062A1 1 0 0 0 28 .708a1 1 0 0 0-.374-.157 1 1 0 0 0-.156 0 1 1 0 0 0-.03-.03l-.003-.003zM4.25 2.547h22.218v9.97c0 2.21 1.82 4.03 4.03 4.03h10.564v36.438a2.02 2.02 0 0 1-2.032 2.032H4.25c-1.13 0-2.032-.9-2.032-2.032V4.58c0-1.13.902-2.032 2.03-2.032zm24.218 1.345l10.375 9.937.75.718H30.5c-1.13 0-2.032-.9-2.032-2.03V3.89z"
  }));
}

function FolderIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    style: {
      minWidth: 16,
      marginRight: 3
    },
    viewBox: "0 0 276.157 276.157"
  }, h("path", {
    d: "M273.08 101.378c-3.3-4.65-8.86-7.32-15.254-7.32h-24.34V67.59c0-10.2-8.3-18.5-18.5-18.5h-85.322c-3.63 0-9.295-2.875-11.436-5.805l-6.386-8.735c-4.982-6.814-15.104-11.954-23.546-11.954H58.73c-9.292 0-18.638 6.608-21.737 15.372l-2.033 5.752c-.958 2.71-4.72 5.37-7.596 5.37H18.5C8.3 49.09 0 57.39 0 67.59v167.07c0 .886.16 1.73.443 2.52.152 3.306 1.18 6.424 3.053 9.064 3.3 4.652 8.86 7.32 15.255 7.32h188.487c11.395 0 23.27-8.425 27.035-19.18l40.677-116.188c2.11-6.035 1.43-12.164-1.87-16.816zM18.5 64.088h8.864c9.295 0 18.64-6.607 21.738-15.37l2.032-5.75c.96-2.712 4.722-5.373 7.597-5.373h29.565c3.63 0 9.295 2.876 11.437 5.806l6.386 8.735c4.982 6.815 15.104 11.954 23.546 11.954h85.322c1.898 0 3.5 1.602 3.5 3.5v26.47H69.34c-11.395 0-23.27 8.423-27.035 19.178L15 191.23V67.59c0-1.898 1.603-3.5 3.5-3.5zm242.29 49.15l-40.676 116.188c-1.674 4.78-7.812 9.135-12.877 9.135H18.75c-1.447 0-2.576-.372-3.02-.997-.442-.625-.422-1.814.057-3.18l40.677-116.19c1.674-4.78 7.812-9.134 12.877-9.134h188.487c1.448 0 2.577.372 3.02.997.443.625.423 1.814-.056 3.18z"
  }));
}

function VideoIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    style: {
      width: 16,
      marginRight: 4
    },
    viewBox: "0 0 58 58"
  }, h("path", {
    d: "M36.537 28.156l-11-7a1.005 1.005 0 0 0-1.02-.033C24.2 21.3 24 21.635 24 22v14a1 1 0 0 0 1.537.844l11-7a1.002 1.002 0 0 0 0-1.688zM26 34.18V23.82L34.137 29 26 34.18z"
  }), h("path", {
    d: "M57 6H1a1 1 0 0 0-1 1v44a1 1 0 0 0 1 1h56a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zM10 28H2v-9h8v9zm-8 2h8v9H2v-9zm10 10V8h34v42H12V40zm44-12h-8v-9h8v9zm-8 2h8v9h-8v-9zm8-22v9h-8V8h8zM2 8h8v9H2V8zm0 42v-9h8v9H2zm54 0h-8v-9h8v9z"
  }));
}

module.exports = function (props) {
  if (props.itemIconString === null) return;

  switch (props.itemIconString) {
    case 'file':
      return h(FileIcon, null);

    case 'folder':
      return h(FolderIcon, null);

    case 'video':
      return h(VideoIcon, null);

    default:
      return h("img", {
        src: props.itemIconString
      });
  }
};

},{"preact":122}],131:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var getAriaLabelOfCheckbox = function getAriaLabelOfCheckbox(props) {
  if (props.type === 'folder') {
    if (props.isChecked) {
      return props.i18n('unselectAllFilesFromFolderNamed', {
        name: props.title
      });
    }

    return props.i18n('selectAllFilesFromFolderNamed', {
      name: props.title
    });
  }

  if (props.isChecked) {
    return props.i18n('unselectFileNamed', {
      name: props.title
    });
  }

  return props.i18n('selectFileNamed', {
    name: props.title
  });
}; // if folder:
//   + checkbox (selects all files from folder)
//   + folder name (opens folder)
// if file:
//   + checkbox (selects file)
//   + file name (selects file)


module.exports = function (props) {
  return h("li", {
    className: props.className,
    title: props.isDisabled ? props.restrictionReason : null
  }, !props.isCheckboxDisabled ? h("button", {
    type: "button",
    className: "uppy-u-reset uppy-ProviderBrowserItem-fakeCheckbox " + (props.isChecked ? 'uppy-ProviderBrowserItem-fakeCheckbox--is-checked' : ''),
    onClick: props.toggleCheckbox // for the <label/>
    ,
    id: props.id,
    role: "option",
    "aria-label": getAriaLabelOfCheckbox(props),
    "aria-selected": props.isChecked,
    "aria-disabled": props.isDisabled,
    disabled: props.isDisabled,
    "data-uppy-super-focusable": true
  }) : null, props.type === 'file' ? // label for a checkbox
  h("label", {
    htmlFor: props.id,
    className: "uppy-u-reset uppy-ProviderBrowserItem-inner"
  }, h("div", {
    className: "uppy-ProviderBrowserItem-iconWrap"
  }, props.itemIconEl), props.showTitles && props.title) : // button to open a folder
  h("button", {
    type: "button",
    className: "uppy-u-reset uppy-ProviderBrowserItem-inner",
    onClick: props.handleFolderClick,
    "aria-label": props.i18n('openFolderNamed', {
      name: props.title
    })
  }, h("div", {
    className: "uppy-ProviderBrowserItem-iconWrap"
  }, props.itemIconEl), props.showTitles && h("span", null, props.title)));
};

},{"preact":122}],132:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

var ItemIcon = require('./components/ItemIcon');

var GridLi = require('./components/GridLi');

var ListLi = require('./components/ListLi');

module.exports = function (props) {
  var itemIconString = props.getItemIcon();
  var className = classNames('uppy-ProviderBrowserItem', {
    'uppy-ProviderBrowserItem--selected': props.isChecked
  }, {
    'uppy-ProviderBrowserItem--disabled': props.isDisabled
  }, {
    'uppy-ProviderBrowserItem--noPreview': itemIconString === 'video'
  });
  var itemIconEl = h(ItemIcon, {
    itemIconString: itemIconString
  });

  switch (props.viewType) {
    case 'grid':
      return h(GridLi, _extends({}, props, {
        className: className,
        itemIconEl: itemIconEl
      }));

    case 'list':
      return h(ListLi, _extends({}, props, {
        className: className,
        itemIconEl: itemIconEl
      }));

    default:
      throw new Error("There is no such type " + props.viewType);
  }
};

},{"./components/GridLi":129,"./components/ItemIcon":130,"./components/ListLi":131,"classnames":10,"preact":122}],133:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var remoteFileObjToLocal = require('./../../utils/lib/remoteFileObjToLocal');

var Item = require('./Item/index'); // Hopefully this name will not be used by Google


var VIRTUAL_SHARED_DIR = 'shared-with-me';

var getSharedProps = function getSharedProps(fileOrFolder, props) {
  return {
    id: fileOrFolder.id,
    title: fileOrFolder.name,
    getItemIcon: function getItemIcon() {
      return fileOrFolder.icon;
    },
    isChecked: props.isChecked(fileOrFolder),
    toggleCheckbox: function toggleCheckbox(e) {
      return props.toggleCheckbox(e, fileOrFolder);
    },
    columns: props.columns,
    showTitles: props.showTitles,
    viewType: props.viewType,
    i18n: props.i18n
  };
};

module.exports = function (props) {
  var folders = props.folders,
      files = props.files,
      handleScroll = props.handleScroll,
      isChecked = props.isChecked;

  if (!folders.length && !files.length) {
    return h("div", {
      className: "uppy-Provider-empty"
    }, props.i18n('noFilesFound'));
  }

  return h("div", {
    className: "uppy-ProviderBrowser-body"
  }, h("ul", {
    className: "uppy-ProviderBrowser-list",
    onScroll: handleScroll,
    role: "listbox" // making <ul> not focusable for firefox
    ,
    tabIndex: "-1"
  }, folders.map(function (folder) {
    return Item(_extends({}, getSharedProps(folder, props), {
      type: 'folder',
      isDisabled: isChecked(folder) ? isChecked(folder).loading : false,
      isCheckboxDisabled: folder.id === VIRTUAL_SHARED_DIR,
      handleFolderClick: function handleFolderClick() {
        return props.handleFolderClick(folder);
      }
    }));
  }), files.map(function (file) {
    var validateRestrictions = props.validateRestrictions(remoteFileObjToLocal(file), [].concat(props.uppyFiles, props.currentSelection));
    var sharedProps = getSharedProps(file, props);
    var restrictionReason = validateRestrictions.reason;
    return Item(_extends({}, sharedProps, {
      type: 'file',
      isDisabled: !validateRestrictions.result && !sharedProps.isChecked,
      restrictionReason: restrictionReason
    }));
  })));
};

},{"./../../utils/lib/remoteFileObjToLocal":242,"./Item/index":132,"preact":122}],134:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("div", {
    className: "uppy-Provider-loading"
  }, h("span", null, props.i18n('loading')));
};

},{"preact":122}],135:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var AuthView = /*#__PURE__*/function (_Component) {
  _inheritsLoose(AuthView, _Component);

  function AuthView() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = AuthView.prototype;

  _proto.render = function render() {
    var pluginNameComponent = h("span", {
      className: "uppy-Provider-authTitleName"
    }, this.props.pluginName, h("br", null));
    return h("div", {
      className: "uppy-Provider-auth"
    }, h("div", {
      className: "uppy-Provider-authIcon"
    }, this.props.pluginIcon()), h("div", {
      className: "uppy-Provider-authTitle"
    }, this.props.i18nArray('authenticateWithTitle', {
      pluginName: pluginNameComponent
    })), h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Provider-authBtn",
      onClick: this.props.handleAuth,
      "data-uppy-super-focusable": true
    }, this.props.i18nArray('authenticateWith', {
      pluginName: this.props.pluginName
    })));
  };

  return AuthView;
}(Component);

module.exports = AuthView;

},{"preact":122}],136:[function(require,module,exports){
var User = require('./User');

var Breadcrumbs = require('../Breadcrumbs');

module.exports = function (props) {
  var components = [];

  if (props.showBreadcrumbs) {
    components.push(Breadcrumbs({
      getFolder: props.getFolder,
      directories: props.directories,
      breadcrumbsIcon: props.pluginIcon && props.pluginIcon(),
      title: props.title
    }));
  }

  components.push(User({
    logout: props.logout,
    username: props.username,
    i18n: props.i18n
  }));
  return components;
};

},{"../Breadcrumbs":124,"./User":138}],137:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var AuthView = require('./AuthView');

var Header = require('./Header');

var Browser = require('../Browser');

var LoaderView = require('../Loader');

var generateFileID = require('./../../../utils/lib/generateFileID');

var getFileType = require('./../../../utils/lib/getFileType');

var findIndex = require('./../../../utils/lib/findIndex');

var isPreviewSupported = require('./../../../utils/lib/isPreviewSupported');

var SharedHandler = require('../SharedHandler');

var CloseWrapper = require('../CloseWrapper'); // location.origin does not exist in IE


function getOrigin() {
  if ('origin' in location) {
    return location.origin; // eslint-disable-line compat/compat
  }

  return location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : '');
}
/**
 * Class to easily generate generic views for Provider plugins
 */


module.exports = (_temp = _class = /*#__PURE__*/function () {
  /**
   * @param {object} plugin instance of the plugin
   * @param {object} opts
   */
  function ProviderView(plugin, opts) {
    this.plugin = plugin;
    this.provider = opts.provider;
    this._sharedHandler = new SharedHandler(plugin); // set default options

    var defaultOptions = {
      viewType: 'list',
      showTitles: true,
      showFilter: true,
      showBreadcrumbs: true
    }; // merge default options with the ones set by user

    this.opts = _extends({}, defaultOptions, opts); // Logic

    this.addFile = this.addFile.bind(this);
    this.filterQuery = this.filterQuery.bind(this);
    this.getFolder = this.getFolder.bind(this);
    this.getNextFolder = this.getNextFolder.bind(this);
    this.logout = this.logout.bind(this);
    this.preFirstRender = this.preFirstRender.bind(this);
    this.handleAuth = this.handleAuth.bind(this);
    this.sortByTitle = this.sortByTitle.bind(this);
    this.sortByDate = this.sortByDate.bind(this);
    this.handleError = this.handleError.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.listAllFiles = this.listAllFiles.bind(this);
    this.donePicking = this.donePicking.bind(this);
    this.cancelPicking = this.cancelPicking.bind(this);
    this.clearSelection = this.clearSelection.bind(this); // Visual

    this.render = this.render.bind(this);
    this.clearSelection(); // Set default state for the plugin

    this.plugin.setPluginState({
      authenticated: false,
      files: [],
      folders: [],
      directories: [],
      filterInput: '',
      isSearchVisible: false
    });
  }

  var _proto = ProviderView.prototype;

  _proto.tearDown = function tearDown() {// Nothing.
  };

  _proto._updateFilesAndFolders = function _updateFilesAndFolders(res, files, folders) {
    this.nextPagePath = res.nextPagePath;
    res.items.forEach(function (item) {
      if (item.isFolder) {
        folders.push(item);
      } else {
        files.push(item);
      }
    });
    this.plugin.setPluginState({
      folders: folders,
      files: files
    });
  }
  /**
   * Called only the first time the provider view is rendered.
   * Kind of like an init function.
   */
  ;

  _proto.preFirstRender = function preFirstRender() {
    this.plugin.setPluginState({
      didFirstRender: true
    });
    this.plugin.onFirstRender();
  }
  /**
   * Based on folder ID, fetch a new folder and update it to state
   *
   * @param  {string} id Folder id
   * @returns {Promise}   Folders/files in folder
   */
  ;

  _proto.getFolder = function getFolder(id, name) {
    var _this = this;

    return this._sharedHandler.loaderWrapper(this.provider.list(id), function (res) {
      var folders = [];
      var files = [];
      var updatedDirectories;

      var state = _this.plugin.getPluginState();

      var index = findIndex(state.directories, function (dir) {
        return id === dir.id;
      });

      if (index !== -1) {
        updatedDirectories = state.directories.slice(0, index + 1);
      } else {
        updatedDirectories = state.directories.concat([{
          id: id,
          title: name
        }]);
      }

      _this.username = res.username || _this.username;

      _this._updateFilesAndFolders(res, files, folders);

      _this.plugin.setPluginState({
        directories: updatedDirectories
      });
    }, this.handleError);
  }
  /**
   * Fetches new folder
   *
   * @param  {object} folder
   */
  ;

  _proto.getNextFolder = function getNextFolder(folder) {
    this.getFolder(folder.requestPath, folder.name);
    this.lastCheckbox = undefined;
  };

  _proto.addFile = function addFile(file) {
    var tagFile = {
      id: this.providerFileToId(file),
      source: this.plugin.id,
      data: file,
      name: file.name || file.id,
      type: file.mimeType,
      isRemote: true,
      body: {
        fileId: file.id
      },
      remote: {
        companionUrl: this.plugin.opts.companionUrl,
        url: "" + this.provider.fileUrl(file.requestPath),
        body: {
          fileId: file.id
        },
        providerOptions: this.provider.opts
      }
    };
    var fileType = getFileType(tagFile); // TODO Should we just always use the thumbnail URL if it exists?

    if (fileType && isPreviewSupported(fileType)) {
      tagFile.preview = file.thumbnail;
    }

    this.plugin.uppy.log('Adding remote file');

    try {
      this.plugin.uppy.addFile(tagFile);
      return true;
    } catch (err) {
      if (!err.isRestriction) {
        this.plugin.uppy.log(err);
      }

      return false;
    }
  }
  /**
   * Removes session token on client side.
   */
  ;

  _proto.logout = function logout() {
    var _this2 = this;

    this.provider.logout().then(function (res) {
      if (res.ok) {
        if (!res.revoked) {
          var message = _this2.plugin.uppy.i18n('companionUnauthorizeHint', {
            provider: _this2.plugin.title,
            url: res.manual_revoke_url
          });

          _this2.plugin.uppy.info(message, 'info', 7000);
        }

        var newState = {
          authenticated: false,
          files: [],
          folders: [],
          directories: []
        };

        _this2.plugin.setPluginState(newState);
      }
    }).catch(this.handleError);
  };

  _proto.filterQuery = function filterQuery(e) {
    var state = this.plugin.getPluginState();
    this.plugin.setPluginState(_extends({}, state, {
      filterInput: e ? e.target.value : ''
    }));
  };

  _proto.sortByTitle = function sortByTitle() {
    var state = _extends({}, this.plugin.getPluginState());

    var files = state.files,
        folders = state.folders,
        sorting = state.sorting;
    var sortedFiles = files.sort(function (fileA, fileB) {
      if (sorting === 'titleDescending') {
        return fileB.name.localeCompare(fileA.name);
      }

      return fileA.name.localeCompare(fileB.name);
    });
    var sortedFolders = folders.sort(function (folderA, folderB) {
      if (sorting === 'titleDescending') {
        return folderB.name.localeCompare(folderA.name);
      }

      return folderA.name.localeCompare(folderB.name);
    });
    this.plugin.setPluginState(_extends({}, state, {
      files: sortedFiles,
      folders: sortedFolders,
      sorting: sorting === 'titleDescending' ? 'titleAscending' : 'titleDescending'
    }));
  };

  _proto.sortByDate = function sortByDate() {
    var state = _extends({}, this.plugin.getPluginState());

    var files = state.files,
        folders = state.folders,
        sorting = state.sorting;
    var sortedFiles = files.sort(function (fileA, fileB) {
      var a = new Date(fileA.modifiedDate);
      var b = new Date(fileB.modifiedDate);

      if (sorting === 'dateDescending') {
        return a > b ? -1 : a < b ? 1 : 0;
      }

      return a > b ? 1 : a < b ? -1 : 0;
    });
    var sortedFolders = folders.sort(function (folderA, folderB) {
      var a = new Date(folderA.modifiedDate);
      var b = new Date(folderB.modifiedDate);

      if (sorting === 'dateDescending') {
        return a > b ? -1 : a < b ? 1 : 0;
      }

      return a > b ? 1 : a < b ? -1 : 0;
    });
    this.plugin.setPluginState(_extends({}, state, {
      files: sortedFiles,
      folders: sortedFolders,
      sorting: sorting === 'dateDescending' ? 'dateAscending' : 'dateDescending'
    }));
  };

  _proto.sortBySize = function sortBySize() {
    var state = _extends({}, this.plugin.getPluginState());

    var files = state.files,
        sorting = state.sorting; // check that plugin supports file sizes

    if (!files.length || !this.plugin.getItemData(files[0]).size) {
      return;
    }

    var sortedFiles = files.sort(function (fileA, fileB) {
      var a = fileA.size;
      var b = fileB.size;

      if (sorting === 'sizeDescending') {
        return a > b ? -1 : a < b ? 1 : 0;
      }

      return a > b ? 1 : a < b ? -1 : 0;
    });
    this.plugin.setPluginState(_extends({}, state, {
      files: sortedFiles,
      sorting: sorting === 'sizeDescending' ? 'sizeAscending' : 'sizeDescending'
    }));
  }
  /**
   * Adds all files found inside of specified folder.
   *
   * Uses separated state while folder contents are being fetched and
   * mantains list of selected folders, which are separated from files.
   */
  ;

  _proto.addFolder = function addFolder(folder) {
    var _this3 = this;

    var folderId = this.providerFileToId(folder);
    var state = this.plugin.getPluginState();

    var folders = _extends({}, state.selectedFolders);

    if (folderId in folders && folders[folderId].loading) {
      return;
    }

    folders[folderId] = {
      loading: true,
      files: []
    };
    this.plugin.setPluginState({
      selectedFolders: _extends({}, folders)
    });
    return this.listAllFiles(folder.requestPath).then(function (files) {
      var count = 0;
      files.forEach(function (file) {
        var success = _this3.addFile(file);

        if (success) count++;
      });
      var ids = files.map(_this3.providerFileToId);
      folders[folderId] = {
        loading: false,
        files: ids
      };

      _this3.plugin.setPluginState({
        selectedFolders: folders
      });

      var message;

      if (files.length) {
        message = _this3.plugin.uppy.i18n('folderAdded', {
          smart_count: count,
          folder: folder.name
        });
      } else {
        message = _this3.plugin.uppy.i18n('emptyFolderAdded');
      }

      _this3.plugin.uppy.info(message);
    }).catch(function (e) {
      var state = _this3.plugin.getPluginState();

      var selectedFolders = _extends({}, state.selectedFolders);

      delete selectedFolders[folderId];

      _this3.plugin.setPluginState({
        selectedFolders: selectedFolders
      });

      _this3.handleError(e);
    });
  };

  _proto.providerFileToId = function providerFileToId(file) {
    return generateFileID({
      data: file,
      name: file.name || file.id,
      type: file.mimeType
    });
  };

  _proto.handleAuth = function handleAuth() {
    var _this4 = this;

    var authState = btoa(JSON.stringify({
      origin: getOrigin()
    }));
    var clientVersion = "@uppy/provider-views=" + ProviderView.VERSION;
    var link = this.provider.authUrl({
      state: authState,
      uppyVersions: clientVersion
    });
    var authWindow = window.open(link, '_blank');

    var handleToken = function handleToken(e) {
      if (!_this4._isOriginAllowed(e.origin, _this4.plugin.opts.companionAllowedHosts) || e.source !== authWindow) {
        _this4.plugin.uppy.log("rejecting event from " + e.origin + " vs allowed pattern " + _this4.plugin.opts.companionAllowedHosts);

        return;
      } // Check if it's a string before doing the JSON.parse to maintain support
      // for older Companion versions that used object references


      var data = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;

      if (!data.token) {
        _this4.plugin.uppy.log('did not receive token from auth window');

        return;
      }

      authWindow.close();
      window.removeEventListener('message', handleToken);

      _this4.provider.setAuthToken(data.token);

      _this4.preFirstRender();
    };

    window.addEventListener('message', handleToken);
  };

  _proto._isOriginAllowed = function _isOriginAllowed(origin, allowedOrigin) {
    var getRegex = function getRegex(value) {
      if (typeof value === 'string') {
        return new RegExp("^" + value + "$");
      }

      if (value instanceof RegExp) {
        return value;
      }
    };

    var patterns = Array.isArray(allowedOrigin) ? allowedOrigin.map(getRegex) : [getRegex(allowedOrigin)];
    return patterns.filter(function (pattern) {
      return pattern != null;
    }) // loose comparison to catch undefined
    .some(function (pattern) {
      return pattern.test(origin) || pattern.test(origin + "/");
    }); // allowing for trailing '/'
  };

  _proto.handleError = function handleError(error) {
    var uppy = this.plugin.uppy;
    uppy.log(error.toString());

    if (error.isAuthError) {
      return;
    }

    var message = uppy.i18n('companionError');
    uppy.info({
      message: message,
      details: error.toString()
    }, 'error', 5000);
  };

  _proto.handleScroll = function handleScroll(e) {
    var _this5 = this;

    var scrollPos = e.target.scrollHeight - (e.target.scrollTop + e.target.offsetHeight);
    var path = this.nextPagePath || null;

    if (scrollPos < 50 && path && !this._isHandlingScroll) {
      this.provider.list(path).then(function (res) {
        var _this5$plugin$getPlug = _this5.plugin.getPluginState(),
            files = _this5$plugin$getPlug.files,
            folders = _this5$plugin$getPlug.folders;

        _this5._updateFilesAndFolders(res, files, folders);
      }).catch(this.handleError).then(function () {
        _this5._isHandlingScroll = false;
      }); // always called

      this._isHandlingScroll = true;
    }
  };

  _proto.listAllFiles = function listAllFiles(path, files) {
    var _this6 = this;

    if (files === void 0) {
      files = null;
    }

    files = files || [];
    return new Promise(function (resolve, reject) {
      _this6.provider.list(path).then(function (res) {
        res.items.forEach(function (item) {
          if (!item.isFolder) {
            files.push(item);
          } else {
            _this6.addFolder(item);
          }
        });
        var moreFiles = res.nextPagePath || null;

        if (moreFiles) {
          return _this6.listAllFiles(moreFiles, files).then(function (files) {
            return resolve(files);
          }).catch(function (e) {
            return reject(e);
          });
        }

        return resolve(files);
      }).catch(function (e) {
        return reject(e);
      });
    });
  };

  _proto.donePicking = function donePicking() {
    var _this7 = this;

    var _this$plugin$getPlugi = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi.currentSelection;

    var promises = currentSelection.map(function (file) {
      if (file.isFolder) {
        return _this7.addFolder(file);
      }

      return _this7.addFile(file);
    });

    this._sharedHandler.loaderWrapper(Promise.all(promises), function () {
      _this7.clearSelection();
    }, function () {});
  };

  _proto.cancelPicking = function cancelPicking() {
    this.clearSelection();
    var dashboard = this.plugin.uppy.getPlugin('Dashboard');
    if (dashboard) dashboard.hideAllPanels();
  };

  _proto.clearSelection = function clearSelection() {
    this.plugin.setPluginState({
      currentSelection: []
    });
  };

  _proto.render = function render(state, viewOptions) {
    if (viewOptions === void 0) {
      viewOptions = {};
    }

    var _this$plugin$getPlugi2 = this.plugin.getPluginState(),
        authenticated = _this$plugin$getPlugi2.authenticated,
        didFirstRender = _this$plugin$getPlugi2.didFirstRender;

    if (!didFirstRender) {
      this.preFirstRender();
    } // reload pluginState for "loading" attribute because it might
    // have changed above.


    if (this.plugin.getPluginState().loading) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(LoaderView, {
        i18n: this.plugin.uppy.i18n
      }));
    }

    if (!authenticated) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(AuthView, {
        pluginName: this.plugin.title,
        pluginIcon: this.plugin.icon,
        handleAuth: this.handleAuth,
        i18n: this.plugin.uppy.i18n,
        i18nArray: this.plugin.uppy.i18nArray
      }));
    }

    var targetViewOptions = _extends({}, this.opts, viewOptions);

    var headerProps = {
      showBreadcrumbs: targetViewOptions.showBreadcrumbs,
      getFolder: this.getFolder,
      directories: this.plugin.getPluginState().directories,
      pluginIcon: this.plugin.icon,
      title: this.plugin.title,
      logout: this.logout,
      username: this.username,
      i18n: this.plugin.uppy.i18n
    };

    var browserProps = _extends({}, this.plugin.getPluginState(), {
      username: this.username,
      getNextFolder: this.getNextFolder,
      getFolder: this.getFolder,
      filterItems: this._sharedHandler.filterItems,
      filterQuery: this.filterQuery,
      sortByTitle: this.sortByTitle,
      sortByDate: this.sortByDate,
      logout: this.logout,
      isChecked: this._sharedHandler.isChecked,
      toggleCheckbox: this._sharedHandler.toggleCheckbox,
      handleScroll: this.handleScroll,
      listAllFiles: this.listAllFiles,
      done: this.donePicking,
      cancel: this.cancelPicking,
      headerComponent: Header(headerProps),
      title: this.plugin.title,
      viewType: targetViewOptions.viewType,
      showTitles: targetViewOptions.showTitles,
      showFilter: targetViewOptions.showFilter,
      showBreadcrumbs: targetViewOptions.showBreadcrumbs,
      pluginIcon: this.plugin.icon,
      i18n: this.plugin.uppy.i18n,
      uppyFiles: this.plugin.uppy.getFiles(),
      validateRestrictions: this.plugin.uppy.validateRestrictions
    });

    return h(CloseWrapper, {
      onUnmount: this.clearSelection
    }, h(Browser, browserProps));
  };

  return ProviderView;
}(), _class.VERSION = require('../../package.json').version, _temp);

},{"../../package.json":123,"../Browser":125,"../CloseWrapper":126,"../Loader":134,"../SharedHandler":144,"./../../../utils/lib/findIndex":219,"./../../../utils/lib/generateFileID":220,"./../../../utils/lib/getFileType":228,"./../../../utils/lib/isPreviewSupported":239,"./AuthView":135,"./Header":136,"preact":122}],138:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return [h("span", {
    className: "uppy-ProviderBrowser-user",
    key: "username"
  }, props.username), h("button", {
    type: "button",
    onClick: props.logout,
    className: "uppy-u-reset uppy-ProviderBrowser-userLogout",
    key: "logout"
  }, props.i18n('logOut'))];
};

},{"preact":122}],139:[function(require,module,exports){
module.exports = require('./ProviderView');

},{"./ProviderView":137}],140:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("button", {
    type: "button",
    onClick: props.triggerSearchInput,
    className: "uppy-u-reset uppy-ProviderBrowser-userLogout"
  }, props.i18n('backToSearch'));
};

},{"preact":122}],141:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  var input;

  var handleKeyPress = function handleKeyPress(ev) {
    if (ev.keyCode === 13) {
      validateAndSearch();
    }
  };

  var validateAndSearch = function validateAndSearch() {
    if (input.value) {
      props.search(input.value);
    }
  };

  return h("div", {
    className: "uppy-SearchProvider"
  }, h("input", {
    className: "uppy-u-reset uppy-c-textInput uppy-SearchProvider-input",
    type: "text",
    "aria-label": props.i18n('enterTextToSearch'),
    placeholder: props.i18n('enterTextToSearch'),
    onKeyUp: handleKeyPress,
    ref: function ref(input_) {
      input = input_;
    },
    "data-uppy-super-focusable": true
  }), h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-SearchProvider-searchButton",
    type: "button",
    onClick: validateAndSearch
  }, props.i18n('searchImages')));
};

},{"preact":122}],142:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var SearchInput = require('./InputView');

var Browser = require('../Browser');

var LoaderView = require('../Loader');

var generateFileID = require('./../../../utils/lib/generateFileID');

var getFileType = require('./../../../utils/lib/getFileType');

var isPreviewSupported = require('./../../../utils/lib/isPreviewSupported');

var Header = require('./Header');

var SharedHandler = require('../SharedHandler');

var CloseWrapper = require('../CloseWrapper');
/**
 * Class to easily generate generic views for Provider plugins
 */


module.exports = (_temp = _class = /*#__PURE__*/function () {
  /**
   * @param {object} plugin instance of the plugin
   * @param {object} opts
   */
  function ProviderView(plugin, opts) {
    this.plugin = plugin;
    this.provider = opts.provider;
    this._sharedHandler = new SharedHandler(plugin); // set default options

    var defaultOptions = {
      viewType: 'grid',
      showTitles: false,
      showFilter: false,
      showBreadcrumbs: false
    }; // merge default options with the ones set by user

    this.opts = _extends({}, defaultOptions, opts); // Logic

    this.search = this.search.bind(this);
    this.triggerSearchInput = this.triggerSearchInput.bind(this);
    this.addFile = this.addFile.bind(this);
    this.preFirstRender = this.preFirstRender.bind(this);
    this.handleError = this.handleError.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.donePicking = this.donePicking.bind(this);
    this.cancelPicking = this.cancelPicking.bind(this);
    this.clearSelection = this.clearSelection.bind(this); // Visual

    this.render = this.render.bind(this);
    this.clearSelection(); // Set default state for the plugin

    this.plugin.setPluginState({
      isInputMode: true,
      files: [],
      folders: [],
      directories: [],
      filterInput: '',
      isSearchVisible: false
    });
  }

  var _proto = ProviderView.prototype;

  _proto.tearDown = function tearDown() {// Nothing.
  };

  _proto._updateFilesAndInputMode = function _updateFilesAndInputMode(res, files) {
    this.nextPageQuery = res.nextPageQuery;
    this._searchTerm = res.searchedFor;
    res.items.forEach(function (item) {
      files.push(item);
    });
    this.plugin.setPluginState({
      isInputMode: false,
      files: files
    });
  }
  /**
   * Called only the first time the provider view is rendered.
   * Kind of like an init function.
   */
  ;

  _proto.preFirstRender = function preFirstRender() {
    this.plugin.setPluginState({
      didFirstRender: true
    });
    this.plugin.onFirstRender();
  };

  _proto.search = function search(query) {
    var _this = this;

    if (query && query === this._searchTerm) {
      // no need to search again as this is the same as the previous search
      this.plugin.setPluginState({
        isInputMode: false
      });
      return;
    }

    return this._sharedHandler.loaderWrapper(this.provider.search(query), function (res) {
      _this._updateFilesAndInputMode(res, []);
    }, this.handleError);
  };

  _proto.triggerSearchInput = function triggerSearchInput() {
    this.plugin.setPluginState({
      isInputMode: true
    });
  } // @todo this function should really be a function of the plugin and not the view.
  // maybe we should consider creating a base ProviderPlugin class that has this method
  ;

  _proto.addFile = function addFile(file) {
    var tagFile = {
      id: this.providerFileToId(file),
      source: this.plugin.id,
      data: file,
      name: file.name || file.id,
      type: file.mimeType,
      isRemote: true,
      body: {
        fileId: file.id
      },
      remote: {
        companionUrl: this.plugin.opts.companionUrl,
        url: "" + this.provider.fileUrl(file.requestPath),
        body: {
          fileId: file.id
        },
        providerOptions: _extends({}, this.provider.opts, {
          provider: null
        })
      }
    };
    var fileType = getFileType(tagFile); // TODO Should we just always use the thumbnail URL if it exists?

    if (fileType && isPreviewSupported(fileType)) {
      tagFile.preview = file.thumbnail;
    }

    this.plugin.uppy.log('Adding remote file');

    try {
      this.plugin.uppy.addFile(tagFile);
    } catch (err) {
      if (!err.isRestriction) {
        this.plugin.uppy.log(err);
      }
    }
  };

  _proto.providerFileToId = function providerFileToId(file) {
    return generateFileID({
      data: file,
      name: file.name || file.id,
      type: file.mimeType
    });
  };

  _proto.handleError = function handleError(error) {
    var uppy = this.plugin.uppy;
    uppy.log(error.toString());
    var message = uppy.i18n('companionError');
    uppy.info({
      message: message,
      details: error.toString()
    }, 'error', 5000);
  };

  _proto.handleScroll = function handleScroll(e) {
    var _this2 = this;

    var scrollPos = e.target.scrollHeight - (e.target.scrollTop + e.target.offsetHeight);
    var query = this.nextPageQuery || null;

    if (scrollPos < 50 && query && !this._isHandlingScroll) {
      this.provider.search(this._searchTerm, query).then(function (res) {
        var _this2$plugin$getPlug = _this2.plugin.getPluginState(),
            files = _this2$plugin$getPlug.files;

        _this2._updateFilesAndInputMode(res, files);
      }).catch(this.handleError).then(function () {
        _this2._isHandlingScroll = false;
      }); // always called

      this._isHandlingScroll = true;
    }
  };

  _proto.donePicking = function donePicking() {
    var _this3 = this;

    var _this$plugin$getPlugi = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi.currentSelection;

    var promises = currentSelection.map(function (file) {
      return _this3.addFile(file);
    });

    this._sharedHandler.loaderWrapper(Promise.all(promises), function () {
      _this3.clearSelection();
    }, function () {});
  };

  _proto.cancelPicking = function cancelPicking() {
    this.clearSelection();
    var dashboard = this.plugin.uppy.getPlugin('Dashboard');
    if (dashboard) dashboard.hideAllPanels();
  };

  _proto.clearSelection = function clearSelection() {
    this.plugin.setPluginState({
      currentSelection: []
    });
  };

  _proto.render = function render(state, viewOptions) {
    if (viewOptions === void 0) {
      viewOptions = {};
    }

    var _this$plugin$getPlugi2 = this.plugin.getPluginState(),
        didFirstRender = _this$plugin$getPlugi2.didFirstRender,
        isInputMode = _this$plugin$getPlugi2.isInputMode;

    if (!didFirstRender) {
      this.preFirstRender();
    } // reload pluginState for "loading" attribute because it might
    // have changed above.


    if (this.plugin.getPluginState().loading) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(LoaderView, {
        i18n: this.plugin.uppy.i18n
      }));
    }

    if (isInputMode) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(SearchInput, {
        search: this.search,
        i18n: this.plugin.uppy.i18n
      }));
    }

    var targetViewOptions = _extends({}, this.opts, viewOptions);

    var browserProps = _extends({}, this.plugin.getPluginState(), {
      isChecked: this._sharedHandler.isChecked,
      toggleCheckbox: this._sharedHandler.toggleCheckbox,
      handleScroll: this.handleScroll,
      done: this.donePicking,
      cancel: this.cancelPicking,
      headerComponent: Header({
        triggerSearchInput: this.triggerSearchInput,
        i18n: this.plugin.uppy.i18n
      }),
      title: this.plugin.title,
      viewType: targetViewOptions.viewType,
      showTitles: targetViewOptions.showTitles,
      showFilter: targetViewOptions.showFilter,
      showBreadcrumbs: targetViewOptions.showBreadcrumbs,
      pluginIcon: this.plugin.icon,
      i18n: this.plugin.uppy.i18n,
      uppyFiles: this.plugin.uppy.getFiles(),
      validateRestrictions: this.plugin.uppy.validateRestrictions
    });

    return h(CloseWrapper, {
      onUnmount: this.clearSelection
    }, h(Browser, browserProps));
  };

  return ProviderView;
}(), _class.VERSION = require('../../package.json').version, _temp);

},{"../../package.json":123,"../Browser":125,"../CloseWrapper":126,"../Loader":134,"../SharedHandler":144,"./../../../utils/lib/generateFileID":220,"./../../../utils/lib/getFileType":228,"./../../../utils/lib/isPreviewSupported":239,"./Header":140,"./InputView":141,"preact":122}],143:[function(require,module,exports){
module.exports = require('./SearchProviderView');

},{"./SearchProviderView":142}],144:[function(require,module,exports){
var remoteFileObjToLocal = require('./../../utils/lib/remoteFileObjToLocal');

module.exports = /*#__PURE__*/function () {
  function SharedHandler(plugin) {
    this.plugin = plugin;
    this.filterItems = this.filterItems.bind(this);
    this.toggleCheckbox = this.toggleCheckbox.bind(this);
    this.isChecked = this.isChecked.bind(this);
    this.loaderWrapper = this.loaderWrapper.bind(this);
  }

  var _proto = SharedHandler.prototype;

  _proto.filterItems = function filterItems(items) {
    var state = this.plugin.getPluginState();

    if (!state.filterInput || state.filterInput === '') {
      return items;
    }

    return items.filter(function (folder) {
      return folder.name.toLowerCase().indexOf(state.filterInput.toLowerCase()) !== -1;
    });
  }
  /**
   * Toggles file/folder checkbox to on/off state while updating files list.
   *
   * Note that some extra complexity comes from supporting shift+click to
   * toggle multiple checkboxes at once, which is done by getting all files
   * in between last checked file and current one.
   */
  ;

  _proto.toggleCheckbox = function toggleCheckbox(e, file) {
    var _this = this;

    e.stopPropagation();
    e.preventDefault();
    e.currentTarget.focus();

    var _this$plugin$getPlugi = this.plugin.getPluginState(),
        folders = _this$plugin$getPlugi.folders,
        files = _this$plugin$getPlugi.files;

    var items = this.filterItems(folders.concat(files)); // Shift-clicking selects a single consecutive list of items
    // starting at the previous click and deselects everything else.

    if (this.lastCheckbox && e.shiftKey) {
      var _currentSelection;

      var prevIndex = items.indexOf(this.lastCheckbox);
      var currentIndex = items.indexOf(file);

      if (prevIndex < currentIndex) {
        _currentSelection = items.slice(prevIndex, currentIndex + 1);
      } else {
        _currentSelection = items.slice(currentIndex, prevIndex + 1);
      } // Check restrictions on each file in currentSelection,
      // reduce it to only contain files that pass restrictions


      _currentSelection = _currentSelection.reduce(function (reducedCurrentSelection, item) {
        var uppy = _this.plugin.uppy;
        var validatedRestrictions = uppy.validateRestrictions(remoteFileObjToLocal(item), [].concat(uppy.getFiles(), reducedCurrentSelection));

        if (!validatedRestrictions.result) {
          uppy.info({
            message: validatedRestrictions.reason
          }, 'error', uppy.opts.infoTimeout);
          return reducedCurrentSelection;
        }

        return [].concat(reducedCurrentSelection, [item]);
      });
      this.plugin.setPluginState({
        currentSelection: _currentSelection
      });
      return;
    }

    this.lastCheckbox = file;

    var _this$plugin$getPlugi2 = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi2.currentSelection;

    if (this.isChecked(file)) {
      this.plugin.setPluginState({
        currentSelection: currentSelection.filter(function (item) {
          return item.id !== file.id;
        })
      });
    } else {
      this.plugin.setPluginState({
        currentSelection: currentSelection.concat([file])
      });
    }
  };

  _proto.isChecked = function isChecked(file) {
    var _this$plugin$getPlugi3 = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi3.currentSelection; // comparing id instead of the file object, because the reference to the object
    // changes when we switch folders, and the file list is updated


    return currentSelection.some(function (item) {
      return item.id === file.id;
    });
  };

  _proto.loaderWrapper = function loaderWrapper(promise, then, catch_) {
    var _this2 = this;

    promise.then(function (result) {
      _this2.plugin.setPluginState({
        loading: false
      });

      then(result);
    }).catch(function (err) {
      _this2.plugin.setPluginState({
        loading: false
      });

      catch_(err);
    });
    this.plugin.setPluginState({
      loading: true
    });
  };

  return SharedHandler;
}();

},{"./../../utils/lib/remoteFileObjToLocal":242}],145:[function(require,module,exports){
var ProviderViews = require('./ProviderView');

var SearchProviderViews = require('./SearchProviderView');

module.exports = {
  ProviderViews: ProviderViews,
  SearchProviderViews: SearchProviderViews
};

},{"./ProviderView":139,"./SearchProviderView":143}],146:[function(require,module,exports){
module.exports={
  "name": "@uppy/robodog",
  "description": "Transloadit SDK for browsers based on Uppy",
  "version": "1.10.12",
  "license": "MIT",
  "main": "lib/index.js",
  "jsnext:main": "src/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "transloadit",
    "file encoding",
    "encoding",
    "file processing",
    "video encoding",
    "crop",
    "resize",
    "watermark",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/core": "file:../core",
    "@uppy/dashboard": "file:../dashboard",
    "@uppy/dropbox": "file:../dropbox",
    "@uppy/facebook": "file:../facebook",
    "@uppy/form": "file:../form",
    "@uppy/google-drive": "file:../google-drive",
    "@uppy/instagram": "file:../instagram",
    "@uppy/onedrive": "file:../onedrive",
    "@uppy/status-bar": "file:../status-bar",
    "@uppy/transloadit": "file:../transloadit",
    "@uppy/url": "file:../url",
    "@uppy/utils": "file:../utils",
    "@uppy/webcam": "file:../webcam",
    "es6-promise": "4.2.5",
    "whatwg-fetch": "3.6.2"
  }
}

},{}],147:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var toArray = require('./../../utils/lib/toArray');

var findDOMElement = require('./../../utils/lib/findDOMElement');
/**
 * Add files from existing file inputs to Uppy.
 */


var AttachFileInputs = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(AttachFileInputs, _Plugin);

  function AttachFileInputs(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'AttachFileInputs';
    _this.type = 'acquirer';
    _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_this));
    _this.inputs = null;
    return _this;
  }

  var _proto = AttachFileInputs.prototype;

  _proto.handleChange = function handleChange(event) {
    this.addFiles(event.target);
  };

  _proto.addFiles = function addFiles(input) {
    var _this2 = this;

    var files = toArray(input.files);
    files.forEach(function (file) {
      try {
        _this2.uppy.addFile({
          source: _this2.id,
          name: file.name,
          type: file.type,
          data: file
        });
      } catch (err) {
        if (!err.isRestriction) {
          _this2.uppy.log(err);
        }
      }
    });
  };

  _proto.install = function install() {
    var _this3 = this;

    this.el = findDOMElement(this.opts.target);

    if (!this.el) {
      throw new Error('[AttachFileInputs] Target form does not exist');
    }

    var restrictions = this.uppy.opts.restrictions;
    this.inputs = this.el.querySelectorAll('input[type="file"]');
    this.inputs.forEach(function (input) {
      input.addEventListener('change', _this3.handleChange);

      if (!input.hasAttribute('multiple')) {
        if (restrictions.maxNumberOfFiles !== 1) {
          input.setAttribute('multiple', 'multiple');
        } else {
          input.removeAttribute('multiple');
        }
      }

      if (!input.hasAttribute('accept') && restrictions.allowedFileTypes) {
        input.setAttribute('accept', restrictions.allowedFileTypes.join(','));
      } // Check if this input already contains files (eg. user selected them before Uppy loaded,
      // or the page was refreshed and the browser kept files selected)


      _this3.addFiles(input);
    });
  };

  _proto.uninstall = function uninstall() {
    var _this4 = this;

    this.inputs.forEach(function (input) {
      input.removeEventListener('change', _this4.handleChange);
    });
    this.inputs = null;
  };

  return AttachFileInputs;
}(Plugin);

module.exports = AttachFileInputs;

},{"./../../core":73,"./../../utils/lib/findDOMElement":218,"./../../utils/lib/toArray":245}],148:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var findDOMElement = require('./../../utils/lib/findDOMElement');
/**
 * After an upload completes, inject result data from Transloadit in a hidden input.
 *
 * Must be added _after_ the Transloadit plugin.
 */


var TransloaditFormResult = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(TransloaditFormResult, _Plugin);

  function TransloaditFormResult(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'TransloaditFormResult';
    _this.type = 'modifier';
    _this.handleUpload = _this.handleUpload.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = TransloaditFormResult.prototype;

  _proto.getAssemblyStatuses = function getAssemblyStatuses(fileIDs) {
    var _this2 = this;

    var assemblyIds = [];
    fileIDs.forEach(function (fileID) {
      var file = _this2.uppy.getFile(fileID);

      var assembly = file.transloadit && file.transloadit.assembly;

      if (assembly && assemblyIds.indexOf(assembly) === -1) {
        assemblyIds.push(assembly);
      }
    });
    var tl = this.uppy.getPlugin(this.opts.transloaditPluginId || 'Transloadit');
    return assemblyIds.map(function (id) {
      return tl.getAssembly(id);
    });
  };

  _proto.handleUpload = function handleUpload(fileIDs) {
    var assemblies = this.getAssemblyStatuses(fileIDs);
    var input = document.createElement('input');
    input.type = 'hidden';
    input.name = this.opts.name;
    input.value = JSON.stringify(assemblies);
    var target = findDOMElement(this.opts.target);
    target.appendChild(input);
  };

  _proto.install = function install() {
    this.uppy.addPostProcessor(this.handleUpload);
  };

  _proto.uninstall = function uninstall() {
    this.uppy.removePostProcessor(this.handleUpload);
  };

  return TransloaditFormResult;
}(Plugin);

module.exports = TransloaditFormResult;

},{"./../../core":73,"./../../utils/lib/findDOMElement":218}],149:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;
/**
 * Add a `results` key to the upload result data, containing all Transloadit Assembly results.
 */


var TransloaditResultsPlugin = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(TransloaditResultsPlugin, _Plugin);

  function TransloaditResultsPlugin(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.type = 'modifier';
    _this.id = _this.opts.id || 'TransloaditResultsPlugin';
    _this._afterUpload = _this._afterUpload.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = TransloaditResultsPlugin.prototype;

  _proto.install = function install() {
    this.uppy.addPostProcessor(this._afterUpload);
  };

  _proto._afterUpload = function _afterUpload(fileIDs, uploadID) {
    var _this$uppy$getState = this.uppy.getState(),
        currentUploads = _this$uppy$getState.currentUploads;

    var result = currentUploads[uploadID].result;
    var assemblies = result && Array.isArray(result.transloadit) ? result.transloadit : []; // Merge the assembly.results[*] arrays and add `stepName` and
    // `assemblyId` properties.

    var assemblyResults = [];
    assemblies.forEach(function (assembly) {
      Object.keys(assembly.results).forEach(function (stepName) {
        var results = assembly.results[stepName];
        results.forEach(function (result) {
          assemblyResults.push(_extends({}, result, {
            assemblyId: assembly.assembly_id,
            stepName: stepName
          }));
        });
      });
    });
    this.uppy.addResultData(uploadID, {
      results: assemblyResults
    });
  };

  return TransloaditResultsPlugin;
}(Plugin);

module.exports = TransloaditResultsPlugin;

},{"./../../core":73}],150:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var Dashboard = require('./../../dashboard');

var has = require('./../../utils/lib/hasProperty');

var dashboardOptionNames = ['metaFields', 'width', 'height', 'thumbnailWidth', 'showLinkToFileUploadResult', 'showProgressDetails', 'hideRetryButton', 'hideCancelButton', 'hideUploadButton', 'hideProgressAfterFinish', 'note', 'disableStatusBar', 'disableInformer', 'disableThumbnailGenerator', 'showSelectedFiles', 'proudlyDisplayPoweredByUppy', 'theme'];
var modalDashboardOptionNames = ['trigger', 'closeModalOnClickOutside', 'closeAfterFinish', 'disablePageScrollWhenModalOpen', 'animateOpenClose', 'onRequestCloseModal', 'browserBackButtonClose'];

function addDashboardPlugin(uppy, opts, overrideOpts) {
  var dashboardOpts = {};
  dashboardOptionNames.forEach(function (key) {
    if (has(opts, key)) {
      dashboardOpts[key] = opts[key];
    }
  });
  var inline = overrideOpts.inline == null ? dashboardOpts.inline : overrideOpts.inline;

  if (!inline) {
    modalDashboardOptionNames.forEach(function (key) {
      if (has(opts, key)) {
        dashboardOpts[key] = opts[key];
      }
    });
  }

  uppy.use(Dashboard, _extends({}, dashboardOpts, overrideOpts));
}

module.exports = addDashboardPlugin;

},{"./../../dashboard":94,"./../../utils/lib/hasProperty":234}],151:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var Transloadit = require('./../../transloadit');

var has = require('./../../utils/lib/hasProperty');

var remoteProviders = {
  dropbox: require('./../../dropbox'),
  'google-drive': require('./../../google-drive'),
  instagram: require('./../../instagram'),
  facebook: require('./../../facebook'),
  onedrive: require('./../../onedrive'),
  url: require('./../../url')
};
var localProviders = {
  webcam: require('./../../webcam')
};
var remoteProviderOptionNames = ['companionUrl', 'companionAllowedHosts', 'companionHeaders', 'serverHeaders', 'target']; // No shared options.

var localProviderOptionNames = ['target'];

function addRemoteProvider(uppy, name, opts) {
  var Provider = remoteProviders[name];
  var providerOptions = {
    // Default to the :tl: Companion servers.
    companionUrl: Transloadit.COMPANION,
    companionAllowedHosts: Transloadit.COMPANION_PATTERN
  };
  remoteProviderOptionNames.forEach(function (name) {
    if (has(opts, name)) providerOptions[name] = opts[name];
  }); // Apply overrides for a specific provider plugin.

  if (typeof opts[name] === 'object') {
    _extends(providerOptions, opts[name]);
  }

  uppy.use(Provider, providerOptions);
}

function addLocalProvider(uppy, name, opts) {
  var Provider = localProviders[name];
  var providerOptions = {};
  localProviderOptionNames.forEach(function (name) {
    if (has(opts, name)) providerOptions[name] = opts[name];
  }); // Apply overrides for a specific provider plugin.

  if (typeof opts[name] === 'object') {
    _extends(providerOptions, opts[name]);
  }

  uppy.use(Provider, providerOptions);
}

function addProviders(uppy, names, opts) {
  if (opts === void 0) {
    opts = {};
  }

  names.forEach(function (name) {
    if (has(remoteProviders, name)) {
      addRemoteProvider(uppy, name, opts);
    } else if (has(localProviders, name)) {
      addLocalProvider(uppy, name, opts);
    } else {
      var validNames = [].concat(Object.keys(remoteProviders), Object.keys(localProviders));
      var expectedNameString = validNames.sort().map(function (validName) {
        return "'" + validName + "'";
      }).join(', ');
      throw new Error("Unexpected provider '" + name + "', expected one of [" + expectedNameString + "]");
    }
  });
}

module.exports = addProviders;

},{"./../../dropbox":103,"./../../facebook":106,"./../../google-drive":112,"./../../instagram":118,"./../../onedrive":121,"./../../transloadit":198,"./../../url":206,"./../../utils/lib/hasProperty":234,"./../../webcam":259}],152:[function(require,module,exports){
var Transloadit = require('./../../transloadit');

var has = require('./../../utils/lib/hasProperty');

var TransloaditResults = require('./TransloaditResultsPlugin');

var transloaditOptionNames = ['service', 'waitForEncoding', 'waitForMetadata', 'alwaysRunAssembly', 'importFromUploadURLs', 'signature', 'params', 'fields', 'limit', 'locale', 'getAssemblyOptions'];

function addTransloaditPlugin(uppy, opts) {
  var transloaditOptions = {};
  transloaditOptionNames.forEach(function (name) {
    if (has(opts, name)) transloaditOptions[name] = opts[name];
  });
  uppy.use(Transloadit, transloaditOptions); // Adds a `results` key to the upload result data containing a flat array of all results from all Assemblies.

  if (transloaditOptions.waitForEncoding) {
    uppy.use(TransloaditResults);
  }
}

module.exports = addTransloaditPlugin;

},{"./../../transloadit":198,"./../../utils/lib/hasProperty":234,"./TransloaditResultsPlugin":149}],153:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var Uppy = require('./../../core');

var has = require('./../../utils/lib/hasProperty');

var eventNames = {
  // File management events
  onFileAdded: 'file-added',
  onFileRemoved: 'file-removed',
  // Transloadit events
  onImportError: 'transloadit:import-error',
  onAssemblyCreated: 'transloadit:assembly-created',
  onAssemblyExecuting: 'transloadit:assembly-executing',
  onAssemblyError: 'transloadit:assembly-error',
  onAssemblyComplete: 'transloadit:complete',
  onResult: 'transloadit:result',
  // Upload events
  onStart: 'upload',
  onPause: 'pause-all',
  onFilePause: 'upload-pause',
  onCancel: 'cancel-all',
  onError: 'error',
  // mostly akin to promise rejection
  onFileCancel: 'upload-cancel',
  onFileProgress: 'upload-progress',
  onFileError: 'upload-error',
  onUploaded: 'transloadit:upload',
  onComplete: 'complete' // mostly akin to promise resolution

};
var uppyOptionNames = ['autoProceed', 'restrictions', 'meta', 'onBeforeFileAdded', 'onBeforeUpload', 'debug'];

function createUppy(opts, overrides) {
  if (overrides === void 0) {
    overrides = {};
  }

  var uppyOptions = {};
  uppyOptionNames.forEach(function (name) {
    if (has(opts, name)) uppyOptions[name] = opts[name];
  });

  _extends(uppyOptions, overrides);

  var uppy = new Uppy(uppyOptions); // Builtin event aliases

  Object.keys(eventNames).forEach(function (optionName) {
    var eventName = eventNames[optionName];

    if (typeof opts[optionName] === 'function') {
      uppy.on(eventName, opts[optionName]);
    }
  }); // Custom events (these should probably be added to core)

  if (typeof opts.onProgress === 'function') {
    uppy.on('upload-progress', function () {
      var _uppy$getState = uppy.getState(),
          totalProgress = _uppy$getState.totalProgress;

      opts.onProgress.call(uppy, totalProgress);
    });
  }

  return uppy;
}

module.exports = createUppy;

},{"./../../core":73,"./../../utils/lib/hasProperty":234}],154:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var createUppy = require('./createUppy');

var addDashboardPlugin = require('./addDashboardPlugin');

var addTransloaditPlugin = require('./addTransloaditPlugin');

var addProviders = require('./addProviders');

function dashboard(target, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var inline = opts.inline == null ? true : opts.inline;
  var pluginId = 'Dashboard';
  var uppy = createUppy(opts);
  addTransloaditPlugin(uppy, opts);
  addDashboardPlugin(uppy, opts, {
    id: pluginId,
    inline: inline,
    target: target,
    closeAfterFinish: false
  });

  if (Array.isArray(opts.providers)) {
    addProviders(uppy, opts.providers, _extends({}, opts, {
      // Install providers into the Dashboard.
      target: uppy.getPlugin(pluginId)
    }));
  }

  return uppy;
}

module.exports = dashboard;

},{"./addDashboardPlugin":150,"./addProviders":151,"./addTransloaditPlugin":152,"./createUppy":153}],155:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var Uppy = require('./../../core');

var Form = require('./../../form');

var StatusBar = require('./../../status-bar');

var findDOMElement = require('./../../utils/lib/findDOMElement');

var has = require('./../../utils/lib/hasProperty');

var AttachFileInputs = require('./AttachFileInputs');

var TransloaditFormResult = require('./TransloaditFormResult');

var addDashboardPlugin = require('./addDashboardPlugin');

var addTransloaditPlugin = require('./addTransloaditPlugin');

var addProviders = require('./addProviders');

var defaultLocaleStrings = {
  chooseFiles: 'Choose files'
};

function mergeDefaultLocale(defaults, userProvided) {
  if (userProvided === void 0) {
    userProvided = {};
  }

  var strings = userProvided.strings || {};
  return _extends({}, userProvided, {
    strings: _extends({}, defaults, strings)
  });
}

function form(target, opts) {
  if (!opts) throw new TypeError('robodog.form: must provide an options object');
  opts = _extends({}, opts, {
    locale: mergeDefaultLocale(defaultLocaleStrings, opts.locale)
  });
  var uppy = new Uppy(opts);
  addTransloaditPlugin(uppy, opts);
  uppy.use(TransloaditFormResult, {
    target: target,
    transloaditPluginId: 'Transloadit',
    name: 'transloadit'
  });
  var submitOnSuccess = true;

  if (has(opts, 'submitOnSuccess')) {
    submitOnSuccess = !!opts.submitOnSuccess;
  }

  var formOptions = {
    target: target,
    triggerUploadOnSubmit: true,
    submitOnSuccess: submitOnSuccess,
    addResultToForm: false // using custom implementation instead

  };

  if (has(opts, 'triggerUploadOnSubmit')) {
    formOptions.triggerUploadOnSubmit = opts.triggerUploadOnSubmit;
  }

  uppy.use(Form, formOptions);
  var useDashboard = opts.dashboard || opts.modal;

  if (useDashboard) {
    var dashboardTarget = findDOMElement(opts.dashboard) || document.body;
    var dashboardId = 'form:Dashboard';
    var dashboardOpts = {
      id: dashboardId,
      target: dashboardTarget
    };

    if (opts.modal) {
      var trigger = 'input[type="file"]';
      var button = document.createElement('button');
      button.textContent = uppy.i18n('chooseFiles');
      button.type = 'button';
      var old = findDOMElement(trigger, findDOMElement(target));
      old.parentNode.replaceChild(button, old);
      dashboardOpts.inline = false;
      dashboardOpts.trigger = button;
    } else {
      dashboardOpts.inline = true;
      dashboardOpts.hideUploadButton = true;
    }

    addDashboardPlugin(uppy, opts, dashboardOpts);

    if (Array.isArray(opts.providers)) {
      addProviders(uppy, opts.providers, _extends({}, opts, {
        target: uppy.getPlugin(dashboardId)
      }));
    }
  } else {
    uppy.use(AttachFileInputs, {
      target: target
    });
  }

  if (opts.statusBar) {
    uppy.use(StatusBar, {
      target: opts.statusBar,
      // hide most of the things to keep our api simple,
      // we can change this in the future if someone needs it
      hideUploadButton: true,
      hideAfterFinish: true,
      hideRetryButton: true,
      hidePauseResumeButtons: true,
      hideCancelButtons: true
    });
  }

  return uppy;
}

module.exports = form;

},{"./../../core":73,"./../../form":108,"./../../status-bar":163,"./../../utils/lib/findDOMElement":218,"./../../utils/lib/hasProperty":234,"./AttachFileInputs":147,"./TransloaditFormResult":148,"./addDashboardPlugin":150,"./addProviders":151,"./addTransloaditPlugin":152}],156:[function(require,module,exports){
var form = require('./form');

var dashboard = require('./dashboard');

var pick = require('./pick');

var upload = require('./upload');

module.exports = {
  dashboard: dashboard,
  form: form,
  pick: pick,
  upload: upload,
  VERSION: require('../package.json').version
};

},{"../package.json":146,"./dashboard":154,"./form":155,"./pick":157,"./upload":158}],157:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var createUppy = require('./createUppy');

var addDashboardPlugin = require('./addDashboardPlugin');

var addTransloaditPlugin = require('./addTransloaditPlugin');

var addProviders = require('./addProviders');

var CANCEL = {};

function pick(opts) {
  if (opts === void 0) {
    opts = {};
  }

  var target = opts.target || document.body;
  var pluginId = 'pick';
  var uppy = createUppy(opts, {
    allowMultipleUploads: false
  });
  addTransloaditPlugin(uppy, opts);
  addDashboardPlugin(uppy, opts, {
    id: pluginId,
    target: target,
    closeAfterFinish: true
  });

  if (Array.isArray(opts.providers)) {
    addProviders(uppy, opts.providers, _extends({}, opts, {
      // Install providers into the Dashboard.
      target: uppy.getPlugin(pluginId)
    }));
  }

  return new Promise(function (resolve, reject) {
    uppy.on('complete', function (result) {
      if (result.failed.length === 0) {
        resolve(result);
      }
    });
    uppy.on('error', reject);
    uppy.on('cancel-all', function () {
      return reject(CANCEL);
    });
    uppy.getPlugin(pluginId).openModal();
  }).then(function (result) {
    return result;
  }, function (err) {
    if (err === CANCEL) {
      uppy.getPlugin(pluginId).requestCloseModal();
      return null;
    }

    throw err;
  });
}

module.exports = pick;

},{"./addDashboardPlugin":150,"./addProviders":151,"./addTransloaditPlugin":152,"./createUppy":153}],158:[function(require,module,exports){
var toArray = require('./../../utils/lib/toArray');

var createUppy = require('./createUppy');

var addTransloaditPlugin = require('./addTransloaditPlugin');

function upload(files, opts) {
  if (opts === void 0) {
    opts = {};
  }

  if (!Array.isArray(files) && typeof files.length === 'number') {
    files = toArray(files);
  }

  var uppy = createUppy(opts, {
    allowMultipleUploads: false
  });
  addTransloaditPlugin(uppy, opts);
  files.forEach(function (file) {
    uppy.addFile({
      data: file,
      type: file.type,
      name: file.name,
      meta: file.meta || {}
    });
  });
  return uppy.upload();
}

module.exports = upload;

},{"./../../utils/lib/toArray":245,"./addTransloaditPlugin":152,"./createUppy":153}],159:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],160:[function(require,module,exports){
module.exports={
  "name": "@uppy/status-bar",
  "description": "A progress bar for Uppy, with many bells and whistles.",
  "version": "1.9.6",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "progress bar",
    "status bar",
    "progress",
    "upload",
    "eta",
    "speed"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@transloadit/prettier-bytes": "0.0.7",
    "@uppy/utils": "file:../utils",
    "classnames": "^2.2.6",
    "lodash.throttle": "^4.1.1",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],161:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var throttle = require('lodash.throttle');

var classNames = require('classnames');

var statusBarStates = require('./StatusBarStates');

var prettierBytes = require('@transloadit/prettier-bytes');

var prettyETA = require('./../../utils/lib/prettyETA');

var _require = require('preact'),
    h = _require.h;

function calculateProcessingProgress(files) {
  // Collect pre or postprocessing progress states.
  var progresses = [];
  Object.keys(files).forEach(function (fileID) {
    var progress = files[fileID].progress;

    if (progress.preprocess) {
      progresses.push(progress.preprocess);
    }

    if (progress.postprocess) {
      progresses.push(progress.postprocess);
    }
  }); // In the future we should probably do this differently. For now we'll take the
  // mode and message from the first file

  var _progresses$ = progresses[0],
      mode = _progresses$.mode,
      message = _progresses$.message;
  var value = progresses.filter(isDeterminate).reduce(function (total, progress, index, all) {
    return total + progress.value / all.length;
  }, 0);

  function isDeterminate(progress) {
    return progress.mode === 'determinate';
  }

  return {
    mode: mode,
    message: message,
    value: value
  };
}

function togglePauseResume(props) {
  if (props.isAllComplete) return;

  if (!props.resumableUploads) {
    return props.cancelAll();
  }

  if (props.isAllPaused) {
    return props.resumeAll();
  }

  return props.pauseAll();
}

function RenderReSelectGhosts(_ref) {
  var i18n = _ref.i18n;
  return h("div", {
    className: "uppy-StatusBar-serviceMsg"
  }, i18n('reSelectGhosts'), h("svg", {
    className: "uppy-c-icon uppy-StatusBar-serviceMsg-ghostsIcon",
    "aria-hidden": "true",
    width: "15",
    height: "19",
    viewBox: "0 0 35 39"
  }, h("path", {
    d: "M1.708 38.66c1.709 0 3.417-3.417 6.834-3.417 3.416 0 5.125 3.417 8.61 3.417 3.348 0 5.056-3.417 8.473-3.417 4.305 0 5.125 3.417 6.833 3.417.889 0 1.709-.889 1.709-1.709v-19.68C34.167-5.757 0-5.757 0 17.271v19.68c0 .82.888 1.709 1.708 1.709zm8.542-17.084a3.383 3.383 0 01-3.417-3.416 3.383 3.383 0 013.417-3.417 3.383 3.383 0 013.417 3.417 3.383 3.383 0 01-3.417 3.416zm13.667 0A3.383 3.383 0 0120.5 18.16a3.383 3.383 0 013.417-3.417 3.383 3.383 0 013.416 3.417 3.383 3.383 0 01-3.416 3.416z",
    fillRule: "nonzero"
  })));
}

module.exports = function (props) {
  props = props || {};
  var _props = props,
      newFiles = _props.newFiles,
      allowNewUpload = _props.allowNewUpload,
      isUploadInProgress = _props.isUploadInProgress,
      isAllPaused = _props.isAllPaused,
      resumableUploads = _props.resumableUploads,
      error = _props.error,
      hideUploadButton = _props.hideUploadButton,
      hidePauseResumeButton = _props.hidePauseResumeButton,
      hideCancelButton = _props.hideCancelButton,
      hideRetryButton = _props.hideRetryButton,
      recoveredState = _props.recoveredState;
  var uploadState = props.uploadState;
  var progressValue = props.totalProgress;
  var progressMode;
  var progressBarContent;

  if (uploadState === statusBarStates.STATE_PREPROCESSING || uploadState === statusBarStates.STATE_POSTPROCESSING) {
    var progress = calculateProcessingProgress(props.files);
    progressMode = progress.mode;

    if (progressMode === 'determinate') {
      progressValue = progress.value * 100;
    }

    progressBarContent = ProgressBarProcessing(progress);
  } else if (uploadState === statusBarStates.STATE_COMPLETE) {
    progressBarContent = ProgressBarComplete(props);
  } else if (uploadState === statusBarStates.STATE_UPLOADING) {
    if (!props.supportsUploadProgress) {
      progressMode = 'indeterminate';
      progressValue = null;
    }

    progressBarContent = ProgressBarUploading(props);
  } else if (uploadState === statusBarStates.STATE_ERROR) {
    progressValue = undefined;
    progressBarContent = ProgressBarError(props);
  }

  var width = typeof progressValue === 'number' ? progressValue : 100;
  var isHidden = uploadState === statusBarStates.STATE_WAITING && props.hideUploadButton || uploadState === statusBarStates.STATE_WAITING && !props.newFiles > 0 || uploadState === statusBarStates.STATE_COMPLETE && props.hideAfterFinish;
  var showUploadBtn = !error && newFiles && !isUploadInProgress && !isAllPaused && allowNewUpload && !hideUploadButton;

  if (recoveredState) {
    isHidden = false;
    showUploadBtn = true;
  }

  var showCancelBtn = !hideCancelButton && uploadState !== statusBarStates.STATE_WAITING && uploadState !== statusBarStates.STATE_COMPLETE;
  var showPauseResumeBtn = resumableUploads && !hidePauseResumeButton && uploadState === statusBarStates.STATE_UPLOADING;
  var showRetryBtn = error && !hideRetryButton;
  var showDoneBtn = props.doneButtonHandler && uploadState === statusBarStates.STATE_COMPLETE;
  var progressClassNames = "uppy-StatusBar-progress\n                           " + (progressMode ? "is-" + progressMode : '');
  var statusBarClassNames = classNames({
    'uppy-Root': props.isTargetDOMEl
  }, 'uppy-StatusBar', "is-" + uploadState, {
    'has-ghosts': props.isSomeGhost
  });
  return h("div", {
    className: statusBarClassNames,
    "aria-hidden": isHidden
  }, h("div", {
    className: progressClassNames,
    style: {
      width: width + "%"
    },
    role: "progressbar",
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    "aria-valuenow": progressValue
  }), progressBarContent, h("div", {
    className: "uppy-StatusBar-actions"
  }, showUploadBtn ? h(UploadBtn, _extends({}, props, {
    uploadState: uploadState
  })) : null, showRetryBtn ? h(RetryBtn, props) : null, showPauseResumeBtn ? h(PauseResumeButton, props) : null, showCancelBtn ? h(CancelBtn, props) : null, showDoneBtn ? h(DoneBtn, props) : null));
};

var UploadBtn = function UploadBtn(props) {
  var uploadBtnClassNames = classNames('uppy-u-reset', 'uppy-c-btn', 'uppy-StatusBar-actionBtn', 'uppy-StatusBar-actionBtn--upload', {
    'uppy-c-btn-primary': props.uploadState === statusBarStates.STATE_WAITING
  }, {
    'uppy-StatusBar-actionBtn--disabled': props.isSomeGhost
  });
  var uploadBtnText = props.newFiles && props.isUploadStarted && !props.recoveredState ? props.i18n('uploadXNewFiles', {
    smart_count: props.newFiles
  }) : props.i18n('uploadXFiles', {
    smart_count: props.newFiles
  });
  return h("button", {
    type: "button",
    className: uploadBtnClassNames,
    "aria-label": props.i18n('uploadXFiles', {
      smart_count: props.newFiles
    }),
    onClick: props.startUpload,
    disabled: props.isSomeGhost,
    "data-uppy-super-focusable": true
  }, uploadBtnText);
};

var RetryBtn = function RetryBtn(props) {
  return h("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--retry",
    "aria-label": props.i18n('retryUpload'),
    onClick: props.retryAll,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "8",
    height: "10",
    viewBox: "0 0 8 10"
  }, h("path", {
    d: "M4 2.408a2.75 2.75 0 1 0 2.75 2.75.626.626 0 0 1 1.25.018v.023a4 4 0 1 1-4-4.041V.25a.25.25 0 0 1 .389-.208l2.299 1.533a.25.25 0 0 1 0 .416l-2.3 1.533A.25.25 0 0 1 4 3.316v-.908z"
  })), props.i18n('retry'));
};

var CancelBtn = function CancelBtn(props) {
  return h("button", {
    type: "button",
    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    title: props.i18n('cancel'),
    "aria-label": props.i18n('cancel'),
    onClick: props.cancelAll,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    fill: "#FFF",
    d: "M9.283 8l2.567 2.567-1.283 1.283L8 9.283 5.433 11.85 4.15 10.567 6.717 8 4.15 5.433 5.433 4.15 8 6.717l2.567-2.567 1.283 1.283z"
  }))));
};

var PauseResumeButton = function PauseResumeButton(props) {
  var isAllPaused = props.isAllPaused,
      i18n = props.i18n;
  var title = isAllPaused ? i18n('resume') : i18n('pause');
  return h("button", {
    title: title,
    "aria-label": title,
    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    type: "button",
    onClick: function onClick() {
      return togglePauseResume(props);
    },
    "data-uppy-super-focusable": true
  }, isAllPaused ? h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    fill: "#FFF",
    d: "M6 4.25L11.5 8 6 11.75z"
  }))) : h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    d: "M5 4.5h2v7H5v-7zm4 0h2v7H9v-7z",
    fill: "#FFF"
  }))));
};

var DoneBtn = function DoneBtn(props) {
  var i18n = props.i18n;
  return h("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--done",
    onClick: props.doneButtonHandler,
    "data-uppy-super-focusable": true
  }, i18n('done'));
};

var LoadingSpinner = function LoadingSpinner() {
  return h("svg", {
    className: "uppy-StatusBar-spinner",
    "aria-hidden": "true",
    focusable: "false",
    width: "14",
    height: "14"
  }, h("path", {
    d: "M13.983 6.547c-.12-2.509-1.64-4.893-3.939-5.936-2.48-1.127-5.488-.656-7.556 1.094C.524 3.367-.398 6.048.162 8.562c.556 2.495 2.46 4.52 4.94 5.183 2.932.784 5.61-.602 7.256-3.015-1.493 1.993-3.745 3.309-6.298 2.868-2.514-.434-4.578-2.349-5.153-4.84a6.226 6.226 0 0 1 2.98-6.778C6.34.586 9.74 1.1 11.373 3.493c.407.596.693 1.282.842 1.988.127.598.073 1.197.161 1.794.078.525.543 1.257 1.15.864.525-.341.49-1.05.456-1.592-.007-.15.02.3 0 0",
    fillRule: "evenodd"
  }));
};

var ProgressBarProcessing = function ProgressBarProcessing(props) {
  var value = Math.round(props.value * 100);
  return h("div", {
    className: "uppy-StatusBar-content"
  }, h(LoadingSpinner, null), props.mode === 'determinate' ? value + "% \xB7 " : '', props.message);
};

var renderDot = function renderDot() {
  return " \xB7 ";
};

var ProgressDetails = function ProgressDetails(props) {
  var ifShowFilesUploadedOfTotal = props.numUploads > 1;
  return h("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, ifShowFilesUploadedOfTotal && props.i18n('filesUploadedOfTotal', {
    complete: props.complete,
    smart_count: props.numUploads
  }), h("span", {
    className: "uppy-StatusBar-additionalInfo"
  }, ifShowFilesUploadedOfTotal && renderDot(), props.i18n('dataUploadedOfTotal', {
    complete: prettierBytes(props.totalUploadedSize),
    total: prettierBytes(props.totalSize)
  }), renderDot(), props.i18n('xTimeLeft', {
    time: prettyETA(props.totalETA)
  })));
};

var UnknownProgressDetails = function UnknownProgressDetails(props) {
  return h("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, props.i18n('filesUploadedOfTotal', {
    complete: props.complete,
    smart_count: props.numUploads
  }));
};

var UploadNewlyAddedFiles = function UploadNewlyAddedFiles(props) {
  var uploadBtnClassNames = classNames('uppy-u-reset', 'uppy-c-btn', 'uppy-StatusBar-actionBtn', 'uppy-StatusBar-actionBtn--uploadNewlyAdded');
  return h("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, h("div", {
    className: "uppy-StatusBar-statusSecondaryHint"
  }, props.i18n('xMoreFilesAdded', {
    smart_count: props.newFiles
  })), h("button", {
    type: "button",
    className: uploadBtnClassNames,
    "aria-label": props.i18n('uploadXFiles', {
      smart_count: props.newFiles
    }),
    onClick: props.startUpload
  }, props.i18n('upload')));
};

var ThrottledProgressDetails = throttle(ProgressDetails, 500, {
  leading: true,
  trailing: true
});

var ProgressBarUploading = function ProgressBarUploading(props) {
  if (!props.isUploadStarted || props.isAllComplete) {
    return null;
  }

  var title = props.isAllPaused ? props.i18n('paused') : props.i18n('uploading');
  var showUploadNewlyAddedFiles = props.newFiles && props.isUploadStarted;
  return h("div", {
    className: "uppy-StatusBar-content",
    "aria-label": title,
    title: title
  }, !props.isAllPaused ? h(LoadingSpinner, null) : null, h("div", {
    className: "uppy-StatusBar-status"
  }, h("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, props.supportsUploadProgress ? title + ": " + props.totalProgress + "%" : title), !props.isAllPaused && !showUploadNewlyAddedFiles && props.showProgressDetails ? props.supportsUploadProgress ? h(ThrottledProgressDetails, props) : h(UnknownProgressDetails, props) : null, showUploadNewlyAddedFiles ? h(UploadNewlyAddedFiles, props) : null));
};

var ProgressBarComplete = function ProgressBarComplete(_ref2) {
  var totalProgress = _ref2.totalProgress,
      i18n = _ref2.i18n;
  return h("div", {
    className: "uppy-StatusBar-content",
    role: "status",
    title: i18n('complete')
  }, h("div", {
    className: "uppy-StatusBar-status"
  }, h("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
    width: "15",
    height: "11",
    viewBox: "0 0 15 11"
  }, h("path", {
    d: "M.414 5.843L1.627 4.63l3.472 3.472L13.202 0l1.212 1.213L5.1 10.528z"
  })), i18n('complete'))));
};

var ProgressBarError = function ProgressBarError(_ref3) {
  var error = _ref3.error,
      retryAll = _ref3.retryAll,
      hideRetryButton = _ref3.hideRetryButton,
      i18n = _ref3.i18n;

  function displayErrorAlert() {
    var errorMessage = i18n('uploadFailed') + " \n\n " + error;
    alert(errorMessage);
  }

  return h("div", {
    className: "uppy-StatusBar-content",
    role: "alert",
    title: i18n('uploadFailed')
  }, h("div", {
    className: "uppy-StatusBar-status"
  }, h("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
    width: "11",
    height: "11",
    viewBox: "0 0 11 11"
  }, h("path", {
    d: "M4.278 5.5L0 1.222 1.222 0 5.5 4.278 9.778 0 11 1.222 6.722 5.5 11 9.778 9.778 11 5.5 6.722 1.222 11 0 9.778z"
  })), i18n('uploadFailed'))), h("span", {
    className: "uppy-StatusBar-details",
    "aria-label": error,
    "data-microtip-position": "top-right",
    "data-microtip-size": "medium",
    role: "tooltip",
    onClick: displayErrorAlert
  }, "?"));
};

},{"./../../utils/lib/prettyETA":241,"./StatusBarStates":162,"@transloadit/prettier-bytes":1,"classnames":10,"lodash.throttle":32,"preact":159}],162:[function(require,module,exports){
module.exports = {
  STATE_ERROR: 'error',
  STATE_WAITING: 'waiting',
  STATE_PREPROCESSING: 'preprocessing',
  STATE_UPLOADING: 'uploading',
  STATE_POSTPROCESSING: 'postprocessing',
  STATE_COMPLETE: 'complete'
};

},{}],163:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Translator = require('./../../utils/lib/Translator');

var StatusBarUI = require('./StatusBar');

var statusBarStates = require('./StatusBarStates');

var getSpeed = require('./../../utils/lib/getSpeed');

var getBytesRemaining = require('./../../utils/lib/getBytesRemaining');

var getTextDirection = require('./../../utils/lib/getTextDirection');
/**
 * StatusBar: renders a status bar with upload/pause/resume/cancel/retry buttons,
 * progress percentage and time remaining.
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(StatusBar, _Plugin);

  function StatusBar(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.startUpload = function () {
      var _this$uppy$getState = _this.uppy.getState(),
          recoveredState = _this$uppy$getState.recoveredState;

      if (recoveredState) {
        _this.uppy.emit('restore-confirmed');

        return;
      }

      return _this.uppy.upload().catch(function () {// Error logged in Core
      });
    };

    _this.id = _this.opts.id || 'StatusBar';
    _this.title = 'StatusBar';
    _this.type = 'progressindicator';
    _this.defaultLocale = {
      strings: {
        uploading: 'Uploading',
        upload: 'Upload',
        complete: 'Complete',
        uploadFailed: 'Upload failed',
        paused: 'Paused',
        retry: 'Retry',
        retryUpload: 'Retry upload',
        cancel: 'Cancel',
        pause: 'Pause',
        resume: 'Resume',
        done: 'Done',
        filesUploadedOfTotal: {
          0: '%{complete} of %{smart_count} file uploaded',
          1: '%{complete} of %{smart_count} files uploaded'
        },
        dataUploadedOfTotal: '%{complete} of %{total}',
        xTimeLeft: '%{time} left',
        uploadXFiles: {
          0: 'Upload %{smart_count} file',
          1: 'Upload %{smart_count} files'
        },
        uploadXNewFiles: {
          0: 'Upload +%{smart_count} file',
          1: 'Upload +%{smart_count} files'
        },
        xMoreFilesAdded: {
          0: '%{smart_count} more file added',
          1: '%{smart_count} more files added'
        }
      }
    }; // set default options

    var defaultOptions = {
      target: 'body',
      hideUploadButton: false,
      hideRetryButton: false,
      hidePauseResumeButton: false,
      hideCancelButton: false,
      showProgressDetails: false,
      hideAfterFinish: true,
      doneButtonHandler: null
    };
    _this.opts = _extends({}, defaultOptions, opts);

    _this.i18nInit();

    _this.render = _this.render.bind(_assertThisInitialized(_this));
    _this.install = _this.install.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = StatusBar.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.getTotalSpeed = function getTotalSpeed(files) {
    var totalSpeed = 0;
    files.forEach(function (file) {
      totalSpeed += getSpeed(file.progress);
    });
    return totalSpeed;
  };

  _proto.getTotalETA = function getTotalETA(files) {
    var totalSpeed = this.getTotalSpeed(files);

    if (totalSpeed === 0) {
      return 0;
    }

    var totalBytesRemaining = files.reduce(function (total, file) {
      return total + getBytesRemaining(file.progress);
    }, 0);
    return Math.round(totalBytesRemaining / totalSpeed * 10) / 10;
  };

  _proto.getUploadingState = function getUploadingState(isAllErrored, isAllComplete, recoveredState, files) {
    if (isAllErrored) {
      return statusBarStates.STATE_ERROR;
    }

    if (isAllComplete) {
      return statusBarStates.STATE_COMPLETE;
    }

    if (recoveredState) {
      return statusBarStates.STATE_WAITING;
    }

    var state = statusBarStates.STATE_WAITING;
    var fileIDs = Object.keys(files);

    for (var i = 0; i < fileIDs.length; i++) {
      var progress = files[fileIDs[i]].progress; // If ANY files are being uploaded right now, show the uploading state.

      if (progress.uploadStarted && !progress.uploadComplete) {
        return statusBarStates.STATE_UPLOADING;
      } // If files are being preprocessed AND postprocessed at this time, we show the
      // preprocess state. If any files are being uploaded we show uploading.


      if (progress.preprocess && state !== statusBarStates.STATE_UPLOADING) {
        state = statusBarStates.STATE_PREPROCESSING;
      } // If NO files are being preprocessed or uploaded right now, but some files are
      // being postprocessed, show the postprocess state.


      if (progress.postprocess && state !== statusBarStates.STATE_UPLOADING && state !== statusBarStates.STATE_PREPROCESSING) {
        state = statusBarStates.STATE_POSTPROCESSING;
      }
    }

    return state;
  };

  _proto.render = function render(state) {
    var capabilities = state.capabilities,
        files = state.files,
        allowNewUpload = state.allowNewUpload,
        totalProgress = state.totalProgress,
        error = state.error,
        recoveredState = state.recoveredState; // TODO: move this to Core, to share between Status Bar and Dashboard
    // (and any other plugin that might need it, too)

    var filesArray = Object.keys(files).map(function (file) {
      return files[file];
    });
    var newFiles = filesArray.filter(function (file) {
      return !file.progress.uploadStarted && !file.progress.preprocess && !file.progress.postprocess;
    }); // If some state was recovered, we want to show Upload button/counter
    // for all the files, because in this case its not an Upload button,
    // but Confirm Restore Button

    if (recoveredState) {
      newFiles = filesArray;
    }

    var uploadStartedFiles = filesArray.filter(function (file) {
      return file.progress.uploadStarted;
    });
    var pausedFiles = uploadStartedFiles.filter(function (file) {
      return file.isPaused;
    });
    var completeFiles = filesArray.filter(function (file) {
      return file.progress.uploadComplete;
    });
    var erroredFiles = filesArray.filter(function (file) {
      return file.error;
    });
    var inProgressFiles = filesArray.filter(function (file) {
      return !file.progress.uploadComplete && file.progress.uploadStarted;
    });
    var inProgressNotPausedFiles = inProgressFiles.filter(function (file) {
      return !file.isPaused;
    });
    var startedFiles = filesArray.filter(function (file) {
      return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;
    });
    var processingFiles = filesArray.filter(function (file) {
      return file.progress.preprocess || file.progress.postprocess;
    });
    var totalETA = this.getTotalETA(inProgressNotPausedFiles);
    var totalSize = 0;
    var totalUploadedSize = 0;
    startedFiles.forEach(function (file) {
      totalSize += file.progress.bytesTotal || 0;
      totalUploadedSize += file.progress.bytesUploaded || 0;
    });
    var isUploadStarted = startedFiles.length > 0;
    var isAllComplete = totalProgress === 100 && completeFiles.length === Object.keys(files).length && processingFiles.length === 0;
    var isAllErrored = error && erroredFiles.length === filesArray.length;
    var isAllPaused = inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length;
    var isUploadInProgress = inProgressFiles.length > 0;
    var resumableUploads = capabilities.resumableUploads || false;
    var supportsUploadProgress = capabilities.uploadProgress !== false;
    var isSomeGhost = filesArray.some(function (file) {
      return file.isGhost;
    });
    return StatusBarUI({
      error: error,
      uploadState: this.getUploadingState(isAllErrored, isAllComplete, recoveredState, state.files || {}),
      allowNewUpload: allowNewUpload,
      totalProgress: totalProgress,
      totalSize: totalSize,
      totalUploadedSize: totalUploadedSize,
      isAllComplete: isAllComplete,
      isAllPaused: isAllPaused,
      isAllErrored: isAllErrored,
      isUploadStarted: isUploadStarted,
      isUploadInProgress: isUploadInProgress,
      isSomeGhost: isSomeGhost,
      recoveredState: recoveredState,
      complete: completeFiles.length,
      newFiles: newFiles.length,
      numUploads: startedFiles.length,
      totalETA: totalETA,
      files: files,
      i18n: this.i18n,
      pauseAll: this.uppy.pauseAll,
      resumeAll: this.uppy.resumeAll,
      retryAll: this.uppy.retryAll,
      cancelAll: this.uppy.cancelAll,
      startUpload: this.startUpload,
      doneButtonHandler: this.opts.doneButtonHandler,
      resumableUploads: resumableUploads,
      supportsUploadProgress: supportsUploadProgress,
      showProgressDetails: this.opts.showProgressDetails,
      hideUploadButton: this.opts.hideUploadButton,
      hideRetryButton: this.opts.hideRetryButton,
      hidePauseResumeButton: this.opts.hidePauseResumeButton,
      hideCancelButton: this.opts.hideCancelButton,
      hideAfterFinish: this.opts.hideAfterFinish,
      isTargetDOMEl: this.isTargetDOMEl
    });
  };

  _proto.onMount = function onMount() {
    // Set the text direction if the page has not defined one.
    var element = this.el;
    var direction = getTextDirection(element);

    if (!direction) {
      element.dir = 'ltr';
    }
  };

  _proto.install = function install() {
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.unmount();
  };

  return StatusBar;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":160,"./../../core":73,"./../../utils/lib/Translator":212,"./../../utils/lib/getBytesRemaining":221,"./../../utils/lib/getSpeed":231,"./../../utils/lib/getTextDirection":232,"./StatusBar":161,"./StatusBarStates":162}],164:[function(require,module,exports){
module.exports={
  "name": "@uppy/store-default",
  "description": "The default simple object-based store for Uppy.",
  "version": "1.2.7",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-store"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  }
}

},{}],165:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/**
 * Default store that keeps state in a simple object.
 */
var DefaultStore = /*#__PURE__*/function () {
  function DefaultStore() {
    this.state = {};
    this.callbacks = [];
  }

  var _proto = DefaultStore.prototype;

  _proto.getState = function getState() {
    return this.state;
  };

  _proto.setState = function setState(patch) {
    var prevState = _extends({}, this.state);

    var nextState = _extends({}, this.state, patch);

    this.state = nextState;

    this._publish(prevState, nextState, patch);
  };

  _proto.subscribe = function subscribe(listener) {
    var _this = this;

    this.callbacks.push(listener);
    return function () {
      // Remove the listener.
      _this.callbacks.splice(_this.callbacks.indexOf(listener), 1);
    };
  };

  _proto._publish = function _publish() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.callbacks.forEach(function (listener) {
      listener.apply(void 0, args);
    });
  };

  return DefaultStore;
}();

DefaultStore.VERSION = require('../package.json').version;

module.exports = function defaultStore() {
  return new DefaultStore();
};

},{"../package.json":164}],166:[function(require,module,exports){
module.exports={
  "name": "@uppy/thumbnail-generator",
  "description": "Uppy plugin that generates small previews of images to show on your upload UI.",
  "version": "1.7.11",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "thumbnail",
    "preview",
    "resize"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "exifr": "^6.0.0",
    "math-log2": "^1.0.1"
  },
  "devDependencies": {
    "namespace-emitter": "2.0.1"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],167:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Translator = require('./../../utils/lib/Translator');

var dataURItoBlob = require('./../../utils/lib/dataURItoBlob');

var isObjectURL = require('./../../utils/lib/isObjectURL');

var isPreviewSupported = require('./../../utils/lib/isPreviewSupported');

var MathLog2 = require('math-log2'); // Polyfill for IE.


var exifr = require('exifr/dist/mini.legacy.umd.js');
/**
 * The Thumbnail Generator plugin
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(ThumbnailGenerator, _Plugin);

  function ThumbnailGenerator(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.onFileAdded = function (file) {
      if (!file.preview && file.data && isPreviewSupported(file.type) && !file.isRemote) {
        _this.addToQueue(file.id);
      }
    };

    _this.onCancelRequest = function (file) {
      var index = _this.queue.indexOf(file.id);

      if (index !== -1) {
        _this.queue.splice(index, 1);
      }
    };

    _this.onFileRemoved = function (file) {
      var index = _this.queue.indexOf(file.id);

      if (index !== -1) {
        _this.queue.splice(index, 1);
      } // Clean up object URLs.


      if (file.preview && isObjectURL(file.preview)) {
        URL.revokeObjectURL(file.preview);
      }
    };

    _this.onRestored = function () {
      var restoredFiles = _this.uppy.getFiles().filter(function (file) {
        return file.isRestored;
      });

      restoredFiles.forEach(function (file) {
        // Only add blob URLs; they are likely invalid after being restored.
        if (!file.preview || isObjectURL(file.preview)) {
          _this.addToQueue(file.id);
        }
      });
    };

    _this.waitUntilAllProcessed = function (fileIDs) {
      fileIDs.forEach(function (fileID) {
        var file = _this.uppy.getFile(fileID);

        _this.uppy.emit('preprocess-progress', file, {
          mode: 'indeterminate',
          message: _this.i18n('generatingThumbnails')
        });
      });

      var emitPreprocessCompleteForAll = function emitPreprocessCompleteForAll() {
        fileIDs.forEach(function (fileID) {
          var file = _this.uppy.getFile(fileID);

          _this.uppy.emit('preprocess-complete', file);
        });
      };

      return new Promise(function (resolve, reject) {
        if (_this.queueProcessing) {
          _this.uppy.once('thumbnail:all-generated', function () {
            emitPreprocessCompleteForAll();
            resolve();
          });
        } else {
          emitPreprocessCompleteForAll();
          resolve();
        }
      });
    };

    _this.type = 'modifier';
    _this.id = _this.opts.id || 'ThumbnailGenerator';
    _this.title = 'Thumbnail Generator';
    _this.queue = [];
    _this.queueProcessing = false;
    _this.defaultThumbnailDimension = 200;
    _this.thumbnailType = _this.opts.thumbnailType || 'image/jpeg';
    _this.defaultLocale = {
      strings: {
        generatingThumbnails: 'Generating thumbnails...'
      }
    };
    var defaultOptions = {
      thumbnailWidth: null,
      thumbnailHeight: null,
      waitForThumbnailsBeforeUpload: false,
      lazy: false
    };
    _this.opts = _extends({}, defaultOptions, opts);

    if (_this.opts.lazy && _this.opts.waitForThumbnailsBeforeUpload) {
      throw new Error('ThumbnailGenerator: The `lazy` and `waitForThumbnailsBeforeUpload` options are mutually exclusive. Please ensure at most one of them is set to `true`.');
    }

    _this.i18nInit();

    return _this;
  }

  var _proto = ThumbnailGenerator.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  }
  /**
   * Create a thumbnail for the given Uppy file object.
   *
   * @param {{data: Blob}} file
   * @param {number} targetWidth
   * @param {number} targetHeight
   * @returns {Promise}
   */
  ;

  _proto.createThumbnail = function createThumbnail(file, targetWidth, targetHeight) {
    var _this2 = this;

    // bug in the compatibility data
    // eslint-disable-next-line compat/compat
    var originalUrl = URL.createObjectURL(file.data);
    var onload = new Promise(function (resolve, reject) {
      var image = new Image();
      image.src = originalUrl;
      image.addEventListener('load', function () {
        // bug in the compatibility data
        // eslint-disable-next-line compat/compat
        URL.revokeObjectURL(originalUrl);
        resolve(image);
      });
      image.addEventListener('error', function (event) {
        // bug in the compatibility data
        // eslint-disable-next-line compat/compat
        URL.revokeObjectURL(originalUrl);
        reject(event.error || new Error('Could not create thumbnail'));
      });
    });
    var orientationPromise = exifr.rotation(file.data).catch(function (_err) {
      return 1;
    });
    return Promise.all([onload, orientationPromise]).then(function (_ref) {
      var image = _ref[0],
          orientation = _ref[1];

      var dimensions = _this2.getProportionalDimensions(image, targetWidth, targetHeight, orientation.deg);

      var rotatedImage = _this2.rotateImage(image, orientation);

      var resizedImage = _this2.resizeImage(rotatedImage, dimensions.width, dimensions.height);

      return _this2.canvasToBlob(resizedImage, _this2.thumbnailType, 80);
    }).then(function (blob) {
      // bug in the compatibility data
      // eslint-disable-next-line compat/compat
      return URL.createObjectURL(blob);
    });
  }
  /**
   * Get the new calculated dimensions for the given image and a target width
   * or height. If both width and height are given, only width is taken into
   * account. If neither width nor height are given, the default dimension
   * is used.
   */
  ;

  _proto.getProportionalDimensions = function getProportionalDimensions(img, width, height, rotation) {
    var aspect = img.width / img.height;

    if (rotation === 90 || rotation === 270) {
      aspect = img.height / img.width;
    }

    if (width != null) {
      return {
        width: width,
        height: Math.round(width / aspect)
      };
    }

    if (height != null) {
      return {
        width: Math.round(height * aspect),
        height: height
      };
    }

    return {
      width: this.defaultThumbnailDimension,
      height: Math.round(this.defaultThumbnailDimension / aspect)
    };
  }
  /**
   * Make sure the image doesnt exceed browser/device canvas limits.
   * For ios with 256 RAM and ie
   */
  ;

  _proto.protect = function protect(image) {
    // https://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element
    var ratio = image.width / image.height;
    var maxSquare = 5000000; // ios max canvas square

    var maxSize = 4096; // ie max canvas dimensions

    var maxW = Math.floor(Math.sqrt(maxSquare * ratio));
    var maxH = Math.floor(maxSquare / Math.sqrt(maxSquare * ratio));

    if (maxW > maxSize) {
      maxW = maxSize;
      maxH = Math.round(maxW / ratio);
    }

    if (maxH > maxSize) {
      maxH = maxSize;
      maxW = Math.round(ratio * maxH);
    }

    if (image.width > maxW) {
      var canvas = document.createElement('canvas');
      canvas.width = maxW;
      canvas.height = maxH;
      canvas.getContext('2d').drawImage(image, 0, 0, maxW, maxH);
      image = canvas;
    }

    return image;
  }
  /**
   * Resize an image to the target `width` and `height`.
   *
   * Returns a Canvas with the resized image on it.
   */
  ;

  _proto.resizeImage = function resizeImage(image, targetWidth, targetHeight) {
    // Resizing in steps refactored to use a solution from
    // https://blog.uploadcare.com/image-resize-in-browsers-is-broken-e38eed08df01
    image = this.protect(image);
    var steps = Math.ceil(MathLog2(image.width / targetWidth));

    if (steps < 1) {
      steps = 1;
    }

    var sW = targetWidth * Math.pow(2, steps - 1);
    var sH = targetHeight * Math.pow(2, steps - 1);
    var x = 2;

    while (steps--) {
      var canvas = document.createElement('canvas');
      canvas.width = sW;
      canvas.height = sH;
      canvas.getContext('2d').drawImage(image, 0, 0, sW, sH);
      image = canvas;
      sW = Math.round(sW / x);
      sH = Math.round(sH / x);
    }

    return image;
  };

  _proto.rotateImage = function rotateImage(image, translate) {
    var w = image.width;
    var h = image.height;

    if (translate.deg === 90 || translate.deg === 270) {
      w = image.height;
      h = image.width;
    }

    var canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    var context = canvas.getContext('2d');
    context.translate(w / 2, h / 2);

    if (translate.canvas) {
      context.rotate(translate.rad);
      context.scale(translate.scaleX, translate.scaleY);
    }

    context.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
    return canvas;
  }
  /**
   * Save a <canvas> element's content to a Blob object.
   *
   * @param {HTMLCanvasElement} canvas
   * @returns {Promise}
   */
  ;

  _proto.canvasToBlob = function canvasToBlob(canvas, type, quality) {
    try {
      canvas.getContext('2d').getImageData(0, 0, 1, 1);
    } catch (err) {
      if (err.code === 18) {
        return Promise.reject(new Error('cannot read image, probably an svg with external resources'));
      }
    }

    if (canvas.toBlob) {
      return new Promise(function (resolve) {
        canvas.toBlob(resolve, type, quality);
      }).then(function (blob) {
        if (blob === null) {
          throw new Error('cannot read image, probably an svg with external resources');
        }

        return blob;
      });
    }

    return Promise.resolve().then(function () {
      return dataURItoBlob(canvas.toDataURL(type, quality), {});
    }).then(function (blob) {
      if (blob === null) {
        throw new Error('could not extract blob, probably an old browser');
      }

      return blob;
    });
  }
  /**
   * Set the preview URL for a file.
   */
  ;

  _proto.setPreviewURL = function setPreviewURL(fileID, preview) {
    this.uppy.setFileState(fileID, {
      preview: preview
    });
  };

  _proto.addToQueue = function addToQueue(item) {
    this.queue.push(item);

    if (this.queueProcessing === false) {
      this.processQueue();
    }
  };

  _proto.processQueue = function processQueue() {
    var _this3 = this;

    this.queueProcessing = true;

    if (this.queue.length > 0) {
      var current = this.uppy.getFile(this.queue.shift());

      if (!current) {
        this.uppy.log('[ThumbnailGenerator] file was removed before a thumbnail could be generated, but not removed from the queue. This is probably a bug', 'error');
        return;
      }

      return this.requestThumbnail(current).catch(function (err) {}) // eslint-disable-line handle-callback-err
      .then(function () {
        return _this3.processQueue();
      });
    }

    this.queueProcessing = false;
    this.uppy.log('[ThumbnailGenerator] Emptied thumbnail queue');
    this.uppy.emit('thumbnail:all-generated');
  };

  _proto.requestThumbnail = function requestThumbnail(file) {
    var _this4 = this;

    if (isPreviewSupported(file.type) && !file.isRemote) {
      return this.createThumbnail(file, this.opts.thumbnailWidth, this.opts.thumbnailHeight).then(function (preview) {
        _this4.setPreviewURL(file.id, preview);

        _this4.uppy.log("[ThumbnailGenerator] Generated thumbnail for " + file.id);

        _this4.uppy.emit('thumbnail:generated', _this4.uppy.getFile(file.id), preview);
      }).catch(function (err) {
        _this4.uppy.log("[ThumbnailGenerator] Failed thumbnail for " + file.id + ":", 'warning');

        _this4.uppy.log(err, 'warning');

        _this4.uppy.emit('thumbnail:error', _this4.uppy.getFile(file.id), err);
      });
    }

    return Promise.resolve();
  };

  _proto.install = function install() {
    this.uppy.on('file-removed', this.onFileRemoved);

    if (this.opts.lazy) {
      this.uppy.on('thumbnail:request', this.onFileAdded);
      this.uppy.on('thumbnail:cancel', this.onCancelRequest);
    } else {
      this.uppy.on('file-added', this.onFileAdded);
      this.uppy.on('restored', this.onRestored);
    }

    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.addPreProcessor(this.waitUntilAllProcessed);
    }
  };

  _proto.uninstall = function uninstall() {
    this.uppy.off('file-removed', this.onFileRemoved);

    if (this.opts.lazy) {
      this.uppy.off('thumbnail:request', this.onFileAdded);
      this.uppy.off('thumbnail:cancel', this.onCancelRequest);
    } else {
      this.uppy.off('file-added', this.onFileAdded);
      this.uppy.off('restored', this.onRestored);
    }

    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.removePreProcessor(this.waitUntilAllProcessed);
    }
  };

  return ThumbnailGenerator;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":166,"./../../core":73,"./../../utils/lib/Translator":212,"./../../utils/lib/dataURItoBlob":214,"./../../utils/lib/isObjectURL":238,"./../../utils/lib/isPreviewSupported":239,"exifr/dist/mini.legacy.umd.js":22,"math-log2":33}],168:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],169:[function(require,module,exports){
(function (process){(function (){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this)}).call(this,require('_process'))

},{"./debug":170,"_process":37}],170:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":181}],171:[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":172,"engine.io-parser":19}],172:[function(require,module,exports){
/**
 * Module dependencies.
 */

var transports = require('./transports/index');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (typeof location !== 'undefined' && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (typeof location !== 'undefined' ? location.hostname : 'localhost');
  this.port = opts.port || (typeof location !== 'undefined' && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // detect ReactNative environment
  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');

  // other options for Node.js or ReactNative client
  if (typeof self === 'undefined' || this.isReactNative) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports/index');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0),
    isReactNative: this.isReactNative
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

},{"./transport":173,"./transports/index":174,"component-emitter":168,"debug":169,"engine.io-parser":19,"indexof":28,"parseqs":182,"parseuri":183}],173:[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // results of ReactNative environment detection
  this.isReactNative = opts.isReactNative;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":168,"engine.io-parser":19}],174:[function(require,module,exports){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

},{"./polling-jsonp":175,"./polling-xhr":176,"./websocket":178,"xmlhttprequest-ssl":179}],175:[function(require,module,exports){
(function (global){(function (){
/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * Until https://github.com/tc39/proposal-global is shipped.
 */
function glob () {
  return typeof self !== 'undefined' ? self
      : typeof window !== 'undefined' ? window
      : typeof global !== 'undefined' ? global : {};
}

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    var global = glob();
    callbacks = global.___eio = (global.___eio || []);
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (typeof addEventListener === 'function') {
    addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":177,"component-inherit":12}],176:[function(require,module,exports){
/* global attachEvent */

/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');
            if (self.supportsBinary && contentType === 'application/octet-stream') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (typeof document !== 'undefined') {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (typeof document !== 'undefined') {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== 'undefined') {
  if (typeof attachEvent === 'function') {
    attachEvent('onunload', unloadHandler);
  } else if (typeof addEventListener === 'function') {
    var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

},{"./polling":177,"component-emitter":168,"component-inherit":12,"debug":169,"xmlhttprequest-ssl":179}],177:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = require('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":173,"component-inherit":12,"debug":169,"engine.io-parser":19,"parseqs":182,"xmlhttprequest-ssl":179,"yeast":61}],178:[function(require,module,exports){
(function (Buffer){(function (){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:websocket');

var BrowserWebSocket, NodeWebSocket;

if (typeof WebSocket !== 'undefined') {
  BrowserWebSocket = WebSocket;
} else if (typeof self !== 'undefined') {
  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
} else {
  try {
    NodeWebSocket = require('ws');
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocketImpl = BrowserWebSocket || NodeWebSocket;

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocketImpl = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws =
      this.usingBrowserWebSocket && !this.isReactNative
        ? protocols
          ? new WebSocketImpl(uri, protocols)
          : new WebSocketImpl(uri)
        : new WebSocketImpl(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
};

}).call(this)}).call(this,require("buffer").Buffer)

},{"../transport":173,"buffer":9,"component-inherit":12,"debug":169,"engine.io-parser":19,"parseqs":182,"ws":8,"yeast":61}],179:[function(require,module,exports){
// browser shim for xmlhttprequest module

var hasCORS = require('has-cors');

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new self[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};

},{"has-cors":26}],180:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],181:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],182:[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],183:[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],184:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":185,"./socket":187,"./url":188,"debug":169,"socket.io-parser":190}],185:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":186,"./socket":187,"backo2":4,"component-bind":11,"component-emitter":168,"debug":169,"engine.io-client":171,"indexof":28,"socket.io-parser":190}],186:[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}

},{}],187:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var parseqs = require('parseqs');
var hasBin = require('has-binary2');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.flags = {};
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  this.flags = {};

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: parser.CONNECT, query: query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  var sameNamespace = packet.nsp === this.nsp;
  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

  if (!sameNamespace && !rootNamespaceError) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} whether the emitted data contains binary
 * @return {Socket} self
 * @api public
 */

Socket.prototype.binary = function (binary) {
  this.flags.binary = binary;
  return this;
};

},{"./on":186,"component-bind":11,"component-emitter":168,"debug":169,"has-binary2":24,"parseqs":182,"socket.io-parser":190,"to-array":44}],188:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || (typeof location !== 'undefined' && location);
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}

},{"debug":169,"parseuri":183}],189:[function(require,module,exports){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

},{"./is-buffer":191,"isarray":180}],190:[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an encoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  } else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  } else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var start = i + 1;
    while (str.charAt(++i) !== '-' && i != str.length) {}
    var buf = str.substring(start, i);
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    var start = i + 1;
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      if (i === str.length) break;
    }
    p.nsp = str.substring(start, i);
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    var start = i + 1;
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      if (i === str.length) break;
    }
    p.id = Number(str.substring(start, i + 1));
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}

},{"./binary":189,"./is-buffer":191,"component-emitter":192,"debug":169,"isarray":180}],191:[function(require,module,exports){
(function (Buffer){(function (){

module.exports = isBuf;

var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
};

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":9}],192:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],193:[function(require,module,exports){
module.exports={
  "name": "@uppy/transloadit",
  "description": "The Transloadit plugin can be used to upload files to Transloadit for all kinds of processing, such as transcoding video, resizing images, zipping/unzipping, and more",
  "version": "1.6.26",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "transloadit",
    "file encoding",
    "encoding",
    "file processing",
    "video encoding",
    "crop",
    "resize",
    "watermark",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/tus": "file:../tus",
    "@uppy/utils": "file:../utils",
    "component-emitter": "^1.2.1",
    "socket.io-client": "~2.2.0",
    "url-parse": "^1.4.7"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],194:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var io = requireSocketIo;

var Emitter = require('component-emitter');

var has = require('./../../utils/lib/hasProperty');

var parseUrl = require('./parseUrl');

var NetworkError = require('./../../utils/lib/NetworkError');

var fetchWithNetworkError = require('./../../utils/lib/fetchWithNetworkError'); // Lazy load socket.io to avoid a console error
// in IE 10 when the Transloadit plugin is not used.
// (The console.error call comes from `buffer`. I
// think we actually don't use that part of socket.io
// at all)


var socketIo;

function requireSocketIo() {
  if (!socketIo) {
    socketIo = require('socket.io-client');
  }

  return socketIo;
}

var ASSEMBLY_UPLOADING = 'ASSEMBLY_UPLOADING';
var ASSEMBLY_EXECUTING = 'ASSEMBLY_EXECUTING';
var ASSEMBLY_COMPLETED = 'ASSEMBLY_COMPLETED';
var statusOrder = [ASSEMBLY_UPLOADING, ASSEMBLY_EXECUTING, ASSEMBLY_COMPLETED];
/**
 * Check that an assembly status is equal to or larger than some desired status.
 * It checks for things that are larger so that a comparison like this works,
 * when the old assembly status is UPLOADING but the new is FINISHED:
 *
 * !isStatus(oldStatus, ASSEMBLY_EXECUTING) && isStatus(newState, ASSEMBLY_EXECUTING)
 *
 * so that we can emit the 'executing' event even if the execution step was so
 * fast that we missed it.
 */

function isStatus(status, test) {
  return statusOrder.indexOf(status) >= statusOrder.indexOf(test);
}

var TransloaditAssembly = /*#__PURE__*/function (_Emitter) {
  _inheritsLoose(TransloaditAssembly, _Emitter);

  function TransloaditAssembly(assembly) {
    var _this;

    _this = _Emitter.call(this) || this; // The current assembly status.

    _this.status = assembly; // The socket.io connection.

    _this.socket = null; // The interval timer for full status updates.

    _this.pollInterval = null; // Whether this assembly has been closed (finished or errored)

    _this.closed = false;
    return _this;
  }

  var _proto = TransloaditAssembly.prototype;

  _proto.connect = function connect() {
    this._connectSocket();

    this._beginPolling();
  };

  _proto._onFinished = function _onFinished() {
    this.emit('finished');
    this.close();
  };

  _proto._connectSocket = function _connectSocket() {
    var _this2 = this;

    var parsed = parseUrl(this.status.websocket_url);
    var socket = io().connect(parsed.origin, {
      transports: ['websocket'],
      path: parsed.pathname
    });
    socket.on('connect', function () {
      socket.emit('assembly_connect', {
        id: _this2.status.assembly_id
      });

      _this2.emit('connect');
    });
    socket.on('connect_failed', function () {
      _this2._onError(new NetworkError('Transloadit Socket.io connection error'));

      _this2.socket = null;
    });
    socket.on('error', function () {
      socket.disconnect();
      _this2.socket = null;
    });
    socket.on('assembly_finished', function () {
      _this2._onFinished();
    });
    socket.on('assembly_upload_finished', function (file) {
      _this2.emit('upload', file);

      _this2.status.uploads.push(file);
    });
    socket.on('assembly_uploading_finished', function () {
      _this2.emit('executing');
    });
    socket.on('assembly_upload_meta_data_extracted', function () {
      _this2.emit('metadata');

      _this2._fetchStatus({
        diff: false
      });
    });
    socket.on('assembly_result_finished', function (stepName, result) {
      _this2.emit('result', stepName, result);

      if (!_this2.status.results[stepName]) {
        _this2.status.results[stepName] = [];
      }

      _this2.status.results[stepName].push(result);
    });
    socket.on('assembly_error', function (err) {
      _this2._onError(err); // Refetch for updated status code


      _this2._fetchStatus({
        diff: false
      });
    });
    this.socket = socket;
  };

  _proto._onError = function _onError(err) {
    this.emit('error', _extends(new Error(err.message), err));
  }
  /**
   * Begin polling for assembly status changes. This sends a request to the
   * assembly status endpoint every so often, if the socket is not connected.
   * If the socket connection fails or takes a long time, we won't miss any
   * events.
   */
  ;

  _proto._beginPolling = function _beginPolling() {
    var _this3 = this;

    this.pollInterval = setInterval(function () {
      if (!_this3.socket || !_this3.socket.connected) {
        _this3._fetchStatus();
      }
    }, 2000);
  }
  /**
   * Reload assembly status. Useful if the socket doesn't work.
   *
   * Pass `diff: false` to avoid emitting diff events, instead only emitting
   * 'status'.
   */
  ;

  _proto._fetchStatus = function _fetchStatus(_temp) {
    var _this4 = this;

    var _ref = _temp === void 0 ? {} : _temp,
        _ref$diff = _ref.diff,
        diff = _ref$diff === void 0 ? true : _ref$diff;

    return fetchWithNetworkError(this.status.assembly_ssl_url).then(function (response) {
      return response.json();
    }).then(function (status) {
      // Avoid updating if we closed during this request's lifetime.
      if (_this4.closed) return;

      _this4.emit('status', status);

      if (diff) {
        _this4.updateStatus(status);
      } else {
        _this4.status = status;
      }
    }).catch(function (err) {
      return _this4._onError(err);
    });
  };

  _proto.update = function update() {
    return this._fetchStatus({
      diff: true
    });
  }
  /**
   * Update this assembly's status with a full new object. Events will be
   * emitted for status changes, new files, and new results.
   *
   * @param {object} next The new assembly status object.
   */
  ;

  _proto.updateStatus = function updateStatus(next) {
    this._diffStatus(this.status, next);

    this.status = next;
  }
  /**
   * Diff two assembly statuses, and emit the events necessary to go from `prev`
   * to `next`.
   *
   * @param {object} prev The previous assembly status.
   * @param {object} next The new assembly status.
   */
  ;

  _proto._diffStatus = function _diffStatus(prev, next) {
    var _this5 = this;

    var prevStatus = prev.ok;
    var nextStatus = next.ok;

    if (next.error && !prev.error) {
      return this._onError(next);
    } // Desired emit order:
    //  - executing
    //  - (n  upload)
    //  - metadata
    //  - (m  result)
    //  - finished
    // The below checks run in this order, that way even if we jump from
    // UPLOADING straight to FINISHED all the events are emitted as expected.


    var nowExecuting = isStatus(nextStatus, ASSEMBLY_EXECUTING) && !isStatus(prevStatus, ASSEMBLY_EXECUTING);

    if (nowExecuting) {
      // Without WebSockets, this is our only way to tell if uploading finished.
      // Hence, we emit this just before the 'upload's and before the 'metadata'
      // event for the most intuitive ordering, corresponding to the _usual_
      // ordering (if not guaranteed) that you'd get on the WebSocket.
      this.emit('executing');
    } // Find new uploaded files.


    Object.keys(next.uploads).filter(function (upload) {
      return !has(prev.uploads, upload);
    }).map(function (upload) {
      return next.uploads[upload];
    }).forEach(function (upload) {
      _this5.emit('upload', upload);
    });

    if (nowExecuting) {
      this.emit('metadata');
    } // Find new results.


    Object.keys(next.results).forEach(function (stepName) {
      var nextResults = next.results[stepName];
      var prevResults = prev.results[stepName];
      nextResults.filter(function (n) {
        return !prevResults || !prevResults.some(function (p) {
          return p.id === n.id;
        });
      }).forEach(function (result) {
        _this5.emit('result', stepName, result);
      });
    });

    if (isStatus(nextStatus, ASSEMBLY_COMPLETED) && !isStatus(prevStatus, ASSEMBLY_COMPLETED)) {
      this.emit('finished');
    }
  }
  /**
   * Stop updating this assembly.
   */
  ;

  _proto.close = function close() {
    this.closed = true;

    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }

    clearInterval(this.pollInterval);
  };

  return TransloaditAssembly;
}(Emitter);

module.exports = TransloaditAssembly;

},{"./../../utils/lib/NetworkError":210,"./../../utils/lib/fetchWithNetworkError":216,"./../../utils/lib/hasProperty":234,"./parseUrl":199,"component-emitter":168,"socket.io-client":184}],195:[function(require,module,exports){
/**
 * Check that Assembly parameters are present and include all required fields.
 */
function validateParams(params) {
  if (!params) {
    throw new Error('Transloadit: The `params` option is required.');
  }

  if (typeof params === 'string') {
    try {
      params = JSON.parse(params);
    } catch (err) {
      // Tell the user that this is not an Uppy bug!
      err.message = "Transloadit: The `params` option is a malformed JSON string: " + err.message;
      throw err;
    }
  }

  if (!params.auth || !params.auth.key) {
    throw new Error('Transloadit: The `params.auth.key` option is required. ' + 'You can find your Transloadit API key at https://transloadit.com/account/api-settings.');
  }
}
/**
 * Turn Transloadit plugin options and a list of files into a list of Assembly
 * options.
 */


var AssemblyOptions = /*#__PURE__*/function () {
  function AssemblyOptions(files, opts) {
    this.files = files;
    this.opts = opts;
  }
  /**
   * Normalize Uppy-specific Assembly option features to a Transloadit-
   * compatible object.
   */


  var _proto = AssemblyOptions.prototype;

  _proto._normalizeAssemblyOptions = function _normalizeAssemblyOptions(file, assemblyOptions) {
    if (Array.isArray(assemblyOptions.fields)) {
      var fieldNames = assemblyOptions.fields;
      assemblyOptions.fields = {};
      fieldNames.forEach(function (fieldName) {
        assemblyOptions.fields[fieldName] = file.meta[fieldName];
      });
    }

    if (!assemblyOptions.fields) {
      assemblyOptions.fields = {};
    }

    return assemblyOptions;
  }
  /**
   * Get Assembly options for a file.
   */
  ;

  _proto._getAssemblyOptions = function _getAssemblyOptions(file) {
    var _this = this;

    var options = this.opts;
    return Promise.resolve().then(function () {
      return options.getAssemblyOptions(file, options);
    }).then(function (assemblyOptions) {
      return _this._normalizeAssemblyOptions(file, assemblyOptions);
    }).then(function (assemblyOptions) {
      validateParams(assemblyOptions.params);
      return {
        fileIDs: [file.id],
        options: assemblyOptions
      };
    });
  }
  /**
   * Combine Assemblies with the same options into a single Assembly for all the
   * relevant files.
   */
  ;

  _proto._dedupe = function _dedupe(list) {
    var dedupeMap = Object.create(null);
    list.forEach(function (_ref) {
      var fileIDs = _ref.fileIDs,
          options = _ref.options;
      var id = JSON.stringify(options);

      if (dedupeMap[id]) {
        var _dedupeMap$id$fileIDs;

        (_dedupeMap$id$fileIDs = dedupeMap[id].fileIDs).push.apply(_dedupeMap$id$fileIDs, fileIDs);
      } else {
        dedupeMap[id] = {
          options: options,
          fileIDs: [].concat(fileIDs)
        };
      }
    });
    return Object.keys(dedupeMap).map(function (id) {
      return dedupeMap[id];
    });
  }
  /**
   * Generate a set of Assemblies that will handle the upload.
   * Returns a Promise for an object with keys:
   *  - fileIDs - an array of file IDs to add to this Assembly
   *  - options - Assembly options
   */
  ;

  _proto.build = function build() {
    var _this2 = this;

    var options = this.opts;

    if (this.files.length > 0) {
      return Promise.all(this.files.map(function (file) {
        return _this2._getAssemblyOptions(file);
      })).then(function (list) {
        return _this2._dedupe(list);
      });
    }

    if (options.alwaysRunAssembly) {
      // No files, just generate one Assembly
      return Promise.resolve(options.getAssemblyOptions(null, options)).then(function (assemblyOptions) {
        validateParams(assemblyOptions.params);
        return [{
          fileIDs: _this2.files.map(function (file) {
            return file.id;
          }),
          options: assemblyOptions
        }];
      });
    } // If there are no files and we do not `alwaysRunAssembly`,
    // don't do anything.


    return Promise.resolve([]);
  };

  return AssemblyOptions;
}();

module.exports = AssemblyOptions;
module.exports.validateParams = validateParams;

},{}],196:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Emitter = require('component-emitter');
/**
 * Track completion of multiple assemblies.
 *
 * Emits 'assembly-complete' when an assembly completes.
 * Emits 'assembly-error' when an assembly fails.
 * Exposes a `.promise` property that resolves when all assemblies have
 * completed (or failed).
 */


var TransloaditAssemblyWatcher = /*#__PURE__*/function (_Emitter) {
  _inheritsLoose(TransloaditAssemblyWatcher, _Emitter);

  function TransloaditAssemblyWatcher(uppy, assemblyIDs) {
    var _this;

    _this = _Emitter.call(this) || this;
    _this._uppy = uppy;
    _this._assemblyIDs = assemblyIDs;
    _this._remaining = assemblyIDs.length;
    _this.promise = new Promise(function (resolve, reject) {
      _this._resolve = resolve;
      _this._reject = reject;
    });
    _this._onAssemblyComplete = _this._onAssemblyComplete.bind(_assertThisInitialized(_this));
    _this._onAssemblyCancel = _this._onAssemblyCancel.bind(_assertThisInitialized(_this));
    _this._onAssemblyError = _this._onAssemblyError.bind(_assertThisInitialized(_this));
    _this._onImportError = _this._onImportError.bind(_assertThisInitialized(_this));

    _this._addListeners();

    return _this;
  }
  /**
   * Are we watching this assembly ID?
   */


  var _proto = TransloaditAssemblyWatcher.prototype;

  _proto._watching = function _watching(id) {
    return this._assemblyIDs.indexOf(id) !== -1;
  };

  _proto._onAssemblyComplete = function _onAssemblyComplete(assembly) {
    if (!this._watching(assembly.assembly_id)) {
      return;
    }

    this._uppy.log("[Transloadit] AssemblyWatcher: Got Assembly finish " + assembly.assembly_id);

    this.emit('assembly-complete', assembly.assembly_id);

    this._checkAllComplete();
  };

  _proto._onAssemblyCancel = function _onAssemblyCancel(assembly) {
    if (!this._watching(assembly.assembly_id)) {
      return;
    }

    this._checkAllComplete();
  };

  _proto._onAssemblyError = function _onAssemblyError(assembly, error) {
    if (!this._watching(assembly.assembly_id)) {
      return;
    }

    this._uppy.log("[Transloadit] AssemblyWatcher: Got Assembly error " + assembly.assembly_id);

    this._uppy.log(error);

    this.emit('assembly-error', assembly.assembly_id, error);

    this._checkAllComplete();
  };

  _proto._onImportError = function _onImportError(assembly, fileID, error) {
    if (!this._watching(assembly.assembly_id)) {
      return;
    } // Not sure if we should be doing something when it's just one file failing.
    // ATM, the only options are 1) ignoring or 2) failing the entire upload.
    // I think failing the upload is better than silently ignoring.
    // In the future we should maybe have a way to resolve uploads with some failures,
    // like returning an object with `{ successful, failed }` uploads.


    this._onAssemblyError(assembly, error);
  };

  _proto._checkAllComplete = function _checkAllComplete() {
    this._remaining -= 1;

    if (this._remaining === 0) {
      // We're done, these listeners can be removed
      this._removeListeners();

      this._resolve();
    }
  };

  _proto._removeListeners = function _removeListeners() {
    this._uppy.off('transloadit:complete', this._onAssemblyComplete);

    this._uppy.off('transloadit:assembly-cancel', this._onAssemblyCancel);

    this._uppy.off('transloadit:assembly-error', this._onAssemblyError);

    this._uppy.off('transloadit:import-error', this._onImportError);
  };

  _proto._addListeners = function _addListeners() {
    this._uppy.on('transloadit:complete', this._onAssemblyComplete);

    this._uppy.on('transloadit:assembly-cancel', this._onAssemblyCancel);

    this._uppy.on('transloadit:assembly-error', this._onAssemblyError);

    this._uppy.on('transloadit:import-error', this._onImportError);
  };

  return TransloaditAssemblyWatcher;
}(Emitter);

module.exports = TransloaditAssemblyWatcher;

},{"component-emitter":168}],197:[function(require,module,exports){
var fetchWithNetworkError = require('./../../utils/lib/fetchWithNetworkError');

var URL = require('url-parse');
/**
 * A Barebones HTTP API client for Transloadit.
 */


module.exports = /*#__PURE__*/function () {
  function Client(opts) {
    if (opts === void 0) {
      opts = {};
    }

    this.opts = opts;
    this._reportError = this._reportError.bind(this);
    this._headers = {
      'Transloadit-Client': this.opts.client
    };
  }
  /**
   * Create a new assembly.
   *
   * @param {object} options
   * @param {string|object} options.params
   * @param {object} options.fields
   * @param {string} options.signature
   * @param {number} options.expectedFiles
   */


  var _proto = Client.prototype;

  _proto.createAssembly = function createAssembly(_ref) {
    var _this = this;

    var params = _ref.params,
        fields = _ref.fields,
        signature = _ref.signature,
        expectedFiles = _ref.expectedFiles;
    var data = new FormData();
    data.append('params', typeof params === 'string' ? params : JSON.stringify(params));

    if (signature) {
      data.append('signature', signature);
    }

    Object.keys(fields).forEach(function (key) {
      data.append(key, fields[key]);
    });
    data.append('num_expected_upload_files', expectedFiles);
    var url = new URL('/assemblies', "" + this.opts.service).href;
    return fetchWithNetworkError(url, {
      method: 'post',
      headers: this._headers,
      body: data
    }).then(function (response) {
      return response.json();
    }).then(function (assembly) {
      if (assembly.error) {
        var error = new Error(assembly.error);
        error.details = assembly.message;
        error.assembly = assembly;

        if (assembly.assembly_id) {
          error.details += ' ' + ("Assembly ID: " + assembly.assembly_id);
        }

        throw error;
      }

      return assembly;
    }).catch(function (err) {
      return _this._reportError(err, {
        url: url,
        type: 'API_ERROR'
      });
    });
  }
  /**
   * Reserve resources for a file in an Assembly. Then addFile can be used later.
   *
   * @param {object} assembly
   * @param {UppyFile} file
   */
  ;

  _proto.reserveFile = function reserveFile(assembly, file) {
    var _this2 = this;

    var size = encodeURIComponent(file.size);
    var url = assembly.assembly_ssl_url + "/reserve_file?size=" + size;
    return fetchWithNetworkError(url, {
      method: 'post',
      headers: this._headers
    }).then(function (response) {
      return response.json();
    }).catch(function (err) {
      return _this2._reportError(err, {
        assembly: assembly,
        file: file,
        url: url,
        type: 'API_ERROR'
      });
    });
  }
  /**
   * Import a remote file to an Assembly.
   *
   * @param {object} assembly
   * @param {UppyFile} file
   */
  ;

  _proto.addFile = function addFile(assembly, file) {
    var _this3 = this;

    if (!file.uploadURL) {
      return Promise.reject(new Error('File does not have an `uploadURL`.'));
    }

    var size = encodeURIComponent(file.size);
    var uploadUrl = encodeURIComponent(file.uploadURL);
    var filename = encodeURIComponent(file.name);
    var fieldname = 'file';
    var qs = "size=" + size + "&filename=" + filename + "&fieldname=" + fieldname + "&s3Url=" + uploadUrl;
    var url = assembly.assembly_ssl_url + "/add_file?" + qs;
    return fetchWithNetworkError(url, {
      method: 'post',
      headers: this._headers
    }).then(function (response) {
      return response.json();
    }).catch(function (err) {
      return _this3._reportError(err, {
        assembly: assembly,
        file: file,
        url: url,
        type: 'API_ERROR'
      });
    });
  }
  /**
   * Cancel a running Assembly.
   *
   * @param {object} assembly
   */
  ;

  _proto.cancelAssembly = function cancelAssembly(assembly) {
    var _this4 = this;

    var url = assembly.assembly_ssl_url;
    return fetchWithNetworkError(url, {
      method: 'delete',
      headers: this._headers
    }).then(function (response) {
      return response.json();
    }).catch(function (err) {
      return _this4._reportError(err, {
        url: url,
        type: 'API_ERROR'
      });
    });
  }
  /**
   * Get the current status for an assembly.
   *
   * @param {string} url The status endpoint of the assembly.
   */
  ;

  _proto.getAssemblyStatus = function getAssemblyStatus(url) {
    var _this5 = this;

    return fetchWithNetworkError(url, {
      headers: this._headers
    }).then(function (response) {
      return response.json();
    }).catch(function (err) {
      return _this5._reportError(err, {
        url: url,
        type: 'STATUS_ERROR'
      });
    });
  };

  _proto.submitError = function submitError(err, _ref2) {
    var endpoint = _ref2.endpoint,
        instance = _ref2.instance,
        assembly = _ref2.assembly;
    var message = err.details ? err.message + " (" + err.details + ")" : err.message;
    return fetchWithNetworkError('https://transloaditstatus.com/client_error', {
      method: 'post',
      body: JSON.stringify({
        endpoint: endpoint,
        instance: instance,
        assembly_id: assembly,
        agent: typeof navigator !== 'undefined' ? navigator.userAgent : '',
        client: this.opts.client,
        error: message
      })
    }).then(function (response) {
      return response.json();
    });
  };

  _proto._reportError = function _reportError(err, params) {
    if (this.opts.errorReporting === false) {
      throw err;
    }

    var opts = {
      type: params.type
    };

    if (params.assembly) {
      opts.assembly = params.assembly.assembly_id;
      opts.instance = params.assembly.instance;
    }

    if (params.url) {
      opts.endpoint = params.url;
    }

    this.submitError(err, opts).catch(function (_) {// not much we can do then is there
    });
    throw err;
  };

  return Client;
}();

},{"./../../utils/lib/fetchWithNetworkError":216,"url-parse":59}],198:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Translator = require('./../../utils/lib/Translator');

var hasProperty = require('./../../utils/lib/hasProperty');

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Tus = require('./../../tus');

var Assembly = require('./Assembly');

var Client = require('./Client');

var AssemblyOptions = require('./AssemblyOptions');

var AssemblyWatcher = require('./AssemblyWatcher');

function defaultGetAssemblyOptions(file, options) {
  return {
    params: options.params,
    signature: options.signature,
    fields: options.fields
  };
}

var COMPANION = 'https://api2.transloadit.com/companion'; // Regex matching acceptable postMessage() origins for authentication feedback from companion.

var ALLOWED_COMPANION_PATTERN = /\.transloadit\.com$/; // Regex used to check if a Companion address is run by Transloadit.

var TL_COMPANION = /https?:\/\/api2(?:-\w+)?\.transloadit\.com\/companion/;
var TL_UPPY_SERVER = /https?:\/\/api2(?:-\w+)?\.transloadit\.com\/uppy-server/;
/**
 * Upload files to Transloadit using Tus.
 */

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Transloadit, _Plugin);

  function Transloadit(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.type = 'uploader';
    _this.id = _this.opts.id || 'Transloadit';
    _this.title = 'Transloadit';
    _this.defaultLocale = {
      strings: {
        creatingAssembly: 'Preparing upload...',
        creatingAssemblyFailed: 'Transloadit: Could not create Assembly',
        encoding: 'Encoding...'
      }
    };
    var defaultOptions = {
      service: 'https://api2.transloadit.com',
      errorReporting: true,
      waitForEncoding: false,
      waitForMetadata: false,
      alwaysRunAssembly: false,
      importFromUploadURLs: false,
      signature: null,
      params: null,
      fields: {},
      getAssemblyOptions: defaultGetAssemblyOptions,
      limit: 0
    };
    _this.opts = _extends({}, defaultOptions, opts);

    _this.i18nInit();

    _this._prepareUpload = _this._prepareUpload.bind(_assertThisInitialized(_this));
    _this._afterUpload = _this._afterUpload.bind(_assertThisInitialized(_this));
    _this._onError = _this._onError.bind(_assertThisInitialized(_this));
    _this._onTusError = _this._onTusError.bind(_assertThisInitialized(_this));
    _this._onCancelAll = _this._onCancelAll.bind(_assertThisInitialized(_this));
    _this._onFileUploadURLAvailable = _this._onFileUploadURLAvailable.bind(_assertThisInitialized(_this));
    _this._onRestored = _this._onRestored.bind(_assertThisInitialized(_this));
    _this._getPersistentData = _this._getPersistentData.bind(_assertThisInitialized(_this));
    var hasCustomAssemblyOptions = _this.opts.getAssemblyOptions !== defaultOptions.getAssemblyOptions;

    if (_this.opts.params) {
      AssemblyOptions.validateParams(_this.opts.params);
    } else if (!hasCustomAssemblyOptions) {
      // Throw the same error that we'd throw if the `params` returned from a
      // `getAssemblyOptions()` function is null.
      AssemblyOptions.validateParams(null);
    }

    _this.client = new Client({
      service: _this.opts.service,
      client: _this._getClientVersion(),
      errorReporting: _this.opts.errorReporting
    }); // Contains Assembly instances for in-progress Assemblies.

    _this.activeAssemblies = {}; // Contains a mapping of uploadID to AssemblyWatcher

    _this.assemblyWatchers = {}; // Contains a file IDs that have completed postprocessing before the upload they belong to has entered the postprocess stage.

    _this.completedFiles = Object.create(null);
    return _this;
  }

  var _proto = Transloadit.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto._getClientVersion = function _getClientVersion() {
    var _this2 = this;

    var list = ["uppy-core:" + this.uppy.constructor.VERSION, "uppy-transloadit:" + this.constructor.VERSION, "uppy-tus:" + Tus.VERSION];

    var addPluginVersion = function addPluginVersion(pluginName, versionName) {
      var plugin = _this2.uppy.getPlugin(pluginName);

      if (plugin) {
        list.push(versionName + ":" + plugin.constructor.VERSION);
      }
    };

    if (this.opts.importFromUploadURLs) {
      addPluginVersion('XHRUpload', 'uppy-xhr-upload');
      addPluginVersion('AwsS3', 'uppy-aws-s3');
      addPluginVersion('AwsS3Multipart', 'uppy-aws-s3-multipart');
    }

    addPluginVersion('Dropbox', 'uppy-dropbox');
    addPluginVersion('Box', 'uppy-box');
    addPluginVersion('Facebook', 'uppy-facebook');
    addPluginVersion('GoogleDrive', 'uppy-google-drive');
    addPluginVersion('Instagram', 'uppy-instagram');
    addPluginVersion('OneDrive', 'uppy-onedrive');
    addPluginVersion('Zoom', 'uppy-zoom');
    addPluginVersion('Url', 'uppy-url');
    return list.join(',');
  }
  /**
   * Attach metadata to files to configure the Tus plugin to upload to Transloadit.
   * Also use Transloadit's Companion
   *
   * See: https://github.com/tus/tusd/wiki/Uploading-to-Transloadit-using-tus#uploading-using-tus
   *
   * @param {object} file
   * @param {object} status
   */
  ;

  _proto._attachAssemblyMetadata = function _attachAssemblyMetadata(file, status) {
    // Add the metadata parameters Transloadit needs.
    var meta = _extends({}, file.meta, {
      assembly_url: status.assembly_url,
      filename: file.name,
      fieldname: 'file'
    }); // Add Assembly-specific Tus endpoint.


    var tus = _extends({}, file.tus, {
      endpoint: status.tus_url,
      // Include X-Request-ID headers for better debugging.
      addRequestId: true
    }); // Set Companion location. We only add this, if 'file' has the attribute
    // remote, because this is the criteria to identify remote files.
    // We only replace the hostname for Transloadit's companions, so that
    // people can also self-host them while still using Transloadit for encoding.


    var remote = file.remote;

    if (file.remote && TL_UPPY_SERVER.test(file.remote.companionUrl)) {
      var err = new Error('The https://api2.transloadit.com/uppy-server endpoint was renamed to ' + 'https://api2.transloadit.com/companion, please update your `companionUrl` ' + 'options accordingly.'); // Explicitly log this error here because it is caught by the `createAssembly`
      // Promise further along.
      // That's fine, but createAssembly only shows the informer, we need something a
      // little more noisy.

      this.uppy.log(err);
      throw err;
    }

    if (file.remote && TL_COMPANION.test(file.remote.companionUrl)) {
      var newHost = status.companion_url.replace(/\/$/, '');
      var path = file.remote.url.replace(file.remote.companionUrl, '').replace(/^\//, '');
      remote = _extends({}, file.remote, {
        companionUrl: newHost,
        url: newHost + "/" + path
      });
    } // Store the Assembly ID this file is in on the file under the `transloadit` key.


    var newFile = _extends({}, file, {
      transloadit: {
        assembly: status.assembly_id
      }
    }); // Only configure the Tus plugin if we are uploading straight to Transloadit (the default).


    if (!this.opts.importFromUploadURLs) {
      _extends(newFile, {
        meta: meta,
        tus: tus,
        remote: remote
      });
    }

    return newFile;
  };

  _proto._createAssembly = function _createAssembly(fileIDs, uploadID, options) {
    var _this3 = this;

    this.uppy.log('[Transloadit] Create Assembly');
    return this.client.createAssembly({
      params: options.params,
      fields: options.fields,
      expectedFiles: fileIDs.length,
      signature: options.signature
    }).then(function (newAssembly) {
      var _extends2, _extends3;

      var assembly = new Assembly(newAssembly);
      var status = assembly.status;
      var assemblyID = status.assembly_id;

      var _this3$getPluginState = _this3.getPluginState(),
          assemblies = _this3$getPluginState.assemblies,
          uploadsAssemblies = _this3$getPluginState.uploadsAssemblies;

      _this3.setPluginState({
        // Store the Assembly status.
        assemblies: _extends({}, assemblies, (_extends2 = {}, _extends2[assemblyID] = status, _extends2)),
        // Store the list of Assemblies related to this upload.
        uploadsAssemblies: _extends({}, uploadsAssemblies, (_extends3 = {}, _extends3[uploadID] = [].concat(uploadsAssemblies[uploadID], [assemblyID]), _extends3))
      });

      var _this3$uppy$getState = _this3.uppy.getState(),
          files = _this3$uppy$getState.files;

      var updatedFiles = {};
      fileIDs.forEach(function (id) {
        updatedFiles[id] = _this3._attachAssemblyMetadata(_this3.uppy.getFile(id), status);
      });

      _this3.uppy.setState({
        files: _extends({}, files, updatedFiles)
      });

      _this3.uppy.emit('transloadit:assembly-created', status, fileIDs);

      _this3.uppy.log("[Transloadit] Created Assembly " + assemblyID);

      return assembly;
    }).catch(function (err) {
      err.message = _this3.i18n('creatingAssemblyFailed') + ": " + err.message; // Reject the promise.

      throw err;
    });
  };

  _proto._createAssemblyWatcher = function _createAssemblyWatcher(assemblyID, fileIDs, uploadID) {
    var _this4 = this;

    // AssemblyWatcher tracks completion states of all Assemblies in this upload.
    var watcher = new AssemblyWatcher(this.uppy, assemblyID);
    watcher.on('assembly-complete', function (id) {
      var files = _this4.getAssemblyFiles(id);

      files.forEach(function (file) {
        _this4.completedFiles[file.id] = true;

        _this4.uppy.emit('postprocess-complete', file);
      });
    });
    watcher.on('assembly-error', function (id, error) {
      // Clear postprocessing state for all our files.
      var files = _this4.getAssemblyFiles(id);

      files.forEach(function (file) {
        // TODO Maybe make a postprocess-error event here?
        _this4.uppy.emit('upload-error', file, error);

        _this4.uppy.emit('postprocess-complete', file);
      });
    });
    this.assemblyWatchers[uploadID] = watcher;
  };

  _proto._shouldWaitAfterUpload = function _shouldWaitAfterUpload() {
    return this.opts.waitForEncoding || this.opts.waitForMetadata;
  }
  /**
   * Used when `importFromUploadURLs` is enabled: reserves all files in
   * the Assembly.
   */
  ;

  _proto._reserveFiles = function _reserveFiles(assembly, fileIDs) {
    var _this5 = this;

    return Promise.all(fileIDs.map(function (fileID) {
      var file = _this5.uppy.getFile(fileID);

      return _this5.client.reserveFile(assembly.status, file);
    }));
  }
  /**
   * Used when `importFromUploadURLs` is enabled: adds files to the Assembly
   * once they have been fully uploaded.
   */
  ;

  _proto._onFileUploadURLAvailable = function _onFileUploadURLAvailable(rawFile) {
    var _this6 = this;

    var file = this.uppy.getFile(rawFile.id);

    if (!file || !file.transloadit || !file.transloadit.assembly) {
      return;
    }

    var _this$getPluginState = this.getPluginState(),
        assemblies = _this$getPluginState.assemblies;

    var assembly = assemblies[file.transloadit.assembly];
    this.client.addFile(assembly, file).catch(function (err) {
      _this6.uppy.log(err);

      _this6.uppy.emit('transloadit:import-error', assembly, file.id, err);
    });
  };

  _proto._findFile = function _findFile(uploadedFile) {
    var files = this.uppy.getFiles();

    for (var i = 0; i < files.length; i++) {
      var file = files[i]; // Completed file upload.

      if (file.uploadURL === uploadedFile.tus_upload_url) {
        return file;
      } // In-progress file upload.


      if (file.tus && file.tus.uploadUrl === uploadedFile.tus_upload_url) {
        return file;
      }

      if (!uploadedFile.is_tus_file) {
        // Fingers-crossed check for non-tus uploads, eg imported from S3.
        if (file.name === uploadedFile.name && file.size === uploadedFile.size) {
          return file;
        }
      }
    }
  };

  _proto._onFileUploadComplete = function _onFileUploadComplete(assemblyId, uploadedFile) {
    var _extends4;

    var state = this.getPluginState();

    var file = this._findFile(uploadedFile);

    if (!file) {
      this.uppy.log('[Transloadit] Couldnt file the file, it was likely removed in the process');
      return;
    }

    this.setPluginState({
      files: _extends({}, state.files, (_extends4 = {}, _extends4[uploadedFile.id] = {
        assembly: assemblyId,
        id: file.id,
        uploadedFile: uploadedFile
      }, _extends4))
    });
    this.uppy.emit('transloadit:upload', uploadedFile, this.getAssembly(assemblyId));
  }
  /**
   * Callback when a new Assembly result comes in.
   *
   * @param {string} assemblyId
   * @param {string} stepName
   * @param {object} result
   */
  ;

  _proto._onResult = function _onResult(assemblyId, stepName, result) {
    var state = this.getPluginState();
    var file = state.files[result.original_id]; // The `file` may not exist if an import robot was used instead of a file upload.

    result.localId = file ? file.id : null;
    var entry = {
      result: result,
      stepName: stepName,
      id: result.id,
      assembly: assemblyId
    };
    this.setPluginState({
      results: [].concat(state.results, [entry])
    });
    this.uppy.emit('transloadit:result', stepName, result, this.getAssembly(assemblyId));
  }
  /**
   * When an Assembly has finished processing, get the final state
   * and emit it.
   *
   * @param {object} status
   */
  ;

  _proto._onAssemblyFinished = function _onAssemblyFinished(status) {
    var _this7 = this;

    var url = status.assembly_ssl_url;
    this.client.getAssemblyStatus(url).then(function (finalStatus) {
      var _extends5;

      var assemblyId = finalStatus.assembly_id;

      var state = _this7.getPluginState();

      _this7.setPluginState({
        assemblies: _extends({}, state.assemblies, (_extends5 = {}, _extends5[assemblyId] = finalStatus, _extends5))
      });

      _this7.uppy.emit('transloadit:complete', finalStatus);
    });
  };

  _proto._cancelAssembly = function _cancelAssembly(assembly) {
    var _this8 = this;

    return this.client.cancelAssembly(assembly).then(function () {
      // TODO bubble this through AssemblyWatcher so its event handlers can clean up correctly
      _this8.uppy.emit('transloadit:assembly-cancelled', assembly);
    });
  }
  /**
   * When all files are removed, cancel in-progress Assemblies.
   */
  ;

  _proto._onCancelAll = function _onCancelAll() {
    var _this9 = this;

    var _this$getPluginState2 = this.getPluginState(),
        uploadsAssemblies = _this$getPluginState2.uploadsAssemblies;

    var assemblyIDs = Object.keys(uploadsAssemblies).reduce(function (acc, uploadID) {
      acc.push.apply(acc, uploadsAssemblies[uploadID]);
      return acc;
    }, []);
    var cancelPromises = assemblyIDs.map(function (assemblyID) {
      var assembly = _this9.getAssembly(assemblyID);

      return _this9._cancelAssembly(assembly);
    });
    Promise.all(cancelPromises).catch(function (err) {
      _this9.uppy.log(err);
    });
  }
  /**
   * Custom state serialization for the Golden Retriever plugin.
   * It will pass this back to the `_onRestored` function.
   *
   * @param {Function} setData
   */
  ;

  _proto._getPersistentData = function _getPersistentData(setData) {
    var _setData;

    var state = this.getPluginState();
    var assemblies = state.assemblies;
    var uploadsAssemblies = state.uploadsAssemblies;
    setData((_setData = {}, _setData[this.id] = {
      assemblies: assemblies,
      uploadsAssemblies: uploadsAssemblies
    }, _setData));
  };

  _proto._onRestored = function _onRestored(pluginData) {
    var _this10 = this;

    var savedState = pluginData && pluginData[this.id] ? pluginData[this.id] : {};
    var previousAssemblies = savedState.assemblies || {};
    var uploadsAssemblies = savedState.uploadsAssemblies || {};

    if (Object.keys(uploadsAssemblies).length === 0) {
      // Nothing to restore.
      return;
    } // Convert loaded Assembly statuses to a Transloadit plugin state object.


    var restoreState = function restoreState(assemblies) {
      var files = {};
      var results = [];
      Object.keys(assemblies).forEach(function (id) {
        var status = assemblies[id];
        status.uploads.forEach(function (uploadedFile) {
          var file = _this10._findFile(uploadedFile);

          files[uploadedFile.id] = {
            id: file.id,
            assembly: id,
            uploadedFile: uploadedFile
          };
        });

        var state = _this10.getPluginState();

        Object.keys(status.results).forEach(function (stepName) {
          status.results[stepName].forEach(function (result) {
            var file = state.files[result.original_id];
            result.localId = file ? file.id : null;
            results.push({
              id: result.id,
              result: result,
              stepName: stepName,
              assembly: id
            });
          });
        });
      });

      _this10.setPluginState({
        assemblies: assemblies,
        files: files,
        results: results,
        uploadsAssemblies: uploadsAssemblies
      });
    }; // Set up the Assembly instances and AssemblyWatchers for existing Assemblies.


    var restoreAssemblies = function restoreAssemblies() {
      var _this10$getPluginStat = _this10.getPluginState(),
          assemblies = _this10$getPluginStat.assemblies,
          uploadsAssemblies = _this10$getPluginStat.uploadsAssemblies; // Set up the assembly watchers again for all the ongoing uploads.


      Object.keys(uploadsAssemblies).forEach(function (uploadID) {
        var assemblyIDs = uploadsAssemblies[uploadID];
        var fileIDsInUpload = assemblyIDs.reduce(function (acc, assemblyID) {
          var fileIDsInAssembly = _this10.getAssemblyFiles(assemblyID).map(function (file) {
            return file.id;
          });

          acc.push.apply(acc, fileIDsInAssembly);
          return acc;
        }, []);

        _this10._createAssemblyWatcher(assemblyIDs, fileIDsInUpload, uploadID);
      });
      var allAssemblyIDs = Object.keys(assemblies);
      allAssemblyIDs.forEach(function (id) {
        var assembly = new Assembly(assemblies[id]);

        _this10._connectAssembly(assembly);
      });
    }; // Force-update all Assemblies to check for missed events.


    var updateAssemblies = function updateAssemblies() {
      var _this10$getPluginStat2 = _this10.getPluginState(),
          assemblies = _this10$getPluginStat2.assemblies;

      return Promise.all(Object.keys(assemblies).map(function (id) {
        return _this10.activeAssemblies[id].update();
      }));
    }; // Restore all Assembly state.


    this.restored = Promise.resolve().then(function () {
      restoreState(previousAssemblies);
      restoreAssemblies();
      return updateAssemblies();
    });
    this.restored.then(function () {
      _this10.restored = null;
    });
  };

  _proto._connectAssembly = function _connectAssembly(assembly) {
    var _this11 = this;

    var status = assembly.status;
    var id = status.assembly_id;
    this.activeAssemblies[id] = assembly; // Sync local `assemblies` state

    assembly.on('status', function (newStatus) {
      var _extends6;

      var _this11$getPluginStat = _this11.getPluginState(),
          assemblies = _this11$getPluginStat.assemblies;

      _this11.setPluginState({
        assemblies: _extends({}, assemblies, (_extends6 = {}, _extends6[id] = newStatus, _extends6))
      });
    });
    assembly.on('upload', function (file) {
      _this11._onFileUploadComplete(id, file);
    });
    assembly.on('error', function (error) {
      error.assembly = assembly.status;

      _this11.uppy.emit('transloadit:assembly-error', assembly.status, error);
    });
    assembly.on('executing', function () {
      _this11.uppy.emit('transloadit:assembly-executing', assembly.status);
    });

    if (this.opts.waitForEncoding) {
      assembly.on('result', function (stepName, result) {
        _this11._onResult(id, stepName, result);
      });
    }

    if (this.opts.waitForEncoding) {
      assembly.on('finished', function () {
        _this11._onAssemblyFinished(assembly.status);
      });
    } else if (this.opts.waitForMetadata) {
      assembly.on('metadata', function () {
        _this11._onAssemblyFinished(assembly.status);
      });
    } // No need to connect to the socket if the Assembly has completed by now.


    if (assembly.ok === 'ASSEMBLY_COMPLETE') {
      return assembly;
    } // TODO Do we still need this for anything?
    // eslint-disable-next-line no-unused-vars


    var connected = new Promise(function (resolve, reject) {
      assembly.once('connect', resolve);
      assembly.once('status', resolve);
      assembly.once('error', reject);
    }).then(function () {
      _this11.uppy.log('[Transloadit] Socket is ready');
    });
    assembly.connect();
    return assembly;
  };

  _proto._prepareUpload = function _prepareUpload(fileIDs, uploadID) {
    var _this12 = this,
        _extends7;

    // Only use files without errors
    fileIDs = fileIDs.filter(function (file) {
      return !file.error;
    });
    fileIDs.forEach(function (fileID) {
      var file = _this12.uppy.getFile(fileID);

      _this12.uppy.emit('preprocess-progress', file, {
        mode: 'indeterminate',
        message: _this12.i18n('creatingAssembly')
      });
    });

    var createAssembly = function createAssembly(_ref) {
      var fileIDs = _ref.fileIDs,
          options = _ref.options;
      var createdAssembly;
      return _this12._createAssembly(fileIDs, uploadID, options).then(function (assembly) {
        createdAssembly = assembly;

        if (_this12.opts.importFromUploadURLs) {
          return _this12._reserveFiles(assembly, fileIDs);
        }
      }).then(function () {
        fileIDs.forEach(function (fileID) {
          var file = _this12.uppy.getFile(fileID);

          _this12.uppy.emit('preprocess-complete', file);
        });
        return createdAssembly;
      }).catch(function (err) {
        fileIDs.forEach(function (fileID) {
          var file = _this12.uppy.getFile(fileID); // Clear preprocessing state when the Assembly could not be created,
          // otherwise the UI gets confused about the lingering progress keys


          _this12.uppy.emit('preprocess-complete', file);

          _this12.uppy.emit('upload-error', file, err);
        });
        throw err;
      });
    };

    var _this$getPluginState3 = this.getPluginState(),
        uploadsAssemblies = _this$getPluginState3.uploadsAssemblies;

    this.setPluginState({
      uploadsAssemblies: _extends({}, uploadsAssemblies, (_extends7 = {}, _extends7[uploadID] = [], _extends7))
    });
    var files = fileIDs.map(function (id) {
      return _this12.uppy.getFile(id);
    });
    var assemblyOptions = new AssemblyOptions(files, this.opts);
    return assemblyOptions.build().then(function (assemblies) {
      return Promise.all(assemblies.map(createAssembly)).then(function (createdAssemblies) {
        var assemblyIDs = createdAssemblies.map(function (assembly) {
          return assembly.status.assembly_id;
        });

        _this12._createAssemblyWatcher(assemblyIDs, fileIDs, uploadID);

        createdAssemblies.map(function (assembly) {
          return _this12._connectAssembly(assembly);
        });
      });
    }, // If something went wrong before any Assemblies could be created,
    // clear all processing state.
    function (err) {
      fileIDs.forEach(function (fileID) {
        var file = _this12.uppy.getFile(fileID);

        _this12.uppy.emit('preprocess-complete', file);

        _this12.uppy.emit('upload-error', file, err);
      });
      throw err;
    });
  };

  _proto._afterUpload = function _afterUpload(fileIDs, uploadID) {
    var _this13 = this;

    var files = fileIDs.map(function (fileID) {
      return _this13.uppy.getFile(fileID);
    }); // Only use files without errors

    fileIDs = files.filter(function (file) {
      return !file.error;
    }).map(function (file) {
      return file.id;
    });
    var state = this.getPluginState(); // If we're still restoring state, wait for that to be done.

    if (this.restored) {
      return this.restored.then(function () {
        return _this13._afterUpload(fileIDs, uploadID);
      });
    }

    var assemblyIDs = state.uploadsAssemblies[uploadID];

    var closeSocketConnections = function closeSocketConnections() {
      assemblyIDs.forEach(function (assemblyID) {
        var assembly = _this13.activeAssemblies[assemblyID];
        assembly.close();
        delete _this13.activeAssemblies[assemblyID];
      });
    }; // If we don't have to wait for encoding metadata or results, we can close
    // the socket immediately and finish the upload.


    if (!this._shouldWaitAfterUpload()) {
      closeSocketConnections();
      var assemblies = assemblyIDs.map(function (id) {
        return _this13.getAssembly(id);
      });
      this.uppy.addResultData(uploadID, {
        transloadit: assemblies
      });
      return Promise.resolve();
    } // If no Assemblies were created for this upload, we also do not have to wait.
    // There's also no sockets or anything to close, so just return immediately.


    if (assemblyIDs.length === 0) {
      this.uppy.addResultData(uploadID, {
        transloadit: []
      });
      return Promise.resolve();
    }

    var incompleteFiles = files.filter(function (file) {
      return !hasProperty(_this13.completedFiles, file.id);
    });
    incompleteFiles.forEach(function (file) {
      _this13.uppy.emit('postprocess-progress', file, {
        mode: 'indeterminate',
        message: _this13.i18n('encoding')
      });
    });
    var watcher = this.assemblyWatchers[uploadID];
    return watcher.promise.then(function () {
      closeSocketConnections();
      var assemblies = assemblyIDs.map(function (id) {
        return _this13.getAssembly(id);
      }); // Remove the Assembly ID list for this upload,
      // it's no longer going to be used anywhere.

      var state = _this13.getPluginState();

      var uploadsAssemblies = _extends({}, state.uploadsAssemblies);

      delete uploadsAssemblies[uploadID];

      _this13.setPluginState({
        uploadsAssemblies: uploadsAssemblies
      });

      _this13.uppy.addResultData(uploadID, {
        transloadit: assemblies
      });
    });
  };

  _proto._onError = function _onError(err, uploadID) {
    var _this14 = this;

    if (err === void 0) {
      err = null;
    }

    var state = this.getPluginState();
    var assemblyIDs = state.uploadsAssemblies[uploadID];
    assemblyIDs.forEach(function (assemblyID) {
      if (_this14.activeAssemblies[assemblyID]) {
        _this14.activeAssemblies[assemblyID].close();
      }
    });
  };

  _proto._onTusError = function _onTusError(err) {
    if (err && /^tus: /.test(err.message)) {
      var xhr = err.originalRequest ? err.originalRequest.getUnderlyingObject() : null;
      var url = xhr && xhr.responseURL ? xhr.responseURL : null;
      this.client.submitError(err, {
        url: url,
        type: 'TUS_ERROR'
      }).then(function (_) {// if we can't report the error that sucks
      });
    }
  };

  _proto.install = function install() {
    this.uppy.addPreProcessor(this._prepareUpload);
    this.uppy.addPostProcessor(this._afterUpload); // We may need to close socket.io connections on error.

    this.uppy.on('error', this._onError); // Handle cancellation.

    this.uppy.on('cancel-all', this._onCancelAll); // For error reporting.

    this.uppy.on('upload-error', this._onTusError);

    if (this.opts.importFromUploadURLs) {
      // No uploader needed when importing; instead we take the upload URL from an existing uploader.
      this.uppy.on('upload-success', this._onFileUploadURLAvailable);
    } else {
      this.uppy.use(Tus, {
        // Disable tus-js-client fingerprinting, otherwise uploading the same file at different times
        // will upload to an outdated Assembly, and we won't get socket events for it.
        //
        // To resume a Transloadit upload, we need to reconnect to the websocket, and the state that's
        // required to do that is not saved by tus-js-client's fingerprinting. We need the tus URL,
        // the Assembly URL, and the WebSocket URL, at least. We also need to know _all_ the files that
        // were added to the Assembly, so we can properly complete it. All that state is handled by
        // Golden Retriever. So, Golden Retriever is required to do resumability with the Transloadit plugin,
        // and we disable Tus's default resume implementation to prevent bad behaviours.
        storeFingerprintForResuming: false,
        resume: false,
        // Disable Companion's retry optimisation; we need to change the endpoint on retry
        // so it can't just reuse the same tus.Upload instance server-side.
        useFastRemoteRetry: false,
        // Only send Assembly metadata to the tus endpoint.
        metaFields: ['assembly_url', 'filename', 'fieldname'],
        // Pass the limit option to @uppy/tus
        limit: this.opts.limit
      });
    }

    this.uppy.on('restore:get-data', this._getPersistentData);
    this.uppy.on('restored', this._onRestored);
    this.setPluginState({
      // Contains Assembly status objects, indexed by their ID.
      assemblies: {},
      // Contains arrays of Assembly IDs, indexed by the upload ID that they belong to.
      uploadsAssemblies: {},
      // Contains file data from Transloadit, indexed by their Transloadit-assigned ID.
      files: {},
      // Contains result data from Transloadit.
      results: []
    }); // We cannot cancel individual files because Assemblies tend to contain many files.

    var _this$uppy$getState = this.uppy.getState(),
        capabilities = _this$uppy$getState.capabilities;

    this.uppy.setState({
      capabilities: _extends({}, capabilities, {
        individualCancellation: false
      })
    });
  };

  _proto.uninstall = function uninstall() {
    this.uppy.removePreProcessor(this._prepareUpload);
    this.uppy.removePostProcessor(this._afterUpload);
    this.uppy.off('error', this._onError);

    if (this.opts.importFromUploadURLs) {
      this.uppy.off('upload-success', this._onFileUploadURLAvailable);
    }

    var _this$uppy$getState2 = this.uppy.getState(),
        capabilities = _this$uppy$getState2.capabilities;

    this.uppy.setState({
      capabilities: _extends({}, capabilities, {
        individualCancellation: true
      })
    });
  };

  _proto.getAssembly = function getAssembly(id) {
    var _this$getPluginState4 = this.getPluginState(),
        assemblies = _this$getPluginState4.assemblies;

    return assemblies[id];
  };

  _proto.getAssemblyFiles = function getAssemblyFiles(assemblyID) {
    return this.uppy.getFiles().filter(function (file) {
      return file && file.transloadit && file.transloadit.assembly === assemblyID;
    });
  };

  return Transloadit;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);
module.exports.COMPANION = COMPANION;
module.exports.UPPY_SERVER = COMPANION;
module.exports.COMPANION_PATTERN = ALLOWED_COMPANION_PATTERN;

},{"../package.json":193,"./../../core":73,"./../../tus":202,"./../../utils/lib/Translator":212,"./../../utils/lib/hasProperty":234,"./Assembly":194,"./AssemblyOptions":195,"./AssemblyWatcher":196,"./Client":197}],199:[function(require,module,exports){
module.exports = function parseUrl(url) {
  var scheme = /^\w+:\/\//.exec(url);
  var i = 0;

  if (scheme) {
    i = scheme[0].length + 1;
  }

  var slashIndex = url.indexOf('/', i);

  if (slashIndex === -1) {
    return {
      origin: url,
      pathname: '/'
    };
  }

  return {
    origin: url.slice(0, slashIndex),
    pathname: url.slice(slashIndex)
  };
};

},{}],200:[function(require,module,exports){
module.exports={
  "name": "@uppy/tus",
  "description": "Resumable uploads for Uppy using Tus.io",
  "version": "1.9.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "upload",
    "resumable",
    "tus"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/utils": "file:../utils",
    "tus-js-client": "^2.1.1"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],201:[function(require,module,exports){
var tus = require('tus-js-client');

function isCordova() {
  return typeof window !== 'undefined' && (typeof window.PhoneGap !== 'undefined' || typeof window.Cordova !== 'undefined' || typeof window.cordova !== 'undefined');
}

function isReactNative() {
  return typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative';
} // We override tus fingerprint to uppys `file.id`, since the `file.id`
// now also includes `relativePath` for files added from folders.
// This means you can add 2 identical files, if one is in folder a,
// the other in folder b  `a/file.jpg` and `b/file.jpg`, when added
// together with a folder, will be treated as 2 separate files.
//
// For React Native and Cordova, we let tus-js-clients default
// fingerprint handling take charge.


module.exports = function getFingerprint(uppyFileObj) {
  return function (file, options) {
    if (isCordova() || isReactNative()) {
      return tus.defaultOptions.fingerprint(file, options);
    }

    var uppyFingerprint = ['tus', uppyFileObj.id, options.endpoint].join('-');
    return Promise.resolve(uppyFingerprint);
  };
};

},{"tus-js-client":48}],202:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var tus = require('tus-js-client');

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider,
    RequestClient = _require2.RequestClient,
    Socket = _require2.Socket;

var emitSocketProgress = require('./../../utils/lib/emitSocketProgress');

var getSocketHost = require('./../../utils/lib/getSocketHost');

var settle = require('./../../utils/lib/settle');

var EventTracker = require('./../../utils/lib/EventTracker');

var NetworkError = require('./../../utils/lib/NetworkError');

var isNetworkError = require('./../../utils/lib/isNetworkError');

var RateLimitedQueue = require('./../../utils/lib/RateLimitedQueue');

var hasProperty = require('./../../utils/lib/hasProperty');

var getFingerprint = require('./getFingerprint');
/** @typedef {import('..').TusOptions} TusOptions */

/** @typedef {import('tus-js-client').UploadOptions} RawTusOptions */

/** @typedef {import('@uppy/core').Uppy} Uppy */

/** @typedef {import('@uppy/core').UppyFile} UppyFile */

/** @typedef {import('@uppy/core').FailedUppyFile<{}>} FailedUppyFile */

/**
 * Extracted from https://github.com/tus/tus-js-client/blob/master/lib/upload.js#L13
 * excepted we removed 'fingerprint' key to avoid adding more dependencies
 *
 * @type {RawTusOptions}
 */


var tusDefaultOptions = {
  endpoint: '',
  uploadUrl: null,
  metadata: {},
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  chunkSize: Infinity,
  retryDelays: [0, 1000, 3000, 5000],
  parallelUploads: 1,
  storeFingerprintForResuming: true,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false
};
/**
 * Tus resumable file uploader
 */

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Tus, _Plugin);

  /**
   * @param {Uppy} uppy
   * @param {TusOptions} opts
   */
  function Tus(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.type = 'uploader';
    _this.id = _this.opts.id || 'Tus';
    _this.title = 'Tus'; // set default options

    var defaultOptions = {
      autoRetry: true,
      resume: true,
      useFastRemoteRetry: true,
      limit: 0,
      retryDelays: [0, 1000, 3000, 5000],
      withCredentials: false
    }; // merge default options with the ones set by user

    /** @type {import("..").TusOptions} */

    _this.opts = _extends({}, defaultOptions, opts);
    /**
     * Simultaneous upload limiting is shared across all uploads with this plugin.
     *
     * @type {RateLimitedQueue}
     */

    _this.requests = new RateLimitedQueue(_this.opts.limit);
    _this.uploaders = Object.create(null);
    _this.uploaderEvents = Object.create(null);
    _this.uploaderSockets = Object.create(null);
    _this.handleResetProgress = _this.handleResetProgress.bind(_assertThisInitialized(_this));
    _this.handleUpload = _this.handleUpload.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Tus.prototype;

  _proto.handleResetProgress = function handleResetProgress() {
    var files = _extends({}, this.uppy.getState().files);

    Object.keys(files).forEach(function (fileID) {
      // Only clone the file object if it has a Tus `uploadUrl` attached.
      if (files[fileID].tus && files[fileID].tus.uploadUrl) {
        var tusState = _extends({}, files[fileID].tus);

        delete tusState.uploadUrl;
        files[fileID] = _extends({}, files[fileID], {
          tus: tusState
        });
      }
    });
    this.uppy.setState({
      files: files
    });
  }
  /**
   * Clean up all references for a file's upload: the tus.Upload instance,
   * any events related to the file, and the Companion WebSocket connection.
   *
   * @param {string} fileID
   */
  ;

  _proto.resetUploaderReferences = function resetUploaderReferences(fileID, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (this.uploaders[fileID]) {
      var uploader = this.uploaders[fileID];
      uploader.abort();

      if (opts.abort) {
        // to avoid 423 error from tus server, we wait
        // to be sure the previous request has been aborted before terminating the upload
        // @todo remove the timeout when this "wait" is handled in tus-js-client internally
        setTimeout(function () {
          return uploader.abort(true);
        }, 1000);
      }

      this.uploaders[fileID] = null;
    }

    if (this.uploaderEvents[fileID]) {
      this.uploaderEvents[fileID].remove();
      this.uploaderEvents[fileID] = null;
    }

    if (this.uploaderSockets[fileID]) {
      this.uploaderSockets[fileID].close();
      this.uploaderSockets[fileID] = null;
    }
  }
  /**
   * Create a new Tus upload.
   *
   * A lot can happen during an upload, so this is quite hard to follow!
   * - First, the upload is started. If the file was already paused by the time the upload starts, nothing should happen.
   *   If the `limit` option is used, the upload must be queued onto the `this.requests` queue.
   *   When an upload starts, we store the tus.Upload instance, and an EventTracker instance that manages the event listeners
   *   for pausing, cancellation, removal, etc.
   * - While the upload is in progress, it may be paused or cancelled.
   *   Pausing aborts the underlying tus.Upload, and removes the upload from the `this.requests` queue. All other state is
   *   maintained.
   *   Cancelling removes the upload from the `this.requests` queue, and completely aborts the upload--the tus.Upload instance
   *   is aborted and discarded, the EventTracker instance is destroyed (removing all listeners).
   *   Resuming the upload uses the `this.requests` queue as well, to prevent selectively pausing and resuming uploads from
   *   bypassing the limit.
   * - After completing an upload, the tus.Upload and EventTracker instances are cleaned up, and the upload is marked as done
   *   in the `this.requests` queue.
   * - When an upload completed with an error, the same happens as on successful completion, but the `upload()` promise is rejected.
   *
   * When working on this function, keep in mind:
   *  - When an upload is completed or cancelled for any reason, the tus.Upload and EventTracker instances need to be cleaned up using this.resetUploaderReferences().
   *  - When an upload is cancelled or paused, for any reason, it needs to be removed from the `this.requests` queue using `queuedRequest.abort()`.
   *  - When an upload is completed for any reason, including errors, it needs to be marked as such using `queuedRequest.done()`.
   *  - When an upload is started or resumed, it needs to go through the `this.requests` queue. The `queuedRequest` variable must be updated so the other uses of it are valid.
   *  - Before replacing the `queuedRequest` variable, the previous `queuedRequest` must be aborted, else it will keep taking up a spot in the queue.
   *
   * @param {UppyFile} file for use with upload
   * @param {number} current file in a queue
   * @param {number} total number of files in a queue
   * @returns {Promise<void>}
   */
  ;

  _proto.upload = function upload(file, current, total) {
    var _this2 = this;

    this.resetUploaderReferences(file.id); // Create a new tus upload

    return new Promise(function (resolve, reject) {
      _this2.uppy.emit('upload-started', file);

      var opts = _extends({}, _this2.opts, file.tus || {});
      /** @type {RawTusOptions} */


      var uploadOptions = _extends({}, tusDefaultOptions, opts);

      delete uploadOptions.resume; // Make `resume: true` work like it did in tus-js-client v1.
      // TODO: Remove in @uppy/tus v2

      if (opts.resume) {
        uploadOptions.storeFingerprintForResuming = true;
      } // We override tus fingerprint to uppys `file.id`, since the `file.id`
      // now also includes `relativePath` for files added from folders.
      // This means you can add 2 identical files, if one is in folder a,
      // the other in folder b.


      uploadOptions.fingerprint = getFingerprint(file);

      uploadOptions.onBeforeRequest = function (req) {
        var xhr = req.getUnderlyingObject();
        xhr.withCredentials = !!opts.withCredentials;

        if (typeof opts.onBeforeRequest === 'function') {
          opts.onBeforeRequest(req);
        }
      };

      uploadOptions.onError = function (err) {
        _this2.uppy.log(err);

        var xhr = err.originalRequest ? err.originalRequest.getUnderlyingObject() : null;

        if (isNetworkError(xhr)) {
          err = new NetworkError(err, xhr);
        }

        _this2.resetUploaderReferences(file.id);

        queuedRequest.done();

        _this2.uppy.emit('upload-error', file, err);

        reject(err);
      };

      uploadOptions.onProgress = function (bytesUploaded, bytesTotal) {
        _this2.onReceiveUploadUrl(file, upload.url);

        _this2.uppy.emit('upload-progress', file, {
          uploader: _this2,
          bytesUploaded: bytesUploaded,
          bytesTotal: bytesTotal
        });
      };

      uploadOptions.onSuccess = function () {
        var uploadResp = {
          uploadURL: upload.url
        };

        _this2.resetUploaderReferences(file.id);

        queuedRequest.done();

        _this2.uppy.emit('upload-success', file, uploadResp);

        if (upload.url) {
          _this2.uppy.log("Download " + upload.file.name + " from " + upload.url);
        }

        resolve(upload);
      };

      var copyProp = function copyProp(obj, srcProp, destProp) {
        if (hasProperty(obj, srcProp) && !hasProperty(obj, destProp)) {
          obj[destProp] = obj[srcProp];
        }
      };
      /** @type {Record<string, string>} */


      var meta = {};
      var metaFields = Array.isArray(opts.metaFields) ? opts.metaFields // Send along all fields by default.
      : Object.keys(file.meta);
      metaFields.forEach(function (item) {
        meta[item] = file.meta[item];
      }); // tusd uses metadata fields 'filetype' and 'filename'

      copyProp(meta, 'type', 'filetype');
      copyProp(meta, 'name', 'filename');
      uploadOptions.metadata = meta;
      var upload = new tus.Upload(file.data, uploadOptions);
      _this2.uploaders[file.id] = upload;
      _this2.uploaderEvents[file.id] = new EventTracker(_this2.uppy); // Make `resume: true` work like it did in tus-js-client v1.
      // TODO: Remove in @uppy/tus v2.

      if (opts.resume) {
        upload.findPreviousUploads().then(function (previousUploads) {
          var previousUpload = previousUploads[0];

          if (previousUpload) {
            _this2.uppy.log("[Tus] Resuming upload of " + file.id + " started at " + previousUpload.creationTime);

            upload.resumeFromPreviousUpload(previousUpload);
          }
        });
      }

      var queuedRequest = _this2.requests.run(function () {
        if (!file.isPaused) {
          // Ensure this gets scheduled to run _after_ `findPreviousUploads()` returns.
          // TODO: Remove in @uppy/tus v2.
          Promise.resolve().then(function () {
            upload.start();
          });
        } // Don't do anything here, the caller will take care of cancelling the upload itself
        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be
        // called when this request is still in the queue, and has not been started yet, too. At
        // that point this cancellation function is not going to be called.
        // Also, we need to remove the request from the queue _without_ destroying everything
        // related to this upload to handle pauses.


        return function () {};
      });

      _this2.onFileRemove(file.id, function (targetFileID) {
        queuedRequest.abort();

        _this2.resetUploaderReferences(file.id, {
          abort: !!upload.url
        });

        resolve("upload " + targetFileID + " was removed");
      });

      _this2.onPause(file.id, function (isPaused) {
        if (isPaused) {
          // Remove this file from the queue so another file can start in its place.
          queuedRequest.abort();
          upload.abort();
        } else {
          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.
          queuedRequest.abort();
          queuedRequest = _this2.requests.run(function () {
            upload.start();
            return function () {};
          });
        }
      });

      _this2.onPauseAll(file.id, function () {
        queuedRequest.abort();
        upload.abort();
      });

      _this2.onCancelAll(file.id, function () {
        queuedRequest.abort();

        _this2.resetUploaderReferences(file.id, {
          abort: !!upload.url
        });

        resolve("upload " + file.id + " was canceled");
      });

      _this2.onResumeAll(file.id, function () {
        queuedRequest.abort();

        if (file.error) {
          upload.abort();
        }

        queuedRequest = _this2.requests.run(function () {
          upload.start();
          return function () {};
        });
      });
    }).catch(function (err) {
      _this2.uppy.emit('upload-error', file, err);

      throw err;
    });
  }
  /**
   * @param {UppyFile} file for use with upload
   * @param {number} current file in a queue
   * @param {number} total number of files in a queue
   * @returns {Promise<void>}
   */
  ;

  _proto.uploadRemote = function uploadRemote(file, current, total) {
    var _this3 = this;

    this.resetUploaderReferences(file.id);

    var opts = _extends({}, this.opts);

    if (file.tus) {
      // Install file-specific upload overrides.
      _extends(opts, file.tus);
    }

    this.uppy.emit('upload-started', file);
    this.uppy.log(file.remote.url);

    if (file.serverToken) {
      return this.connectToServerSocket(file);
    }

    return new Promise(function (resolve, reject) {
      var Client = file.remote.providerOptions.provider ? Provider : RequestClient;
      var client = new Client(_this3.uppy, file.remote.providerOptions); // !! cancellation is NOT supported at this stage yet

      client.post(file.remote.url, _extends({}, file.remote.body, {
        endpoint: opts.endpoint,
        uploadUrl: opts.uploadUrl,
        protocol: 'tus',
        size: file.data.size,
        headers: opts.headers,
        metadata: file.meta
      })).then(function (res) {
        _this3.uppy.setFileState(file.id, {
          serverToken: res.token
        });

        file = _this3.uppy.getFile(file.id);
        return _this3.connectToServerSocket(file);
      }).then(function () {
        resolve();
      }).catch(function (err) {
        _this3.uppy.emit('upload-error', file, err);

        reject(err);
      });
    });
  }
  /**
   * See the comment on the upload() method.
   *
   * Additionally, when an upload is removed, completed, or cancelled, we need to close the WebSocket connection. This is handled by the resetUploaderReferences() function, so the same guidelines apply as in upload().
   *
   * @param {UppyFile} file
   */
  ;

  _proto.connectToServerSocket = function connectToServerSocket(file) {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
      var token = file.serverToken;
      var host = getSocketHost(file.remote.companionUrl);
      var socket = new Socket({
        target: host + "/api/" + token,
        autoOpen: false
      });
      _this4.uploaderSockets[file.id] = socket;
      _this4.uploaderEvents[file.id] = new EventTracker(_this4.uppy);

      _this4.onFileRemove(file.id, function () {
        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion
        // @todo don't send pause event in the next major release.

        socket.send('pause', {});
        socket.send('cancel', {});

        _this4.resetUploaderReferences(file.id);

        resolve("upload " + file.id + " was removed");
      });

      _this4.onPause(file.id, function (isPaused) {
        if (isPaused) {
          // Remove this file from the queue so another file can start in its place.
          queuedRequest.abort();
          socket.send('pause', {});
        } else {
          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.
          queuedRequest.abort();
          queuedRequest = _this4.requests.run(function () {
            socket.send('resume', {});
            return function () {};
          });
        }
      });

      _this4.onPauseAll(file.id, function () {
        queuedRequest.abort();
        socket.send('pause', {});
      });

      _this4.onCancelAll(file.id, function () {
        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion
        // @todo don't send pause event in the next major release.

        socket.send('pause', {});
        socket.send('cancel', {});

        _this4.resetUploaderReferences(file.id);

        resolve("upload " + file.id + " was canceled");
      });

      _this4.onResumeAll(file.id, function () {
        queuedRequest.abort();

        if (file.error) {
          socket.send('pause', {});
        }

        queuedRequest = _this4.requests.run(function () {
          socket.send('resume', {});
          return function () {};
        });
      });

      _this4.onRetry(file.id, function () {
        // Only do the retry if the upload is actually in progress;
        // else we could try to send these messages when the upload is still queued.
        // We may need a better check for this since the socket may also be closed
        // for other reasons, like network failures.
        if (socket.isOpen) {
          socket.send('pause', {});
          socket.send('resume', {});
        }
      });

      _this4.onRetryAll(file.id, function () {
        // See the comment in the onRetry() call
        if (socket.isOpen) {
          socket.send('pause', {});
          socket.send('resume', {});
        }
      });

      socket.on('progress', function (progressData) {
        return emitSocketProgress(_this4, progressData, file);
      });
      socket.on('error', function (errData) {
        var message = errData.error.message;

        var error = _extends(new Error(message), {
          cause: errData.error
        }); // If the remote retry optimisation should not be used,
        // close the socketthis will tell companion to clear state and delete the file.


        if (!_this4.opts.useFastRemoteRetry) {
          _this4.resetUploaderReferences(file.id); // Remove the serverToken so that a new one will be created for the retry.


          _this4.uppy.setFileState(file.id, {
            serverToken: null
          });
        } else {
          socket.close();
        }

        _this4.uppy.emit('upload-error', file, error);

        queuedRequest.done();
        reject(error);
      });
      socket.on('success', function (data) {
        var uploadResp = {
          uploadURL: data.url
        };

        _this4.uppy.emit('upload-success', file, uploadResp);

        _this4.resetUploaderReferences(file.id);

        queuedRequest.done();
        resolve();
      });

      var queuedRequest = _this4.requests.run(function () {
        socket.open();

        if (file.isPaused) {
          socket.send('pause', {});
        } // Don't do anything here, the caller will take care of cancelling the upload itself
        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be
        // called when this request is still in the queue, and has not been started yet, too. At
        // that point this cancellation function is not going to be called.
        // Also, we need to remove the request from the queue _without_ destroying everything
        // related to this upload to handle pauses.


        return function () {};
      });
    });
  }
  /**
   * Store the uploadUrl on the file options, so that when Golden Retriever
   * restores state, we will continue uploading to the correct URL.
   *
   * @param {UppyFile} file
   * @param {string} uploadURL
   */
  ;

  _proto.onReceiveUploadUrl = function onReceiveUploadUrl(file, uploadURL) {
    var currentFile = this.uppy.getFile(file.id);
    if (!currentFile) return; // Only do the update if we didn't have an upload URL yet.

    if (!currentFile.tus || currentFile.tus.uploadUrl !== uploadURL) {
      this.uppy.log('[Tus] Storing upload url');
      this.uppy.setFileState(currentFile.id, {
        tus: _extends({}, currentFile.tus, {
          uploadUrl: uploadURL
        })
      });
    }
  }
  /**
   * @param {string} fileID
   * @param {function(string): void} cb
   */
  ;

  _proto.onFileRemove = function onFileRemove(fileID, cb) {
    this.uploaderEvents[fileID].on('file-removed', function (file) {
      if (fileID === file.id) cb(file.id);
    });
  }
  /**
   * @param {string} fileID
   * @param {function(boolean): void} cb
   */
  ;

  _proto.onPause = function onPause(fileID, cb) {
    this.uploaderEvents[fileID].on('upload-pause', function (targetFileID, isPaused) {
      if (fileID === targetFileID) {
        // const isPaused = this.uppy.pauseResume(fileID)
        cb(isPaused);
      }
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onRetry = function onRetry(fileID, cb) {
    this.uploaderEvents[fileID].on('upload-retry', function (targetFileID) {
      if (fileID === targetFileID) {
        cb();
      }
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onRetryAll = function onRetryAll(fileID, cb) {
    var _this5 = this;

    this.uploaderEvents[fileID].on('retry-all', function (filesToRetry) {
      if (!_this5.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onPauseAll = function onPauseAll(fileID, cb) {
    var _this6 = this;

    this.uploaderEvents[fileID].on('pause-all', function () {
      if (!_this6.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onCancelAll = function onCancelAll(fileID, cb) {
    var _this7 = this;

    this.uploaderEvents[fileID].on('cancel-all', function () {
      if (!_this7.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onResumeAll = function onResumeAll(fileID, cb) {
    var _this8 = this;

    this.uploaderEvents[fileID].on('resume-all', function () {
      if (!_this8.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {(UppyFile | FailedUppyFile)[]} files
   */
  ;

  _proto.uploadFiles = function uploadFiles(files) {
    var _this9 = this;

    var promises = files.map(function (file, i) {
      var current = i + 1;
      var total = files.length;

      if ('error' in file && file.error) {
        return Promise.reject(new Error(file.error));
      }

      if (file.isRemote) {
        // We emit upload-started here, so that it's also emitted for files
        // that have to wait due to the `limit` option.
        // Don't double-emit upload-started for Golden Retriever-restored files that were already started
        if (!file.progress.uploadStarted || !file.isRestored) {
          _this9.uppy.emit('upload-started', file);
        }

        return _this9.uploadRemote(file, current, total);
      } // Don't double-emit upload-started for Golden Retriever-restored files that were already started


      if (!file.progress.uploadStarted || !file.isRestored) {
        _this9.uppy.emit('upload-started', file);
      }

      return _this9.upload(file, current, total);
    });
    return settle(promises);
  }
  /**
   * @param {string[]} fileIDs
   */
  ;

  _proto.handleUpload = function handleUpload(fileIDs) {
    var _this10 = this;

    if (fileIDs.length === 0) {
      this.uppy.log('[Tus] No files to upload');
      return Promise.resolve();
    }

    if (this.opts.limit === 0) {
      this.uppy.log('[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0', 'warning');
    }

    this.uppy.log('[Tus] Uploading...');
    var filesToUpload = fileIDs.map(function (fileID) {
      return _this10.uppy.getFile(fileID);
    });
    return this.uploadFiles(filesToUpload).then(function () {
      return null;
    });
  };

  _proto.install = function install() {
    this.uppy.setState({
      capabilities: _extends({}, this.uppy.getState().capabilities, {
        resumableUploads: true
      })
    });
    this.uppy.addUploader(this.handleUpload);
    this.uppy.on('reset-progress', this.handleResetProgress);

    if (this.opts.autoRetry) {
      this.uppy.on('back-online', this.uppy.retryAll);
    }
  };

  _proto.uninstall = function uninstall() {
    this.uppy.setState({
      capabilities: _extends({}, this.uppy.getState().capabilities, {
        resumableUploads: false
      })
    });
    this.uppy.removeUploader(this.handleUpload);

    if (this.opts.autoRetry) {
      this.uppy.off('back-online', this.uppy.retryAll);
    }
  };

  return Tus;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":200,"./../../companion-client":68,"./../../core":73,"./../../utils/lib/EventTracker":208,"./../../utils/lib/NetworkError":210,"./../../utils/lib/RateLimitedQueue":211,"./../../utils/lib/emitSocketProgress":215,"./../../utils/lib/getSocketHost":230,"./../../utils/lib/hasProperty":234,"./../../utils/lib/isNetworkError":237,"./../../utils/lib/settle":244,"./getFingerprint":201,"tus-js-client":48}],203:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],204:[function(require,module,exports){
module.exports={
  "name": "@uppy/url",
  "description": "The Url plugin lets users import files from the Internet. Paste any URL and itll be added!",
  "version": "1.5.23",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "url",
    "import from url",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],205:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var UrlUI = /*#__PURE__*/function (_Component) {
  _inheritsLoose(UrlUI, _Component);

  function UrlUI(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.handleKeyPress = _this.handleKeyPress.bind(_assertThisInitialized(_this));
    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = UrlUI.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.input.value = '';
  };

  _proto.handleKeyPress = function handleKeyPress(ev) {
    if (ev.keyCode === 13) {
      this.props.addFile(this.input.value);
    }
  };

  _proto.handleClick = function handleClick() {
    this.props.addFile(this.input.value);
  };

  _proto.render = function render() {
    var _this2 = this;

    return h("div", {
      className: "uppy-Url"
    }, h("input", {
      className: "uppy-u-reset uppy-c-textInput uppy-Url-input",
      type: "text",
      "aria-label": this.props.i18n('enterUrlToImport'),
      placeholder: this.props.i18n('enterUrlToImport'),
      onKeyUp: this.handleKeyPress,
      ref: function ref(input) {
        _this2.input = input;
      },
      "data-uppy-super-focusable": true
    }), h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Url-importButton",
      type: "button",
      onClick: this.handleClick
    }, this.props.i18n('import')));
  };

  return UrlUI;
}(Component);

module.exports = UrlUI;

},{"preact":203}],206:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Translator = require('./../../utils/lib/Translator');

var _require2 = require('preact'),
    h = _require2.h;

var _require3 = require('./../../companion-client'),
    RequestClient = _require3.RequestClient;

var UrlUI = require('./UrlUI.js');

var forEachDroppedOrPastedUrl = require('./utils/forEachDroppedOrPastedUrl');

function UrlIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("rect", {
    className: "uppy-ProviderIconBg",
    fill: "#FF753E",
    width: "32",
    height: "32",
    rx: "16"
  }), h("path", {
    d: "M22.788 15.389l-2.199 2.19a3.184 3.184 0 0 1-.513.437c-.806.584-1.686.876-2.638.876a4.378 4.378 0 0 1-3.519-1.752c-.22-.292-.146-.802.147-1.021.293-.22.806-.146 1.026.146.953 1.313 2.785 1.532 4.105.583a.571.571 0 0 0 .293-.292l2.199-2.189c1.1-1.167 1.1-2.992-.073-4.086a2.976 2.976 0 0 0-4.105 0l-1.246 1.24a.71.71 0 0 1-1.026 0 .703.703 0 0 1 0-1.022l1.246-1.24a4.305 4.305 0 0 1 6.083 0c1.833 1.605 1.906 4.451.22 6.13zm-7.183 5.035l-1.246 1.24a2.976 2.976 0 0 1-4.105 0c-1.172-1.094-1.172-2.991-.073-4.086l2.2-2.19.292-.291c.66-.438 1.393-.657 2.2-.584.805.146 1.465.51 1.905 1.168.22.292.733.365 1.026.146.293-.22.367-.73.147-1.022-.733-.949-1.76-1.532-2.859-1.678-1.1-.22-2.272.073-3.225.802l-.44.438-2.199 2.19c-1.686 1.75-1.612 4.524.074 6.202.88.803 1.979 1.241 3.078 1.241 1.1 0 2.199-.438 3.079-1.24l1.246-1.241a.703.703 0 0 0 0-1.022c-.294-.292-.807-.365-1.1-.073z",
    fill: "#FFF",
    fillRule: "nonzero"
  })));
}
/**
 * Url
 *
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Url, _Plugin);

  function Url(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Url';
    _this.title = _this.opts.title || 'Link';
    _this.type = 'acquirer';

    _this.icon = function () {
      return h(UrlIcon, null);
    }; // Set default options and locale


    _this.defaultLocale = {
      strings: {
        import: 'Import',
        enterUrlToImport: 'Enter URL to import a file',
        failedToFetch: 'Companion failed to fetch this URL, please make sure its correct',
        enterCorrectUrl: 'Incorrect URL: Please make sure you are entering a direct link to a file'
      }
    };
    var defaultOptions = {};
    _this.opts = _extends({}, defaultOptions, opts);

    _this.i18nInit();

    _this.hostname = _this.opts.companionUrl;

    if (!_this.hostname) {
      throw new Error('Companion hostname is required, please consult https://uppy.io/docs/companion');
    } // Bind all event handlers for referencability


    _this.getMeta = _this.getMeta.bind(_assertThisInitialized(_this));
    _this.addFile = _this.addFile.bind(_assertThisInitialized(_this));
    _this.handleRootDrop = _this.handleRootDrop.bind(_assertThisInitialized(_this));
    _this.handleRootPaste = _this.handleRootPaste.bind(_assertThisInitialized(_this));
    _this.client = new RequestClient(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionCookiesRule: _this.opts.companionCookiesRule
    });
    return _this;
  }

  var _proto = Url.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.getFileNameFromUrl = function getFileNameFromUrl(url) {
    return url.substring(url.lastIndexOf('/') + 1);
  };

  _proto.checkIfCorrectURL = function checkIfCorrectURL(url) {
    if (!url) return false;
    var protocol = url.match(/^([a-z0-9]+):\/\//)[1];

    if (protocol !== 'http' && protocol !== 'https') {
      return false;
    }

    return true;
  };

  _proto.addProtocolToURL = function addProtocolToURL(url) {
    var protocolRegex = /^[a-z0-9]+:\/\//;
    var defaultProtocol = 'http://';

    if (protocolRegex.test(url)) {
      return url;
    }

    return defaultProtocol + url;
  };

  _proto.getMeta = function getMeta(url) {
    var _this2 = this;

    return this.client.post('url/meta', {
      url: url
    }).then(function (res) {
      if (res.error) {
        _this2.uppy.log('[URL] Error:');

        _this2.uppy.log(res.error);

        throw new Error('Failed to fetch the file');
      }

      return res;
    });
  };

  _proto.addFile = function addFile(url) {
    var _this3 = this;

    url = this.addProtocolToURL(url);

    if (!this.checkIfCorrectURL(url)) {
      this.uppy.log("[URL] Incorrect URL entered: " + url);
      this.uppy.info(this.i18n('enterCorrectUrl'), 'error', 4000);
      return;
    }

    return this.getMeta(url).then(function (meta) {
      var tagFile = {
        source: _this3.id,
        name: _this3.getFileNameFromUrl(url),
        type: meta.type,
        data: {
          size: meta.size
        },
        isRemote: true,
        body: {
          url: url
        },
        remote: {
          companionUrl: _this3.opts.companionUrl,
          url: _this3.hostname + "/url/get",
          body: {
            fileId: url,
            url: url
          },
          providerOptions: _this3.client.opts
        }
      };
      return tagFile;
    }).then(function (tagFile) {
      _this3.uppy.log('[Url] Adding remote file');

      try {
        return _this3.uppy.addFile(tagFile);
      } catch (err) {
        if (!err.isRestriction) {
          _this3.uppy.log(err);
        }

        return err;
      }
    }).catch(function (err) {
      _this3.uppy.log(err);

      _this3.uppy.info({
        message: _this3.i18n('failedToFetch'),
        details: err
      }, 'error', 4000);

      return err;
    });
  };

  _proto.handleRootDrop = function handleRootDrop(e) {
    var _this4 = this;

    forEachDroppedOrPastedUrl(e.dataTransfer, 'drop', function (url) {
      _this4.uppy.log("[URL] Adding file from dropped url: " + url);

      _this4.addFile(url);
    });
  };

  _proto.handleRootPaste = function handleRootPaste(e) {
    var _this5 = this;

    forEachDroppedOrPastedUrl(e.clipboardData, 'paste', function (url) {
      _this5.uppy.log("[URL] Adding file from pasted url: " + url);

      _this5.addFile(url);
    });
  };

  _proto.render = function render(state) {
    return h(UrlUI, {
      i18n: this.i18n,
      addFile: this.addFile
    });
  };

  _proto.install = function install() {
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.unmount();
  };

  return Url;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":204,"./../../companion-client":68,"./../../core":73,"./../../utils/lib/Translator":212,"./UrlUI.js":205,"./utils/forEachDroppedOrPastedUrl":207,"preact":203}],207:[function(require,module,exports){
var toArray = require('./../../../utils/lib/toArray');
/*
  SITUATION

    1. Cross-browser dataTransfer.items

      paste in chrome [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}
      paste in safari [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}
      2: {kind: "string", type: "text/plain"}
      3: {kind: "string", type: "text/uri-list"}
      paste in firefox [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}

      paste in chrome [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}
      paste in safari [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}
      1: {kind: "string", type: "text/uri-list"}
      paste in firefox [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}

      drop in chrome [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/html"}
      drop in safari [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/html"}
      2: {kind: "file", type: "image/png"}
      drop in firefox [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/x-moz-url"}
      2: {kind: "string", type: "text/plain"}

    2. We can determine if it's a 'copypaste' or a 'drop', but we can't discern between [Copy Image] and [Copy Image Address].

  CONCLUSION

    1. 'paste' ([Copy Image] or [Copy Image Address], we can't discern between these two)
      Don't do anything if there is 'file' item. .handlePaste in the DashboardPlugin will deal with all 'file' items.
      If there are no 'file' items - handle 'text/plain' items.

    2. 'drop'
      Take 'text/uri-list' items. Safari has an additional item of .kind === 'file', and you may worry about the item being duplicated (first by DashboardPlugin, and then by UrlPlugin, now), but don't. Directory handling code won't pay attention to this particular item of kind 'file'.
*/

/**
 * Finds all links dropped/pasted from one browser window to another.
 *
 * @param {object} dataTransfer - DataTransfer instance, e.g. e.clipboardData, or e.dataTransfer
 * @param {string} isDropOrPaste - either 'drop' or 'paste'
 * @param {Function} callback - (urlString) => {}
 */


module.exports = function forEachDroppedOrPastedUrl(dataTransfer, isDropOrPaste, callback) {
  var items = toArray(dataTransfer.items);
  var urlItems;

  switch (isDropOrPaste) {
    case 'paste':
      {
        var atLeastOneFileIsDragged = items.some(function (item) {
          return item.kind === 'file';
        });

        if (atLeastOneFileIsDragged) {
          return;
        }

        urlItems = items.filter(function (item) {
          return item.kind === 'string' && item.type === 'text/plain';
        });
        break;
      }

    case 'drop':
      {
        urlItems = items.filter(function (item) {
          return item.kind === 'string' && item.type === 'text/uri-list';
        });
        break;
      }

    default:
      {
        throw new Error("isDropOrPaste must be either 'drop' or 'paste', but it's " + isDropOrPaste);
      }
  }

  urlItems.forEach(function (item) {
    item.getAsString(function (urlString) {
      return callback(urlString);
    });
  });
};

},{"./../../../utils/lib/toArray":245}],208:[function(require,module,exports){
/**
 * Create a wrapper around an event emitter with a `remove` method to remove
 * all events that were added using the wrapped emitter.
 */
module.exports = /*#__PURE__*/function () {
  function EventTracker(emitter) {
    this._events = [];
    this._emitter = emitter;
  }

  var _proto = EventTracker.prototype;

  _proto.on = function on(event, fn) {
    this._events.push([event, fn]);

    return this._emitter.on(event, fn);
  };

  _proto.remove = function remove() {
    var _this = this;

    this._events.forEach(function (_ref) {
      var event = _ref[0],
          fn = _ref[1];

      _this._emitter.off(event, fn);
    });
  };

  return EventTracker;
}();

},{}],209:[function(require,module,exports){
module.exports = ['a[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'area[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'input:not([disabled]):not([inert]):not([aria-hidden])', 'select:not([disabled]):not([inert]):not([aria-hidden])', 'textarea:not([disabled]):not([inert]):not([aria-hidden])', 'button:not([disabled]):not([inert]):not([aria-hidden])', 'iframe:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'object:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'embed:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[contenteditable]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[tabindex]:not([tabindex^="-"]):not([inert]):not([aria-hidden])'];

},{}],210:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var NetworkError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(NetworkError, _Error);

  function NetworkError(error, xhr) {
    var _this;

    if (xhr === void 0) {
      xhr = null;
    }

    _this = _Error.call(this, "This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.\n\nSource error: [" + error + "]") || this;
    _this.isNetworkError = true;
    _this.request = xhr;
    return _this;
  }

  return NetworkError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

module.exports = NetworkError;

},{}],211:[function(require,module,exports){
var findIndex = require('./findIndex');

function createCancelError() {
  return new Error('Cancelled');
}

module.exports = /*#__PURE__*/function () {
  function RateLimitedQueue(limit) {
    if (typeof limit !== 'number' || limit === 0) {
      this.limit = Infinity;
    } else {
      this.limit = limit;
    }

    this.activeRequests = 0;
    this.queuedHandlers = [];
  }

  var _proto = RateLimitedQueue.prototype;

  _proto._call = function _call(fn) {
    var _this = this;

    this.activeRequests += 1;
    var _done = false;
    var cancelActive;

    try {
      cancelActive = fn();
    } catch (err) {
      this.activeRequests -= 1;
      throw err;
    }

    return {
      abort: function abort() {
        if (_done) return;
        _done = true;
        _this.activeRequests -= 1;
        cancelActive();

        _this._queueNext();
      },
      done: function done() {
        if (_done) return;
        _done = true;
        _this.activeRequests -= 1;

        _this._queueNext();
      }
    };
  };

  _proto._queueNext = function _queueNext() {
    var _this2 = this;

    // Do it soon but not immediately, this allows clearing out the entire queue synchronously
    // one by one without continuously _advancing_ it (and starting new tasks before immediately
    // aborting them)
    Promise.resolve().then(function () {
      _this2._next();
    });
  };

  _proto._next = function _next() {
    if (this.activeRequests >= this.limit) {
      return;
    }

    if (this.queuedHandlers.length === 0) {
      return;
    } // Dispatch the next request, and update the abort/done handlers
    // so that cancelling it does the Right Thing (and doesn't just try
    // to dequeue an already-running request).


    var next = this.queuedHandlers.shift();

    var handler = this._call(next.fn);

    next.abort = handler.abort;
    next.done = handler.done;
  };

  _proto._queue = function _queue(fn, options) {
    var _this3 = this;

    if (options === void 0) {
      options = {};
    }

    var handler = {
      fn: fn,
      priority: options.priority || 0,
      abort: function abort() {
        _this3._dequeue(handler);
      },
      done: function done() {
        throw new Error('Cannot mark a queued request as done: this indicates a bug');
      }
    };
    var index = findIndex(this.queuedHandlers, function (other) {
      return handler.priority > other.priority;
    });

    if (index === -1) {
      this.queuedHandlers.push(handler);
    } else {
      this.queuedHandlers.splice(index, 0, handler);
    }

    return handler;
  };

  _proto._dequeue = function _dequeue(handler) {
    var index = this.queuedHandlers.indexOf(handler);

    if (index !== -1) {
      this.queuedHandlers.splice(index, 1);
    }
  };

  _proto.run = function run(fn, queueOptions) {
    if (this.activeRequests < this.limit) {
      return this._call(fn);
    }

    return this._queue(fn, queueOptions);
  };

  _proto.wrapPromiseFunction = function wrapPromiseFunction(fn, queueOptions) {
    var _this4 = this;

    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var queuedRequest;
      var outerPromise = new Promise(function (resolve, reject) {
        queuedRequest = _this4.run(function () {
          var cancelError;
          var innerPromise;

          try {
            innerPromise = Promise.resolve(fn.apply(void 0, args));
          } catch (err) {
            innerPromise = Promise.reject(err);
          }

          innerPromise.then(function (result) {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              resolve(result);
            }
          }, function (err) {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              reject(err);
            }
          });
          return function () {
            cancelError = createCancelError();
          };
        }, queueOptions);
      });

      outerPromise.abort = function () {
        queuedRequest.abort();
      };

      return outerPromise;
    };
  };

  return RateLimitedQueue;
}();

},{"./findIndex":219}],212:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var has = require('./hasProperty');
/**
 * Translates strings with interpolation & pluralization support.
 * Extensible with custom dictionaries and pluralization functions.
 *
 * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,
 * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded
 * and can be easily added among with dictionaries, nested objects are used for pluralization
 * as opposed to `||||` delimeter
 *
 * Usage example: `translator.translate('files_chosen', {smart_count: 3})`
 */


module.exports = /*#__PURE__*/function () {
  /**
   * @param {object|Array<object>} locales - locale or list of locales.
   */
  function Translator(locales) {
    var _this = this;

    this.locale = {
      strings: {},
      pluralize: function pluralize(n) {
        if (n === 1) {
          return 0;
        }

        return 1;
      }
    };

    if (Array.isArray(locales)) {
      locales.forEach(function (locale) {
        return _this._apply(locale);
      });
    } else {
      this._apply(locales);
    }
  }

  var _proto = Translator.prototype;

  _proto._apply = function _apply(locale) {
    if (!locale || !locale.strings) {
      return;
    }

    var prevLocale = this.locale;
    this.locale = _extends({}, prevLocale, {
      strings: _extends({}, prevLocale.strings, locale.strings)
    });
    this.locale.pluralize = locale.pluralize || prevLocale.pluralize;
  }
  /**
   * Takes a string with placeholder variables like `%{smart_count} file selected`
   * and replaces it with values from options `{smart_count: 5}`
   *
   * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
   * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
   *
   * @param {string} phrase that needs interpolation, with placeholders
   * @param {object} options with values that will be used to replace placeholders
   * @returns {any[]} interpolated
   */
  ;

  _proto.interpolate = function interpolate(phrase, options) {
    var _String$prototype = String.prototype,
        split = _String$prototype.split,
        replace = _String$prototype.replace;
    var dollarRegex = /\$/g;
    var dollarBillsYall = '$$$$';
    var interpolated = [phrase];

    for (var arg in options) {
      if (arg !== '_' && has(options, arg)) {
        // Ensure replacement value is escaped to prevent special $-prefixed
        // regex replace tokens. the "$$$$" is needed because each "$" needs to
        // be escaped with "$" itself, and we need two in the resulting output.
        var replacement = options[arg];

        if (typeof replacement === 'string') {
          replacement = replace.call(options[arg], dollarRegex, dollarBillsYall);
        } // We create a new `RegExp` each time instead of using a more-efficient
        // string replace so that the same argument can be replaced multiple times
        // in the same phrase.


        interpolated = insertReplacement(interpolated, new RegExp("%\\{" + arg + "\\}", 'g'), replacement);
      }
    }

    return interpolated;

    function insertReplacement(source, rx, replacement) {
      var newParts = [];
      source.forEach(function (chunk) {
        // When the source contains multiple placeholders for interpolation,
        // we should ignore chunks that are not strings, because those
        // can be JSX objects and will be otherwise incorrectly turned into strings.
        // Without this condition wed get this: [object Object] hello [object Object] my <button>
        if (typeof chunk !== 'string') {
          return newParts.push(chunk);
        }

        split.call(chunk, rx).forEach(function (raw, i, list) {
          if (raw !== '') {
            newParts.push(raw);
          } // Interlace with the `replacement` value


          if (i < list.length - 1) {
            newParts.push(replacement);
          }
        });
      });
      return newParts;
    }
  }
  /**
   * Public translate method
   *
   * @param {string} key
   * @param {object} options with values that will be used later to replace placeholders in string
   * @returns {string} translated (and interpolated)
   */
  ;

  _proto.translate = function translate(key, options) {
    return this.translateArray(key, options).join('');
  }
  /**
   * Get a translation and return the translated and interpolated parts as an array.
   *
   * @param {string} key
   * @param {object} options with values that will be used to replace placeholders
   * @returns {Array} The translated and interpolated parts, in order.
   */
  ;

  _proto.translateArray = function translateArray(key, options) {
    if (!has(this.locale.strings, key)) {
      throw new Error("missing string: " + key);
    }

    var string = this.locale.strings[key];
    var hasPluralForms = typeof string === 'object';

    if (hasPluralForms) {
      if (options && typeof options.smart_count !== 'undefined') {
        var plural = this.locale.pluralize(options.smart_count);
        return this.interpolate(string[plural], options);
      }

      throw new Error('Attempted to use a string with plural forms, but no value was given for %{smart_count}');
    }

    return this.interpolate(string, options);
  };

  return Translator;
}();

},{"./hasProperty":234}],213:[function(require,module,exports){
var dataURItoBlob = require('./dataURItoBlob');
/**
 * Save a <canvas> element's content to a Blob object.
 *
 * @param {HTMLCanvasElement} canvas
 * @returns {Promise}
 */


module.exports = function canvasToBlob(canvas, type, quality) {
  if (canvas.toBlob) {
    return new Promise(function (resolve) {
      canvas.toBlob(resolve, type, quality);
    });
  }

  return Promise.resolve().then(function () {
    return dataURItoBlob(canvas.toDataURL(type, quality), {});
  });
};

},{"./dataURItoBlob":214}],214:[function(require,module,exports){
module.exports = function dataURItoBlob(dataURI, opts, toFile) {
  // get the base64 data
  var data = dataURI.split(',')[1]; // user may provide mime type, if not get it from data URI

  var mimeType = opts.mimeType || dataURI.split(',')[0].split(':')[1].split(';')[0]; // default to plain/text if data URI has no mimeType

  if (mimeType == null) {
    mimeType = 'plain/text';
  }

  var binary = atob(data);
  var array = [];

  for (var i = 0; i < binary.length; i++) {
    array.push(binary.charCodeAt(i));
  }

  var bytes;

  try {
    bytes = new Uint8Array(array); // eslint-disable-line compat/compat
  } catch (err) {
    return null;
  } // Convert to a File?


  if (toFile) {
    return new File([bytes], opts.name || '', {
      type: mimeType
    });
  }

  return new Blob([bytes], {
    type: mimeType
  });
};

},{}],215:[function(require,module,exports){
var throttle = require('lodash.throttle');

function _emitSocketProgress(uploader, progressData, file) {
  var progress = progressData.progress,
      bytesUploaded = progressData.bytesUploaded,
      bytesTotal = progressData.bytesTotal;

  if (progress) {
    uploader.uppy.log("Upload progress: " + progress);
    uploader.uppy.emit('upload-progress', file, {
      uploader: uploader,
      bytesUploaded: bytesUploaded,
      bytesTotal: bytesTotal
    });
  }
}

module.exports = throttle(_emitSocketProgress, 300, {
  leading: true,
  trailing: true
});

},{"lodash.throttle":32}],216:[function(require,module,exports){
var NetworkError = require('./NetworkError');
/**
 * Wrapper around window.fetch that throws a NetworkError when appropriate
 */


module.exports = function fetchWithNetworkError() {
  return fetch.apply(void 0, arguments).catch(function (err) {
    if (err.name === 'AbortError') {
      throw err;
    } else {
      throw new NetworkError(err);
    }
  });
};

},{"./NetworkError":210}],217:[function(require,module,exports){
var isDOMElement = require('./isDOMElement');
/**
 * Find one or more DOM elements.
 *
 * @param {string} element
 * @returns {Array|null}
 */


module.exports = function findAllDOMElements(element) {
  if (typeof element === 'string') {
    var elements = [].slice.call(document.querySelectorAll(element));
    return elements.length > 0 ? elements : null;
  }

  if (typeof element === 'object' && isDOMElement(element)) {
    return [element];
  }
};

},{"./isDOMElement":235}],218:[function(require,module,exports){
var isDOMElement = require('./isDOMElement');
/**
 * Find a DOM element.
 *
 * @param {Node|string} element
 * @returns {Node|null}
 */


module.exports = function findDOMElement(element, context) {
  if (context === void 0) {
    context = document;
  }

  if (typeof element === 'string') {
    return context.querySelector(element);
  }

  if (isDOMElement(element)) {
    return element;
  }
};

},{"./isDOMElement":235}],219:[function(require,module,exports){
/**
 * Array.prototype.findIndex ponyfill for old browsers.
 *
 * @param {Array} array
 * @param {Function} predicate
 * @returns {number}
 */
module.exports = function findIndex(array, predicate) {
  for (var i = 0; i < array.length; i++) {
    if (predicate(array[i])) return i;
  }

  return -1;
};

},{}],220:[function(require,module,exports){
/**
 * Takes a file object and turns it into fileID, by converting file.name to lowercase,
 * removing extra characters and adding type, size and lastModified
 *
 * @param {object} file
 * @returns {string} the fileID
 */
module.exports = function generateFileID(file) {
  // It's tempting to do `[items].filter(Boolean).join('-')` here, but that
  // is slower! simple string concatenation is fast
  var id = 'uppy';

  if (typeof file.name === 'string') {
    id += "-" + encodeFilename(file.name.toLowerCase());
  }

  if (file.type !== undefined) {
    id += "-" + file.type;
  }

  if (file.meta && typeof file.meta.relativePath === 'string') {
    id += "-" + encodeFilename(file.meta.relativePath.toLowerCase());
  }

  if (file.data.size !== undefined) {
    id += "-" + file.data.size;
  }

  if (file.data.lastModified !== undefined) {
    id += "-" + file.data.lastModified;
  }

  return id;
};

function encodeFilename(name) {
  var suffix = '';
  return name.replace(/[^A-Z0-9]/ig, function (character) {
    suffix += "-" + encodeCharacter(character);
    return '/';
  }) + suffix;
}

function encodeCharacter(character) {
  return character.charCodeAt(0).toString(32);
}

},{}],221:[function(require,module,exports){
module.exports = function getBytesRemaining(fileProgress) {
  return fileProgress.bytesTotal - fileProgress.bytesUploaded;
};

},{}],222:[function(require,module,exports){
var webkitGetAsEntryApi = require('./utils/webkitGetAsEntryApi/index');

var fallbackApi = require('./utils/fallbackApi');
/**
 * Returns a promise that resolves to the array of dropped files (if a folder is dropped, and browser supports folder parsing - promise resolves to the flat array of all files in all directories).
 * Each file has .relativePath prop appended to it (e.g. "/docs/Prague/ticket_from_prague_to_ufa.pdf") if browser supports it. Otherwise it's undefined.
 *
 * @param {DataTransfer} dataTransfer
 * @param {Function} logDropError - a function that's called every time some folder or some file error out (e.g. because of the folder name being too long on Windows). Notice that resulting promise will always be resolved anyway.
 *
 * @returns {Promise} - Array<File>
 */


module.exports = function getDroppedFiles(dataTransfer, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$logDropError = _ref.logDropError,
      logDropError = _ref$logDropError === void 0 ? function () {} : _ref$logDropError;

  // Get all files from all subdirs. Works (at least) in Chrome, Mozilla, and Safari
  if (dataTransfer.items && dataTransfer.items[0] && 'webkitGetAsEntry' in dataTransfer.items[0]) {
    return webkitGetAsEntryApi(dataTransfer, logDropError); // Otherwise just return all first-order files
  }

  return fallbackApi(dataTransfer);
};

},{"./utils/fallbackApi":223,"./utils/webkitGetAsEntryApi/index":226}],223:[function(require,module,exports){
var toArray = require('../../toArray'); // .files fallback, should be implemented in any browser


module.exports = function fallbackApi(dataTransfer) {
  var files = toArray(dataTransfer.files);
  return Promise.resolve(files);
};

},{"../../toArray":245}],224:[function(require,module,exports){
/**
 * Recursive function, calls the original callback() when the directory is entirely parsed.
 *
 * @param {FileSystemDirectoryReader} directoryReader
 * @param {Array} oldEntries
 * @param {Function} logDropError
 * @param {Function} callback - called with ([ all files and directories in that directoryReader ])
 */
module.exports = function getFilesAndDirectoriesFromDirectory(directoryReader, oldEntries, logDropError, _ref) {
  var onSuccess = _ref.onSuccess;
  directoryReader.readEntries(function (entries) {
    var newEntries = [].concat(oldEntries, entries); // According to the FileSystem API spec, getFilesAndDirectoriesFromDirectory() must be called until it calls the onSuccess with an empty array.

    if (entries.length) {
      setTimeout(function () {
        getFilesAndDirectoriesFromDirectory(directoryReader, newEntries, logDropError, {
          onSuccess: onSuccess
        });
      }, 0); // Done iterating this particular directory
    } else {
      onSuccess(newEntries);
    }
  }, // Make sure we resolve on error anyway, it's fine if only one directory couldn't be parsed!
  function (error) {
    logDropError(error);
    onSuccess(oldEntries);
  });
};

},{}],225:[function(require,module,exports){
/**
 * Get the relative path from the FileEntry#fullPath, because File#webkitRelativePath is always '', at least onDrop.
 *
 * @param {FileEntry} fileEntry
 *
 * @returns {string|null} - if file is not in a folder - return null (this is to be consistent with .relativePath-s of files selected from My Device). If file is in a folder - return its fullPath, e.g. '/simpsons/hi.jpeg'.
 */
module.exports = function getRelativePath(fileEntry) {
  // fileEntry.fullPath - "/simpsons/hi.jpeg" or undefined (for browsers that don't support it)
  // fileEntry.name - "hi.jpeg"
  if (!fileEntry.fullPath || fileEntry.fullPath === "/" + fileEntry.name) {
    return null;
  }

  return fileEntry.fullPath;
};

},{}],226:[function(require,module,exports){
var toArray = require('../../../toArray');

var getRelativePath = require('./getRelativePath');

var getFilesAndDirectoriesFromDirectory = require('./getFilesAndDirectoriesFromDirectory');

module.exports = function webkitGetAsEntryApi(dataTransfer, logDropError) {
  var files = [];
  var rootPromises = [];
  /**
   * Returns a resolved promise, when :files array is enhanced
   *
   * @param {(FileSystemFileEntry|FileSystemDirectoryEntry)} entry
   * @returns {Promise} - empty promise that resolves when :files is enhanced with a file
   */

  var createPromiseToAddFileOrParseDirectory = function createPromiseToAddFileOrParseDirectory(entry) {
    return new Promise(function (resolve) {
      // This is a base call
      if (entry.isFile) {
        // Creates a new File object which can be used to read the file.
        entry.file(function (file) {
          file.relativePath = getRelativePath(entry);
          files.push(file);
          resolve();
        }, // Make sure we resolve on error anyway, it's fine if only one file couldn't be read!
        function (error) {
          logDropError(error);
          resolve();
        }); // This is a recursive call
      } else if (entry.isDirectory) {
        var directoryReader = entry.createReader();
        getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {
          onSuccess: function onSuccess(entries) {
            var promises = entries.map(function (entry) {
              return createPromiseToAddFileOrParseDirectory(entry);
            });
            Promise.all(promises).then(function () {
              return resolve();
            });
          }
        });
      }
    });
  }; // For each dropped item, - make sure it's a file/directory, and start deepening in!


  toArray(dataTransfer.items).forEach(function (item) {
    var entry = item.webkitGetAsEntry(); // :entry can be null when we drop the url e.g.

    if (entry) {
      rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));
    }
  });
  return Promise.all(rootPromises).then(function () {
    return files;
  });
};

},{"../../../toArray":245,"./getFilesAndDirectoriesFromDirectory":224,"./getRelativePath":225}],227:[function(require,module,exports){
/**
 * Takes a full filename string and returns an object {name, extension}
 *
 * @param {string} fullFileName
 * @returns {object} {name, extension}
 */
module.exports = function getFileNameAndExtension(fullFileName) {
  var lastDot = fullFileName.lastIndexOf('.'); // these count as no extension: "no-dot", "trailing-dot."

  if (lastDot === -1 || lastDot === fullFileName.length - 1) {
    return {
      name: fullFileName,
      extension: undefined
    };
  }

  return {
    name: fullFileName.slice(0, lastDot),
    extension: fullFileName.slice(lastDot + 1)
  };
};

},{}],228:[function(require,module,exports){
var getFileNameAndExtension = require('./getFileNameAndExtension');

var mimeTypes = require('./mimeTypes');

module.exports = function getFileType(file) {
  var fileExtension = file.name ? getFileNameAndExtension(file.name).extension : null;
  fileExtension = fileExtension ? fileExtension.toLowerCase() : null;

  if (file.type) {
    // if mime type is set in the file object already, use that
    return file.type;
  }

  if (fileExtension && mimeTypes[fileExtension]) {
    // else, see if we can map extension to a mime type
    return mimeTypes[fileExtension];
  } // if all fails, fall back to a generic byte stream type


  return 'application/octet-stream';
};

},{"./getFileNameAndExtension":227,"./mimeTypes":240}],229:[function(require,module,exports){
// TODO Check which types are actually supported in browsers. Chrome likes webm
// from my testing, but we may need more.
// We could use a library but they tend to contain dozens of KBs of mappings,
// most of which will go unused, so not sure if that's worth it.
var mimeToExtensions = {
  'audio/mp3': 'mp3',
  'audio/mp4': 'mp4',
  'audio/ogg': 'ogg',
  'audio/webm': 'webm',
  'image/gif': 'gif',
  'image/heic': 'heic',
  'image/heif': 'heif',
  'image/jpeg': 'jpg',
  'image/png': 'png',
  'image/svg+xml': 'svg',
  'video/mp4': 'mp4',
  'video/ogg': 'ogv',
  'video/quicktime': 'mov',
  'video/webm': 'webm',
  'video/x-matroska': 'mkv',
  'video/x-msvideo': 'avi'
};

module.exports = function getFileTypeExtension(mimeType) {
  // Remove the ; bit in 'video/x-matroska;codecs=avc1'
  mimeType = mimeType.replace(/;.*$/, '');
  return mimeToExtensions[mimeType] || null;
};

},{}],230:[function(require,module,exports){
module.exports = function getSocketHost(url) {
  // get the host domain
  var regex = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i;
  var host = regex.exec(url)[1];
  var socketProtocol = /^http:\/\//i.test(url) ? 'ws' : 'wss';
  return socketProtocol + "://" + host;
};

},{}],231:[function(require,module,exports){
module.exports = function getSpeed(fileProgress) {
  if (!fileProgress.bytesUploaded) return 0;
  var timeElapsed = new Date() - fileProgress.uploadStarted;
  var uploadSpeed = fileProgress.bytesUploaded / (timeElapsed / 1000);
  return uploadSpeed;
};

},{}],232:[function(require,module,exports){
/**
 * Get the declared text direction for an element.
 *
 * @param {Node} element
 * @returns {string|undefined}
 */
function getTextDirection(element) {
  // There is another way to determine text direction using getComputedStyle(), as done here:
  // https://github.com/pencil-js/text-direction/blob/2a235ce95089b3185acec3b51313cbba921b3811/text-direction.js
  //
  // We do not use that approach because we are interested specifically in the _declared_ text direction.
  // If no text direction is declared, we have to provide our own explicit text direction so our
  // bidirectional CSS style sheets work.
  while (element && !element.dir) {
    element = element.parentNode;
  }

  return element ? element.dir : undefined;
}

module.exports = getTextDirection;

},{}],233:[function(require,module,exports){
/**
 * Returns a timestamp in the format of `hours:minutes:seconds`
 */
module.exports = function getTimeStamp() {
  var date = new Date();
  var hours = pad(date.getHours().toString());
  var minutes = pad(date.getMinutes().toString());
  var seconds = pad(date.getSeconds().toString());
  return hours + ":" + minutes + ":" + seconds;
};
/**
 * Adds zero to strings shorter than two characters
 */


function pad(str) {
  return str.length !== 2 ? 0 + str : str;
}

},{}],234:[function(require,module,exports){
module.exports = function has(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
};

},{}],235:[function(require,module,exports){
/**
 * Check if an object is a DOM element. Duck-typing based on `nodeType`.
 *
 * @param {*} obj
 */
module.exports = function isDOMElement(obj) {
  return obj && typeof obj === 'object' && obj.nodeType === Node.ELEMENT_NODE;
};

},{}],236:[function(require,module,exports){
/**
 * Checks if the browser supports Drag & Drop (not supported on mobile devices, for example).
 *
 * @returns {boolean}
 */
module.exports = function isDragDropSupported() {
  var div = document.createElement('div');

  if (!('draggable' in div) || !('ondragstart' in div && 'ondrop' in div)) {
    return false;
  }

  if (!('FormData' in window)) {
    return false;
  }

  if (!('FileReader' in window)) {
    return false;
  }

  return true;
};

},{}],237:[function(require,module,exports){
function isNetworkError(xhr) {
  if (!xhr) {
    return false;
  }

  return xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0;
}

module.exports = isNetworkError;

},{}],238:[function(require,module,exports){
/**
 * Check if a URL string is an object URL from `URL.createObjectURL`.
 *
 * @param {string} url
 * @returns {boolean}
 */
module.exports = function isObjectURL(url) {
  return url.indexOf('blob:') === 0;
};

},{}],239:[function(require,module,exports){
module.exports = function isPreviewSupported(fileType) {
  if (!fileType) return false;
  var fileTypeSpecific = fileType.split('/')[1]; // list of images that browsers can preview

  if (/^(jpe?g|gif|png|svg|svg\+xml|bmp|webp|avif)$/.test(fileTypeSpecific)) {
    return true;
  }

  return false;
};

},{}],240:[function(require,module,exports){
// ___Why not add the mime-types package?
//    It's 19.7kB gzipped, and we only need mime types for well-known extensions (for file previews).
// ___Where to take new extensions from?
//    https://github.com/jshttp/mime-db/blob/master/db.json
module.exports = {
  md: 'text/markdown',
  markdown: 'text/markdown',
  mp4: 'video/mp4',
  mp3: 'audio/mp3',
  svg: 'image/svg+xml',
  jpg: 'image/jpeg',
  png: 'image/png',
  gif: 'image/gif',
  heic: 'image/heic',
  heif: 'image/heif',
  yaml: 'text/yaml',
  yml: 'text/yaml',
  csv: 'text/csv',
  tsv: 'text/tab-separated-values',
  tab: 'text/tab-separated-values',
  avi: 'video/x-msvideo',
  mks: 'video/x-matroska',
  mkv: 'video/x-matroska',
  mov: 'video/quicktime',
  doc: 'application/msword',
  docm: 'application/vnd.ms-word.document.macroenabled.12',
  docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  dot: 'application/msword',
  dotm: 'application/vnd.ms-word.template.macroenabled.12',
  dotx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
  xla: 'application/vnd.ms-excel',
  xlam: 'application/vnd.ms-excel.addin.macroenabled.12',
  xlc: 'application/vnd.ms-excel',
  xlf: 'application/x-xliff+xml',
  xlm: 'application/vnd.ms-excel',
  xls: 'application/vnd.ms-excel',
  xlsb: 'application/vnd.ms-excel.sheet.binary.macroenabled.12',
  xlsm: 'application/vnd.ms-excel.sheet.macroenabled.12',
  xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  xlt: 'application/vnd.ms-excel',
  xltm: 'application/vnd.ms-excel.template.macroenabled.12',
  xltx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
  xlw: 'application/vnd.ms-excel',
  txt: 'text/plain',
  text: 'text/plain',
  conf: 'text/plain',
  log: 'text/plain',
  pdf: 'application/pdf',
  zip: 'application/zip',
  '7z': 'application/x-7z-compressed',
  rar: 'application/x-rar-compressed',
  tar: 'application/x-tar',
  gz: 'application/gzip',
  dmg: 'application/x-apple-diskimage'
};

},{}],241:[function(require,module,exports){
var secondsToTime = require('./secondsToTime');

module.exports = function prettyETA(seconds) {
  var time = secondsToTime(seconds); // Only display hours and minutes if they are greater than 0 but always
  // display minutes if hours is being displayed
  // Display a leading zero if the there is a preceding unit: 1m 05s, but 5s

  var hoursStr = time.hours ? time.hours + "h " : '';
  var minutesVal = time.hours ? ("0" + time.minutes).substr(-2) : time.minutes;
  var minutesStr = minutesVal ? minutesVal + "m" : '';
  var secondsVal = minutesVal ? ("0" + time.seconds).substr(-2) : time.seconds;
  var secondsStr = time.hours ? '' : minutesVal ? " " + secondsVal + "s" : secondsVal + "s";
  return "" + hoursStr + minutesStr + secondsStr;
};

},{"./secondsToTime":243}],242:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var getFileNameAndExtension = require('./getFileNameAndExtension');

module.exports = function remoteFileObjToLocal(file) {
  return _extends({}, file, {
    type: file.mimeType,
    extension: file.name ? getFileNameAndExtension(file.name).extension : null
  });
};

},{"./getFileNameAndExtension":227}],243:[function(require,module,exports){
module.exports = function secondsToTime(rawSeconds) {
  var hours = Math.floor(rawSeconds / 3600) % 24;
  var minutes = Math.floor(rawSeconds / 60) % 60;
  var seconds = Math.floor(rawSeconds % 60);
  return {
    hours: hours,
    minutes: minutes,
    seconds: seconds
  };
};

},{}],244:[function(require,module,exports){
module.exports = function settle(promises) {
  var resolutions = [];
  var rejections = [];

  function resolved(value) {
    resolutions.push(value);
  }

  function rejected(error) {
    rejections.push(error);
  }

  var wait = Promise.all(promises.map(function (promise) {
    return promise.then(resolved, rejected);
  }));
  return wait.then(function () {
    return {
      successful: resolutions,
      failed: rejections
    };
  });
};

},{}],245:[function(require,module,exports){
/**
 * Converts list into array
 */
module.exports = function toArray(list) {
  return Array.prototype.slice.call(list || [], 0);
};

},{}],246:[function(require,module,exports){
/**
 * Truncates a string to the given number of chars (maxLength) by inserting '...' in the middle of that string.
 * Partially taken from https://stackoverflow.com/a/5723274/3192470.
 *
 * @param {string} string - string to be truncated
 * @param {number} maxLength - maximum size of the resulting string
 * @returns {string}
 */
module.exports = function truncateString(string, maxLength) {
  var separator = '...'; // Return original string if it's already shorter than maxLength

  if (string.length <= maxLength) {
    return string; // Return truncated substring without '...' if string can't be meaningfully truncated
  }

  if (maxLength <= separator.length) {
    return string.substr(0, maxLength); // Return truncated string divided in half by '...'
  }

  var charsToShow = maxLength - separator.length;
  var frontChars = Math.ceil(charsToShow / 2);
  var backChars = Math.floor(charsToShow / 2);
  return string.substr(0, frontChars) + separator + string.substr(string.length - backChars);
};

},{}],247:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],248:[function(require,module,exports){
module.exports={
  "name": "@uppy/webcam",
  "description": "Uppy plugin that takes photos or records videos using the device's camera.",
  "version": "1.8.12",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "webcam",
    "picture",
    "photo",
    "video",
    "record",
    "mediarecorder"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],249:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    fill: "#0097DC",
    width: "66",
    height: "55",
    viewBox: "0 0 66 55"
  }, h("path", {
    d: "M57.3 8.433c4.59 0 8.1 3.51 8.1 8.1v29.7c0 4.59-3.51 8.1-8.1 8.1H8.7c-4.59 0-8.1-3.51-8.1-8.1v-29.7c0-4.59 3.51-8.1 8.1-8.1h9.45l4.59-7.02c.54-.54 1.35-1.08 2.16-1.08h16.2c.81 0 1.62.54 2.16 1.08l4.59 7.02h9.45zM33 14.64c-8.62 0-15.393 6.773-15.393 15.393 0 8.62 6.773 15.393 15.393 15.393 8.62 0 15.393-6.773 15.393-15.393 0-8.62-6.773-15.393-15.393-15.393zM33 40c-5.648 0-9.966-4.319-9.966-9.967 0-5.647 4.318-9.966 9.966-9.966s9.966 4.319 9.966 9.966C42.966 35.681 38.648 40 33 40z",
    fillRule: "evenodd"
  }));
};

},{"preact":247}],250:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/* eslint-disable jsx-a11y/media-has-caption */
var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var SnapshotButton = require('./SnapshotButton');

var RecordButton = require('./RecordButton');

var RecordingLength = require('./RecordingLength');

var VideoSourceSelect = require('./VideoSourceSelect');

var SubmitButton = require('./SubmitButton');

var DiscardButton = require('./DiscardButton');

function isModeAvailable(modes, mode) {
  return modes.indexOf(mode) !== -1;
}

var CameraScreen = /*#__PURE__*/function (_Component) {
  _inheritsLoose(CameraScreen, _Component);

  function CameraScreen() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = CameraScreen.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var onFocus = this.props.onFocus;
    onFocus();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var onStop = this.props.onStop;
    onStop();
  };

  _proto.render = function render() {
    var _this = this;

    var _this$props = this.props,
        src = _this$props.src,
        recordedVideo = _this$props.recordedVideo,
        recording = _this$props.recording,
        modes = _this$props.modes,
        supportsRecording = _this$props.supportsRecording,
        videoSources = _this$props.videoSources,
        showVideoSourceDropdown = _this$props.showVideoSourceDropdown,
        showRecordingLength = _this$props.showRecordingLength,
        onSubmit = _this$props.onSubmit,
        i18n = _this$props.i18n,
        mirror = _this$props.mirror,
        onSnapshot = _this$props.onSnapshot,
        onStartRecording = _this$props.onStartRecording,
        onStopRecording = _this$props.onStopRecording,
        onDiscardRecordedVideo = _this$props.onDiscardRecordedVideo,
        recordingLengthSeconds = _this$props.recordingLengthSeconds;
    var hasRecordedVideo = !!recordedVideo;
    var shouldShowRecordButton = !hasRecordedVideo && supportsRecording && (isModeAvailable(modes, 'video-only') || isModeAvailable(modes, 'audio-only') || isModeAvailable(modes, 'video-audio'));
    var shouldShowSnapshotButton = !hasRecordedVideo && isModeAvailable(modes, 'picture');
    var shouldShowRecordingLength = supportsRecording && showRecordingLength;
    var shouldShowVideoSourceDropdown = showVideoSourceDropdown && videoSources && videoSources.length > 1;
    var videoProps = {
      playsinline: true
    };

    if (recordedVideo) {
      videoProps.muted = false;
      videoProps.controls = true;
      videoProps.src = recordedVideo; // reset srcObject in dom. If not resetted, stream sticks in element

      if (this.videoElement) {
        this.videoElement.srcObject = undefined;
      }
    } else {
      videoProps.muted = true;
      videoProps.autoplay = true;
      videoProps.srcObject = src;
    }

    return h("div", {
      className: "uppy uppy-Webcam-container"
    }, h("div", {
      className: "uppy-Webcam-videoContainer"
    }, h("video", _extends({
      /* eslint-disable-next-line no-return-assign */
      ref: function ref(videoElement) {
        return _this.videoElement = videoElement;
      },
      className: "uppy-Webcam-video  " + (mirror ? 'uppy-Webcam-video--mirrored' : '')
      /* eslint-disable-next-line react/jsx-props-no-spreading */

    }, videoProps))), h("div", {
      className: "uppy-Webcam-footer"
    }, h("div", {
      className: "uppy-Webcam-videoSourceContainer"
    }, shouldShowVideoSourceDropdown ? VideoSourceSelect(this.props) : null), h("div", {
      className: "uppy-Webcam-buttonContainer"
    }, shouldShowSnapshotButton && h(SnapshotButton, {
      onSnapshot: onSnapshot,
      i18n: i18n
    }), shouldShowRecordButton && h(RecordButton, {
      recording: recording,
      onStartRecording: onStartRecording,
      onStopRecording: onStopRecording,
      i18n: i18n
    }), hasRecordedVideo && h(SubmitButton, {
      onSubmit: onSubmit,
      i18n: i18n
    }), hasRecordedVideo && h(DiscardButton, {
      onDiscard: onDiscardRecordedVideo,
      i18n: i18n
    })), shouldShowRecordingLength && h("div", {
      className: "uppy-Webcam-recordingLength"
    }, h(RecordingLength, {
      recordingLengthSeconds: recordingLengthSeconds,
      i18n: i18n
    }))));
  };

  return CameraScreen;
}(Component);

module.exports = CameraScreen;

},{"./DiscardButton":251,"./RecordButton":253,"./RecordingLength":254,"./SnapshotButton":255,"./SubmitButton":256,"./VideoSourceSelect":257,"preact":247}],251:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function DiscardButton(_ref) {
  var onDiscard = _ref.onDiscard,
      i18n = _ref.i18n;
  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button",
    type: "button",
    title: i18n('discardRecordedFile'),
    "aria-label": i18n('discardRecordedFile'),
    onClick: onDiscard,
    "data-uppy-super-focusable": true
  }, h("svg", {
    width: "13",
    height: "13",
    viewBox: "0 0 13 13",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon"
  }, h("g", {
    fill: "#FFF",
    fillRule: "evenodd"
  }, h("path", {
    d: "M.496 11.367L11.103.76l1.414 1.414L1.911 12.781z"
  }), h("path", {
    d: "M11.104 12.782L.497 2.175 1.911.76l10.607 10.606z"
  }))));
}

module.exports = DiscardButton;

},{"preact":247}],252:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("div", {
    className: "uppy-Webcam-permissons"
  }, h("div", {
    className: "uppy-Webcam-permissonsIcon"
  }, props.icon()), h("h1", {
    className: "uppy-Webcam-title"
  }, props.hasCamera ? props.i18n('allowAccessTitle') : props.i18n('noCameraTitle')), h("p", null, props.hasCamera ? props.i18n('allowAccessDescription') : props.i18n('noCameraDescription')));
};

},{"preact":247}],253:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function RecordButton(_ref) {
  var recording = _ref.recording,
      onStartRecording = _ref.onStartRecording,
      onStopRecording = _ref.onStopRecording,
      i18n = _ref.i18n;

  if (recording) {
    return h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-Webcam-button",
      type: "button",
      title: i18n('stopRecording'),
      "aria-label": i18n('stopRecording'),
      onClick: onStopRecording,
      "data-uppy-super-focusable": true
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      width: "100",
      height: "100",
      viewBox: "0 0 100 100"
    }, h("rect", {
      x: "15",
      y: "15",
      width: "70",
      height: "70"
    })));
  }

  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button",
    type: "button",
    title: i18n('startRecording'),
    "aria-label": i18n('startRecording'),
    onClick: onStartRecording,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "100",
    height: "100",
    viewBox: "0 0 100 100"
  }, h("circle", {
    cx: "50",
    cy: "50",
    r: "40"
  })));
};

},{"preact":247}],254:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var formatSeconds = require('./formatSeconds');

module.exports = function RecordingLength(_ref) {
  var recordingLengthSeconds = _ref.recordingLengthSeconds,
      i18n = _ref.i18n;
  var formattedRecordingLengthSeconds = formatSeconds(recordingLengthSeconds);
  return h("span", {
    "aria-label": i18n('recordingLength', {
      recording_length: formattedRecordingLengthSeconds
    })
  }, formattedRecordingLengthSeconds);
};

},{"./formatSeconds":258,"preact":247}],255:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var CameraIcon = require('./CameraIcon');

module.exports = function (_ref) {
  var onSnapshot = _ref.onSnapshot,
      i18n = _ref.i18n;
  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--picture",
    type: "button",
    title: i18n('takePicture'),
    "aria-label": i18n('takePicture'),
    onClick: onSnapshot,
    "data-uppy-super-focusable": true
  }, CameraIcon());
};

},{"./CameraIcon":249,"preact":247}],256:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function SubmitButton(_ref) {
  var onSubmit = _ref.onSubmit,
      i18n = _ref.i18n;
  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--submit",
    type: "button",
    title: i18n('submitRecordedFile'),
    "aria-label": i18n('submitRecordedFile'),
    onClick: onSubmit,
    "data-uppy-super-focusable": true
  }, h("svg", {
    width: "12",
    height: "9",
    viewBox: "0 0 12 9",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon"
  }, h("path", {
    fill: "#fff",
    fillRule: "nonzero",
    d: "M10.66 0L12 1.31 4.136 9 0 4.956l1.34-1.31L4.136 6.38z"
  })));
}

module.exports = SubmitButton;

},{"preact":247}],257:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (_ref) {
  var currentDeviceId = _ref.currentDeviceId,
      videoSources = _ref.videoSources,
      onChangeVideoSource = _ref.onChangeVideoSource;
  return h("div", {
    className: "uppy-Webcam-videoSource"
  }, h("select", {
    className: "uppy-u-reset uppy-Webcam-videoSource-select",
    onChange: function onChange(event) {
      onChangeVideoSource(event.target.value);
    }
  }, videoSources.map(function (videoSource) {
    return h("option", {
      key: videoSource.deviceId,
      value: videoSource.deviceId,
      selected: videoSource.deviceId === currentDeviceId
    }, videoSource.label);
  })));
};

},{"preact":247}],258:[function(require,module,exports){
/**
 * Takes an Integer value of seconds (e.g. 83) and converts it into a human-readable formatted string (e.g. '1:23').
 *
 * @param {Integer} seconds
 * @returns {string} the formatted seconds (e.g. '1:23' for 1 minute and 23 seconds)
 *
 */
module.exports = function formatSeconds(seconds) {
  return Math.floor(seconds / 60) + ":" + String(seconds % 60).padStart(2, 0);
};

},{}],259:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h;

var _require2 = require('./../../core'),
    Plugin = _require2.Plugin;

var Translator = require('./../../utils/lib/Translator');

var getFileTypeExtension = require('./../../utils/lib/getFileTypeExtension');

var mimeTypes = require('./../../utils/lib/mimeTypes');

var canvasToBlob = require('./../../utils/lib/canvasToBlob');

var supportsMediaRecorder = require('./supportsMediaRecorder');

var CameraIcon = require('./CameraIcon');

var CameraScreen = require('./CameraScreen');

var PermissionsScreen = require('./PermissionsScreen');

var packageJsonVersion = require('../package.json').version;
/**
 * Normalize a MIME type or file extension into a MIME type.
 *
 * @param {string} fileType - MIME type or a file extension prefixed with `.`.
 * @returns {string|undefined} The MIME type or `undefined` if the fileType is an extension and is not known.
 */


function toMimeType(fileType) {
  if (fileType[0] === '.') {
    return mimeTypes[fileType.slice(1)];
  }

  return fileType;
}
/**
 * Is this MIME type a video?
 *
 * @param {string} mimeType - MIME type.
 * @returns {boolean}
 */


function isVideoMimeType(mimeType) {
  return /^video\/[^*]+$/.test(mimeType);
}
/**
 * Is this MIME type an image?
 *
 * @param {string} mimeType - MIME type.
 * @returns {boolean}
 */


function isImageMimeType(mimeType) {
  return /^image\/[^*]+$/.test(mimeType);
}
/**
 * Setup getUserMedia, with polyfill for older browsers
 * Adapted from: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
 */


function getMediaDevices() {
  // eslint-disable-next-line compat/compat
  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    // eslint-disable-next-line compat/compat
    return navigator.mediaDevices;
  }

  var _getUserMedia = navigator.mozGetUserMedia || navigator.webkitGetUserMedia;

  if (!_getUserMedia) {
    return null;
  }

  return {
    getUserMedia: function getUserMedia(opts) {
      return new Promise(function (resolve, reject) {
        _getUserMedia.call(navigator, opts, resolve, reject);
      });
    }
  };
}
/**
 * Webcam
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Webcam, _Plugin);

  function Webcam(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.mediaDevices = getMediaDevices();
    _this.supportsUserMedia = !!_this.mediaDevices; // eslint-disable-next-line no-restricted-globals

    _this.protocol = location.protocol.match(/https/i) ? 'https' : 'http';
    _this.id = _this.opts.id || 'Webcam';
    _this.title = _this.opts.title || 'Camera';
    _this.type = 'acquirer';
    _this.capturedMediaFile = null;

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        fill: "#03BFEF",
        width: "32",
        height: "32",
        rx: "16"
      }), h("path", {
        d: "M22 11c1.133 0 2 .867 2 2v7.333c0 1.134-.867 2-2 2H10c-1.133 0-2-.866-2-2V13c0-1.133.867-2 2-2h2.333l1.134-1.733C13.6 9.133 13.8 9 14 9h4c.2 0 .4.133.533.267L19.667 11H22zm-6 1.533a3.764 3.764 0 0 0-3.8 3.8c0 2.129 1.672 3.801 3.8 3.801s3.8-1.672 3.8-3.8c0-2.13-1.672-3.801-3.8-3.801zm0 6.261c-1.395 0-2.46-1.066-2.46-2.46 0-1.395 1.065-2.461 2.46-2.461s2.46 1.066 2.46 2.46c0 1.395-1.065 2.461-2.46 2.461z",
        fill: "#FFF",
        fillRule: "nonzero"
      })));
    };

    _this.defaultLocale = {
      strings: {
        smile: 'Smile!',
        takePicture: 'Take a picture',
        startRecording: 'Begin video recording',
        stopRecording: 'Stop video recording',
        allowAccessTitle: 'Please allow access to your camera',
        allowAccessDescription: 'In order to take pictures or record video with your camera, please allow camera access for this site.',
        noCameraTitle: 'Camera Not Available',
        noCameraDescription: 'In order to take pictures or record video, please connect a camera device',
        recordingStoppedMaxSize: 'Recording stopped because the file size is about to exceed the limit',
        recordingLength: 'Recording length %{recording_length}',
        submitRecordedFile: 'Submit recorded file',
        discardRecordedFile: 'Discard recorded file'
      }
    }; // set default options

    var defaultOptions = {
      onBeforeSnapshot: function onBeforeSnapshot() {
        return Promise.resolve();
      },
      countdown: false,
      modes: ['video-audio', 'video-only', 'audio-only', 'picture'],
      mirror: true,
      showVideoSourceDropdown: false,
      facingMode: 'user',
      preferredImageMimeType: null,
      preferredVideoMimeType: null,
      showRecordingLength: false
    };
    _this.opts = _extends({}, defaultOptions, opts);

    _this.i18nInit();

    _this.install = _this.install.bind(_assertThisInitialized(_this));
    _this.setPluginState = _this.setPluginState.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this)); // Camera controls

    _this.start = _this.start.bind(_assertThisInitialized(_this));
    _this.stop = _this.stop.bind(_assertThisInitialized(_this));
    _this.takeSnapshot = _this.takeSnapshot.bind(_assertThisInitialized(_this));
    _this.startRecording = _this.startRecording.bind(_assertThisInitialized(_this));
    _this.stopRecording = _this.stopRecording.bind(_assertThisInitialized(_this));
    _this.discardRecordedVideo = _this.discardRecordedVideo.bind(_assertThisInitialized(_this));
    _this.submit = _this.submit.bind(_assertThisInitialized(_this));
    _this.oneTwoThreeSmile = _this.oneTwoThreeSmile.bind(_assertThisInitialized(_this));
    _this.focus = _this.focus.bind(_assertThisInitialized(_this));
    _this.changeVideoSource = _this.changeVideoSource.bind(_assertThisInitialized(_this));
    _this.webcamActive = false;

    if (_this.opts.countdown) {
      _this.opts.onBeforeSnapshot = _this.oneTwoThreeSmile;
    }

    _this.setPluginState({
      hasCamera: false,
      cameraReady: false,
      cameraError: null,
      recordingLengthSeconds: 0,
      videoSources: [],
      currentDeviceId: null
    });

    return _this;
  }

  var _proto = Webcam.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, _extends({}, newOpts, {
      videoConstraints: _extends({}, this.opts.videoConstraints, newOpts == null ? void 0 : newOpts.videoConstraints)
    }));

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.hasCameraCheck = function hasCameraCheck() {
    if (!this.mediaDevices) {
      return Promise.resolve(false);
    }

    return this.mediaDevices.enumerateDevices().then(function (devices) {
      return devices.some(function (device) {
        return device.kind === 'videoinput';
      });
    });
  };

  _proto.isAudioOnly = function isAudioOnly() {
    return this.opts.modes.length === 1 && this.opts.modes[0] === 'audio-only';
  };

  _proto.getConstraints = function getConstraints(deviceId) {
    var _this$opts$videoConst;

    if (deviceId === void 0) {
      deviceId = null;
    }

    var acceptsAudio = this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('audio-only') !== -1;
    var acceptsVideo = !this.isAudioOnly() && (this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('video-only') !== -1 || this.opts.modes.indexOf('picture') !== -1);

    var videoConstraints = _extends({}, (_this$opts$videoConst = this.opts.videoConstraints) != null ? _this$opts$videoConst : {
      facingMode: this.opts.facingMode
    }, deviceId ? {
      deviceId: deviceId,
      facingMode: null
    } : {});

    return {
      audio: acceptsAudio,
      video: acceptsVideo ? videoConstraints : false
    };
  } // eslint-disable-next-line consistent-return
  ;

  _proto.start = function start(options) {
    var _this2 = this;

    if (options === void 0) {
      options = null;
    }

    if (!this.supportsUserMedia) {
      return Promise.reject(new Error('Webcam access not supported'));
    }

    this.webcamActive = true;
    this.opts.mirror = true;
    var constraints = this.getConstraints(options && options.deviceId ? options.deviceId : null);
    this.hasCameraCheck().then(function (hasCamera) {
      _this2.setPluginState({
        hasCamera: hasCamera
      }); // ask user for access to their camera


      return _this2.mediaDevices.getUserMedia(constraints).then(function (stream) {
        _this2.stream = stream;
        var currentDeviceId = null;
        var tracks = _this2.isAudioOnly() ? stream.getAudioTracks() : stream.getVideoTracks();

        if (!options || !options.deviceId) {
          currentDeviceId = tracks[0].getSettings().deviceId;
        } else {
          tracks.forEach(function (track) {
            if (track.getSettings().deviceId === options.deviceId) {
              currentDeviceId = track.getSettings().deviceId;
            }
          });
        } // Update the sources now, so we can access the names.


        _this2.updateVideoSources();

        _this2.setPluginState({
          currentDeviceId: currentDeviceId,
          cameraReady: true
        });
      }).catch(function (err) {
        _this2.setPluginState({
          cameraReady: false,
          cameraError: err
        });

        _this2.uppy.info(err.message, 'error');
      });
    });
  }
  /**
   * @returns {object}
   */
  ;

  _proto.getMediaRecorderOptions = function getMediaRecorderOptions() {
    var options = {}; // Try to use the `opts.preferredVideoMimeType` or one of the `allowedFileTypes` for the recording.
    // If the browser doesn't support it, we'll fall back to the browser default instead.
    // Safari doesn't have the `isTypeSupported` API.

    if (MediaRecorder.isTypeSupported) {
      var restrictions = this.uppy.opts.restrictions;
      var preferredVideoMimeTypes = [];

      if (this.opts.preferredVideoMimeType) {
        preferredVideoMimeTypes = [this.opts.preferredVideoMimeType];
      } else if (restrictions.allowedFileTypes) {
        preferredVideoMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isVideoMimeType);
      }

      var filterSupportedTypes = function filterSupportedTypes(candidateType) {
        return MediaRecorder.isTypeSupported(candidateType) && getFileTypeExtension(candidateType);
      };

      var acceptableMimeTypes = preferredVideoMimeTypes.filter(filterSupportedTypes);

      if (acceptableMimeTypes.length > 0) {
        // eslint-disable-next-line prefer-destructuring
        options.mimeType = acceptableMimeTypes[0];
      }
    }

    return options;
  };

  _proto.startRecording = function startRecording() {
    var _this3 = this;

    // only used if supportsMediaRecorder() returned true
    // eslint-disable-next-line compat/compat
    this.recorder = new MediaRecorder(this.stream, this.getMediaRecorderOptions());
    this.recordingChunks = [];
    var stoppingBecauseOfMaxSize = false;
    this.recorder.addEventListener('dataavailable', function (event) {
      _this3.recordingChunks.push(event.data);

      var restrictions = _this3.uppy.opts.restrictions;

      if (_this3.recordingChunks.length > 1 && restrictions.maxFileSize != null && !stoppingBecauseOfMaxSize) {
        var totalSize = _this3.recordingChunks.reduce(function (acc, chunk) {
          return acc + chunk.size;
        }, 0); // Exclude the initial chunk from the average size calculation because it is likely to be a very small outlier


        var averageChunkSize = (totalSize - _this3.recordingChunks[0].size) / (_this3.recordingChunks.length - 1);
        var expectedEndChunkSize = averageChunkSize * 3;
        var maxSize = Math.max(0, restrictions.maxFileSize - expectedEndChunkSize);

        if (totalSize > maxSize) {
          stoppingBecauseOfMaxSize = true;

          _this3.uppy.info(_this3.i18n('recordingStoppedMaxSize'), 'warning', 4000);

          _this3.stopRecording();
        }
      }
    }); // use a "time slice" of 500ms: ondataavailable will be called each 500ms
    // smaller time slices mean we can more accurately check the max file size restriction

    this.recorder.start(500);

    if (this.opts.showRecordingLength) {
      // Start the recordingLengthTimer if we are showing the recording length.
      this.recordingLengthTimer = setInterval(function () {
        var currentRecordingLength = _this3.getPluginState().recordingLengthSeconds;

        _this3.setPluginState({
          recordingLengthSeconds: currentRecordingLength + 1
        });
      }, 1000);
    }

    this.setPluginState({
      isRecording: true
    });
  };

  _proto.stopRecording = function stopRecording() {
    var _this4 = this;

    var stopped = new Promise(function (resolve) {
      _this4.recorder.addEventListener('stop', function () {
        resolve();
      });

      _this4.recorder.stop();

      if (_this4.opts.showRecordingLength) {
        // Stop the recordingLengthTimer if we are showing the recording length.
        clearInterval(_this4.recordingLengthTimer);

        _this4.setPluginState({
          recordingLengthSeconds: 0
        });
      }
    });
    return stopped.then(function () {
      _this4.setPluginState({
        isRecording: false
      });

      return _this4.getVideo();
    }).then(function (file) {
      try {
        _this4.capturedMediaFile = file; // create object url for capture result preview

        _this4.setPluginState({
          // eslint-disable-next-line compat/compat
          recordedVideo: URL.createObjectURL(file.data)
        });

        _this4.opts.mirror = false;
      } catch (err) {
        // Logging the error, exept restrictions, which is handled in Core
        if (!err.isRestriction) {
          _this4.uppy.log(err);
        }
      }
    }).then(function () {
      _this4.recordingChunks = null;
      _this4.recorder = null;
    }, function (error) {
      _this4.recordingChunks = null;
      _this4.recorder = null;
      throw error;
    });
  };

  _proto.discardRecordedVideo = function discardRecordedVideo() {
    this.setPluginState({
      recordedVideo: null
    });
    this.opts.mirror = true;
    this.capturedMediaFile = null;
  };

  _proto.submit = function submit() {
    try {
      if (this.capturedMediaFile) {
        this.uppy.addFile(this.capturedMediaFile);
      }
    } catch (err) {
      // Logging the error, exept restrictions, which is handled in Core
      if (!err.isRestriction) {
        this.uppy.log(err, 'error');
      }
    }
  };

  _proto.stop = function stop() {
    if (this.stream) {
      this.stream.getAudioTracks().forEach(function (track) {
        track.stop();
      });
      this.stream.getVideoTracks().forEach(function (track) {
        track.stop();
      });
    }

    this.webcamActive = false;
    this.stream = null;
    this.setPluginState({
      recordedVideo: null
    });
  };

  _proto.getVideoElement = function getVideoElement() {
    return this.el.querySelector('.uppy-Webcam-video');
  };

  _proto.oneTwoThreeSmile = function oneTwoThreeSmile() {
    var _this5 = this;

    return new Promise(function (resolve, reject) {
      var count = _this5.opts.countdown; // eslint-disable-next-line consistent-return

      var countDown = setInterval(function () {
        if (!_this5.webcamActive) {
          clearInterval(countDown);
          _this5.captureInProgress = false;
          return reject(new Error('Webcam is not active'));
        }

        if (count > 0) {
          _this5.uppy.info(count + "...", 'warning', 800);

          count--;
        } else {
          clearInterval(countDown);

          _this5.uppy.info(_this5.i18n('smile'), 'success', 1500);

          setTimeout(function () {
            return resolve();
          }, 1500);
        }
      }, 1000);
    });
  };

  _proto.takeSnapshot = function takeSnapshot() {
    var _this6 = this;

    if (this.captureInProgress) return;
    this.captureInProgress = true;
    this.opts.onBeforeSnapshot().catch(function (err) {
      var message = typeof err === 'object' ? err.message : err;

      _this6.uppy.info(message, 'error', 5000);

      return Promise.reject(new Error("onBeforeSnapshot: " + message));
    }).then(function () {
      return _this6.getImage();
    }).then(function (tagFile) {
      _this6.captureInProgress = false;

      try {
        _this6.uppy.addFile(tagFile);
      } catch (err) {
        // Logging the error, except restrictions, which is handled in Core
        if (!err.isRestriction) {
          _this6.uppy.log(err);
        }
      }
    }, function (error) {
      _this6.captureInProgress = false;
      throw error;
    });
  };

  _proto.getImage = function getImage() {
    var _this7 = this;

    var video = this.getVideoElement();

    if (!video) {
      return Promise.reject(new Error('No video element found, likely due to the Webcam tab being closed.'));
    }

    var width = video.videoWidth;
    var height = video.videoHeight;
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);
    var restrictions = this.uppy.opts.restrictions;
    var preferredImageMimeTypes = [];

    if (this.opts.preferredImageMimeType) {
      preferredImageMimeTypes = [this.opts.preferredImageMimeType];
    } else if (restrictions.allowedFileTypes) {
      preferredImageMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isImageMimeType);
    }

    var mimeType = preferredImageMimeTypes[0] || 'image/jpeg';
    var ext = getFileTypeExtension(mimeType) || 'jpg';
    var name = "cam-" + Date.now() + "." + ext;
    return canvasToBlob(canvas, mimeType).then(function (blob) {
      return {
        source: _this7.id,
        name: name,
        data: new Blob([blob], {
          type: mimeType
        }),
        type: mimeType
      };
    });
  };

  _proto.getVideo = function getVideo() {
    // Sometimes in iOS Safari, Blobs (especially the first Blob in the recordingChunks Array)
    // have empty 'type' attributes (e.g. '') so we need to find a Blob that has a defined 'type'
    // attribute in order to determine the correct MIME type.
    var mimeType = this.recordingChunks.find(function (blob) {
      var _blob$type;

      return ((_blob$type = blob.type) == null ? void 0 : _blob$type.length) > 0;
    }).type;
    var fileExtension = getFileTypeExtension(mimeType);

    if (!fileExtension) {
      return Promise.reject(new Error("Could not retrieve recording: Unsupported media type \"" + mimeType + "\""));
    }

    var name = "webcam-" + Date.now() + "." + fileExtension;
    var blob = new Blob(this.recordingChunks, {
      type: mimeType
    });
    var file = {
      source: this.id,
      name: name,
      data: new Blob([blob], {
        type: mimeType
      }),
      type: mimeType
    };
    return Promise.resolve(file);
  };

  _proto.focus = function focus() {
    var _this8 = this;

    if (!this.opts.countdown) return;
    setTimeout(function () {
      _this8.uppy.info(_this8.i18n('smile'), 'success', 1500);
    }, 1000);
  };

  _proto.changeVideoSource = function changeVideoSource(deviceId) {
    this.stop();
    this.start({
      deviceId: deviceId
    });
  };

  _proto.updateVideoSources = function updateVideoSources() {
    var _this9 = this;

    this.mediaDevices.enumerateDevices().then(function (devices) {
      _this9.setPluginState({
        videoSources: devices.filter(function (device) {
          return device.kind === 'videoinput';
        })
      });
    });
  };

  _proto.render = function render() {
    if (!this.webcamActive) {
      this.start();
    }

    var webcamState = this.getPluginState();

    if (!webcamState.cameraReady || !webcamState.hasCamera) {
      return h(PermissionsScreen, {
        icon: CameraIcon,
        i18n: this.i18n,
        hasCamera: webcamState.hasCamera
      });
    }

    return h(CameraScreen // eslint-disable-next-line react/jsx-props-no-spreading
    , _extends({}, webcamState, {
      onChangeVideoSource: this.changeVideoSource,
      onSnapshot: this.takeSnapshot,
      onStartRecording: this.startRecording,
      onStopRecording: this.stopRecording,
      onDiscardRecordedVideo: this.discardRecordedVideo,
      onSubmit: this.submit,
      onFocus: this.focus,
      onStop: this.stop,
      i18n: this.i18n,
      modes: this.opts.modes,
      showRecordingLength: this.opts.showRecordingLength,
      showVideoSourceDropdown: this.opts.showVideoSourceDropdown,
      supportsRecording: supportsMediaRecorder(),
      recording: webcamState.isRecording,
      mirror: this.opts.mirror,
      src: this.stream
    }));
  };

  _proto.install = function install() {
    var _this10 = this;

    this.setPluginState({
      cameraReady: false,
      recordingLengthSeconds: 0
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }

    if (this.mediaDevices) {
      this.updateVideoSources();

      this.mediaDevices.ondevicechange = function () {
        _this10.updateVideoSources();

        if (_this10.stream) {
          var restartStream = true;

          var _this10$getPluginStat = _this10.getPluginState(),
              videoSources = _this10$getPluginStat.videoSources,
              currentDeviceId = _this10$getPluginStat.currentDeviceId;

          videoSources.forEach(function (videoSource) {
            if (currentDeviceId === videoSource.deviceId) {
              restartStream = false;
            }
          });

          if (restartStream) {
            _this10.stop();

            _this10.start();
          }
        }
      };
    }
  };

  _proto.uninstall = function uninstall() {
    if (this.stream) {
      this.stop();
    }

    this.unmount();
  };

  return Webcam;
}(Plugin), _class.VERSION = packageJsonVersion, _temp);

},{"../package.json":248,"./../../core":73,"./../../utils/lib/Translator":212,"./../../utils/lib/canvasToBlob":213,"./../../utils/lib/getFileTypeExtension":229,"./../../utils/lib/mimeTypes":240,"./CameraIcon":249,"./CameraScreen":250,"./PermissionsScreen":252,"./supportsMediaRecorder":260,"preact":247}],260:[function(require,module,exports){
module.exports = function supportsMediaRecorder() {
  /* eslint-disable compat/compat */
  return typeof MediaRecorder === 'function' && !!MediaRecorder.prototype && typeof MediaRecorder.prototype.start === 'function';
  /* eslint-enable compat/compat */
};

},{}],261:[function(require,module,exports){
(function (global){(function (){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

;(function(root) {
'use strict';

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: /^ {0,3}(`{3,}|~{3,})([^`~\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: '^ {0,3}(?:' // optional indentation
    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
    + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
    + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
    + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
    + ')',
  def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
  nptable: noop,
  table: noop,
  lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
  text: /^[^\n]+/
};

block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def)
  .replace('label', block._label)
  .replace('title', block._title)
  .getRegex();

block.bullet = /(?:[*+-]|\d{1,9}\.)/;
block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
block.item = edit(block.item, 'gm')
  .replace(/bull/g, block.bullet)
  .getRegex();

block.list = edit(block.list)
  .replace(/bull/g, block.bullet)
  .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
  .replace('def', '\\n+(?=' + block.def.source + ')')
  .getRegex();

block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
  + '|track|ul';
block._comment = /<!--(?!-?>)[\s\S]*?-->/;
block.html = edit(block.html, 'i')
  .replace('comment', block._comment)
  .replace('tag', block._tag)
  .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
  .getRegex();

block.paragraph = edit(block._paragraph)
  .replace('hr', block.hr)
  .replace('heading', ' {0,3}#{1,6} +')
  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('blockquote', ' {0,3}>')
  .replace('fences', ' {0,3}(?:`{3,}|~{3,})[^`\\n]*\\n')
  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();

block.blockquote = edit(block.blockquote)
  .replace('paragraph', block.paragraph)
  .getRegex();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  nptable: /^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,
  table: /^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/
});

/**
 * Pedantic grammar (original John Gruber's loose markdown specification)
 */

block.pedantic = merge({}, block.normal, {
  html: edit(
    '^ *(?:comment *(?:\\n|\\s*$)'
    + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
    .replace('comment', block._comment)
    .replace(/tag/g, '(?!(?:'
      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
      + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
    .getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
  fences: noop, // fences not supported
  paragraph: edit(block.normal._paragraph)
    .replace('hr', block.hr)
    .replace('heading', ' *#{1,6} *[^\n]')
    .replace('lheading', block.lheading)
    .replace('blockquote', ' {0,3}>')
    .replace('|fences', '')
    .replace('|list', '')
    .replace('|html', '')
    .getRegex()
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = Object.create(null);
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.pedantic) {
    this.rules = block.pedantic;
  } else if (this.options.gfm) {
    this.rules = block.gfm;
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top) {
  src = src.replace(/^ +$/gm, '');
  var next,
      loose,
      cap,
      bull,
      b,
      item,
      listStart,
      listItems,
      t,
      space,
      i,
      tag,
      l,
      isordered,
      istask,
      ischecked;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      var lastToken = this.tokens[this.tokens.length - 1];
      src = src.substring(cap[0].length);
      // An indented code block cannot interrupt a paragraph.
      if (lastToken && lastToken.type === 'paragraph') {
        lastToken.text += '\n' + cap[0].trimRight();
      } else {
        cap = cap[0].replace(/^ {4}/gm, '');
        this.tokens.push({
          type: 'code',
          codeBlockStyle: 'indented',
          text: !this.options.pedantic
            ? rtrim(cap, '\n')
            : cap
        });
      }
      continue;
    }

    // fences
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2] ? cap[2].trim() : cap[2],
        text: cap[3] || ''
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (cap = this.rules.nptable.exec(src)) {
      item = {
        type: 'table',
        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
      };

      if (item.header.length === item.align.length) {
        src = src.substring(cap[0].length);

        for (i = 0; i < item.align.length; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }

        for (i = 0; i < item.cells.length; i++) {
          item.cells[i] = splitCells(item.cells[i], item.header.length);
        }

        this.tokens.push(item);

        continue;
      }
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];
      isordered = bull.length > 1;

      listStart = {
        type: 'list_start',
        ordered: isordered,
        start: isordered ? +bull : '',
        loose: false
      };

      this.tokens.push(listStart);

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      listItems = [];
      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) */, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull.length > 1 ? b.length === 1
            : (b.length > 1 || (this.options.smartLists && b !== bull))) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        if (loose) {
          listStart.loose = true;
        }

        // Check for task list items
        istask = /^\[[ xX]\] /.test(item);
        ischecked = undefined;
        if (istask) {
          ischecked = item[1] !== ' ';
          item = item.replace(/^\[[ xX]\] +/, '');
        }

        t = {
          type: 'list_item_start',
          task: istask,
          checked: ischecked,
          loose: loose
        };

        listItems.push(t);
        this.tokens.push(t);

        // Recurse.
        this.token(item, false);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      if (listStart.loose) {
        l = listItems.length;
        i = 0;
        for (; i < l; i++) {
          listItems[i].loose = true;
        }
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
      tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
      if (!this.tokens.links[tag]) {
        this.tokens.links[tag] = {
          href: cap[2],
          title: cap[3]
        };
      }
      continue;
    }

    // table (gfm)
    if (cap = this.rules.table.exec(src)) {
      item = {
        type: 'table',
        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
      };

      if (item.header.length === item.align.length) {
        src = src.substring(cap[0].length);

        for (i = 0; i < item.align.length; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }

        for (i = 0; i < item.cells.length; i++) {
          item.cells[i] = splitCells(
            item.cells[i].replace(/^ *\| *| *\| *$/g, ''),
            item.header.length);
        }

        this.tokens.push(item);

        continue;
      }
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2].charAt(0) === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noop,
  tag: '^comment'
    + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
  nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
  strong: /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,
  em: /^_([^\s_])_(?!_)|^\*([^\s*<\[])\*(?!\*)|^_([^\s<][\s\S]*?[^\s_])_(?!_|[^\spunctuation])|^_([^\s_<][\s\S]*?[^\s])_(?!_|[^\spunctuation])|^\*([^\s<"][\s\S]*?[^\s\*])\*(?!\*|[^\spunctuation])|^\*([^\s*"<\[][\s\S]*?[^\s])\*(?!\*)/,
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noop,
  text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/
};

// list of punctuation marks from common mark spec
// without ` and ] to workaround Rule 17 (inline code blocks/links)
inline._punctuation = '!"#$%&\'()*+,\\-./:;<=>?@\\[^_{|}~';
inline.em = edit(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();

inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;

inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink)
  .replace('scheme', inline._scheme)
  .replace('email', inline._email)
  .getRegex();

inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

inline.tag = edit(inline.tag)
  .replace('comment', block._comment)
  .replace('attribute', inline._attribute)
  .getRegex();

inline._label = /(?:\[[^\[\]]*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

inline.link = edit(inline.link)
  .replace('label', inline._label)
  .replace('href', inline._href)
  .replace('title', inline._title)
  .getRegex();

inline.reflink = edit(inline.reflink)
  .replace('label', inline._label)
  .getRegex();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
  link: edit(/^!?\[(label)\]\((.*?)\)/)
    .replace('label', inline._label)
    .getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
    .replace('label', inline._label)
    .getRegex()
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^~+(?=\S)([\s\S]*?\S)~+/,
  text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
});

inline.gfm.url = edit(inline.gfm.url, 'i')
  .replace('email', inline.gfm._extended_email)
  .getRegex();
/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace('{2,}', '*').getRegex(),
  text: edit(inline.gfm.text)
    .replace('\\b_', '\\b_| {2,}\\n')
    .replace(/\{2,\}/g, '*')
    .getRegex()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer();
  this.renderer.options = this.options;

  if (!this.links) {
    throw new Error('Tokens array requires a `links` property.');
  }

  if (this.options.pedantic) {
    this.rules = inline.pedantic;
  } else if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = '',
      link,
      text,
      href,
      title,
      cap,
      prevCapZero;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(cap[1]);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      if (!this.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.inRawBlock = true;
      } else if (this.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.inRawBlock = false;
      }

      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      var lastParenIndex = findClosingBracket(cap[2], '()');
      if (lastParenIndex > -1) {
        var linkLen = 4 + cap[1].length + lastParenIndex;
        cap[2] = cap[2].substring(0, lastParenIndex);
        cap[0] = cap[0].substring(0, linkLen).trim();
        cap[3] = '';
      }
      src = src.substring(cap[0].length);
      this.inLink = true;
      href = cap[2];
      if (this.options.pedantic) {
        link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

        if (link) {
          href = link[1];
          title = link[3];
        } else {
          title = '';
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : '';
      }
      href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
      out += this.outputLink(cap, {
        href: InlineLexer.escapes(href),
        title: InlineLexer.escapes(title)
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2].trim(), true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = escape(this.mangle(cap[1]));
        href = 'mailto:' + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      if (cap[2] === '@') {
        text = escape(cap[0]);
        href = 'mailto:' + text;
      } else {
        // do extended autolink path validation
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === 'www.') {
          href = 'http://' + text;
        } else {
          href = text;
        }
      }
      src = src.substring(cap[0].length);
      out += this.renderer.link(href, null, text);
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      if (this.inRawBlock) {
        out += this.renderer.text(this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]);
      } else {
        out += this.renderer.text(escape(this.smartypants(cap[0])));
      }
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

InlineLexer.escapes = function(text) {
  return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = link.href,
      title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  if (!this.options.mangle) return text;
  var out = '',
      l = text.length,
      i = 0,
      ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || marked.defaults;
}

Renderer.prototype.code = function(code, infostring, escaped) {
  var lang = (infostring || '').match(/\S*/)[0];
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw, slugger) {
  if (this.options.headerIds) {
    return '<h'
      + level
      + ' id="'
      + this.options.headerPrefix
      + slugger.slug(raw)
      + '">'
      + text
      + '</h'
      + level
      + '>\n';
  }
  // ignore IDs
  return '<h' + level + '>' + text + '</h' + level + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered, start) {
  var type = ordered ? 'ol' : 'ul',
      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
  return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.checkbox = function(checked) {
  return '<input '
    + (checked ? 'checked="" ' : '')
    + 'disabled="" type="checkbox"'
    + (this.options.xhtml ? ' /' : '')
    + '> ';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  if (body) body = '<tbody>' + body + '</tbody>';

  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + body
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' align="' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
  if (href === null) {
    return text;
  }
  var out = '<a href="' + escape(href) + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
  if (href === null) {
    return text;
  }

  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

Renderer.prototype.text = function(text) {
  return text;
};

/**
 * TextRenderer
 * returns only the textual part of the token
 */

function TextRenderer() {}

// no need for block level renderers

TextRenderer.prototype.strong =
TextRenderer.prototype.em =
TextRenderer.prototype.codespan =
TextRenderer.prototype.del =
TextRenderer.prototype.text = function(text) {
  return text;
};

TextRenderer.prototype.link =
TextRenderer.prototype.image = function(href, title, text) {
  return '' + text;
};

TextRenderer.prototype.br = function() {
  return '';
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer();
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
  this.slugger = new Slugger();
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options) {
  var parser = new Parser(options);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options);
  // use an InlineLexer with a TextRenderer to extract pure text
  this.inlineText = new InlineLexer(
    src.links,
    merge({}, this.options, { renderer: new TextRenderer() })
  );
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  this.token = this.tokens.pop();
  return this.token;
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        unescape(this.inlineText.output(this.token.text)),
        this.slugger);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = '',
          body = '',
          i,
          row,
          cell,
          j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      body = '';
      var ordered = this.token.ordered,
          start = this.token.start;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered, start);
    }
    case 'list_item_start': {
      body = '';
      var loose = this.token.loose;
      var checked = this.token.checked;
      var task = this.token.task;

      if (this.token.task) {
        body += this.renderer.checkbox(checked);
      }

      while (this.next().type !== 'list_item_end') {
        body += !loose && this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }
      return this.renderer.listitem(body, task, checked);
    }
    case 'html': {
      // TODO parse inline content if parameter markdown=1
      return this.renderer.html(this.token.text);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
    default: {
      var errMsg = 'Token with "' + this.token.type + '" type was not found.';
      if (this.options.silent) {
        console.log(errMsg);
      } else {
        throw new Error(errMsg);
      }
    }
  }
};

/**
 * Slugger generates header id
 */

function Slugger() {
  this.seen = {};
}

/**
 * Convert string to unique id
 */

Slugger.prototype.slug = function(value) {
  var slug = value
    .toLowerCase()
    .trim()
    .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
    .replace(/\s/g, '-');

  if (this.seen.hasOwnProperty(slug)) {
    var originalSlug = slug;
    do {
      this.seen[originalSlug]++;
      slug = originalSlug + '-' + this.seen[originalSlug];
    } while (this.seen.hasOwnProperty(slug));
  }
  this.seen[slug] = 0;

  return slug;
};

/**
 * Helpers
 */

function escape(html, encode) {
  if (encode) {
    if (escape.escapeTest.test(html)) {
      return html.replace(escape.escapeReplace, function(ch) { return escape.replacements[ch]; });
    }
  } else {
    if (escape.escapeTestNoEncode.test(html)) {
      return html.replace(escape.escapeReplaceNoEncode, function(ch) { return escape.replacements[ch]; });
    }
  }

  return html;
}

escape.escapeTest = /[&<>"']/;
escape.escapeReplace = /[&<>"']/g;
escape.replacements = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

escape.escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
escape.escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;

function unescape(html) {
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function edit(regex, opt) {
  regex = regex.source || regex;
  opt = opt || '';
  return {
    replace: function(name, val) {
      val = val.source || val;
      val = val.replace(/(^|[^\[])\^/g, '$1');
      regex = regex.replace(name, val);
      return this;
    },
    getRegex: function() {
      return new RegExp(regex, opt);
    }
  };
}

function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, '%');
  } catch (e) {
    return null;
  }
  return href;
}

function resolveUrl(base, href) {
  if (!baseUrls[' ' + base]) {
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (/^[^:]+:\/*[^/]*$/.test(base)) {
      baseUrls[' ' + base] = base + '/';
    } else {
      baseUrls[' ' + base] = rtrim(base, '/', true);
    }
  }
  base = baseUrls[' ' + base];

  if (href.slice(0, 2) === '//') {
    return base.replace(/:[\s\S]*/, ':') + href;
  } else if (href.charAt(0) === '/') {
    return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
  } else {
    return base + href;
  }
}
var baseUrls = {};
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1,
      target,
      key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}

function splitCells(tableRow, count) {
  // ensure that every cell-delimiting pipe has a space
  // before it to distinguish it from an escaped pipe
  var row = tableRow.replace(/\|/g, function(match, offset, str) {
        var escaped = false,
            curr = offset;
        while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
        if (escaped) {
          // odd number of slashes means | is escaped
          // so we leave it alone
          return '|';
        } else {
          // add space before unescaped |
          return ' |';
        }
      }),
      cells = row.split(/ \|/),
      i = 0;

  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count) cells.push('');
  }

  for (; i < cells.length; i++) {
    // leading or trailing whitespace is ignored per the gfm spec
    cells[i] = cells[i].trim().replace(/\\\|/g, '|');
  }
  return cells;
}

// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
// /c*$/ is vulnerable to REDOS.
// invert: Remove suffix of non-c chars instead. Default falsey.
function rtrim(str, c, invert) {
  if (str.length === 0) {
    return '';
  }

  // Length of suffix matching the invert condition.
  var suffLen = 0;

  // Step left until we fail to match the invert condition.
  while (suffLen < str.length) {
    var currChar = str.charAt(str.length - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }

  return str.substr(0, str.length - suffLen);
}

function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  var level = 0;
  for (var i = 0; i < str.length; i++) {
    if (str[i] === '\\') {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}

function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
  }
}

/**
 * Marked
 */

function marked(src, opt, callback) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }

  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});
    checkSanitizeDeprecation(opt);

    var highlight = opt.highlight,
        tokens,
        pending,
        i = 0;

    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    checkSanitizeDeprecation(opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occurred:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.getDefaults = function() {
  return {
    baseUrl: null,
    breaks: false,
    gfm: true,
    headerIds: true,
    headerPrefix: '',
    highlight: null,
    langPrefix: 'language-',
    mangle: true,
    pedantic: false,
    renderer: new Renderer(),
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    xhtml: false
  };
};

marked.defaults = marked.getDefaults();

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.Slugger = Slugger;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  root.marked = marked;
}
})(this || (typeof window !== 'undefined' ? window : global));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],262:[function(require,module,exports){
/* eslint-env browser */
var marked = require('marked');

var dragdrop = require('drag-drop'); // Add Robodog JS. It is advisable to install Robodog from npm/yarn.
// But for experimenting, you can use also Transloadits CDN, Edgly:
// <script src="https://releases.transloadit.com/uppy/robodog/v1.10.12/robodog.min.js"></script>


var robodog = require('./../../../../packages/@uppy/robodog');

var TRANSLOADIT_EXAMPLE_KEY = '35c1aed03f5011e982b6afe82599b6a0';
var TRANSLOADIT_EXAMPLE_TEMPLATE = '0b2ee2bc25dc43619700c2ce0a75164a';
/**
 * A textarea for markdown text, with support for file attachments.
 *
 * ## Usage
 *
 * ```js
 * const element = document.querySelector('textarea')
 * const mdtxt = new MarkdownTextarea(element)
 * mdtxt.install()
 * ```
 */

var MarkdownTextarea = /*#__PURE__*/function () {
  function MarkdownTextarea(element) {
    this.element = element;
    this.controls = document.createElement('div');
    this.controls.classList.add('mdtxt-controls');
    this.uploadLine = document.createElement('button');
    this.uploadLine.setAttribute('type', 'button');
    this.uploadLine.classList.add('form-upload');
    this.uploadLine.appendChild(document.createTextNode('Tap here to upload an attachment'));
  }

  var _proto = MarkdownTextarea.prototype;

  _proto.install = function install() {
    var element = this.element;
    var wrapper = document.createElement('div');
    wrapper.classList.add('mdtxt');
    element.parentNode.replaceChild(wrapper, element);
    wrapper.appendChild(this.controls);
    wrapper.appendChild(element);
    wrapper.appendChild(this.uploadLine);
    this.setupUploadLine();
    this.setupTextareaDrop();
  };

  _proto.setupTextareaDrop = function setupTextareaDrop() {
    var _this = this;

    dragdrop(this.element, function (files) {
      _this.uploadFiles(files);
    });
  };

  _proto.setupUploadLine = function setupUploadLine() {
    var _this2 = this;

    this.uploadLine.addEventListener('click', function () {
      _this2.pickFiles();
    });
  };

  _proto.reportUploadError = function reportUploadError(err) {
    this.uploadLine.classList.add('error');
    var message = document.createElement('span');
    message.appendChild(document.createTextNode(err.message));
    this.uploadLine.insertChild(message, this.uploadLine.firstChild);
  };

  _proto.unreportUploadError = function unreportUploadError() {
    this.uploadLine.classList.remove('error');
    var message = this.uploadLine.querySelector('message');

    if (message) {
      this.uploadLine.removeChild(message);
    }
  };

  _proto.insertAttachments = function insertAttachments(attachments) {
    var _this3 = this;

    attachments.forEach(function (attachment) {
      var file = attachment.file,
          thumb = attachment.thumb;
      var link = "\n[LABEL](" + file.ssl_url + ")\n";
      var labelText = "View File " + file.basename;

      if (thumb) {
        _this3.element.value += link.replace('LABEL', "![" + labelText + "](" + thumb.ssl_url + ")");
      } else {
        _this3.element.value += link.replace('LABEL', labelText);
      }
    });
  };

  _proto.matchFilesAndThumbs = function matchFilesAndThumbs(results) {
    var filesById = {};
    var thumbsById = {};
    results.forEach(function (result) {
      if (result.stepName === 'thumbnails') {
        thumbsById[result.original_id] = result;
      } else {
        filesById[result.original_id] = result;
      }
    });
    return Object.keys(filesById).reduce(function (acc, key) {
      var file = filesById[key];
      var thumb = thumbsById[key];
      acc.push({
        file: file,
        thumb: thumb
      });
      return acc;
    }, []);
  };

  _proto.uploadFiles = function uploadFiles(files) {
    var _this4 = this;

    robodog.upload(files, {
      waitForEncoding: true,
      params: {
        auth: {
          key: TRANSLOADIT_EXAMPLE_KEY
        },
        template_id: TRANSLOADIT_EXAMPLE_TEMPLATE
      }
    }).then(function (result) {
      if (result === null) return;

      _this4.insertAttachments(_this4.matchFilesAndThumbs(result.results));
    }).catch(function (err) {
      console.error(err);

      _this4.reportUploadError(err);
    });
  };

  _proto.pickFiles = function pickFiles() {
    var _this5 = this;

    robodog.pick({
      waitForEncoding: true,
      params: {
        auth: {
          key: TRANSLOADIT_EXAMPLE_KEY
        },
        template_id: TRANSLOADIT_EXAMPLE_TEMPLATE
      },
      providers: ['webcam', 'url', 'instagram', 'google-drive', 'dropbox']
    }).then(function (result) {
      if (result === null) return;

      _this5.insertAttachments(_this5.matchFilesAndThumbs(result.results));
    }).catch(function (err) {
      console.error(err);

      _this5.reportUploadError(err);
    });
  };

  return MarkdownTextarea;
}();

var textarea = new MarkdownTextarea(document.querySelector('#new textarea'));
textarea.install();

function renderSnippet(title, text) {
  var template = document.querySelector('#snippet');
  var newSnippet = document.importNode(template.content, true);
  var titleEl = newSnippet.querySelector('.snippet-title');
  var contentEl = newSnippet.querySelector('.snippet-content');
  titleEl.appendChild(document.createTextNode(title));
  contentEl.innerHTML = marked(text);
  var list = document.querySelector('#snippets');
  list.insertBefore(newSnippet, list.firstChild);
}

function saveSnippet(title, text) {
  var id = parseInt(localStorage.numSnippets || 0, 10);
  localStorage["snippet_" + id] = JSON.stringify({
    title: title,
    text: text
  });
  localStorage.numSnippets = id + 1;
}

function loadSnippets() {
  for (var id = 0; localStorage["snippet_" + id] != null; id += 1) {
    var _JSON$parse = JSON.parse(localStorage["snippet_" + id]),
        title = _JSON$parse.title,
        text = _JSON$parse.text;

    renderSnippet(title, text);
  }
}

document.querySelector('#new').addEventListener('submit', function (event) {
  event.preventDefault();
  var title = event.target.querySelector('input[name="title"]').value || 'Unnamed Snippet';
  var text = textarea.element.value;
  saveSnippet(title, text);
  renderSnippet(title, text);
  event.target.querySelector('input').value = '';
  event.target.querySelector('textarea').value = '';
});
window.addEventListener('DOMContentLoaded', function () {
  loadSnippets();
});

},{"./../../../../packages/@uppy/robodog":156,"drag-drop":17,"marked":261}]},{},[262])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzL3ByZXR0aWVyQnl0ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWZ0ZXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYmFja28yL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1hcnJheWJ1ZmZlci9saWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ibG9iL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb21wb25lbnQtYmluZC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jdWlkL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2N1aWQvbGliL2ZpbmdlcnByaW50LmJyb3dzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvY3VpZC9saWIvZ2V0UmFuZG9tVmFsdWUuYnJvd3Nlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9jdWlkL2xpYi9wYWQuanMiLCIuLi9ub2RlX21vZHVsZXMvZHJhZy1kcm9wL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2RyYWctZHJvcC9ub2RlX21vZHVsZXMvZmxhdHRlbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2tleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvdXRmOC5qcyIsIi4uL25vZGVfbW9kdWxlcy9leGlmci9kaXN0L21pbmkubGVnYWN5LnVtZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9nZXQtZm9ybS1kYXRhL2xpYi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5Mi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5Mi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9oYXMtY29ycy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvaXMtc2hhbGxvdy1lcXVhbC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9qcy1iYXNlNjQvYmFzZTY0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gudGhyb3R0bGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbWF0aC1sb2cyL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL21lbW9pemUtb25lL2Rpc3QvbWVtb2l6ZS1vbmUuY2pzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21pbWUtbWF0Y2gvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbmFtZXNwYWNlLWVtaXR0ZXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3FzLXN0cmluZ2lmeS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ2lmeS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9xdWV1ZS1taWNyb3Rhc2svaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcmVxdWlyZXMtcG9ydC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ydW4tcGFyYWxsZWwvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvdG8tYXJyYXkvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvZmlsZVJlYWRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvYnJvd3Nlci9maW5nZXJwcmludC5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvYnJvd3Nlci9odHRwU3RhY2suanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvaXNDb3Jkb3ZhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL2lzUmVhY3ROYXRpdmUuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvcmVhZEFzQnl0ZUFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL3VyaVRvQmxvYi5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvYnJvd3Nlci91cmxTdG9yYWdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9lcnJvci5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvbG9nZ2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9ub29wVXJsU3RvcmFnZS5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvdXBsb2FkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS91dWlkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3VybC1wYXJzZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy93aWxkY2FyZC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy95ZWFzdC9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvbXBhbmlvbi1jbGllbnQvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvY29tcGFuaW9uLWNsaWVudC9zcmMvQXV0aEVycm9yLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29tcGFuaW9uLWNsaWVudC9zcmMvUHJvdmlkZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb21wYW5pb24tY2xpZW50L3NyYy9SZXF1ZXN0Q2xpZW50LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29tcGFuaW9uLWNsaWVudC9zcmMvU2VhcmNoUHJvdmlkZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb21wYW5pb24tY2xpZW50L3NyYy9Tb2NrZXQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb21wYW5pb24tY2xpZW50L3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvbXBhbmlvbi1jbGllbnQvc3JjL3Rva2VuU3RvcmFnZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvcmUvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvY29yZS9zcmMvUGx1Z2luLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29yZS9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb3JlL3NyYy9sb2dnZXJzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29yZS9zcmMvc3VwcG9ydHNVcGxvYWRQcm9ncmVzcy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvQWRkRmlsZXMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvQWRkRmlsZXNQYW5lbC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9EYXNoYm9hcmQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRWRpdG9yUGFuZWwuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUNhcmQvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vQnV0dG9ucy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9GaWxlSXRlbS9GaWxlSW5mby9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9GaWxlSXRlbS9GaWxlUHJldmlld0FuZExpbmsvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vRmlsZVByb2dyZXNzL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVJdGVtL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVMaXN0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVQcmV2aWV3LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL1BpY2tlclBhbmVsQ29udGVudC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9QaWNrZXJQYW5lbFRvcEJhci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9TbGlkZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9WaXJ0dWFsTGlzdC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL3V0aWxzL2NvcHlUb0NsaXBib2FyZC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvdXRpbHMvY3JlYXRlU3VwZXJGb2N1cy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvdXRpbHMvZ2V0QWN0aXZlT3ZlcmxheUVsLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy91dGlscy9nZXRGaWxlVHlwZUljb24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL3V0aWxzL2lnbm9yZUV2ZW50LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy91dGlscy90cmFwRm9jdXMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kcm9wYm94L3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L2Ryb3Bib3gvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZmFjZWJvb2svcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvZmFjZWJvb2svc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZm9ybS9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9mb3JtL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2dvb2dsZS1kcml2ZS9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9nb29nbGUtZHJpdmUvc3JjL0RyaXZlUHJvdmlkZXJWaWV3cy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2dvb2dsZS1kcml2ZS9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9pbmZvcm1lci9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9pbmZvcm1lci9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9pbnN0YWdyYW0vcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvaW5zdGFncmFtL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L29uZWRyaXZlL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L29uZWRyaXZlL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9CcmVhZGNydW1icy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9Ccm93c2VyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0Nsb3NlV3JhcHBlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9GaWx0ZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvRm9vdGVyQWN0aW9ucy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9JdGVtL2NvbXBvbmVudHMvR3JpZExpLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0l0ZW0vY29tcG9uZW50cy9JdGVtSWNvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9JdGVtL2NvbXBvbmVudHMvTGlzdExpLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0l0ZW0vaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvSXRlbUxpc3QuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvTG9hZGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1Byb3ZpZGVyVmlldy9BdXRoVmlldy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9Qcm92aWRlclZpZXcvSGVhZGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1Byb3ZpZGVyVmlldy9Qcm92aWRlclZpZXcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvUHJvdmlkZXJWaWV3L1VzZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvUHJvdmlkZXJWaWV3L2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1NlYXJjaFByb3ZpZGVyVmlldy9IZWFkZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvU2VhcmNoUHJvdmlkZXJWaWV3L0lucHV0Vmlldy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9TZWFyY2hQcm92aWRlclZpZXcvU2VhcmNoUHJvdmlkZXJWaWV3LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1NlYXJjaFByb3ZpZGVyVmlldy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9TaGFyZWRIYW5kbGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcm9ib2RvZy9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9yb2JvZG9nL3NyYy9BdHRhY2hGaWxlSW5wdXRzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcm9ib2RvZy9zcmMvVHJhbnNsb2FkaXRGb3JtUmVzdWx0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcm9ib2RvZy9zcmMvVHJhbnNsb2FkaXRSZXN1bHRzUGx1Z2luLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcm9ib2RvZy9zcmMvYWRkRGFzaGJvYXJkUGx1Z2luLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcm9ib2RvZy9zcmMvYWRkUHJvdmlkZXJzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcm9ib2RvZy9zcmMvYWRkVHJhbnNsb2FkaXRQbHVnaW4uanMiLCIuLi9wYWNrYWdlcy9AdXBweS9yb2JvZG9nL3NyYy9jcmVhdGVVcHB5LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcm9ib2RvZy9zcmMvZGFzaGJvYXJkLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcm9ib2RvZy9zcmMvZm9ybS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3JvYm9kb2cvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcm9ib2RvZy9zcmMvcGljay5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3JvYm9kb2cvc3JjL3VwbG9hZC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3N0YXR1cy1iYXIvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvc3RhdHVzLWJhci9zcmMvU3RhdHVzQmFyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc3RhdHVzLWJhci9zcmMvU3RhdHVzQmFyU3RhdGVzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc3RhdHVzLWJhci9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9zdG9yZS1kZWZhdWx0L3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3N0b3JlLWRlZmF1bHQvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdGh1bWJuYWlsLWdlbmVyYXRvci9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS90aHVtYm5haWwtZ2VuZXJhdG9yL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9wYXJzZXFzL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvbm9kZV9tb2R1bGVzL3BhcnNldXJpL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL21hbmFnZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvb24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL3VybC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaXMtYnVmZmVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvc3JjL0Fzc2VtYmx5LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvc3JjL0Fzc2VtYmx5T3B0aW9ucy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3RyYW5zbG9hZGl0L3NyYy9Bc3NlbWJseVdhdGNoZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90cmFuc2xvYWRpdC9zcmMvQ2xpZW50LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHJhbnNsb2FkaXQvc3JjL3BhcnNlVXJsLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHVzL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3R1cy9zcmMvZ2V0RmluZ2VycHJpbnQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90dXMvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXJsL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3VybC9zcmMvVXJsVUkuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91cmwvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXJsL3NyYy91dGlscy9mb3JFYWNoRHJvcHBlZE9yUGFzdGVkVXJsLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL0V2ZW50VHJhY2tlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9GT0NVU0FCTEVfRUxFTUVOVFMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvTmV0d29ya0Vycm9yLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL1JhdGVMaW1pdGVkUXVldWUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvVHJhbnNsYXRvci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9jYW52YXNUb0Jsb2IuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZGF0YVVSSXRvQmxvYi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9lbWl0U29ja2V0UHJvZ3Jlc3MuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZmV0Y2hXaXRoTmV0d29ya0Vycm9yLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2ZpbmRBbGxET01FbGVtZW50cy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9maW5kRE9NRWxlbWVudC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9maW5kSW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2VuZXJhdGVGaWxlSUQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0Qnl0ZXNSZW1haW5pbmcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RHJvcHBlZEZpbGVzL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldERyb3BwZWRGaWxlcy91dGlscy9mYWxsYmFja0FwaS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXREcm9wcGVkRmlsZXMvdXRpbHMvd2Via2l0R2V0QXNFbnRyeUFwaS9nZXRGaWxlc0FuZERpcmVjdG9yaWVzRnJvbURpcmVjdG9yeS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXREcm9wcGVkRmlsZXMvdXRpbHMvd2Via2l0R2V0QXNFbnRyeUFwaS9nZXRSZWxhdGl2ZVBhdGguanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RHJvcHBlZEZpbGVzL3V0aWxzL3dlYmtpdEdldEFzRW50cnlBcGkvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RmlsZVR5cGUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RmlsZVR5cGVFeHRlbnNpb24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0U29ja2V0SG9zdC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRTcGVlZC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRUZXh0RGlyZWN0aW9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldFRpbWVTdGFtcC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9oYXNQcm9wZXJ0eS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9pc0RPTUVsZW1lbnQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvaXNEcmFnRHJvcFN1cHBvcnRlZC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9pc05ldHdvcmtFcnJvci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9pc09iamVjdFVSTC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9pc1ByZXZpZXdTdXBwb3J0ZWQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvbWltZVR5cGVzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL3ByZXR0eUVUQS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9yZW1vdGVGaWxlT2JqVG9Mb2NhbC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9zZWNvbmRzVG9UaW1lLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL3NldHRsZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy90b0FycmF5LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL3RydW5jYXRlU3RyaW5nLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvQ2FtZXJhSWNvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvQ2FtZXJhU2NyZWVuLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9EaXNjYXJkQnV0dG9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9QZXJtaXNzaW9uc1NjcmVlbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvUmVjb3JkQnV0dG9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9SZWNvcmRpbmdMZW5ndGguanMiLCIuLi9wYWNrYWdlcy9AdXBweS93ZWJjYW0vc3JjL1NuYXBzaG90QnV0dG9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9TdWJtaXRCdXR0b24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS93ZWJjYW0vc3JjL1ZpZGVvU291cmNlU2VsZWN0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9mb3JtYXRTZWNvbmRzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvc3VwcG9ydHNNZWRpYVJlY29yZGVyLmpzIiwibm9kZV9tb2R1bGVzL21hcmtlZC9saWIvbWFya2VkLmpzIiwic3JjL2V4YW1wbGVzL21hcmtkb3duLXNuaXBwZXRzL2FwcC5lczYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsTkE7QUFDQTs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3g2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqb0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzljQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pDQSxJQUFNLEVBQUUsR0FBRyxlQUFYOztBQUNBLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxtQkFBRCxDQUF2Qjs7QUFDQSxJQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsNkJBQUQsQ0FBbkI7O0FBQ0EsSUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFlBQUQsQ0FBeEI7O0FBQ0EsSUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLDhCQUFELENBQTVCOztBQUNBLElBQU0scUJBQXFCLEdBQUcsT0FBTyxDQUFDLHVDQUFELENBQXJDLEMsQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxJQUFJLFFBQUo7O0FBQ0EsU0FBUyxlQUFULEdBQTRCO0FBQzFCLE1BQUksQ0FBQyxRQUFMLEVBQWU7QUFDYixJQUFBLFFBQVEsR0FBRyxPQUFPLENBQUMsa0JBQUQsQ0FBbEI7QUFDRDs7QUFDRCxTQUFPLFFBQVA7QUFDRDs7QUFFRCxJQUFNLGtCQUFrQixHQUFHLG9CQUEzQjtBQUNBLElBQU0sa0JBQWtCLEdBQUcsb0JBQTNCO0FBQ0EsSUFBTSxrQkFBa0IsR0FBRyxvQkFBM0I7QUFFQSxJQUFNLFdBQVcsR0FBRyxDQUNsQixrQkFEa0IsRUFFbEIsa0JBRmtCLEVBR2xCLGtCQUhrQixDQUFwQjtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVMsUUFBVCxDQUFtQixNQUFuQixFQUEyQixJQUEzQixFQUFpQztBQUMvQixTQUFPLFdBQVcsQ0FBQyxPQUFaLENBQW9CLE1BQXBCLEtBQStCLFdBQVcsQ0FBQyxPQUFaLENBQW9CLElBQXBCLENBQXRDO0FBQ0Q7O0lBRUssbUI7OztBQUNKLCtCQUFhLFFBQWIsRUFBdUI7QUFBQTs7QUFDckIsd0NBRHFCLENBR3JCOztBQUNBLFVBQUssTUFBTCxHQUFjLFFBQWQsQ0FKcUIsQ0FLckI7O0FBQ0EsVUFBSyxNQUFMLEdBQWMsSUFBZCxDQU5xQixDQU9yQjs7QUFDQSxVQUFLLFlBQUwsR0FBb0IsSUFBcEIsQ0FScUIsQ0FTckI7O0FBQ0EsVUFBSyxNQUFMLEdBQWMsS0FBZDtBQVZxQjtBQVd0Qjs7OztTQUVELE8sR0FBQSxtQkFBVztBQUNULFNBQUssY0FBTDs7QUFDQSxTQUFLLGFBQUw7QUFDRCxHOztTQUVELFcsR0FBQSx1QkFBZTtBQUNiLFNBQUssSUFBTCxDQUFVLFVBQVY7QUFDQSxTQUFLLEtBQUw7QUFDRCxHOztTQUVELGMsR0FBQSwwQkFBa0I7QUFBQTs7QUFDaEIsUUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLEtBQUssTUFBTCxDQUFZLGFBQWIsQ0FBdkI7QUFDQSxRQUFNLE1BQU0sR0FBRyxFQUFFLEdBQUcsT0FBTCxDQUFhLE1BQU0sQ0FBQyxNQUFwQixFQUE0QjtBQUN6QyxNQUFBLFVBQVUsRUFBRSxDQUFDLFdBQUQsQ0FENkI7QUFFekMsTUFBQSxJQUFJLEVBQUUsTUFBTSxDQUFDO0FBRjRCLEtBQTVCLENBQWY7QUFLQSxJQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUsU0FBVixFQUFxQixZQUFNO0FBQ3pCLE1BQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxrQkFBWixFQUFnQztBQUM5QixRQUFBLEVBQUUsRUFBRSxNQUFJLENBQUMsTUFBTCxDQUFZO0FBRGMsT0FBaEM7O0FBSUEsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLFNBQVY7QUFDRCxLQU5EO0FBUUEsSUFBQSxNQUFNLENBQUMsRUFBUCxDQUFVLGdCQUFWLEVBQTRCLFlBQU07QUFDaEMsTUFBQSxNQUFJLENBQUMsUUFBTCxDQUFjLElBQUksWUFBSixDQUFpQix3Q0FBakIsQ0FBZDs7QUFDQSxNQUFBLE1BQUksQ0FBQyxNQUFMLEdBQWMsSUFBZDtBQUNELEtBSEQ7QUFLQSxJQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUsT0FBVixFQUFtQixZQUFNO0FBQ3ZCLE1BQUEsTUFBTSxDQUFDLFVBQVA7QUFDQSxNQUFBLE1BQUksQ0FBQyxNQUFMLEdBQWMsSUFBZDtBQUNELEtBSEQ7QUFLQSxJQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUsbUJBQVYsRUFBK0IsWUFBTTtBQUNuQyxNQUFBLE1BQUksQ0FBQyxXQUFMO0FBQ0QsS0FGRDtBQUlBLElBQUEsTUFBTSxDQUFDLEVBQVAsQ0FBVSwwQkFBVixFQUFzQyxVQUFDLElBQUQsRUFBVTtBQUM5QyxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsUUFBVixFQUFvQixJQUFwQjs7QUFDQSxNQUFBLE1BQUksQ0FBQyxNQUFMLENBQVksT0FBWixDQUFvQixJQUFwQixDQUF5QixJQUF6QjtBQUNELEtBSEQ7QUFLQSxJQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUsNkJBQVYsRUFBeUMsWUFBTTtBQUM3QyxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsV0FBVjtBQUNELEtBRkQ7QUFJQSxJQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUscUNBQVYsRUFBaUQsWUFBTTtBQUNyRCxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsVUFBVjs7QUFDQSxNQUFBLE1BQUksQ0FBQyxZQUFMLENBQWtCO0FBQUUsUUFBQSxJQUFJLEVBQUU7QUFBUixPQUFsQjtBQUNELEtBSEQ7QUFLQSxJQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUsMEJBQVYsRUFBc0MsVUFBQyxRQUFELEVBQVcsTUFBWCxFQUFzQjtBQUMxRCxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsUUFBVixFQUFvQixRQUFwQixFQUE4QixNQUE5Qjs7QUFDQSxVQUFJLENBQUMsTUFBSSxDQUFDLE1BQUwsQ0FBWSxPQUFaLENBQW9CLFFBQXBCLENBQUwsRUFBb0M7QUFDbEMsUUFBQSxNQUFJLENBQUMsTUFBTCxDQUFZLE9BQVosQ0FBb0IsUUFBcEIsSUFBZ0MsRUFBaEM7QUFDRDs7QUFDRCxNQUFBLE1BQUksQ0FBQyxNQUFMLENBQVksT0FBWixDQUFvQixRQUFwQixFQUE4QixJQUE5QixDQUFtQyxNQUFuQztBQUNELEtBTkQ7QUFRQSxJQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUsZ0JBQVYsRUFBNEIsVUFBQyxHQUFELEVBQVM7QUFDbkMsTUFBQSxNQUFJLENBQUMsUUFBTCxDQUFjLEdBQWQsRUFEbUMsQ0FFbkM7OztBQUNBLE1BQUEsTUFBSSxDQUFDLFlBQUwsQ0FBa0I7QUFBRSxRQUFBLElBQUksRUFBRTtBQUFSLE9BQWxCO0FBQ0QsS0FKRDtBQU1BLFNBQUssTUFBTCxHQUFjLE1BQWQ7QUFDRCxHOztTQUVELFEsR0FBQSxrQkFBVSxHQUFWLEVBQWU7QUFDYixTQUFLLElBQUwsQ0FBVSxPQUFWLEVBQW1CLFNBQWMsSUFBSSxLQUFKLENBQVUsR0FBRyxDQUFDLE9BQWQsQ0FBZCxFQUFzQyxHQUF0QyxDQUFuQjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7U0FDRSxhLEdBQUEseUJBQWlCO0FBQUE7O0FBQ2YsU0FBSyxZQUFMLEdBQW9CLFdBQVcsQ0FBQyxZQUFNO0FBQ3BDLFVBQUksQ0FBQyxNQUFJLENBQUMsTUFBTixJQUFnQixDQUFDLE1BQUksQ0FBQyxNQUFMLENBQVksU0FBakMsRUFBNEM7QUFDMUMsUUFBQSxNQUFJLENBQUMsWUFBTDtBQUNEO0FBQ0YsS0FKOEIsRUFJNUIsSUFKNEIsQ0FBL0I7QUFLRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O1NBQ0UsWSxHQUFBLDZCQUFvQztBQUFBOztBQUFBLGtDQUFKLEVBQUk7QUFBQSx5QkFBcEIsSUFBb0I7QUFBQSxRQUFwQixJQUFvQiwwQkFBYixJQUFhOztBQUNsQyxXQUFPLHFCQUFxQixDQUFDLEtBQUssTUFBTCxDQUFZLGdCQUFiLENBQXJCLENBQ0osSUFESSxDQUNDLFVBQUMsUUFBRDtBQUFBLGFBQWMsUUFBUSxDQUFDLElBQVQsRUFBZDtBQUFBLEtBREQsRUFFSixJQUZJLENBRUMsVUFBQyxNQUFELEVBQVk7QUFDaEI7QUFDQSxVQUFJLE1BQUksQ0FBQyxNQUFULEVBQWlCOztBQUNqQixNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsUUFBVixFQUFvQixNQUFwQjs7QUFFQSxVQUFJLElBQUosRUFBVTtBQUNSLFFBQUEsTUFBSSxDQUFDLFlBQUwsQ0FBa0IsTUFBbEI7QUFDRCxPQUZELE1BRU87QUFDTCxRQUFBLE1BQUksQ0FBQyxNQUFMLEdBQWMsTUFBZDtBQUNEO0FBQ0YsS0FaSSxFQWFKLEtBYkksQ0FhRSxVQUFDLEdBQUQ7QUFBQSxhQUFTLE1BQUksQ0FBQyxRQUFMLENBQWMsR0FBZCxDQUFUO0FBQUEsS0FiRixDQUFQO0FBY0QsRzs7U0FFRCxNLEdBQUEsa0JBQVU7QUFDUixXQUFPLEtBQUssWUFBTCxDQUFrQjtBQUFFLE1BQUEsSUFBSSxFQUFFO0FBQVIsS0FBbEIsQ0FBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7U0FDRSxZLEdBQUEsc0JBQWMsSUFBZCxFQUFvQjtBQUNsQixTQUFLLFdBQUwsQ0FBaUIsS0FBSyxNQUF0QixFQUE4QixJQUE5Qjs7QUFDQSxTQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O1NBQ0UsVyxHQUFBLHFCQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUI7QUFBQTs7QUFDdkIsUUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEVBQXhCO0FBQ0EsUUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEVBQXhCOztBQUVBLFFBQUksSUFBSSxDQUFDLEtBQUwsSUFBYyxDQUFDLElBQUksQ0FBQyxLQUF4QixFQUErQjtBQUM3QixhQUFPLEtBQUssUUFBTCxDQUFjLElBQWQsQ0FBUDtBQUNELEtBTnNCLENBUXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBLFFBQU0sWUFBWSxHQUNkLFFBQVEsQ0FBQyxVQUFELEVBQWEsa0JBQWIsQ0FBUixJQUNDLENBQUMsUUFBUSxDQUFDLFVBQUQsRUFBYSxrQkFBYixDQUZkOztBQUdBLFFBQUksWUFBSixFQUFrQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQUssSUFBTCxDQUFVLFdBQVY7QUFDRCxLQTFCc0IsQ0E0QnZCOzs7QUFDQSxJQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksSUFBSSxDQUFDLE9BQWpCLEVBQ0csTUFESCxDQUNVLFVBQUMsTUFBRDtBQUFBLGFBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU4sRUFBZSxNQUFmLENBQWhCO0FBQUEsS0FEVixFQUVHLEdBRkgsQ0FFTyxVQUFDLE1BQUQ7QUFBQSxhQUFZLElBQUksQ0FBQyxPQUFMLENBQWEsTUFBYixDQUFaO0FBQUEsS0FGUCxFQUdHLE9BSEgsQ0FHVyxVQUFDLE1BQUQsRUFBWTtBQUNuQixNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsUUFBVixFQUFvQixNQUFwQjtBQUNELEtBTEg7O0FBT0EsUUFBSSxZQUFKLEVBQWtCO0FBQ2hCLFdBQUssSUFBTCxDQUFVLFVBQVY7QUFDRCxLQXRDc0IsQ0F3Q3ZCOzs7QUFDQSxJQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksSUFBSSxDQUFDLE9BQWpCLEVBQTBCLE9BQTFCLENBQWtDLFVBQUMsUUFBRCxFQUFjO0FBQzlDLFVBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFMLENBQWEsUUFBYixDQUFwQjtBQUNBLFVBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFMLENBQWEsUUFBYixDQUFwQjtBQUVBLE1BQUEsV0FBVyxDQUNSLE1BREgsQ0FDVSxVQUFDLENBQUQ7QUFBQSxlQUFPLENBQUMsV0FBRCxJQUFnQixDQUFDLFdBQVcsQ0FBQyxJQUFaLENBQWlCLFVBQUMsQ0FBRDtBQUFBLGlCQUFPLENBQUMsQ0FBQyxFQUFGLEtBQVMsQ0FBQyxDQUFDLEVBQWxCO0FBQUEsU0FBakIsQ0FBeEI7QUFBQSxPQURWLEVBRUcsT0FGSCxDQUVXLFVBQUMsTUFBRCxFQUFZO0FBQ25CLFFBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxRQUFWLEVBQW9CLFFBQXBCLEVBQThCLE1BQTlCO0FBQ0QsT0FKSDtBQUtELEtBVEQ7O0FBV0EsUUFBSSxRQUFRLENBQUMsVUFBRCxFQUFhLGtCQUFiLENBQVIsSUFDRyxDQUFDLFFBQVEsQ0FBQyxVQUFELEVBQWEsa0JBQWIsQ0FEaEIsRUFDa0Q7QUFDaEQsV0FBSyxJQUFMLENBQVUsVUFBVjtBQUNEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7OztTQUNFLEssR0FBQSxpQkFBUztBQUNQLFNBQUssTUFBTCxHQUFjLElBQWQ7O0FBQ0EsUUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDZixXQUFLLE1BQUwsQ0FBWSxVQUFaO0FBQ0EsV0FBSyxNQUFMLEdBQWMsSUFBZDtBQUNEOztBQUNELElBQUEsYUFBYSxDQUFDLEtBQUssWUFBTixDQUFiO0FBQ0QsRzs7O0VBdk4rQixPOztBQTBObEMsTUFBTSxDQUFDLE9BQVAsR0FBaUIsbUJBQWpCOzs7QUN0UUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxjQUFULENBQXlCLE1BQXpCLEVBQWlDO0FBQy9CLE1BQUksQ0FBQyxNQUFMLEVBQWE7QUFDWCxVQUFNLElBQUksS0FBSixDQUFVLCtDQUFWLENBQU47QUFDRDs7QUFFRCxNQUFJLE9BQU8sTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QixRQUFJO0FBQ0YsTUFBQSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBVyxNQUFYLENBQVQ7QUFDRCxLQUZELENBRUUsT0FBTyxHQUFQLEVBQVk7QUFDWjtBQUNBLE1BQUEsR0FBRyxDQUFDLE9BQUoscUVBQ0UsR0FBRyxDQUFDLE9BRE47QUFFQSxZQUFNLEdBQU47QUFDRDtBQUNGOztBQUVELE1BQUksQ0FBQyxNQUFNLENBQUMsSUFBUixJQUFnQixDQUFDLE1BQU0sQ0FBQyxJQUFQLENBQVksR0FBakMsRUFBc0M7QUFDcEMsVUFBTSxJQUFJLEtBQUosQ0FBVSw0REFDWix3RkFERSxDQUFOO0FBRUQ7QUFDRjtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7SUFDTSxlO0FBQ0osMkJBQWEsS0FBYixFQUFvQixJQUFwQixFQUEwQjtBQUN4QixTQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsU0FBSyxJQUFMLEdBQVksSUFBWjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7Ozs7O1NBQ0UseUIsR0FBQSxtQ0FBMkIsSUFBM0IsRUFBaUMsZUFBakMsRUFBa0Q7QUFDaEQsUUFBSSxLQUFLLENBQUMsT0FBTixDQUFjLGVBQWUsQ0FBQyxNQUE5QixDQUFKLEVBQTJDO0FBQ3pDLFVBQU0sVUFBVSxHQUFHLGVBQWUsQ0FBQyxNQUFuQztBQUNBLE1BQUEsZUFBZSxDQUFDLE1BQWhCLEdBQXlCLEVBQXpCO0FBQ0EsTUFBQSxVQUFVLENBQUMsT0FBWCxDQUFtQixVQUFDLFNBQUQsRUFBZTtBQUNoQyxRQUFBLGVBQWUsQ0FBQyxNQUFoQixDQUF1QixTQUF2QixJQUFvQyxJQUFJLENBQUMsSUFBTCxDQUFVLFNBQVYsQ0FBcEM7QUFDRCxPQUZEO0FBR0Q7O0FBRUQsUUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFyQixFQUE2QjtBQUMzQixNQUFBLGVBQWUsQ0FBQyxNQUFoQixHQUF5QixFQUF6QjtBQUNEOztBQUVELFdBQU8sZUFBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7U0FDRSxtQixHQUFBLDZCQUFxQixJQUFyQixFQUEyQjtBQUFBOztBQUN6QixRQUFNLE9BQU8sR0FBRyxLQUFLLElBQXJCO0FBRUEsV0FBTyxPQUFPLENBQUMsT0FBUixHQUNKLElBREksQ0FDQyxZQUFNO0FBQ1YsYUFBTyxPQUFPLENBQUMsa0JBQVIsQ0FBMkIsSUFBM0IsRUFBaUMsT0FBakMsQ0FBUDtBQUNELEtBSEksRUFJSixJQUpJLENBSUMsVUFBQyxlQUFELEVBQXFCO0FBQ3pCLGFBQU8sS0FBSSxDQUFDLHlCQUFMLENBQStCLElBQS9CLEVBQXFDLGVBQXJDLENBQVA7QUFDRCxLQU5JLEVBT0osSUFQSSxDQU9DLFVBQUMsZUFBRCxFQUFxQjtBQUN6QixNQUFBLGNBQWMsQ0FBQyxlQUFlLENBQUMsTUFBakIsQ0FBZDtBQUVBLGFBQU87QUFDTCxRQUFBLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFOLENBREo7QUFFTCxRQUFBLE9BQU8sRUFBRTtBQUZKLE9BQVA7QUFJRCxLQWRJLENBQVA7QUFlRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBOzs7U0FDRSxPLEdBQUEsaUJBQVMsSUFBVCxFQUFlO0FBQ2IsUUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQVAsQ0FBYyxJQUFkLENBQWxCO0FBQ0EsSUFBQSxJQUFJLENBQUMsT0FBTCxDQUFhLGdCQUEwQjtBQUFBLFVBQXZCLE9BQXVCLFFBQXZCLE9BQXVCO0FBQUEsVUFBZCxPQUFjLFFBQWQsT0FBYztBQUNyQyxVQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsU0FBTCxDQUFlLE9BQWYsQ0FBWDs7QUFDQSxVQUFJLFNBQVMsQ0FBQyxFQUFELENBQWIsRUFBbUI7QUFBQTs7QUFDakIsaUNBQUEsU0FBUyxDQUFDLEVBQUQsQ0FBVCxDQUFjLE9BQWQsRUFBc0IsSUFBdEIsOEJBQThCLE9BQTlCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsUUFBQSxTQUFTLENBQUMsRUFBRCxDQUFULEdBQWdCO0FBQ2QsVUFBQSxPQUFPLEVBQVAsT0FEYztBQUVkLFVBQUEsT0FBTyxZQUFNLE9BQU47QUFGTyxTQUFoQjtBQUlEO0FBQ0YsS0FWRDtBQVlBLFdBQU8sTUFBTSxDQUFDLElBQVAsQ0FBWSxTQUFaLEVBQXVCLEdBQXZCLENBQTJCLFVBQUMsRUFBRDtBQUFBLGFBQVEsU0FBUyxDQUFDLEVBQUQsQ0FBakI7QUFBQSxLQUEzQixDQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztTQUNFLEssR0FBQSxpQkFBUztBQUFBOztBQUNQLFFBQU0sT0FBTyxHQUFHLEtBQUssSUFBckI7O0FBRUEsUUFBSSxLQUFLLEtBQUwsQ0FBVyxNQUFYLEdBQW9CLENBQXhCLEVBQTJCO0FBQ3pCLGFBQU8sT0FBTyxDQUFDLEdBQVIsQ0FDTCxLQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWUsVUFBQyxJQUFEO0FBQUEsZUFBVSxNQUFJLENBQUMsbUJBQUwsQ0FBeUIsSUFBekIsQ0FBVjtBQUFBLE9BQWYsQ0FESyxFQUVMLElBRkssQ0FFQSxVQUFDLElBQUQsRUFBVTtBQUNmLGVBQU8sTUFBSSxDQUFDLE9BQUwsQ0FBYSxJQUFiLENBQVA7QUFDRCxPQUpNLENBQVA7QUFLRDs7QUFFRCxRQUFJLE9BQU8sQ0FBQyxpQkFBWixFQUErQjtBQUM3QjtBQUNBLGFBQU8sT0FBTyxDQUFDLE9BQVIsQ0FDTCxPQUFPLENBQUMsa0JBQVIsQ0FBMkIsSUFBM0IsRUFBaUMsT0FBakMsQ0FESyxFQUVMLElBRkssQ0FFQSxVQUFDLGVBQUQsRUFBcUI7QUFDMUIsUUFBQSxjQUFjLENBQUMsZUFBZSxDQUFDLE1BQWpCLENBQWQ7QUFDQSxlQUFPLENBQUM7QUFDTixVQUFBLE9BQU8sRUFBRSxNQUFJLENBQUMsS0FBTCxDQUFXLEdBQVgsQ0FBZSxVQUFDLElBQUQ7QUFBQSxtQkFBVSxJQUFJLENBQUMsRUFBZjtBQUFBLFdBQWYsQ0FESDtBQUVOLFVBQUEsT0FBTyxFQUFFO0FBRkgsU0FBRCxDQUFQO0FBSUQsT0FSTSxDQUFQO0FBU0QsS0F0Qk0sQ0F3QlA7QUFDQTs7O0FBQ0EsV0FBTyxPQUFPLENBQUMsT0FBUixDQUFnQixFQUFoQixDQUFQO0FBQ0QsRzs7Ozs7QUFHSCxNQUFNLENBQUMsT0FBUCxHQUFpQixlQUFqQjtBQUNBLE1BQU0sQ0FBQyxPQUFQLENBQWUsY0FBZixHQUFnQyxjQUFoQzs7Ozs7Ozs7O0FDeElBLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxtQkFBRCxDQUF2QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztJQUNNLDBCOzs7QUFDSixzQ0FBYSxJQUFiLEVBQW1CLFdBQW5CLEVBQWdDO0FBQUE7O0FBQzlCO0FBRUEsVUFBSyxLQUFMLEdBQWEsSUFBYjtBQUNBLFVBQUssWUFBTCxHQUFvQixXQUFwQjtBQUNBLFVBQUssVUFBTCxHQUFrQixXQUFXLENBQUMsTUFBOUI7QUFFQSxVQUFLLE9BQUwsR0FBZSxJQUFJLE9BQUosQ0FBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCO0FBQzlDLFlBQUssUUFBTCxHQUFnQixPQUFoQjtBQUNBLFlBQUssT0FBTCxHQUFlLE1BQWY7QUFDRCxLQUhjLENBQWY7QUFLQSxVQUFLLG1CQUFMLEdBQTJCLE1BQUssbUJBQUwsQ0FBeUIsSUFBekIsK0JBQTNCO0FBQ0EsVUFBSyxpQkFBTCxHQUF5QixNQUFLLGlCQUFMLENBQXVCLElBQXZCLCtCQUF6QjtBQUNBLFVBQUssZ0JBQUwsR0FBd0IsTUFBSyxnQkFBTCxDQUFzQixJQUF0QiwrQkFBeEI7QUFDQSxVQUFLLGNBQUwsR0FBc0IsTUFBSyxjQUFMLENBQW9CLElBQXBCLCtCQUF0Qjs7QUFFQSxVQUFLLGFBQUw7O0FBakI4QjtBQWtCL0I7QUFFRDtBQUNGO0FBQ0E7Ozs7O1NBQ0UsUyxHQUFBLG1CQUFXLEVBQVgsRUFBZTtBQUNiLFdBQU8sS0FBSyxZQUFMLENBQWtCLE9BQWxCLENBQTBCLEVBQTFCLE1BQWtDLENBQUMsQ0FBMUM7QUFDRCxHOztTQUVELG1CLEdBQUEsNkJBQXFCLFFBQXJCLEVBQStCO0FBQzdCLFFBQUksQ0FBQyxLQUFLLFNBQUwsQ0FBZSxRQUFRLENBQUMsV0FBeEIsQ0FBTCxFQUEyQztBQUN6QztBQUNEOztBQUVELFNBQUssS0FBTCxDQUFXLEdBQVgseURBQXFFLFFBQVEsQ0FBQyxXQUE5RTs7QUFFQSxTQUFLLElBQUwsQ0FBVSxtQkFBVixFQUErQixRQUFRLENBQUMsV0FBeEM7O0FBRUEsU0FBSyxpQkFBTDtBQUNELEc7O1NBRUQsaUIsR0FBQSwyQkFBbUIsUUFBbkIsRUFBNkI7QUFDM0IsUUFBSSxDQUFDLEtBQUssU0FBTCxDQUFlLFFBQVEsQ0FBQyxXQUF4QixDQUFMLEVBQTJDO0FBQ3pDO0FBQ0Q7O0FBRUQsU0FBSyxpQkFBTDtBQUNELEc7O1NBRUQsZ0IsR0FBQSwwQkFBa0IsUUFBbEIsRUFBNEIsS0FBNUIsRUFBbUM7QUFDakMsUUFBSSxDQUFDLEtBQUssU0FBTCxDQUFlLFFBQVEsQ0FBQyxXQUF4QixDQUFMLEVBQTJDO0FBQ3pDO0FBQ0Q7O0FBRUQsU0FBSyxLQUFMLENBQVcsR0FBWCx3REFBb0UsUUFBUSxDQUFDLFdBQTdFOztBQUNBLFNBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZSxLQUFmOztBQUVBLFNBQUssSUFBTCxDQUFVLGdCQUFWLEVBQTRCLFFBQVEsQ0FBQyxXQUFyQyxFQUFrRCxLQUFsRDs7QUFFQSxTQUFLLGlCQUFMO0FBQ0QsRzs7U0FFRCxjLEdBQUEsd0JBQWdCLFFBQWhCLEVBQTBCLE1BQTFCLEVBQWtDLEtBQWxDLEVBQXlDO0FBQ3ZDLFFBQUksQ0FBQyxLQUFLLFNBQUwsQ0FBZSxRQUFRLENBQUMsV0FBeEIsQ0FBTCxFQUEyQztBQUN6QztBQUNELEtBSHNDLENBS3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQUssZ0JBQUwsQ0FBc0IsUUFBdEIsRUFBZ0MsS0FBaEM7QUFDRCxHOztTQUVELGlCLEdBQUEsNkJBQXFCO0FBQ25CLFNBQUssVUFBTCxJQUFtQixDQUFuQjs7QUFDQSxRQUFJLEtBQUssVUFBTCxLQUFvQixDQUF4QixFQUEyQjtBQUN6QjtBQUNBLFdBQUssZ0JBQUw7O0FBQ0EsV0FBSyxRQUFMO0FBQ0Q7QUFDRixHOztTQUVELGdCLEdBQUEsNEJBQW9CO0FBQ2xCLFNBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZSxzQkFBZixFQUF1QyxLQUFLLG1CQUE1Qzs7QUFDQSxTQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWUsNkJBQWYsRUFBOEMsS0FBSyxpQkFBbkQ7O0FBQ0EsU0FBSyxLQUFMLENBQVcsR0FBWCxDQUFlLDRCQUFmLEVBQTZDLEtBQUssZ0JBQWxEOztBQUNBLFNBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZSwwQkFBZixFQUEyQyxLQUFLLGNBQWhEO0FBQ0QsRzs7U0FFRCxhLEdBQUEseUJBQWlCO0FBQ2YsU0FBSyxLQUFMLENBQVcsRUFBWCxDQUFjLHNCQUFkLEVBQXNDLEtBQUssbUJBQTNDOztBQUNBLFNBQUssS0FBTCxDQUFXLEVBQVgsQ0FBYyw2QkFBZCxFQUE2QyxLQUFLLGlCQUFsRDs7QUFDQSxTQUFLLEtBQUwsQ0FBVyxFQUFYLENBQWMsNEJBQWQsRUFBNEMsS0FBSyxnQkFBakQ7O0FBQ0EsU0FBSyxLQUFMLENBQVcsRUFBWCxDQUFjLDBCQUFkLEVBQTBDLEtBQUssY0FBL0M7QUFDRCxHOzs7RUEvRnNDLE87O0FBa0d6QyxNQUFNLENBQUMsT0FBUCxHQUFpQiwwQkFBakI7OztBQzVHQSxJQUFNLHFCQUFxQixHQUFHLE9BQU8sQ0FBQyx1Q0FBRCxDQUFyQzs7QUFDQSxJQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsV0FBRCxDQUFuQjtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTSxDQUFDLE9BQVA7QUFDRSxrQkFBYSxJQUFiLEVBQXdCO0FBQUEsUUFBWCxJQUFXO0FBQVgsTUFBQSxJQUFXLEdBQUosRUFBSTtBQUFBOztBQUN0QixTQUFLLElBQUwsR0FBWSxJQUFaO0FBRUEsU0FBSyxZQUFMLEdBQW9CLEtBQUssWUFBTCxDQUFrQixJQUFsQixDQUF1QixJQUF2QixDQUFwQjtBQUVBLFNBQUssUUFBTCxHQUFnQjtBQUNkLDRCQUFzQixLQUFLLElBQUwsQ0FBVTtBQURsQixLQUFoQjtBQUdEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFuQkE7O0FBQUEsU0FvQkUsY0FwQkYsR0FvQkUsOEJBS0c7QUFBQTs7QUFBQSxRQUpELE1BSUMsUUFKRCxNQUlDO0FBQUEsUUFIRCxNQUdDLFFBSEQsTUFHQztBQUFBLFFBRkQsU0FFQyxRQUZELFNBRUM7QUFBQSxRQURELGFBQ0MsUUFERCxhQUNDO0FBQ0QsUUFBTSxJQUFJLEdBQUcsSUFBSSxRQUFKLEVBQWI7QUFDQSxJQUFBLElBQUksQ0FBQyxNQUFMLENBQVksUUFBWixFQUFzQixPQUFPLE1BQVAsS0FBa0IsUUFBbEIsR0FDbEIsTUFEa0IsR0FFbEIsSUFBSSxDQUFDLFNBQUwsQ0FBZSxNQUFmLENBRko7O0FBR0EsUUFBSSxTQUFKLEVBQWU7QUFDYixNQUFBLElBQUksQ0FBQyxNQUFMLENBQVksV0FBWixFQUF5QixTQUF6QjtBQUNEOztBQUVELElBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxNQUFaLEVBQW9CLE9BQXBCLENBQTRCLFVBQUMsR0FBRCxFQUFTO0FBQ25DLE1BQUEsSUFBSSxDQUFDLE1BQUwsQ0FBWSxHQUFaLEVBQWlCLE1BQU0sQ0FBQyxHQUFELENBQXZCO0FBQ0QsS0FGRDtBQUdBLElBQUEsSUFBSSxDQUFDLE1BQUwsQ0FBWSwyQkFBWixFQUF5QyxhQUF6QztBQUVBLFFBQU0sR0FBRyxHQUFHLElBQUksR0FBSixDQUFRLGFBQVIsT0FBMEIsS0FBSyxJQUFMLENBQVUsT0FBcEMsRUFBK0MsSUFBM0Q7QUFDQSxXQUFPLHFCQUFxQixDQUFDLEdBQUQsRUFBTTtBQUNoQyxNQUFBLE1BQU0sRUFBRSxNQUR3QjtBQUVoQyxNQUFBLE9BQU8sRUFBRSxLQUFLLFFBRmtCO0FBR2hDLE1BQUEsSUFBSSxFQUFFO0FBSDBCLEtBQU4sQ0FBckIsQ0FLSixJQUxJLENBS0MsVUFBQyxRQUFEO0FBQUEsYUFBYyxRQUFRLENBQUMsSUFBVCxFQUFkO0FBQUEsS0FMRCxFQUtnQyxJQUxoQyxDQUtxQyxVQUFDLFFBQUQsRUFBYztBQUN0RCxVQUFJLFFBQVEsQ0FBQyxLQUFiLEVBQW9CO0FBQ2xCLFlBQU0sS0FBSyxHQUFHLElBQUksS0FBSixDQUFVLFFBQVEsQ0FBQyxLQUFuQixDQUFkO0FBQ0EsUUFBQSxLQUFLLENBQUMsT0FBTixHQUFnQixRQUFRLENBQUMsT0FBekI7QUFDQSxRQUFBLEtBQUssQ0FBQyxRQUFOLEdBQWlCLFFBQWpCOztBQUNBLFlBQUksUUFBUSxDQUFDLFdBQWIsRUFBMEI7QUFDeEIsVUFBQSxLQUFLLENBQUMsT0FBTixJQUFpQix5QkFBc0IsUUFBUSxDQUFDLFdBQS9CLENBQWpCO0FBQ0Q7O0FBQ0QsY0FBTSxLQUFOO0FBQ0Q7O0FBRUQsYUFBTyxRQUFQO0FBQ0QsS0FqQkksRUFrQkosS0FsQkksQ0FrQkUsVUFBQyxHQUFEO0FBQUEsYUFBUyxLQUFJLENBQUMsWUFBTCxDQUFrQixHQUFsQixFQUF1QjtBQUFFLFFBQUEsR0FBRyxFQUFILEdBQUY7QUFBTyxRQUFBLElBQUksRUFBRTtBQUFiLE9BQXZCLENBQVQ7QUFBQSxLQWxCRixDQUFQO0FBbUJEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEVBOztBQUFBLFNBbUVFLFdBbkVGLEdBbUVFLHFCQUFhLFFBQWIsRUFBdUIsSUFBdkIsRUFBNkI7QUFBQTs7QUFDM0IsUUFBTSxJQUFJLEdBQUcsa0JBQWtCLENBQUMsSUFBSSxDQUFDLElBQU4sQ0FBL0I7QUFDQSxRQUFNLEdBQUcsR0FBTSxRQUFRLENBQUMsZ0JBQWYsMkJBQXFELElBQTlEO0FBQ0EsV0FBTyxxQkFBcUIsQ0FBQyxHQUFELEVBQU07QUFBRSxNQUFBLE1BQU0sRUFBRSxNQUFWO0FBQWtCLE1BQUEsT0FBTyxFQUFFLEtBQUs7QUFBaEMsS0FBTixDQUFyQixDQUNKLElBREksQ0FDQyxVQUFDLFFBQUQ7QUFBQSxhQUFjLFFBQVEsQ0FBQyxJQUFULEVBQWQ7QUFBQSxLQURELEVBRUosS0FGSSxDQUVFLFVBQUMsR0FBRDtBQUFBLGFBQVMsTUFBSSxDQUFDLFlBQUwsQ0FBa0IsR0FBbEIsRUFBdUI7QUFBRSxRQUFBLFFBQVEsRUFBUixRQUFGO0FBQVksUUFBQSxJQUFJLEVBQUosSUFBWjtBQUFrQixRQUFBLEdBQUcsRUFBSCxHQUFsQjtBQUF1QixRQUFBLElBQUksRUFBRTtBQUE3QixPQUF2QixDQUFUO0FBQUEsS0FGRixDQUFQO0FBR0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoRkE7O0FBQUEsU0FpRkUsT0FqRkYsR0FpRkUsaUJBQVMsUUFBVCxFQUFtQixJQUFuQixFQUF5QjtBQUFBOztBQUN2QixRQUFJLENBQUMsSUFBSSxDQUFDLFNBQVYsRUFBcUI7QUFDbkIsYUFBTyxPQUFPLENBQUMsTUFBUixDQUFlLElBQUksS0FBSixDQUFVLG9DQUFWLENBQWYsQ0FBUDtBQUNEOztBQUNELFFBQU0sSUFBSSxHQUFHLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFOLENBQS9CO0FBQ0EsUUFBTSxTQUFTLEdBQUcsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFNBQU4sQ0FBcEM7QUFDQSxRQUFNLFFBQVEsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBTixDQUFuQztBQUNBLFFBQU0sU0FBUyxHQUFHLE1BQWxCO0FBRUEsUUFBTSxFQUFFLGFBQVcsSUFBWCxrQkFBNEIsUUFBNUIsbUJBQWtELFNBQWxELGVBQXFFLFNBQTdFO0FBQ0EsUUFBTSxHQUFHLEdBQU0sUUFBUSxDQUFDLGdCQUFmLGtCQUE0QyxFQUFyRDtBQUNBLFdBQU8scUJBQXFCLENBQUMsR0FBRCxFQUFNO0FBQUUsTUFBQSxNQUFNLEVBQUUsTUFBVjtBQUFrQixNQUFBLE9BQU8sRUFBRSxLQUFLO0FBQWhDLEtBQU4sQ0FBckIsQ0FDSixJQURJLENBQ0MsVUFBQyxRQUFEO0FBQUEsYUFBYyxRQUFRLENBQUMsSUFBVCxFQUFkO0FBQUEsS0FERCxFQUVKLEtBRkksQ0FFRSxVQUFDLEdBQUQ7QUFBQSxhQUFTLE1BQUksQ0FBQyxZQUFMLENBQWtCLEdBQWxCLEVBQXVCO0FBQUUsUUFBQSxRQUFRLEVBQVIsUUFBRjtBQUFZLFFBQUEsSUFBSSxFQUFKLElBQVo7QUFBa0IsUUFBQSxHQUFHLEVBQUgsR0FBbEI7QUFBdUIsUUFBQSxJQUFJLEVBQUU7QUFBN0IsT0FBdkIsQ0FBVDtBQUFBLEtBRkYsQ0FBUDtBQUdEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQXJHQTs7QUFBQSxTQXNHRSxjQXRHRixHQXNHRSx3QkFBZ0IsUUFBaEIsRUFBMEI7QUFBQTs7QUFDeEIsUUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLGdCQUFyQjtBQUNBLFdBQU8scUJBQXFCLENBQUMsR0FBRCxFQUFNO0FBQUUsTUFBQSxNQUFNLEVBQUUsUUFBVjtBQUFvQixNQUFBLE9BQU8sRUFBRSxLQUFLO0FBQWxDLEtBQU4sQ0FBckIsQ0FDSixJQURJLENBQ0MsVUFBQyxRQUFEO0FBQUEsYUFBYyxRQUFRLENBQUMsSUFBVCxFQUFkO0FBQUEsS0FERCxFQUVKLEtBRkksQ0FFRSxVQUFDLEdBQUQ7QUFBQSxhQUFTLE1BQUksQ0FBQyxZQUFMLENBQWtCLEdBQWxCLEVBQXVCO0FBQUUsUUFBQSxHQUFHLEVBQUgsR0FBRjtBQUFPLFFBQUEsSUFBSSxFQUFFO0FBQWIsT0FBdkIsQ0FBVDtBQUFBLEtBRkYsQ0FBUDtBQUdEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQWpIQTs7QUFBQSxTQWtIRSxpQkFsSEYsR0FrSEUsMkJBQW1CLEdBQW5CLEVBQXdCO0FBQUE7O0FBQ3RCLFdBQU8scUJBQXFCLENBQUMsR0FBRCxFQUFNO0FBQUUsTUFBQSxPQUFPLEVBQUUsS0FBSztBQUFoQixLQUFOLENBQXJCLENBQ0osSUFESSxDQUNDLFVBQUMsUUFBRDtBQUFBLGFBQWMsUUFBUSxDQUFDLElBQVQsRUFBZDtBQUFBLEtBREQsRUFFSixLQUZJLENBRUUsVUFBQyxHQUFEO0FBQUEsYUFBUyxNQUFJLENBQUMsWUFBTCxDQUFrQixHQUFsQixFQUF1QjtBQUFFLFFBQUEsR0FBRyxFQUFILEdBQUY7QUFBTyxRQUFBLElBQUksRUFBRTtBQUFiLE9BQXZCLENBQVQ7QUFBQSxLQUZGLENBQVA7QUFHRCxHQXRISDs7QUFBQSxTQXdIRSxXQXhIRixHQXdIRSxxQkFBYSxHQUFiLFNBQW9EO0FBQUEsUUFBaEMsUUFBZ0MsU0FBaEMsUUFBZ0M7QUFBQSxRQUF0QixRQUFzQixTQUF0QixRQUFzQjtBQUFBLFFBQVosUUFBWSxTQUFaLFFBQVk7QUFDbEQsUUFBTSxPQUFPLEdBQUcsR0FBRyxDQUFDLE9BQUosR0FDVCxHQUFHLENBQUMsT0FESyxVQUNPLEdBQUcsQ0FBQyxPQURYLFNBRVosR0FBRyxDQUFDLE9BRlI7QUFJQSxXQUFPLHFCQUFxQixDQUFDLDRDQUFELEVBQStDO0FBQ3pFLE1BQUEsTUFBTSxFQUFFLE1BRGlFO0FBRXpFLE1BQUEsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFMLENBQWU7QUFDbkIsUUFBQSxRQUFRLEVBQVIsUUFEbUI7QUFFbkIsUUFBQSxRQUFRLEVBQVIsUUFGbUI7QUFHbkIsUUFBQSxXQUFXLEVBQUUsUUFITTtBQUluQixRQUFBLEtBQUssRUFBRSxPQUFPLFNBQVAsS0FBcUIsV0FBckIsR0FBbUMsU0FBUyxDQUFDLFNBQTdDLEdBQXlELEVBSjdDO0FBS25CLFFBQUEsTUFBTSxFQUFFLEtBQUssSUFBTCxDQUFVLE1BTEM7QUFNbkIsUUFBQSxLQUFLLEVBQUU7QUFOWSxPQUFmO0FBRm1FLEtBQS9DLENBQXJCLENBV0osSUFYSSxDQVdDLFVBQUMsUUFBRDtBQUFBLGFBQWMsUUFBUSxDQUFDLElBQVQsRUFBZDtBQUFBLEtBWEQsQ0FBUDtBQVlELEdBeklIOztBQUFBLFNBMklFLFlBM0lGLEdBMklFLHNCQUFjLEdBQWQsRUFBbUIsTUFBbkIsRUFBMkI7QUFDekIsUUFBSSxLQUFLLElBQUwsQ0FBVSxjQUFWLEtBQTZCLEtBQWpDLEVBQXdDO0FBQ3RDLFlBQU0sR0FBTjtBQUNEOztBQUVELFFBQU0sSUFBSSxHQUFHO0FBQ1gsTUFBQSxJQUFJLEVBQUUsTUFBTSxDQUFDO0FBREYsS0FBYjs7QUFHQSxRQUFJLE1BQU0sQ0FBQyxRQUFYLEVBQXFCO0FBQ25CLE1BQUEsSUFBSSxDQUFDLFFBQUwsR0FBZ0IsTUFBTSxDQUFDLFFBQVAsQ0FBZ0IsV0FBaEM7QUFDQSxNQUFBLElBQUksQ0FBQyxRQUFMLEdBQWdCLE1BQU0sQ0FBQyxRQUFQLENBQWdCLFFBQWhDO0FBQ0Q7O0FBQ0QsUUFBSSxNQUFNLENBQUMsR0FBWCxFQUFnQjtBQUNkLE1BQUEsSUFBSSxDQUFDLFFBQUwsR0FBZ0IsTUFBTSxDQUFDLEdBQXZCO0FBQ0Q7O0FBRUQsU0FBSyxXQUFMLENBQWlCLEdBQWpCLEVBQXNCLElBQXRCLEVBQTRCLEtBQTVCLENBQWtDLFVBQUMsQ0FBRCxFQUFPLENBQ3ZDO0FBQ0QsS0FGRDtBQUlBLFVBQU0sR0FBTjtBQUNELEdBaEtIOztBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUNOQSxJQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsNEJBQUQsQ0FBMUI7O0FBQ0EsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLDZCQUFELENBQTNCOztBQUNBLGVBQW1CLE9BQU8sQ0FBQyxZQUFELENBQTFCO0FBQUEsSUFBUSxNQUFSLFlBQVEsTUFBUjs7QUFDQSxJQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsV0FBRCxDQUFuQjs7QUFDQSxJQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsWUFBRCxDQUF4Qjs7QUFDQSxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBRCxDQUF0Qjs7QUFDQSxJQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsbUJBQUQsQ0FBL0I7O0FBQ0EsSUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLG1CQUFELENBQS9COztBQUVBLFNBQVMseUJBQVQsQ0FBb0MsSUFBcEMsRUFBMEMsT0FBMUMsRUFBbUQ7QUFDakQsU0FBTztBQUNMLElBQUEsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQURYO0FBRUwsSUFBQSxTQUFTLEVBQUUsT0FBTyxDQUFDLFNBRmQ7QUFHTCxJQUFBLE1BQU0sRUFBRSxPQUFPLENBQUM7QUFIWCxHQUFQO0FBS0Q7O0FBRUQsSUFBTSxTQUFTLEdBQUcsd0NBQWxCLEMsQ0FDQTs7QUFDQSxJQUFNLHlCQUF5QixHQUFHLHFCQUFsQyxDLENBQ0E7O0FBQ0EsSUFBTSxZQUFZLEdBQUcsdURBQXJCO0FBQ0EsSUFBTSxjQUFjLEdBQUcseURBQXZCO0FBRUE7QUFDQTtBQUNBOztBQUNBLE1BQU0sQ0FBQyxPQUFQO0FBQUE7O0FBR0UsdUJBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QjtBQUFBOztBQUN2QiwrQkFBTSxJQUFOLEVBQVksSUFBWjtBQUNBLFVBQUssSUFBTCxHQUFZLFVBQVo7QUFDQSxVQUFLLEVBQUwsR0FBVSxNQUFLLElBQUwsQ0FBVSxFQUFWLElBQWdCLGFBQTFCO0FBQ0EsVUFBSyxLQUFMLEdBQWEsYUFBYjtBQUVBLFVBQUssYUFBTCxHQUFxQjtBQUNuQixNQUFBLE9BQU8sRUFBRTtBQUNQLFFBQUEsZ0JBQWdCLEVBQUUscUJBRFg7QUFFUCxRQUFBLHNCQUFzQixFQUFFLHdDQUZqQjtBQUdQLFFBQUEsUUFBUSxFQUFFO0FBSEg7QUFEVSxLQUFyQjtBQVFBLFFBQU0sY0FBYyxHQUFHO0FBQ3JCLE1BQUEsT0FBTyxFQUFFLDhCQURZO0FBRXJCLE1BQUEsY0FBYyxFQUFFLElBRks7QUFHckIsTUFBQSxlQUFlLEVBQUUsS0FISTtBQUlyQixNQUFBLGVBQWUsRUFBRSxLQUpJO0FBS3JCLE1BQUEsaUJBQWlCLEVBQUUsS0FMRTtBQU1yQixNQUFBLG9CQUFvQixFQUFFLEtBTkQ7QUFPckIsTUFBQSxTQUFTLEVBQUUsSUFQVTtBQVFyQixNQUFBLE1BQU0sRUFBRSxJQVJhO0FBU3JCLE1BQUEsTUFBTSxFQUFFLEVBVGE7QUFVckIsTUFBQSxrQkFBa0IsRUFBRSx5QkFWQztBQVdyQixNQUFBLEtBQUssRUFBRTtBQVhjLEtBQXZCO0FBY0EsVUFBSyxJQUFMLGdCQUFpQixjQUFqQixFQUFvQyxJQUFwQzs7QUFFQSxVQUFLLFFBQUw7O0FBRUEsVUFBSyxjQUFMLEdBQXNCLE1BQUssY0FBTCxDQUFvQixJQUFwQiwrQkFBdEI7QUFDQSxVQUFLLFlBQUwsR0FBb0IsTUFBSyxZQUFMLENBQWtCLElBQWxCLCtCQUFwQjtBQUNBLFVBQUssUUFBTCxHQUFnQixNQUFLLFFBQUwsQ0FBYyxJQUFkLCtCQUFoQjtBQUNBLFVBQUssV0FBTCxHQUFtQixNQUFLLFdBQUwsQ0FBaUIsSUFBakIsK0JBQW5CO0FBQ0EsVUFBSyxZQUFMLEdBQW9CLE1BQUssWUFBTCxDQUFrQixJQUFsQiwrQkFBcEI7QUFDQSxVQUFLLHlCQUFMLEdBQWlDLE1BQUsseUJBQUwsQ0FBK0IsSUFBL0IsK0JBQWpDO0FBQ0EsVUFBSyxXQUFMLEdBQW1CLE1BQUssV0FBTCxDQUFpQixJQUFqQiwrQkFBbkI7QUFDQSxVQUFLLGtCQUFMLEdBQTBCLE1BQUssa0JBQUwsQ0FBd0IsSUFBeEIsK0JBQTFCO0FBRUEsUUFBTSx3QkFBd0IsR0FBRyxNQUFLLElBQUwsQ0FBVSxrQkFBVixLQUFpQyxjQUFjLENBQUMsa0JBQWpGOztBQUNBLFFBQUksTUFBSyxJQUFMLENBQVUsTUFBZCxFQUFzQjtBQUNwQixNQUFBLGVBQWUsQ0FBQyxjQUFoQixDQUErQixNQUFLLElBQUwsQ0FBVSxNQUF6QztBQUNELEtBRkQsTUFFTyxJQUFJLENBQUMsd0JBQUwsRUFBK0I7QUFDcEM7QUFDQTtBQUNBLE1BQUEsZUFBZSxDQUFDLGNBQWhCLENBQStCLElBQS9CO0FBQ0Q7O0FBRUQsVUFBSyxNQUFMLEdBQWMsSUFBSSxNQUFKLENBQVc7QUFDdkIsTUFBQSxPQUFPLEVBQUUsTUFBSyxJQUFMLENBQVUsT0FESTtBQUV2QixNQUFBLE1BQU0sRUFBRSxNQUFLLGlCQUFMLEVBRmU7QUFHdkIsTUFBQSxjQUFjLEVBQUUsTUFBSyxJQUFMLENBQVU7QUFISCxLQUFYLENBQWQsQ0FsRHVCLENBdUR2Qjs7QUFDQSxVQUFLLGdCQUFMLEdBQXdCLEVBQXhCLENBeER1QixDQXlEdkI7O0FBQ0EsVUFBSyxnQkFBTCxHQUF3QixFQUF4QixDQTFEdUIsQ0EyRHZCOztBQUNBLFVBQUssY0FBTCxHQUFzQixNQUFNLENBQUMsTUFBUCxDQUFjLElBQWQsQ0FBdEI7QUE1RHVCO0FBNkR4Qjs7QUFoRUg7O0FBQUEsU0FrRUUsVUFsRUYsR0FrRUUsb0JBQVksT0FBWixFQUFxQjtBQUNuQixzQkFBTSxVQUFOLFlBQWlCLE9BQWpCOztBQUNBLFNBQUssUUFBTDtBQUNELEdBckVIOztBQUFBLFNBdUVFLFFBdkVGLEdBdUVFLG9CQUFZO0FBQ1YsU0FBSyxVQUFMLEdBQWtCLElBQUksVUFBSixDQUFlLENBQUMsS0FBSyxhQUFOLEVBQXFCLEtBQUssSUFBTCxDQUFVLE1BQS9CLEVBQXVDLEtBQUssSUFBTCxDQUFVLE1BQWpELENBQWYsQ0FBbEI7QUFDQSxTQUFLLElBQUwsR0FBWSxLQUFLLFVBQUwsQ0FBZ0IsU0FBaEIsQ0FBMEIsSUFBMUIsQ0FBK0IsS0FBSyxVQUFwQyxDQUFaO0FBQ0EsU0FBSyxTQUFMLEdBQWlCLEtBQUssVUFBTCxDQUFnQixjQUFoQixDQUErQixJQUEvQixDQUFvQyxLQUFLLFVBQXpDLENBQWpCO0FBQ0EsU0FBSyxjQUFMLEdBSlUsQ0FJWTtBQUN2QixHQTVFSDs7QUFBQSxTQThFRSxpQkE5RUYsR0E4RUUsNkJBQXFCO0FBQUE7O0FBQ25CLFFBQU0sSUFBSSxHQUFHLGdCQUNFLEtBQUssSUFBTCxDQUFVLFdBQVYsQ0FBc0IsT0FEeEIsd0JBRVMsS0FBSyxXQUFMLENBQWlCLE9BRjFCLGdCQUdDLEdBQUcsQ0FBQyxPQUhMLENBQWI7O0FBTUEsUUFBTSxnQkFBZ0IsR0FBRyxTQUFuQixnQkFBbUIsQ0FBQyxVQUFELEVBQWEsV0FBYixFQUE2QjtBQUNwRCxVQUFNLE1BQU0sR0FBRyxNQUFJLENBQUMsSUFBTCxDQUFVLFNBQVYsQ0FBb0IsVUFBcEIsQ0FBZjs7QUFDQSxVQUFJLE1BQUosRUFBWTtBQUNWLFFBQUEsSUFBSSxDQUFDLElBQUwsQ0FBYSxXQUFiLFNBQTRCLE1BQU0sQ0FBQyxXQUFQLENBQW1CLE9BQS9DO0FBQ0Q7QUFDRixLQUxEOztBQU9BLFFBQUksS0FBSyxJQUFMLENBQVUsb0JBQWQsRUFBb0M7QUFDbEMsTUFBQSxnQkFBZ0IsQ0FBQyxXQUFELEVBQWMsaUJBQWQsQ0FBaEI7QUFDQSxNQUFBLGdCQUFnQixDQUFDLE9BQUQsRUFBVSxhQUFWLENBQWhCO0FBQ0EsTUFBQSxnQkFBZ0IsQ0FBQyxnQkFBRCxFQUFtQix1QkFBbkIsQ0FBaEI7QUFDRDs7QUFFRCxJQUFBLGdCQUFnQixDQUFDLFNBQUQsRUFBWSxjQUFaLENBQWhCO0FBQ0EsSUFBQSxnQkFBZ0IsQ0FBQyxLQUFELEVBQVEsVUFBUixDQUFoQjtBQUNBLElBQUEsZ0JBQWdCLENBQUMsVUFBRCxFQUFhLGVBQWIsQ0FBaEI7QUFDQSxJQUFBLGdCQUFnQixDQUFDLGFBQUQsRUFBZ0IsbUJBQWhCLENBQWhCO0FBQ0EsSUFBQSxnQkFBZ0IsQ0FBQyxXQUFELEVBQWMsZ0JBQWQsQ0FBaEI7QUFDQSxJQUFBLGdCQUFnQixDQUFDLFVBQUQsRUFBYSxlQUFiLENBQWhCO0FBQ0EsSUFBQSxnQkFBZ0IsQ0FBQyxNQUFELEVBQVMsV0FBVCxDQUFoQjtBQUNBLElBQUEsZ0JBQWdCLENBQUMsS0FBRCxFQUFRLFVBQVIsQ0FBaEI7QUFFQSxXQUFPLElBQUksQ0FBQyxJQUFMLENBQVUsR0FBVixDQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0SEE7O0FBQUEsU0F1SEUsdUJBdkhGLEdBdUhFLGlDQUF5QixJQUF6QixFQUErQixNQUEvQixFQUF1QztBQUNyQztBQUNBLFFBQU0sSUFBSSxnQkFDTCxJQUFJLENBQUMsSUFEQTtBQUVSLE1BQUEsWUFBWSxFQUFFLE1BQU0sQ0FBQyxZQUZiO0FBR1IsTUFBQSxRQUFRLEVBQUUsSUFBSSxDQUFDLElBSFA7QUFJUixNQUFBLFNBQVMsRUFBRTtBQUpILE1BQVYsQ0FGcUMsQ0FRckM7OztBQUNBLFFBQU0sR0FBRyxnQkFDSixJQUFJLENBQUMsR0FERDtBQUVQLE1BQUEsUUFBUSxFQUFFLE1BQU0sQ0FBQyxPQUZWO0FBR1A7QUFDQSxNQUFBLFlBQVksRUFBRTtBQUpQLE1BQVQsQ0FUcUMsQ0FnQnJDO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxRQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBbEI7O0FBQ0EsUUFBSSxJQUFJLENBQUMsTUFBTCxJQUFlLGNBQWMsQ0FBQyxJQUFmLENBQW9CLElBQUksQ0FBQyxNQUFMLENBQVksWUFBaEMsQ0FBbkIsRUFBa0U7QUFDaEUsVUFBTSxHQUFHLEdBQUcsSUFBSSxLQUFKLENBQ1YsMEVBQ0UsNEVBREYsR0FFRSxzQkFIUSxDQUFaLENBRGdFLENBTWhFO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFdBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxHQUFkO0FBQ0EsWUFBTSxHQUFOO0FBQ0Q7O0FBRUQsUUFBSSxJQUFJLENBQUMsTUFBTCxJQUFlLFlBQVksQ0FBQyxJQUFiLENBQWtCLElBQUksQ0FBQyxNQUFMLENBQVksWUFBOUIsQ0FBbkIsRUFBZ0U7QUFDOUQsVUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLGFBQVAsQ0FDYixPQURhLENBQ0wsS0FESyxFQUNFLEVBREYsQ0FBaEI7QUFFQSxVQUFNLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTCxDQUFZLEdBQVosQ0FDVixPQURVLENBQ0YsSUFBSSxDQUFDLE1BQUwsQ0FBWSxZQURWLEVBQ3dCLEVBRHhCLEVBRVYsT0FGVSxDQUVGLEtBRkUsRUFFSyxFQUZMLENBQWI7QUFJQSxNQUFBLE1BQU0sZ0JBQ0QsSUFBSSxDQUFDLE1BREo7QUFFSixRQUFBLFlBQVksRUFBRSxPQUZWO0FBR0osUUFBQSxHQUFHLEVBQUssT0FBTCxTQUFnQjtBQUhmLFFBQU47QUFLRCxLQS9Db0MsQ0FpRHJDOzs7QUFDQSxRQUFNLE9BQU8sZ0JBQ1IsSUFEUTtBQUVYLE1BQUEsV0FBVyxFQUFFO0FBQ1gsUUFBQSxRQUFRLEVBQUUsTUFBTSxDQUFDO0FBRE47QUFGRixNQUFiLENBbERxQyxDQXdEckM7OztBQUNBLFFBQUksQ0FBQyxLQUFLLElBQUwsQ0FBVSxvQkFBZixFQUFxQztBQUNuQyxlQUFjLE9BQWQsRUFBdUI7QUFBRSxRQUFBLElBQUksRUFBSixJQUFGO0FBQVEsUUFBQSxHQUFHLEVBQUgsR0FBUjtBQUFhLFFBQUEsTUFBTSxFQUFOO0FBQWIsT0FBdkI7QUFDRDs7QUFDRCxXQUFPLE9BQVA7QUFDRCxHQXBMSDs7QUFBQSxTQXNMRSxlQXRMRixHQXNMRSx5QkFBaUIsT0FBakIsRUFBMEIsUUFBMUIsRUFBb0MsT0FBcEMsRUFBNkM7QUFBQTs7QUFDM0MsU0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLCtCQUFkO0FBRUEsV0FBTyxLQUFLLE1BQUwsQ0FBWSxjQUFaLENBQTJCO0FBQ2hDLE1BQUEsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQURnQjtBQUVoQyxNQUFBLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFGZ0I7QUFHaEMsTUFBQSxhQUFhLEVBQUUsT0FBTyxDQUFDLE1BSFM7QUFJaEMsTUFBQSxTQUFTLEVBQUUsT0FBTyxDQUFDO0FBSmEsS0FBM0IsRUFLSixJQUxJLENBS0MsVUFBQyxXQUFELEVBQWlCO0FBQUE7O0FBQ3ZCLFVBQU0sUUFBUSxHQUFHLElBQUksUUFBSixDQUFhLFdBQWIsQ0FBakI7QUFDQSxVQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsTUFBeEI7QUFDQSxVQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsV0FBMUI7O0FBRUEsa0NBQTBDLE1BQUksQ0FBQyxjQUFMLEVBQTFDO0FBQUEsVUFBUSxVQUFSLHlCQUFRLFVBQVI7QUFBQSxVQUFvQixpQkFBcEIseUJBQW9CLGlCQUFwQjs7QUFDQSxNQUFBLE1BQUksQ0FBQyxjQUFMLENBQW9CO0FBQ2xCO0FBQ0EsUUFBQSxVQUFVLGVBQ0wsVUFESyw2QkFFUCxVQUZPLElBRU0sTUFGTixhQUZRO0FBTWxCO0FBQ0EsUUFBQSxpQkFBaUIsZUFDWixpQkFEWSw2QkFFZCxRQUZjLGNBR1YsaUJBQWlCLENBQUMsUUFBRCxDQUhQLEdBSWIsVUFKYTtBQVBDLE9BQXBCOztBQWdCQSxpQ0FBa0IsTUFBSSxDQUFDLElBQUwsQ0FBVSxRQUFWLEVBQWxCO0FBQUEsVUFBUSxLQUFSLHdCQUFRLEtBQVI7O0FBQ0EsVUFBTSxZQUFZLEdBQUcsRUFBckI7QUFDQSxNQUFBLE9BQU8sQ0FBQyxPQUFSLENBQWdCLFVBQUMsRUFBRCxFQUFRO0FBQ3RCLFFBQUEsWUFBWSxDQUFDLEVBQUQsQ0FBWixHQUFtQixNQUFJLENBQUMsdUJBQUwsQ0FBNkIsTUFBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLENBQWtCLEVBQWxCLENBQTdCLEVBQW9ELE1BQXBELENBQW5CO0FBQ0QsT0FGRDs7QUFHQSxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsUUFBVixDQUFtQjtBQUNqQixRQUFBLEtBQUssZUFDQSxLQURBLEVBRUEsWUFGQTtBQURZLE9BQW5COztBQU9BLE1BQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsOEJBQWYsRUFBK0MsTUFBL0MsRUFBdUQsT0FBdkQ7O0FBRUEsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYscUNBQWdELFVBQWhEOztBQUNBLGFBQU8sUUFBUDtBQUNELEtBM0NNLEVBMkNKLEtBM0NJLENBMkNFLFVBQUMsR0FBRCxFQUFTO0FBQ2hCLE1BQUEsR0FBRyxDQUFDLE9BQUosR0FBaUIsTUFBSSxDQUFDLElBQUwsQ0FBVSx3QkFBVixDQUFqQixVQUF5RCxHQUFHLENBQUMsT0FBN0QsQ0FEZ0IsQ0FFaEI7O0FBQ0EsWUFBTSxHQUFOO0FBQ0QsS0EvQ00sQ0FBUDtBQWdERCxHQXpPSDs7QUFBQSxTQTJPRSxzQkEzT0YsR0EyT0UsZ0NBQXdCLFVBQXhCLEVBQW9DLE9BQXBDLEVBQTZDLFFBQTdDLEVBQXVEO0FBQUE7O0FBQ3ZEO0FBQ0UsUUFBTSxPQUFPLEdBQUcsSUFBSSxlQUFKLENBQW9CLEtBQUssSUFBekIsRUFBK0IsVUFBL0IsQ0FBaEI7QUFFQSxJQUFBLE9BQU8sQ0FBQyxFQUFSLENBQVcsbUJBQVgsRUFBZ0MsVUFBQyxFQUFELEVBQVE7QUFDdEMsVUFBTSxLQUFLLEdBQUcsTUFBSSxDQUFDLGdCQUFMLENBQXNCLEVBQXRCLENBQWQ7O0FBQ0EsTUFBQSxLQUFLLENBQUMsT0FBTixDQUFjLFVBQUMsSUFBRCxFQUFVO0FBQ3RCLFFBQUEsTUFBSSxDQUFDLGNBQUwsQ0FBb0IsSUFBSSxDQUFDLEVBQXpCLElBQStCLElBQS9COztBQUNBLFFBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsc0JBQWYsRUFBdUMsSUFBdkM7QUFDRCxPQUhEO0FBSUQsS0FORDtBQVFBLElBQUEsT0FBTyxDQUFDLEVBQVIsQ0FBVyxnQkFBWCxFQUE2QixVQUFDLEVBQUQsRUFBSyxLQUFMLEVBQWU7QUFDNUM7QUFDRSxVQUFNLEtBQUssR0FBRyxNQUFJLENBQUMsZ0JBQUwsQ0FBc0IsRUFBdEIsQ0FBZDs7QUFDQSxNQUFBLEtBQUssQ0FBQyxPQUFOLENBQWMsVUFBQyxJQUFELEVBQVU7QUFDeEI7QUFDRSxRQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLGNBQWYsRUFBK0IsSUFBL0IsRUFBcUMsS0FBckM7O0FBRUEsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxzQkFBZixFQUF1QyxJQUF2QztBQUNELE9BTEQ7QUFNRCxLQVREO0FBV0EsU0FBSyxnQkFBTCxDQUFzQixRQUF0QixJQUFrQyxPQUFsQztBQUNELEdBblFIOztBQUFBLFNBcVFFLHNCQXJRRixHQXFRRSxrQ0FBMEI7QUFDeEIsV0FBTyxLQUFLLElBQUwsQ0FBVSxlQUFWLElBQTZCLEtBQUssSUFBTCxDQUFVLGVBQTlDO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQTVRQTs7QUFBQSxTQTZRRSxhQTdRRixHQTZRRSx1QkFBZSxRQUFmLEVBQXlCLE9BQXpCLEVBQWtDO0FBQUE7O0FBQ2hDLFdBQU8sT0FBTyxDQUFDLEdBQVIsQ0FBWSxPQUFPLENBQUMsR0FBUixDQUFZLFVBQUMsTUFBRCxFQUFZO0FBQ3pDLFVBQU0sSUFBSSxHQUFHLE1BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFrQixNQUFsQixDQUFiOztBQUNBLGFBQU8sTUFBSSxDQUFDLE1BQUwsQ0FBWSxXQUFaLENBQXdCLFFBQVEsQ0FBQyxNQUFqQyxFQUF5QyxJQUF6QyxDQUFQO0FBQ0QsS0FIa0IsQ0FBWixDQUFQO0FBSUQ7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQXZSQTs7QUFBQSxTQXdSRSx5QkF4UkYsR0F3UkUsbUNBQTJCLE9BQTNCLEVBQW9DO0FBQUE7O0FBQ2xDLFFBQU0sSUFBSSxHQUFHLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBa0IsT0FBTyxDQUFDLEVBQTFCLENBQWI7O0FBQ0EsUUFBSSxDQUFDLElBQUQsSUFBUyxDQUFDLElBQUksQ0FBQyxXQUFmLElBQThCLENBQUMsSUFBSSxDQUFDLFdBQUwsQ0FBaUIsUUFBcEQsRUFBOEQ7QUFDNUQ7QUFDRDs7QUFFRCwrQkFBdUIsS0FBSyxjQUFMLEVBQXZCO0FBQUEsUUFBUSxVQUFSLHdCQUFRLFVBQVI7O0FBQ0EsUUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxXQUFMLENBQWlCLFFBQWxCLENBQTNCO0FBRUEsU0FBSyxNQUFMLENBQVksT0FBWixDQUFvQixRQUFwQixFQUE4QixJQUE5QixFQUFvQyxLQUFwQyxDQUEwQyxVQUFDLEdBQUQsRUFBUztBQUNqRCxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsR0FBVixDQUFjLEdBQWQ7O0FBQ0EsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSwwQkFBZixFQUEyQyxRQUEzQyxFQUFxRCxJQUFJLENBQUMsRUFBMUQsRUFBOEQsR0FBOUQ7QUFDRCxLQUhEO0FBSUQsR0FyU0g7O0FBQUEsU0F1U0UsU0F2U0YsR0F1U0UsbUJBQVcsWUFBWCxFQUF5QjtBQUN2QixRQUFNLEtBQUssR0FBRyxLQUFLLElBQUwsQ0FBVSxRQUFWLEVBQWQ7O0FBQ0EsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFiLEVBQWdCLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBMUIsRUFBa0MsQ0FBQyxFQUFuQyxFQUF1QztBQUNyQyxVQUFNLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBRCxDQUFsQixDQURxQyxDQUVyQzs7QUFDQSxVQUFJLElBQUksQ0FBQyxTQUFMLEtBQW1CLFlBQVksQ0FBQyxjQUFwQyxFQUFvRDtBQUNsRCxlQUFPLElBQVA7QUFDRCxPQUxvQyxDQU1yQzs7O0FBQ0EsVUFBSSxJQUFJLENBQUMsR0FBTCxJQUFZLElBQUksQ0FBQyxHQUFMLENBQVMsU0FBVCxLQUF1QixZQUFZLENBQUMsY0FBcEQsRUFBb0U7QUFDbEUsZUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsVUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFsQixFQUErQjtBQUM3QjtBQUNBLFlBQUksSUFBSSxDQUFDLElBQUwsS0FBYyxZQUFZLENBQUMsSUFBM0IsSUFBbUMsSUFBSSxDQUFDLElBQUwsS0FBYyxZQUFZLENBQUMsSUFBbEUsRUFBd0U7QUFDdEUsaUJBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEdBMVRIOztBQUFBLFNBNFRFLHFCQTVURixHQTRURSwrQkFBdUIsVUFBdkIsRUFBbUMsWUFBbkMsRUFBaUQ7QUFBQTs7QUFDL0MsUUFBTSxLQUFLLEdBQUcsS0FBSyxjQUFMLEVBQWQ7O0FBQ0EsUUFBTSxJQUFJLEdBQUcsS0FBSyxTQUFMLENBQWUsWUFBZixDQUFiOztBQUNBLFFBQUksQ0FBQyxJQUFMLEVBQVc7QUFDVCxXQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsNEVBQWQ7QUFDQTtBQUNEOztBQUNELFNBQUssY0FBTCxDQUFvQjtBQUNsQixNQUFBLEtBQUssZUFDQSxLQUFLLENBQUMsS0FETiw2QkFFRixZQUFZLENBQUMsRUFGWCxJQUVnQjtBQUNqQixRQUFBLFFBQVEsRUFBRSxVQURPO0FBRWpCLFFBQUEsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUZRO0FBR2pCLFFBQUEsWUFBWSxFQUFaO0FBSGlCLE9BRmhCO0FBRGEsS0FBcEI7QUFVQSxTQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsb0JBQWYsRUFBcUMsWUFBckMsRUFBbUQsS0FBSyxXQUFMLENBQWlCLFVBQWpCLENBQW5EO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRWQTs7QUFBQSxTQXVWRSxTQXZWRixHQXVWRSxtQkFBVyxVQUFYLEVBQXVCLFFBQXZCLEVBQWlDLE1BQWpDLEVBQXlDO0FBQ3ZDLFFBQU0sS0FBSyxHQUFHLEtBQUssY0FBTCxFQUFkO0FBQ0EsUUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLEtBQU4sQ0FBWSxNQUFNLENBQUMsV0FBbkIsQ0FBYixDQUZ1QyxDQUd2Qzs7QUFDQSxJQUFBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLElBQUksR0FBRyxJQUFJLENBQUMsRUFBUixHQUFhLElBQWxDO0FBRUEsUUFBTSxLQUFLLEdBQUc7QUFDWixNQUFBLE1BQU0sRUFBTixNQURZO0FBRVosTUFBQSxRQUFRLEVBQVIsUUFGWTtBQUdaLE1BQUEsRUFBRSxFQUFFLE1BQU0sQ0FBQyxFQUhDO0FBSVosTUFBQSxRQUFRLEVBQUU7QUFKRSxLQUFkO0FBT0EsU0FBSyxjQUFMLENBQW9CO0FBQ2xCLE1BQUEsT0FBTyxZQUFNLEtBQUssQ0FBQyxPQUFaLEdBQXFCLEtBQXJCO0FBRFcsS0FBcEI7QUFHQSxTQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsb0JBQWYsRUFBcUMsUUFBckMsRUFBK0MsTUFBL0MsRUFBdUQsS0FBSyxXQUFMLENBQWlCLFVBQWpCLENBQXZEO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEvV0E7O0FBQUEsU0FnWEUsbUJBaFhGLEdBZ1hFLDZCQUFxQixNQUFyQixFQUE2QjtBQUFBOztBQUMzQixRQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsZ0JBQW5CO0FBQ0EsU0FBSyxNQUFMLENBQVksaUJBQVosQ0FBOEIsR0FBOUIsRUFBbUMsSUFBbkMsQ0FBd0MsVUFBQyxXQUFELEVBQWlCO0FBQUE7O0FBQ3ZELFVBQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyxXQUEvQjs7QUFDQSxVQUFNLEtBQUssR0FBRyxNQUFJLENBQUMsY0FBTCxFQUFkOztBQUNBLE1BQUEsTUFBSSxDQUFDLGNBQUwsQ0FBb0I7QUFDbEIsUUFBQSxVQUFVLGVBQ0wsS0FBSyxDQUFDLFVBREQsNkJBRVAsVUFGTyxJQUVNLFdBRk47QUFEUSxPQUFwQjs7QUFNQSxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLHNCQUFmLEVBQXVDLFdBQXZDO0FBQ0QsS0FWRDtBQVdELEdBN1hIOztBQUFBLFNBK1hFLGVBL1hGLEdBK1hFLHlCQUFpQixRQUFqQixFQUEyQjtBQUFBOztBQUN6QixXQUFPLEtBQUssTUFBTCxDQUFZLGNBQVosQ0FBMkIsUUFBM0IsRUFBcUMsSUFBckMsQ0FBMEMsWUFBTTtBQUNyRDtBQUNBLE1BQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsZ0NBQWYsRUFBaUQsUUFBakQ7QUFDRCxLQUhNLENBQVA7QUFJRDtBQUVEO0FBQ0Y7QUFDQTtBQXhZQTs7QUFBQSxTQXlZRSxZQXpZRixHQXlZRSx3QkFBZ0I7QUFBQTs7QUFDZCxnQ0FBOEIsS0FBSyxjQUFMLEVBQTlCO0FBQUEsUUFBUSxpQkFBUix5QkFBUSxpQkFBUjs7QUFFQSxRQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBUCxDQUFZLGlCQUFaLEVBQStCLE1BQS9CLENBQXNDLFVBQUMsR0FBRCxFQUFNLFFBQU4sRUFBbUI7QUFDM0UsTUFBQSxHQUFHLENBQUMsSUFBSixPQUFBLEdBQUcsRUFBUyxpQkFBaUIsQ0FBQyxRQUFELENBQTFCLENBQUg7QUFDQSxhQUFPLEdBQVA7QUFDRCxLQUhtQixFQUdqQixFQUhpQixDQUFwQjtBQUtBLFFBQU0sY0FBYyxHQUFHLFdBQVcsQ0FBQyxHQUFaLENBQWdCLFVBQUMsVUFBRCxFQUFnQjtBQUNyRCxVQUFNLFFBQVEsR0FBRyxNQUFJLENBQUMsV0FBTCxDQUFpQixVQUFqQixDQUFqQjs7QUFDQSxhQUFPLE1BQUksQ0FBQyxlQUFMLENBQXFCLFFBQXJCLENBQVA7QUFDRCxLQUhzQixDQUF2QjtBQUtBLElBQUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxjQUFaLEVBQTRCLEtBQTVCLENBQWtDLFVBQUMsR0FBRCxFQUFTO0FBQ3pDLE1BQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxHQUFWLENBQWMsR0FBZDtBQUNELEtBRkQ7QUFHRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhhQTs7QUFBQSxTQWlhRSxrQkFqYUYsR0FpYUUsNEJBQW9CLE9BQXBCLEVBQTZCO0FBQUE7O0FBQzNCLFFBQU0sS0FBSyxHQUFHLEtBQUssY0FBTCxFQUFkO0FBQ0EsUUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLFVBQXpCO0FBQ0EsUUFBTSxpQkFBaUIsR0FBRyxLQUFLLENBQUMsaUJBQWhDO0FBRUEsSUFBQSxPQUFPLDBCQUNKLEtBQUssRUFERCxJQUNNO0FBQ1QsTUFBQSxVQUFVLEVBQVYsVUFEUztBQUVULE1BQUEsaUJBQWlCLEVBQWpCO0FBRlMsS0FETixZQUFQO0FBTUQsR0E1YUg7O0FBQUEsU0E4YUUsV0E5YUYsR0E4YUUscUJBQWEsVUFBYixFQUF5QjtBQUFBOztBQUN2QixRQUFNLFVBQVUsR0FBRyxVQUFVLElBQUksVUFBVSxDQUFDLEtBQUssRUFBTixDQUF4QixHQUFvQyxVQUFVLENBQUMsS0FBSyxFQUFOLENBQTlDLEdBQTBELEVBQTdFO0FBQ0EsUUFBTSxrQkFBa0IsR0FBRyxVQUFVLENBQUMsVUFBWCxJQUF5QixFQUFwRDtBQUNBLFFBQU0saUJBQWlCLEdBQUcsVUFBVSxDQUFDLGlCQUFYLElBQWdDLEVBQTFEOztBQUVBLFFBQUksTUFBTSxDQUFDLElBQVAsQ0FBWSxpQkFBWixFQUErQixNQUEvQixLQUEwQyxDQUE5QyxFQUFpRDtBQUMvQztBQUNBO0FBQ0QsS0FSc0IsQ0FVdkI7OztBQUNBLFFBQU0sWUFBWSxHQUFHLFNBQWYsWUFBZSxDQUFDLFVBQUQsRUFBZ0I7QUFDbkMsVUFBTSxLQUFLLEdBQUcsRUFBZDtBQUNBLFVBQU0sT0FBTyxHQUFHLEVBQWhCO0FBQ0EsTUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLFVBQVosRUFBd0IsT0FBeEIsQ0FBZ0MsVUFBQyxFQUFELEVBQVE7QUFDdEMsWUFBTSxNQUFNLEdBQUcsVUFBVSxDQUFDLEVBQUQsQ0FBekI7QUFFQSxRQUFBLE1BQU0sQ0FBQyxPQUFQLENBQWUsT0FBZixDQUF1QixVQUFDLFlBQUQsRUFBa0I7QUFDdkMsY0FBTSxJQUFJLEdBQUcsT0FBSSxDQUFDLFNBQUwsQ0FBZSxZQUFmLENBQWI7O0FBQ0EsVUFBQSxLQUFLLENBQUMsWUFBWSxDQUFDLEVBQWQsQ0FBTCxHQUF5QjtBQUN2QixZQUFBLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFEYztBQUV2QixZQUFBLFFBQVEsRUFBRSxFQUZhO0FBR3ZCLFlBQUEsWUFBWSxFQUFaO0FBSHVCLFdBQXpCO0FBS0QsU0FQRDs7QUFTQSxZQUFNLEtBQUssR0FBRyxPQUFJLENBQUMsY0FBTCxFQUFkOztBQUNBLFFBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxNQUFNLENBQUMsT0FBbkIsRUFBNEIsT0FBNUIsQ0FBb0MsVUFBQyxRQUFELEVBQWM7QUFDaEQsVUFBQSxNQUFNLENBQUMsT0FBUCxDQUFlLFFBQWYsRUFBeUIsT0FBekIsQ0FBaUMsVUFBQyxNQUFELEVBQVk7QUFDM0MsZ0JBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxLQUFOLENBQVksTUFBTSxDQUFDLFdBQW5CLENBQWI7QUFDQSxZQUFBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLElBQUksR0FBRyxJQUFJLENBQUMsRUFBUixHQUFhLElBQWxDO0FBQ0EsWUFBQSxPQUFPLENBQUMsSUFBUixDQUFhO0FBQ1gsY0FBQSxFQUFFLEVBQUUsTUFBTSxDQUFDLEVBREE7QUFFWCxjQUFBLE1BQU0sRUFBTixNQUZXO0FBR1gsY0FBQSxRQUFRLEVBQVIsUUFIVztBQUlYLGNBQUEsUUFBUSxFQUFFO0FBSkMsYUFBYjtBQU1ELFdBVEQ7QUFVRCxTQVhEO0FBWUQsT0F6QkQ7O0FBMkJBLE1BQUEsT0FBSSxDQUFDLGNBQUwsQ0FBb0I7QUFDbEIsUUFBQSxVQUFVLEVBQVYsVUFEa0I7QUFFbEIsUUFBQSxLQUFLLEVBQUwsS0FGa0I7QUFHbEIsUUFBQSxPQUFPLEVBQVAsT0FIa0I7QUFJbEIsUUFBQSxpQkFBaUIsRUFBakI7QUFKa0IsT0FBcEI7QUFNRCxLQXBDRCxDQVh1QixDQWlEdkI7OztBQUNBLFFBQU0saUJBQWlCLEdBQUcsU0FBcEIsaUJBQW9CLEdBQU07QUFDOUIsa0NBQTBDLE9BQUksQ0FBQyxjQUFMLEVBQTFDO0FBQUEsVUFBUSxVQUFSLHlCQUFRLFVBQVI7QUFBQSxVQUFvQixpQkFBcEIseUJBQW9CLGlCQUFwQixDQUQ4QixDQUc5Qjs7O0FBQ0EsTUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLGlCQUFaLEVBQStCLE9BQS9CLENBQXVDLFVBQUMsUUFBRCxFQUFjO0FBQ25ELFlBQU0sV0FBVyxHQUFHLGlCQUFpQixDQUFDLFFBQUQsQ0FBckM7QUFDQSxZQUFNLGVBQWUsR0FBRyxXQUFXLENBQUMsTUFBWixDQUFtQixVQUFDLEdBQUQsRUFBTSxVQUFOLEVBQXFCO0FBQzlELGNBQU0saUJBQWlCLEdBQUcsT0FBSSxDQUFDLGdCQUFMLENBQXNCLFVBQXRCLEVBQWtDLEdBQWxDLENBQXNDLFVBQUMsSUFBRDtBQUFBLG1CQUFVLElBQUksQ0FBQyxFQUFmO0FBQUEsV0FBdEMsQ0FBMUI7O0FBQ0EsVUFBQSxHQUFHLENBQUMsSUFBSixPQUFBLEdBQUcsRUFBUyxpQkFBVCxDQUFIO0FBQ0EsaUJBQU8sR0FBUDtBQUNELFNBSnVCLEVBSXJCLEVBSnFCLENBQXhCOztBQUtBLFFBQUEsT0FBSSxDQUFDLHNCQUFMLENBQTRCLFdBQTVCLEVBQXlDLGVBQXpDLEVBQTBELFFBQTFEO0FBQ0QsT0FSRDtBQVVBLFVBQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksVUFBWixDQUF2QjtBQUNBLE1BQUEsY0FBYyxDQUFDLE9BQWYsQ0FBdUIsVUFBQyxFQUFELEVBQVE7QUFDN0IsWUFBTSxRQUFRLEdBQUcsSUFBSSxRQUFKLENBQWEsVUFBVSxDQUFDLEVBQUQsQ0FBdkIsQ0FBakI7O0FBQ0EsUUFBQSxPQUFJLENBQUMsZ0JBQUwsQ0FBc0IsUUFBdEI7QUFDRCxPQUhEO0FBSUQsS0FuQkQsQ0FsRHVCLENBdUV2Qjs7O0FBQ0EsUUFBTSxnQkFBZ0IsR0FBRyxTQUFuQixnQkFBbUIsR0FBTTtBQUM3QixtQ0FBdUIsT0FBSSxDQUFDLGNBQUwsRUFBdkI7QUFBQSxVQUFRLFVBQVIsMEJBQVEsVUFBUjs7QUFDQSxhQUFPLE9BQU8sQ0FBQyxHQUFSLENBQ0wsTUFBTSxDQUFDLElBQVAsQ0FBWSxVQUFaLEVBQXdCLEdBQXhCLENBQTRCLFVBQUMsRUFBRCxFQUFRO0FBQ2xDLGVBQU8sT0FBSSxDQUFDLGdCQUFMLENBQXNCLEVBQXRCLEVBQTBCLE1BQTFCLEVBQVA7QUFDRCxPQUZELENBREssQ0FBUDtBQUtELEtBUEQsQ0F4RXVCLENBaUZ2Qjs7O0FBQ0EsU0FBSyxRQUFMLEdBQWdCLE9BQU8sQ0FBQyxPQUFSLEdBQWtCLElBQWxCLENBQXVCLFlBQU07QUFDM0MsTUFBQSxZQUFZLENBQUMsa0JBQUQsQ0FBWjtBQUNBLE1BQUEsaUJBQWlCO0FBQ2pCLGFBQU8sZ0JBQWdCLEVBQXZCO0FBQ0QsS0FKZSxDQUFoQjtBQU1BLFNBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsWUFBTTtBQUN2QixNQUFBLE9BQUksQ0FBQyxRQUFMLEdBQWdCLElBQWhCO0FBQ0QsS0FGRDtBQUdELEdBemdCSDs7QUFBQSxTQTJnQkUsZ0JBM2dCRixHQTJnQkUsMEJBQWtCLFFBQWxCLEVBQTRCO0FBQUE7O0FBQzFCLFFBQVEsTUFBUixHQUFtQixRQUFuQixDQUFRLE1BQVI7QUFDQSxRQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsV0FBbEI7QUFDQSxTQUFLLGdCQUFMLENBQXNCLEVBQXRCLElBQTRCLFFBQTVCLENBSDBCLENBSzFCOztBQUNBLElBQUEsUUFBUSxDQUFDLEVBQVQsQ0FBWSxRQUFaLEVBQXNCLFVBQUMsU0FBRCxFQUFlO0FBQUE7O0FBQ25DLGtDQUF1QixPQUFJLENBQUMsY0FBTCxFQUF2QjtBQUFBLFVBQVEsVUFBUix5QkFBUSxVQUFSOztBQUNBLE1BQUEsT0FBSSxDQUFDLGNBQUwsQ0FBb0I7QUFDbEIsUUFBQSxVQUFVLGVBQ0wsVUFESyw2QkFFUCxFQUZPLElBRUYsU0FGRTtBQURRLE9BQXBCO0FBTUQsS0FSRDtBQVVBLElBQUEsUUFBUSxDQUFDLEVBQVQsQ0FBWSxRQUFaLEVBQXNCLFVBQUMsSUFBRCxFQUFVO0FBQzlCLE1BQUEsT0FBSSxDQUFDLHFCQUFMLENBQTJCLEVBQTNCLEVBQStCLElBQS9CO0FBQ0QsS0FGRDtBQUdBLElBQUEsUUFBUSxDQUFDLEVBQVQsQ0FBWSxPQUFaLEVBQXFCLFVBQUMsS0FBRCxFQUFXO0FBQzlCLE1BQUEsS0FBSyxDQUFDLFFBQU4sR0FBaUIsUUFBUSxDQUFDLE1BQTFCOztBQUNBLE1BQUEsT0FBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsNEJBQWYsRUFBNkMsUUFBUSxDQUFDLE1BQXRELEVBQThELEtBQTlEO0FBQ0QsS0FIRDtBQUtBLElBQUEsUUFBUSxDQUFDLEVBQVQsQ0FBWSxXQUFaLEVBQXlCLFlBQU07QUFDN0IsTUFBQSxPQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxnQ0FBZixFQUFpRCxRQUFRLENBQUMsTUFBMUQ7QUFDRCxLQUZEOztBQUlBLFFBQUksS0FBSyxJQUFMLENBQVUsZUFBZCxFQUErQjtBQUM3QixNQUFBLFFBQVEsQ0FBQyxFQUFULENBQVksUUFBWixFQUFzQixVQUFDLFFBQUQsRUFBVyxNQUFYLEVBQXNCO0FBQzFDLFFBQUEsT0FBSSxDQUFDLFNBQUwsQ0FBZSxFQUFmLEVBQW1CLFFBQW5CLEVBQTZCLE1BQTdCO0FBQ0QsT0FGRDtBQUdEOztBQUVELFFBQUksS0FBSyxJQUFMLENBQVUsZUFBZCxFQUErQjtBQUM3QixNQUFBLFFBQVEsQ0FBQyxFQUFULENBQVksVUFBWixFQUF3QixZQUFNO0FBQzVCLFFBQUEsT0FBSSxDQUFDLG1CQUFMLENBQXlCLFFBQVEsQ0FBQyxNQUFsQztBQUNELE9BRkQ7QUFHRCxLQUpELE1BSU8sSUFBSSxLQUFLLElBQUwsQ0FBVSxlQUFkLEVBQStCO0FBQ3BDLE1BQUEsUUFBUSxDQUFDLEVBQVQsQ0FBWSxVQUFaLEVBQXdCLFlBQU07QUFDNUIsUUFBQSxPQUFJLENBQUMsbUJBQUwsQ0FBeUIsUUFBUSxDQUFDLE1BQWxDO0FBQ0QsT0FGRDtBQUdELEtBMUN5QixDQTRDMUI7OztBQUNBLFFBQUksUUFBUSxDQUFDLEVBQVQsS0FBZ0IsbUJBQXBCLEVBQXlDO0FBQ3ZDLGFBQU8sUUFBUDtBQUNELEtBL0N5QixDQWlEMUI7QUFDQTs7O0FBQ0EsUUFBTSxTQUFTLEdBQUcsSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUNqRCxNQUFBLFFBQVEsQ0FBQyxJQUFULENBQWMsU0FBZCxFQUF5QixPQUF6QjtBQUNBLE1BQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxRQUFkLEVBQXdCLE9BQXhCO0FBQ0EsTUFBQSxRQUFRLENBQUMsSUFBVCxDQUFjLE9BQWQsRUFBdUIsTUFBdkI7QUFDRCxLQUppQixFQUlmLElBSmUsQ0FJVixZQUFNO0FBQ1osTUFBQSxPQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYsQ0FBYywrQkFBZDtBQUNELEtBTmlCLENBQWxCO0FBUUEsSUFBQSxRQUFRLENBQUMsT0FBVDtBQUNBLFdBQU8sUUFBUDtBQUNELEdBeGtCSDs7QUFBQSxTQTBrQkUsY0Exa0JGLEdBMGtCRSx3QkFBZ0IsT0FBaEIsRUFBeUIsUUFBekIsRUFBbUM7QUFBQTtBQUFBOztBQUNqQztBQUNBLElBQUEsT0FBTyxHQUFHLE9BQU8sQ0FBQyxNQUFSLENBQWUsVUFBQyxJQUFEO0FBQUEsYUFBVSxDQUFDLElBQUksQ0FBQyxLQUFoQjtBQUFBLEtBQWYsQ0FBVjtBQUVBLElBQUEsT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsVUFBQyxNQUFELEVBQVk7QUFDMUIsVUFBTSxJQUFJLEdBQUcsT0FBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLENBQWtCLE1BQWxCLENBQWI7O0FBQ0EsTUFBQSxPQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxxQkFBZixFQUFzQyxJQUF0QyxFQUE0QztBQUMxQyxRQUFBLElBQUksRUFBRSxlQURvQztBQUUxQyxRQUFBLE9BQU8sRUFBRSxPQUFJLENBQUMsSUFBTCxDQUFVLGtCQUFWO0FBRmlDLE9BQTVDO0FBSUQsS0FORDs7QUFRQSxRQUFNLGNBQWMsR0FBRyxTQUFqQixjQUFpQixPQUEwQjtBQUFBLFVBQXZCLE9BQXVCLFFBQXZCLE9BQXVCO0FBQUEsVUFBZCxPQUFjLFFBQWQsT0FBYztBQUMvQyxVQUFJLGVBQUo7QUFDQSxhQUFPLE9BQUksQ0FBQyxlQUFMLENBQXFCLE9BQXJCLEVBQThCLFFBQTlCLEVBQXdDLE9BQXhDLEVBQWlELElBQWpELENBQXNELFVBQUMsUUFBRCxFQUFjO0FBQ3pFLFFBQUEsZUFBZSxHQUFHLFFBQWxCOztBQUNBLFlBQUksT0FBSSxDQUFDLElBQUwsQ0FBVSxvQkFBZCxFQUFvQztBQUNsQyxpQkFBTyxPQUFJLENBQUMsYUFBTCxDQUFtQixRQUFuQixFQUE2QixPQUE3QixDQUFQO0FBQ0Q7QUFDRixPQUxNLEVBS0osSUFMSSxDQUtDLFlBQU07QUFDWixRQUFBLE9BQU8sQ0FBQyxPQUFSLENBQWdCLFVBQUMsTUFBRCxFQUFZO0FBQzFCLGNBQU0sSUFBSSxHQUFHLE9BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFrQixNQUFsQixDQUFiOztBQUNBLFVBQUEsT0FBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUscUJBQWYsRUFBc0MsSUFBdEM7QUFDRCxTQUhEO0FBSUEsZUFBTyxlQUFQO0FBQ0QsT0FYTSxFQVdKLEtBWEksQ0FXRSxVQUFDLEdBQUQsRUFBUztBQUNoQixRQUFBLE9BQU8sQ0FBQyxPQUFSLENBQWdCLFVBQUMsTUFBRCxFQUFZO0FBQzFCLGNBQU0sSUFBSSxHQUFHLE9BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFrQixNQUFsQixDQUFiLENBRDBCLENBRTFCO0FBQ0E7OztBQUNBLFVBQUEsT0FBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUscUJBQWYsRUFBc0MsSUFBdEM7O0FBQ0EsVUFBQSxPQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxjQUFmLEVBQStCLElBQS9CLEVBQXFDLEdBQXJDO0FBQ0QsU0FORDtBQU9BLGNBQU0sR0FBTjtBQUNELE9BcEJNLENBQVA7QUFxQkQsS0F2QkQ7O0FBeUJBLGdDQUE4QixLQUFLLGNBQUwsRUFBOUI7QUFBQSxRQUFRLGlCQUFSLHlCQUFRLGlCQUFSOztBQUNBLFNBQUssY0FBTCxDQUFvQjtBQUNsQixNQUFBLGlCQUFpQixlQUNaLGlCQURZLDZCQUVkLFFBRmMsSUFFSCxFQUZHO0FBREMsS0FBcEI7QUFPQSxRQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsR0FBUixDQUFZLFVBQUMsRUFBRDtBQUFBLGFBQVEsT0FBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLENBQWtCLEVBQWxCLENBQVI7QUFBQSxLQUFaLENBQWQ7QUFDQSxRQUFNLGVBQWUsR0FBRyxJQUFJLGVBQUosQ0FBb0IsS0FBcEIsRUFBMkIsS0FBSyxJQUFoQyxDQUF4QjtBQUVBLFdBQU8sZUFBZSxDQUFDLEtBQWhCLEdBQXdCLElBQXhCLENBQ0wsVUFBQyxVQUFEO0FBQUEsYUFBZ0IsT0FBTyxDQUFDLEdBQVIsQ0FDZCxVQUFVLENBQUMsR0FBWCxDQUFlLGNBQWYsQ0FEYyxFQUVkLElBRmMsQ0FFVCxVQUFDLGlCQUFELEVBQXVCO0FBQzVCLFlBQU0sV0FBVyxHQUFHLGlCQUFpQixDQUFDLEdBQWxCLENBQXNCLFVBQUEsUUFBUTtBQUFBLGlCQUFJLFFBQVEsQ0FBQyxNQUFULENBQWdCLFdBQXBCO0FBQUEsU0FBOUIsQ0FBcEI7O0FBQ0EsUUFBQSxPQUFJLENBQUMsc0JBQUwsQ0FBNEIsV0FBNUIsRUFBeUMsT0FBekMsRUFBa0QsUUFBbEQ7O0FBQ0EsUUFBQSxpQkFBaUIsQ0FBQyxHQUFsQixDQUFzQixVQUFBLFFBQVE7QUFBQSxpQkFBSSxPQUFJLENBQUMsZ0JBQUwsQ0FBc0IsUUFBdEIsQ0FBSjtBQUFBLFNBQTlCO0FBQ0QsT0FOZSxDQUFoQjtBQUFBLEtBREssRUFRTDtBQUNBO0FBQ0EsY0FBQyxHQUFELEVBQVM7QUFDUCxNQUFBLE9BQU8sQ0FBQyxPQUFSLENBQWdCLFVBQUMsTUFBRCxFQUFZO0FBQzFCLFlBQU0sSUFBSSxHQUFHLE9BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFrQixNQUFsQixDQUFiOztBQUNBLFFBQUEsT0FBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUscUJBQWYsRUFBc0MsSUFBdEM7O0FBQ0EsUUFBQSxPQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxjQUFmLEVBQStCLElBQS9CLEVBQXFDLEdBQXJDO0FBQ0QsT0FKRDtBQUtBLFlBQU0sR0FBTjtBQUNELEtBakJJLENBQVA7QUFtQkQsR0E3b0JIOztBQUFBLFNBK29CRSxZQS9vQkYsR0Erb0JFLHNCQUFjLE9BQWQsRUFBdUIsUUFBdkIsRUFBaUM7QUFBQTs7QUFDL0IsUUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEdBQVIsQ0FBWSxVQUFBLE1BQU07QUFBQSxhQUFJLE9BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFrQixNQUFsQixDQUFKO0FBQUEsS0FBbEIsQ0FBZCxDQUQrQixDQUUvQjs7QUFDQSxJQUFBLE9BQU8sR0FBRyxLQUFLLENBQUMsTUFBTixDQUFhLFVBQUMsSUFBRDtBQUFBLGFBQVUsQ0FBQyxJQUFJLENBQUMsS0FBaEI7QUFBQSxLQUFiLEVBQW9DLEdBQXBDLENBQXdDLFVBQUEsSUFBSTtBQUFBLGFBQUksSUFBSSxDQUFDLEVBQVQ7QUFBQSxLQUE1QyxDQUFWO0FBRUEsUUFBTSxLQUFLLEdBQUcsS0FBSyxjQUFMLEVBQWQsQ0FMK0IsQ0FPL0I7O0FBQ0EsUUFBSSxLQUFLLFFBQVQsRUFBbUI7QUFDakIsYUFBTyxLQUFLLFFBQUwsQ0FBYyxJQUFkLENBQW1CLFlBQU07QUFDOUIsZUFBTyxPQUFJLENBQUMsWUFBTCxDQUFrQixPQUFsQixFQUEyQixRQUEzQixDQUFQO0FBQ0QsT0FGTSxDQUFQO0FBR0Q7O0FBRUQsUUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLGlCQUFOLENBQXdCLFFBQXhCLENBQXBCOztBQUVBLFFBQU0sc0JBQXNCLEdBQUcsU0FBekIsc0JBQXlCLEdBQU07QUFDbkMsTUFBQSxXQUFXLENBQUMsT0FBWixDQUFvQixVQUFDLFVBQUQsRUFBZ0I7QUFDbEMsWUFBTSxRQUFRLEdBQUcsT0FBSSxDQUFDLGdCQUFMLENBQXNCLFVBQXRCLENBQWpCO0FBQ0EsUUFBQSxRQUFRLENBQUMsS0FBVDtBQUNBLGVBQU8sT0FBSSxDQUFDLGdCQUFMLENBQXNCLFVBQXRCLENBQVA7QUFDRCxPQUpEO0FBS0QsS0FORCxDQWhCK0IsQ0F3Qi9CO0FBQ0E7OztBQUNBLFFBQUksQ0FBQyxLQUFLLHNCQUFMLEVBQUwsRUFBb0M7QUFDbEMsTUFBQSxzQkFBc0I7QUFDdEIsVUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLEdBQVosQ0FBZ0IsVUFBQyxFQUFEO0FBQUEsZUFBUSxPQUFJLENBQUMsV0FBTCxDQUFpQixFQUFqQixDQUFSO0FBQUEsT0FBaEIsQ0FBbkI7QUFDQSxXQUFLLElBQUwsQ0FBVSxhQUFWLENBQXdCLFFBQXhCLEVBQWtDO0FBQUUsUUFBQSxXQUFXLEVBQUU7QUFBZixPQUFsQztBQUNBLGFBQU8sT0FBTyxDQUFDLE9BQVIsRUFBUDtBQUNELEtBL0I4QixDQWlDL0I7QUFDQTs7O0FBQ0EsUUFBSSxXQUFXLENBQUMsTUFBWixLQUF1QixDQUEzQixFQUE4QjtBQUM1QixXQUFLLElBQUwsQ0FBVSxhQUFWLENBQXdCLFFBQXhCLEVBQWtDO0FBQUUsUUFBQSxXQUFXLEVBQUU7QUFBZixPQUFsQztBQUNBLGFBQU8sT0FBTyxDQUFDLE9BQVIsRUFBUDtBQUNEOztBQUVELFFBQU0sZUFBZSxHQUFHLEtBQUssQ0FBQyxNQUFOLENBQWEsVUFBQSxJQUFJO0FBQUEsYUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFJLENBQUMsY0FBTixFQUFzQixJQUFJLENBQUMsRUFBM0IsQ0FBaEI7QUFBQSxLQUFqQixDQUF4QjtBQUNBLElBQUEsZUFBZSxDQUFDLE9BQWhCLENBQXdCLFVBQUMsSUFBRCxFQUFVO0FBQ2hDLE1BQUEsT0FBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsc0JBQWYsRUFBdUMsSUFBdkMsRUFBNkM7QUFDM0MsUUFBQSxJQUFJLEVBQUUsZUFEcUM7QUFFM0MsUUFBQSxPQUFPLEVBQUUsT0FBSSxDQUFDLElBQUwsQ0FBVSxVQUFWO0FBRmtDLE9BQTdDO0FBSUQsS0FMRDtBQU9BLFFBQU0sT0FBTyxHQUFHLEtBQUssZ0JBQUwsQ0FBc0IsUUFBdEIsQ0FBaEI7QUFDQSxXQUFPLE9BQU8sQ0FBQyxPQUFSLENBQWdCLElBQWhCLENBQXFCLFlBQU07QUFDaEMsTUFBQSxzQkFBc0I7QUFFdEIsVUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLEdBQVosQ0FBZ0IsVUFBQyxFQUFEO0FBQUEsZUFBUSxPQUFJLENBQUMsV0FBTCxDQUFpQixFQUFqQixDQUFSO0FBQUEsT0FBaEIsQ0FBbkIsQ0FIZ0MsQ0FLaEM7QUFDQTs7QUFDQSxVQUFNLEtBQUssR0FBRyxPQUFJLENBQUMsY0FBTCxFQUFkOztBQUNBLFVBQU0saUJBQWlCLGdCQUFRLEtBQUssQ0FBQyxpQkFBZCxDQUF2Qjs7QUFDQSxhQUFPLGlCQUFpQixDQUFDLFFBQUQsQ0FBeEI7O0FBQ0EsTUFBQSxPQUFJLENBQUMsY0FBTCxDQUFvQjtBQUFFLFFBQUEsaUJBQWlCLEVBQWpCO0FBQUYsT0FBcEI7O0FBRUEsTUFBQSxPQUFJLENBQUMsSUFBTCxDQUFVLGFBQVYsQ0FBd0IsUUFBeEIsRUFBa0M7QUFDaEMsUUFBQSxXQUFXLEVBQUU7QUFEbUIsT0FBbEM7QUFHRCxLQWZNLENBQVA7QUFnQkQsR0FodEJIOztBQUFBLFNBa3RCRSxRQWx0QkYsR0FrdEJFLGtCQUFVLEdBQVYsRUFBc0IsUUFBdEIsRUFBZ0M7QUFBQTs7QUFBQSxRQUF0QixHQUFzQjtBQUF0QixNQUFBLEdBQXNCLEdBQWhCLElBQWdCO0FBQUE7O0FBQzlCLFFBQU0sS0FBSyxHQUFHLEtBQUssY0FBTCxFQUFkO0FBQ0EsUUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLGlCQUFOLENBQXdCLFFBQXhCLENBQXBCO0FBRUEsSUFBQSxXQUFXLENBQUMsT0FBWixDQUFvQixVQUFDLFVBQUQsRUFBZ0I7QUFDbEMsVUFBSSxPQUFJLENBQUMsZ0JBQUwsQ0FBc0IsVUFBdEIsQ0FBSixFQUF1QztBQUNyQyxRQUFBLE9BQUksQ0FBQyxnQkFBTCxDQUFzQixVQUF0QixFQUFrQyxLQUFsQztBQUNEO0FBQ0YsS0FKRDtBQUtELEdBM3RCSDs7QUFBQSxTQTZ0QkUsV0E3dEJGLEdBNnRCRSxxQkFBYSxHQUFiLEVBQWtCO0FBQ2hCLFFBQUksR0FBRyxJQUFJLFNBQVMsSUFBVCxDQUFjLEdBQUcsQ0FBQyxPQUFsQixDQUFYLEVBQXVDO0FBQ3JDLFVBQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxlQUFKLEdBQXNCLEdBQUcsQ0FBQyxlQUFKLENBQW9CLG1CQUFwQixFQUF0QixHQUFrRSxJQUE5RTtBQUNBLFVBQU0sR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsV0FBWCxHQUF5QixHQUFHLENBQUMsV0FBN0IsR0FBMkMsSUFBdkQ7QUFDQSxXQUFLLE1BQUwsQ0FBWSxXQUFaLENBQXdCLEdBQXhCLEVBQTZCO0FBQUUsUUFBQSxHQUFHLEVBQUgsR0FBRjtBQUFPLFFBQUEsSUFBSSxFQUFFO0FBQWIsT0FBN0IsRUFBeUQsSUFBekQsQ0FBOEQsVUFBQyxDQUFELEVBQU8sQ0FDbkU7QUFDRCxPQUZEO0FBR0Q7QUFDRixHQXJ1Qkg7O0FBQUEsU0F1dUJFLE9BdnVCRixHQXV1QkUsbUJBQVc7QUFDVCxTQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLEtBQUssY0FBL0I7QUFDQSxTQUFLLElBQUwsQ0FBVSxnQkFBVixDQUEyQixLQUFLLFlBQWhDLEVBRlMsQ0FJVDs7QUFDQSxTQUFLLElBQUwsQ0FBVSxFQUFWLENBQWEsT0FBYixFQUFzQixLQUFLLFFBQTNCLEVBTFMsQ0FPVDs7QUFDQSxTQUFLLElBQUwsQ0FBVSxFQUFWLENBQWEsWUFBYixFQUEyQixLQUFLLFlBQWhDLEVBUlMsQ0FVVDs7QUFDQSxTQUFLLElBQUwsQ0FBVSxFQUFWLENBQWEsY0FBYixFQUE2QixLQUFLLFdBQWxDOztBQUVBLFFBQUksS0FBSyxJQUFMLENBQVUsb0JBQWQsRUFBb0M7QUFDbEM7QUFDQSxXQUFLLElBQUwsQ0FBVSxFQUFWLENBQWEsZ0JBQWIsRUFBK0IsS0FBSyx5QkFBcEM7QUFDRCxLQUhELE1BR087QUFDTCxXQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsR0FBZCxFQUFtQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFBLDJCQUEyQixFQUFFLEtBVlo7QUFXakIsUUFBQSxNQUFNLEVBQUUsS0FYUztBQVlqQjtBQUNBO0FBQ0EsUUFBQSxrQkFBa0IsRUFBRSxLQWRIO0FBZWpCO0FBQ0EsUUFBQSxVQUFVLEVBQUUsQ0FBQyxjQUFELEVBQWlCLFVBQWpCLEVBQTZCLFdBQTdCLENBaEJLO0FBaUJqQjtBQUNBLFFBQUEsS0FBSyxFQUFFLEtBQUssSUFBTCxDQUFVO0FBbEJBLE9BQW5CO0FBb0JEOztBQUVELFNBQUssSUFBTCxDQUFVLEVBQVYsQ0FBYSxrQkFBYixFQUFpQyxLQUFLLGtCQUF0QztBQUNBLFNBQUssSUFBTCxDQUFVLEVBQVYsQ0FBYSxVQUFiLEVBQXlCLEtBQUssV0FBOUI7QUFFQSxTQUFLLGNBQUwsQ0FBb0I7QUFDbEI7QUFDQSxNQUFBLFVBQVUsRUFBRSxFQUZNO0FBR2xCO0FBQ0EsTUFBQSxpQkFBaUIsRUFBRSxFQUpEO0FBS2xCO0FBQ0EsTUFBQSxLQUFLLEVBQUUsRUFOVztBQU9sQjtBQUNBLE1BQUEsT0FBTyxFQUFFO0FBUlMsS0FBcEIsRUExQ1MsQ0FxRFQ7O0FBQ0EsOEJBQXlCLEtBQUssSUFBTCxDQUFVLFFBQVYsRUFBekI7QUFBQSxRQUFRLFlBQVIsdUJBQVEsWUFBUjs7QUFDQSxTQUFLLElBQUwsQ0FBVSxRQUFWLENBQW1CO0FBQ2pCLE1BQUEsWUFBWSxlQUNQLFlBRE87QUFFVixRQUFBLHNCQUFzQixFQUFFO0FBRmQ7QUFESyxLQUFuQjtBQU1ELEdBcHlCSDs7QUFBQSxTQXN5QkUsU0F0eUJGLEdBc3lCRSxxQkFBYTtBQUNYLFNBQUssSUFBTCxDQUFVLGtCQUFWLENBQTZCLEtBQUssY0FBbEM7QUFDQSxTQUFLLElBQUwsQ0FBVSxtQkFBVixDQUE4QixLQUFLLFlBQW5DO0FBQ0EsU0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLE9BQWQsRUFBdUIsS0FBSyxRQUE1Qjs7QUFFQSxRQUFJLEtBQUssSUFBTCxDQUFVLG9CQUFkLEVBQW9DO0FBQ2xDLFdBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxnQkFBZCxFQUFnQyxLQUFLLHlCQUFyQztBQUNEOztBQUVELCtCQUF5QixLQUFLLElBQUwsQ0FBVSxRQUFWLEVBQXpCO0FBQUEsUUFBUSxZQUFSLHdCQUFRLFlBQVI7O0FBQ0EsU0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQjtBQUNqQixNQUFBLFlBQVksZUFDUCxZQURPO0FBRVYsUUFBQSxzQkFBc0IsRUFBRTtBQUZkO0FBREssS0FBbkI7QUFNRCxHQXR6Qkg7O0FBQUEsU0F3ekJFLFdBeHpCRixHQXd6QkUscUJBQWEsRUFBYixFQUFpQjtBQUNmLGdDQUF1QixLQUFLLGNBQUwsRUFBdkI7QUFBQSxRQUFRLFVBQVIseUJBQVEsVUFBUjs7QUFDQSxXQUFPLFVBQVUsQ0FBQyxFQUFELENBQWpCO0FBQ0QsR0EzekJIOztBQUFBLFNBNnpCRSxnQkE3ekJGLEdBNnpCRSwwQkFBa0IsVUFBbEIsRUFBOEI7QUFDNUIsV0FBTyxLQUFLLElBQUwsQ0FBVSxRQUFWLEdBQXFCLE1BQXJCLENBQTRCLFVBQUMsSUFBRCxFQUFVO0FBQzNDLGFBQU8sSUFBSSxJQUFJLElBQUksQ0FBQyxXQUFiLElBQTRCLElBQUksQ0FBQyxXQUFMLENBQWlCLFFBQWpCLEtBQThCLFVBQWpFO0FBQ0QsS0FGTSxDQUFQO0FBR0QsR0FqMEJIOztBQUFBO0FBQUEsRUFBMkMsTUFBM0MsVUFDUyxPQURULEdBQ21CLE9BQU8sQ0FBQyxpQkFBRCxDQUFQLENBQTJCLE9BRDlDO0FBbzBCQSxNQUFNLENBQUMsT0FBUCxDQUFlLFNBQWYsR0FBMkIsU0FBM0I7QUFDQSxNQUFNLENBQUMsT0FBUCxDQUFlLFdBQWYsR0FBNkIsU0FBN0I7QUFDQSxNQUFNLENBQUMsT0FBUCxDQUFlLGlCQUFmLEdBQW1DLHlCQUFuQzs7O0FDajJCQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLFFBQVQsQ0FBbUIsR0FBbkIsRUFBd0I7QUFDdkMsTUFBTSxNQUFNLEdBQUcsWUFBWSxJQUFaLENBQWlCLEdBQWpCLENBQWY7QUFDQSxNQUFJLENBQUMsR0FBRyxDQUFSOztBQUNBLE1BQUksTUFBSixFQUFZO0FBQ1YsSUFBQSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLE1BQVYsR0FBbUIsQ0FBdkI7QUFDRDs7QUFDRCxNQUFNLFVBQVUsR0FBRyxHQUFHLENBQUMsT0FBSixDQUFZLEdBQVosRUFBaUIsQ0FBakIsQ0FBbkI7O0FBQ0EsTUFBSSxVQUFVLEtBQUssQ0FBQyxDQUFwQixFQUF1QjtBQUNyQixXQUFPO0FBQ0wsTUFBQSxNQUFNLEVBQUUsR0FESDtBQUVMLE1BQUEsUUFBUSxFQUFFO0FBRkwsS0FBUDtBQUlEOztBQUVELFNBQU87QUFDTCxJQUFBLE1BQU0sRUFBRSxHQUFHLENBQUMsS0FBSixDQUFVLENBQVYsRUFBYSxVQUFiLENBREg7QUFFTCxJQUFBLFFBQVEsRUFBRSxHQUFHLENBQUMsS0FBSixDQUFVLFVBQVY7QUFGTCxHQUFQO0FBSUQsQ0FsQkQ7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0EsSUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLGVBQUQsQ0FBbkI7O0FBRUEsU0FBUyxTQUFULEdBQXNCO0FBQ3BCLFNBQU8sT0FBTyxNQUFQLEtBQWtCLFdBQWxCLEtBQ0wsT0FBTyxNQUFNLENBQUMsUUFBZCxLQUEyQixXQUEzQixJQUNHLE9BQU8sTUFBTSxDQUFDLE9BQWQsS0FBMEIsV0FEN0IsSUFFRyxPQUFPLE1BQU0sQ0FBQyxPQUFkLEtBQTBCLFdBSHhCLENBQVA7QUFLRDs7QUFFRCxTQUFTLGFBQVQsR0FBMEI7QUFDeEIsU0FBTyxPQUFPLFNBQVAsS0FBcUIsV0FBckIsSUFDRixPQUFPLFNBQVMsQ0FBQyxPQUFqQixLQUE2QixRQUQzQixJQUVGLFNBQVMsQ0FBQyxPQUFWLENBQWtCLFdBQWxCLE9BQW9DLGFBRnpDO0FBR0QsQyxDQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsY0FBVCxDQUF5QixXQUF6QixFQUFzQztBQUNyRCxTQUFPLFVBQVUsSUFBVixFQUFnQixPQUFoQixFQUF5QjtBQUM5QixRQUFJLFNBQVMsTUFBTSxhQUFhLEVBQWhDLEVBQW9DO0FBQ2xDLGFBQU8sR0FBRyxDQUFDLGNBQUosQ0FBbUIsV0FBbkIsQ0FBK0IsSUFBL0IsRUFBcUMsT0FBckMsQ0FBUDtBQUNEOztBQUVELFFBQU0sZUFBZSxHQUFHLENBQ3RCLEtBRHNCLEVBRXRCLFdBQVcsQ0FBQyxFQUZVLEVBR3RCLE9BQU8sQ0FBQyxRQUhjLEVBSXRCLElBSnNCLENBSWpCLEdBSmlCLENBQXhCO0FBTUEsV0FBTyxPQUFPLENBQUMsT0FBUixDQUFnQixlQUFoQixDQUFQO0FBQ0QsR0FaRDtBQWFELENBZEQ7Ozs7Ozs7Ozs7Ozs7QUN4QkEsZUFBbUIsT0FBTyxDQUFDLFlBQUQsQ0FBMUI7QUFBQSxJQUFRLE1BQVIsWUFBUSxNQUFSOztBQUNBLElBQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxlQUFELENBQW5COztBQUNBLGdCQUE0QyxPQUFPLENBQUMsd0JBQUQsQ0FBbkQ7QUFBQSxJQUFRLFFBQVIsYUFBUSxRQUFSO0FBQUEsSUFBa0IsYUFBbEIsYUFBa0IsYUFBbEI7QUFBQSxJQUFpQyxNQUFqQyxhQUFpQyxNQUFqQzs7QUFDQSxJQUFNLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxvQ0FBRCxDQUFsQzs7QUFDQSxJQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsK0JBQUQsQ0FBN0I7O0FBQ0EsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLHdCQUFELENBQXRCOztBQUNBLElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyw4QkFBRCxDQUE1Qjs7QUFDQSxJQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsOEJBQUQsQ0FBNUI7O0FBQ0EsSUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLGdDQUFELENBQTlCOztBQUNBLElBQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLGtDQUFELENBQWhDOztBQUNBLElBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyw2QkFBRCxDQUEzQjs7QUFDQSxJQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsa0JBQUQsQ0FBOUI7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLElBQU0saUJBQWlCLEdBQUc7QUFDeEIsRUFBQSxRQUFRLEVBQUUsRUFEYztBQUd4QixFQUFBLFNBQVMsRUFBRSxJQUhhO0FBSXhCLEVBQUEsUUFBUSxFQUFFLEVBSmM7QUFLeEIsRUFBQSxVQUFVLEVBQUUsSUFMWTtBQU94QixFQUFBLFVBQVUsRUFBRSxJQVBZO0FBUXhCLEVBQUEsZUFBZSxFQUFFLElBUk87QUFTeEIsRUFBQSxTQUFTLEVBQUUsSUFUYTtBQVV4QixFQUFBLE9BQU8sRUFBRSxJQVZlO0FBWXhCLEVBQUEsbUJBQW1CLEVBQUUsS0FaRztBQWF4QixFQUFBLE9BQU8sRUFBRSxFQWJlO0FBY3hCLEVBQUEsWUFBWSxFQUFFLEtBZFU7QUFnQnhCLEVBQUEsU0FBUyxFQUFFLFFBaEJhO0FBaUJ4QixFQUFBLFdBQVcsRUFBRSxDQUFDLENBQUQsRUFBSSxJQUFKLEVBQVUsSUFBVixFQUFnQixJQUFoQixDQWpCVztBQWtCeEIsRUFBQSxlQUFlLEVBQUUsQ0FsQk87QUFtQnhCLEVBQUEsMkJBQTJCLEVBQUUsSUFuQkw7QUFvQnhCLEVBQUEsMEJBQTBCLEVBQUUsS0FwQko7QUFxQnhCLEVBQUEsb0JBQW9CLEVBQUUsS0FyQkU7QUFzQnhCLEVBQUEsd0JBQXdCLEVBQUU7QUF0QkYsQ0FBMUI7QUF5QkE7QUFDQTtBQUNBOztBQUNBLE1BQU0sQ0FBQyxPQUFQO0FBQUE7O0FBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDRSxlQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUI7QUFBQTs7QUFDdkIsK0JBQU0sSUFBTixFQUFZLElBQVo7QUFDQSxVQUFLLElBQUwsR0FBWSxVQUFaO0FBQ0EsVUFBSyxFQUFMLEdBQVUsTUFBSyxJQUFMLENBQVUsRUFBVixJQUFnQixLQUExQjtBQUNBLFVBQUssS0FBTCxHQUFhLEtBQWIsQ0FKdUIsQ0FNdkI7O0FBQ0EsUUFBTSxjQUFjLEdBQUc7QUFDckIsTUFBQSxTQUFTLEVBQUUsSUFEVTtBQUVyQixNQUFBLE1BQU0sRUFBRSxJQUZhO0FBR3JCLE1BQUEsa0JBQWtCLEVBQUUsSUFIQztBQUlyQixNQUFBLEtBQUssRUFBRSxDQUpjO0FBS3JCLE1BQUEsV0FBVyxFQUFFLENBQUMsQ0FBRCxFQUFJLElBQUosRUFBVSxJQUFWLEVBQWdCLElBQWhCLENBTFE7QUFNckIsTUFBQSxlQUFlLEVBQUU7QUFOSSxLQUF2QixDQVB1QixDQWdCdkI7O0FBQ0E7O0FBQ0EsVUFBSyxJQUFMLGdCQUFpQixjQUFqQixFQUFvQyxJQUFwQztBQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBQ0ksVUFBSyxRQUFMLEdBQWdCLElBQUksZ0JBQUosQ0FBcUIsTUFBSyxJQUFMLENBQVUsS0FBL0IsQ0FBaEI7QUFFQSxVQUFLLFNBQUwsR0FBaUIsTUFBTSxDQUFDLE1BQVAsQ0FBYyxJQUFkLENBQWpCO0FBQ0EsVUFBSyxjQUFMLEdBQXNCLE1BQU0sQ0FBQyxNQUFQLENBQWMsSUFBZCxDQUF0QjtBQUNBLFVBQUssZUFBTCxHQUF1QixNQUFNLENBQUMsTUFBUCxDQUFjLElBQWQsQ0FBdkI7QUFFQSxVQUFLLG1CQUFMLEdBQTJCLE1BQUssbUJBQUwsQ0FBeUIsSUFBekIsK0JBQTNCO0FBQ0EsVUFBSyxZQUFMLEdBQW9CLE1BQUssWUFBTCxDQUFrQixJQUFsQiwrQkFBcEI7QUFoQ3VCO0FBaUN4Qjs7QUF4Q0g7O0FBQUEsU0EwQ0UsbUJBMUNGLEdBMENFLCtCQUF1QjtBQUNyQixRQUFNLEtBQUssZ0JBQVEsS0FBSyxJQUFMLENBQVUsUUFBVixHQUFxQixLQUE3QixDQUFYOztBQUNBLElBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxLQUFaLEVBQW1CLE9BQW5CLENBQTJCLFVBQUMsTUFBRCxFQUFZO0FBQ3JDO0FBQ0EsVUFBSSxLQUFLLENBQUMsTUFBRCxDQUFMLENBQWMsR0FBZCxJQUFxQixLQUFLLENBQUMsTUFBRCxDQUFMLENBQWMsR0FBZCxDQUFrQixTQUEzQyxFQUFzRDtBQUNwRCxZQUFNLFFBQVEsZ0JBQVEsS0FBSyxDQUFDLE1BQUQsQ0FBTCxDQUFjLEdBQXRCLENBQWQ7O0FBQ0EsZUFBTyxRQUFRLENBQUMsU0FBaEI7QUFDQSxRQUFBLEtBQUssQ0FBQyxNQUFELENBQUwsZ0JBQXFCLEtBQUssQ0FBQyxNQUFELENBQTFCO0FBQW9DLFVBQUEsR0FBRyxFQUFFO0FBQXpDO0FBQ0Q7QUFDRixLQVBEO0FBU0EsU0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQjtBQUFFLE1BQUEsS0FBSyxFQUFMO0FBQUYsS0FBbkI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdEQTs7QUFBQSxTQThERSx1QkE5REYsR0E4REUsaUNBQXlCLE1BQXpCLEVBQWlDLElBQWpDLEVBQTRDO0FBQUEsUUFBWCxJQUFXO0FBQVgsTUFBQSxJQUFXLEdBQUosRUFBSTtBQUFBOztBQUMxQyxRQUFJLEtBQUssU0FBTCxDQUFlLE1BQWYsQ0FBSixFQUE0QjtBQUMxQixVQUFNLFFBQVEsR0FBRyxLQUFLLFNBQUwsQ0FBZSxNQUFmLENBQWpCO0FBQ0EsTUFBQSxRQUFRLENBQUMsS0FBVDs7QUFDQSxVQUFJLElBQUksQ0FBQyxLQUFULEVBQWdCO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsUUFBQSxVQUFVLENBQUM7QUFBQSxpQkFBTSxRQUFRLENBQUMsS0FBVCxDQUFlLElBQWYsQ0FBTjtBQUFBLFNBQUQsRUFBNkIsSUFBN0IsQ0FBVjtBQUNEOztBQUNELFdBQUssU0FBTCxDQUFlLE1BQWYsSUFBeUIsSUFBekI7QUFDRDs7QUFDRCxRQUFJLEtBQUssY0FBTCxDQUFvQixNQUFwQixDQUFKLEVBQWlDO0FBQy9CLFdBQUssY0FBTCxDQUFvQixNQUFwQixFQUE0QixNQUE1QjtBQUNBLFdBQUssY0FBTCxDQUFvQixNQUFwQixJQUE4QixJQUE5QjtBQUNEOztBQUNELFFBQUksS0FBSyxlQUFMLENBQXFCLE1BQXJCLENBQUosRUFBa0M7QUFDaEMsV0FBSyxlQUFMLENBQXFCLE1BQXJCLEVBQTZCLEtBQTdCO0FBQ0EsV0FBSyxlQUFMLENBQXFCLE1BQXJCLElBQStCLElBQS9CO0FBQ0Q7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEhBOztBQUFBLFNBbUhFLE1BbkhGLEdBbUhFLGdCQUFRLElBQVIsRUFBYyxPQUFkLEVBQXVCLEtBQXZCLEVBQThCO0FBQUE7O0FBQzVCLFNBQUssdUJBQUwsQ0FBNkIsSUFBSSxDQUFDLEVBQWxDLEVBRDRCLENBRzVCOztBQUNBLFdBQU8sSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLGdCQUFmLEVBQWlDLElBQWpDOztBQUVBLFVBQU0sSUFBSSxnQkFDTCxNQUFJLENBQUMsSUFEQSxFQUVKLElBQUksQ0FBQyxHQUFMLElBQVksRUFGUixDQUFWO0FBS0E7OztBQUNBLFVBQU0sYUFBYSxnQkFDZCxpQkFEYyxFQUdkLElBSGMsQ0FBbkI7O0FBTUEsYUFBTyxhQUFhLENBQUMsTUFBckIsQ0Fmc0MsQ0FpQnRDO0FBQ0E7O0FBQ0EsVUFBSSxJQUFJLENBQUMsTUFBVCxFQUFpQjtBQUNmLFFBQUEsYUFBYSxDQUFDLDJCQUFkLEdBQTRDLElBQTVDO0FBQ0QsT0FyQnFDLENBdUJ0QztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBQSxhQUFhLENBQUMsV0FBZCxHQUE0QixjQUFjLENBQUMsSUFBRCxDQUExQzs7QUFFQSxNQUFBLGFBQWEsQ0FBQyxlQUFkLEdBQWdDLFVBQUMsR0FBRCxFQUFTO0FBQ3ZDLFlBQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxtQkFBSixFQUFaO0FBQ0EsUUFBQSxHQUFHLENBQUMsZUFBSixHQUFzQixDQUFDLENBQUMsSUFBSSxDQUFDLGVBQTdCOztBQUVBLFlBQUksT0FBTyxJQUFJLENBQUMsZUFBWixLQUFnQyxVQUFwQyxFQUFnRDtBQUM5QyxVQUFBLElBQUksQ0FBQyxlQUFMLENBQXFCLEdBQXJCO0FBQ0Q7QUFDRixPQVBEOztBQVNBLE1BQUEsYUFBYSxDQUFDLE9BQWQsR0FBd0IsVUFBQyxHQUFELEVBQVM7QUFDL0IsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYsQ0FBYyxHQUFkOztBQUVBLFlBQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxlQUFKLEdBQXNCLEdBQUcsQ0FBQyxlQUFKLENBQW9CLG1CQUFwQixFQUF0QixHQUFrRSxJQUE5RTs7QUFDQSxZQUFJLGNBQWMsQ0FBQyxHQUFELENBQWxCLEVBQXlCO0FBQ3ZCLFVBQUEsR0FBRyxHQUFHLElBQUksWUFBSixDQUFpQixHQUFqQixFQUFzQixHQUF0QixDQUFOO0FBQ0Q7O0FBRUQsUUFBQSxNQUFJLENBQUMsdUJBQUwsQ0FBNkIsSUFBSSxDQUFDLEVBQWxDOztBQUNBLFFBQUEsYUFBYSxDQUFDLElBQWQ7O0FBRUEsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxjQUFmLEVBQStCLElBQS9CLEVBQXFDLEdBQXJDOztBQUVBLFFBQUEsTUFBTSxDQUFDLEdBQUQsQ0FBTjtBQUNELE9BZEQ7O0FBZ0JBLE1BQUEsYUFBYSxDQUFDLFVBQWQsR0FBMkIsVUFBQyxhQUFELEVBQWdCLFVBQWhCLEVBQStCO0FBQ3hELFFBQUEsTUFBSSxDQUFDLGtCQUFMLENBQXdCLElBQXhCLEVBQThCLE1BQU0sQ0FBQyxHQUFyQzs7QUFDQSxRQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLGlCQUFmLEVBQWtDLElBQWxDLEVBQXdDO0FBQ3RDLFVBQUEsUUFBUSxFQUFFLE1BRDRCO0FBRXRDLFVBQUEsYUFBYSxFQUFiLGFBRnNDO0FBR3RDLFVBQUEsVUFBVSxFQUFWO0FBSHNDLFNBQXhDO0FBS0QsT0FQRDs7QUFTQSxNQUFBLGFBQWEsQ0FBQyxTQUFkLEdBQTBCLFlBQU07QUFDOUIsWUFBTSxVQUFVLEdBQUc7QUFDakIsVUFBQSxTQUFTLEVBQUUsTUFBTSxDQUFDO0FBREQsU0FBbkI7O0FBSUEsUUFBQSxNQUFJLENBQUMsdUJBQUwsQ0FBNkIsSUFBSSxDQUFDLEVBQWxDOztBQUNBLFFBQUEsYUFBYSxDQUFDLElBQWQ7O0FBRUEsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxnQkFBZixFQUFpQyxJQUFqQyxFQUF1QyxVQUF2Qzs7QUFFQSxZQUFJLE1BQU0sQ0FBQyxHQUFYLEVBQWdCO0FBQ2QsVUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYsZUFBMEIsTUFBTSxDQUFDLElBQVAsQ0FBWSxJQUF0QyxjQUFtRCxNQUFNLENBQUMsR0FBMUQ7QUFDRDs7QUFFRCxRQUFBLE9BQU8sQ0FBQyxNQUFELENBQVA7QUFDRCxPQWZEOztBQWlCQSxVQUFNLFFBQVEsR0FBRyxTQUFYLFFBQVcsQ0FBQyxHQUFELEVBQU0sT0FBTixFQUFlLFFBQWYsRUFBNEI7QUFDM0MsWUFBSSxXQUFXLENBQUMsR0FBRCxFQUFNLE9BQU4sQ0FBWCxJQUE2QixDQUFDLFdBQVcsQ0FBQyxHQUFELEVBQU0sUUFBTixDQUE3QyxFQUE4RDtBQUM1RCxVQUFBLEdBQUcsQ0FBQyxRQUFELENBQUgsR0FBZ0IsR0FBRyxDQUFDLE9BQUQsQ0FBbkI7QUFDRDtBQUNGLE9BSkQ7QUFNQTs7O0FBQ0EsVUFBTSxJQUFJLEdBQUcsRUFBYjtBQUNBLFVBQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxPQUFOLENBQWMsSUFBSSxDQUFDLFVBQW5CLElBQ2YsSUFBSSxDQUFDLFVBRFUsQ0FFakI7QUFGaUIsUUFHZixNQUFNLENBQUMsSUFBUCxDQUFZLElBQUksQ0FBQyxJQUFqQixDQUhKO0FBSUEsTUFBQSxVQUFVLENBQUMsT0FBWCxDQUFtQixVQUFDLElBQUQsRUFBVTtBQUMzQixRQUFBLElBQUksQ0FBQyxJQUFELENBQUosR0FBYSxJQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBYjtBQUNELE9BRkQsRUE1RnNDLENBZ0d0Qzs7QUFDQSxNQUFBLFFBQVEsQ0FBQyxJQUFELEVBQU8sTUFBUCxFQUFlLFVBQWYsQ0FBUjtBQUNBLE1BQUEsUUFBUSxDQUFDLElBQUQsRUFBTyxNQUFQLEVBQWUsVUFBZixDQUFSO0FBRUEsTUFBQSxhQUFhLENBQUMsUUFBZCxHQUF5QixJQUF6QjtBQUVBLFVBQU0sTUFBTSxHQUFHLElBQUksR0FBRyxDQUFDLE1BQVIsQ0FBZSxJQUFJLENBQUMsSUFBcEIsRUFBMEIsYUFBMUIsQ0FBZjtBQUNBLE1BQUEsTUFBSSxDQUFDLFNBQUwsQ0FBZSxJQUFJLENBQUMsRUFBcEIsSUFBMEIsTUFBMUI7QUFDQSxNQUFBLE1BQUksQ0FBQyxjQUFMLENBQW9CLElBQUksQ0FBQyxFQUF6QixJQUErQixJQUFJLFlBQUosQ0FBaUIsTUFBSSxDQUFDLElBQXRCLENBQS9CLENBeEdzQyxDQTBHdEM7QUFDQTs7QUFDQSxVQUFJLElBQUksQ0FBQyxNQUFULEVBQWlCO0FBQ2YsUUFBQSxNQUFNLENBQUMsbUJBQVAsR0FBNkIsSUFBN0IsQ0FBa0MsVUFBQyxlQUFELEVBQXFCO0FBQ3JELGNBQU0sY0FBYyxHQUFHLGVBQWUsQ0FBQyxDQUFELENBQXRDOztBQUNBLGNBQUksY0FBSixFQUFvQjtBQUNsQixZQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsR0FBViwrQkFBMEMsSUFBSSxDQUFDLEVBQS9DLG9CQUFnRSxjQUFjLENBQUMsWUFBL0U7O0FBQ0EsWUFBQSxNQUFNLENBQUMsd0JBQVAsQ0FBZ0MsY0FBaEM7QUFDRDtBQUNGLFNBTkQ7QUFPRDs7QUFFRCxVQUFJLGFBQWEsR0FBRyxNQUFJLENBQUMsUUFBTCxDQUFjLEdBQWQsQ0FBa0IsWUFBTTtBQUMxQyxZQUFJLENBQUMsSUFBSSxDQUFDLFFBQVYsRUFBb0I7QUFDbEI7QUFDQTtBQUNBLFVBQUEsT0FBTyxDQUFDLE9BQVIsR0FBa0IsSUFBbEIsQ0FBdUIsWUFBTTtBQUMzQixZQUFBLE1BQU0sQ0FBQyxLQUFQO0FBQ0QsV0FGRDtBQUdELFNBUHlDLENBUTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsZUFBTyxZQUFNLENBQUUsQ0FBZjtBQUNELE9BZm1CLENBQXBCOztBQWlCQSxNQUFBLE1BQUksQ0FBQyxZQUFMLENBQWtCLElBQUksQ0FBQyxFQUF2QixFQUEyQixVQUFDLFlBQUQsRUFBa0I7QUFDM0MsUUFBQSxhQUFhLENBQUMsS0FBZDs7QUFDQSxRQUFBLE1BQUksQ0FBQyx1QkFBTCxDQUE2QixJQUFJLENBQUMsRUFBbEMsRUFBc0M7QUFBRSxVQUFBLEtBQUssRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQWxCLFNBQXRDOztBQUNBLFFBQUEsT0FBTyxhQUFXLFlBQVgsa0JBQVA7QUFDRCxPQUpEOztBQU1BLE1BQUEsTUFBSSxDQUFDLE9BQUwsQ0FBYSxJQUFJLENBQUMsRUFBbEIsRUFBc0IsVUFBQyxRQUFELEVBQWM7QUFDbEMsWUFBSSxRQUFKLEVBQWM7QUFDWjtBQUNBLFVBQUEsYUFBYSxDQUFDLEtBQWQ7QUFDQSxVQUFBLE1BQU0sQ0FBQyxLQUFQO0FBQ0QsU0FKRCxNQUlPO0FBQ0w7QUFDQSxVQUFBLGFBQWEsQ0FBQyxLQUFkO0FBQ0EsVUFBQSxhQUFhLEdBQUcsTUFBSSxDQUFDLFFBQUwsQ0FBYyxHQUFkLENBQWtCLFlBQU07QUFDdEMsWUFBQSxNQUFNLENBQUMsS0FBUDtBQUNBLG1CQUFPLFlBQU0sQ0FBRSxDQUFmO0FBQ0QsV0FIZSxDQUFoQjtBQUlEO0FBQ0YsT0FiRDs7QUFlQSxNQUFBLE1BQUksQ0FBQyxVQUFMLENBQWdCLElBQUksQ0FBQyxFQUFyQixFQUF5QixZQUFNO0FBQzdCLFFBQUEsYUFBYSxDQUFDLEtBQWQ7QUFDQSxRQUFBLE1BQU0sQ0FBQyxLQUFQO0FBQ0QsT0FIRDs7QUFLQSxNQUFBLE1BQUksQ0FBQyxXQUFMLENBQWlCLElBQUksQ0FBQyxFQUF0QixFQUEwQixZQUFNO0FBQzlCLFFBQUEsYUFBYSxDQUFDLEtBQWQ7O0FBQ0EsUUFBQSxNQUFJLENBQUMsdUJBQUwsQ0FBNkIsSUFBSSxDQUFDLEVBQWxDLEVBQXNDO0FBQUUsVUFBQSxLQUFLLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUFsQixTQUF0Qzs7QUFDQSxRQUFBLE9BQU8sYUFBVyxJQUFJLENBQUMsRUFBaEIsbUJBQVA7QUFDRCxPQUpEOztBQU1BLE1BQUEsTUFBSSxDQUFDLFdBQUwsQ0FBaUIsSUFBSSxDQUFDLEVBQXRCLEVBQTBCLFlBQU07QUFDOUIsUUFBQSxhQUFhLENBQUMsS0FBZDs7QUFDQSxZQUFJLElBQUksQ0FBQyxLQUFULEVBQWdCO0FBQ2QsVUFBQSxNQUFNLENBQUMsS0FBUDtBQUNEOztBQUNELFFBQUEsYUFBYSxHQUFHLE1BQUksQ0FBQyxRQUFMLENBQWMsR0FBZCxDQUFrQixZQUFNO0FBQ3RDLFVBQUEsTUFBTSxDQUFDLEtBQVA7QUFDQSxpQkFBTyxZQUFNLENBQUUsQ0FBZjtBQUNELFNBSGUsQ0FBaEI7QUFJRCxPQVREO0FBVUQsS0FqTE0sRUFpTEosS0FqTEksQ0FpTEUsVUFBQyxHQUFELEVBQVM7QUFDaEIsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxjQUFmLEVBQStCLElBQS9CLEVBQXFDLEdBQXJDOztBQUNBLFlBQU0sR0FBTjtBQUNELEtBcExNLENBQVA7QUFxTEQ7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuVEE7O0FBQUEsU0FvVEUsWUFwVEYsR0FvVEUsc0JBQWMsSUFBZCxFQUFvQixPQUFwQixFQUE2QixLQUE3QixFQUFvQztBQUFBOztBQUNsQyxTQUFLLHVCQUFMLENBQTZCLElBQUksQ0FBQyxFQUFsQzs7QUFFQSxRQUFNLElBQUksZ0JBQVEsS0FBSyxJQUFiLENBQVY7O0FBQ0EsUUFBSSxJQUFJLENBQUMsR0FBVCxFQUFjO0FBQ1o7QUFDQSxlQUFjLElBQWQsRUFBb0IsSUFBSSxDQUFDLEdBQXpCO0FBQ0Q7O0FBRUQsU0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGdCQUFmLEVBQWlDLElBQWpDO0FBQ0EsU0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLElBQUksQ0FBQyxNQUFMLENBQVksR0FBMUI7O0FBRUEsUUFBSSxJQUFJLENBQUMsV0FBVCxFQUFzQjtBQUNwQixhQUFPLEtBQUsscUJBQUwsQ0FBMkIsSUFBM0IsQ0FBUDtBQUNEOztBQUVELFdBQU8sSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxVQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTCxDQUFZLGVBQVosQ0FBNEIsUUFBNUIsR0FBdUMsUUFBdkMsR0FBa0QsYUFBakU7QUFDQSxVQUFNLE1BQU0sR0FBRyxJQUFJLE1BQUosQ0FBVyxNQUFJLENBQUMsSUFBaEIsRUFBc0IsSUFBSSxDQUFDLE1BQUwsQ0FBWSxlQUFsQyxDQUFmLENBRnNDLENBSXRDOztBQUNBLE1BQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxJQUFJLENBQUMsTUFBTCxDQUFZLEdBQXhCLGVBQ0ssSUFBSSxDQUFDLE1BQUwsQ0FBWSxJQURqQjtBQUVFLFFBQUEsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUZqQjtBQUdFLFFBQUEsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUhsQjtBQUlFLFFBQUEsUUFBUSxFQUFFLEtBSlo7QUFLRSxRQUFBLElBQUksRUFBRSxJQUFJLENBQUMsSUFBTCxDQUFVLElBTGxCO0FBTUUsUUFBQSxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BTmhCO0FBT0UsUUFBQSxRQUFRLEVBQUUsSUFBSSxDQUFDO0FBUGpCLFVBUUcsSUFSSCxDQVFRLFVBQUMsR0FBRCxFQUFTO0FBQ2YsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLFlBQVYsQ0FBdUIsSUFBSSxDQUFDLEVBQTVCLEVBQWdDO0FBQUUsVUFBQSxXQUFXLEVBQUUsR0FBRyxDQUFDO0FBQW5CLFNBQWhDOztBQUNBLFFBQUEsSUFBSSxHQUFHLE1BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFrQixJQUFJLENBQUMsRUFBdkIsQ0FBUDtBQUNBLGVBQU8sTUFBSSxDQUFDLHFCQUFMLENBQTJCLElBQTNCLENBQVA7QUFDRCxPQVpELEVBWUcsSUFaSCxDQVlRLFlBQU07QUFDWixRQUFBLE9BQU87QUFDUixPQWRELEVBY0csS0FkSCxDQWNTLFVBQUMsR0FBRCxFQUFTO0FBQ2hCLFFBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsY0FBZixFQUErQixJQUEvQixFQUFxQyxHQUFyQzs7QUFDQSxRQUFBLE1BQU0sQ0FBQyxHQUFELENBQU47QUFDRCxPQWpCRDtBQWtCRCxLQXZCTSxDQUFQO0FBd0JEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwV0E7O0FBQUEsU0FxV0UscUJBcldGLEdBcVdFLCtCQUF1QixJQUF2QixFQUE2QjtBQUFBOztBQUMzQixXQUFPLElBQUksT0FBSixDQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7QUFDdEMsVUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQW5CO0FBQ0EsVUFBTSxJQUFJLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFMLENBQVksWUFBYixDQUExQjtBQUNBLFVBQU0sTUFBTSxHQUFHLElBQUksTUFBSixDQUFXO0FBQUUsUUFBQSxNQUFNLEVBQUssSUFBTCxhQUFpQixLQUF6QjtBQUFrQyxRQUFBLFFBQVEsRUFBRTtBQUE1QyxPQUFYLENBQWY7QUFDQSxNQUFBLE1BQUksQ0FBQyxlQUFMLENBQXFCLElBQUksQ0FBQyxFQUExQixJQUFnQyxNQUFoQztBQUNBLE1BQUEsTUFBSSxDQUFDLGNBQUwsQ0FBb0IsSUFBSSxDQUFDLEVBQXpCLElBQStCLElBQUksWUFBSixDQUFpQixNQUFJLENBQUMsSUFBdEIsQ0FBL0I7O0FBRUEsTUFBQSxNQUFJLENBQUMsWUFBTCxDQUFrQixJQUFJLENBQUMsRUFBdkIsRUFBMkIsWUFBTTtBQUMvQixRQUFBLGFBQWEsQ0FBQyxLQUFkLEdBRCtCLENBRS9CO0FBQ0E7O0FBQ0EsUUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLE9BQVosRUFBcUIsRUFBckI7QUFDQSxRQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksUUFBWixFQUFzQixFQUF0Qjs7QUFDQSxRQUFBLE1BQUksQ0FBQyx1QkFBTCxDQUE2QixJQUFJLENBQUMsRUFBbEM7O0FBQ0EsUUFBQSxPQUFPLGFBQVcsSUFBSSxDQUFDLEVBQWhCLGtCQUFQO0FBQ0QsT0FSRDs7QUFVQSxNQUFBLE1BQUksQ0FBQyxPQUFMLENBQWEsSUFBSSxDQUFDLEVBQWxCLEVBQXNCLFVBQUMsUUFBRCxFQUFjO0FBQ2xDLFlBQUksUUFBSixFQUFjO0FBQ1o7QUFDQSxVQUFBLGFBQWEsQ0FBQyxLQUFkO0FBQ0EsVUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLE9BQVosRUFBcUIsRUFBckI7QUFDRCxTQUpELE1BSU87QUFDTDtBQUNBLFVBQUEsYUFBYSxDQUFDLEtBQWQ7QUFDQSxVQUFBLGFBQWEsR0FBRyxNQUFJLENBQUMsUUFBTCxDQUFjLEdBQWQsQ0FBa0IsWUFBTTtBQUN0QyxZQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksUUFBWixFQUFzQixFQUF0QjtBQUNBLG1CQUFPLFlBQU0sQ0FBRSxDQUFmO0FBQ0QsV0FIZSxDQUFoQjtBQUlEO0FBQ0YsT0FiRDs7QUFlQSxNQUFBLE1BQUksQ0FBQyxVQUFMLENBQWdCLElBQUksQ0FBQyxFQUFyQixFQUF5QixZQUFNO0FBQzdCLFFBQUEsYUFBYSxDQUFDLEtBQWQ7QUFDQSxRQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksT0FBWixFQUFxQixFQUFyQjtBQUNELE9BSEQ7O0FBS0EsTUFBQSxNQUFJLENBQUMsV0FBTCxDQUFpQixJQUFJLENBQUMsRUFBdEIsRUFBMEIsWUFBTTtBQUM5QixRQUFBLGFBQWEsQ0FBQyxLQUFkLEdBRDhCLENBRTlCO0FBQ0E7O0FBQ0EsUUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLE9BQVosRUFBcUIsRUFBckI7QUFDQSxRQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksUUFBWixFQUFzQixFQUF0Qjs7QUFDQSxRQUFBLE1BQUksQ0FBQyx1QkFBTCxDQUE2QixJQUFJLENBQUMsRUFBbEM7O0FBQ0EsUUFBQSxPQUFPLGFBQVcsSUFBSSxDQUFDLEVBQWhCLG1CQUFQO0FBQ0QsT0FSRDs7QUFVQSxNQUFBLE1BQUksQ0FBQyxXQUFMLENBQWlCLElBQUksQ0FBQyxFQUF0QixFQUEwQixZQUFNO0FBQzlCLFFBQUEsYUFBYSxDQUFDLEtBQWQ7O0FBQ0EsWUFBSSxJQUFJLENBQUMsS0FBVCxFQUFnQjtBQUNkLFVBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxPQUFaLEVBQXFCLEVBQXJCO0FBQ0Q7O0FBQ0QsUUFBQSxhQUFhLEdBQUcsTUFBSSxDQUFDLFFBQUwsQ0FBYyxHQUFkLENBQWtCLFlBQU07QUFDdEMsVUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLFFBQVosRUFBc0IsRUFBdEI7QUFDQSxpQkFBTyxZQUFNLENBQUUsQ0FBZjtBQUNELFNBSGUsQ0FBaEI7QUFJRCxPQVREOztBQVdBLE1BQUEsTUFBSSxDQUFDLE9BQUwsQ0FBYSxJQUFJLENBQUMsRUFBbEIsRUFBc0IsWUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUksTUFBTSxDQUFDLE1BQVgsRUFBbUI7QUFDakIsVUFBQSxNQUFNLENBQUMsSUFBUCxDQUFZLE9BQVosRUFBcUIsRUFBckI7QUFDQSxVQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksUUFBWixFQUFzQixFQUF0QjtBQUNEO0FBQ0YsT0FURDs7QUFXQSxNQUFBLE1BQUksQ0FBQyxVQUFMLENBQWdCLElBQUksQ0FBQyxFQUFyQixFQUF5QixZQUFNO0FBQzdCO0FBQ0EsWUFBSSxNQUFNLENBQUMsTUFBWCxFQUFtQjtBQUNqQixVQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksT0FBWixFQUFxQixFQUFyQjtBQUNBLFVBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxRQUFaLEVBQXNCLEVBQXRCO0FBQ0Q7QUFDRixPQU5EOztBQVFBLE1BQUEsTUFBTSxDQUFDLEVBQVAsQ0FBVSxVQUFWLEVBQXNCLFVBQUMsWUFBRDtBQUFBLGVBQWtCLGtCQUFrQixDQUFDLE1BQUQsRUFBTyxZQUFQLEVBQXFCLElBQXJCLENBQXBDO0FBQUEsT0FBdEI7QUFFQSxNQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUsT0FBVixFQUFtQixVQUFDLE9BQUQsRUFBYTtBQUM5QixZQUFRLE9BQVIsR0FBb0IsT0FBTyxDQUFDLEtBQTVCLENBQVEsT0FBUjs7QUFDQSxZQUFNLEtBQUssR0FBRyxTQUFjLElBQUksS0FBSixDQUFVLE9BQVYsQ0FBZCxFQUFrQztBQUFFLFVBQUEsS0FBSyxFQUFFLE9BQU8sQ0FBQztBQUFqQixTQUFsQyxDQUFkLENBRjhCLENBSTlCO0FBQ0E7OztBQUNBLFlBQUksQ0FBQyxNQUFJLENBQUMsSUFBTCxDQUFVLGtCQUFmLEVBQW1DO0FBQ2pDLFVBQUEsTUFBSSxDQUFDLHVCQUFMLENBQTZCLElBQUksQ0FBQyxFQUFsQyxFQURpQyxDQUVqQzs7O0FBQ0EsVUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLFlBQVYsQ0FBdUIsSUFBSSxDQUFDLEVBQTVCLEVBQWdDO0FBQzlCLFlBQUEsV0FBVyxFQUFFO0FBRGlCLFdBQWhDO0FBR0QsU0FORCxNQU1PO0FBQ0wsVUFBQSxNQUFNLENBQUMsS0FBUDtBQUNEOztBQUVELFFBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsY0FBZixFQUErQixJQUEvQixFQUFxQyxLQUFyQzs7QUFDQSxRQUFBLGFBQWEsQ0FBQyxJQUFkO0FBQ0EsUUFBQSxNQUFNLENBQUMsS0FBRCxDQUFOO0FBQ0QsT0FuQkQ7QUFxQkEsTUFBQSxNQUFNLENBQUMsRUFBUCxDQUFVLFNBQVYsRUFBcUIsVUFBQyxJQUFELEVBQVU7QUFDN0IsWUFBTSxVQUFVLEdBQUc7QUFDakIsVUFBQSxTQUFTLEVBQUUsSUFBSSxDQUFDO0FBREMsU0FBbkI7O0FBSUEsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxnQkFBZixFQUFpQyxJQUFqQyxFQUF1QyxVQUF2Qzs7QUFDQSxRQUFBLE1BQUksQ0FBQyx1QkFBTCxDQUE2QixJQUFJLENBQUMsRUFBbEM7O0FBQ0EsUUFBQSxhQUFhLENBQUMsSUFBZDtBQUVBLFFBQUEsT0FBTztBQUNSLE9BVkQ7O0FBWUEsVUFBSSxhQUFhLEdBQUcsTUFBSSxDQUFDLFFBQUwsQ0FBYyxHQUFkLENBQWtCLFlBQU07QUFDMUMsUUFBQSxNQUFNLENBQUMsSUFBUDs7QUFDQSxZQUFJLElBQUksQ0FBQyxRQUFULEVBQW1CO0FBQ2pCLFVBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxPQUFaLEVBQXFCLEVBQXJCO0FBQ0QsU0FKeUMsQ0FNMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxlQUFPLFlBQU0sQ0FBRSxDQUFmO0FBQ0QsT0FibUIsQ0FBcEI7QUFjRCxLQTlITSxDQUFQO0FBK0hEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE3ZUE7O0FBQUEsU0E4ZUUsa0JBOWVGLEdBOGVFLDRCQUFvQixJQUFwQixFQUEwQixTQUExQixFQUFxQztBQUNuQyxRQUFNLFdBQVcsR0FBRyxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWtCLElBQUksQ0FBQyxFQUF2QixDQUFwQjtBQUNBLFFBQUksQ0FBQyxXQUFMLEVBQWtCLE9BRmlCLENBR25DOztBQUNBLFFBQUksQ0FBQyxXQUFXLENBQUMsR0FBYixJQUFvQixXQUFXLENBQUMsR0FBWixDQUFnQixTQUFoQixLQUE4QixTQUF0RCxFQUFpRTtBQUMvRCxXQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsMEJBQWQ7QUFDQSxXQUFLLElBQUwsQ0FBVSxZQUFWLENBQXVCLFdBQVcsQ0FBQyxFQUFuQyxFQUF1QztBQUNyQyxRQUFBLEdBQUcsZUFBTyxXQUFXLENBQUMsR0FBbkI7QUFBd0IsVUFBQSxTQUFTLEVBQUU7QUFBbkM7QUFEa0MsT0FBdkM7QUFHRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUE3ZkE7O0FBQUEsU0E4ZkUsWUE5ZkYsR0E4ZkUsc0JBQWMsTUFBZCxFQUFzQixFQUF0QixFQUEwQjtBQUN4QixTQUFLLGNBQUwsQ0FBb0IsTUFBcEIsRUFBNEIsRUFBNUIsQ0FBK0IsY0FBL0IsRUFBK0MsVUFBQyxJQUFELEVBQVU7QUFDdkQsVUFBSSxNQUFNLEtBQUssSUFBSSxDQUFDLEVBQXBCLEVBQXdCLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBTixDQUFGO0FBQ3pCLEtBRkQ7QUFHRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBdmdCQTs7QUFBQSxTQXdnQkUsT0F4Z0JGLEdBd2dCRSxpQkFBUyxNQUFULEVBQWlCLEVBQWpCLEVBQXFCO0FBQ25CLFNBQUssY0FBTCxDQUFvQixNQUFwQixFQUE0QixFQUE1QixDQUErQixjQUEvQixFQUErQyxVQUFDLFlBQUQsRUFBZSxRQUFmLEVBQTRCO0FBQ3pFLFVBQUksTUFBTSxLQUFLLFlBQWYsRUFBNkI7QUFDM0I7QUFDQSxRQUFBLEVBQUUsQ0FBQyxRQUFELENBQUY7QUFDRDtBQUNGLEtBTEQ7QUFNRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBcGhCQTs7QUFBQSxTQXFoQkUsT0FyaEJGLEdBcWhCRSxpQkFBUyxNQUFULEVBQWlCLEVBQWpCLEVBQXFCO0FBQ25CLFNBQUssY0FBTCxDQUFvQixNQUFwQixFQUE0QixFQUE1QixDQUErQixjQUEvQixFQUErQyxVQUFDLFlBQUQsRUFBa0I7QUFDL0QsVUFBSSxNQUFNLEtBQUssWUFBZixFQUE2QjtBQUMzQixRQUFBLEVBQUU7QUFDSDtBQUNGLEtBSkQ7QUFLRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBaGlCQTs7QUFBQSxTQWlpQkUsVUFqaUJGLEdBaWlCRSxvQkFBWSxNQUFaLEVBQW9CLEVBQXBCLEVBQXdCO0FBQUE7O0FBQ3RCLFNBQUssY0FBTCxDQUFvQixNQUFwQixFQUE0QixFQUE1QixDQUErQixXQUEvQixFQUE0QyxVQUFDLFlBQUQsRUFBa0I7QUFDNUQsVUFBSSxDQUFDLE1BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFrQixNQUFsQixDQUFMLEVBQWdDO0FBQ2hDLE1BQUEsRUFBRTtBQUNILEtBSEQ7QUFJRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBM2lCQTs7QUFBQSxTQTRpQkUsVUE1aUJGLEdBNGlCRSxvQkFBWSxNQUFaLEVBQW9CLEVBQXBCLEVBQXdCO0FBQUE7O0FBQ3RCLFNBQUssY0FBTCxDQUFvQixNQUFwQixFQUE0QixFQUE1QixDQUErQixXQUEvQixFQUE0QyxZQUFNO0FBQ2hELFVBQUksQ0FBQyxNQUFJLENBQUMsSUFBTCxDQUFVLE9BQVYsQ0FBa0IsTUFBbEIsQ0FBTCxFQUFnQztBQUNoQyxNQUFBLEVBQUU7QUFDSCxLQUhEO0FBSUQ7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQXRqQkE7O0FBQUEsU0F1akJFLFdBdmpCRixHQXVqQkUscUJBQWEsTUFBYixFQUFxQixFQUFyQixFQUF5QjtBQUFBOztBQUN2QixTQUFLLGNBQUwsQ0FBb0IsTUFBcEIsRUFBNEIsRUFBNUIsQ0FBK0IsWUFBL0IsRUFBNkMsWUFBTTtBQUNqRCxVQUFJLENBQUMsTUFBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLENBQWtCLE1BQWxCLENBQUwsRUFBZ0M7QUFDaEMsTUFBQSxFQUFFO0FBQ0gsS0FIRDtBQUlEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFqa0JBOztBQUFBLFNBa2tCRSxXQWxrQkYsR0Fra0JFLHFCQUFhLE1BQWIsRUFBcUIsRUFBckIsRUFBeUI7QUFBQTs7QUFDdkIsU0FBSyxjQUFMLENBQW9CLE1BQXBCLEVBQTRCLEVBQTVCLENBQStCLFlBQS9CLEVBQTZDLFlBQU07QUFDakQsVUFBSSxDQUFDLE1BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFrQixNQUFsQixDQUFMLEVBQWdDO0FBQ2hDLE1BQUEsRUFBRTtBQUNILEtBSEQ7QUFJRDtBQUVEO0FBQ0Y7QUFDQTtBQTNrQkE7O0FBQUEsU0E0a0JFLFdBNWtCRixHQTRrQkUscUJBQWEsS0FBYixFQUFvQjtBQUFBOztBQUNsQixRQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsR0FBTixDQUFVLFVBQUMsSUFBRCxFQUFPLENBQVAsRUFBYTtBQUN0QyxVQUFNLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBcEI7QUFDQSxVQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBcEI7O0FBRUEsVUFBSSxXQUFXLElBQVgsSUFBbUIsSUFBSSxDQUFDLEtBQTVCLEVBQW1DO0FBQ2pDLGVBQU8sT0FBTyxDQUFDLE1BQVIsQ0FBZSxJQUFJLEtBQUosQ0FBVSxJQUFJLENBQUMsS0FBZixDQUFmLENBQVA7QUFDRDs7QUFBQyxVQUFJLElBQUksQ0FBQyxRQUFULEVBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFlBQUksQ0FBQyxJQUFJLENBQUMsUUFBTCxDQUFjLGFBQWYsSUFBZ0MsQ0FBQyxJQUFJLENBQUMsVUFBMUMsRUFBc0Q7QUFDcEQsVUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBZSxnQkFBZixFQUFpQyxJQUFqQztBQUNEOztBQUNELGVBQU8sTUFBSSxDQUFDLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0IsT0FBeEIsRUFBaUMsS0FBakMsQ0FBUDtBQUNELE9BZHFDLENBZXRDOzs7QUFDQSxVQUFJLENBQUMsSUFBSSxDQUFDLFFBQUwsQ0FBYyxhQUFmLElBQWdDLENBQUMsSUFBSSxDQUFDLFVBQTFDLEVBQXNEO0FBQ3BELFFBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsZ0JBQWYsRUFBaUMsSUFBakM7QUFDRDs7QUFDRCxhQUFPLE1BQUksQ0FBQyxNQUFMLENBQVksSUFBWixFQUFrQixPQUFsQixFQUEyQixLQUEzQixDQUFQO0FBQ0QsS0FwQmdCLENBQWpCO0FBc0JBLFdBQU8sTUFBTSxDQUFDLFFBQUQsQ0FBYjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBeG1CQTs7QUFBQSxTQXltQkUsWUF6bUJGLEdBeW1CRSxzQkFBYyxPQUFkLEVBQXVCO0FBQUE7O0FBQ3JCLFFBQUksT0FBTyxDQUFDLE1BQVIsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsV0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLDBCQUFkO0FBQ0EsYUFBTyxPQUFPLENBQUMsT0FBUixFQUFQO0FBQ0Q7O0FBRUQsUUFBSSxLQUFLLElBQUwsQ0FBVSxLQUFWLEtBQW9CLENBQXhCLEVBQTJCO0FBQ3pCLFdBQUssSUFBTCxDQUFVLEdBQVYsQ0FDRSxxT0FERixFQUVFLFNBRkY7QUFJRDs7QUFFRCxTQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsb0JBQWQ7QUFDQSxRQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsR0FBUixDQUFZLFVBQUMsTUFBRDtBQUFBLGFBQVksT0FBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLENBQWtCLE1BQWxCLENBQVo7QUFBQSxLQUFaLENBQXRCO0FBRUEsV0FBTyxLQUFLLFdBQUwsQ0FBaUIsYUFBakIsRUFDSixJQURJLENBQ0M7QUFBQSxhQUFNLElBQU47QUFBQSxLQURELENBQVA7QUFFRCxHQTNuQkg7O0FBQUEsU0E2bkJFLE9BN25CRixHQTZuQkUsbUJBQVc7QUFDVCxTQUFLLElBQUwsQ0FBVSxRQUFWLENBQW1CO0FBQ2pCLE1BQUEsWUFBWSxlQUFPLEtBQUssSUFBTCxDQUFVLFFBQVYsR0FBcUIsWUFBNUI7QUFBMEMsUUFBQSxnQkFBZ0IsRUFBRTtBQUE1RDtBQURLLEtBQW5CO0FBR0EsU0FBSyxJQUFMLENBQVUsV0FBVixDQUFzQixLQUFLLFlBQTNCO0FBRUEsU0FBSyxJQUFMLENBQVUsRUFBVixDQUFhLGdCQUFiLEVBQStCLEtBQUssbUJBQXBDOztBQUVBLFFBQUksS0FBSyxJQUFMLENBQVUsU0FBZCxFQUF5QjtBQUN2QixXQUFLLElBQUwsQ0FBVSxFQUFWLENBQWEsYUFBYixFQUE0QixLQUFLLElBQUwsQ0FBVSxRQUF0QztBQUNEO0FBQ0YsR0F4b0JIOztBQUFBLFNBMG9CRSxTQTFvQkYsR0Ewb0JFLHFCQUFhO0FBQ1gsU0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQjtBQUNqQixNQUFBLFlBQVksZUFBTyxLQUFLLElBQUwsQ0FBVSxRQUFWLEdBQXFCLFlBQTVCO0FBQTBDLFFBQUEsZ0JBQWdCLEVBQUU7QUFBNUQ7QUFESyxLQUFuQjtBQUdBLFNBQUssSUFBTCxDQUFVLGNBQVYsQ0FBeUIsS0FBSyxZQUE5Qjs7QUFFQSxRQUFJLEtBQUssSUFBTCxDQUFVLFNBQWQsRUFBeUI7QUFDdkIsV0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLGFBQWQsRUFBNkIsS0FBSyxJQUFMLENBQVUsUUFBdkM7QUFDRDtBQUNGLEdBbnBCSDs7QUFBQTtBQUFBLEVBQW1DLE1BQW5DLFVBQ1MsT0FEVCxHQUNtQixPQUFPLENBQUMsaUJBQUQsQ0FBUCxDQUEyQixPQUQ5Qzs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hDQSxlQUF5QixPQUFPLENBQUMsUUFBRCxDQUFoQztBQUFBLElBQVEsQ0FBUixZQUFRLENBQVI7QUFBQSxJQUFXLFNBQVgsWUFBVyxTQUFYOztJQUVNLEs7OztBQUNKLGlCQUFhLEtBQWIsRUFBb0I7QUFBQTs7QUFDbEIsa0NBQU0sS0FBTjtBQUNBLFVBQUssY0FBTCxHQUFzQixNQUFLLGNBQUwsQ0FBb0IsSUFBcEIsK0JBQXRCO0FBQ0EsVUFBSyxXQUFMLEdBQW1CLE1BQUssV0FBTCxDQUFpQixJQUFqQiwrQkFBbkI7QUFIa0I7QUFJbkI7Ozs7U0FFRCxpQixHQUFBLDZCQUFxQjtBQUNuQixTQUFLLEtBQUwsQ0FBVyxLQUFYLEdBQW1CLEVBQW5CO0FBQ0QsRzs7U0FFRCxjLEdBQUEsd0JBQWdCLEVBQWhCLEVBQW9CO0FBQ2xCLFFBQUksRUFBRSxDQUFDLE9BQUgsS0FBZSxFQUFuQixFQUF1QjtBQUNyQixXQUFLLEtBQUwsQ0FBVyxPQUFYLENBQW1CLEtBQUssS0FBTCxDQUFXLEtBQTlCO0FBQ0Q7QUFDRixHOztTQUVELFcsR0FBQSx1QkFBZTtBQUNiLFNBQUssS0FBTCxDQUFXLE9BQVgsQ0FBbUIsS0FBSyxLQUFMLENBQVcsS0FBOUI7QUFDRCxHOztTQUVELE0sR0FBQSxrQkFBVTtBQUFBOztBQUNSLFdBQ0U7QUFBSyxNQUFBLFNBQVMsRUFBQztBQUFmLE9BQ0U7QUFDRSxNQUFBLFNBQVMsRUFBQyw4Q0FEWjtBQUVFLE1BQUEsSUFBSSxFQUFDLE1BRlA7QUFHRSxvQkFBWSxLQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLGtCQUFoQixDQUhkO0FBSUUsTUFBQSxXQUFXLEVBQUUsS0FBSyxLQUFMLENBQVcsSUFBWCxDQUFnQixrQkFBaEIsQ0FKZjtBQUtFLE1BQUEsT0FBTyxFQUFFLEtBQUssY0FMaEI7QUFNRSxNQUFBLEdBQUcsRUFBRSxhQUFDLEtBQUQsRUFBVztBQUFFLFFBQUEsTUFBSSxDQUFDLEtBQUwsR0FBYSxLQUFiO0FBQW9CLE9BTnhDO0FBT0U7QUFQRixNQURGLEVBVUU7QUFDRSxNQUFBLFNBQVMsRUFBQyxrRUFEWjtBQUVFLE1BQUEsSUFBSSxFQUFDLFFBRlA7QUFHRSxNQUFBLE9BQU8sRUFBRSxLQUFLO0FBSGhCLE9BS0csS0FBSyxLQUFMLENBQVcsSUFBWCxDQUFnQixRQUFoQixDQUxILENBVkYsQ0FERjtBQW9CRCxHOzs7RUExQ2lCLFM7O0FBNkNwQixNQUFNLENBQUMsT0FBUCxHQUFpQixLQUFqQjs7Ozs7Ozs7Ozs7OztBQy9DQSxlQUFtQixPQUFPLENBQUMsWUFBRCxDQUExQjtBQUFBLElBQVEsTUFBUixZQUFRLE1BQVI7O0FBQ0EsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLDRCQUFELENBQTFCOztBQUNBLGdCQUFjLE9BQU8sQ0FBQyxRQUFELENBQXJCO0FBQUEsSUFBUSxDQUFSLGFBQVEsQ0FBUjs7QUFDQSxnQkFBMEIsT0FBTyxDQUFDLHdCQUFELENBQWpDO0FBQUEsSUFBUSxhQUFSLGFBQVEsYUFBUjs7QUFDQSxJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsWUFBRCxDQUFyQjs7QUFDQSxJQUFNLHlCQUF5QixHQUFHLE9BQU8sQ0FBQyxtQ0FBRCxDQUF6Qzs7QUFFQSxTQUFTLE9BQVQsR0FBb0I7QUFDbEIsU0FDRTtBQUFLLG1CQUFZLE1BQWpCO0FBQXdCLElBQUEsU0FBUyxFQUFDLE9BQWxDO0FBQTBDLElBQUEsS0FBSyxFQUFDLElBQWhEO0FBQXFELElBQUEsTUFBTSxFQUFDLElBQTVEO0FBQWlFLElBQUEsT0FBTyxFQUFDO0FBQXpFLEtBQ0U7QUFBRyxJQUFBLElBQUksRUFBQyxNQUFSO0FBQWUsSUFBQSxRQUFRLEVBQUM7QUFBeEIsS0FDRTtBQUFNLElBQUEsU0FBUyxFQUFDLHFCQUFoQjtBQUFzQyxJQUFBLElBQUksRUFBQyxTQUEzQztBQUFxRCxJQUFBLEtBQUssRUFBQyxJQUEzRDtBQUFnRSxJQUFBLE1BQU0sRUFBQyxJQUF2RTtBQUE0RSxJQUFBLEVBQUUsRUFBQztBQUEvRSxJQURGLEVBRUU7QUFBTSxJQUFBLENBQUMsRUFBQyw4MkJBQVI7QUFBdTNCLElBQUEsSUFBSSxFQUFDLE1BQTUzQjtBQUFtNEIsSUFBQSxRQUFRLEVBQUM7QUFBNTRCLElBRkYsQ0FERixDQURGO0FBUUQ7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTSxDQUFDLE9BQVA7QUFBQTs7QUFHRSxlQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUI7QUFBQTs7QUFDdkIsK0JBQU0sSUFBTixFQUFZLElBQVo7QUFDQSxVQUFLLEVBQUwsR0FBVSxNQUFLLElBQUwsQ0FBVSxFQUFWLElBQWdCLEtBQTFCO0FBQ0EsVUFBSyxLQUFMLEdBQWEsTUFBSyxJQUFMLENBQVUsS0FBVixJQUFtQixNQUFoQztBQUNBLFVBQUssSUFBTCxHQUFZLFVBQVo7O0FBQ0EsVUFBSyxJQUFMLEdBQVk7QUFBQSxhQUFNLEVBQUMsT0FBRCxPQUFOO0FBQUEsS0FBWixDQUx1QixDQU92Qjs7O0FBQ0EsVUFBSyxhQUFMLEdBQXFCO0FBQ25CLE1BQUEsT0FBTyxFQUFFO0FBQ1AsUUFBQSxNQUFNLEVBQUUsUUFERDtBQUVQLFFBQUEsZ0JBQWdCLEVBQUUsNEJBRlg7QUFHUCxRQUFBLGFBQWEsRUFBRSxtRUFIUjtBQUlQLFFBQUEsZUFBZSxFQUFFO0FBSlY7QUFEVSxLQUFyQjtBQVNBLFFBQU0sY0FBYyxHQUFHLEVBQXZCO0FBRUEsVUFBSyxJQUFMLGdCQUFpQixjQUFqQixFQUFvQyxJQUFwQzs7QUFFQSxVQUFLLFFBQUw7O0FBRUEsVUFBSyxRQUFMLEdBQWdCLE1BQUssSUFBTCxDQUFVLFlBQTFCOztBQUVBLFFBQUksQ0FBQyxNQUFLLFFBQVYsRUFBb0I7QUFDbEIsWUFBTSxJQUFJLEtBQUosQ0FBVSwrRUFBVixDQUFOO0FBQ0QsS0EzQnNCLENBNkJ2Qjs7O0FBQ0EsVUFBSyxPQUFMLEdBQWUsTUFBSyxPQUFMLENBQWEsSUFBYiwrQkFBZjtBQUNBLFVBQUssT0FBTCxHQUFlLE1BQUssT0FBTCxDQUFhLElBQWIsK0JBQWY7QUFDQSxVQUFLLGNBQUwsR0FBc0IsTUFBSyxjQUFMLENBQW9CLElBQXBCLCtCQUF0QjtBQUNBLFVBQUssZUFBTCxHQUF1QixNQUFLLGVBQUwsQ0FBcUIsSUFBckIsK0JBQXZCO0FBRUEsVUFBSyxNQUFMLEdBQWMsSUFBSSxhQUFKLENBQWtCLElBQWxCLEVBQXdCO0FBQ3BDLE1BQUEsWUFBWSxFQUFFLE1BQUssSUFBTCxDQUFVLFlBRFk7QUFFcEMsTUFBQSxnQkFBZ0IsRUFBRSxNQUFLLElBQUwsQ0FBVSxnQkFBVixJQUE4QixNQUFLLElBQUwsQ0FBVSxhQUZ0QjtBQUdwQyxNQUFBLG9CQUFvQixFQUFFLE1BQUssSUFBTCxDQUFVO0FBSEksS0FBeEIsQ0FBZDtBQW5DdUI7QUF3Q3hCOztBQTNDSDs7QUFBQSxTQTZDRSxVQTdDRixHQTZDRSxvQkFBWSxPQUFaLEVBQXFCO0FBQ25CLHNCQUFNLFVBQU4sWUFBaUIsT0FBakI7O0FBQ0EsU0FBSyxRQUFMO0FBQ0QsR0FoREg7O0FBQUEsU0FrREUsUUFsREYsR0FrREUsb0JBQVk7QUFDVixTQUFLLFVBQUwsR0FBa0IsSUFBSSxVQUFKLENBQWUsQ0FBQyxLQUFLLGFBQU4sRUFBcUIsS0FBSyxJQUFMLENBQVUsTUFBL0IsRUFBdUMsS0FBSyxJQUFMLENBQVUsTUFBakQsQ0FBZixDQUFsQjtBQUNBLFNBQUssSUFBTCxHQUFZLEtBQUssVUFBTCxDQUFnQixTQUFoQixDQUEwQixJQUExQixDQUErQixLQUFLLFVBQXBDLENBQVo7QUFDQSxTQUFLLFNBQUwsR0FBaUIsS0FBSyxVQUFMLENBQWdCLGNBQWhCLENBQStCLElBQS9CLENBQW9DLEtBQUssVUFBekMsQ0FBakI7QUFDQSxTQUFLLGNBQUwsR0FKVSxDQUlZO0FBQ3ZCLEdBdkRIOztBQUFBLFNBeURFLGtCQXpERixHQXlERSw0QkFBb0IsR0FBcEIsRUFBeUI7QUFDdkIsV0FBTyxHQUFHLENBQUMsU0FBSixDQUFjLEdBQUcsQ0FBQyxXQUFKLENBQWdCLEdBQWhCLElBQXVCLENBQXJDLENBQVA7QUFDRCxHQTNESDs7QUFBQSxTQTZERSxpQkE3REYsR0E2REUsMkJBQW1CLEdBQW5CLEVBQXdCO0FBQ3RCLFFBQUksQ0FBQyxHQUFMLEVBQVUsT0FBTyxLQUFQO0FBRVYsUUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLEtBQUosQ0FBVSxtQkFBVixFQUErQixDQUEvQixDQUFqQjs7QUFDQSxRQUFJLFFBQVEsS0FBSyxNQUFiLElBQXVCLFFBQVEsS0FBSyxPQUF4QyxFQUFpRDtBQUMvQyxhQUFPLEtBQVA7QUFDRDs7QUFFRCxXQUFPLElBQVA7QUFDRCxHQXRFSDs7QUFBQSxTQXdFRSxnQkF4RUYsR0F3RUUsMEJBQWtCLEdBQWxCLEVBQXVCO0FBQ3JCLFFBQU0sYUFBYSxHQUFHLGlCQUF0QjtBQUNBLFFBQU0sZUFBZSxHQUFHLFNBQXhCOztBQUNBLFFBQUksYUFBYSxDQUFDLElBQWQsQ0FBbUIsR0FBbkIsQ0FBSixFQUE2QjtBQUMzQixhQUFPLEdBQVA7QUFDRDs7QUFFRCxXQUFPLGVBQWUsR0FBRyxHQUF6QjtBQUNELEdBaEZIOztBQUFBLFNBa0ZFLE9BbEZGLEdBa0ZFLGlCQUFTLEdBQVQsRUFBYztBQUFBOztBQUNaLFdBQU8sS0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixVQUFqQixFQUE2QjtBQUFFLE1BQUEsR0FBRyxFQUFIO0FBQUYsS0FBN0IsRUFDSixJQURJLENBQ0MsVUFBQyxHQUFELEVBQVM7QUFDYixVQUFJLEdBQUcsQ0FBQyxLQUFSLEVBQWU7QUFDYixRQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsR0FBVixDQUFjLGNBQWQ7O0FBQ0EsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYsQ0FBYyxHQUFHLENBQUMsS0FBbEI7O0FBQ0EsY0FBTSxJQUFJLEtBQUosQ0FBVSwwQkFBVixDQUFOO0FBQ0Q7O0FBQ0QsYUFBTyxHQUFQO0FBQ0QsS0FSSSxDQUFQO0FBU0QsR0E1Rkg7O0FBQUEsU0E4RkUsT0E5RkYsR0E4RkUsaUJBQVMsR0FBVCxFQUFjO0FBQUE7O0FBQ1osSUFBQSxHQUFHLEdBQUcsS0FBSyxnQkFBTCxDQUFzQixHQUF0QixDQUFOOztBQUNBLFFBQUksQ0FBQyxLQUFLLGlCQUFMLENBQXVCLEdBQXZCLENBQUwsRUFBa0M7QUFDaEMsV0FBSyxJQUFMLENBQVUsR0FBVixtQ0FBOEMsR0FBOUM7QUFDQSxXQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsS0FBSyxJQUFMLENBQVUsaUJBQVYsQ0FBZixFQUE2QyxPQUE3QyxFQUFzRCxJQUF0RDtBQUNBO0FBQ0Q7O0FBRUQsV0FBTyxLQUFLLE9BQUwsQ0FBYSxHQUFiLEVBQ0osSUFESSxDQUNDLFVBQUMsSUFBRCxFQUFVO0FBQ2QsVUFBTSxPQUFPLEdBQUc7QUFDZCxRQUFBLE1BQU0sRUFBRSxNQUFJLENBQUMsRUFEQztBQUVkLFFBQUEsSUFBSSxFQUFFLE1BQUksQ0FBQyxrQkFBTCxDQUF3QixHQUF4QixDQUZRO0FBR2QsUUFBQSxJQUFJLEVBQUUsSUFBSSxDQUFDLElBSEc7QUFJZCxRQUFBLElBQUksRUFBRTtBQUNKLFVBQUEsSUFBSSxFQUFFLElBQUksQ0FBQztBQURQLFNBSlE7QUFPZCxRQUFBLFFBQVEsRUFBRSxJQVBJO0FBUWQsUUFBQSxJQUFJLEVBQUU7QUFDSixVQUFBLEdBQUcsRUFBSDtBQURJLFNBUlE7QUFXZCxRQUFBLE1BQU0sRUFBRTtBQUNOLFVBQUEsWUFBWSxFQUFFLE1BQUksQ0FBQyxJQUFMLENBQVUsWUFEbEI7QUFFTixVQUFBLEdBQUcsRUFBSyxNQUFJLENBQUMsUUFBVixhQUZHO0FBR04sVUFBQSxJQUFJLEVBQUU7QUFDSixZQUFBLE1BQU0sRUFBRSxHQURKO0FBRUosWUFBQSxHQUFHLEVBQUg7QUFGSSxXQUhBO0FBT04sVUFBQSxlQUFlLEVBQUUsTUFBSSxDQUFDLE1BQUwsQ0FBWTtBQVB2QjtBQVhNLE9BQWhCO0FBcUJBLGFBQU8sT0FBUDtBQUNELEtBeEJJLEVBeUJKLElBekJJLENBeUJDLFVBQUMsT0FBRCxFQUFhO0FBQ2pCLE1BQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxHQUFWLENBQWMsMEJBQWQ7O0FBQ0EsVUFBSTtBQUNGLGVBQU8sTUFBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLENBQWtCLE9BQWxCLENBQVA7QUFDRCxPQUZELENBRUUsT0FBTyxHQUFQLEVBQVk7QUFDWixZQUFJLENBQUMsR0FBRyxDQUFDLGFBQVQsRUFBd0I7QUFDdEIsVUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYsQ0FBYyxHQUFkO0FBQ0Q7O0FBQ0QsZUFBTyxHQUFQO0FBQ0Q7QUFDRixLQW5DSSxFQW9DSixLQXBDSSxDQW9DRSxVQUFDLEdBQUQsRUFBUztBQUNkLE1BQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxHQUFWLENBQWMsR0FBZDs7QUFDQSxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlO0FBQ2IsUUFBQSxPQUFPLEVBQUUsTUFBSSxDQUFDLElBQUwsQ0FBVSxlQUFWLENBREk7QUFFYixRQUFBLE9BQU8sRUFBRTtBQUZJLE9BQWYsRUFHRyxPQUhILEVBR1ksSUFIWjs7QUFJQSxhQUFPLEdBQVA7QUFDRCxLQTNDSSxDQUFQO0FBNENELEdBbEpIOztBQUFBLFNBb0pFLGNBcEpGLEdBb0pFLHdCQUFnQixDQUFoQixFQUFtQjtBQUFBOztBQUNqQixJQUFBLHlCQUF5QixDQUFDLENBQUMsQ0FBQyxZQUFILEVBQWlCLE1BQWpCLEVBQXlCLFVBQUMsR0FBRCxFQUFTO0FBQ3pELE1BQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxHQUFWLDBDQUFxRCxHQUFyRDs7QUFDQSxNQUFBLE1BQUksQ0FBQyxPQUFMLENBQWEsR0FBYjtBQUNELEtBSHdCLENBQXpCO0FBSUQsR0F6Skg7O0FBQUEsU0EySkUsZUEzSkYsR0EySkUseUJBQWlCLENBQWpCLEVBQW9CO0FBQUE7O0FBQ2xCLElBQUEseUJBQXlCLENBQUMsQ0FBQyxDQUFDLGFBQUgsRUFBa0IsT0FBbEIsRUFBMkIsVUFBQyxHQUFELEVBQVM7QUFDM0QsTUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYseUNBQW9ELEdBQXBEOztBQUNBLE1BQUEsTUFBSSxDQUFDLE9BQUwsQ0FBYSxHQUFiO0FBQ0QsS0FId0IsQ0FBekI7QUFJRCxHQWhLSDs7QUFBQSxTQWtLRSxNQWxLRixHQWtLRSxnQkFBUSxLQUFSLEVBQWU7QUFDYixXQUFPLEVBQUMsS0FBRDtBQUFPLE1BQUEsSUFBSSxFQUFFLEtBQUssSUFBbEI7QUFBd0IsTUFBQSxPQUFPLEVBQUUsS0FBSztBQUF0QyxNQUFQO0FBQ0QsR0FwS0g7O0FBQUEsU0FzS0UsT0F0S0YsR0FzS0UsbUJBQVc7QUFDVCxRQUFNLE1BQU0sR0FBRyxLQUFLLElBQUwsQ0FBVSxNQUF6Qjs7QUFDQSxRQUFJLE1BQUosRUFBWTtBQUNWLFdBQUssS0FBTCxDQUFXLE1BQVgsRUFBbUIsSUFBbkI7QUFDRDtBQUNGLEdBM0tIOztBQUFBLFNBNktFLFNBN0tGLEdBNktFLHFCQUFhO0FBQ1gsU0FBSyxPQUFMO0FBQ0QsR0EvS0g7O0FBQUE7QUFBQSxFQUFtQyxNQUFuQyxVQUNTLE9BRFQsR0FDbUIsT0FBTyxDQUFDLGlCQUFELENBQVAsQ0FBMkIsT0FEOUM7OztBQ3RCQSxJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMseUJBQUQsQ0FBdkI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMseUJBQVQsQ0FBb0MsWUFBcEMsRUFBa0QsYUFBbEQsRUFBaUUsUUFBakUsRUFBMkU7QUFDMUYsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxLQUFkLENBQXJCO0FBRUEsTUFBSSxRQUFKOztBQUVBLFVBQVEsYUFBUjtBQUNFLFNBQUssT0FBTDtBQUFjO0FBQ1osWUFBTSx1QkFBdUIsR0FBRyxLQUFLLENBQUMsSUFBTixDQUFXLFVBQUMsSUFBRDtBQUFBLGlCQUFVLElBQUksQ0FBQyxJQUFMLEtBQWMsTUFBeEI7QUFBQSxTQUFYLENBQWhDOztBQUNBLFlBQUksdUJBQUosRUFBNkI7QUFDM0I7QUFDRDs7QUFDRCxRQUFBLFFBQVEsR0FBRyxLQUFLLENBQUMsTUFBTixDQUFhLFVBQUMsSUFBRDtBQUFBLGlCQUN0QixJQUFJLENBQUMsSUFBTCxLQUFjLFFBQWQsSUFDSyxJQUFJLENBQUMsSUFBTCxLQUFjLFlBRkc7QUFBQSxTQUFiLENBQVg7QUFJQTtBQUNEOztBQUNELFNBQUssTUFBTDtBQUFhO0FBQ1gsUUFBQSxRQUFRLEdBQUcsS0FBSyxDQUFDLE1BQU4sQ0FBYSxVQUFDLElBQUQ7QUFBQSxpQkFDdEIsSUFBSSxDQUFDLElBQUwsS0FBYyxRQUFkLElBQ0csSUFBSSxDQUFDLElBQUwsS0FBYyxlQUZLO0FBQUEsU0FBYixDQUFYO0FBR0E7QUFDRDs7QUFDRDtBQUFTO0FBQ1AsY0FBTSxJQUFJLEtBQUosK0RBQXNFLGFBQXRFLENBQU47QUFDRDtBQXBCSDs7QUF1QkEsRUFBQSxRQUFRLENBQUMsT0FBVCxDQUFpQixVQUFDLElBQUQsRUFBVTtBQUN6QixJQUFBLElBQUksQ0FBQyxXQUFMLENBQWlCLFVBQUMsU0FBRDtBQUFBLGFBQ2YsUUFBUSxDQUFDLFNBQUQsQ0FETztBQUFBLEtBQWpCO0FBRUQsR0FIRDtBQUlELENBaENEOzs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBQUMsT0FBUDtBQUNFLHdCQUFhLE9BQWIsRUFBc0I7QUFDcEIsU0FBSyxPQUFMLEdBQWUsRUFBZjtBQUNBLFNBQUssUUFBTCxHQUFnQixPQUFoQjtBQUNEOztBQUpIOztBQUFBLFNBTUUsRUFORixHQU1FLFlBQUksS0FBSixFQUFXLEVBQVgsRUFBZTtBQUNiLFNBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsQ0FBQyxLQUFELEVBQVEsRUFBUixDQUFsQjs7QUFDQSxXQUFPLEtBQUssUUFBTCxDQUFjLEVBQWQsQ0FBaUIsS0FBakIsRUFBd0IsRUFBeEIsQ0FBUDtBQUNELEdBVEg7O0FBQUEsU0FXRSxNQVhGLEdBV0Usa0JBQVU7QUFBQTs7QUFDUixTQUFLLE9BQUwsQ0FBYSxPQUFiLENBQXFCLGdCQUFpQjtBQUFBLFVBQWYsS0FBZTtBQUFBLFVBQVIsRUFBUTs7QUFDcEMsTUFBQSxLQUFJLENBQUMsUUFBTCxDQUFjLEdBQWQsQ0FBa0IsS0FBbEIsRUFBeUIsRUFBekI7QUFDRCxLQUZEO0FBR0QsR0FmSDs7QUFBQTtBQUFBOzs7QUNKQSxNQUFNLENBQUMsT0FBUCxHQUFpQixDQUNmLDhEQURlLEVBRWYsaUVBRmUsRUFHZix1REFIZSxFQUlmLHdEQUplLEVBS2YsMERBTGUsRUFNZix3REFOZSxFQU9mLDZEQVBlLEVBUWYsNkRBUmUsRUFTZiw0REFUZSxFQVVmLHdFQVZlLEVBV2YsaUVBWGUsQ0FBakI7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDQU0sWTs7O0FBQ0osd0JBQWEsS0FBYixFQUFvQixHQUFwQixFQUFnQztBQUFBOztBQUFBLFFBQVosR0FBWTtBQUFaLE1BQUEsR0FBWSxHQUFOLElBQU07QUFBQTs7QUFDOUIsMkpBQWlJLEtBQWpJO0FBRUEsVUFBSyxjQUFMLEdBQXNCLElBQXRCO0FBQ0EsVUFBSyxPQUFMLEdBQWUsR0FBZjtBQUo4QjtBQUsvQjs7O2lDQU53QixLOztBQVMzQixNQUFNLENBQUMsT0FBUCxHQUFpQixZQUFqQjs7O0FDVEEsSUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLGFBQUQsQ0FBekI7O0FBRUEsU0FBUyxpQkFBVCxHQUE4QjtBQUM1QixTQUFPLElBQUksS0FBSixDQUFVLFdBQVYsQ0FBUDtBQUNEOztBQUVELE1BQU0sQ0FBQyxPQUFQO0FBQ0UsNEJBQWEsS0FBYixFQUFvQjtBQUNsQixRQUFJLE9BQU8sS0FBUCxLQUFpQixRQUFqQixJQUE2QixLQUFLLEtBQUssQ0FBM0MsRUFBOEM7QUFDNUMsV0FBSyxLQUFMLEdBQWEsUUFBYjtBQUNELEtBRkQsTUFFTztBQUNMLFdBQUssS0FBTCxHQUFhLEtBQWI7QUFDRDs7QUFFRCxTQUFLLGNBQUwsR0FBc0IsQ0FBdEI7QUFDQSxTQUFLLGNBQUwsR0FBc0IsRUFBdEI7QUFDRDs7QUFWSDs7QUFBQSxTQVlFLEtBWkYsR0FZRSxlQUFPLEVBQVAsRUFBVztBQUFBOztBQUNULFNBQUssY0FBTCxJQUF1QixDQUF2QjtBQUVBLFFBQUksS0FBSSxHQUFHLEtBQVg7QUFFQSxRQUFJLFlBQUo7O0FBQ0EsUUFBSTtBQUNGLE1BQUEsWUFBWSxHQUFHLEVBQUUsRUFBakI7QUFDRCxLQUZELENBRUUsT0FBTyxHQUFQLEVBQVk7QUFDWixXQUFLLGNBQUwsSUFBdUIsQ0FBdkI7QUFDQSxZQUFNLEdBQU47QUFDRDs7QUFFRCxXQUFPO0FBQ0wsTUFBQSxLQUFLLEVBQUUsaUJBQU07QUFDWCxZQUFJLEtBQUosRUFBVTtBQUNWLFFBQUEsS0FBSSxHQUFHLElBQVA7QUFDQSxRQUFBLEtBQUksQ0FBQyxjQUFMLElBQXVCLENBQXZCO0FBQ0EsUUFBQSxZQUFZOztBQUNaLFFBQUEsS0FBSSxDQUFDLFVBQUw7QUFDRCxPQVBJO0FBU0wsTUFBQSxJQUFJLEVBQUUsZ0JBQU07QUFDVixZQUFJLEtBQUosRUFBVTtBQUNWLFFBQUEsS0FBSSxHQUFHLElBQVA7QUFDQSxRQUFBLEtBQUksQ0FBQyxjQUFMLElBQXVCLENBQXZCOztBQUNBLFFBQUEsS0FBSSxDQUFDLFVBQUw7QUFDRDtBQWRJLEtBQVA7QUFnQkQsR0F6Q0g7O0FBQUEsU0EyQ0UsVUEzQ0YsR0EyQ0Usc0JBQWM7QUFBQTs7QUFDWjtBQUNBO0FBQ0E7QUFDQSxJQUFBLE9BQU8sQ0FBQyxPQUFSLEdBQWtCLElBQWxCLENBQXVCLFlBQU07QUFDM0IsTUFBQSxNQUFJLENBQUMsS0FBTDtBQUNELEtBRkQ7QUFHRCxHQWxESDs7QUFBQSxTQW9ERSxLQXBERixHQW9ERSxpQkFBUztBQUNQLFFBQUksS0FBSyxjQUFMLElBQXVCLEtBQUssS0FBaEMsRUFBdUM7QUFDckM7QUFDRDs7QUFDRCxRQUFJLEtBQUssY0FBTCxDQUFvQixNQUFwQixLQUErQixDQUFuQyxFQUFzQztBQUNwQztBQUNELEtBTk0sQ0FRUDtBQUNBO0FBQ0E7OztBQUNBLFFBQU0sSUFBSSxHQUFHLEtBQUssY0FBTCxDQUFvQixLQUFwQixFQUFiOztBQUNBLFFBQU0sT0FBTyxHQUFHLEtBQUssS0FBTCxDQUFXLElBQUksQ0FBQyxFQUFoQixDQUFoQjs7QUFDQSxJQUFBLElBQUksQ0FBQyxLQUFMLEdBQWEsT0FBTyxDQUFDLEtBQXJCO0FBQ0EsSUFBQSxJQUFJLENBQUMsSUFBTCxHQUFZLE9BQU8sQ0FBQyxJQUFwQjtBQUNELEdBbkVIOztBQUFBLFNBcUVFLE1BckVGLEdBcUVFLGdCQUFRLEVBQVIsRUFBWSxPQUFaLEVBQTBCO0FBQUE7O0FBQUEsUUFBZCxPQUFjO0FBQWQsTUFBQSxPQUFjLEdBQUosRUFBSTtBQUFBOztBQUN4QixRQUFNLE9BQU8sR0FBRztBQUNkLE1BQUEsRUFBRSxFQUFGLEVBRGM7QUFFZCxNQUFBLFFBQVEsRUFBRSxPQUFPLENBQUMsUUFBUixJQUFvQixDQUZoQjtBQUdkLE1BQUEsS0FBSyxFQUFFLGlCQUFNO0FBQ1gsUUFBQSxNQUFJLENBQUMsUUFBTCxDQUFjLE9BQWQ7QUFDRCxPQUxhO0FBTWQsTUFBQSxJQUFJLEVBQUUsZ0JBQU07QUFDVixjQUFNLElBQUksS0FBSixDQUFVLDREQUFWLENBQU47QUFDRDtBQVJhLEtBQWhCO0FBV0EsUUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLEtBQUssY0FBTixFQUFzQixVQUFDLEtBQUQsRUFBVztBQUN0RCxhQUFPLE9BQU8sQ0FBQyxRQUFSLEdBQW1CLEtBQUssQ0FBQyxRQUFoQztBQUNELEtBRnNCLENBQXZCOztBQUdBLFFBQUksS0FBSyxLQUFLLENBQUMsQ0FBZixFQUFrQjtBQUNoQixXQUFLLGNBQUwsQ0FBb0IsSUFBcEIsQ0FBeUIsT0FBekI7QUFDRCxLQUZELE1BRU87QUFDTCxXQUFLLGNBQUwsQ0FBb0IsTUFBcEIsQ0FBMkIsS0FBM0IsRUFBa0MsQ0FBbEMsRUFBcUMsT0FBckM7QUFDRDs7QUFDRCxXQUFPLE9BQVA7QUFDRCxHQTFGSDs7QUFBQSxTQTRGRSxRQTVGRixHQTRGRSxrQkFBVSxPQUFWLEVBQW1CO0FBQ2pCLFFBQU0sS0FBSyxHQUFHLEtBQUssY0FBTCxDQUFvQixPQUFwQixDQUE0QixPQUE1QixDQUFkOztBQUNBLFFBQUksS0FBSyxLQUFLLENBQUMsQ0FBZixFQUFrQjtBQUNoQixXQUFLLGNBQUwsQ0FBb0IsTUFBcEIsQ0FBMkIsS0FBM0IsRUFBa0MsQ0FBbEM7QUFDRDtBQUNGLEdBakdIOztBQUFBLFNBbUdFLEdBbkdGLEdBbUdFLGFBQUssRUFBTCxFQUFTLFlBQVQsRUFBdUI7QUFDckIsUUFBSSxLQUFLLGNBQUwsR0FBc0IsS0FBSyxLQUEvQixFQUFzQztBQUNwQyxhQUFPLEtBQUssS0FBTCxDQUFXLEVBQVgsQ0FBUDtBQUNEOztBQUNELFdBQU8sS0FBSyxNQUFMLENBQVksRUFBWixFQUFnQixZQUFoQixDQUFQO0FBQ0QsR0F4R0g7O0FBQUEsU0EwR0UsbUJBMUdGLEdBMEdFLDZCQUFxQixFQUFyQixFQUF5QixZQUF6QixFQUF1QztBQUFBOztBQUNyQyxXQUFPLFlBQWE7QUFBQSx3Q0FBVCxJQUFTO0FBQVQsUUFBQSxJQUFTO0FBQUE7O0FBQ2xCLFVBQUksYUFBSjtBQUNBLFVBQU0sWUFBWSxHQUFHLElBQUksT0FBSixDQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7QUFDcEQsUUFBQSxhQUFhLEdBQUcsTUFBSSxDQUFDLEdBQUwsQ0FBUyxZQUFNO0FBQzdCLGNBQUksV0FBSjtBQUNBLGNBQUksWUFBSjs7QUFDQSxjQUFJO0FBQ0YsWUFBQSxZQUFZLEdBQUcsT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsRUFBRSxNQUFGLFNBQU0sSUFBTixDQUFoQixDQUFmO0FBQ0QsV0FGRCxDQUVFLE9BQU8sR0FBUCxFQUFZO0FBQ1osWUFBQSxZQUFZLEdBQUcsT0FBTyxDQUFDLE1BQVIsQ0FBZSxHQUFmLENBQWY7QUFDRDs7QUFFRCxVQUFBLFlBQVksQ0FBQyxJQUFiLENBQWtCLFVBQUMsTUFBRCxFQUFZO0FBQzVCLGdCQUFJLFdBQUosRUFBaUI7QUFDZixjQUFBLE1BQU0sQ0FBQyxXQUFELENBQU47QUFDRCxhQUZELE1BRU87QUFDTCxjQUFBLGFBQWEsQ0FBQyxJQUFkO0FBQ0EsY0FBQSxPQUFPLENBQUMsTUFBRCxDQUFQO0FBQ0Q7QUFDRixXQVBELEVBT0csVUFBQyxHQUFELEVBQVM7QUFDVixnQkFBSSxXQUFKLEVBQWlCO0FBQ2YsY0FBQSxNQUFNLENBQUMsV0FBRCxDQUFOO0FBQ0QsYUFGRCxNQUVPO0FBQ0wsY0FBQSxhQUFhLENBQUMsSUFBZDtBQUNBLGNBQUEsTUFBTSxDQUFDLEdBQUQsQ0FBTjtBQUNEO0FBQ0YsV0FkRDtBQWdCQSxpQkFBTyxZQUFNO0FBQ1gsWUFBQSxXQUFXLEdBQUcsaUJBQWlCLEVBQS9CO0FBQ0QsV0FGRDtBQUdELFNBNUJlLEVBNEJiLFlBNUJhLENBQWhCO0FBNkJELE9BOUJvQixDQUFyQjs7QUFnQ0EsTUFBQSxZQUFZLENBQUMsS0FBYixHQUFxQixZQUFNO0FBQ3pCLFFBQUEsYUFBYSxDQUFDLEtBQWQ7QUFDRCxPQUZEOztBQUlBLGFBQU8sWUFBUDtBQUNELEtBdkNEO0FBd0NELEdBbkpIOztBQUFBO0FBQUE7Ozs7O0FDTkEsSUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLGVBQUQsQ0FBbkI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNLENBQUMsT0FBUDtBQUNFO0FBQ0Y7QUFDQTtBQUNFLHNCQUFhLE9BQWIsRUFBc0I7QUFBQTs7QUFDcEIsU0FBSyxNQUFMLEdBQWM7QUFDWixNQUFBLE9BQU8sRUFBRSxFQURHO0FBRVosTUFBQSxTQUZZLHFCQUVELENBRkMsRUFFRTtBQUNaLFlBQUksQ0FBQyxLQUFLLENBQVYsRUFBYTtBQUNYLGlCQUFPLENBQVA7QUFDRDs7QUFDRCxlQUFPLENBQVA7QUFDRDtBQVBXLEtBQWQ7O0FBVUEsUUFBSSxLQUFLLENBQUMsT0FBTixDQUFjLE9BQWQsQ0FBSixFQUE0QjtBQUMxQixNQUFBLE9BQU8sQ0FBQyxPQUFSLENBQWdCLFVBQUMsTUFBRDtBQUFBLGVBQVksS0FBSSxDQUFDLE1BQUwsQ0FBWSxNQUFaLENBQVo7QUFBQSxPQUFoQjtBQUNELEtBRkQsTUFFTztBQUNMLFdBQUssTUFBTCxDQUFZLE9BQVo7QUFDRDtBQUNGOztBQXBCSDs7QUFBQSxTQXNCRSxNQXRCRixHQXNCRSxnQkFBUSxNQUFSLEVBQWdCO0FBQ2QsUUFBSSxDQUFDLE1BQUQsSUFBVyxDQUFDLE1BQU0sQ0FBQyxPQUF2QixFQUFnQztBQUM5QjtBQUNEOztBQUVELFFBQU0sVUFBVSxHQUFHLEtBQUssTUFBeEI7QUFDQSxTQUFLLE1BQUwsZ0JBQW1CLFVBQW5CO0FBQStCLE1BQUEsT0FBTyxlQUFPLFVBQVUsQ0FBQyxPQUFsQixFQUE4QixNQUFNLENBQUMsT0FBckM7QUFBdEM7QUFDQSxTQUFLLE1BQUwsQ0FBWSxTQUFaLEdBQXdCLE1BQU0sQ0FBQyxTQUFQLElBQW9CLFVBQVUsQ0FBQyxTQUF2RDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFDQTs7QUFBQSxTQTJDRSxXQTNDRixHQTJDRSxxQkFBYSxNQUFiLEVBQXFCLE9BQXJCLEVBQThCO0FBQzVCLDRCQUEyQixNQUFNLENBQUMsU0FBbEM7QUFBQSxRQUFRLEtBQVIscUJBQVEsS0FBUjtBQUFBLFFBQWUsT0FBZixxQkFBZSxPQUFmO0FBQ0EsUUFBTSxXQUFXLEdBQUcsS0FBcEI7QUFDQSxRQUFNLGVBQWUsR0FBRyxNQUF4QjtBQUNBLFFBQUksWUFBWSxHQUFHLENBQUMsTUFBRCxDQUFuQjs7QUFFQSxTQUFLLElBQU0sR0FBWCxJQUFrQixPQUFsQixFQUEyQjtBQUN6QixVQUFJLEdBQUcsS0FBSyxHQUFSLElBQWUsR0FBRyxDQUFDLE9BQUQsRUFBVSxHQUFWLENBQXRCLEVBQXNDO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFlBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxHQUFELENBQXpCOztBQUNBLFlBQUksT0FBTyxXQUFQLEtBQXVCLFFBQTNCLEVBQXFDO0FBQ25DLFVBQUEsV0FBVyxHQUFHLE9BQU8sQ0FBQyxJQUFSLENBQWEsT0FBTyxDQUFDLEdBQUQsQ0FBcEIsRUFBMkIsV0FBM0IsRUFBd0MsZUFBeEMsQ0FBZDtBQUNELFNBUG1DLENBUXBDO0FBQ0E7QUFDQTs7O0FBQ0EsUUFBQSxZQUFZLEdBQUcsaUJBQWlCLENBQUMsWUFBRCxFQUFlLElBQUksTUFBSixVQUFrQixHQUFsQixVQUE0QixHQUE1QixDQUFmLEVBQWlELFdBQWpELENBQWhDO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPLFlBQVA7O0FBRUEsYUFBUyxpQkFBVCxDQUE0QixNQUE1QixFQUFvQyxFQUFwQyxFQUF3QyxXQUF4QyxFQUFxRDtBQUNuRCxVQUFNLFFBQVEsR0FBRyxFQUFqQjtBQUNBLE1BQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxVQUFDLEtBQUQsRUFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUksT0FBTyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLGlCQUFPLFFBQVEsQ0FBQyxJQUFULENBQWMsS0FBZCxDQUFQO0FBQ0Q7O0FBRUQsUUFBQSxLQUFLLENBQUMsSUFBTixDQUFXLEtBQVgsRUFBa0IsRUFBbEIsRUFBc0IsT0FBdEIsQ0FBOEIsVUFBQyxHQUFELEVBQU0sQ0FBTixFQUFTLElBQVQsRUFBa0I7QUFDOUMsY0FBSSxHQUFHLEtBQUssRUFBWixFQUFnQjtBQUNkLFlBQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxHQUFkO0FBQ0QsV0FINkMsQ0FLOUM7OztBQUNBLGNBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFMLEdBQWMsQ0FBdEIsRUFBeUI7QUFDdkIsWUFBQSxRQUFRLENBQUMsSUFBVCxDQUFjLFdBQWQ7QUFDRDtBQUNGLFNBVEQ7QUFVRCxPQW5CRDtBQW9CQSxhQUFPLFFBQVA7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuR0E7O0FBQUEsU0FvR0UsU0FwR0YsR0FvR0UsbUJBQVcsR0FBWCxFQUFnQixPQUFoQixFQUF5QjtBQUN2QixXQUFPLEtBQUssY0FBTCxDQUFvQixHQUFwQixFQUF5QixPQUF6QixFQUFrQyxJQUFsQyxDQUF1QyxFQUF2QyxDQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlHQTs7QUFBQSxTQStHRSxjQS9HRixHQStHRSx3QkFBZ0IsR0FBaEIsRUFBcUIsT0FBckIsRUFBOEI7QUFDNUIsUUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLE1BQUwsQ0FBWSxPQUFiLEVBQXNCLEdBQXRCLENBQVIsRUFBb0M7QUFDbEMsWUFBTSxJQUFJLEtBQUosc0JBQTZCLEdBQTdCLENBQU47QUFDRDs7QUFFRCxRQUFNLE1BQU0sR0FBRyxLQUFLLE1BQUwsQ0FBWSxPQUFaLENBQW9CLEdBQXBCLENBQWY7QUFDQSxRQUFNLGNBQWMsR0FBRyxPQUFPLE1BQVAsS0FBa0IsUUFBekM7O0FBRUEsUUFBSSxjQUFKLEVBQW9CO0FBQ2xCLFVBQUksT0FBTyxJQUFJLE9BQU8sT0FBTyxDQUFDLFdBQWYsS0FBK0IsV0FBOUMsRUFBMkQ7QUFDekQsWUFBTSxNQUFNLEdBQUcsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixPQUFPLENBQUMsV0FBOUIsQ0FBZjtBQUNBLGVBQU8sS0FBSyxXQUFMLENBQWlCLE1BQU0sQ0FBQyxNQUFELENBQXZCLEVBQWlDLE9BQWpDLENBQVA7QUFDRDs7QUFDRCxZQUFNLElBQUksS0FBSixDQUFVLHdGQUFWLENBQU47QUFDRDs7QUFFRCxXQUFPLEtBQUssV0FBTCxDQUFpQixNQUFqQixFQUF5QixPQUF6QixDQUFQO0FBQ0QsR0FoSUg7O0FBQUE7QUFBQTs7O0FDYkEsSUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLGlCQUFELENBQTdCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLFlBQVQsQ0FBdUIsTUFBdkIsRUFBK0IsSUFBL0IsRUFBcUMsT0FBckMsRUFBOEM7QUFDN0QsTUFBSSxNQUFNLENBQUMsTUFBWCxFQUFtQjtBQUNqQixXQUFPLElBQUksT0FBSixDQUFZLFVBQUMsT0FBRCxFQUFhO0FBQzlCLE1BQUEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxPQUFkLEVBQXVCLElBQXZCLEVBQTZCLE9BQTdCO0FBQ0QsS0FGTSxDQUFQO0FBR0Q7O0FBQ0QsU0FBTyxPQUFPLENBQUMsT0FBUixHQUFrQixJQUFsQixDQUF1QixZQUFNO0FBQ2xDLFdBQU8sYUFBYSxDQUFDLE1BQU0sQ0FBQyxTQUFQLENBQWlCLElBQWpCLEVBQXVCLE9BQXZCLENBQUQsRUFBa0MsRUFBbEMsQ0FBcEI7QUFDRCxHQUZNLENBQVA7QUFHRCxDQVREOzs7QUNSQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLGFBQVQsQ0FBd0IsT0FBeEIsRUFBaUMsSUFBakMsRUFBdUMsTUFBdkMsRUFBK0M7QUFDOUQ7QUFDQSxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsS0FBUixDQUFjLEdBQWQsRUFBbUIsQ0FBbkIsQ0FBYixDQUY4RCxDQUk5RDs7QUFDQSxNQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBTCxJQUFpQixPQUFPLENBQUMsS0FBUixDQUFjLEdBQWQsRUFBbUIsQ0FBbkIsRUFBc0IsS0FBdEIsQ0FBNEIsR0FBNUIsRUFBaUMsQ0FBakMsRUFBb0MsS0FBcEMsQ0FBMEMsR0FBMUMsRUFBK0MsQ0FBL0MsQ0FBaEMsQ0FMOEQsQ0FPOUQ7O0FBQ0EsTUFBSSxRQUFRLElBQUksSUFBaEIsRUFBc0I7QUFDcEIsSUFBQSxRQUFRLEdBQUcsWUFBWDtBQUNEOztBQUVELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFELENBQW5CO0FBQ0EsTUFBTSxLQUFLLEdBQUcsRUFBZDs7QUFDQSxPQUFLLElBQUksQ0FBQyxHQUFHLENBQWIsRUFBZ0IsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUEzQixFQUFtQyxDQUFDLEVBQXBDLEVBQXdDO0FBQ3RDLElBQUEsS0FBSyxDQUFDLElBQU4sQ0FBVyxNQUFNLENBQUMsVUFBUCxDQUFrQixDQUFsQixDQUFYO0FBQ0Q7O0FBRUQsTUFBSSxLQUFKOztBQUNBLE1BQUk7QUFDRixJQUFBLEtBQUssR0FBRyxJQUFJLFVBQUosQ0FBZSxLQUFmLENBQVIsQ0FERSxDQUM0QjtBQUMvQixHQUZELENBRUUsT0FBTyxHQUFQLEVBQVk7QUFDWixXQUFPLElBQVA7QUFDRCxHQXZCNkQsQ0F5QjlEOzs7QUFDQSxNQUFJLE1BQUosRUFBWTtBQUNWLFdBQU8sSUFBSSxJQUFKLENBQVMsQ0FBQyxLQUFELENBQVQsRUFBa0IsSUFBSSxDQUFDLElBQUwsSUFBYSxFQUEvQixFQUFtQztBQUFFLE1BQUEsSUFBSSxFQUFFO0FBQVIsS0FBbkMsQ0FBUDtBQUNEOztBQUVELFNBQU8sSUFBSSxJQUFKLENBQVMsQ0FBQyxLQUFELENBQVQsRUFBa0I7QUFBRSxJQUFBLElBQUksRUFBRTtBQUFSLEdBQWxCLENBQVA7QUFDRCxDQS9CRDs7O0FDQUEsSUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLGlCQUFELENBQXhCOztBQUVBLFNBQVMsbUJBQVQsQ0FBOEIsUUFBOUIsRUFBd0MsWUFBeEMsRUFBc0QsSUFBdEQsRUFBNEQ7QUFDMUQsTUFBUSxRQUFSLEdBQWdELFlBQWhELENBQVEsUUFBUjtBQUFBLE1BQWtCLGFBQWxCLEdBQWdELFlBQWhELENBQWtCLGFBQWxCO0FBQUEsTUFBaUMsVUFBakMsR0FBZ0QsWUFBaEQsQ0FBaUMsVUFBakM7O0FBQ0EsTUFBSSxRQUFKLEVBQWM7QUFDWixJQUFBLFFBQVEsQ0FBQyxJQUFULENBQWMsR0FBZCx1QkFBc0MsUUFBdEM7QUFDQSxJQUFBLFFBQVEsQ0FBQyxJQUFULENBQWMsSUFBZCxDQUFtQixpQkFBbkIsRUFBc0MsSUFBdEMsRUFBNEM7QUFDMUMsTUFBQSxRQUFRLEVBQVIsUUFEMEM7QUFFMUMsTUFBQSxhQUFhLEVBQWIsYUFGMEM7QUFHMUMsTUFBQSxVQUFVLEVBQVY7QUFIMEMsS0FBNUM7QUFLRDtBQUNGOztBQUVELE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFFBQVEsQ0FBQyxtQkFBRCxFQUFzQixHQUF0QixFQUEyQjtBQUNsRCxFQUFBLE9BQU8sRUFBRSxJQUR5QztBQUVsRCxFQUFBLFFBQVEsRUFBRTtBQUZ3QyxDQUEzQixDQUF6Qjs7O0FDZEEsSUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLGdCQUFELENBQTVCO0FBRUE7QUFDQTtBQUNBOzs7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLHFCQUFULEdBQTRDO0FBQzNELFNBQU8sS0FBSyxNQUFMLG9CQUNKLEtBREksQ0FDRSxVQUFDLEdBQUQsRUFBUztBQUNkLFFBQUksR0FBRyxDQUFDLElBQUosS0FBYSxZQUFqQixFQUErQjtBQUM3QixZQUFNLEdBQU47QUFDRCxLQUZELE1BRU87QUFDTCxZQUFNLElBQUksWUFBSixDQUFpQixHQUFqQixDQUFOO0FBQ0Q7QUFDRixHQVBJLENBQVA7QUFRRCxDQVREOzs7QUNMQSxJQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsZ0JBQUQsQ0FBNUI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsa0JBQVQsQ0FBNkIsT0FBN0IsRUFBc0M7QUFDckQsTUFBSSxPQUFPLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0IsUUFBTSxRQUFRLEdBQUcsR0FBRyxLQUFILENBQVMsSUFBVCxDQUFjLFFBQVEsQ0FBQyxnQkFBVCxDQUEwQixPQUExQixDQUFkLENBQWpCO0FBQ0EsV0FBTyxRQUFRLENBQUMsTUFBVCxHQUFrQixDQUFsQixHQUFzQixRQUF0QixHQUFpQyxJQUF4QztBQUNEOztBQUVELE1BQUksT0FBTyxPQUFQLEtBQW1CLFFBQW5CLElBQStCLFlBQVksQ0FBQyxPQUFELENBQS9DLEVBQTBEO0FBQ3hELFdBQU8sQ0FBQyxPQUFELENBQVA7QUFDRDtBQUNGLENBVEQ7OztBQ1JBLElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxnQkFBRCxDQUE1QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxjQUFULENBQXlCLE9BQXpCLEVBQWtDLE9BQWxDLEVBQXNEO0FBQUEsTUFBcEIsT0FBb0I7QUFBcEIsSUFBQSxPQUFvQixHQUFWLFFBQVU7QUFBQTs7QUFDckUsTUFBSSxPQUFPLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0IsV0FBTyxPQUFPLENBQUMsYUFBUixDQUFzQixPQUF0QixDQUFQO0FBQ0Q7O0FBRUQsTUFBSSxZQUFZLENBQUMsT0FBRCxDQUFoQixFQUEyQjtBQUN6QixXQUFPLE9BQVA7QUFDRDtBQUNGLENBUkQ7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxTQUFULENBQW9CLEtBQXBCLEVBQTJCLFNBQTNCLEVBQXNDO0FBQ3JELE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBYixFQUFnQixDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQTFCLEVBQWtDLENBQUMsRUFBbkMsRUFBdUM7QUFDckMsUUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUQsQ0FBTixDQUFiLEVBQXlCLE9BQU8sQ0FBUDtBQUMxQjs7QUFDRCxTQUFPLENBQUMsQ0FBUjtBQUNELENBTEQ7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxjQUFULENBQXlCLElBQXpCLEVBQStCO0FBQzlDO0FBQ0E7QUFFQSxNQUFJLEVBQUUsR0FBRyxNQUFUOztBQUNBLE1BQUksT0FBTyxJQUFJLENBQUMsSUFBWixLQUFxQixRQUF6QixFQUFtQztBQUNqQyxJQUFBLEVBQUUsVUFBUSxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUwsQ0FBVSxXQUFWLEVBQUQsQ0FBeEI7QUFDRDs7QUFFRCxNQUFJLElBQUksQ0FBQyxJQUFMLEtBQWMsU0FBbEIsRUFBNkI7QUFDM0IsSUFBQSxFQUFFLFVBQVEsSUFBSSxDQUFDLElBQWY7QUFDRDs7QUFFRCxNQUFJLElBQUksQ0FBQyxJQUFMLElBQWEsT0FBTyxJQUFJLENBQUMsSUFBTCxDQUFVLFlBQWpCLEtBQWtDLFFBQW5ELEVBQTZEO0FBQzNELElBQUEsRUFBRSxVQUFRLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBTCxDQUFVLFlBQVYsQ0FBdUIsV0FBdkIsRUFBRCxDQUF4QjtBQUNEOztBQUVELE1BQUksSUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLEtBQW1CLFNBQXZCLEVBQWtDO0FBQ2hDLElBQUEsRUFBRSxVQUFRLElBQUksQ0FBQyxJQUFMLENBQVUsSUFBcEI7QUFDRDs7QUFDRCxNQUFJLElBQUksQ0FBQyxJQUFMLENBQVUsWUFBVixLQUEyQixTQUEvQixFQUEwQztBQUN4QyxJQUFBLEVBQUUsVUFBUSxJQUFJLENBQUMsSUFBTCxDQUFVLFlBQXBCO0FBQ0Q7O0FBRUQsU0FBTyxFQUFQO0FBQ0QsQ0F6QkQ7O0FBMkJBLFNBQVMsY0FBVCxDQUF5QixJQUF6QixFQUErQjtBQUM3QixNQUFJLE1BQU0sR0FBRyxFQUFiO0FBQ0EsU0FBTyxJQUFJLENBQUMsT0FBTCxDQUFhLGFBQWIsRUFBNEIsVUFBQyxTQUFELEVBQWU7QUFDaEQsSUFBQSxNQUFNLFVBQVEsZUFBZSxDQUFDLFNBQUQsQ0FBN0I7QUFDQSxXQUFPLEdBQVA7QUFDRCxHQUhNLElBR0YsTUFITDtBQUlEOztBQUVELFNBQVMsZUFBVCxDQUEwQixTQUExQixFQUFxQztBQUNuQyxTQUFPLFNBQVMsQ0FBQyxVQUFWLENBQXFCLENBQXJCLEVBQXdCLFFBQXhCLENBQWlDLEVBQWpDLENBQVA7QUFDRDs7O0FDNUNELE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsaUJBQVQsQ0FBNEIsWUFBNUIsRUFBMEM7QUFDekQsU0FBTyxZQUFZLENBQUMsVUFBYixHQUEwQixZQUFZLENBQUMsYUFBOUM7QUFDRCxDQUZEOzs7QUNBQSxJQUFNLG1CQUFtQixHQUFHLE9BQU8sQ0FBQyxtQ0FBRCxDQUFuQzs7QUFDQSxJQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMscUJBQUQsQ0FBM0I7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsZUFBVCxDQUEwQixZQUExQixTQUEwRTtBQUFBLGdDQUFKLEVBQUk7QUFBQSwrQkFBaEMsWUFBZ0M7QUFBQSxNQUFoQyxZQUFnQyxrQ0FBakIsWUFBTSxDQUFFLENBQVM7O0FBQ3pGO0FBQ0EsTUFBSSxZQUFZLENBQUMsS0FBYixJQUFzQixZQUFZLENBQUMsS0FBYixDQUFtQixDQUFuQixDQUF0QixJQUErQyxzQkFBc0IsWUFBWSxDQUFDLEtBQWIsQ0FBbUIsQ0FBbkIsQ0FBekUsRUFBZ0c7QUFDOUYsV0FBTyxtQkFBbUIsQ0FBQyxZQUFELEVBQWUsWUFBZixDQUExQixDQUQ4RixDQUVoRztBQUNDOztBQUNELFNBQU8sV0FBVyxDQUFDLFlBQUQsQ0FBbEI7QUFDRCxDQVBEOzs7QUNaQSxJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsZUFBRCxDQUF2QixDLENBRUE7OztBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsV0FBVCxDQUFzQixZQUF0QixFQUFvQztBQUNuRCxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLEtBQWQsQ0FBckI7QUFDQSxTQUFPLE9BQU8sQ0FBQyxPQUFSLENBQWdCLEtBQWhCLENBQVA7QUFDRCxDQUhEOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxtQ0FBVCxDQUE4QyxlQUE5QyxFQUErRCxVQUEvRCxFQUEyRSxZQUEzRSxRQUF3RztBQUFBLE1BQWIsU0FBYSxRQUFiLFNBQWE7QUFDdkgsRUFBQSxlQUFlLENBQUMsV0FBaEIsQ0FDRSxVQUFDLE9BQUQsRUFBYTtBQUNYLFFBQU0sVUFBVSxhQUFPLFVBQVAsRUFBc0IsT0FBdEIsQ0FBaEIsQ0FEVyxDQUVYOztBQUNBLFFBQUksT0FBTyxDQUFDLE1BQVosRUFBb0I7QUFDbEIsTUFBQSxVQUFVLENBQUMsWUFBTTtBQUNmLFFBQUEsbUNBQW1DLENBQUMsZUFBRCxFQUFrQixVQUFsQixFQUE4QixZQUE5QixFQUE0QztBQUFFLFVBQUEsU0FBUyxFQUFUO0FBQUYsU0FBNUMsQ0FBbkM7QUFDRCxPQUZTLEVBRVAsQ0FGTyxDQUFWLENBRGtCLENBSXBCO0FBQ0MsS0FMRCxNQUtPO0FBQ0wsTUFBQSxTQUFTLENBQUMsVUFBRCxDQUFUO0FBQ0Q7QUFDRixHQVpILEVBYUU7QUFDQSxZQUFDLEtBQUQsRUFBVztBQUNULElBQUEsWUFBWSxDQUFDLEtBQUQsQ0FBWjtBQUNBLElBQUEsU0FBUyxDQUFDLFVBQUQsQ0FBVDtBQUNELEdBakJIO0FBbUJELENBcEJEOzs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsZUFBVCxDQUEwQixTQUExQixFQUFxQztBQUNwRDtBQUNBO0FBQ0EsTUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFYLElBQXVCLFNBQVMsQ0FBQyxRQUFWLFdBQTJCLFNBQVMsQ0FBQyxJQUFoRSxFQUF3RTtBQUN0RSxXQUFPLElBQVA7QUFDRDs7QUFDRCxTQUFPLFNBQVMsQ0FBQyxRQUFqQjtBQUNELENBUEQ7OztBQ1BBLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxrQkFBRCxDQUF2Qjs7QUFDQSxJQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsbUJBQUQsQ0FBL0I7O0FBQ0EsSUFBTSxtQ0FBbUMsR0FBRyxPQUFPLENBQUMsdUNBQUQsQ0FBbkQ7O0FBRUEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxtQkFBVCxDQUE4QixZQUE5QixFQUE0QyxZQUE1QyxFQUEwRDtBQUN6RSxNQUFNLEtBQUssR0FBRyxFQUFkO0FBRUEsTUFBTSxZQUFZLEdBQUcsRUFBckI7QUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0UsTUFBTSxzQ0FBc0MsR0FBRyxTQUF6QyxzQ0FBeUMsQ0FBQyxLQUFEO0FBQUEsV0FDN0MsSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQWE7QUFDdkI7QUFDQSxVQUFJLEtBQUssQ0FBQyxNQUFWLEVBQWtCO0FBQ2hCO0FBQ0EsUUFBQSxLQUFLLENBQUMsSUFBTixDQUNFLFVBQUMsSUFBRCxFQUFVO0FBQ1IsVUFBQSxJQUFJLENBQUMsWUFBTCxHQUFvQixlQUFlLENBQUMsS0FBRCxDQUFuQztBQUNBLFVBQUEsS0FBSyxDQUFDLElBQU4sQ0FBVyxJQUFYO0FBQ0EsVUFBQSxPQUFPO0FBQ1IsU0FMSCxFQU1FO0FBQ0Esa0JBQUMsS0FBRCxFQUFXO0FBQ1QsVUFBQSxZQUFZLENBQUMsS0FBRCxDQUFaO0FBQ0EsVUFBQSxPQUFPO0FBQ1IsU0FWSCxFQUZnQixDQWNsQjtBQUNDLE9BZkQsTUFlTyxJQUFJLEtBQUssQ0FBQyxXQUFWLEVBQXVCO0FBQzVCLFlBQU0sZUFBZSxHQUFHLEtBQUssQ0FBQyxZQUFOLEVBQXhCO0FBQ0EsUUFBQSxtQ0FBbUMsQ0FBQyxlQUFELEVBQWtCLEVBQWxCLEVBQXNCLFlBQXRCLEVBQW9DO0FBQ3JFLFVBQUEsU0FBUyxFQUFFLG1CQUFDLE9BQUQsRUFBYTtBQUN0QixnQkFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLEdBQVIsQ0FBWSxVQUFDLEtBQUQ7QUFBQSxxQkFBVyxzQ0FBc0MsQ0FBQyxLQUFELENBQWpEO0FBQUEsYUFBWixDQUFqQjtBQUNBLFlBQUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxRQUFaLEVBQXNCLElBQXRCLENBQTJCO0FBQUEscUJBQU0sT0FBTyxFQUFiO0FBQUEsYUFBM0I7QUFDRDtBQUpvRSxTQUFwQyxDQUFuQztBQU1EO0FBQ0YsS0ExQkQsQ0FENkM7QUFBQSxHQUEvQyxDQVh5RSxDQXdDekU7OztBQUNBLEVBQUEsT0FBTyxDQUFDLFlBQVksQ0FBQyxLQUFkLENBQVAsQ0FDRyxPQURILENBQ1csVUFBQyxJQUFELEVBQVU7QUFDakIsUUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGdCQUFMLEVBQWQsQ0FEaUIsQ0FFakI7O0FBQ0EsUUFBSSxLQUFKLEVBQVc7QUFDVCxNQUFBLFlBQVksQ0FBQyxJQUFiLENBQWtCLHNDQUFzQyxDQUFDLEtBQUQsQ0FBeEQ7QUFDRDtBQUNGLEdBUEg7QUFTQSxTQUFPLE9BQU8sQ0FBQyxHQUFSLENBQVksWUFBWixFQUNKLElBREksQ0FDQztBQUFBLFdBQU0sS0FBTjtBQUFBLEdBREQsQ0FBUDtBQUVELENBcEREOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLHVCQUFULENBQWtDLFlBQWxDLEVBQWdEO0FBQy9ELE1BQU0sT0FBTyxHQUFHLFlBQVksQ0FBQyxXQUFiLENBQXlCLEdBQXpCLENBQWhCLENBRCtELENBRS9EOztBQUNBLE1BQUksT0FBTyxLQUFLLENBQUMsQ0FBYixJQUFrQixPQUFPLEtBQUssWUFBWSxDQUFDLE1BQWIsR0FBc0IsQ0FBeEQsRUFBMkQ7QUFDekQsV0FBTztBQUNMLE1BQUEsSUFBSSxFQUFFLFlBREQ7QUFFTCxNQUFBLFNBQVMsRUFBRTtBQUZOLEtBQVA7QUFJRDs7QUFDRCxTQUFPO0FBQ0wsSUFBQSxJQUFJLEVBQUUsWUFBWSxDQUFDLEtBQWIsQ0FBbUIsQ0FBbkIsRUFBc0IsT0FBdEIsQ0FERDtBQUVMLElBQUEsU0FBUyxFQUFFLFlBQVksQ0FBQyxLQUFiLENBQW1CLE9BQU8sR0FBRyxDQUE3QjtBQUZOLEdBQVA7QUFJRCxDQWJEOzs7QUNOQSxJQUFNLHVCQUF1QixHQUFHLE9BQU8sQ0FBQywyQkFBRCxDQUF2Qzs7QUFDQSxJQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsYUFBRCxDQUF6Qjs7QUFFQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLFdBQVQsQ0FBc0IsSUFBdEIsRUFBNEI7QUFDM0MsTUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLElBQUwsR0FBWSx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsSUFBTixDQUF2QixDQUFtQyxTQUEvQyxHQUEyRCxJQUEvRTtBQUNBLEVBQUEsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLENBQUMsV0FBZCxFQUFILEdBQWlDLElBQTlEOztBQUVBLE1BQUksSUFBSSxDQUFDLElBQVQsRUFBZTtBQUNiO0FBQ0EsV0FBTyxJQUFJLENBQUMsSUFBWjtBQUNEOztBQUFDLE1BQUksYUFBYSxJQUFJLFNBQVMsQ0FBQyxhQUFELENBQTlCLEVBQStDO0FBQy9DO0FBQ0EsV0FBTyxTQUFTLENBQUMsYUFBRCxDQUFoQjtBQUNELEdBVjBDLENBVzNDOzs7QUFDQSxTQUFPLDBCQUFQO0FBQ0QsQ0FiRDs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNLGdCQUFnQixHQUFHO0FBQ3ZCLGVBQWEsS0FEVTtBQUV2QixlQUFhLEtBRlU7QUFHdkIsZUFBYSxLQUhVO0FBSXZCLGdCQUFjLE1BSlM7QUFLdkIsZUFBYSxLQUxVO0FBTXZCLGdCQUFjLE1BTlM7QUFPdkIsZ0JBQWMsTUFQUztBQVF2QixnQkFBYyxLQVJTO0FBU3ZCLGVBQWEsS0FUVTtBQVV2QixtQkFBaUIsS0FWTTtBQVd2QixlQUFhLEtBWFU7QUFZdkIsZUFBYSxLQVpVO0FBYXZCLHFCQUFtQixLQWJJO0FBY3ZCLGdCQUFjLE1BZFM7QUFldkIsc0JBQW9CLEtBZkc7QUFnQnZCLHFCQUFtQjtBQWhCSSxDQUF6Qjs7QUFtQkEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxvQkFBVCxDQUErQixRQUEvQixFQUF5QztBQUN4RDtBQUNBLEVBQUEsUUFBUSxHQUFHLFFBQVEsQ0FBQyxPQUFULENBQWlCLE1BQWpCLEVBQXlCLEVBQXpCLENBQVg7QUFDQSxTQUFPLGdCQUFnQixDQUFDLFFBQUQsQ0FBaEIsSUFBOEIsSUFBckM7QUFDRCxDQUpEOzs7QUN2QkEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxhQUFULENBQXdCLEdBQXhCLEVBQTZCO0FBQzVDO0FBQ0EsTUFBSSxLQUFLLEdBQUcsd0RBQVo7QUFDQSxNQUFJLElBQUksR0FBRyxLQUFLLENBQUMsSUFBTixDQUFXLEdBQVgsRUFBZ0IsQ0FBaEIsQ0FBWDtBQUNBLE1BQUksY0FBYyxHQUFHLGNBQWMsSUFBZCxDQUFtQixHQUFuQixJQUEwQixJQUExQixHQUFpQyxLQUF0RDtBQUVBLFNBQVUsY0FBVixXQUE4QixJQUE5QjtBQUNELENBUEQ7OztBQ0FBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsUUFBVCxDQUFtQixZQUFuQixFQUFpQztBQUNoRCxNQUFJLENBQUMsWUFBWSxDQUFDLGFBQWxCLEVBQWlDLE9BQU8sQ0FBUDtBQUVqQyxNQUFNLFdBQVcsR0FBSSxJQUFJLElBQUosRUFBRCxHQUFlLFlBQVksQ0FBQyxhQUFoRDtBQUNBLE1BQU0sV0FBVyxHQUFHLFlBQVksQ0FBQyxhQUFiLElBQThCLFdBQVcsR0FBRyxJQUE1QyxDQUFwQjtBQUNBLFNBQU8sV0FBUDtBQUNELENBTkQ7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLFNBQVMsZ0JBQVQsQ0FBMkIsT0FBM0IsRUFBb0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBTyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBM0IsRUFBZ0M7QUFDOUIsSUFBQSxPQUFPLEdBQUcsT0FBTyxDQUFDLFVBQWxCO0FBQ0Q7O0FBQ0QsU0FBTyxPQUFPLEdBQUcsT0FBTyxDQUFDLEdBQVgsR0FBaUIsU0FBL0I7QUFDRDs7QUFFRCxNQUFNLENBQUMsT0FBUCxHQUFpQixnQkFBakI7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLFlBQVQsR0FBeUI7QUFDeEMsTUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFKLEVBQVg7QUFDQSxNQUFJLEtBQUssR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQUwsR0FBZ0IsUUFBaEIsRUFBRCxDQUFmO0FBQ0EsTUFBSSxPQUFPLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFMLEdBQWtCLFFBQWxCLEVBQUQsQ0FBakI7QUFDQSxNQUFJLE9BQU8sR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQUwsR0FBa0IsUUFBbEIsRUFBRCxDQUFqQjtBQUNBLFNBQVUsS0FBVixTQUFtQixPQUFuQixTQUE4QixPQUE5QjtBQUNELENBTkQ7QUFRQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMsR0FBVCxDQUFjLEdBQWQsRUFBbUI7QUFDakIsU0FBTyxHQUFHLENBQUMsTUFBSixLQUFlLENBQWYsR0FBbUIsSUFBSSxHQUF2QixHQUE2QixHQUFwQztBQUNEOzs7QUNoQkQsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxHQUFULENBQWMsTUFBZCxFQUFzQixHQUF0QixFQUEyQjtBQUMxQyxTQUFPLE1BQU0sQ0FBQyxTQUFQLENBQWlCLGNBQWpCLENBQWdDLElBQWhDLENBQXFDLE1BQXJDLEVBQTZDLEdBQTdDLENBQVA7QUFDRCxDQUZEOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxZQUFULENBQXVCLEdBQXZCLEVBQTRCO0FBQzNDLFNBQU8sR0FBRyxJQUFJLE9BQU8sR0FBUCxLQUFlLFFBQXRCLElBQWtDLEdBQUcsQ0FBQyxRQUFKLEtBQWlCLElBQUksQ0FBQyxZQUEvRDtBQUNELENBRkQ7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLG1CQUFULEdBQWdDO0FBQy9DLE1BQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFULENBQXVCLEtBQXZCLENBQVo7O0FBRUEsTUFBSSxFQUFFLGVBQWUsR0FBakIsS0FBeUIsRUFBRSxpQkFBaUIsR0FBakIsSUFBd0IsWUFBWSxHQUF0QyxDQUE3QixFQUF5RTtBQUN2RSxXQUFPLEtBQVA7QUFDRDs7QUFFRCxNQUFJLEVBQUUsY0FBYyxNQUFoQixDQUFKLEVBQTZCO0FBQzNCLFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQUksRUFBRSxnQkFBZ0IsTUFBbEIsQ0FBSixFQUErQjtBQUM3QixXQUFPLEtBQVA7QUFDRDs7QUFFRCxTQUFPLElBQVA7QUFDRCxDQWhCRDs7O0FDTEEsU0FBUyxjQUFULENBQXlCLEdBQXpCLEVBQThCO0FBQzVCLE1BQUksQ0FBQyxHQUFMLEVBQVU7QUFDUixXQUFPLEtBQVA7QUFDRDs7QUFDRCxTQUFRLEdBQUcsQ0FBQyxVQUFKLEtBQW1CLENBQW5CLElBQXdCLEdBQUcsQ0FBQyxVQUFKLEtBQW1CLENBQTVDLElBQWtELEdBQUcsQ0FBQyxNQUFKLEtBQWUsQ0FBeEU7QUFDRDs7QUFFRCxNQUFNLENBQUMsT0FBUCxHQUFpQixjQUFqQjs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxXQUFULENBQXNCLEdBQXRCLEVBQTJCO0FBQzFDLFNBQU8sR0FBRyxDQUFDLE9BQUosQ0FBWSxPQUFaLE1BQXlCLENBQWhDO0FBQ0QsQ0FGRDs7O0FDTkEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsU0FBUyxrQkFBVCxDQUE2QixRQUE3QixFQUF1QztBQUN0RCxNQUFJLENBQUMsUUFBTCxFQUFlLE9BQU8sS0FBUDtBQUNmLE1BQU0sZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLEtBQVQsQ0FBZSxHQUFmLEVBQW9CLENBQXBCLENBQXpCLENBRnNELENBR3REOztBQUNBLE1BQUksK0NBQStDLElBQS9DLENBQW9ELGdCQUFwRCxDQUFKLEVBQTJFO0FBQ3pFLFdBQU8sSUFBUDtBQUNEOztBQUNELFNBQU8sS0FBUDtBQUNELENBUkQ7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBTSxDQUFDLE9BQVAsR0FBaUI7QUFDZixFQUFBLEVBQUUsRUFBRSxlQURXO0FBRWYsRUFBQSxRQUFRLEVBQUUsZUFGSztBQUdmLEVBQUEsR0FBRyxFQUFFLFdBSFU7QUFJZixFQUFBLEdBQUcsRUFBRSxXQUpVO0FBS2YsRUFBQSxHQUFHLEVBQUUsZUFMVTtBQU1mLEVBQUEsR0FBRyxFQUFFLFlBTlU7QUFPZixFQUFBLEdBQUcsRUFBRSxXQVBVO0FBUWYsRUFBQSxHQUFHLEVBQUUsV0FSVTtBQVNmLEVBQUEsSUFBSSxFQUFFLFlBVFM7QUFVZixFQUFBLElBQUksRUFBRSxZQVZTO0FBV2YsRUFBQSxJQUFJLEVBQUUsV0FYUztBQVlmLEVBQUEsR0FBRyxFQUFFLFdBWlU7QUFhZixFQUFBLEdBQUcsRUFBRSxVQWJVO0FBY2YsRUFBQSxHQUFHLEVBQUUsMkJBZFU7QUFlZixFQUFBLEdBQUcsRUFBRSwyQkFmVTtBQWdCZixFQUFBLEdBQUcsRUFBRSxpQkFoQlU7QUFpQmYsRUFBQSxHQUFHLEVBQUUsa0JBakJVO0FBa0JmLEVBQUEsR0FBRyxFQUFFLGtCQWxCVTtBQW1CZixFQUFBLEdBQUcsRUFBRSxpQkFuQlU7QUFvQmYsRUFBQSxHQUFHLEVBQUUsb0JBcEJVO0FBcUJmLEVBQUEsSUFBSSxFQUFFLGtEQXJCUztBQXNCZixFQUFBLElBQUksRUFBRSx5RUF0QlM7QUF1QmYsRUFBQSxHQUFHLEVBQUUsb0JBdkJVO0FBd0JmLEVBQUEsSUFBSSxFQUFFLGtEQXhCUztBQXlCZixFQUFBLElBQUksRUFBRSx5RUF6QlM7QUEwQmYsRUFBQSxHQUFHLEVBQUUsMEJBMUJVO0FBMkJmLEVBQUEsSUFBSSxFQUFFLGdEQTNCUztBQTRCZixFQUFBLEdBQUcsRUFBRSwwQkE1QlU7QUE2QmYsRUFBQSxHQUFHLEVBQUUseUJBN0JVO0FBOEJmLEVBQUEsR0FBRyxFQUFFLDBCQTlCVTtBQStCZixFQUFBLEdBQUcsRUFBRSwwQkEvQlU7QUFnQ2YsRUFBQSxJQUFJLEVBQUUsdURBaENTO0FBaUNmLEVBQUEsSUFBSSxFQUFFLGdEQWpDUztBQWtDZixFQUFBLElBQUksRUFBRSxtRUFsQ1M7QUFtQ2YsRUFBQSxHQUFHLEVBQUUsMEJBbkNVO0FBb0NmLEVBQUEsSUFBSSxFQUFFLG1EQXBDUztBQXFDZixFQUFBLElBQUksRUFBRSxzRUFyQ1M7QUFzQ2YsRUFBQSxHQUFHLEVBQUUsMEJBdENVO0FBdUNmLEVBQUEsR0FBRyxFQUFFLFlBdkNVO0FBd0NmLEVBQUEsSUFBSSxFQUFFLFlBeENTO0FBeUNmLEVBQUEsSUFBSSxFQUFFLFlBekNTO0FBMENmLEVBQUEsR0FBRyxFQUFFLFlBMUNVO0FBMkNmLEVBQUEsR0FBRyxFQUFFLGlCQTNDVTtBQTRDZixFQUFBLEdBQUcsRUFBRSxpQkE1Q1U7QUE2Q2YsUUFBTSw2QkE3Q1M7QUE4Q2YsRUFBQSxHQUFHLEVBQUUsOEJBOUNVO0FBK0NmLEVBQUEsR0FBRyxFQUFFLG1CQS9DVTtBQWdEZixFQUFBLEVBQUUsRUFBRSxrQkFoRFc7QUFpRGYsRUFBQSxHQUFHLEVBQUU7QUFqRFUsQ0FBakI7OztBQ0xBLElBQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxpQkFBRCxDQUE3Qjs7QUFFQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLFNBQVQsQ0FBb0IsT0FBcEIsRUFBNkI7QUFDNUMsTUFBTSxJQUFJLEdBQUcsYUFBYSxDQUFDLE9BQUQsQ0FBMUIsQ0FENEMsQ0FHNUM7QUFDQTtBQUNBOztBQUNBLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFMLEdBQWdCLElBQUksQ0FBQyxLQUFyQixVQUFpQyxFQUFsRDtBQUNBLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFMLEdBQWEsT0FBSyxJQUFJLENBQUMsT0FBVixFQUFxQixNQUFyQixDQUE0QixDQUFDLENBQTdCLENBQWIsR0FBK0MsSUFBSSxDQUFDLE9BQXZFO0FBQ0EsTUFBTSxVQUFVLEdBQUcsVUFBVSxHQUFNLFVBQU4sU0FBc0IsRUFBbkQ7QUFDQSxNQUFNLFVBQVUsR0FBRyxVQUFVLEdBQUcsT0FBSyxJQUFJLENBQUMsT0FBVixFQUFxQixNQUFyQixDQUE0QixDQUFDLENBQTdCLENBQUgsR0FBcUMsSUFBSSxDQUFDLE9BQXZFO0FBQ0EsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUwsR0FBYSxFQUFiLEdBQW1CLFVBQVUsU0FBTyxVQUFQLFNBQTBCLFVBQTFCLE1BQWhEO0FBRUEsY0FBVSxRQUFWLEdBQXFCLFVBQXJCLEdBQWtDLFVBQWxDO0FBQ0QsQ0FiRDs7Ozs7QUNGQSxJQUFNLHVCQUF1QixHQUFHLE9BQU8sQ0FBQywyQkFBRCxDQUF2Qzs7QUFFQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLG9CQUFULENBQStCLElBQS9CLEVBQXFDO0FBQ3BELHNCQUNLLElBREw7QUFFRSxJQUFBLElBQUksRUFBRSxJQUFJLENBQUMsUUFGYjtBQUdFLElBQUEsU0FBUyxFQUFFLElBQUksQ0FBQyxJQUFMLEdBQVksdUJBQXVCLENBQUMsSUFBSSxDQUFDLElBQU4sQ0FBdkIsQ0FBbUMsU0FBL0MsR0FBMkQ7QUFIeEU7QUFLRCxDQU5EOzs7QUNGQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLGFBQVQsQ0FBd0IsVUFBeEIsRUFBb0M7QUFDbkQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBVyxVQUFVLEdBQUcsSUFBeEIsSUFBZ0MsRUFBOUM7QUFDQSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLFVBQVUsR0FBRyxFQUF4QixJQUE4QixFQUE5QztBQUNBLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsVUFBVSxHQUFHLEVBQXhCLENBQWhCO0FBRUEsU0FBTztBQUFFLElBQUEsS0FBSyxFQUFMLEtBQUY7QUFBUyxJQUFBLE9BQU8sRUFBUCxPQUFUO0FBQWtCLElBQUEsT0FBTyxFQUFQO0FBQWxCLEdBQVA7QUFDRCxDQU5EOzs7QUNBQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLE1BQVQsQ0FBaUIsUUFBakIsRUFBMkI7QUFDMUMsTUFBTSxXQUFXLEdBQUcsRUFBcEI7QUFDQSxNQUFNLFVBQVUsR0FBRyxFQUFuQjs7QUFDQSxXQUFTLFFBQVQsQ0FBbUIsS0FBbkIsRUFBMEI7QUFDeEIsSUFBQSxXQUFXLENBQUMsSUFBWixDQUFpQixLQUFqQjtBQUNEOztBQUNELFdBQVMsUUFBVCxDQUFtQixLQUFuQixFQUEwQjtBQUN4QixJQUFBLFVBQVUsQ0FBQyxJQUFYLENBQWdCLEtBQWhCO0FBQ0Q7O0FBRUQsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLEdBQVIsQ0FDWCxRQUFRLENBQUMsR0FBVCxDQUFhLFVBQUMsT0FBRDtBQUFBLFdBQWEsT0FBTyxDQUFDLElBQVIsQ0FBYSxRQUFiLEVBQXVCLFFBQXZCLENBQWI7QUFBQSxHQUFiLENBRFcsQ0FBYjtBQUlBLFNBQU8sSUFBSSxDQUFDLElBQUwsQ0FBVSxZQUFNO0FBQ3JCLFdBQU87QUFDTCxNQUFBLFVBQVUsRUFBRSxXQURQO0FBRUwsTUFBQSxNQUFNLEVBQUU7QUFGSCxLQUFQO0FBSUQsR0FMTSxDQUFQO0FBTUQsQ0FwQkQ7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsT0FBVCxDQUFrQixJQUFsQixFQUF3QjtBQUN2QyxTQUFPLEtBQUssQ0FBQyxTQUFOLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLElBQUksSUFBSSxFQUFuQyxFQUF1QyxDQUF2QyxDQUFQO0FBQ0QsQ0FGRDs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsY0FBVCxDQUF5QixNQUF6QixFQUFpQyxTQUFqQyxFQUE0QztBQUMzRCxNQUFNLFNBQVMsR0FBRyxLQUFsQixDQUQyRCxDQUczRDs7QUFDQSxNQUFJLE1BQU0sQ0FBQyxNQUFQLElBQWlCLFNBQXJCLEVBQWdDO0FBQzlCLFdBQU8sTUFBUCxDQUQ4QixDQUVoQztBQUNDOztBQUFDLE1BQUksU0FBUyxJQUFJLFNBQVMsQ0FBQyxNQUEzQixFQUFtQztBQUNuQyxXQUFPLE1BQU0sQ0FBQyxNQUFQLENBQWMsQ0FBZCxFQUFpQixTQUFqQixDQUFQLENBRG1DLENBRXJDO0FBQ0M7O0FBQ0QsTUFBTSxXQUFXLEdBQUcsU0FBUyxHQUFHLFNBQVMsQ0FBQyxNQUExQztBQUNBLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFMLENBQVUsV0FBVyxHQUFHLENBQXhCLENBQW5CO0FBQ0EsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBVyxXQUFXLEdBQUcsQ0FBekIsQ0FBbEI7QUFFQSxTQUFPLE1BQU0sQ0FBQyxNQUFQLENBQWMsQ0FBZCxFQUFpQixVQUFqQixJQUErQixTQUEvQixHQUEyQyxNQUFNLENBQUMsTUFBUCxDQUFjLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLFNBQTlCLENBQWxEO0FBQ0QsQ0FoQkQ7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQSxlQUFjLE9BQU8sQ0FBQyxRQUFELENBQXJCO0FBQUEsSUFBUSxDQUFSLFlBQVEsQ0FBUjs7QUFFQSxNQUFNLENBQUMsT0FBUCxHQUFpQixVQUFDLEtBQUQsRUFBVztBQUMxQixTQUNFO0FBQUssbUJBQVksTUFBakI7QUFBd0IsSUFBQSxTQUFTLEVBQUMsT0FBbEM7QUFBMEMsSUFBQSxJQUFJLEVBQUMsU0FBL0M7QUFBeUQsSUFBQSxLQUFLLEVBQUMsSUFBL0Q7QUFBb0UsSUFBQSxNQUFNLEVBQUMsSUFBM0U7QUFBZ0YsSUFBQSxPQUFPLEVBQUM7QUFBeEYsS0FDRTtBQUFNLElBQUEsQ0FBQyxFQUFDLHNlQUFSO0FBQStlLElBQUEsUUFBUSxFQUFDO0FBQXhmLElBREYsQ0FERjtBQUtELENBTkQ7Ozs7Ozs7OztBQ0ZBO0FBQ0EsZUFBeUIsT0FBTyxDQUFDLFFBQUQsQ0FBaEM7QUFBQSxJQUFRLENBQVIsWUFBUSxDQUFSO0FBQUEsSUFBVyxTQUFYLFlBQVcsU0FBWDs7QUFDQSxJQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsa0JBQUQsQ0FBOUI7O0FBQ0EsSUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLGdCQUFELENBQTVCOztBQUNBLElBQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxtQkFBRCxDQUEvQjs7QUFDQSxJQUFNLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxxQkFBRCxDQUFqQzs7QUFDQSxJQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsZ0JBQUQsQ0FBNUI7O0FBQ0EsSUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLGlCQUFELENBQTdCOztBQUVBLFNBQVMsZUFBVCxDQUEwQixLQUExQixFQUFpQyxJQUFqQyxFQUF1QztBQUNyQyxTQUFPLEtBQUssQ0FBQyxPQUFOLENBQWMsSUFBZCxNQUF3QixDQUFDLENBQWhDO0FBQ0Q7O0lBRUssWTs7Ozs7Ozs7O1NBQ0osaUIsR0FBQSw2QkFBcUI7QUFDbkIsUUFBUSxPQUFSLEdBQW9CLEtBQUssS0FBekIsQ0FBUSxPQUFSO0FBQ0EsSUFBQSxPQUFPO0FBQ1IsRzs7U0FFRCxvQixHQUFBLGdDQUF3QjtBQUN0QixRQUFRLE1BQVIsR0FBbUIsS0FBSyxLQUF4QixDQUFRLE1BQVI7QUFDQSxJQUFBLE1BQU07QUFDUCxHOztTQUVELE0sR0FBQSxrQkFBVTtBQUFBOztBQUNSLHNCQWlCSSxLQUFLLEtBakJUO0FBQUEsUUFDRSxHQURGLGVBQ0UsR0FERjtBQUFBLFFBRUUsYUFGRixlQUVFLGFBRkY7QUFBQSxRQUdFLFNBSEYsZUFHRSxTQUhGO0FBQUEsUUFJRSxLQUpGLGVBSUUsS0FKRjtBQUFBLFFBS0UsaUJBTEYsZUFLRSxpQkFMRjtBQUFBLFFBTUUsWUFORixlQU1FLFlBTkY7QUFBQSxRQU9FLHVCQVBGLGVBT0UsdUJBUEY7QUFBQSxRQVFFLG1CQVJGLGVBUUUsbUJBUkY7QUFBQSxRQVNFLFFBVEYsZUFTRSxRQVRGO0FBQUEsUUFVRSxJQVZGLGVBVUUsSUFWRjtBQUFBLFFBV0UsTUFYRixlQVdFLE1BWEY7QUFBQSxRQVlFLFVBWkYsZUFZRSxVQVpGO0FBQUEsUUFhRSxnQkFiRixlQWFFLGdCQWJGO0FBQUEsUUFjRSxlQWRGLGVBY0UsZUFkRjtBQUFBLFFBZUUsc0JBZkYsZUFlRSxzQkFmRjtBQUFBLFFBZ0JFLHNCQWhCRixlQWdCRSxzQkFoQkY7QUFtQkEsUUFBTSxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsYUFBM0I7QUFDQSxRQUFNLHNCQUFzQixHQUFHLENBQUMsZ0JBQUQsSUFBcUIsaUJBQXJCLEtBQzdCLGVBQWUsQ0FBQyxLQUFELEVBQVEsWUFBUixDQUFmLElBQ0csZUFBZSxDQUFDLEtBQUQsRUFBUSxZQUFSLENBRGxCLElBRUcsZUFBZSxDQUFDLEtBQUQsRUFBUSxhQUFSLENBSFcsQ0FBL0I7QUFLQSxRQUFNLHdCQUF3QixHQUFHLENBQUMsZ0JBQUQsSUFBcUIsZUFBZSxDQUFDLEtBQUQsRUFBUSxTQUFSLENBQXJFO0FBQ0EsUUFBTSx5QkFBeUIsR0FBRyxpQkFBaUIsSUFBSSxtQkFBdkQ7QUFDQSxRQUFNLDZCQUE2QixHQUFHLHVCQUF1QixJQUFJLFlBQTNCLElBQTJDLFlBQVksQ0FBQyxNQUFiLEdBQXNCLENBQXZHO0FBRUEsUUFBTSxVQUFVLEdBQUc7QUFDakIsTUFBQSxXQUFXLEVBQUU7QUFESSxLQUFuQjs7QUFJQSxRQUFJLGFBQUosRUFBbUI7QUFDakIsTUFBQSxVQUFVLENBQUMsS0FBWCxHQUFtQixLQUFuQjtBQUNBLE1BQUEsVUFBVSxDQUFDLFFBQVgsR0FBc0IsSUFBdEI7QUFDQSxNQUFBLFVBQVUsQ0FBQyxHQUFYLEdBQWlCLGFBQWpCLENBSGlCLENBS2pCOztBQUNBLFVBQUksS0FBSyxZQUFULEVBQXVCO0FBQ3JCLGFBQUssWUFBTCxDQUFrQixTQUFsQixHQUE4QixTQUE5QjtBQUNEO0FBQ0YsS0FURCxNQVNPO0FBQ0wsTUFBQSxVQUFVLENBQUMsS0FBWCxHQUFtQixJQUFuQjtBQUNBLE1BQUEsVUFBVSxDQUFDLFFBQVgsR0FBc0IsSUFBdEI7QUFDQSxNQUFBLFVBQVUsQ0FBQyxTQUFYLEdBQXVCLEdBQXZCO0FBQ0Q7O0FBRUQsV0FDRTtBQUFLLE1BQUEsU0FBUyxFQUFDO0FBQWYsT0FDRTtBQUFLLE1BQUEsU0FBUyxFQUFDO0FBQWYsT0FDRTtBQUNFO0FBQ0EsTUFBQSxHQUFHLEVBQUUsYUFBQyxZQUFEO0FBQUEsZUFBbUIsS0FBSSxDQUFDLFlBQUwsR0FBb0IsWUFBdkM7QUFBQSxPQUZQO0FBR0UsTUFBQSxTQUFTLDJCQUF3QixNQUFNLEdBQUcsNkJBQUgsR0FBbUMsRUFBakU7QUFDVDs7QUFKRixPQUtNLFVBTE4sRUFERixDQURGLEVBVUU7QUFBSyxNQUFBLFNBQVMsRUFBQztBQUFmLE9BQ0U7QUFBSyxNQUFBLFNBQVMsRUFBQztBQUFmLE9BQ0csNkJBQTZCLEdBQzFCLGlCQUFpQixDQUFDLEtBQUssS0FBTixDQURTLEdBRTFCLElBSE4sQ0FERixFQU1FO0FBQUssTUFBQSxTQUFTLEVBQUM7QUFBZixPQUNHLHdCQUF3QixJQUFJLEVBQUMsY0FBRDtBQUFnQixNQUFBLFVBQVUsRUFBRSxVQUE1QjtBQUF3QyxNQUFBLElBQUksRUFBRTtBQUE5QyxNQUQvQixFQUdHLHNCQUFzQixJQUNyQixFQUFDLFlBQUQ7QUFDRSxNQUFBLFNBQVMsRUFBRSxTQURiO0FBRUUsTUFBQSxnQkFBZ0IsRUFBRSxnQkFGcEI7QUFHRSxNQUFBLGVBQWUsRUFBRSxlQUhuQjtBQUlFLE1BQUEsSUFBSSxFQUFFO0FBSlIsTUFKSixFQVlHLGdCQUFnQixJQUFJLEVBQUMsWUFBRDtBQUFjLE1BQUEsUUFBUSxFQUFFLFFBQXhCO0FBQWtDLE1BQUEsSUFBSSxFQUFFO0FBQXhDLE1BWnZCLEVBY0csZ0JBQWdCLElBQUksRUFBQyxhQUFEO0FBQWUsTUFBQSxTQUFTLEVBQUUsc0JBQTFCO0FBQWtELE1BQUEsSUFBSSxFQUFFO0FBQXhELE1BZHZCLENBTkYsRUF1QkcseUJBQXlCLElBQ3hCO0FBQUssTUFBQSxTQUFTLEVBQUM7QUFBZixPQUNFLEVBQUMsZUFBRDtBQUFpQixNQUFBLHNCQUFzQixFQUFFLHNCQUF6QztBQUFpRSxNQUFBLElBQUksRUFBRTtBQUF2RSxNQURGLENBeEJKLENBVkYsQ0FERjtBQTBDRCxHOzs7RUF0R3dCLFM7O0FBeUczQixNQUFNLENBQUMsT0FBUCxHQUFpQixZQUFqQjs7O0FDdEhBLGVBQWMsT0FBTyxDQUFDLFFBQUQsQ0FBckI7QUFBQSxJQUFRLENBQVIsWUFBUSxDQUFSOztBQUVBLFNBQVMsYUFBVCxPQUE2QztBQUFBLE1BQW5CLFNBQW1CLFFBQW5CLFNBQW1CO0FBQUEsTUFBUixJQUFRLFFBQVIsSUFBUTtBQUMzQyxTQUNFO0FBQ0UsSUFBQSxTQUFTLEVBQUMsNENBRFo7QUFFRSxJQUFBLElBQUksRUFBQyxRQUZQO0FBR0UsSUFBQSxLQUFLLEVBQUUsSUFBSSxDQUFDLHFCQUFELENBSGI7QUFJRSxrQkFBWSxJQUFJLENBQUMscUJBQUQsQ0FKbEI7QUFLRSxJQUFBLE9BQU8sRUFBRSxTQUxYO0FBTUU7QUFORixLQVFFO0FBQ0UsSUFBQSxLQUFLLEVBQUMsSUFEUjtBQUVFLElBQUEsTUFBTSxFQUFDLElBRlQ7QUFHRSxJQUFBLE9BQU8sRUFBQyxXQUhWO0FBSUUsSUFBQSxLQUFLLEVBQUMsNEJBSlI7QUFLRSxtQkFBWSxNQUxkO0FBTUUsSUFBQSxTQUFTLEVBQUMsT0FOWjtBQU9FLElBQUEsU0FBUyxFQUFDO0FBUFosS0FTRTtBQUFHLElBQUEsSUFBSSxFQUFDLE1BQVI7QUFBZSxJQUFBLFFBQVEsRUFBQztBQUF4QixLQUNFO0FBQU0sSUFBQSxDQUFDLEVBQUM7QUFBUixJQURGLEVBRUU7QUFBTSxJQUFBLENBQUMsRUFBQztBQUFSLElBRkYsQ0FURixDQVJGLENBREY7QUF5QkQ7O0FBRUQsTUFBTSxDQUFDLE9BQVAsR0FBaUIsYUFBakI7OztBQzlCQSxlQUFjLE9BQU8sQ0FBQyxRQUFELENBQXJCO0FBQUEsSUFBUSxDQUFSLFlBQVEsQ0FBUjs7QUFFQSxNQUFNLENBQUMsT0FBUCxHQUFpQixVQUFDLEtBQUQsRUFBVztBQUMxQixTQUNFO0FBQUssSUFBQSxTQUFTLEVBQUM7QUFBZixLQUNFO0FBQUssSUFBQSxTQUFTLEVBQUM7QUFBZixLQUE2QyxLQUFLLENBQUMsSUFBTixFQUE3QyxDQURGLEVBRUU7QUFBSSxJQUFBLFNBQVMsRUFBQztBQUFkLEtBQW1DLEtBQUssQ0FBQyxTQUFOLEdBQWtCLEtBQUssQ0FBQyxJQUFOLENBQVcsa0JBQVgsQ0FBbEIsR0FBbUQsS0FBSyxDQUFDLElBQU4sQ0FBVyxlQUFYLENBQXRGLENBRkYsRUFHRSxhQUFJLEtBQUssQ0FBQyxTQUFOLEdBQWtCLEtBQUssQ0FBQyxJQUFOLENBQVcsd0JBQVgsQ0FBbEIsR0FBeUQsS0FBSyxDQUFDLElBQU4sQ0FBVyxxQkFBWCxDQUE3RCxDQUhGLENBREY7QUFPRCxDQVJEOzs7QUNGQSxlQUFjLE9BQU8sQ0FBQyxRQUFELENBQXJCO0FBQUEsSUFBUSxDQUFSLFlBQVEsQ0FBUjs7QUFFQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLFlBQVQsT0FBK0U7QUFBQSxNQUF0RCxTQUFzRCxRQUF0RCxTQUFzRDtBQUFBLE1BQTNDLGdCQUEyQyxRQUEzQyxnQkFBMkM7QUFBQSxNQUF6QixlQUF5QixRQUF6QixlQUF5QjtBQUFBLE1BQVIsSUFBUSxRQUFSLElBQVE7O0FBQzlGLE1BQUksU0FBSixFQUFlO0FBQ2IsV0FDRTtBQUNFLE1BQUEsU0FBUyxFQUFDLDRDQURaO0FBRUUsTUFBQSxJQUFJLEVBQUMsUUFGUDtBQUdFLE1BQUEsS0FBSyxFQUFFLElBQUksQ0FBQyxlQUFELENBSGI7QUFJRSxvQkFBWSxJQUFJLENBQUMsZUFBRCxDQUpsQjtBQUtFLE1BQUEsT0FBTyxFQUFFLGVBTFg7QUFNRTtBQU5GLE9BUUU7QUFBSyxxQkFBWSxNQUFqQjtBQUF3QixNQUFBLFNBQVMsRUFBQyxPQUFsQztBQUEwQyxNQUFBLFNBQVMsRUFBQyxhQUFwRDtBQUFrRSxNQUFBLEtBQUssRUFBQyxLQUF4RTtBQUE4RSxNQUFBLE1BQU0sRUFBQyxLQUFyRjtBQUEyRixNQUFBLE9BQU8sRUFBQztBQUFuRyxPQUNFO0FBQU0sTUFBQSxDQUFDLEVBQUMsSUFBUjtBQUFhLE1BQUEsQ0FBQyxFQUFDLElBQWY7QUFBb0IsTUFBQSxLQUFLLEVBQUMsSUFBMUI7QUFBK0IsTUFBQSxNQUFNLEVBQUM7QUFBdEMsTUFERixDQVJGLENBREY7QUFjRDs7QUFFRCxTQUNFO0FBQ0UsSUFBQSxTQUFTLEVBQUMsNENBRFo7QUFFRSxJQUFBLElBQUksRUFBQyxRQUZQO0FBR0UsSUFBQSxLQUFLLEVBQUUsSUFBSSxDQUFDLGdCQUFELENBSGI7QUFJRSxrQkFBWSxJQUFJLENBQUMsZ0JBQUQsQ0FKbEI7QUFLRSxJQUFBLE9BQU8sRUFBRSxnQkFMWDtBQU1FO0FBTkYsS0FRRTtBQUFLLG1CQUFZLE1BQWpCO0FBQXdCLElBQUEsU0FBUyxFQUFDLE9BQWxDO0FBQTBDLElBQUEsU0FBUyxFQUFDLGFBQXBEO0FBQWtFLElBQUEsS0FBSyxFQUFDLEtBQXhFO0FBQThFLElBQUEsTUFBTSxFQUFDLEtBQXJGO0FBQTJGLElBQUEsT0FBTyxFQUFDO0FBQW5HLEtBQ0U7QUFBUSxJQUFBLEVBQUUsRUFBQyxJQUFYO0FBQWdCLElBQUEsRUFBRSxFQUFDLElBQW5CO0FBQXdCLElBQUEsQ0FBQyxFQUFDO0FBQTFCLElBREYsQ0FSRixDQURGO0FBY0QsQ0FoQ0Q7OztBQ0ZBLGVBQWMsT0FBTyxDQUFDLFFBQUQsQ0FBckI7QUFBQSxJQUFRLENBQVIsWUFBUSxDQUFSOztBQUNBLElBQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxpQkFBRCxDQUE3Qjs7QUFFQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLGVBQVQsT0FBNEQ7QUFBQSxNQUFoQyxzQkFBZ0MsUUFBaEMsc0JBQWdDO0FBQUEsTUFBUixJQUFRLFFBQVIsSUFBUTtBQUMzRSxNQUFNLCtCQUErQixHQUFHLGFBQWEsQ0FBQyxzQkFBRCxDQUFyRDtBQUVBLFNBQ0U7QUFBTSxrQkFBWSxJQUFJLENBQUMsaUJBQUQsRUFBb0I7QUFBRSxNQUFBLGdCQUFnQixFQUFFO0FBQXBCLEtBQXBCO0FBQXRCLEtBQ0csK0JBREgsQ0FERjtBQUtELENBUkQ7OztBQ0hBLGVBQWMsT0FBTyxDQUFDLFFBQUQsQ0FBckI7QUFBQSxJQUFRLENBQVIsWUFBUSxDQUFSOztBQUNBLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxjQUFELENBQTFCOztBQUVBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLGdCQUEwQjtBQUFBLE1BQXZCLFVBQXVCLFFBQXZCLFVBQXVCO0FBQUEsTUFBWCxJQUFXLFFBQVgsSUFBVztBQUN6QyxTQUNFO0FBQ0UsSUFBQSxTQUFTLEVBQUMsd0VBRFo7QUFFRSxJQUFBLElBQUksRUFBQyxRQUZQO0FBR0UsSUFBQSxLQUFLLEVBQUUsSUFBSSxDQUFDLGFBQUQsQ0FIYjtBQUlFLGtCQUFZLElBQUksQ0FBQyxhQUFELENBSmxCO0FBS0UsSUFBQSxPQUFPLEVBQUUsVUFMWDtBQU1FO0FBTkYsS0FRRyxVQUFVLEVBUmIsQ0FERjtBQVlELENBYkQ7OztBQ0hBLGVBQWMsT0FBTyxDQUFDLFFBQUQsQ0FBckI7QUFBQSxJQUFRLENBQVIsWUFBUSxDQUFSOztBQUVBLFNBQVMsWUFBVCxPQUEyQztBQUFBLE1BQWxCLFFBQWtCLFFBQWxCLFFBQWtCO0FBQUEsTUFBUixJQUFRLFFBQVIsSUFBUTtBQUN6QyxTQUNFO0FBQ0UsSUFBQSxTQUFTLEVBQUMsdUVBRFo7QUFFRSxJQUFBLElBQUksRUFBQyxRQUZQO0FBR0UsSUFBQSxLQUFLLEVBQUUsSUFBSSxDQUFDLG9CQUFELENBSGI7QUFJRSxrQkFBWSxJQUFJLENBQUMsb0JBQUQsQ0FKbEI7QUFLRSxJQUFBLE9BQU8sRUFBRSxRQUxYO0FBTUU7QUFORixLQVFFO0FBQ0UsSUFBQSxLQUFLLEVBQUMsSUFEUjtBQUVFLElBQUEsTUFBTSxFQUFDLEdBRlQ7QUFHRSxJQUFBLE9BQU8sRUFBQyxVQUhWO0FBSUUsSUFBQSxLQUFLLEVBQUMsNEJBSlI7QUFLRSxtQkFBWSxNQUxkO0FBTUUsSUFBQSxTQUFTLEVBQUMsT0FOWjtBQU9FLElBQUEsU0FBUyxFQUFDO0FBUFosS0FTRTtBQUFNLElBQUEsSUFBSSxFQUFDLE1BQVg7QUFBa0IsSUFBQSxRQUFRLEVBQUMsU0FBM0I7QUFBcUMsSUFBQSxDQUFDLEVBQUM7QUFBdkMsSUFURixDQVJGLENBREY7QUFzQkQ7O0FBRUQsTUFBTSxDQUFDLE9BQVAsR0FBaUIsWUFBakI7OztBQzNCQSxlQUFjLE9BQU8sQ0FBQyxRQUFELENBQXJCO0FBQUEsSUFBUSxDQUFSLFlBQVEsQ0FBUjs7QUFFQSxNQUFNLENBQUMsT0FBUCxHQUFpQixnQkFBNEQ7QUFBQSxNQUF6RCxlQUF5RCxRQUF6RCxlQUF5RDtBQUFBLE1BQXhDLFlBQXdDLFFBQXhDLFlBQXdDO0FBQUEsTUFBMUIsbUJBQTBCLFFBQTFCLG1CQUEwQjtBQUMzRSxTQUNFO0FBQUssSUFBQSxTQUFTLEVBQUM7QUFBZixLQUNFO0FBQ0UsSUFBQSxTQUFTLEVBQUMsNkNBRFo7QUFFRSxJQUFBLFFBQVEsRUFBRSxrQkFBQyxLQUFELEVBQVc7QUFBRSxNQUFBLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxNQUFOLENBQWEsS0FBZCxDQUFuQjtBQUF5QztBQUZsRSxLQUlHLFlBQVksQ0FBQyxHQUFiLENBQWlCLFVBQUMsV0FBRDtBQUFBLFdBQ2hCO0FBQ0UsTUFBQSxHQUFHLEVBQUUsV0FBVyxDQUFDLFFBRG5CO0FBRUUsTUFBQSxLQUFLLEVBQUUsV0FBVyxDQUFDLFFBRnJCO0FBR0UsTUFBQSxRQUFRLEVBQUUsV0FBVyxDQUFDLFFBQVosS0FBeUI7QUFIckMsT0FLRyxXQUFXLENBQUMsS0FMZixDQURnQjtBQUFBLEdBQWpCLENBSkgsQ0FERixDQURGO0FBa0JELENBbkJEOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFNBQVMsYUFBVCxDQUF3QixPQUF4QixFQUFpQztBQUNoRCxTQUFVLElBQUksQ0FBQyxLQUFMLENBQ1IsT0FBTyxHQUFHLEVBREYsQ0FBVixTQUVLLE1BQU0sQ0FBQyxPQUFPLEdBQUcsRUFBWCxDQUFOLENBQXFCLFFBQXJCLENBQThCLENBQTlCLEVBQWlDLENBQWpDLENBRkw7QUFHRCxDQUpEOzs7Ozs7Ozs7Ozs7O0FDUEEsZUFBYyxPQUFPLENBQUMsUUFBRCxDQUFyQjtBQUFBLElBQVEsQ0FBUixZQUFRLENBQVI7O0FBQ0EsZ0JBQW1CLE9BQU8sQ0FBQyxZQUFELENBQTFCO0FBQUEsSUFBUSxNQUFSLGFBQVEsTUFBUjs7QUFDQSxJQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsNEJBQUQsQ0FBMUI7O0FBQ0EsSUFBTSxvQkFBb0IsR0FBRyxPQUFPLENBQUMsc0NBQUQsQ0FBcEM7O0FBQ0EsSUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLDJCQUFELENBQXpCOztBQUNBLElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyw4QkFBRCxDQUE1Qjs7QUFDQSxJQUFNLHFCQUFxQixHQUFHLE9BQU8sQ0FBQyx5QkFBRCxDQUFyQzs7QUFDQSxJQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsY0FBRCxDQUExQjs7QUFDQSxJQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsZ0JBQUQsQ0FBNUI7O0FBQ0EsSUFBTSxpQkFBaUIsR0FBRyxPQUFPLENBQUMscUJBQUQsQ0FBakM7O0FBQ0EsSUFBTSxrQkFBa0IsR0FBRyxPQUFPLENBQUMsaUJBQUQsQ0FBUCxDQUEyQixPQUF0RDtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUyxVQUFULENBQXFCLFFBQXJCLEVBQStCO0FBQzdCLE1BQUksUUFBUSxDQUFDLENBQUQsQ0FBUixLQUFnQixHQUFwQixFQUF5QjtBQUN2QixXQUFPLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBVCxDQUFlLENBQWYsQ0FBRCxDQUFoQjtBQUNEOztBQUNELFNBQU8sUUFBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLGVBQVQsQ0FBMEIsUUFBMUIsRUFBb0M7QUFDbEMsU0FBTyxpQkFBaUIsSUFBakIsQ0FBc0IsUUFBdEIsQ0FBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLGVBQVQsQ0FBMEIsUUFBMUIsRUFBb0M7QUFDbEMsU0FBTyxpQkFBaUIsSUFBakIsQ0FBc0IsUUFBdEIsQ0FBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMsZUFBVCxHQUE0QjtBQUMxQjtBQUNBLE1BQUksU0FBUyxDQUFDLFlBQVYsSUFBMEIsU0FBUyxDQUFDLFlBQVYsQ0FBdUIsWUFBckQsRUFBbUU7QUFDakU7QUFDQSxXQUFPLFNBQVMsQ0FBQyxZQUFqQjtBQUNEOztBQUVELE1BQU0sYUFBWSxHQUFHLFNBQVMsQ0FBQyxlQUFWLElBQTZCLFNBQVMsQ0FBQyxrQkFBNUQ7O0FBQ0EsTUFBSSxDQUFDLGFBQUwsRUFBbUI7QUFDakIsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBTztBQUNMLElBQUEsWUFESyx3QkFDUyxJQURULEVBQ2U7QUFDbEIsYUFBTyxJQUFJLE9BQUosQ0FBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCO0FBQ3RDLFFBQUEsYUFBWSxDQUFDLElBQWIsQ0FBa0IsU0FBbEIsRUFBNkIsSUFBN0IsRUFBbUMsT0FBbkMsRUFBNEMsTUFBNUM7QUFDRCxPQUZNLENBQVA7QUFHRDtBQUxJLEdBQVA7QUFPRDtBQUNEO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTSxDQUFDLE9BQVA7QUFBQTs7QUFHRSxrQkFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCO0FBQUE7O0FBQ3ZCLCtCQUFNLElBQU4sRUFBWSxJQUFaO0FBQ0EsVUFBSyxZQUFMLEdBQW9CLGVBQWUsRUFBbkM7QUFDQSxVQUFLLGlCQUFMLEdBQXlCLENBQUMsQ0FBQyxNQUFLLFlBQWhDLENBSHVCLENBSXZCOztBQUNBLFVBQUssUUFBTCxHQUFnQixRQUFRLENBQUMsUUFBVCxDQUFrQixLQUFsQixDQUF3QixRQUF4QixJQUFvQyxPQUFwQyxHQUE4QyxNQUE5RDtBQUNBLFVBQUssRUFBTCxHQUFVLE1BQUssSUFBTCxDQUFVLEVBQVYsSUFBZ0IsUUFBMUI7QUFDQSxVQUFLLEtBQUwsR0FBYSxNQUFLLElBQUwsQ0FBVSxLQUFWLElBQW1CLFFBQWhDO0FBQ0EsVUFBSyxJQUFMLEdBQVksVUFBWjtBQUNBLFVBQUssaUJBQUwsR0FBeUIsSUFBekI7O0FBQ0EsVUFBSyxJQUFMLEdBQVk7QUFBQSxhQUNWO0FBQUssdUJBQVksTUFBakI7QUFBd0IsUUFBQSxTQUFTLEVBQUMsT0FBbEM7QUFBMEMsUUFBQSxLQUFLLEVBQUMsSUFBaEQ7QUFBcUQsUUFBQSxNQUFNLEVBQUMsSUFBNUQ7QUFBaUUsUUFBQSxPQUFPLEVBQUM7QUFBekUsU0FDRTtBQUFHLFFBQUEsSUFBSSxFQUFDLE1BQVI7QUFBZSxRQUFBLFFBQVEsRUFBQztBQUF4QixTQUNFO0FBQU0sUUFBQSxTQUFTLEVBQUMscUJBQWhCO0FBQXNDLFFBQUEsSUFBSSxFQUFDLFNBQTNDO0FBQXFELFFBQUEsS0FBSyxFQUFDLElBQTNEO0FBQWdFLFFBQUEsTUFBTSxFQUFDLElBQXZFO0FBQTRFLFFBQUEsRUFBRSxFQUFDO0FBQS9FLFFBREYsRUFFRTtBQUFNLFFBQUEsQ0FBQyxFQUFDLHdaQUFSO0FBQWlhLFFBQUEsSUFBSSxFQUFDLE1BQXRhO0FBQTZhLFFBQUEsUUFBUSxFQUFDO0FBQXRiLFFBRkYsQ0FERixDQURVO0FBQUEsS0FBWjs7QUFTQSxVQUFLLGFBQUwsR0FBcUI7QUFDbkIsTUFBQSxPQUFPLEVBQUU7QUFDUCxRQUFBLEtBQUssRUFBRSxRQURBO0FBRVAsUUFBQSxXQUFXLEVBQUUsZ0JBRk47QUFHUCxRQUFBLGNBQWMsRUFBRSx1QkFIVDtBQUlQLFFBQUEsYUFBYSxFQUFFLHNCQUpSO0FBS1AsUUFBQSxnQkFBZ0IsRUFBRSxvQ0FMWDtBQU1QLFFBQUEsc0JBQXNCLEVBQUUsdUdBTmpCO0FBT1AsUUFBQSxhQUFhLEVBQUUsc0JBUFI7QUFRUCxRQUFBLG1CQUFtQixFQUFFLDJFQVJkO0FBU1AsUUFBQSx1QkFBdUIsRUFBRSxzRUFUbEI7QUFVUCxRQUFBLGVBQWUsRUFBRSxzQ0FWVjtBQVdQLFFBQUEsa0JBQWtCLEVBQUUsc0JBWGI7QUFZUCxRQUFBLG1CQUFtQixFQUFFO0FBWmQ7QUFEVSxLQUFyQixDQW5CdUIsQ0FvQ3ZCOztBQUNBLFFBQU0sY0FBYyxHQUFHO0FBQ3JCLE1BQUEsZ0JBQWdCLEVBQUU7QUFBQSxlQUFNLE9BQU8sQ0FBQyxPQUFSLEVBQU47QUFBQSxPQURHO0FBRXJCLE1BQUEsU0FBUyxFQUFFLEtBRlU7QUFHckIsTUFBQSxLQUFLLEVBQUUsQ0FDTCxhQURLLEVBRUwsWUFGSyxFQUdMLFlBSEssRUFJTCxTQUpLLENBSGM7QUFTckIsTUFBQSxNQUFNLEVBQUUsSUFUYTtBQVVyQixNQUFBLHVCQUF1QixFQUFFLEtBVko7QUFXckIsTUFBQSxVQUFVLEVBQUUsTUFYUztBQVlyQixNQUFBLHNCQUFzQixFQUFFLElBWkg7QUFhckIsTUFBQSxzQkFBc0IsRUFBRSxJQWJIO0FBY3JCLE1BQUEsbUJBQW1CLEVBQUU7QUFkQSxLQUF2QjtBQWlCQSxVQUFLLElBQUwsZ0JBQWlCLGNBQWpCLEVBQW9DLElBQXBDOztBQUVBLFVBQUssUUFBTDs7QUFFQSxVQUFLLE9BQUwsR0FBZSxNQUFLLE9BQUwsQ0FBYSxJQUFiLCtCQUFmO0FBQ0EsVUFBSyxjQUFMLEdBQXNCLE1BQUssY0FBTCxDQUFvQixJQUFwQiwrQkFBdEI7QUFFQSxVQUFLLE1BQUwsR0FBYyxNQUFLLE1BQUwsQ0FBWSxJQUFaLCtCQUFkLENBN0R1QixDQStEdkI7O0FBQ0EsVUFBSyxLQUFMLEdBQWEsTUFBSyxLQUFMLENBQVcsSUFBWCwrQkFBYjtBQUNBLFVBQUssSUFBTCxHQUFZLE1BQUssSUFBTCxDQUFVLElBQVYsK0JBQVo7QUFDQSxVQUFLLFlBQUwsR0FBb0IsTUFBSyxZQUFMLENBQWtCLElBQWxCLCtCQUFwQjtBQUNBLFVBQUssY0FBTCxHQUFzQixNQUFLLGNBQUwsQ0FBb0IsSUFBcEIsK0JBQXRCO0FBQ0EsVUFBSyxhQUFMLEdBQXFCLE1BQUssYUFBTCxDQUFtQixJQUFuQiwrQkFBckI7QUFDQSxVQUFLLG9CQUFMLEdBQTRCLE1BQUssb0JBQUwsQ0FBMEIsSUFBMUIsK0JBQTVCO0FBQ0EsVUFBSyxNQUFMLEdBQWMsTUFBSyxNQUFMLENBQVksSUFBWiwrQkFBZDtBQUNBLFVBQUssZ0JBQUwsR0FBd0IsTUFBSyxnQkFBTCxDQUFzQixJQUF0QiwrQkFBeEI7QUFDQSxVQUFLLEtBQUwsR0FBYSxNQUFLLEtBQUwsQ0FBVyxJQUFYLCtCQUFiO0FBQ0EsVUFBSyxpQkFBTCxHQUF5QixNQUFLLGlCQUFMLENBQXVCLElBQXZCLCtCQUF6QjtBQUVBLFVBQUssWUFBTCxHQUFvQixLQUFwQjs7QUFFQSxRQUFJLE1BQUssSUFBTCxDQUFVLFNBQWQsRUFBeUI7QUFDdkIsWUFBSyxJQUFMLENBQVUsZ0JBQVYsR0FBNkIsTUFBSyxnQkFBbEM7QUFDRDs7QUFFRCxVQUFLLGNBQUwsQ0FBb0I7QUFDbEIsTUFBQSxTQUFTLEVBQUUsS0FETztBQUVsQixNQUFBLFdBQVcsRUFBRSxLQUZLO0FBR2xCLE1BQUEsV0FBVyxFQUFFLElBSEs7QUFJbEIsTUFBQSxzQkFBc0IsRUFBRSxDQUpOO0FBS2xCLE1BQUEsWUFBWSxFQUFFLEVBTEk7QUFNbEIsTUFBQSxlQUFlLEVBQUU7QUFOQyxLQUFwQjs7QUFqRnVCO0FBeUZ4Qjs7QUE1Rkg7O0FBQUEsU0E4RkUsVUE5RkYsR0E4RkUsb0JBQVksT0FBWixFQUFxQjtBQUNuQixzQkFBTSxVQUFOLHlCQUNLLE9BREw7QUFFRSxNQUFBLGdCQUFnQixlQUVYLEtBQUssSUFBTCxDQUFVLGdCQUZDLEVBR1gsT0FIVyxvQkFHWCxPQUFPLENBQUUsZ0JBSEU7QUFGbEI7O0FBU0EsU0FBSyxRQUFMO0FBQ0QsR0F6R0g7O0FBQUEsU0EyR0UsUUEzR0YsR0EyR0Usb0JBQVk7QUFDVixTQUFLLFVBQUwsR0FBa0IsSUFBSSxVQUFKLENBQWUsQ0FBQyxLQUFLLGFBQU4sRUFBcUIsS0FBSyxJQUFMLENBQVUsTUFBL0IsRUFBdUMsS0FBSyxJQUFMLENBQVUsTUFBakQsQ0FBZixDQUFsQjtBQUNBLFNBQUssSUFBTCxHQUFZLEtBQUssVUFBTCxDQUFnQixTQUFoQixDQUEwQixJQUExQixDQUErQixLQUFLLFVBQXBDLENBQVo7QUFDQSxTQUFLLFNBQUwsR0FBaUIsS0FBSyxVQUFMLENBQWdCLGNBQWhCLENBQStCLElBQS9CLENBQW9DLEtBQUssVUFBekMsQ0FBakI7QUFDQSxTQUFLLGNBQUwsR0FKVSxDQUlZO0FBQ3ZCLEdBaEhIOztBQUFBLFNBa0hFLGNBbEhGLEdBa0hFLDBCQUFrQjtBQUNoQixRQUFJLENBQUMsS0FBSyxZQUFWLEVBQXdCO0FBQ3RCLGFBQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsS0FBaEIsQ0FBUDtBQUNEOztBQUVELFdBQU8sS0FBSyxZQUFMLENBQWtCLGdCQUFsQixHQUFxQyxJQUFyQyxDQUEwQyxVQUFBLE9BQU8sRUFBSTtBQUMxRCxhQUFPLE9BQU8sQ0FBQyxJQUFSLENBQWEsVUFBQSxNQUFNO0FBQUEsZUFBSSxNQUFNLENBQUMsSUFBUCxLQUFnQixZQUFwQjtBQUFBLE9BQW5CLENBQVA7QUFDRCxLQUZNLENBQVA7QUFHRCxHQTFISDs7QUFBQSxTQTRIRSxXQTVIRixHQTRIRSx1QkFBZTtBQUNiLFdBQU8sS0FBSyxJQUFMLENBQVUsS0FBVixDQUFnQixNQUFoQixLQUEyQixDQUEzQixJQUFnQyxLQUFLLElBQUwsQ0FBVSxLQUFWLENBQWdCLENBQWhCLE1BQXVCLFlBQTlEO0FBQ0QsR0E5SEg7O0FBQUEsU0FnSUUsY0FoSUYsR0FnSUUsd0JBQWdCLFFBQWhCLEVBQWlDO0FBQUE7O0FBQUEsUUFBakIsUUFBaUI7QUFBakIsTUFBQSxRQUFpQixHQUFOLElBQU07QUFBQTs7QUFDL0IsUUFBTSxZQUFZLEdBQUcsS0FBSyxJQUFMLENBQVUsS0FBVixDQUFnQixPQUFoQixDQUF3QixhQUF4QixNQUEyQyxDQUFDLENBQTVDLElBQ2hCLEtBQUssSUFBTCxDQUFVLEtBQVYsQ0FBZ0IsT0FBaEIsQ0FBd0IsWUFBeEIsTUFBMEMsQ0FBQyxDQURoRDtBQUVBLFFBQU0sWUFBWSxHQUFHLENBQUMsS0FBSyxXQUFMLEVBQUQsS0FDYixLQUFLLElBQUwsQ0FBVSxLQUFWLENBQWdCLE9BQWhCLENBQXdCLGFBQXhCLE1BQTJDLENBQUMsQ0FBNUMsSUFDQyxLQUFLLElBQUwsQ0FBVSxLQUFWLENBQWdCLE9BQWhCLENBQXdCLFlBQXhCLE1BQTBDLENBQUMsQ0FENUMsSUFFQyxLQUFLLElBQUwsQ0FBVSxLQUFWLENBQWdCLE9BQWhCLENBQXdCLFNBQXhCLE1BQXVDLENBQUMsQ0FINUIsQ0FBckI7O0FBS0EsUUFBTSxnQkFBZ0IseUNBQ2hCLEtBQUssSUFBTCxDQUFVLGdCQURNLG9DQUNjO0FBQUUsTUFBQSxVQUFVLEVBQUUsS0FBSyxJQUFMLENBQVU7QUFBeEIsS0FEZCxFQUloQixRQUFRLEdBQUc7QUFBRSxNQUFBLFFBQVEsRUFBUixRQUFGO0FBQVksTUFBQSxVQUFVLEVBQUU7QUFBeEIsS0FBSCxHQUFvQyxFQUo1QixDQUF0Qjs7QUFPQSxXQUFPO0FBQ0wsTUFBQSxLQUFLLEVBQUUsWUFERjtBQUVMLE1BQUEsS0FBSyxFQUFFLFlBQVksR0FBRyxnQkFBSCxHQUFzQjtBQUZwQyxLQUFQO0FBSUQsR0FuSkgsQ0FxSkU7QUFySkY7O0FBQUEsU0FzSkUsS0F0SkYsR0FzSkUsZUFBTyxPQUFQLEVBQXVCO0FBQUE7O0FBQUEsUUFBaEIsT0FBZ0I7QUFBaEIsTUFBQSxPQUFnQixHQUFOLElBQU07QUFBQTs7QUFDckIsUUFBSSxDQUFDLEtBQUssaUJBQVYsRUFBNkI7QUFDM0IsYUFBTyxPQUFPLENBQUMsTUFBUixDQUFlLElBQUksS0FBSixDQUFVLDZCQUFWLENBQWYsQ0FBUDtBQUNEOztBQUVELFNBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNBLFNBQUssSUFBTCxDQUFVLE1BQVYsR0FBbUIsSUFBbkI7QUFFQSxRQUFNLFdBQVcsR0FBRyxLQUFLLGNBQUwsQ0FBb0IsT0FBTyxJQUFJLE9BQU8sQ0FBQyxRQUFuQixHQUE4QixPQUFPLENBQUMsUUFBdEMsR0FBaUQsSUFBckUsQ0FBcEI7QUFFQSxTQUFLLGNBQUwsR0FBc0IsSUFBdEIsQ0FBMkIsVUFBQSxTQUFTLEVBQUk7QUFDdEMsTUFBQSxNQUFJLENBQUMsY0FBTCxDQUFvQjtBQUNsQixRQUFBLFNBQVMsRUFBVDtBQURrQixPQUFwQixFQURzQyxDQUt0Qzs7O0FBQ0EsYUFBTyxNQUFJLENBQUMsWUFBTCxDQUFrQixZQUFsQixDQUErQixXQUEvQixFQUNKLElBREksQ0FDQyxVQUFDLE1BQUQsRUFBWTtBQUNoQixRQUFBLE1BQUksQ0FBQyxNQUFMLEdBQWMsTUFBZDtBQUVBLFlBQUksZUFBZSxHQUFHLElBQXRCO0FBQ0EsWUFBTSxNQUFNLEdBQUcsTUFBSSxDQUFDLFdBQUwsS0FBcUIsTUFBTSxDQUFDLGNBQVAsRUFBckIsR0FBK0MsTUFBTSxDQUFDLGNBQVAsRUFBOUQ7O0FBRUEsWUFBSSxDQUFDLE9BQUQsSUFBWSxDQUFDLE9BQU8sQ0FBQyxRQUF6QixFQUFtQztBQUNqQyxVQUFBLGVBQWUsR0FBRyxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsV0FBVixHQUF3QixRQUExQztBQUNELFNBRkQsTUFFTztBQUNMLFVBQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxVQUFDLEtBQUQsRUFBVztBQUN4QixnQkFBSSxLQUFLLENBQUMsV0FBTixHQUFvQixRQUFwQixLQUFpQyxPQUFPLENBQUMsUUFBN0MsRUFBdUQ7QUFDckQsY0FBQSxlQUFlLEdBQUcsS0FBSyxDQUFDLFdBQU4sR0FBb0IsUUFBdEM7QUFDRDtBQUNGLFdBSkQ7QUFLRCxTQWRlLENBZ0JoQjs7O0FBQ0EsUUFBQSxNQUFJLENBQUMsa0JBQUw7O0FBRUEsUUFBQSxNQUFJLENBQUMsY0FBTCxDQUFvQjtBQUNsQixVQUFBLGVBQWUsRUFBZixlQURrQjtBQUVsQixVQUFBLFdBQVcsRUFBRTtBQUZLLFNBQXBCO0FBSUQsT0F4QkksRUF5QkosS0F6QkksQ0F5QkUsVUFBQyxHQUFELEVBQVM7QUFDZCxRQUFBLE1BQUksQ0FBQyxjQUFMLENBQW9CO0FBQ2xCLFVBQUEsV0FBVyxFQUFFLEtBREs7QUFFbEIsVUFBQSxXQUFXLEVBQUU7QUFGSyxTQUFwQjs7QUFJQSxRQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLEdBQUcsQ0FBQyxPQUFuQixFQUE0QixPQUE1QjtBQUNELE9BL0JJLENBQVA7QUFnQ0QsS0F0Q0Q7QUF1Q0Q7QUFFRDtBQUNGO0FBQ0E7QUEzTUE7O0FBQUEsU0E0TUUsdUJBNU1GLEdBNE1FLG1DQUEyQjtBQUN6QixRQUFNLE9BQU8sR0FBRyxFQUFoQixDQUR5QixDQUd6QjtBQUNBO0FBQ0E7O0FBQ0EsUUFBSSxhQUFhLENBQUMsZUFBbEIsRUFBbUM7QUFDakMsVUFBUSxZQUFSLEdBQXlCLEtBQUssSUFBTCxDQUFVLElBQW5DLENBQVEsWUFBUjtBQUNBLFVBQUksdUJBQXVCLEdBQUcsRUFBOUI7O0FBQ0EsVUFBSSxLQUFLLElBQUwsQ0FBVSxzQkFBZCxFQUFzQztBQUNwQyxRQUFBLHVCQUF1QixHQUFHLENBQUMsS0FBSyxJQUFMLENBQVUsc0JBQVgsQ0FBMUI7QUFDRCxPQUZELE1BRU8sSUFBSSxZQUFZLENBQUMsZ0JBQWpCLEVBQW1DO0FBQ3hDLFFBQUEsdUJBQXVCLEdBQUcsWUFBWSxDQUFDLGdCQUFiLENBQThCLEdBQTlCLENBQWtDLFVBQWxDLEVBQThDLE1BQTlDLENBQXFELGVBQXJELENBQTFCO0FBQ0Q7O0FBRUQsVUFBTSxvQkFBb0IsR0FBRyxTQUF2QixvQkFBdUIsQ0FBQyxhQUFEO0FBQUEsZUFBbUIsYUFBYSxDQUFDLGVBQWQsQ0FBOEIsYUFBOUIsS0FDM0Msb0JBQW9CLENBQUMsYUFBRCxDQURJO0FBQUEsT0FBN0I7O0FBRUEsVUFBTSxtQkFBbUIsR0FBRyx1QkFBdUIsQ0FBQyxNQUF4QixDQUErQixvQkFBL0IsQ0FBNUI7O0FBRUEsVUFBSSxtQkFBbUIsQ0FBQyxNQUFwQixHQUE2QixDQUFqQyxFQUFvQztBQUNsQztBQUNBLFFBQUEsT0FBTyxDQUFDLFFBQVIsR0FBbUIsbUJBQW1CLENBQUMsQ0FBRCxDQUF0QztBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxPQUFQO0FBQ0QsR0F0T0g7O0FBQUEsU0F3T0UsY0F4T0YsR0F3T0UsMEJBQWtCO0FBQUE7O0FBQ2hCO0FBQ0E7QUFDQSxTQUFLLFFBQUwsR0FBZ0IsSUFBSSxhQUFKLENBQWtCLEtBQUssTUFBdkIsRUFBK0IsS0FBSyx1QkFBTCxFQUEvQixDQUFoQjtBQUNBLFNBQUssZUFBTCxHQUF1QixFQUF2QjtBQUNBLFFBQUksd0JBQXdCLEdBQUcsS0FBL0I7QUFDQSxTQUFLLFFBQUwsQ0FBYyxnQkFBZCxDQUErQixlQUEvQixFQUFnRCxVQUFDLEtBQUQsRUFBVztBQUN6RCxNQUFBLE1BQUksQ0FBQyxlQUFMLENBQXFCLElBQXJCLENBQTBCLEtBQUssQ0FBQyxJQUFoQzs7QUFFQSxVQUFRLFlBQVIsR0FBeUIsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFuQyxDQUFRLFlBQVI7O0FBQ0EsVUFBSSxNQUFJLENBQUMsZUFBTCxDQUFxQixNQUFyQixHQUE4QixDQUE5QixJQUNHLFlBQVksQ0FBQyxXQUFiLElBQTRCLElBRC9CLElBRUcsQ0FBQyx3QkFGUixFQUVrQztBQUNoQyxZQUFNLFNBQVMsR0FBRyxNQUFJLENBQUMsZUFBTCxDQUFxQixNQUFyQixDQUE0QixVQUFDLEdBQUQsRUFBTSxLQUFOO0FBQUEsaUJBQWdCLEdBQUcsR0FBRyxLQUFLLENBQUMsSUFBNUI7QUFBQSxTQUE1QixFQUE4RCxDQUE5RCxDQUFsQixDQURnQyxDQUVoQzs7O0FBQ0EsWUFBTSxnQkFBZ0IsR0FBRyxDQUFDLFNBQVMsR0FBRyxNQUFJLENBQUMsZUFBTCxDQUFxQixDQUFyQixFQUF3QixJQUFyQyxLQUE4QyxNQUFJLENBQUMsZUFBTCxDQUFxQixNQUFyQixHQUE4QixDQUE1RSxDQUF6QjtBQUNBLFlBQU0sb0JBQW9CLEdBQUcsZ0JBQWdCLEdBQUcsQ0FBaEQ7QUFDQSxZQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBTCxDQUFTLENBQVQsRUFBWSxZQUFZLENBQUMsV0FBYixHQUEyQixvQkFBdkMsQ0FBaEI7O0FBRUEsWUFBSSxTQUFTLEdBQUcsT0FBaEIsRUFBeUI7QUFDdkIsVUFBQSx3QkFBd0IsR0FBRyxJQUEzQjs7QUFDQSxVQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLE1BQUksQ0FBQyxJQUFMLENBQVUseUJBQVYsQ0FBZixFQUFxRCxTQUFyRCxFQUFnRSxJQUFoRTs7QUFDQSxVQUFBLE1BQUksQ0FBQyxhQUFMO0FBQ0Q7QUFDRjtBQUNGLEtBbkJELEVBTmdCLENBMkJoQjtBQUNBOztBQUNBLFNBQUssUUFBTCxDQUFjLEtBQWQsQ0FBb0IsR0FBcEI7O0FBRUEsUUFBSSxLQUFLLElBQUwsQ0FBVSxtQkFBZCxFQUFtQztBQUNqQztBQUNBLFdBQUssb0JBQUwsR0FBNEIsV0FBVyxDQUFDLFlBQU07QUFDNUMsWUFBTSxzQkFBc0IsR0FBRyxNQUFJLENBQUMsY0FBTCxHQUFzQixzQkFBckQ7O0FBQ0EsUUFBQSxNQUFJLENBQUMsY0FBTCxDQUFvQjtBQUFFLFVBQUEsc0JBQXNCLEVBQUUsc0JBQXNCLEdBQUc7QUFBbkQsU0FBcEI7QUFDRCxPQUhzQyxFQUdwQyxJQUhvQyxDQUF2QztBQUlEOztBQUVELFNBQUssY0FBTCxDQUFvQjtBQUNsQixNQUFBLFdBQVcsRUFBRTtBQURLLEtBQXBCO0FBR0QsR0FsUkg7O0FBQUEsU0FvUkUsYUFwUkYsR0FvUkUseUJBQWlCO0FBQUE7O0FBQ2YsUUFBTSxPQUFPLEdBQUcsSUFBSSxPQUFKLENBQVksVUFBQyxPQUFELEVBQWE7QUFDdkMsTUFBQSxNQUFJLENBQUMsUUFBTCxDQUFjLGdCQUFkLENBQStCLE1BQS9CLEVBQXVDLFlBQU07QUFDM0MsUUFBQSxPQUFPO0FBQ1IsT0FGRDs7QUFHQSxNQUFBLE1BQUksQ0FBQyxRQUFMLENBQWMsSUFBZDs7QUFFQSxVQUFJLE1BQUksQ0FBQyxJQUFMLENBQVUsbUJBQWQsRUFBbUM7QUFDakM7QUFDQSxRQUFBLGFBQWEsQ0FBQyxNQUFJLENBQUMsb0JBQU4sQ0FBYjs7QUFDQSxRQUFBLE1BQUksQ0FBQyxjQUFMLENBQW9CO0FBQUUsVUFBQSxzQkFBc0IsRUFBRTtBQUExQixTQUFwQjtBQUNEO0FBQ0YsS0FYZSxDQUFoQjtBQWFBLFdBQU8sT0FBTyxDQUFDLElBQVIsQ0FBYSxZQUFNO0FBQ3hCLE1BQUEsTUFBSSxDQUFDLGNBQUwsQ0FBb0I7QUFDbEIsUUFBQSxXQUFXLEVBQUU7QUFESyxPQUFwQjs7QUFHQSxhQUFPLE1BQUksQ0FBQyxRQUFMLEVBQVA7QUFDRCxLQUxNLEVBS0osSUFMSSxDQUtDLFVBQUMsSUFBRCxFQUFVO0FBQ2hCLFVBQUk7QUFDRixRQUFBLE1BQUksQ0FBQyxpQkFBTCxHQUF5QixJQUF6QixDQURFLENBRUY7O0FBQ0EsUUFBQSxNQUFJLENBQUMsY0FBTCxDQUFvQjtBQUNsQjtBQUNBLFVBQUEsYUFBYSxFQUFFLEdBQUcsQ0FBQyxlQUFKLENBQW9CLElBQUksQ0FBQyxJQUF6QjtBQUZHLFNBQXBCOztBQUlBLFFBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxNQUFWLEdBQW1CLEtBQW5CO0FBQ0QsT0FSRCxDQVFFLE9BQU8sR0FBUCxFQUFZO0FBQ1o7QUFDQSxZQUFJLENBQUMsR0FBRyxDQUFDLGFBQVQsRUFBd0I7QUFDdEIsVUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLEdBQVYsQ0FBYyxHQUFkO0FBQ0Q7QUFDRjtBQUNGLEtBcEJNLEVBb0JKLElBcEJJLENBb0JDLFlBQU07QUFDWixNQUFBLE1BQUksQ0FBQyxlQUFMLEdBQXVCLElBQXZCO0FBQ0EsTUFBQSxNQUFJLENBQUMsUUFBTCxHQUFnQixJQUFoQjtBQUNELEtBdkJNLEVBdUJKLFVBQUMsS0FBRCxFQUFXO0FBQ1osTUFBQSxNQUFJLENBQUMsZUFBTCxHQUF1QixJQUF2QjtBQUNBLE1BQUEsTUFBSSxDQUFDLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxZQUFNLEtBQU47QUFDRCxLQTNCTSxDQUFQO0FBNEJELEdBOVRIOztBQUFBLFNBZ1VFLG9CQWhVRixHQWdVRSxnQ0FBd0I7QUFDdEIsU0FBSyxjQUFMLENBQW9CO0FBQUUsTUFBQSxhQUFhLEVBQUU7QUFBakIsS0FBcEI7QUFDQSxTQUFLLElBQUwsQ0FBVSxNQUFWLEdBQW1CLElBQW5CO0FBQ0EsU0FBSyxpQkFBTCxHQUF5QixJQUF6QjtBQUNELEdBcFVIOztBQUFBLFNBc1VFLE1BdFVGLEdBc1VFLGtCQUFVO0FBQ1IsUUFBSTtBQUNGLFVBQUksS0FBSyxpQkFBVCxFQUE0QjtBQUMxQixhQUFLLElBQUwsQ0FBVSxPQUFWLENBQWtCLEtBQUssaUJBQXZCO0FBQ0Q7QUFDRixLQUpELENBSUUsT0FBTyxHQUFQLEVBQVk7QUFDWjtBQUNBLFVBQUksQ0FBQyxHQUFHLENBQUMsYUFBVCxFQUF3QjtBQUN0QixhQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsR0FBZCxFQUFtQixPQUFuQjtBQUNEO0FBQ0Y7QUFDRixHQWpWSDs7QUFBQSxTQW1WRSxJQW5WRixHQW1WRSxnQkFBUTtBQUNOLFFBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2YsV0FBSyxNQUFMLENBQVksY0FBWixHQUE2QixPQUE3QixDQUFxQyxVQUFDLEtBQUQsRUFBVztBQUM5QyxRQUFBLEtBQUssQ0FBQyxJQUFOO0FBQ0QsT0FGRDtBQUdBLFdBQUssTUFBTCxDQUFZLGNBQVosR0FBNkIsT0FBN0IsQ0FBcUMsVUFBQyxLQUFELEVBQVc7QUFDOUMsUUFBQSxLQUFLLENBQUMsSUFBTjtBQUNELE9BRkQ7QUFHRDs7QUFDRCxTQUFLLFlBQUwsR0FBb0IsS0FBcEI7QUFDQSxTQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0EsU0FBSyxjQUFMLENBQW9CO0FBQ2xCLE1BQUEsYUFBYSxFQUFFO0FBREcsS0FBcEI7QUFHRCxHQWpXSDs7QUFBQSxTQW1XRSxlQW5XRixHQW1XRSwyQkFBbUI7QUFDakIsV0FBTyxLQUFLLEVBQUwsQ0FBUSxhQUFSLENBQXNCLG9CQUF0QixDQUFQO0FBQ0QsR0FyV0g7O0FBQUEsU0F1V0UsZ0JBdldGLEdBdVdFLDRCQUFvQjtBQUFBOztBQUNsQixXQUFPLElBQUksT0FBSixDQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7QUFDdEMsVUFBSSxLQUFLLEdBQUcsTUFBSSxDQUFDLElBQUwsQ0FBVSxTQUF0QixDQURzQyxDQUd0Qzs7QUFDQSxVQUFNLFNBQVMsR0FBRyxXQUFXLENBQUMsWUFBTTtBQUNsQyxZQUFJLENBQUMsTUFBSSxDQUFDLFlBQVYsRUFBd0I7QUFDdEIsVUFBQSxhQUFhLENBQUMsU0FBRCxDQUFiO0FBQ0EsVUFBQSxNQUFJLENBQUMsaUJBQUwsR0FBeUIsS0FBekI7QUFDQSxpQkFBTyxNQUFNLENBQUMsSUFBSSxLQUFKLENBQVUsc0JBQVYsQ0FBRCxDQUFiO0FBQ0Q7O0FBRUQsWUFBSSxLQUFLLEdBQUcsQ0FBWixFQUFlO0FBQ2IsVUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLElBQVYsQ0FBa0IsS0FBbEIsVUFBOEIsU0FBOUIsRUFBeUMsR0FBekM7O0FBQ0EsVUFBQSxLQUFLO0FBQ04sU0FIRCxNQUdPO0FBQ0wsVUFBQSxhQUFhLENBQUMsU0FBRCxDQUFiOztBQUNBLFVBQUEsTUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFWLENBQWUsTUFBSSxDQUFDLElBQUwsQ0FBVSxPQUFWLENBQWYsRUFBbUMsU0FBbkMsRUFBOEMsSUFBOUM7O0FBQ0EsVUFBQSxVQUFVLENBQUM7QUFBQSxtQkFBTSxPQUFPLEVBQWI7QUFBQSxXQUFELEVBQWtCLElBQWxCLENBQVY7QUFDRDtBQUNGLE9BZjRCLEVBZTFCLElBZjBCLENBQTdCO0FBZ0JELEtBcEJNLENBQVA7QUFxQkQsR0E3WEg7O0FBQUEsU0ErWEUsWUEvWEYsR0ErWEUsd0JBQWdCO0FBQUE7O0FBQ2QsUUFBSSxLQUFLLGlCQUFULEVBQTRCO0FBRTVCLFNBQUssaUJBQUwsR0FBeUIsSUFBekI7QUFFQSxTQUFLLElBQUwsQ0FBVSxnQkFBVixHQUE2QixLQUE3QixDQUFtQyxVQUFDLEdBQUQsRUFBUztBQUMxQyxVQUFNLE9BQU8sR0FBRyxPQUFPLEdBQVAsS0FBZSxRQUFmLEdBQTBCLEdBQUcsQ0FBQyxPQUE5QixHQUF3QyxHQUF4RDs7QUFDQSxNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLE9BQWYsRUFBd0IsT0FBeEIsRUFBaUMsSUFBakM7O0FBQ0EsYUFBTyxPQUFPLENBQUMsTUFBUixDQUFlLElBQUksS0FBSix3QkFBK0IsT0FBL0IsQ0FBZixDQUFQO0FBQ0QsS0FKRCxFQUlHLElBSkgsQ0FJUSxZQUFNO0FBQ1osYUFBTyxNQUFJLENBQUMsUUFBTCxFQUFQO0FBQ0QsS0FORCxFQU1HLElBTkgsQ0FNUSxVQUFDLE9BQUQsRUFBYTtBQUNuQixNQUFBLE1BQUksQ0FBQyxpQkFBTCxHQUF5QixLQUF6Qjs7QUFDQSxVQUFJO0FBQ0YsUUFBQSxNQUFJLENBQUMsSUFBTCxDQUFVLE9BQVYsQ0FBa0IsT0FBbEI7QUFDRCxPQUZELENBRUUsT0FBTyxHQUFQLEVBQVk7QUFDWjtBQUNBLFlBQUksQ0FBQyxHQUFHLENBQUMsYUFBVCxFQUF3QjtBQUN0QixVQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsR0FBVixDQUFjLEdBQWQ7QUFDRDtBQUNGO0FBQ0YsS0FoQkQsRUFnQkcsVUFBQyxLQUFELEVBQVc7QUFDWixNQUFBLE1BQUksQ0FBQyxpQkFBTCxHQUF5QixLQUF6QjtBQUNBLFlBQU0sS0FBTjtBQUNELEtBbkJEO0FBb0JELEdBeFpIOztBQUFBLFNBMFpFLFFBMVpGLEdBMFpFLG9CQUFZO0FBQUE7O0FBQ1YsUUFBTSxLQUFLLEdBQUcsS0FBSyxlQUFMLEVBQWQ7O0FBQ0EsUUFBSSxDQUFDLEtBQUwsRUFBWTtBQUNWLGFBQU8sT0FBTyxDQUFDLE1BQVIsQ0FBZSxJQUFJLEtBQUosQ0FBVSxvRUFBVixDQUFmLENBQVA7QUFDRDs7QUFFRCxRQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsVUFBcEI7QUFDQSxRQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsV0FBckI7QUFFQSxRQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBVCxDQUF1QixRQUF2QixDQUFmO0FBQ0EsSUFBQSxNQUFNLENBQUMsS0FBUCxHQUFlLEtBQWY7QUFDQSxJQUFBLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLE1BQWhCO0FBQ0EsUUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFVBQVAsQ0FBa0IsSUFBbEIsQ0FBWjtBQUNBLElBQUEsR0FBRyxDQUFDLFNBQUosQ0FBYyxLQUFkLEVBQXFCLENBQXJCLEVBQXdCLENBQXhCO0FBRUEsUUFBUSxZQUFSLEdBQXlCLEtBQUssSUFBTCxDQUFVLElBQW5DLENBQVEsWUFBUjtBQUNBLFFBQUksdUJBQXVCLEdBQUcsRUFBOUI7O0FBQ0EsUUFBSSxLQUFLLElBQUwsQ0FBVSxzQkFBZCxFQUFzQztBQUNwQyxNQUFBLHVCQUF1QixHQUFHLENBQUMsS0FBSyxJQUFMLENBQVUsc0JBQVgsQ0FBMUI7QUFDRCxLQUZELE1BRU8sSUFBSSxZQUFZLENBQUMsZ0JBQWpCLEVBQW1DO0FBQ3hDLE1BQUEsdUJBQXVCLEdBQUcsWUFBWSxDQUFDLGdCQUFiLENBQThCLEdBQTlCLENBQWtDLFVBQWxDLEVBQThDLE1BQTlDLENBQXFELGVBQXJELENBQTFCO0FBQ0Q7O0FBRUQsUUFBTSxRQUFRLEdBQUcsdUJBQXVCLENBQUMsQ0FBRCxDQUF2QixJQUE4QixZQUEvQztBQUNBLFFBQU0sR0FBRyxHQUFHLG9CQUFvQixDQUFDLFFBQUQsQ0FBcEIsSUFBa0MsS0FBOUM7QUFDQSxRQUFNLElBQUksWUFBVSxJQUFJLENBQUMsR0FBTCxFQUFWLFNBQXdCLEdBQWxDO0FBRUEsV0FBTyxZQUFZLENBQUMsTUFBRCxFQUFTLFFBQVQsQ0FBWixDQUErQixJQUEvQixDQUFvQyxVQUFDLElBQUQsRUFBVTtBQUNuRCxhQUFPO0FBQ0wsUUFBQSxNQUFNLEVBQUUsTUFBSSxDQUFDLEVBRFI7QUFFTCxRQUFBLElBQUksRUFBSixJQUZLO0FBR0wsUUFBQSxJQUFJLEVBQUUsSUFBSSxJQUFKLENBQVMsQ0FBQyxJQUFELENBQVQsRUFBaUI7QUFBRSxVQUFBLElBQUksRUFBRTtBQUFSLFNBQWpCLENBSEQ7QUFJTCxRQUFBLElBQUksRUFBRTtBQUpELE9BQVA7QUFNRCxLQVBNLENBQVA7QUFRRCxHQTdiSDs7QUFBQSxTQStiRSxRQS9iRixHQStiRSxvQkFBWTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQU0sUUFBUSxHQUFHLEtBQUssZUFBTCxDQUFxQixJQUFyQixDQUEwQixVQUFBLElBQUk7QUFBQTs7QUFBQSxhQUFJLGVBQUEsSUFBSSxDQUFDLElBQUwsZ0NBQVcsTUFBWCxJQUFvQixDQUF4QjtBQUFBLEtBQTlCLEVBQXlELElBQTFFO0FBRUEsUUFBTSxhQUFhLEdBQUcsb0JBQW9CLENBQUMsUUFBRCxDQUExQzs7QUFFQSxRQUFJLENBQUMsYUFBTCxFQUFvQjtBQUNsQixhQUFPLE9BQU8sQ0FBQyxNQUFSLENBQWUsSUFBSSxLQUFKLDZEQUFtRSxRQUFuRSxRQUFmLENBQVA7QUFDRDs7QUFFRCxRQUFNLElBQUksZUFBYSxJQUFJLENBQUMsR0FBTCxFQUFiLFNBQTJCLGFBQXJDO0FBQ0EsUUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFKLENBQVMsS0FBSyxlQUFkLEVBQStCO0FBQUUsTUFBQSxJQUFJLEVBQUU7QUFBUixLQUEvQixDQUFiO0FBQ0EsUUFBTSxJQUFJLEdBQUc7QUFDWCxNQUFBLE1BQU0sRUFBRSxLQUFLLEVBREY7QUFFWCxNQUFBLElBQUksRUFBSixJQUZXO0FBR1gsTUFBQSxJQUFJLEVBQUUsSUFBSSxJQUFKLENBQVMsQ0FBQyxJQUFELENBQVQsRUFBaUI7QUFBRSxRQUFBLElBQUksRUFBRTtBQUFSLE9BQWpCLENBSEs7QUFJWCxNQUFBLElBQUksRUFBRTtBQUpLLEtBQWI7QUFPQSxXQUFPLE9BQU8sQ0FBQyxPQUFSLENBQWdCLElBQWhCLENBQVA7QUFDRCxHQXJkSDs7QUFBQSxTQXVkRSxLQXZkRixHQXVkRSxpQkFBUztBQUFBOztBQUNQLFFBQUksQ0FBQyxLQUFLLElBQUwsQ0FBVSxTQUFmLEVBQTBCO0FBQzFCLElBQUEsVUFBVSxDQUFDLFlBQU07QUFDZixNQUFBLE1BQUksQ0FBQyxJQUFMLENBQVUsSUFBVixDQUFlLE1BQUksQ0FBQyxJQUFMLENBQVUsT0FBVixDQUFmLEVBQW1DLFNBQW5DLEVBQThDLElBQTlDO0FBQ0QsS0FGUyxFQUVQLElBRk8sQ0FBVjtBQUdELEdBNWRIOztBQUFBLFNBOGRFLGlCQTlkRixHQThkRSwyQkFBbUIsUUFBbkIsRUFBNkI7QUFDM0IsU0FBSyxJQUFMO0FBQ0EsU0FBSyxLQUFMLENBQVc7QUFBRSxNQUFBLFFBQVEsRUFBUjtBQUFGLEtBQVg7QUFDRCxHQWplSDs7QUFBQSxTQW1lRSxrQkFuZUYsR0FtZUUsOEJBQXNCO0FBQUE7O0FBQ3BCLFNBQUssWUFBTCxDQUFrQixnQkFBbEIsR0FBcUMsSUFBckMsQ0FBMEMsVUFBQSxPQUFPLEVBQUk7QUFDbkQsTUFBQSxNQUFJLENBQUMsY0FBTCxDQUFvQjtBQUNsQixRQUFBLFlBQVksRUFBRSxPQUFPLENBQUMsTUFBUixDQUFlLFVBQUMsTUFBRDtBQUFBLGlCQUFZLE1BQU0sQ0FBQyxJQUFQLEtBQWdCLFlBQTVCO0FBQUEsU0FBZjtBQURJLE9BQXBCO0FBR0QsS0FKRDtBQUtELEdBemVIOztBQUFBLFNBMmVFLE1BM2VGLEdBMmVFLGtCQUFVO0FBQ1IsUUFBSSxDQUFDLEtBQUssWUFBVixFQUF3QjtBQUN0QixXQUFLLEtBQUw7QUFDRDs7QUFFRCxRQUFNLFdBQVcsR0FBRyxLQUFLLGNBQUwsRUFBcEI7O0FBRUEsUUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFiLElBQTRCLENBQUMsV0FBVyxDQUFDLFNBQTdDLEVBQXdEO0FBQ3RELGFBQ0UsRUFBQyxpQkFBRDtBQUNFLFFBQUEsSUFBSSxFQUFFLFVBRFI7QUFFRSxRQUFBLElBQUksRUFBRSxLQUFLLElBRmI7QUFHRSxRQUFBLFNBQVMsRUFBRSxXQUFXLENBQUM7QUFIekIsUUFERjtBQU9EOztBQUVELFdBQ0UsRUFBQyxZQUFELENBQ0U7QUFERixtQkFFTSxXQUZOO0FBR0UsTUFBQSxtQkFBbUIsRUFBRSxLQUFLLGlCQUg1QjtBQUlFLE1BQUEsVUFBVSxFQUFFLEtBQUssWUFKbkI7QUFLRSxNQUFBLGdCQUFnQixFQUFFLEtBQUssY0FMekI7QUFNRSxNQUFBLGVBQWUsRUFBRSxLQUFLLGFBTnhCO0FBT0UsTUFBQSxzQkFBc0IsRUFBRSxLQUFLLG9CQVAvQjtBQVFFLE1BQUEsUUFBUSxFQUFFLEtBQUssTUFSakI7QUFTRSxNQUFBLE9BQU8sRUFBRSxLQUFLLEtBVGhCO0FBVUUsTUFBQSxNQUFNLEVBQUUsS0FBSyxJQVZmO0FBV0UsTUFBQSxJQUFJLEVBQUUsS0FBSyxJQVhiO0FBWUUsTUFBQSxLQUFLLEVBQUUsS0FBSyxJQUFMLENBQVUsS0FabkI7QUFhRSxNQUFBLG1CQUFtQixFQUFFLEtBQUssSUFBTCxDQUFVLG1CQWJqQztBQWNFLE1BQUEsdUJBQXVCLEVBQUUsS0FBSyxJQUFMLENBQVUsdUJBZHJDO0FBZUUsTUFBQSxpQkFBaUIsRUFBRSxxQkFBcUIsRUFmMUM7QUFnQkUsTUFBQSxTQUFTLEVBQUUsV0FBVyxDQUFDLFdBaEJ6QjtBQWlCRSxNQUFBLE1BQU0sRUFBRSxLQUFLLElBQUwsQ0FBVSxNQWpCcEI7QUFrQkUsTUFBQSxHQUFHLEVBQUUsS0FBSztBQWxCWixPQURGO0FBc0JELEdBbGhCSDs7QUFBQSxTQW9oQkUsT0FwaEJGLEdBb2hCRSxtQkFBVztBQUFBOztBQUNULFNBQUssY0FBTCxDQUFvQjtBQUNsQixNQUFBLFdBQVcsRUFBRSxLQURLO0FBRWxCLE1BQUEsc0JBQXNCLEVBQUU7QUFGTixLQUFwQjtBQUtBLFFBQVEsTUFBUixHQUFtQixLQUFLLElBQXhCLENBQVEsTUFBUjs7QUFDQSxRQUFJLE1BQUosRUFBWTtBQUNWLFdBQUssS0FBTCxDQUFXLE1BQVgsRUFBbUIsSUFBbkI7QUFDRDs7QUFFRCxRQUFJLEtBQUssWUFBVCxFQUF1QjtBQUNyQixXQUFLLGtCQUFMOztBQUVBLFdBQUssWUFBTCxDQUFrQixjQUFsQixHQUFtQyxZQUFNO0FBQ3ZDLFFBQUEsT0FBSSxDQUFDLGtCQUFMOztBQUVBLFlBQUksT0FBSSxDQUFDLE1BQVQsRUFBaUI7QUFDZixjQUFJLGFBQWEsR0FBRyxJQUFwQjs7QUFFQSxzQ0FBMEMsT0FBSSxDQUFDLGNBQUwsRUFBMUM7QUFBQSxjQUFRLFlBQVIseUJBQVEsWUFBUjtBQUFBLGNBQXNCLGVBQXRCLHlCQUFzQixlQUF0Qjs7QUFFQSxVQUFBLFlBQVksQ0FBQyxPQUFiLENBQXFCLFVBQUMsV0FBRCxFQUFpQjtBQUNwQyxnQkFBSSxlQUFlLEtBQUssV0FBVyxDQUFDLFFBQXBDLEVBQThDO0FBQzVDLGNBQUEsYUFBYSxHQUFHLEtBQWhCO0FBQ0Q7QUFDRixXQUpEOztBQU1BLGNBQUksYUFBSixFQUFtQjtBQUNqQixZQUFBLE9BQUksQ0FBQyxJQUFMOztBQUNBLFlBQUEsT0FBSSxDQUFDLEtBQUw7QUFDRDtBQUNGO0FBQ0YsT0FuQkQ7QUFvQkQ7QUFDRixHQXZqQkg7O0FBQUEsU0F5akJFLFNBempCRixHQXlqQkUscUJBQWE7QUFDWCxRQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNmLFdBQUssSUFBTDtBQUNEOztBQUVELFNBQUssT0FBTDtBQUNELEdBL2pCSDs7QUFBQTtBQUFBLEVBQXNDLE1BQXRDLFVBQ1MsT0FEVCxHQUNtQixrQkFEbkI7OztBQ3hFQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFTLHFCQUFULEdBQWtDO0FBQ2pEO0FBQ0EsU0FBTyxPQUFPLGFBQVAsS0FBeUIsVUFBekIsSUFBdUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxTQUF2RCxJQUNGLE9BQU8sYUFBYSxDQUFDLFNBQWQsQ0FBd0IsS0FBL0IsS0FBeUMsVUFEOUM7QUFFQTtBQUNELENBTEQ7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUFBQSxLQUFLLENBQUMsTUFBTixDQUFhLGFBQWIsQ0FBMkIsT0FBM0IsRUFBb0MsS0FBcEMsR0FBNEMsRUFBNUM7QUFDQSxFQUFBLEtBQUssQ0FBQyxNQUFOLENBQWEsYUFBYixDQUEyQixVQUEzQixFQUF1QyxLQUF2QyxHQUErQyxFQUEvQztBQUNELENBWkQ7QUFjQSxNQUFNLENBQUMsZ0JBQVAsQ0FBd0Isa0JBQXhCLEVBQTRDLFlBQU07QUFDaEQsRUFBQSxZQUFZO0FBQ2IsQ0FGRCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vRmxldC9wcmV0dGllci1ieXRlcy9cbi8vIENoYW5naW5nIDEwMDAgYnl0ZXMgdG8gMTAyNCwgc28gd2UgY2FuIGtlZXAgdXBwZXJjYXNlIEtCIHZzIGtCXG4vLyBJU0MgTGljZW5zZSAoYykgRGFuIEZsZXR0cmUgaHR0cHM6Ly9naXRodWIuY29tL0ZsZXQvcHJldHRpZXItYnl0ZXMvYmxvYi9tYXN0ZXIvTElDRU5TRVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcmV0dGllckJ5dGVzIChudW0pIHtcbiAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInIHx8IGlzTmFOKG51bSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIG51bWJlciwgZ290ICcgKyB0eXBlb2YgbnVtKVxuICB9XG5cbiAgdmFyIG5lZyA9IG51bSA8IDBcbiAgdmFyIHVuaXRzID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ11cblxuICBpZiAobmVnKSB7XG4gICAgbnVtID0gLW51bVxuICB9XG5cbiAgaWYgKG51bSA8IDEpIHtcbiAgICByZXR1cm4gKG5lZyA/ICctJyA6ICcnKSArIG51bSArICcgQidcbiAgfVxuXG4gIHZhciBleHBvbmVudCA9IE1hdGgubWluKE1hdGguZmxvb3IoTWF0aC5sb2cobnVtKSAvIE1hdGgubG9nKDEwMjQpKSwgdW5pdHMubGVuZ3RoIC0gMSlcbiAgbnVtID0gTnVtYmVyKG51bSAvIE1hdGgucG93KDEwMjQsIGV4cG9uZW50KSlcbiAgdmFyIHVuaXQgPSB1bml0c1tleHBvbmVudF1cblxuICBpZiAobnVtID49IDEwIHx8IG51bSAlIDEgPT09IDApIHtcbiAgICAvLyBEbyBub3Qgc2hvdyBkZWNpbWFscyB3aGVuIHRoZSBudW1iZXIgaXMgdHdvLWRpZ2l0LCBvciBpZiB0aGUgbnVtYmVyIGhhcyBub1xuICAgIC8vIGRlY2ltYWwgY29tcG9uZW50LlxuICAgIHJldHVybiAobmVnID8gJy0nIDogJycpICsgbnVtLnRvRml4ZWQoMCkgKyAnICcgKyB1bml0XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChuZWcgPyAnLScgOiAnJykgKyBudW0udG9GaXhlZCgxKSArICcgJyArIHVuaXRcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCIvKipcbiAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG4gIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG4gIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9XG5cbiAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG4iLCIvKlxuICogYmFzZTY0LWFycmF5YnVmZmVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG4oZnVuY3Rpb24oKXtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5cbiAgLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuICB2YXIgbG9va3VwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuICAgIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTMpIHtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAoKGxlbiAlIDMpID09PSAyKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfTtcblxuICBleHBvcnRzLmRlY29kZSA9ICBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG4gICAgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsXG4gICAgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcbiAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgZW5jb2RlZDEgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSldO1xuICAgICAgZW5jb2RlZDIgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsxKV07XG4gICAgICBlbmNvZGVkMyA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzIpXTtcbiAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMyldO1xuXG4gICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbiAgfTtcbn0pKCk7XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qKlxyXG4gKiBDcmVhdGUgYSBibG9iIGJ1aWxkZXIgZXZlbiB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxyXG4gKi9cclxuXHJcbnZhciBCbG9iQnVpbGRlciA9IHR5cGVvZiBCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIFdlYktpdEJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IFdlYktpdEJsb2JCdWlsZGVyIDpcclxuICB0eXBlb2YgTVNCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBNU0Jsb2JCdWlsZGVyIDpcclxuICB0eXBlb2YgTW96QmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTW96QmxvYkJ1aWxkZXIgOiBcclxuICBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxyXG4gKi9cclxuXHJcbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XHJcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xyXG4gIH0gY2F0Y2goZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufSkoKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIHN1cHBvcnRzIEFycmF5QnVmZmVyVmlld3NcclxuICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cclxuICovXHJcblxyXG52YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XHJcbiAgdHJ5IHtcclxuICAgIHZhciBiID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KFsxLDJdKV0pO1xyXG4gICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcclxuICB9IGNhdGNoKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXHJcbiAqL1xyXG5cclxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcclxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kXHJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xyXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcclxuICogc3VwcG9ydCBpdCBpbiB0aGUgQmxvYiBjb25zdHJ1Y3Rvci5cclxuICovXHJcblxyXG5mdW5jdGlvbiBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkge1xyXG4gIHJldHVybiBhcnkubWFwKGZ1bmN0aW9uKGNodW5rKSB7XHJcbiAgICBpZiAoY2h1bmsuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcclxuXHJcbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBzdWJhcnJheSwgbWFrZSBhIGNvcHkgc28gd2Ugb25seVxyXG4gICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShjaHVuay5ieXRlTGVuZ3RoKTtcclxuICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcclxuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGJ1ZjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2h1bms7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIHZhciBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xyXG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KS5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpIHtcclxuICAgIGJiLmFwcGVuZChwYXJ0KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xyXG4gIHJldHVybiBuZXcgQmxvYihtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSksIG9wdGlvbnMgfHwge30pO1xyXG59O1xyXG5cclxuaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJykge1xyXG4gIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IucHJvdG90eXBlID0gQmxvYi5wcm90b3R5cGU7XHJcbiAgQmxvYkNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IEJsb2IucHJvdG90eXBlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcclxuICBpZiAoYmxvYlN1cHBvcnRlZCkge1xyXG4gICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IEJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XHJcbiAgfSBlbHNlIGlmIChibG9iQnVpbGRlclN1cHBvcnRlZCkge1xyXG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG59KSgpO1xyXG4iLCIiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxOCBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGlmIChhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKGFyZy50b1N0cmluZyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iLCIvKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfVxufTtcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07IiwiLyoqXG4gKiBjdWlkLmpzXG4gKiBDb2xsaXNpb24tcmVzaXN0YW50IFVJRCBnZW5lcmF0b3IgZm9yIGJyb3dzZXJzIGFuZCBub2RlLlxuICogU2VxdWVudGlhbCBmb3IgZmFzdCBkYiBsb29rdXBzIGFuZCByZWNlbmN5IHNvcnRpbmcuXG4gKiBTYWZlIGZvciBlbGVtZW50IElEcyBhbmQgc2VydmVyLXNpZGUgbG9va3Vwcy5cbiAqXG4gKiBFeHRyYWN0ZWQgZnJvbSBDTENUUlxuICpcbiAqIENvcHlyaWdodCAoYykgRXJpYyBFbGxpb3R0IDIwMTJcbiAqIE1JVCBMaWNlbnNlXG4gKi9cblxudmFyIGZpbmdlcnByaW50ID0gcmVxdWlyZSgnLi9saWIvZmluZ2VycHJpbnQuanMnKTtcbnZhciBwYWQgPSByZXF1aXJlKCcuL2xpYi9wYWQuanMnKTtcbnZhciBnZXRSYW5kb21WYWx1ZSA9IHJlcXVpcmUoJy4vbGliL2dldFJhbmRvbVZhbHVlLmpzJyk7XG5cbnZhciBjID0gMCxcbiAgYmxvY2tTaXplID0gNCxcbiAgYmFzZSA9IDM2LFxuICBkaXNjcmV0ZVZhbHVlcyA9IE1hdGgucG93KGJhc2UsIGJsb2NrU2l6ZSk7XG5cbmZ1bmN0aW9uIHJhbmRvbUJsb2NrICgpIHtcbiAgcmV0dXJuIHBhZCgoZ2V0UmFuZG9tVmFsdWUoKSAqXG4gICAgZGlzY3JldGVWYWx1ZXMgPDwgMClcbiAgICAudG9TdHJpbmcoYmFzZSksIGJsb2NrU2l6ZSk7XG59XG5cbmZ1bmN0aW9uIHNhZmVDb3VudGVyICgpIHtcbiAgYyA9IGMgPCBkaXNjcmV0ZVZhbHVlcyA/IGMgOiAwO1xuICBjKys7IC8vIHRoaXMgaXMgbm90IHN1YmxpbWluYWxcbiAgcmV0dXJuIGMgLSAxO1xufVxuXG5mdW5jdGlvbiBjdWlkICgpIHtcbiAgLy8gU3RhcnRpbmcgd2l0aCBhIGxvd2VyY2FzZSBsZXR0ZXIgbWFrZXNcbiAgLy8gaXQgSFRNTCBlbGVtZW50IElEIGZyaWVuZGx5LlxuICB2YXIgbGV0dGVyID0gJ2MnLCAvLyBoYXJkLWNvZGVkIGFsbG93cyBmb3Igc2VxdWVudGlhbCBhY2Nlc3NcblxuICAgIC8vIHRpbWVzdGFtcFxuICAgIC8vIHdhcm5pbmc6IHRoaXMgZXhwb3NlcyB0aGUgZXhhY3QgZGF0ZSBhbmQgdGltZVxuICAgIC8vIHRoYXQgdGhlIHVpZCB3YXMgY3JlYXRlZC5cbiAgICB0aW1lc3RhbXAgPSAobmV3IERhdGUoKS5nZXRUaW1lKCkpLnRvU3RyaW5nKGJhc2UpLFxuXG4gICAgLy8gUHJldmVudCBzYW1lLW1hY2hpbmUgY29sbGlzaW9ucy5cbiAgICBjb3VudGVyID0gcGFkKHNhZmVDb3VudGVyKCkudG9TdHJpbmcoYmFzZSksIGJsb2NrU2l6ZSksXG5cbiAgICAvLyBBIGZldyBjaGFycyB0byBnZW5lcmF0ZSBkaXN0aW5jdCBpZHMgZm9yIGRpZmZlcmVudFxuICAgIC8vIGNsaWVudHMgKHNvIGRpZmZlcmVudCBjb21wdXRlcnMgYXJlIGZhciBsZXNzXG4gICAgLy8gbGlrZWx5IHRvIGdlbmVyYXRlIHRoZSBzYW1lIGlkKVxuICAgIHByaW50ID0gZmluZ2VycHJpbnQoKSxcblxuICAgIC8vIEdyYWIgc29tZSBtb3JlIGNoYXJzIGZyb20gTWF0aC5yYW5kb20oKVxuICAgIHJhbmRvbSA9IHJhbmRvbUJsb2NrKCkgKyByYW5kb21CbG9jaygpO1xuXG4gIHJldHVybiBsZXR0ZXIgKyB0aW1lc3RhbXAgKyBjb3VudGVyICsgcHJpbnQgKyByYW5kb207XG59XG5cbmN1aWQuc2x1ZyA9IGZ1bmN0aW9uIHNsdWcgKCkge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLnRvU3RyaW5nKDM2KSxcbiAgICBjb3VudGVyID0gc2FmZUNvdW50ZXIoKS50b1N0cmluZygzNikuc2xpY2UoLTQpLFxuICAgIHByaW50ID0gZmluZ2VycHJpbnQoKS5zbGljZSgwLCAxKSArXG4gICAgICBmaW5nZXJwcmludCgpLnNsaWNlKC0xKSxcbiAgICByYW5kb20gPSByYW5kb21CbG9jaygpLnNsaWNlKC0yKTtcblxuICByZXR1cm4gZGF0ZS5zbGljZSgtMikgK1xuICAgIGNvdW50ZXIgKyBwcmludCArIHJhbmRvbTtcbn07XG5cbmN1aWQuaXNDdWlkID0gZnVuY3Rpb24gaXNDdWlkIChzdHJpbmdUb0NoZWNrKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nVG9DaGVjayAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcbiAgaWYgKHN0cmluZ1RvQ2hlY2suc3RhcnRzV2l0aCgnYycpKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY3VpZC5pc1NsdWcgPSBmdW5jdGlvbiBpc1NsdWcgKHN0cmluZ1RvQ2hlY2spIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmdUb0NoZWNrICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc3RyaW5nTGVuZ3RoID0gc3RyaW5nVG9DaGVjay5sZW5ndGg7XG4gIGlmIChzdHJpbmdMZW5ndGggPj0gNyAmJiBzdHJpbmdMZW5ndGggPD0gMTApIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jdWlkLmZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gY3VpZDtcbiIsInZhciBwYWQgPSByZXF1aXJlKCcuL3BhZC5qcycpO1xuXG52YXIgZW52ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgPyB3aW5kb3cgOiBzZWxmO1xudmFyIGdsb2JhbENvdW50ID0gT2JqZWN0LmtleXMoZW52KS5sZW5ndGg7XG52YXIgbWltZVR5cGVzTGVuZ3RoID0gbmF2aWdhdG9yLm1pbWVUeXBlcyA/IG5hdmlnYXRvci5taW1lVHlwZXMubGVuZ3RoIDogMDtcbnZhciBjbGllbnRJZCA9IHBhZCgobWltZVR5cGVzTGVuZ3RoICtcbiAgbmF2aWdhdG9yLnVzZXJBZ2VudC5sZW5ndGgpLnRvU3RyaW5nKDM2KSArXG4gIGdsb2JhbENvdW50LnRvU3RyaW5nKDM2KSwgNCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmluZ2VycHJpbnQgKCkge1xuICByZXR1cm4gY2xpZW50SWQ7XG59O1xuIiwiXG52YXIgZ2V0UmFuZG9tVmFsdWU7XG5cbnZhciBjcnlwdG8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAod2luZG93LmNyeXB0byB8fCB3aW5kb3cubXNDcnlwdG8pIHx8XG4gIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJlxuICBzZWxmLmNyeXB0bztcblxuaWYgKGNyeXB0bykge1xuICAgIHZhciBsaW0gPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuICAgIGdldFJhbmRvbVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdIC8gbGltKTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBnZXRSYW5kb21WYWx1ZSA9IE1hdGgucmFuZG9tO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhbmRvbVZhbHVlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYWQgKG51bSwgc2l6ZSkge1xuICB2YXIgcyA9ICcwMDAwMDAwMDAnICsgbnVtO1xuICByZXR1cm4gcy5zdWJzdHIocy5sZW5ndGggLSBzaXplKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGRyYWdEcm9wXG5cbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnZmxhdHRlbicpXG52YXIgcGFyYWxsZWwgPSByZXF1aXJlKCdydW4tcGFyYWxsZWwnKVxuXG5mdW5jdGlvbiBkcmFnRHJvcCAoZWxlbSwgbGlzdGVuZXJzKSB7XG4gIGlmICh0eXBlb2YgZWxlbSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBlbGVtXG4gICAgZWxlbSA9IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW0pXG4gICAgaWYgKCFlbGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIHNlbGVjdG9yICsgJ1wiIGRvZXMgbm90IG1hdGNoIGFueSBIVE1MIGVsZW1lbnRzJylcbiAgICB9XG4gIH1cblxuICBpZiAoIWVsZW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGVsZW0gKyAnXCIgaXMgbm90IGEgdmFsaWQgSFRNTCBlbGVtZW50JylcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdGVuZXJzID0geyBvbkRyb3A6IGxpc3RlbmVycyB9XG4gIH1cblxuICB2YXIgdGltZW91dFxuXG4gIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgb25EcmFnRW50ZXIsIGZhbHNlKVxuICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgb25EcmFnT3ZlciwgZmFsc2UpXG4gIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgb25EcmFnTGVhdmUsIGZhbHNlKVxuICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBvbkRyb3AsIGZhbHNlKVxuXG4gIC8vIEZ1bmN0aW9uIHRvIHJlbW92ZSBkcmFnLWRyb3AgbGlzdGVuZXJzXG4gIHJldHVybiBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgIHJlbW92ZURyYWdDbGFzcygpXG4gICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBvbkRyYWdFbnRlciwgZmFsc2UpXG4gICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIG9uRHJhZ092ZXIsIGZhbHNlKVxuICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgb25EcmFnTGVhdmUsIGZhbHNlKVxuICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJvcCcsIG9uRHJvcCwgZmFsc2UpXG4gIH1cblxuICBmdW5jdGlvbiBvbkRyYWdFbnRlciAoZSkge1xuICAgIGlmIChsaXN0ZW5lcnMub25EcmFnRW50ZXIpIHtcbiAgICAgIGxpc3RlbmVycy5vbkRyYWdFbnRlcihlKVxuICAgIH1cblxuICAgIC8vIFByZXZlbnQgZXZlbnRcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBvbkRyYWdPdmVyIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgaWYgKGxpc3RlbmVycy5vbkRyYWdPdmVyKSB7XG4gICAgICBsaXN0ZW5lcnMub25EcmFnT3ZlcihlKVxuICAgIH1cblxuICAgIGlmIChlLmRhdGFUcmFuc2Zlci5pdGVtcykge1xuICAgICAgLy8gT25seSBhZGQgXCJkcmFnXCIgY2xhc3Mgd2hlbiBgaXRlbXNgIGNvbnRhaW5zIGl0ZW1zIHRoYXQgYXJlIGFibGUgdG8gYmVcbiAgICAgIC8vIGhhbmRsZWQgYnkgdGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzIChmaWxlcyB2cy4gdGV4dClcbiAgICAgIHZhciBpdGVtcyA9IEFycmF5LmZyb20oZS5kYXRhVHJhbnNmZXIuaXRlbXMpXG4gICAgICB2YXIgZmlsZUl0ZW1zID0gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLmtpbmQgPT09ICdmaWxlJyB9KVxuICAgICAgdmFyIHRleHRJdGVtcyA9IGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5raW5kID09PSAnc3RyaW5nJyB9KVxuXG4gICAgICBpZiAoZmlsZUl0ZW1zLmxlbmd0aCA9PT0gMCAmJiAhbGlzdGVuZXJzLm9uRHJvcFRleHQpIHJldHVyblxuICAgICAgaWYgKHRleHRJdGVtcy5sZW5ndGggPT09IDAgJiYgIWxpc3RlbmVycy5vbkRyb3ApIHJldHVyblxuICAgICAgaWYgKGZpbGVJdGVtcy5sZW5ndGggPT09IDAgJiYgdGV4dEl0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gICAgfVxuXG4gICAgZWxlbS5jbGFzc0xpc3QuYWRkKCdkcmFnJylcbiAgICBjbGVhclRpbWVvdXQodGltZW91dClcblxuICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSdcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gb25EcmFnTGVhdmUgKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBpZiAobGlzdGVuZXJzLm9uRHJhZ0xlYXZlKSB7XG4gICAgICBsaXN0ZW5lcnMub25EcmFnTGVhdmUoZSlcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChyZW1vdmVEcmFnQ2xhc3MsIDUwKVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBvbkRyb3AgKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBpZiAobGlzdGVuZXJzLm9uRHJhZ0xlYXZlKSB7XG4gICAgICBsaXN0ZW5lcnMub25EcmFnTGVhdmUoZSlcbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICByZW1vdmVEcmFnQ2xhc3MoKVxuXG4gICAgdmFyIHBvcyA9IHtcbiAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgIHk6IGUuY2xpZW50WVxuICAgIH1cblxuICAgIC8vIHRleHQgZHJvcCBzdXBwb3J0XG4gICAgdmFyIHRleHQgPSBlLmRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0JylcbiAgICBpZiAodGV4dCAmJiBsaXN0ZW5lcnMub25Ecm9wVGV4dCkge1xuICAgICAgbGlzdGVuZXJzLm9uRHJvcFRleHQodGV4dCwgcG9zKVxuICAgIH1cblxuICAgIC8vIEZpbGUgZHJvcCBzdXBwb3J0LiBUaGUgYGRhdGFUcmFuc2Zlci5pdGVtc2AgQVBJIHN1cHBvcnRzIGRpcmVjdG9yaWVzLCBzbyB3ZVxuICAgIC8vIHVzZSBpdCBpbnN0ZWFkIG9mIGBkYXRhVHJhbnNmZXIuZmlsZXNgLCBldmVuIHRob3VnaCBpdCdzIG11Y2ggbW9yZVxuICAgIC8vIGNvbXBsaWNhdGVkIHRvIHVzZS5cbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvZHJhZy1kcm9wL2lzc3Vlcy8zOVxuICAgIGlmIChsaXN0ZW5lcnMub25Ecm9wICYmIGUuZGF0YVRyYW5zZmVyLml0ZW1zKSB7XG4gICAgICB2YXIgZmlsZUxpc3QgPSBlLmRhdGFUcmFuc2Zlci5maWxlc1xuXG4gICAgICAvLyBIYW5kbGUgZGlyZWN0b3JpZXMgaW4gQ2hyb21lIHVzaW5nIHRoZSBwcm9wcmlldGFyeSBGaWxlU3lzdGVtIEFQSVxuICAgICAgdmFyIGl0ZW1zID0gQXJyYXkuZnJvbShlLmRhdGFUcmFuc2Zlci5pdGVtcykuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmtpbmQgPT09ICdmaWxlJ1xuICAgICAgfSlcblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgICAgIHBhcmFsbGVsKGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgcHJvY2Vzc0VudHJ5KGl0ZW0ud2Via2l0R2V0QXNFbnRyeSgpLCBjYilcbiAgICAgICAgfVxuICAgICAgfSksIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgLy8gVGhpcyBjYXRjaGVzIHBlcm1pc3Npb24gZXJyb3JzIHdpdGggZmlsZTovLyBpbiBDaHJvbWUuIFRoaXMgc2hvdWxkIG5ldmVyXG4gICAgICAgIC8vIHRocm93IGluIHByb2R1Y3Rpb24gY29kZSwgc28gdGhlIHVzZXIgZG9lcyBub3QgbmVlZCB0byB1c2UgdHJ5LWNhdGNoLlxuICAgICAgICBpZiAoZXJyKSB0aHJvdyBlcnJcblxuICAgICAgICB2YXIgZW50cmllcyA9IGZsYXR0ZW4ocmVzdWx0cylcblxuICAgICAgICB2YXIgZmlsZXMgPSBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtLmlzRmlsZVxuICAgICAgICB9KVxuXG4gICAgICAgIHZhciBkaXJlY3RvcmllcyA9IGVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0uaXNEaXJlY3RvcnlcbiAgICAgICAgfSlcblxuICAgICAgICBsaXN0ZW5lcnMub25Ecm9wKGZpbGVzLCBwb3MsIGZpbGVMaXN0LCBkaXJlY3RvcmllcylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVEcmFnQ2xhc3MgKCkge1xuICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZSgnZHJhZycpXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VudHJ5IChlbnRyeSwgY2IpIHtcbiAgdmFyIGVudHJpZXMgPSBbXVxuXG4gIGlmIChlbnRyeS5pc0ZpbGUpIHtcbiAgICBlbnRyeS5maWxlKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICBmaWxlLmZ1bGxQYXRoID0gZW50cnkuZnVsbFBhdGggLy8gcHJlc2VydmUgcGF0aGluZyBmb3IgY29uc3VtZXJcbiAgICAgIGZpbGUuaXNGaWxlID0gdHJ1ZVxuICAgICAgZmlsZS5pc0RpcmVjdG9yeSA9IGZhbHNlXG4gICAgICBjYihudWxsLCBmaWxlKVxuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICB9KVxuICB9IGVsc2UgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gICAgdmFyIHJlYWRlciA9IGVudHJ5LmNyZWF0ZVJlYWRlcigpXG4gICAgcmVhZEVudHJpZXMoKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEVudHJpZXMgKCkge1xuICAgIHJlYWRlci5yZWFkRW50cmllcyhmdW5jdGlvbiAoZW50cmllc18pIHtcbiAgICAgIGlmIChlbnRyaWVzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVudHJpZXMgPSBlbnRyaWVzLmNvbmNhdChBcnJheS5mcm9tKGVudHJpZXNfKSlcbiAgICAgICAgcmVhZEVudHJpZXMoKSAvLyBjb250aW51ZSByZWFkaW5nIGVudHJpZXMgdW50aWwgYHJlYWRFbnRyaWVzYCByZXR1cm5zIG5vIG1vcmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmVFbnRyaWVzKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gZG9uZUVudHJpZXMgKCkge1xuICAgIHBhcmFsbGVsKGVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgICBwcm9jZXNzRW50cnkoZW50cnksIGNiKVxuICAgICAgfVxuICAgIH0pLCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgZnVsbFBhdGg6IGVudHJ5LmZ1bGxQYXRoLFxuICAgICAgICAgIG5hbWU6IGVudHJ5Lm5hbWUsXG4gICAgICAgICAgaXNGaWxlOiBmYWxzZSxcbiAgICAgICAgICBpc0RpcmVjdG9yeTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICBjYihudWxsLCByZXN1bHRzKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmxhdHRlbihsaXN0LCBkZXB0aCkge1xuICBkZXB0aCA9ICh0eXBlb2YgZGVwdGggPT0gJ251bWJlcicpID8gZGVwdGggOiBJbmZpbml0eTtcblxuICBpZiAoIWRlcHRoKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICAgIHJldHVybiBsaXN0Lm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBpOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICByZXR1cm4gX2ZsYXR0ZW4obGlzdCwgMSk7XG5cbiAgZnVuY3Rpb24gX2ZsYXR0ZW4obGlzdCwgZCkge1xuICAgIHJldHVybiBsaXN0LnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpdGVtKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSAmJiBkIDwgZGVwdGgpIHtcbiAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQoX2ZsYXR0ZW4oaXRlbSwgZCArIDEpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChpdGVtKTtcbiAgICAgIH1cbiAgICB9LCBbXSk7XG4gIH1cbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcbnZhciBoYXNCaW5hcnkgPSByZXF1aXJlKCdoYXMtYmluYXJ5MicpO1xudmFyIHNsaWNlQnVmZmVyID0gcmVxdWlyZSgnYXJyYXlidWZmZXIuc2xpY2UnKTtcbnZhciBhZnRlciA9IHJlcXVpcmUoJ2FmdGVyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xuXG52YXIgYmFzZTY0ZW5jb2RlcjtcbmlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gIGJhc2U2NGVuY29kZXIgPSByZXF1aXJlKCdiYXNlNjQtYXJyYXlidWZmZXInKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBhbiBhbmRyb2lkIGJyb3dzZXIuIFRoYXQgcmVxdWlyZXMgdXMgdG8gdXNlXG4gKiBBcnJheUJ1ZmZlciB3aXRoIHBvbGxpbmcgdHJhbnNwb3J0cy4uLlxuICpcbiAqIGh0dHA6Ly9naGluZGEubmV0L2pwZWctYmxvYi1hamF4LWFuZHJvaWQvXG4gKi9cblxudmFyIGlzQW5kcm9pZCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG4gKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGlzUGhhbnRvbUpTID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5cbnZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuICAsIHBpbmc6ICAgICAyXG4gICwgcG9uZzogICAgIDNcbiAgLCBtZXNzYWdlOiAgNFxuICAsIHVwZ3JhZGU6ICA1XG4gICwgbm9vcDogICAgIDZcbn07XG5cbnZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cblxudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYiA9IHJlcXVpcmUoJ2Jsb2InKTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB1dGY4ZW5jb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuICAgIHV0ZjhlbmNvZGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGRhdGEgPSAocGFja2V0LmRhdGEgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpLCB7IHN0cmljdDogZmFsc2UgfSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQoeyB0eXBlOiBwYWNrZXQudHlwZSwgZGF0YTogZnIucmVzdWx0IH0sIHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBjYWxsYmFjayk7XG4gIH07XG4gIHJldHVybiBmci5yZWFkQXNBcnJheUJ1ZmZlcihwYWNrZXQuZGF0YSk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmIChkb250U2VuZEJsb2JzKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBuZXcgVWludDhBcnJheSgxKTtcbiAgbGVuZ3RoWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIHZhciBibG9iID0gbmV3IEJsb2IoW2xlbmd0aC5idWZmZXIsIHBhY2tldC5kYXRhXSk7XG5cbiAgcmV0dXJuIGNhbGxiYWNrKGJsb2IpO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQgd2l0aCBiaW5hcnkgZGF0YSBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcbiAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBjYWxsYmFjaykge1xuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gIGlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGJ0b2EoYjY0ZGF0YSk7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG4gIC8vIFN0cmluZyBkYXRhXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT09ICdiJykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLCBiaW5hcnlUeXBlKTtcbiAgICB9XG5cbiAgICBpZiAodXRmOGRlY29kZSkge1xuICAgICAgZGF0YSA9IHRyeURlY29kZShkYXRhKTtcbiAgICAgIGlmIChkYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuXG4gICAgaWYgKE51bWJlcih0eXBlKSAhPSB0eXBlIHx8ICFwYWNrZXRzbGlzdFt0eXBlXSkge1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zdWJzdHJpbmcoMSkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0gfTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXNBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgdHlwZSA9IGFzQXJyYXlbMF07XG4gIHZhciByZXN0ID0gc2xpY2VCdWZmZXIoZGF0YSwgMSk7XG4gIGlmIChCbG9iICYmIGJpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgIHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiByZXN0IH07XG59O1xuXG5mdW5jdGlvbiB0cnlEZWNvZGUoZGF0YSkge1xuICB0cnkge1xuICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuXG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICBpZiAoIWJhc2U2NGVuY29kZXIpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG4gIH1cblxuICB2YXIgZGF0YSA9IGJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO1xuXG4gIGlmIChiaW5hcnlUeXBlID09PSAnYmxvYicgJiYgQmxvYikge1xuICAgIGRhdGEgPSBuZXcgQmxvYihbZGF0YV0pO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKS5cbiAqXG4gKiAgICAgPGxlbmd0aD46ZGF0YVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDExOmhlbGxvIHdvcmxkMjpoaVxuICpcbiAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG4gKiBlbmNvZGVkIHN0cmluZ3MgYXJlIG1hcmtlZCB3aXRoIGEgYiBiZWZvcmUgdGhlIGxlbmd0aCBzcGVjaWZpZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBmdW5jdGlvbiAocGFja2V0cywgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpc0JpbmFyeSA9IGhhc0JpbmFyeShwYWNrZXRzKTtcblxuICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcbiAgICBpZiAoQmxvYiAmJiAhZG9udFNlbmRCbG9icykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYihwYWNrZXRzLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIocGFja2V0cywgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoICsgJzonICsgbWVzc2FnZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgIWlzQmluYXJ5ID8gZmFsc2UgOiBzdXBwb3J0c0JpbmFyeSwgZmFsc2UsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG4gKi9cblxuZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXG4gIHZhciBlYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24oaSwgZWwsIGNiKSB7XG4gICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuICAgICAgcmVzdWx0W2ldID0gbXNnO1xuICAgICAgY2IoZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG4gIH1cbn1cblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHBhY2tldDtcbiAgaWYgKGRhdGEgPT09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9ICcnLCBuLCBtc2c7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcblxuICAgIGlmIChjaHIgIT09ICc6Jykge1xuICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGggPT09ICcnIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG5cbiAgICBpZiAobGVuZ3RoICE9IG1zZy5sZW5ndGgpIHtcbiAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgIH1cblxuICAgIGlmIChtc2cubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIGZhbHNlKTtcblxuICAgICAgaWYgKGVyci50eXBlID09PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKHBhY2tldCwgaSArIG4sIGwpO1xuICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgIGkgKz0gbjtcbiAgICBsZW5ndGggPSAnJztcbiAgfVxuXG4gIGlmIChsZW5ndGggIT09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuICpcbiAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcbiAqIDI1NT48ZGF0YT5cbiAqXG4gKiBFeGFtcGxlOlxuICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCBlbmNvZGVkUGFja2V0cykge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IGVuY29kZWRQYWNrZXRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHApIHtcbiAgICAgIHZhciBsZW47XG4gICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgbGVuID0gcC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSBwLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuICAgIH0sIDApO1xuXG4gICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG4gICAgdmFyIGJ1ZmZlckluZGV4ID0gMDtcbiAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgICAgIHZhciBhYiA9IHA7XG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShwLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYWIgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKSB7IC8vIG5vdCB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG4gICAgICB9IGVsc2UgeyAvLyB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5TdHIgPSBhYi5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblxuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSB2aWV3W2ldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFbmNvZGUgYXMgQmxvYlxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYiA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgdmFyIGJpbmFyeUlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAxO1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVkID0gdmlldy5idWZmZXI7XG4gICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gKGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgPyBlbmNvZGVkLmJ5dGVMZW5ndGhcbiAgICAgICAgOiBlbmNvZGVkLnNpemU7XG5cbiAgICAgIHZhciBsZW5TdHIgPSBsZW4udG9TdHJpbmcoKTtcbiAgICAgIHZhciBsZW5ndGhBcnkgPSBuZXcgVWludDhBcnJheShsZW5TdHIubGVuZ3RoICsgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGhBcnlbaV0gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXG4gICAgICBpZiAoQmxvYikge1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgYmxvYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IocmVzdWx0cykpO1xuICB9KTtcbn07XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcbiAqIGludGVycHJldGluZyBlYWNoIGJ5dGUgYXMgYSBrZXkgY29kZSBmb3IgZW50cmllcyBtYXJrZWQgdG8gc3RhcnQgd2l0aCAwLiBTZWVcbiAqIGRlc2NyaXB0aW9uIG9mIGVuY29kZVBheWxvYWRBc0JpbmFyeVxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gIHZhciBidWZmZXJzID0gW107XG5cbiAgd2hpbGUgKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG4gICAgdmFyIGlzU3RyaW5nID0gdGFpbEFycmF5WzBdID09PSAwO1xuICAgIHZhciBtc2dMZW5ndGggPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAxOyA7IGkrKykge1xuICAgICAgaWYgKHRhaWxBcnJheVtpXSA9PT0gMjU1KSBicmVhaztcblxuICAgICAgLy8gMzEwID0gY2hhciBsZW5ndGggb2YgTnVtYmVyLk1BWF9WQUxVRVxuICAgICAgaWYgKG1zZ0xlbmd0aC5sZW5ndGggPiAzMTApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIG1zZ0xlbmd0aCArPSB0YWlsQXJyYXlbaV07XG4gICAgfVxuXG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDIgKyBtc2dMZW5ndGgubGVuZ3RoKTtcbiAgICBtc2dMZW5ndGggPSBwYXJzZUludChtc2dMZW5ndGgpO1xuXG4gICAgdmFyIG1zZyA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDAsIG1zZ0xlbmd0aCk7XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtc2cgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KG1zZykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB0byB0eXBlZCBhcnJheXNcbiAgICAgICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkobXNnKTtcbiAgICAgICAgbXNnID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtc2cgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0eXBlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmZXJzLnB1c2gobXNnKTtcbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmZmVyLCBpKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy5kZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlLCB0cnVlKSwgaSwgdG90YWwpO1xuICB9KTtcbn07XG4iLCJcbi8qKlxuICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuICAgICAgYXJyLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMS4yIGJ5IEBtYXRoaWFzICovXG5cbnZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0dmFyIG91dHB1dCA9IFtdO1xuXHR2YXIgY291bnRlciA9IDA7XG5cdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHR2YXIgdmFsdWU7XG5cdHZhciBleHRyYTtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5mdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHZhciBpbmRleCA9IC0xO1xuXHR2YXIgdmFsdWU7XG5cdHZhciBvdXRwdXQgPSAnJztcblx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHR9XG5cdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB7XG5cdFx0aWYgKHN0cmljdCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5mdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcblx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpIHtcblx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0fVxuXHR2YXIgc3ltYm9sID0gJyc7XG5cdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHR9XG5cdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7IC8vIDMtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICghY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkpIHtcblx0XHRcdGNvZGVQb2ludCA9IDB4RkZGRDtcblx0XHR9XG5cdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0fVxuXHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcblx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHR9XG5cdHN5bWJvbCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoKGNvZGVQb2ludCAmIDB4M0YpIHwgMHg4MCk7XG5cdHJldHVybiBzeW1ib2w7XG59XG5cbmZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nLCBvcHRzKSB7XG5cdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdHZhciBpbmRleCA9IC0xO1xuXHR2YXIgY29kZVBvaW50O1xuXHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KTtcblx0fVxuXHRyZXR1cm4gYnl0ZVN0cmluZztcbn1cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRpZiAoYnl0ZUluZGV4ID49IGJ5dGVDb3VudCkge1xuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0fVxuXG5cdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRieXRlSW5kZXgrKztcblxuXHRpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG5cdFx0cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUgJiAweDNGO1xuXHR9XG5cblx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVTeW1ib2woc3RyaWN0KSB7XG5cdHZhciBieXRlMTtcblx0dmFyIGJ5dGUyO1xuXHR2YXIgYnl0ZTM7XG5cdHZhciBieXRlNDtcblx0dmFyIGNvZGVQb2ludDtcblxuXHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHR9XG5cblx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBSZWFkIGZpcnN0IGJ5dGVcblx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdGJ5dGVJbmRleCsrO1xuXG5cdC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuXHRpZiAoKGJ5dGUxICYgMHg4MCkgPT0gMCkge1xuXHRcdHJldHVybiBieXRlMTtcblx0fVxuXG5cdC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuXHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRyZXR1cm4gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkgPyBjb2RlUG9pbnQgOiAweEZGRkQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MDcpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcblx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdH1cblx0fVxuXG5cdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG59XG5cbnZhciBieXRlQXJyYXk7XG52YXIgYnl0ZUNvdW50O1xudmFyIGJ5dGVJbmRleDtcbmZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZywgb3B0cykge1xuXHRvcHRzID0gb3B0cyB8fCB7fTtcblx0dmFyIHN0cmljdCA9IGZhbHNlICE9PSBvcHRzLnN0cmljdDtcblxuXHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRieXRlSW5kZXggPSAwO1xuXHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHR2YXIgdG1wO1xuXHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbChzdHJpY3QpKSAhPT0gZmFsc2UpIHtcblx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0fVxuXHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHZlcnNpb246ICcyLjEuMicsXG5cdGVuY29kZTogdXRmOGVuY29kZSxcblx0ZGVjb2RlOiB1dGY4ZGVjb2RlXG59O1xuIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/dChleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFwiZXhpZnJcIixbXCJleHBvcnRzXCJdLHQpOnQoKGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczplfHxzZWxmKS5leGlmcj17fSl9KHRoaXMsKGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIG4oZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fWZ1bmN0aW9uIHIoZSx0LHIpe3JldHVybiB0JiZuKGUucHJvdG90eXBlLHQpLHImJm4oZSxyKSxlfWZ1bmN0aW9uIGkoZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfWZ1bmN0aW9uIGEoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pO3ZhciBuPVtcInByb3RvdHlwZVwiLFwiX19wcm90b19fXCIsXCJjYWxsZXJcIixcImFyZ3VtZW50c1wiLFwibGVuZ3RoXCIsXCJuYW1lXCJdO09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpLmZvckVhY2goKGZ1bmN0aW9uKHIpey0xPT09bi5pbmRleE9mKHIpJiZlW3JdIT09dFtyXSYmKGVbcl09dFtyXSl9KSksdCYmdShlLHQpfWZ1bmN0aW9uIHMoZSl7cmV0dXJuKHM9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKX0pKGUpfWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm4odT1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX0pKGUsdCl9ZnVuY3Rpb24gbygpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fWZ1bmN0aW9uIGYoZSx0LG4pe3JldHVybihmPW8oKT9SZWZsZWN0LmNvbnN0cnVjdDpmdW5jdGlvbihlLHQsbil7dmFyIHI9W251bGxdO3IucHVzaC5hcHBseShyLHQpO3ZhciBpPW5ldyhGdW5jdGlvbi5iaW5kLmFwcGx5KGUscikpO3JldHVybiBuJiZ1KGksbi5wcm90b3R5cGUpLGl9KS5hcHBseShudWxsLGFyZ3VtZW50cyl9ZnVuY3Rpb24gYyhlKXt2YXIgdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBNYXA/bmV3IE1hcDp2b2lkIDA7cmV0dXJuKGM9ZnVuY3Rpb24oZSl7aWYobnVsbD09PWV8fChuPWUsLTE9PT1GdW5jdGlvbi50b1N0cmluZy5jYWxsKG4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpKSlyZXR1cm4gZTt2YXIgbjtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtpZih2b2lkIDAhPT10KXtpZih0LmhhcyhlKSlyZXR1cm4gdC5nZXQoZSk7dC5zZXQoZSxyKX1mdW5jdGlvbiByKCl7cmV0dXJuIGYoZSxhcmd1bWVudHMscyh0aGlzKS5jb25zdHJ1Y3Rvcil9cmV0dXJuIHIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpyLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHUocixlKX0pKGUpfWZ1bmN0aW9uIGgoZSl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIGV9ZnVuY3Rpb24gbChlLHQpe3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9oKGUpOnR9ZnVuY3Rpb24gZChlKXt2YXIgdD1vKCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG4scj1zKGUpO2lmKHQpe3ZhciBpPXModGhpcykuY29uc3RydWN0b3I7bj1SZWZsZWN0LmNvbnN0cnVjdChyLGFyZ3VtZW50cyxpKX1lbHNlIG49ci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGwodGhpcyxuKX19ZnVuY3Rpb24gdihlLHQsbil7cmV0dXJuKHY9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3QuZ2V0P1JlZmxlY3QuZ2V0OmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1mdW5jdGlvbihlLHQpe2Zvcig7IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpJiZudWxsIT09KGU9cyhlKSk7KTtyZXR1cm4gZX0oZSx0KTtpZihyKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsdCk7cmV0dXJuIGkuZ2V0P2kuZ2V0LmNhbGwobik6aS52YWx1ZX19KShlLHQsbnx8ZSl9dmFyIHA9T2JqZWN0LnZhbHVlc3x8ZnVuY3Rpb24oZSl7dmFyIHQ9W107Zm9yKHZhciBuIGluIGUpdC5wdXNoKGVbbl0pO3JldHVybiB0fSx5PU9iamVjdC5lbnRyaWVzfHxmdW5jdGlvbihlKXt2YXIgdD1bXTtmb3IodmFyIG4gaW4gZSl0LnB1c2goW24sZVtuXV0pO3JldHVybiB0fSxnPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQ+MT90LTE6MCkscj0xO3I8dDtyKyspbltyLTFdPWFyZ3VtZW50c1tyXTtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXtmb3IodmFyIG4gaW4gdCllW25dPXRbbl19KSksZX0saz1PYmplY3QuZnJvbUVudHJpZXN8fGZ1bmN0aW9uKGUpe3ZhciB0PXt9O3JldHVybiBtKGUpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWVbMF0scj1lWzFdO3Rbbl09cn0pKSx0fSxtPUFycmF5LmZyb218fGZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBQKXt2YXIgdD1bXTtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbihlLG4pe3JldHVybiB0LnB1c2goW24sZV0pfSkpLHR9cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUpfTtmdW5jdGlvbiBiKGUpe3JldHVybi0xIT09dGhpcy5pbmRleE9mKGUpfUFycmF5LnByb3RvdHlwZS5pbmNsdWRlc3x8KEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcz1iKSxTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzfHwoU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcz1iKSxTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGh8fChTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGg9ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjA7cmV0dXJuIHRoaXMuc3Vic3RyaW5nKHQsdCtlLmxlbmd0aCk9PT1lfSksU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aHx8KFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGg9ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGVuZ3RoO3JldHVybiB0aGlzLnN1YnN0cmluZyh0LWUubGVuZ3RoLHQpPT09ZX0pO3ZhciBBPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6Z2xvYmFsLHc9QS5mZXRjaHx8ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24obixyKXt2YXIgaT1uZXcgWE1MSHR0cFJlcXVlc3Q7aWYoaS5vcGVuKFwiZ2V0XCIsZSwhMCksaS5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGkub25lcnJvcj1yLHQuaGVhZGVycylmb3IodmFyIGEgaW4gdC5oZWFkZXJzKWkuc2V0UmVxdWVzdEhlYWRlcihhLHQuaGVhZGVyc1thXSk7aS5vbmxvYWQ9ZnVuY3Rpb24oKXtuKHtvazppLnN0YXR1cz49MjAwJiZpLnN0YXR1czwzMDAsc3RhdHVzOmkuc3RhdHVzLGFycmF5QnVmZmVyOmZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShpLnJlc3BvbnNlKX19KX0saS5zZW5kKG51bGwpfSkpfSxPPWZ1bmN0aW9uKGUpe3ZhciB0PVtdO2lmKE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQse3NpemU6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxlbmd0aH19LGhhczp7dmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuLTEhPT10aGlzLmluZGV4T2YoZSl9fSxhZGQ6e3ZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuaGFzKGUpfHx0aGlzLnB1c2goZSl9fSxkZWxldGU6e3ZhbHVlOmZ1bmN0aW9uKGUpe2lmKHRoaXMuaGFzKGUpKXt2YXIgdD10aGlzLmluZGV4T2YoZSk7dGhpcy5zcGxpY2UodCwxKX19fX0pLEFycmF5LmlzQXJyYXkoZSkpZm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspdC5hZGQoZVtuXSk7cmV0dXJuIHR9LFM9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBQKGUpfSxQPXZvaWQgMCE9PUEuTWFwJiZ2b2lkIDAhPT1BLk1hcC5wcm90b3R5cGUua2V5cz9BLk1hcDpmdW5jdGlvbigpe2Z1bmN0aW9uIGUobil7aWYodCh0aGlzLGUpLHRoaXMuY2xlYXIoKSxuKWZvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXRoaXMuc2V0KG5bcl1bMF0sbltyXVsxXSl9cmV0dXJuIHIoZSxbe2tleTpcImNsZWFyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9tYXA9e30sdGhpcy5fa2V5cz1bXX19LHtrZXk6XCJzaXplXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2tleXMubGVuZ3RofX0se2tleTpcImdldFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9tYXBbXCJtYXBfXCIrZV19fSx7a2V5Olwic2V0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5fbWFwW1wibWFwX1wiK2VdPXQsdGhpcy5fa2V5cy5pbmRleE9mKGUpPDAmJnRoaXMuX2tleXMucHVzaChlKSx0aGlzfX0se2tleTpcImhhc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9rZXlzLmluZGV4T2YoZSk+PTB9fSx7a2V5OlwiZGVsZXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5fa2V5cy5pbmRleE9mKGUpO3JldHVybiEodDwwKSYmKGRlbGV0ZSB0aGlzLl9tYXBbXCJtYXBfXCIrZV0sdGhpcy5fa2V5cy5zcGxpY2UodCwxKSwhMCl9fSx7a2V5Olwia2V5c1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2tleXMuc2xpY2UoMCl9fSx7a2V5OlwidmFsdWVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiB0aGlzLl9rZXlzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGUuZ2V0KHQpfSkpfX0se2tleTpcImVudHJpZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIHRoaXMuX2tleXMubWFwKChmdW5jdGlvbih0KXtyZXR1cm5bdCxlLmdldCh0KV19KSl9fSx7a2V5OlwiZm9yRWFjaFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPTA7bjx0aGlzLl9rZXlzLmxlbmd0aDtuKyspZS5jYWxsKHQsdGhpcy5fbWFwW1wibWFwX1wiK3RoaXMuX2tleXNbbl1dLHRoaXMuX2tleXNbbl0sdGhpcyl9fV0pLGV9KCksVT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOmdsb2JhbCx4PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3IsQz14JiZcInVuZGVmaW5lZFwiPT10eXBlb2YgSFRNTEltYWdlRWxlbWVudCxCPSEoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGdsb2JhbHx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIHByb2Nlc3N8fCFwcm9jZXNzLnZlcnNpb25zfHwhcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSxqPVUuQnVmZmVyLF89ISFqO3ZhciBWPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT1lfTtmdW5jdGlvbiBJKGUpe3JldHVybiB2b2lkIDA9PT1lfHwoZSBpbnN0YW5jZW9mIFA/MD09PWUuc2l6ZTowPT09cChlKS5maWx0ZXIoVikubGVuZ3RoKX1mdW5jdGlvbiBMKGUpe3ZhciB0PW5ldyBFcnJvcihlKTt0aHJvdyBkZWxldGUgdC5zdGFjayx0fWZ1bmN0aW9uIFQoZSl7dmFyIHQ9ZnVuY3Rpb24oZSl7dmFyIHQ9MDtyZXR1cm4gZS5pZmQwLmVuYWJsZWQmJih0Kz0xMDI0KSxlLmV4aWYuZW5hYmxlZCYmKHQrPTIwNDgpLGUubWFrZXJOb3RlJiYodCs9MjA0OCksZS51c2VyQ29tbWVudCYmKHQrPTEwMjQpLGUuZ3BzLmVuYWJsZWQmJih0Kz01MTIpLGUuaW50ZXJvcC5lbmFibGVkJiYodCs9MTAwKSxlLmlmZDEuZW5hYmxlZCYmKHQrPTEwMjQpLHQrMjA0OH0oZSk7cmV0dXJuIGUuamZpZi5lbmFibGVkJiYodCs9NTApLGUueG1wLmVuYWJsZWQmJih0Kz0yZTQpLGUuaXB0Yy5lbmFibGVkJiYodCs9MTRlMyksZS5pY2MuZW5hYmxlZCYmKHQrPTZlMyksdH12YXIgej1mdW5jdGlvbihlKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLGUpfSxGPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTp2b2lkIDA7ZnVuY3Rpb24gRShlKXtyZXR1cm4gRj9GLmRlY29kZShlKTpfP0J1ZmZlci5mcm9tKGUpLnRvU3RyaW5nKFwidXRmOFwiKTpkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHooZSkpKX12YXIgRD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUobil7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjAsaT1hcmd1bWVudHMubGVuZ3RoPjI/YXJndW1lbnRzWzJdOnZvaWQgMCxhPWFyZ3VtZW50cy5sZW5ndGg+Mz9hcmd1bWVudHNbM106dm9pZCAwO2lmKHQodGhpcyxlKSxcImJvb2xlYW5cIj09dHlwZW9mIGEmJih0aGlzLmxlPWEpLEFycmF5LmlzQXJyYXkobikmJihuPW5ldyBVaW50OEFycmF5KG4pKSwwPT09bil0aGlzLmJ5dGVPZmZzZXQ9MCx0aGlzLmJ5dGVMZW5ndGg9MDtlbHNlIGlmKG4gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7dm9pZCAwPT09aSYmKGk9bi5ieXRlTGVuZ3RoLXIpO3ZhciBzPW5ldyBEYXRhVmlldyhuLHIsaSk7dGhpcy5fc3dhcERhdGFWaWV3KHMpfWVsc2UgaWYobiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fG4gaW5zdGFuY2VvZiBEYXRhVmlld3x8biBpbnN0YW5jZW9mIGUpe3ZvaWQgMD09PWkmJihpPW4uYnl0ZUxlbmd0aC1yKSwocis9bi5ieXRlT2Zmc2V0KStpPm4uYnl0ZU9mZnNldCtuLmJ5dGVMZW5ndGgmJkwoXCJDcmVhdGluZyB2aWV3IG91dHNpZGUgb2YgYXZhaWxhYmxlIG1lbW9yeSBpbiBBcnJheUJ1ZmZlclwiKTt2YXIgdT1uZXcgRGF0YVZpZXcobi5idWZmZXIscixpKTt0aGlzLl9zd2FwRGF0YVZpZXcodSl9ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2Ygbil7dmFyIG89bmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcihuKSk7dGhpcy5fc3dhcERhdGFWaWV3KG8pfWVsc2UgTChcIkludmFsaWQgaW5wdXQgYXJndW1lbnQgZm9yIEJ1ZmZlclZpZXc6IFwiK24pfXJldHVybiByKGUsW3trZXk6XCJfc3dhcEFycmF5QnVmZmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fc3dhcERhdGFWaWV3KG5ldyBEYXRhVmlldyhlKSl9fSx7a2V5OlwiX3N3YXBCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLl9zd2FwRGF0YVZpZXcobmV3IERhdGFWaWV3KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxlLmJ5dGVMZW5ndGgpKX19LHtrZXk6XCJfc3dhcERhdGFWaWV3XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5kYXRhVmlldz1lLHRoaXMuYnVmZmVyPWUuYnVmZmVyLHRoaXMuYnl0ZU9mZnNldD1lLmJ5dGVPZmZzZXQsdGhpcy5ieXRlTGVuZ3RoPWUuYnl0ZUxlbmd0aH19LHtrZXk6XCJfbGVuZ3RoVG9FbmRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5ieXRlTGVuZ3RoLWV9fSx7a2V5Olwic2V0XCIsdmFsdWU6ZnVuY3Rpb24odCxuKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06ZTt0IGluc3RhbmNlb2YgRGF0YVZpZXd8fHQgaW5zdGFuY2VvZiBlP3Q9bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCk6dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJiYodD1uZXcgVWludDhBcnJheSh0KSksdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fEwoXCJCdWZmZXJWaWV3LnNldCgpOiBJbnZhbGlkIGRhdGEgYXJndW1lbnQuXCIpO3ZhciBpPXRoaXMudG9VaW50OCgpO3JldHVybiBpLnNldCh0LG4pLG5ldyByKHRoaXMsbix0LmJ5dGVMZW5ndGgpfX0se2tleTpcInN1YmFycmF5XCIsdmFsdWU6ZnVuY3Rpb24odCxuKXtyZXR1cm4gbmV3IGUodGhpcyx0LG49bnx8dGhpcy5fbGVuZ3RoVG9FbmQodCkpfX0se2tleTpcInRvVWludDhcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcix0aGlzLmJ5dGVPZmZzZXQsdGhpcy5ieXRlTGVuZ3RoKX19LHtrZXk6XCJnZXRVaW50OEFycmF5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsdGhpcy5ieXRlT2Zmc2V0K2UsdCl9fSx7a2V5OlwiZ2V0U3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MCx0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmJ5dGVMZW5ndGgsbj10aGlzLmdldFVpbnQ4QXJyYXkoZSx0KTtyZXR1cm4gRShuKX19LHtrZXk6XCJnZXRMYXRpbjFTdHJpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTowLHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMuYnl0ZUxlbmd0aCxuPXRoaXMuZ2V0VWludDhBcnJheShlLHQpO3JldHVybiB6KG4pfX0se2tleTpcImdldFVuaWNvZGVTdHJpbmdcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MCx0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmJ5dGVMZW5ndGgsbj1bXSxyPTA7cjx0JiZlK3I8dGhpcy5ieXRlTGVuZ3RoO3IrPTIpbi5wdXNoKHRoaXMuZ2V0VWludDE2KGUrcikpO3JldHVybiB6KG4pfX0se2tleTpcImdldEludDhcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRJbnQ4KGUpfX0se2tleTpcImdldFVpbnQ4XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0VWludDgoZSl9fSx7a2V5OlwiZ2V0SW50MTZcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5sZTtyZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRJbnQxNihlLHQpfX0se2tleTpcImdldEludDMyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0SW50MzIoZSx0KX19LHtrZXk6XCJnZXRVaW50MTZcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5sZTtyZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRVaW50MTYoZSx0KX19LHtrZXk6XCJnZXRVaW50MzJcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5sZTtyZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRVaW50MzIoZSx0KX19LHtrZXk6XCJnZXRGbG9hdDMyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0RmxvYXQzMihlLHQpfX0se2tleTpcImdldEZsb2F0NjRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5sZTtyZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRGbG9hdDY0KGUsdCl9fSx7a2V5OlwiZ2V0RmxvYXRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5sZTtyZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRGbG9hdDMyKGUsdCl9fSx7a2V5OlwiZ2V0RG91YmxlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0RmxvYXQ2NChlLHQpfX0se2tleTpcImdldFVpbnRCeXRlc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtzd2l0Y2godCl7Y2FzZSAxOnJldHVybiB0aGlzLmdldFVpbnQ4KGUsbik7Y2FzZSAyOnJldHVybiB0aGlzLmdldFVpbnQxNihlLG4pO2Nhc2UgNDpyZXR1cm4gdGhpcy5nZXRVaW50MzIoZSxuKTtjYXNlIDg6cmV0dXJuIHRoaXMuZ2V0VWludDY0JiZ0aGlzLmdldFVpbnQ2NChlLG4pfX19LHtrZXk6XCJnZXRVaW50XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3N3aXRjaCh0KXtjYXNlIDg6cmV0dXJuIHRoaXMuZ2V0VWludDgoZSxuKTtjYXNlIDE2OnJldHVybiB0aGlzLmdldFVpbnQxNihlLG4pO2Nhc2UgMzI6cmV0dXJuIHRoaXMuZ2V0VWludDMyKGUsbik7Y2FzZSA2NDpyZXR1cm4gdGhpcy5nZXRVaW50NjQmJnRoaXMuZ2V0VWludDY0KGUsbil9fX0se2tleTpcInRvU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGF0YVZpZXcudG9TdHJpbmcoZSx0aGlzLmNvbnN0cnVjdG9yLm5hbWUpfX0se2tleTpcImVuc3VyZUNodW5rXCIsdmFsdWU6ZnVuY3Rpb24oKXt9fV0sW3trZXk6XCJmcm9tXCIsdmFsdWU6ZnVuY3Rpb24odCxuKXtyZXR1cm4gdCBpbnN0YW5jZW9mIHRoaXMmJnQubGU9PT1uP3Q6bmV3IGUodCx2b2lkIDAsdm9pZCAwLG4pfX1dKSxlfSgpO2Z1bmN0aW9uIFIoZSx0KXtMKFwiXCIuY29uY2F0KGUsXCIgJ1wiKS5jb25jYXQodCxcIicgd2FzIG5vdCBsb2FkZWQsIHRyeSB1c2luZyBmdWxsIGJ1aWxkIG9mIGV4aWZyLlwiKSl9dmFyIE49ZnVuY3Rpb24oZSl7YShpLGUpO3ZhciBuPWQoaSk7ZnVuY3Rpb24gaShlKXt2YXIgcjtyZXR1cm4gdCh0aGlzLGkpLChyPW4uY2FsbCh0aGlzKSkua2luZD1lLHJ9cmV0dXJuIHIoaSxbe2tleTpcImdldFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuaGFzKGUpfHxSKHRoaXMua2luZCxlKSx0JiYoZSBpbiB0fHxmdW5jdGlvbihlLHQpe0woXCJVbmtub3duIFwiLmNvbmNhdChlLFwiICdcIikuY29uY2F0KHQsXCInLlwiKSl9KHRoaXMua2luZCxlKSx0W2VdLmVuYWJsZWR8fFIodGhpcy5raW5kLGUpKSx2KHMoaS5wcm90b3R5cGUpLFwiZ2V0XCIsdGhpcykuY2FsbCh0aGlzLGUpfX0se2tleTpcImtleUxpc3RcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBtKHRoaXMua2V5cygpKX19XSksaX0oYyhQKSksTT1uZXcgTihcImZpbGUgcGFyc2VyXCIpLFc9bmV3IE4oXCJzZWdtZW50IHBhcnNlclwiKSxLPW5ldyBOKFwiZmlsZSByZWFkZXJcIik7ZnVuY3Rpb24gSChlKXtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sbj0wO248YXJndW1lbnRzLmxlbmd0aDtuKyspdFtuXT1hcmd1bWVudHNbbl07dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoZS5hcHBseSh0aGlzLHQpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX1mdW5jdGlvbiBYKGUsdCxuKXtyZXR1cm4gbj90P3QoZSk6ZTooZSYmZS50aGVufHwoZT1Qcm9taXNlLnJlc29sdmUoZSkpLHQ/ZS50aGVuKHQpOmUpfXZhciBZPUgoKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxuKXt2YXIgcj1uZXcgRmlsZVJlYWRlcjtyLm9ubG9hZGVuZD1mdW5jdGlvbigpe3JldHVybiB0KHIucmVzdWx0fHxuZXcgQXJyYXlCdWZmZXIpfSxyLm9uZXJyb3I9bixyLnJlYWRBc0FycmF5QnVmZmVyKGUpfSkpfSkpLEc9SCgoZnVuY3Rpb24oZSl7cmV0dXJuIHcoZSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXJyYXlCdWZmZXIoKX0pKX0pKSxKPUgoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIFgodChlKSwoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBEKGUpfSkpfSkpLHE9SCgoZnVuY3Rpb24oZSx0LG4pe3ZhciByPW5ldyhLLmdldChuKSkoZSx0KTtyZXR1cm4gWChyLnJlYWQoKSwoZnVuY3Rpb24oKXtyZXR1cm4gcn0pKX0pKSxRPUgoKGZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBLLmhhcyhuKT9xKGUsdCxuKTpyP0ooZSxyKTooTChcIlBhcnNlciBcIi5jb25jYXQobixcIiBpcyBub3QgbG9hZGVkXCIpKSxYKCkpfSkpLFo9XCJJbnZhbGlkIGlucHV0IGFyZ3VtZW50XCI7ZnVuY3Rpb24gJChlLHQpe3JldHVybihuPWUpLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKXx8bi5sZW5ndGg+MWU0P3EoZSx0LFwiYmFzZTY0XCIpOng/UShlLHQsXCJ1cmxcIixHKTpCP3EoZSx0LFwiZnNcIik6dm9pZCBMKFopO3ZhciBufXZhciBlZT1mdW5jdGlvbihlKXthKGksZSk7dmFyIG49ZChpKTtmdW5jdGlvbiBpKCl7cmV0dXJuIHQodGhpcyxpKSxuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gcihpLFt7a2V5OlwidGFnS2V5c1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmFsbEtleXN8fCh0aGlzLmFsbEtleXM9bSh0aGlzLmtleXMoKSkpLHRoaXMuYWxsS2V5c319LHtrZXk6XCJ0YWdWYWx1ZXNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbGxWYWx1ZXN8fCh0aGlzLmFsbFZhbHVlcz1tKHRoaXMudmFsdWVzKCkpKSx0aGlzLmFsbFZhbHVlc319XSksaX0oYyhQKSk7ZnVuY3Rpb24gdGUoZSx0LG4pe3ZhciByPW5ldyBlZSxpPW47QXJyYXkuaXNBcnJheShpKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGkuZW50cmllcyYmKGk9aS5lbnRyaWVzKCkpLGk9bShpKSk7Zm9yKHZhciBhPTA7YTxpLmxlbmd0aDthKyspe3ZhciBzPWlbYV0sdT1zWzBdLG89c1sxXTtyLnNldCh1LG8pfWlmKEFycmF5LmlzQXJyYXkodCkpe3ZhciBmPXQ7QXJyYXkuaXNBcnJheShmKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGYuZW50cmllcyYmKGY9Zi5lbnRyaWVzKCkpLGY9bShmKSk7Zm9yKHZhciBjPTA7YzxmLmxlbmd0aDtjKyspe3ZhciBoPWZbY107ZS5zZXQoaCxyKX19ZWxzZSBlLnNldCh0LHIpO3JldHVybiByfWZ1bmN0aW9uIG5lKGUsdCxuKXt2YXIgcixpPWUuZ2V0KHQpLGE9bjtBcnJheS5pc0FycmF5KGEpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgYS5lbnRyaWVzJiYoYT1hLmVudHJpZXMoKSksYT1tKGEpKTtmb3IodmFyIHM9MDtzPGEubGVuZ3RoO3MrKylyPWFbc10saS5zZXQoclswXSxyWzFdKX12YXIgcmU9UygpLGllPVMoKSxhZT1TKCksc2U9Mzc1MDAsdWU9Mzc1MTAsb2U9MzM3MjMsZmU9MzQ2NzUsY2U9MzQ2NjUsaGU9MzQ4NTMsbGU9NDA5NjUsZGU9W1wiY2h1bmtlZFwiLFwiZmlyc3RDaHVua1NpemVcIixcImZpcnN0Q2h1bmtTaXplTm9kZVwiLFwiZmlyc3RDaHVua1NpemVCcm93c2VyXCIsXCJjaHVua1NpemVcIixcImNodW5rTGltaXRcIl0sdmU9W1wiamZpZlwiLFwieG1wXCIsXCJpY2NcIixcImlwdGNcIixcImloZHJcIl0scGU9W1widGlmZlwiXS5jb25jYXQodmUpLHllPVtcImlmZDBcIixcImlmZDFcIixcImV4aWZcIixcImdwc1wiLFwiaW50ZXJvcFwiXSxnZT1bXS5jb25jYXQocGUseWUpLGtlPVtcIm1ha2VyTm90ZVwiLFwidXNlckNvbW1lbnRcIl0sbWU9W1widHJhbnNsYXRlS2V5c1wiLFwidHJhbnNsYXRlVmFsdWVzXCIsXCJyZXZpdmVWYWx1ZXNcIixcIm11bHRpU2VnbWVudFwiXSxiZT1bXS5jb25jYXQobWUsW1wic2FuaXRpemVcIixcIm1lcmdlT3V0cHV0XCIsXCJzaWxlbnRFcnJvcnNcIl0pLEFlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3QodGhpcyxlKX1yZXR1cm4gcihlLFt7a2V5OlwidHJhbnNsYXRlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlS2V5c3x8dGhpcy50cmFuc2xhdGVWYWx1ZXN8fHRoaXMucmV2aXZlVmFsdWVzfX1dKSxlfSgpLHdlPWZ1bmN0aW9uKGUpe2EocyxlKTt2YXIgbj1kKHMpO2Z1bmN0aW9uIHMoZSxyLGEsdSl7dmFyIG87aWYodCh0aGlzLHMpLGkoaChvPW4uY2FsbCh0aGlzKSksXCJlbmFibGVkXCIsITEpLGkoaChvKSxcInNraXBcIixPKCkpLGkoaChvKSxcInBpY2tcIixPKCkpLGkoaChvKSxcImRlcHNcIixPKCkpLGkoaChvKSxcInRyYW5zbGF0ZUtleXNcIiwhMSksaShoKG8pLFwidHJhbnNsYXRlVmFsdWVzXCIsITEpLGkoaChvKSxcInJldml2ZVZhbHVlc1wiLCExKSxvLmtleT1lLG8uZW5hYmxlZD1yLG8ucGFyc2U9by5lbmFibGVkLG8uYXBwbHlJbmhlcml0YWJsZXModSksby5jYW5CZUZpbHRlcmVkPXllLmluY2x1ZGVzKGUpLG8uY2FuQmVGaWx0ZXJlZCYmKG8uZGljdD1yZS5nZXQoZSkpLHZvaWQgMCE9PWEpaWYoQXJyYXkuaXNBcnJheShhKSlvLnBhcnNlPW8uZW5hYmxlZD0hMCxvLmNhbkJlRmlsdGVyZWQmJmEubGVuZ3RoPjAmJm8udHJhbnNsYXRlVGFnU2V0KGEsby5waWNrKTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBhKXtpZihvLmVuYWJsZWQ9ITAsby5wYXJzZT0hMSE9PWEucGFyc2Usby5jYW5CZUZpbHRlcmVkKXt2YXIgZj1hLnBpY2ssYz1hLnNraXA7ZiYmZi5sZW5ndGg+MCYmby50cmFuc2xhdGVUYWdTZXQoZixvLnBpY2spLGMmJmMubGVuZ3RoPjAmJm8udHJhbnNsYXRlVGFnU2V0KGMsby5za2lwKX1vLmFwcGx5SW5oZXJpdGFibGVzKGEpfWVsc2UhMD09PWF8fCExPT09YT9vLnBhcnNlPW8uZW5hYmxlZD1hOkwoXCJJbnZhbGlkIG9wdGlvbnMgYXJndW1lbnQ6IFwiLmNvbmNhdChhKSk7cmV0dXJuIG99cmV0dXJuIHIocyxbe2tleTpcIm5lZWRlZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR8fHRoaXMuZGVwcy5zaXplPjB9fSx7a2V5OlwiYXBwbHlJbmhlcml0YWJsZXNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdCxuLHI9bWU7QXJyYXkuaXNBcnJheShyKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHIuZW50cmllcyYmKHI9ci5lbnRyaWVzKCkpLHI9bShyKSk7Zm9yKHZhciBpPTA7aTxyLmxlbmd0aDtpKyspdm9pZCAwIT09KG49ZVt0PXJbaV1dKSYmKHRoaXNbdF09bil9fSx7a2V5OlwidHJhbnNsYXRlVGFnU2V0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZih0aGlzLmRpY3Qpe3ZhciBuLHIsaT10aGlzLmRpY3QsYT1pLnRhZ0tleXMscz1pLnRhZ1ZhbHVlcyx1PWU7QXJyYXkuaXNBcnJheSh1KXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHUuZW50cmllcyYmKHU9dS5lbnRyaWVzKCkpLHU9bSh1KSk7Zm9yKHZhciBvPTA7bzx1Lmxlbmd0aDtvKyspXCJzdHJpbmdcIj09dHlwZW9mKG49dVtvXSk/KC0xPT09KHI9cy5pbmRleE9mKG4pKSYmKHI9YS5pbmRleE9mKE51bWJlcihuKSkpLC0xIT09ciYmdC5hZGQoTnVtYmVyKGFbcl0pKSk6dC5hZGQobil9ZWxzZXt2YXIgZj1lO0FycmF5LmlzQXJyYXkoZil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBmLmVudHJpZXMmJihmPWYuZW50cmllcygpKSxmPW0oZikpO2Zvcih2YXIgYz0wO2M8Zi5sZW5ndGg7YysrKXt2YXIgaD1mW2NdO3QuYWRkKGgpfX19fSx7a2V5OlwiZmluYWxpemVGaWx0ZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXshdGhpcy5lbmFibGVkJiZ0aGlzLmRlcHMuc2l6ZT4wPyh0aGlzLmVuYWJsZWQ9ITAsQ2UodGhpcy5waWNrLHRoaXMuZGVwcykpOnRoaXMuZW5hYmxlZCYmdGhpcy5waWNrLnNpemU+MCYmQ2UodGhpcy5waWNrLHRoaXMuZGVwcyl9fV0pLHN9KEFlKSxPZT17amZpZjohMSx0aWZmOiEwLHhtcDohMSxpY2M6ITEsaXB0YzohMSxpZmQwOiEwLGlmZDE6ITEsZXhpZjohMCxncHM6ITAsaW50ZXJvcDohMSxpaGRyOnZvaWQgMCxtYWtlck5vdGU6ITEsdXNlckNvbW1lbnQ6ITEsbXVsdGlTZWdtZW50OiExLHNraXA6W10scGljazpbXSx0cmFuc2xhdGVLZXlzOiEwLHRyYW5zbGF0ZVZhbHVlczohMCxyZXZpdmVWYWx1ZXM6ITAsc2FuaXRpemU6ITAsbWVyZ2VPdXRwdXQ6ITAsc2lsZW50RXJyb3JzOiEwLGNodW5rZWQ6ITAsZmlyc3RDaHVua1NpemU6dm9pZCAwLGZpcnN0Q2h1bmtTaXplTm9kZTo1MTIsZmlyc3RDaHVua1NpemVCcm93c2VyOjY1NTM2LGNodW5rU2l6ZTo2NTUzNixjaHVua0xpbWl0OjV9LFNlPVMoKSxQZT1mdW5jdGlvbihlKXthKGksZSk7dmFyIG49ZChpKTtmdW5jdGlvbiBpKGUpe3ZhciByO3JldHVybiB0KHRoaXMsaSkscj1uLmNhbGwodGhpcyksITA9PT1lP3Iuc2V0dXBGcm9tVHJ1ZSgpOnZvaWQgMD09PWU/ci5zZXR1cEZyb21VbmRlZmluZWQoKTpBcnJheS5pc0FycmF5KGUpP3Iuc2V0dXBGcm9tQXJyYXkoZSk6XCJvYmplY3RcIj09dHlwZW9mIGU/ci5zZXR1cEZyb21PYmplY3QoZSk6TChcIkludmFsaWQgb3B0aW9ucyBhcmd1bWVudCBcIi5jb25jYXQoZSkpLHZvaWQgMD09PXIuZmlyc3RDaHVua1NpemUmJihyLmZpcnN0Q2h1bmtTaXplPXg/ci5maXJzdENodW5rU2l6ZUJyb3dzZXI6ci5maXJzdENodW5rU2l6ZU5vZGUpLHIubWVyZ2VPdXRwdXQmJihyLmlmZDEuZW5hYmxlZD0hMSksci5maWx0ZXJOZXN0ZWRTZWdtZW50VGFncygpLHIudHJhdmVyc2VUaWZmRGVwZW5kZW5jeVRyZWUoKSxyLmNoZWNrTG9hZGVkUGx1Z2lucygpLHJ9cmV0dXJuIHIoaSxbe2tleTpcInNldHVwRnJvbVVuZGVmaW5lZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGUsdD1kZTtBcnJheS5pc0FycmF5KHQpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5lbnRyaWVzJiYodD10LmVudHJpZXMoKSksdD1tKHQpKTtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl0aGlzW2U9dFtuXV09T2VbZV07dmFyIHI9YmU7QXJyYXkuaXNBcnJheShyKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHIuZW50cmllcyYmKHI9ci5lbnRyaWVzKCkpLHI9bShyKSk7Zm9yKHZhciBpPTA7aTxyLmxlbmd0aDtpKyspdGhpc1tlPXJbaV1dPU9lW2VdO3ZhciBhPWtlO0FycmF5LmlzQXJyYXkoYSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLmVudHJpZXMmJihhPWEuZW50cmllcygpKSxhPW0oYSkpO2Zvcih2YXIgcz0wO3M8YS5sZW5ndGg7cysrKXRoaXNbZT1hW3NdXT1PZVtlXTt2YXIgdT1nZTtBcnJheS5pc0FycmF5KHUpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgdS5lbnRyaWVzJiYodT11LmVudHJpZXMoKSksdT1tKHUpKTtmb3IodmFyIG89MDtvPHUubGVuZ3RoO28rKyl0aGlzW2U9dVtvXV09bmV3IHdlKGUsT2VbZV0sdm9pZCAwLHRoaXMpfX0se2tleTpcInNldHVwRnJvbVRydWVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlLHQ9ZGU7QXJyYXkuaXNBcnJheSh0KXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZW50cmllcyYmKHQ9dC5lbnRyaWVzKCkpLHQ9bSh0KSk7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspdGhpc1tlPXRbbl1dPU9lW2VdO3ZhciByPWJlO0FycmF5LmlzQXJyYXkocil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiByLmVudHJpZXMmJihyPXIuZW50cmllcygpKSxyPW0ocikpO2Zvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKXRoaXNbZT1yW2ldXT1PZVtlXTt2YXIgYT1rZTtBcnJheS5pc0FycmF5KGEpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgYS5lbnRyaWVzJiYoYT1hLmVudHJpZXMoKSksYT1tKGEpKTtmb3IodmFyIHM9MDtzPGEubGVuZ3RoO3MrKyl0aGlzW2U9YVtzXV09ITA7dmFyIHU9Z2U7QXJyYXkuaXNBcnJheSh1KXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHUuZW50cmllcyYmKHU9dS5lbnRyaWVzKCkpLHU9bSh1KSk7Zm9yKHZhciBvPTA7bzx1Lmxlbmd0aDtvKyspdGhpc1tlPXVbb11dPW5ldyB3ZShlLCEwLHZvaWQgMCx0aGlzKX19LHtrZXk6XCJzZXR1cEZyb21BcnJheVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0LG49ZGU7QXJyYXkuaXNBcnJheShuKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG4uZW50cmllcyYmKG49bi5lbnRyaWVzKCkpLG49bShuKSk7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspdGhpc1t0PW5bcl1dPU9lW3RdO3ZhciBpPWJlO0FycmF5LmlzQXJyYXkoaSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLmVudHJpZXMmJihpPWkuZW50cmllcygpKSxpPW0oaSkpO2Zvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKXRoaXNbdD1pW2FdXT1PZVt0XTt2YXIgcz1rZTtBcnJheS5pc0FycmF5KHMpfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5lbnRyaWVzJiYocz1zLmVudHJpZXMoKSkscz1tKHMpKTtmb3IodmFyIHU9MDt1PHMubGVuZ3RoO3UrKyl0aGlzW3Q9c1t1XV09T2VbdF07dmFyIG89Z2U7QXJyYXkuaXNBcnJheShvKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG8uZW50cmllcyYmKG89by5lbnRyaWVzKCkpLG89bShvKSk7Zm9yKHZhciBmPTA7ZjxvLmxlbmd0aDtmKyspdGhpc1t0PW9bZl1dPW5ldyB3ZSh0LCExLHZvaWQgMCx0aGlzKTt0aGlzLnNldHVwR2xvYmFsRmlsdGVycyhlLHZvaWQgMCx5ZSl9fSx7a2V5Olwic2V0dXBGcm9tT2JqZWN0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ7eWUuaWZkMD15ZS5pZmQwfHx5ZS5pbWFnZSx5ZS5pZmQxPXllLmlmZDF8fHllLnRodW1ibmFpbCxnKHRoaXMsZSk7dmFyIG49ZGU7QXJyYXkuaXNBcnJheShuKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG4uZW50cmllcyYmKG49bi5lbnRyaWVzKCkpLG49bShuKSk7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspdGhpc1t0PW5bcl1dPXhlKGVbdF0sT2VbdF0pO3ZhciBpPWJlO0FycmF5LmlzQXJyYXkoaSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLmVudHJpZXMmJihpPWkuZW50cmllcygpKSxpPW0oaSkpO2Zvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKXRoaXNbdD1pW2FdXT14ZShlW3RdLE9lW3RdKTt2YXIgcz1rZTtBcnJheS5pc0FycmF5KHMpfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5lbnRyaWVzJiYocz1zLmVudHJpZXMoKSkscz1tKHMpKTtmb3IodmFyIHU9MDt1PHMubGVuZ3RoO3UrKyl0aGlzW3Q9c1t1XV09eGUoZVt0XSxPZVt0XSk7dmFyIG89cGU7QXJyYXkuaXNBcnJheShvKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG8uZW50cmllcyYmKG89by5lbnRyaWVzKCkpLG89bShvKSk7Zm9yKHZhciBmPTA7ZjxvLmxlbmd0aDtmKyspdGhpc1t0PW9bZl1dPW5ldyB3ZSh0LE9lW3RdLGVbdF0sdGhpcyk7dmFyIGM9eWU7QXJyYXkuaXNBcnJheShjKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGMuZW50cmllcyYmKGM9Yy5lbnRyaWVzKCkpLGM9bShjKSk7Zm9yKHZhciBoPTA7aDxjLmxlbmd0aDtoKyspdGhpc1t0PWNbaF1dPW5ldyB3ZSh0LE9lW3RdLGVbdF0sdGhpcy50aWZmKTt0aGlzLnNldHVwR2xvYmFsRmlsdGVycyhlLnBpY2ssZS5za2lwLHllLGdlKSwhMD09PWUudGlmZj90aGlzLmJhdGNoRW5hYmxlV2l0aEJvb2woeWUsITApOiExPT09ZS50aWZmP3RoaXMuYmF0Y2hFbmFibGVXaXRoVXNlclZhbHVlKHllLGUpOkFycmF5LmlzQXJyYXkoZS50aWZmKT90aGlzLnNldHVwR2xvYmFsRmlsdGVycyhlLnRpZmYsdm9pZCAwLHllKTpcIm9iamVjdFwiPT10eXBlb2YgZS50aWZmJiZ0aGlzLnNldHVwR2xvYmFsRmlsdGVycyhlLnRpZmYucGljayxlLnRpZmYuc2tpcCx5ZSl9fSx7a2V5OlwiYmF0Y2hFbmFibGVXaXRoQm9vbFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZTtBcnJheS5pc0FycmF5KG4pfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygbi5lbnRyaWVzJiYobj1uLmVudHJpZXMoKSksbj1tKG4pKTtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dGhpc1tuW3JdXS5lbmFibGVkPXR9fX0se2tleTpcImJhdGNoRW5hYmxlV2l0aFVzZXJWYWx1ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZTtBcnJheS5pc0FycmF5KG4pfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygbi5lbnRyaWVzJiYobj1uLmVudHJpZXMoKSksbj1tKG4pKTtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGk9bltyXSxhPXRbaV07dGhpc1tpXS5lbmFibGVkPSExIT09YSYmdm9pZCAwIT09YX19fSx7a2V5Olwic2V0dXBHbG9iYWxGaWx0ZXJzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTpuO2lmKGUmJmUubGVuZ3RoKXt2YXIgaT1yO0FycmF5LmlzQXJyYXkoaSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLmVudHJpZXMmJihpPWkuZW50cmllcygpKSxpPW0oaSkpO2Zvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKXt2YXIgcz1pW2FdO3RoaXNbc10uZW5hYmxlZD0hMX12YXIgdT1VZShlLG4pLG89dTtBcnJheS5pc0FycmF5KG8pfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygby5lbnRyaWVzJiYobz1vLmVudHJpZXMoKSksbz1tKG8pKTtmb3IodmFyIGY9MDtmPG8ubGVuZ3RoO2YrKyl7dmFyIGM9b1tmXSxoPWNbMF0sbD1jWzFdO0NlKHRoaXNbaF0ucGljayxsKSx0aGlzW2hdLmVuYWJsZWQ9ITB9fWVsc2UgaWYodCYmdC5sZW5ndGgpe3ZhciBkPVVlKHQsbiksdj1kO0FycmF5LmlzQXJyYXkodil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiB2LmVudHJpZXMmJih2PXYuZW50cmllcygpKSx2PW0odikpO2Zvcih2YXIgcD0wO3A8di5sZW5ndGg7cCsrKXt2YXIgeT12W3BdLGc9eVswXSxrPXlbMV07Q2UodGhpc1tnXS5za2lwLGspfX19fSx7a2V5OlwiZmlsdGVyTmVzdGVkU2VnbWVudFRhZ3NcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuaWZkMCx0PXRoaXMuZXhpZixuPXRoaXMueG1wLHI9dGhpcy5pcHRjLGk9dGhpcy5pY2M7dGhpcy5tYWtlck5vdGU/dC5kZXBzLmFkZChzZSk6dC5za2lwLmFkZChzZSksdGhpcy51c2VyQ29tbWVudD90LmRlcHMuYWRkKHVlKTp0LnNraXAuYWRkKHVlKSxuLmVuYWJsZWR8fGUuc2tpcC5hZGQoNzAwKSxyLmVuYWJsZWR8fGUuc2tpcC5hZGQob2UpLGkuZW5hYmxlZHx8ZS5za2lwLmFkZChmZSl9fSx7a2V5OlwidHJhdmVyc2VUaWZmRGVwZW5kZW5jeVRyZWVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLmlmZDAsbj10aGlzLmV4aWYscj10aGlzLmdwczt0aGlzLmludGVyb3AubmVlZGVkJiYobi5kZXBzLmFkZChsZSksdC5kZXBzLmFkZChsZSkpLG4ubmVlZGVkJiZ0LmRlcHMuYWRkKGNlKSxyLm5lZWRlZCYmdC5kZXBzLmFkZChoZSksdGhpcy50aWZmLmVuYWJsZWQ9eWUuc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuITA9PT1lW3RdLmVuYWJsZWR9KSl8fHRoaXMubWFrZXJOb3RlfHx0aGlzLnVzZXJDb21tZW50O3ZhciBpPXllO0FycmF5LmlzQXJyYXkoaSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLmVudHJpZXMmJihpPWkuZW50cmllcygpKSxpPW0oaSkpO2Zvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKXt0aGlzW2lbYV1dLmZpbmFsaXplRmlsdGVycygpfX19LHtrZXk6XCJvbmx5VGlmZlwiLGdldDpmdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIXZlLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF0uZW5hYmxlZH0pKS5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4hMD09PWV9KSkmJnRoaXMudGlmZi5lbmFibGVkfX0se2tleTpcImNoZWNrTG9hZGVkUGx1Z2luc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9cGU7QXJyYXkuaXNBcnJheShlKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZW50cmllcyYmKGU9ZS5lbnRyaWVzKCkpLGU9bShlKSk7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe3ZhciBuPWVbdF07dGhpc1tuXS5lbmFibGVkJiYhVy5oYXMobikmJlIoXCJzZWdtZW50IHBhcnNlclwiLG4pfX19XSxbe2tleTpcInVzZUNhY2hlZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PVNlLmdldChlKTtyZXR1cm4gdm9pZCAwIT09dHx8KHQ9bmV3IHRoaXMoZSksU2Uuc2V0KGUsdCkpLHR9fV0pLGl9KEFlKTtmdW5jdGlvbiBVZShlLHQpe3ZhciBuLHIsaSxhPVtdLHM9dDtBcnJheS5pc0FycmF5KHMpfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5lbnRyaWVzJiYocz1zLmVudHJpZXMoKSkscz1tKHMpKTtmb3IodmFyIHU9MDt1PHMubGVuZ3RoO3UrKyl7cj1zW3VdLG49W107dmFyIG89cmUuZ2V0KHIpO0FycmF5LmlzQXJyYXkobyl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBvLmVudHJpZXMmJihvPW8uZW50cmllcygpKSxvPW0obykpO2Zvcih2YXIgZj0wO2Y8by5sZW5ndGg7ZisrKWk9b1tmXSwoZS5pbmNsdWRlcyhpWzBdKXx8ZS5pbmNsdWRlcyhpWzFdKSkmJm4ucHVzaChpWzBdKTtuLmxlbmd0aCYmYS5wdXNoKFtyLG5dKX1yZXR1cm4gYX1mdW5jdGlvbiB4ZShlLHQpe3JldHVybiB2b2lkIDAhPT1lP2U6dm9pZCAwIT09dD90OnZvaWQgMH1mdW5jdGlvbiBDZShlLHQpe3ZhciBuPXQ7QXJyYXkuaXNBcnJheShuKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG4uZW50cmllcyYmKG49bi5lbnRyaWVzKCkpLG49bShuKSk7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBpPW5bcl07ZS5hZGQoaSl9fWZ1bmN0aW9uIEJlKGUsdCxuKXtyZXR1cm4gbj90P3QoZSk6ZTooZSYmZS50aGVufHwoZT1Qcm9taXNlLnJlc29sdmUoZSkpLHQ/ZS50aGVuKHQpOmUpfWZ1bmN0aW9uIGplKCl7fWZ1bmN0aW9uIF9lKGUsdCl7aWYoIXQpcmV0dXJuIGUmJmUudGhlbj9lLnRoZW4oamUpOlByb21pc2UucmVzb2x2ZSgpfWZ1bmN0aW9uIFZlKGUsdCl7dmFyIG49ZSgpO3JldHVybiBuJiZuLnRoZW4/bi50aGVuKHQpOnQobil9aShQZSxcImRlZmF1bHRcIixPZSk7dmFyIEllPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShuKXt0KHRoaXMsZSksaSh0aGlzLFwicGFyc2Vyc1wiLHt9KSx0aGlzLm9wdGlvbnM9UGUudXNlQ2FjaGVkKG4pfXJldHVybiByKGUsW3trZXk6XCJzZXR1cFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoIXRoaXMuZmlsZVBhcnNlcil7dmFyIGU9dGhpcy5maWxlLHQ9ZS5nZXRVaW50MTYoMCksbj1NO0FycmF5LmlzQXJyYXkobil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLmVudHJpZXMmJihuPW4uZW50cmllcygpKSxuPW0obikpO2Zvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgaT1uW3JdLGE9aVswXSxzPWlbMV07aWYocy5jYW5IYW5kbGUoZSx0KSlyZXR1cm4gdGhpcy5maWxlUGFyc2VyPW5ldyBzKHRoaXMub3B0aW9ucyx0aGlzLmZpbGUsdGhpcy5wYXJzZXJzKSxlW2FdPSEwfUwoXCJVbmtub3duIGZpbGUgZm9ybWF0XCIpfX19LHtrZXk6XCJyZWFkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dHJ5e3ZhciB0PXRoaXM7cmV0dXJuIEJlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/JChlLHQpOngmJiFDJiZlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudD8kKGUuc3JjLHQpOmUgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ8fGUgaW5zdGFuY2VvZiBEYXRhVmlldz9uZXcgRChlKTp4JiZlIGluc3RhbmNlb2YgQmxvYj9RKGUsdCxcImJsb2JcIixZKTp2b2lkIEwoWil9KGUsdC5vcHRpb25zKSwoZnVuY3Rpb24oZSl7dC5maWxlPWV9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJwYXJzZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7ZS5zZXR1cCgpO3ZhciB0PXt9LG49W107cmV0dXJuIFZlKChmdW5jdGlvbigpe3JldHVybiBlLm9wdGlvbnMuc2lsZW50RXJyb3JzP0JlKGUuZG9QYXJzZSh0LG4pLmNhdGNoKChmdW5jdGlvbihlKXtyZXR1cm4gbi5wdXNoKGUpfSkpLChmdW5jdGlvbigpe24ucHVzaC5hcHBseShuLGUuZmlsZVBhcnNlci5lcnJvcnMpfSkpOl9lKGUuZG9QYXJzZSh0LG4pKX0pLChmdW5jdGlvbigpe3JldHVybiBlLmZpbGUuY2xvc2UmJmUuZmlsZS5jbG9zZSgpLGUub3B0aW9ucy5zaWxlbnRFcnJvcnMmJm4ubGVuZ3RoPjAmJih0LmVycm9ycz1uKSxJKHI9dCk/dm9pZCAwOnI7dmFyIHJ9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJkb1BhcnNlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0cnl7dmFyIG49dGhpcztyZXR1cm4gQmUobi5maWxlUGFyc2VyLnBhcnNlKCksKGZ1bmN0aW9uKCl7dmFyIHIsaT1wKG4ucGFyc2VycykubWFwKChyPWZ1bmN0aW9uKHQpe3JldHVybiBCZSh0LnBhcnNlKCksKGZ1bmN0aW9uKG4pe3QuYXNzaWduVG9PdXRwdXQoZSxuKX0pKX0sZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoci5hcHBseSh0aGlzLGUpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSkpO2lmKG4ub3B0aW9ucy5zaWxlbnRFcnJvcnMpe3ZhciBhPWZ1bmN0aW9uKGUpe3JldHVybiB0LnB1c2goZSl9O2k9aS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNhdGNoKGEpfSkpfXJldHVybiBfZShQcm9taXNlLmFsbChpKSl9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJleHRyYWN0VGh1bWJuYWlsXCIsdmFsdWU6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9dGhpcztlLnNldHVwKCk7dmFyIHQsbj1lLm9wdGlvbnMscj1lLmZpbGUsaT1XLmdldChcInRpZmZcIixuKTtyZXR1cm4gVmUoKGZ1bmN0aW9uKCl7aWYoIXIudGlmZilyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9ZSgpO2lmKHQmJnQudGhlbilyZXR1cm4gdC50aGVuKGplKX0oKGZ1bmN0aW9uKCl7aWYoci5qcGVnKXJldHVybiBCZShlLmZpbGVQYXJzZXIuZ2V0T3JGaW5kU2VnbWVudChcInRpZmZcIiksKGZ1bmN0aW9uKGUpe3Q9ZX0pKX0pKTt0PXtzdGFydDowLHR5cGU6XCJ0aWZmXCJ9fSksKGZ1bmN0aW9uKCl7aWYodm9pZCAwIT09dClyZXR1cm4gQmUoZS5maWxlUGFyc2VyLmVuc3VyZVNlZ21lbnRDaHVuayh0KSwoZnVuY3Rpb24odCl7cmV0dXJuIEJlKChlLnBhcnNlcnMudGlmZj1uZXcgaSh0LG4scikpLmV4dHJhY3RUaHVtYm5haWwoKSwoZnVuY3Rpb24oZSl7cmV0dXJuIHIuY2xvc2UmJnIuY2xvc2UoKSxlfSkpfSkpfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fV0pLGV9KCk7dmFyIExlLFRlPShMZT1mdW5jdGlvbihlLHQpe3ZhciBuLHIsaSxhPW5ldyBJZSh0KTtyZXR1cm4gbj1hLnJlYWQoZSkscj1mdW5jdGlvbigpe3JldHVybiBhLnBhcnNlKCl9LGk/cj9yKG4pOm46KG4mJm4udGhlbnx8KG49UHJvbWlzZS5yZXNvbHZlKG4pKSxyP24udGhlbihyKTpuKX0sZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoTGUuYXBwbHkodGhpcyxlKSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0pLHplPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLHBhcnNlOlRlLEV4aWZyOkllLGZpbGVQYXJzZXJzOk0sc2VnbWVudFBhcnNlcnM6VyxmaWxlUmVhZGVyczpLLHRhZ0tleXM6cmUsdGFnVmFsdWVzOmllLHRhZ1Jldml2ZXJzOmFlLGNyZWF0ZURpY3Rpb25hcnk6dGUsZXh0ZW5kRGljdGlvbmFyeTpuZSxmZXRjaFVybEFzQXJyYXlCdWZmZXI6RyxyZWFkQmxvYkFzQXJyYXlCdWZmZXI6WSxjaHVua2VkUHJvcHM6ZGUsb3RoZXJTZWdtZW50czp2ZSxzZWdtZW50czpwZSx0aWZmQmxvY2tzOnllLHNlZ21lbnRzQW5kQmxvY2tzOmdlLHRpZmZFeHRyYWN0YWJsZXM6a2UsaW5oZXJpdGFibGVzOm1lLGFsbEZvcm1hdHRlcnM6YmUsT3B0aW9uczpQZX0pO2Z1bmN0aW9uIEZlKCl7fXZhciBFZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUobixyLGEpe3ZhciBzPXRoaXM7dCh0aGlzLGUpLGkodGhpcyxcImVycm9yc1wiLFtdKSxpKHRoaXMsXCJlbnN1cmVTZWdtZW50Q2h1bmtcIixmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sbj0wO248YXJndW1lbnRzLmxlbmd0aDtuKyspdFtuXT1hcmd1bWVudHNbbl07dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoZS5hcHBseSh0aGlzLHQpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0oKGZ1bmN0aW9uKGUpe3ZhciB0LG4scixpPWUuc3RhcnQsYT1lLnNpemV8fDY1NTM2O3JldHVybiB0PWZ1bmN0aW9uKCl7aWYocy5maWxlLmNodW5rZWQpcmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PWUoKTtpZih0JiZ0LnRoZW4pcmV0dXJuIHQudGhlbihGZSl9KChmdW5jdGlvbigpe2lmKCFzLmZpbGUuYXZhaWxhYmxlKGksYSkpcmV0dXJuIGZ1bmN0aW9uKGUpe2lmKGUmJmUudGhlbilyZXR1cm4gZS50aGVuKEZlKX0oZnVuY3Rpb24oZSx0KXt0cnl7dmFyIG49ZSgpfWNhdGNoKGUpe3JldHVybiB0KGUpfXJldHVybiBuJiZuLnRoZW4/bi50aGVuKHZvaWQgMCx0KTpufSgoZnVuY3Rpb24oKXtyZXR1cm4gdD1zLmZpbGUucmVhZENodW5rKGksYSksbj1mdW5jdGlvbih0KXtlLmNodW5rPXR9LHI/bj9uKHQpOnQ6KHQmJnQudGhlbnx8KHQ9UHJvbWlzZS5yZXNvbHZlKHQpKSxuP3QudGhlbihuKTp0KTt2YXIgdCxuLHJ9KSwoZnVuY3Rpb24odCl7TChcIkNvdWxkbid0IHJlYWQgc2VnbWVudDogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGUpLFwiLiBcIikuY29uY2F0KHQubWVzc2FnZSkpfSkpKTtlLmNodW5rPXMuZmlsZS5zdWJhcnJheShpLGEpfSkpO3MuZmlsZS5ieXRlTGVuZ3RoPmkrYT9lLmNodW5rPXMuZmlsZS5zdWJhcnJheShpLGEpOnZvaWQgMD09PWUuc2l6ZT9lLmNodW5rPXMuZmlsZS5zdWJhcnJheShpKTpMKFwiU2VnbWVudCB1bnJlYWNoYWJsZTogXCIrSlNPTi5zdHJpbmdpZnkoZSkpfSxuPWZ1bmN0aW9uKCl7cmV0dXJuIGUuY2h1bmt9LChyPXQoKSkmJnIudGhlbj9yLnRoZW4obik6bihyKX0pKSksdGhpcy5leHRlbmRPcHRpb25zJiZ0aGlzLmV4dGVuZE9wdGlvbnMobiksdGhpcy5vcHRpb25zPW4sdGhpcy5maWxlPXIsdGhpcy5wYXJzZXJzPWF9cmV0dXJuIHIoZSxbe2tleTpcImluamVjdFNlZ21lbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMub3B0aW9uc1tlXS5lbmFibGVkJiZ0aGlzLmNyZWF0ZVBhcnNlcihlLHQpfX0se2tleTpcImNyZWF0ZVBhcnNlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49bmV3KFcuZ2V0KGUpKSh0LHRoaXMub3B0aW9ucyx0aGlzLmZpbGUpO3JldHVybiB0aGlzLnBhcnNlcnNbZV09bn19LHtrZXk6XCJjcmVhdGVQYXJzZXJzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZTtBcnJheS5pc0FycmF5KHQpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5lbnRyaWVzJiYodD10LmVudHJpZXMoKSksdD1tKHQpKTtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXSxpPXIudHlwZSxhPXIuY2h1bmsscz10aGlzLm9wdGlvbnNbaV07aWYocyYmcy5lbmFibGVkKXt2YXIgdT10aGlzLnBhcnNlcnNbaV07dSYmdS5hcHBlbmR8fHV8fHRoaXMuY3JlYXRlUGFyc2VyKGksYSl9fX19LHtrZXk6XCJyZWFkU2VnbWVudHNcIix2YWx1ZTpmdW5jdGlvbihlKXt0cnl7dmFyIHQ9ZS5tYXAodGhpcy5lbnN1cmVTZWdtZW50Q2h1bmspO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCF0KXJldHVybiBlJiZlLnRoZW4/ZS50aGVuKEZlKTpQcm9taXNlLnJlc29sdmUoKX0oUHJvbWlzZS5hbGwodCkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fV0pLGV9KCksRGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKG4pe3ZhciByPXRoaXMsYT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30scz1hcmd1bWVudHMubGVuZ3RoPjI/YXJndW1lbnRzWzJdOnZvaWQgMDt0KHRoaXMsZSksaSh0aGlzLFwiZXJyb3JzXCIsW10pLGkodGhpcyxcInJhd1wiLFMoKSksaSh0aGlzLFwiaGFuZGxlRXJyb3JcIiwoZnVuY3Rpb24oZSl7aWYoIXIub3B0aW9ucy5zaWxlbnRFcnJvcnMpdGhyb3cgZTtyLmVycm9ycy5wdXNoKGUubWVzc2FnZSl9KSksdGhpcy5jaHVuaz10aGlzLm5vcm1hbGl6ZUlucHV0KG4pLHRoaXMuZmlsZT1zLHRoaXMudHlwZT10aGlzLmNvbnN0cnVjdG9yLnR5cGUsdGhpcy5nbG9iYWxPcHRpb25zPXRoaXMub3B0aW9ucz1hLHRoaXMubG9jYWxPcHRpb25zPWFbdGhpcy50eXBlXSx0aGlzLmNhblRyYW5zbGF0ZT10aGlzLmxvY2FsT3B0aW9ucyYmdGhpcy5sb2NhbE9wdGlvbnMudHJhbnNsYXRlfXJldHVybiByKGUsW3trZXk6XCJub3JtYWxpemVJbnB1dFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgRD9lOm5ldyBEKGUpfX0se2tleTpcInRyYW5zbGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jYW5UcmFuc2xhdGUmJih0aGlzLnRyYW5zbGF0ZWQ9dGhpcy50cmFuc2xhdGVCbG9jayh0aGlzLnJhdyx0aGlzLnR5cGUpKX19LHtrZXk6XCJvdXRwdXRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFuc2xhdGVkP3RoaXMudHJhbnNsYXRlZDp0aGlzLnJhdz9rKHRoaXMucmF3KTp2b2lkIDB9fSx7a2V5OlwidHJhbnNsYXRlQmxvY2tcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWFlLmdldCh0KSxyPWllLmdldCh0KSxpPXJlLmdldCh0KSxhPXRoaXMub3B0aW9uc1t0XSxzPWEucmV2aXZlVmFsdWVzJiYhIW4sdT1hLnRyYW5zbGF0ZVZhbHVlcyYmISFyLG89YS50cmFuc2xhdGVLZXlzJiYhIWksZj17fSxjPWU7QXJyYXkuaXNBcnJheShjKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGMuZW50cmllcyYmKGM9Yy5lbnRyaWVzKCkpLGM9bShjKSk7Zm9yKHZhciBoPTA7aDxjLmxlbmd0aDtoKyspe3ZhciBsPWNbaF0sZD1sWzBdLHY9bFsxXTtzJiZuLmhhcyhkKT92PW4uZ2V0KGQpKHYpOnUmJnIuaGFzKGQpJiYodj10aGlzLnRyYW5zbGF0ZVZhbHVlKHYsci5nZXQoZCkpKSxvJiZpLmhhcyhkKSYmKGQ9aS5nZXQoZCl8fGQpLGZbZF09dn1yZXR1cm4gZn19LHtrZXk6XCJ0cmFuc2xhdGVWYWx1ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRbZV18fHQuREVGQVVMVHx8ZX19LHtrZXk6XCJhc3NpZ25Ub091dHB1dFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5hc3NpZ25PYmplY3RUb091dHB1dChlLHRoaXMuY29uc3RydWN0b3IudHlwZSx0KX19LHtrZXk6XCJhc3NpZ25PYmplY3RUb091dHB1dFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtpZih0aGlzLmdsb2JhbE9wdGlvbnMubWVyZ2VPdXRwdXQpcmV0dXJuIGcoZSxuKTtlW3RdP2coZVt0XSxuKTplW3RdPW59fV0sW3trZXk6XCJmaW5kUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWUuZ2V0VWludDE2KHQrMikrMixyPVwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuaGVhZGVyTGVuZ3RoP3RoaXMuaGVhZGVyTGVuZ3RoKGUsdCxuKTp0aGlzLmhlYWRlckxlbmd0aCxpPXQrcixhPW4tcjtyZXR1cm57b2Zmc2V0OnQsbGVuZ3RoOm4saGVhZGVyTGVuZ3RoOnIsc3RhcnQ6aSxzaXplOmEsZW5kOmkrYX19fSx7a2V5OlwicGFyc2VcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30sbj1uZXcgUGUoaSh7fSx0aGlzLnR5cGUsdCkpLHI9bmV3IHRoaXMoZSxuKTtyZXR1cm4gci5wYXJzZSgpfX1dKSxlfSgpO2Z1bmN0aW9uIFJlKGUsdCxuKXtyZXR1cm4gbj90P3QoZSk6ZTooZSYmZS50aGVufHwoZT1Qcm9taXNlLnJlc29sdmUoZSkpLHQ/ZS50aGVuKHQpOmUpfWkoRGUsXCJoZWFkZXJMZW5ndGhcIiw0KSxpKERlLFwidHlwZVwiLHZvaWQgMCksaShEZSxcIm11bHRpU2VnbWVudFwiLCExKSxpKERlLFwiY2FuSGFuZGxlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuITF9KSk7ZnVuY3Rpb24gTmUoKXt9ZnVuY3Rpb24gTWUoZSx0KXtpZighdClyZXR1cm4gZSYmZS50aGVuP2UudGhlbihOZSk6UHJvbWlzZS5yZXNvbHZlKCl9ZnVuY3Rpb24gV2UoZSl7dmFyIHQ9ZSgpO2lmKHQmJnQudGhlbilyZXR1cm4gdC50aGVuKE5lKX1mdW5jdGlvbiBLZShlLHQpe3ZhciBuPWUoKTtyZXR1cm4gbiYmbi50aGVuP24udGhlbih0KTp0KG4pfWZ1bmN0aW9uIEhlKGUsdCxuKXtpZighZS5zKXtpZihuIGluc3RhbmNlb2YgWGUpe2lmKCFuLnMpcmV0dXJuIHZvaWQobi5vPUhlLmJpbmQobnVsbCxlLHQpKTsxJnQmJih0PW4ucyksbj1uLnZ9aWYobiYmbi50aGVuKXJldHVybiB2b2lkIG4udGhlbihIZS5iaW5kKG51bGwsZSx0KSxIZS5iaW5kKG51bGwsZSwyKSk7ZS5zPXQsZS52PW47dmFyIHI9ZS5vO3ImJnIoZSl9fXZhciBYZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIGUucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24odCxuKXt2YXIgcj1uZXcgZSxpPXRoaXMucztpZihpKXt2YXIgYT0xJmk/dDpuO2lmKGEpe3RyeXtIZShyLDEsYSh0aGlzLnYpKX1jYXRjaChlKXtIZShyLDIsZSl9cmV0dXJuIHJ9cmV0dXJuIHRoaXN9cmV0dXJuIHRoaXMubz1mdW5jdGlvbihlKXt0cnl7dmFyIGk9ZS52OzEmZS5zP0hlKHIsMSx0P3QoaSk6aSk6bj9IZShyLDEsbihpKSk6SGUociwyLGkpfWNhdGNoKGUpe0hlKHIsMixlKX19LHJ9LGV9KCk7ZnVuY3Rpb24gWWUoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBYZSYmMSZlLnN9ZnVuY3Rpb24gR2UoZSx0LG4pe2Zvcih2YXIgcjs7KXt2YXIgaT1lKCk7aWYoWWUoaSkmJihpPWkudiksIWkpcmV0dXJuIGE7aWYoaS50aGVuKXtyPTA7YnJlYWt9dmFyIGE9bigpO2lmKGEmJmEudGhlbil7aWYoIVllKGEpKXtyPTE7YnJlYWt9YT1hLnN9aWYodCl7dmFyIHM9dCgpO2lmKHMmJnMudGhlbiYmIVllKHMpKXtyPTI7YnJlYWt9fX12YXIgdT1uZXcgWGUsbz1IZS5iaW5kKG51bGwsdSwyKTtyZXR1cm4oMD09PXI/aS50aGVuKGMpOjE9PT1yP2EudGhlbihmKTpzLnRoZW4oaCkpLnRoZW4odm9pZCAwLG8pLHU7ZnVuY3Rpb24gZihyKXthPXI7ZG97aWYodCYmKHM9dCgpKSYmcy50aGVuJiYhWWUocykpcmV0dXJuIHZvaWQgcy50aGVuKGgpLnRoZW4odm9pZCAwLG8pO2lmKCEoaT1lKCkpfHxZZShpKSYmIWkudilyZXR1cm4gdm9pZCBIZSh1LDEsYSk7aWYoaS50aGVuKXJldHVybiB2b2lkIGkudGhlbihjKS50aGVuKHZvaWQgMCxvKTtZZShhPW4oKSkmJihhPWEudil9d2hpbGUoIWF8fCFhLnRoZW4pO2EudGhlbihmKS50aGVuKHZvaWQgMCxvKX1mdW5jdGlvbiBjKGUpe2U/KGE9bigpKSYmYS50aGVuP2EudGhlbihmKS50aGVuKHZvaWQgMCxvKTpmKGEpOkhlKHUsMSxhKX1mdW5jdGlvbiBoKCl7KGk9ZSgpKT9pLnRoZW4/aS50aGVuKGMpLnRoZW4odm9pZCAwLG8pOmMoaSk6SGUodSwxLGEpfX1mdW5jdGlvbiBKZShlKXtyZXR1cm4gMTkyPT09ZXx8MTk0PT09ZXx8MTk2PT09ZXx8MjE5PT09ZXx8MjIxPT09ZXx8MjE4PT09ZXx8MjU0PT09ZX1mdW5jdGlvbiBxZShlKXtyZXR1cm4gZT49MjI0JiZlPD0yMzl9ZnVuY3Rpb24gUWUoZSx0LG4pe3ZhciByPVc7QXJyYXkuaXNBcnJheShyKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHIuZW50cmllcyYmKHI9ci5lbnRyaWVzKCkpLHI9bShyKSk7Zm9yKHZhciBpPTA7aTxyLmxlbmd0aDtpKyspe3ZhciBhPXJbaV0scz1hWzBdO2lmKGFbMV0uY2FuSGFuZGxlKGUsdCxuKSlyZXR1cm4gc319dmFyIFplPWZ1bmN0aW9uKGUpe2EocyxlKTt2YXIgbj1kKHMpO2Z1bmN0aW9uIHMoKXt2YXIgZTt0KHRoaXMscyk7Zm9yKHZhciByPWFyZ3VtZW50cy5sZW5ndGgsYT1uZXcgQXJyYXkociksdT0wO3U8cjt1KyspYVt1XT1hcmd1bWVudHNbdV07cmV0dXJuIGkoaChlPW4uY2FsbC5hcHBseShuLFt0aGlzXS5jb25jYXQoYSkpKSxcImFwcFNlZ21lbnRzXCIsW10pLGkoaChlKSxcImpwZWdTZWdtZW50c1wiLFtdKSxpKGgoZSksXCJ1bmtub3duU2VnbWVudHNcIixbXSksZX1yZXR1cm4gcihzLFt7a2V5OlwicGFyc2VcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO3JldHVybiBSZShlLmZpbmRBcHBTZWdtZW50cygpLChmdW5jdGlvbigpe3JldHVybiBSZShlLnJlYWRTZWdtZW50cyhlLmFwcFNlZ21lbnRzKSwoZnVuY3Rpb24oKXtlLm1lcmdlTXVsdGlTZWdtZW50cygpLGUuY3JlYXRlUGFyc2VycyhlLm1lcmdlZEFwcFNlZ21lbnRzfHxlLmFwcFNlZ21lbnRzKX0pKX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcInNldHVwU2VnbWVudEZpbmRlckFyZ3NcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzOyEwPT09ZT8odGhpcy5maW5kQWxsPSEwLHRoaXMud2FudGVkPU8oVy5rZXlMaXN0KCkpKTooZT12b2lkIDA9PT1lP1cua2V5TGlzdCgpLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIHQub3B0aW9uc1tlXS5lbmFibGVkfSkpOmUuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gdC5vcHRpb25zW2VdLmVuYWJsZWQmJlcuaGFzKGUpfSkpLHRoaXMuZmluZEFsbD0hMSx0aGlzLnJlbWFpbmluZz1PKGUpLHRoaXMud2FudGVkPU8oZSkpLHRoaXMudW5maW5pc2hlZE11bHRpU2VnbWVudD0hMX19LHtrZXk6XCJmaW5kQXBwU2VnbWVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTowLHQ9YXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDA7dHJ5e3ZhciBuPXRoaXM7bi5zZXR1cFNlZ21lbnRGaW5kZXJBcmdzKHQpO3ZhciByPW4uZmlsZSxpPW4uZmluZEFsbCxhPW4ud2FudGVkLHM9bi5yZW1haW5pbmc7cmV0dXJuIEtlKChmdW5jdGlvbigpe2lmKCFpJiZuLmZpbGUuY2h1bmtlZClyZXR1cm4gaT1tKGEpLnNvbWUoKGZ1bmN0aW9uKGUpe3ZhciB0PVcuZ2V0KGUpLHI9bi5vcHRpb25zW2VdO3JldHVybiB0Lm11bHRpU2VnbWVudCYmci5tdWx0aVNlZ21lbnR9KSksV2UoKGZ1bmN0aW9uKCl7aWYoaSlyZXR1cm4gTWUobi5maWxlLnJlYWRXaG9sZSgpKX0pKX0pLChmdW5jdGlvbigpe3ZhciB0PSExO2lmKGU9bi5maW5kQXBwU2VnbWVudHNJblJhbmdlKGUsci5ieXRlTGVuZ3RoKSwhbi5vcHRpb25zLm9ubHlUaWZmKXJldHVybiBmdW5jdGlvbigpe2lmKHIuY2h1bmtlZCl7dmFyIGk9ITE7cmV0dXJuIEdlKChmdW5jdGlvbigpe3JldHVybiF0JiZzLnNpemU+MCYmIWkmJighIXIuY2FuUmVhZE5leHRDaHVua3x8ISFuLnVuZmluaXNoZWRNdWx0aVNlZ21lbnQpfSksdm9pZCAwLChmdW5jdGlvbigpe3ZhciBhPXIubmV4dENodW5rT2Zmc2V0LHM9bi5hcHBTZWdtZW50cy5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4hbi5maWxlLmF2YWlsYWJsZShlLm9mZnNldHx8ZS5zdGFydCxlLmxlbmd0aHx8ZS5zaXplKX0pKTtyZXR1cm4gS2UoKGZ1bmN0aW9uKCl7cmV0dXJuIGU+YSYmIXM/UmUoci5yZWFkTmV4dENodW5rKGUpLChmdW5jdGlvbihlKXtpPSFlfSkpOlJlKHIucmVhZE5leHRDaHVuayhhKSwoZnVuY3Rpb24oZSl7aT0hZX0pKX0pLChmdW5jdGlvbigpe3ZvaWQgMD09PShlPW4uZmluZEFwcFNlZ21lbnRzSW5SYW5nZShlLHIuYnl0ZUxlbmd0aCkpJiYodD0hMCl9KSl9KSl9fSgpfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwiZmluZEFwcFNlZ21lbnRzSW5SYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dC09Mjtmb3IodmFyIG4scixpLGEscyx1LG89dGhpcy5maWxlLGY9dGhpcy5maW5kQWxsLGM9dGhpcy53YW50ZWQsaD10aGlzLnJlbWFpbmluZyxsPXRoaXMub3B0aW9ucztlPHQ7ZSsrKWlmKDI1NT09PW8uZ2V0VWludDgoZSkpaWYocWUobj1vLmdldFVpbnQ4KGUrMSkpKXtpZihyPW8uZ2V0VWludDE2KGUrMiksKGk9UWUobyxlLHIpKSYmYy5oYXMoaSkmJihzPShhPVcuZ2V0KGkpKS5maW5kUG9zaXRpb24obyxlKSx1PWxbaV0scy50eXBlPWksdGhpcy5hcHBTZWdtZW50cy5wdXNoKHMpLCFmJiYoYS5tdWx0aVNlZ21lbnQmJnUubXVsdGlTZWdtZW50Pyh0aGlzLnVuZmluaXNoZWRNdWx0aVNlZ21lbnQ9cy5jaHVua051bWJlcjxzLmNodW5rQ291bnQsdGhpcy51bmZpbmlzaGVkTXVsdGlTZWdtZW50fHxoLmRlbGV0ZShpKSk6aC5kZWxldGUoaSksMD09PWguc2l6ZSkpKWJyZWFrO2wucmVjb3JkVW5rbm93blNlZ21lbnRzJiYoKHM9RGUuZmluZFBvc2l0aW9uKG8sZSkpLm1hcmtlcj1uLHRoaXMudW5rbm93blNlZ21lbnRzLnB1c2gocykpLGUrPXIrMX1lbHNlIGlmKEplKG4pKXtpZihyPW8uZ2V0VWludDE2KGUrMiksMjE4PT09biYmITEhPT1sLnN0b3BBZnRlclNvcylyZXR1cm47bC5yZWNvcmRKcGVnU2VnbWVudHMmJnRoaXMuanBlZ1NlZ21lbnRzLnB1c2goe29mZnNldDplLGxlbmd0aDpyLG1hcmtlcjpufSksZSs9cisxfXJldHVybiBlfX0se2tleTpcIm1lcmdlTXVsdGlTZWdtZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztpZih0aGlzLmFwcFNlZ21lbnRzLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiBlLm11bHRpU2VnbWVudH0pKSl7dmFyIHQ9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG4scixpLGE9UygpLHM9MDtzPGUubGVuZ3RoO3MrKylyPShuPWVbc10pW3RdLGEuaGFzKHIpP2k9YS5nZXQocik6YS5zZXQocixpPVtdKSxpLnB1c2gobik7cmV0dXJuIG0oYSl9KHRoaXMuYXBwU2VnbWVudHMsXCJ0eXBlXCIpO3RoaXMubWVyZ2VkQXBwU2VnbWVudHM9dC5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBuPXRbMF0scj10WzFdLGk9Vy5nZXQobixlLm9wdGlvbnMpO3JldHVybiBpLmhhbmRsZU11bHRpU2VnbWVudHM/e3R5cGU6bixjaHVuazppLmhhbmRsZU11bHRpU2VnbWVudHMocil9OnJbMF19KSl9fX0se2tleTpcImdldFNlZ21lbnRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hcHBTZWdtZW50cy5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlPT09ZX0pKX19LHtrZXk6XCJnZXRPckZpbmRTZWdtZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dHJ5e3ZhciB0PXRoaXMsbj10LmdldFNlZ21lbnQoZSk7cmV0dXJuIEtlKChmdW5jdGlvbigpe2lmKHZvaWQgMD09PW4pcmV0dXJuIFJlKHQuZmluZEFwcFNlZ21lbnRzKDAsW2VdKSwoZnVuY3Rpb24oKXtuPXQuZ2V0U2VnbWVudChlKX0pKX0pLChmdW5jdGlvbigpe3JldHVybiBufSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fV0sW3trZXk6XCJjYW5IYW5kbGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiA2NTQ5Nj09PXR9fV0pLHN9KEVlKTtmdW5jdGlvbiAkZSgpe31pKFplLFwidHlwZVwiLFwianBlZ1wiKSxNLnNldChcImpwZWdcIixaZSk7ZnVuY3Rpb24gZXQoZSx0KXtpZighdClyZXR1cm4gZSYmZS50aGVuP2UudGhlbigkZSk6UHJvbWlzZS5yZXNvbHZlKCl9ZnVuY3Rpb24gdHQoZSx0KXt2YXIgbj1lKCk7cmV0dXJuIG4mJm4udGhlbj9uLnRoZW4odCk6dChuKX12YXIgbnQ9W3ZvaWQgMCwxLDEsMiw0LDgsMSwxLDIsNCw4LDQsOCw0XTt2YXIgcnQ9ZnVuY3Rpb24oZSl7YShpLGUpO3ZhciBuPWQoaSk7ZnVuY3Rpb24gaSgpe3JldHVybiB0KHRoaXMsaSksbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIHIoaSxbe2tleTpcInBhcnNlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9dGhpcztlLnBhcnNlSGVhZGVyKCk7dmFyIHQ9ZS5vcHRpb25zO3JldHVybiB0dCgoZnVuY3Rpb24oKXtpZih0LmlmZDAuZW5hYmxlZClyZXR1cm4gZXQoZS5wYXJzZUlmZDBCbG9jaygpKX0pLChmdW5jdGlvbigpe3JldHVybiB0dCgoZnVuY3Rpb24oKXtpZih0LmV4aWYuZW5hYmxlZClyZXR1cm4gZXQoZS5zYWZlUGFyc2UoXCJwYXJzZUV4aWZCbG9ja1wiKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYodC5ncHMuZW5hYmxlZClyZXR1cm4gZXQoZS5zYWZlUGFyc2UoXCJwYXJzZUdwc0Jsb2NrXCIpKX0pLChmdW5jdGlvbigpe3JldHVybiB0dCgoZnVuY3Rpb24oKXtpZih0LmludGVyb3AuZW5hYmxlZClyZXR1cm4gZXQoZS5zYWZlUGFyc2UoXCJwYXJzZUludGVyb3BCbG9ja1wiKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYodC5pZmQxLmVuYWJsZWQpcmV0dXJuIGV0KGUuc2FmZVBhcnNlKFwicGFyc2VUaHVtYm5haWxCbG9ja1wiKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gZS5jcmVhdGVPdXRwdXQoKX0pKX0pKX0pKX0pKX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcInNhZmVQYXJzZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXNbZV0oKTtyZXR1cm4gdm9pZCAwIT09dC5jYXRjaCYmKHQ9dC5jYXRjaCh0aGlzLmhhbmRsZUVycm9yKSksdH19LHtrZXk6XCJmaW5kSWZkME9mZnNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7dm9pZCAwPT09dGhpcy5pZmQwT2Zmc2V0JiYodGhpcy5pZmQwT2Zmc2V0PXRoaXMuY2h1bmsuZ2V0VWludDMyKDQpKX19LHtrZXk6XCJmaW5kSWZkMU9mZnNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodm9pZCAwPT09dGhpcy5pZmQxT2Zmc2V0KXt0aGlzLmZpbmRJZmQwT2Zmc2V0KCk7dmFyIGU9dGhpcy5jaHVuay5nZXRVaW50MTYodGhpcy5pZmQwT2Zmc2V0KSx0PXRoaXMuaWZkME9mZnNldCsyKzEyKmU7dGhpcy5pZmQxT2Zmc2V0PXRoaXMuY2h1bmsuZ2V0VWludDMyKHQpfX19LHtrZXk6XCJwYXJzZUJsb2NrXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1TKCk7cmV0dXJuIHRoaXNbdF09bix0aGlzLnBhcnNlVGFncyhlLHQsbiksbn19LHtrZXk6XCJwYXJzZUlmZDBCbG9ja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7aWYoZS5pZmQwKXJldHVybjt2YXIgdD1lLmZpbGU7cmV0dXJuIGUuZmluZElmZDBPZmZzZXQoKSxlLmlmZDBPZmZzZXQ8OCYmTChcIk1hbGZvcm1lZCBFWElGIGRhdGFcIiksIXQuY2h1bmtlZCYmZS5pZmQwT2Zmc2V0PnQuYnl0ZUxlbmd0aCYmTChcIklGRDAgb2Zmc2V0IHBvaW50cyB0byBvdXRzaWRlIG9mIGZpbGUuXFxudGhpcy5pZmQwT2Zmc2V0OiBcIi5jb25jYXQoZS5pZmQwT2Zmc2V0LFwiLCBmaWxlLmJ5dGVMZW5ndGg6IFwiKS5jb25jYXQodC5ieXRlTGVuZ3RoKSksdHQoKGZ1bmN0aW9uKCl7aWYodC50aWZmKXJldHVybiBldCh0LmVuc3VyZUNodW5rKGUuaWZkME9mZnNldCxUKGUub3B0aW9ucykpKX0pLChmdW5jdGlvbigpe3ZhciB0PWUucGFyc2VCbG9jayhlLmlmZDBPZmZzZXQsXCJpZmQwXCIpO2lmKDAhPT10LnNpemUpcmV0dXJuIGUuZXhpZk9mZnNldD10LmdldChjZSksZS5pbnRlcm9wT2Zmc2V0PXQuZ2V0KGxlKSxlLmdwc09mZnNldD10LmdldChoZSksZS54bXA9dC5nZXQoNzAwKSxlLmlwdGM9dC5nZXQob2UpLGUuaWNjPXQuZ2V0KGZlKSxlLm9wdGlvbnMuc2FuaXRpemUmJih0LmRlbGV0ZShjZSksdC5kZWxldGUobGUpLHQuZGVsZXRlKGhlKSx0LmRlbGV0ZSg3MDApLHQuZGVsZXRlKG9lKSx0LmRlbGV0ZShmZSkpLHR9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJwYXJzZUV4aWZCbG9ja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7aWYoZS5leGlmKXJldHVybjtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYoIWUuaWZkMClyZXR1cm4gZXQoZS5wYXJzZUlmZDBCbG9jaygpKX0pLChmdW5jdGlvbigpe2lmKHZvaWQgMCE9PWUuZXhpZk9mZnNldClyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYoZS5maWxlLnRpZmYpcmV0dXJuIGV0KGUuZmlsZS5lbnN1cmVDaHVuayhlLmV4aWZPZmZzZXQsVChlLm9wdGlvbnMpKSl9KSwoZnVuY3Rpb24oKXt2YXIgdD1lLnBhcnNlQmxvY2soZS5leGlmT2Zmc2V0LFwiZXhpZlwiKTtyZXR1cm4gZS5pbnRlcm9wT2Zmc2V0fHwoZS5pbnRlcm9wT2Zmc2V0PXQuZ2V0KGxlKSksZS5tYWtlck5vdGU9dC5nZXQoc2UpLGUudXNlckNvbW1lbnQ9dC5nZXQodWUpLGUub3B0aW9ucy5zYW5pdGl6ZSYmKHQuZGVsZXRlKGxlKSx0LmRlbGV0ZShzZSksdC5kZWxldGUodWUpKSxlLnVucGFjayh0LDQxNzI4KSxlLnVucGFjayh0LDQxNzI5KSx0fSkpfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwidW5wYWNrXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmdldCh0KTtuJiYxPT09bi5sZW5ndGgmJmUuc2V0KHQsblswXSl9fSx7a2V5OlwicGFyc2VHcHNCbG9ja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7aWYoZS5ncHMpcmV0dXJuO3JldHVybiB0dCgoZnVuY3Rpb24oKXtpZighZS5pZmQwKXJldHVybiBldChlLnBhcnNlSWZkMEJsb2NrKCkpfSksKGZ1bmN0aW9uKCl7aWYodm9pZCAwIT09ZS5ncHNPZmZzZXQpe3ZhciB0PWUucGFyc2VCbG9jayhlLmdwc09mZnNldCxcImdwc1wiKTtyZXR1cm4gdCYmdC5oYXMoMikmJnQuaGFzKDQpJiYodC5zZXQoXCJsYXRpdHVkZVwiLGl0LmFwcGx5KHZvaWQgMCx0LmdldCgyKS5jb25jYXQoW3QuZ2V0KDEpXSkpKSx0LnNldChcImxvbmdpdHVkZVwiLGl0LmFwcGx5KHZvaWQgMCx0LmdldCg0KS5jb25jYXQoW3QuZ2V0KDMpXSkpKSksdH19KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJwYXJzZUludGVyb3BCbG9ja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7aWYoZS5pbnRlcm9wKXJldHVybjtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYoIWUuaWZkMClyZXR1cm4gZXQoZS5wYXJzZUlmZDBCbG9jaygpKX0pLChmdW5jdGlvbigpe3JldHVybiB0dCgoZnVuY3Rpb24oKXtpZih2b2lkIDA9PT1lLmludGVyb3BPZmZzZXQmJiFlLmV4aWYpcmV0dXJuIGV0KGUucGFyc2VFeGlmQmxvY2soKSl9KSwoZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1lLmludGVyb3BPZmZzZXQpcmV0dXJuIGUucGFyc2VCbG9jayhlLmludGVyb3BPZmZzZXQsXCJpbnRlcm9wXCIpfSkpfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwicGFyc2VUaHVtYm5haWxCbG9ja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXTt0cnl7dmFyIHQ9dGhpcztpZih0LmlmZDF8fHQuaWZkMVBhcnNlZClyZXR1cm47aWYodC5vcHRpb25zLm1lcmdlT3V0cHV0JiYhZSlyZXR1cm47cmV0dXJuIHQuZmluZElmZDFPZmZzZXQoKSx0LmlmZDFPZmZzZXQ+MCYmKHQucGFyc2VCbG9jayh0LmlmZDFPZmZzZXQsXCJpZmQxXCIpLHQuaWZkMVBhcnNlZD0hMCksdC5pZmQxfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwiZXh0cmFjdFRodW1ibmFpbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7cmV0dXJuIGUuaGVhZGVyUGFyc2VkfHxlLnBhcnNlSGVhZGVyKCksdHQoKGZ1bmN0aW9uKCl7aWYoIWUuaWZkMVBhcnNlZClyZXR1cm4gZXQoZS5wYXJzZVRodW1ibmFpbEJsb2NrKCEwKSl9KSwoZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1lLmlmZDEpe3ZhciB0PWUuaWZkMS5nZXQoNTEzKSxuPWUuaWZkMS5nZXQoNTE0KTtyZXR1cm4gZS5jaHVuay5nZXRVaW50OEFycmF5KHQsbil9fSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwiaW1hZ2VcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pZmQwfX0se2tleTpcInRodW1ibmFpbFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlmZDF9fSx7a2V5OlwiY3JlYXRlT3V0cHV0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSx0LG4scj17fSxpPXllO0FycmF5LmlzQXJyYXkoaSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLmVudHJpZXMmJihpPWkuZW50cmllcygpKSxpPW0oaSkpO2Zvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKWlmKCFJKGU9dGhpc1t0PWlbYV1dKSlpZihuPXRoaXMuY2FuVHJhbnNsYXRlP3RoaXMudHJhbnNsYXRlQmxvY2soZSx0KTprKGUpLHRoaXMub3B0aW9ucy5tZXJnZU91dHB1dCl7aWYoXCJpZmQxXCI9PT10KWNvbnRpbnVlO2cocixuKX1lbHNlIHJbdF09bjtyZXR1cm4gdGhpcy5tYWtlck5vdGUmJihyLm1ha2VyTm90ZT10aGlzLm1ha2VyTm90ZSksdGhpcy51c2VyQ29tbWVudCYmKHIudXNlckNvbW1lbnQ9dGhpcy51c2VyQ29tbWVudCkscn19LHtrZXk6XCJhc3NpZ25Ub091dHB1dFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYodGhpcy5nbG9iYWxPcHRpb25zLm1lcmdlT3V0cHV0KWcoZSx0KTtlbHNle3ZhciBuPXkodCk7QXJyYXkuaXNBcnJheShuKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG4uZW50cmllcyYmKG49bi5lbnRyaWVzKCkpLG49bShuKSk7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBpPW5bcl0sYT1pWzBdLHM9aVsxXTt0aGlzLmFzc2lnbk9iamVjdFRvT3V0cHV0KGUsYSxzKX19fX1dLFt7a2V5OlwiY2FuSGFuZGxlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMjI1PT09ZS5nZXRVaW50OCh0KzEpJiYxMTY1NTE5MjA2PT09ZS5nZXRVaW50MzIodCs0KSYmMD09PWUuZ2V0VWludDE2KHQrOCl9fV0pLGl9KGZ1bmN0aW9uKGUpe2EoaSxlKTt2YXIgbj1kKGkpO2Z1bmN0aW9uIGkoKXtyZXR1cm4gdCh0aGlzLGkpLG4uYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiByKGksW3trZXk6XCJwYXJzZUhlYWRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5jaHVuay5nZXRVaW50MTYoKTsxODc2MT09PWU/dGhpcy5sZT0hMDoxOTc4OT09PWUmJih0aGlzLmxlPSExKSx0aGlzLmNodW5rLmxlPXRoaXMubGUsdGhpcy5oZWFkZXJQYXJzZWQ9ITB9fSx7a2V5OlwicGFyc2VUYWdzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06UygpLHI9dGhpcy5vcHRpb25zW3RdLGk9ci5waWNrLGE9ci5za2lwLHM9KGk9TyhpKSkuc2l6ZT4wLHU9MD09PWEuc2l6ZSxvPXRoaXMuY2h1bmsuZ2V0VWludDE2KGUpO2UrPTI7Zm9yKHZhciBmPTA7ZjxvO2YrKyl7dmFyIGM9dGhpcy5jaHVuay5nZXRVaW50MTYoZSk7aWYocyl7aWYoaS5oYXMoYykmJihuLnNldChjLHRoaXMucGFyc2VUYWcoZSxjLHQpKSxpLmRlbGV0ZShjKSwwPT09aS5zaXplKSlicmVha31lbHNlIXUmJmEuaGFzKGMpfHxuLnNldChjLHRoaXMucGFyc2VUYWcoZSxjLHQpKTtlKz0xMn1yZXR1cm4gbn19LHtrZXk6XCJwYXJzZVRhZ1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpPXRoaXMuY2h1bmssYT1pLmdldFVpbnQxNihlKzIpLHM9aS5nZXRVaW50MzIoZSs0KSx1PW50W2FdO2lmKHUqczw9ND9lKz04OmU9aS5nZXRVaW50MzIoZSs4KSwoYTwxfHxhPjEzKSYmTChcIkludmFsaWQgVElGRiB2YWx1ZSB0eXBlLiBibG9jazogXCIuY29uY2F0KG4udG9VcHBlckNhc2UoKSxcIiwgdGFnOiBcIikuY29uY2F0KHQudG9TdHJpbmcoMTYpLFwiLCB0eXBlOiBcIikuY29uY2F0KGEsXCIsIG9mZnNldCBcIikuY29uY2F0KGUpKSxlPmkuYnl0ZUxlbmd0aCYmTChcIkludmFsaWQgVElGRiB2YWx1ZSBvZmZzZXQuIGJsb2NrOiBcIi5jb25jYXQobi50b1VwcGVyQ2FzZSgpLFwiLCB0YWc6IFwiKS5jb25jYXQodC50b1N0cmluZygxNiksXCIsIHR5cGU6IFwiKS5jb25jYXQoYSxcIiwgb2Zmc2V0IFwiKS5jb25jYXQoZSxcIiBpcyBvdXRzaWRlIG9mIGNodW5rIHNpemUgXCIpLmNvbmNhdChpLmJ5dGVMZW5ndGgpKSwxPT09YSlyZXR1cm4gaS5nZXRVaW50OEFycmF5KGUscyk7aWYoMj09PWEpcmV0dXJuXCJcIj09PShyPWZ1bmN0aW9uKGUpe2Zvcig7ZS5lbmRzV2l0aChcIlxcMFwiKTspZT1lLnNsaWNlKDAsLTEpO3JldHVybiBlfShyPWkuZ2V0U3RyaW5nKGUscykpLnRyaW0oKSk/dm9pZCAwOnI7aWYoNz09PWEpcmV0dXJuIGkuZ2V0VWludDhBcnJheShlLHMpO2lmKDE9PT1zKXJldHVybiB0aGlzLnBhcnNlVGFnVmFsdWUoYSxlKTtmb3IodmFyIG89bmV3KGZ1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZSAzOnJldHVybiBVaW50MTZBcnJheTtjYXNlIDQ6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2UgNTpyZXR1cm4gQXJyYXk7Y2FzZSA2OnJldHVybiBJbnQ4QXJyYXk7Y2FzZSA4OnJldHVybiBJbnQxNkFycmF5O2Nhc2UgOTpyZXR1cm4gSW50MzJBcnJheTtjYXNlIDEwOnJldHVybiBBcnJheTtjYXNlIDExOnJldHVybiBGbG9hdDMyQXJyYXk7Y2FzZSAxMjpyZXR1cm4gRmxvYXQ2NEFycmF5O2RlZmF1bHQ6cmV0dXJuIEFycmF5fX0oYSkpKHMpLGY9dSxjPTA7YzxzO2MrKylvW2NdPXRoaXMucGFyc2VUYWdWYWx1ZShhLGUpLGUrPWY7cmV0dXJuIG99fSx7a2V5OlwicGFyc2VUYWdWYWx1ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5jaHVuaztzd2l0Y2goZSl7Y2FzZSAxOnJldHVybiBuLmdldFVpbnQ4KHQpO2Nhc2UgMzpyZXR1cm4gbi5nZXRVaW50MTYodCk7Y2FzZSA0OnJldHVybiBuLmdldFVpbnQzMih0KTtjYXNlIDU6cmV0dXJuIG4uZ2V0VWludDMyKHQpL24uZ2V0VWludDMyKHQrNCk7Y2FzZSA2OnJldHVybiBuLmdldEludDgodCk7Y2FzZSA4OnJldHVybiBuLmdldEludDE2KHQpO2Nhc2UgOTpyZXR1cm4gbi5nZXRJbnQzMih0KTtjYXNlIDEwOnJldHVybiBuLmdldEludDMyKHQpL24uZ2V0SW50MzIodCs0KTtjYXNlIDExOnJldHVybiBuLmdldEZsb2F0KHQpO2Nhc2UgMTI6cmV0dXJuIG4uZ2V0RG91YmxlKHQpO2Nhc2UgMTM6cmV0dXJuIG4uZ2V0VWludDMyKHQpO2RlZmF1bHQ6TChcIkludmFsaWQgdGlmZiB0eXBlIFwiLmNvbmNhdChlKSl9fX1dKSxpfShEZSkpO2Z1bmN0aW9uIGl0KGUsdCxuLHIpe3ZhciBpPWUrdC82MCtuLzM2MDA7cmV0dXJuXCJTXCIhPT1yJiZcIldcIiE9PXJ8fChpKj0tMSksaX1pKHJ0LFwidHlwZVwiLFwidGlmZlwiKSxpKHJ0LFwiaGVhZGVyTGVuZ3RoXCIsMTApLFcuc2V0KFwidGlmZlwiLHJ0KTt2YXIgYXQ9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsZGVmYXVsdDp6ZSxFeGlmcjpJZSxmaWxlUGFyc2VyczpNLHNlZ21lbnRQYXJzZXJzOlcsZmlsZVJlYWRlcnM6Syx0YWdLZXlzOnJlLHRhZ1ZhbHVlczppZSx0YWdSZXZpdmVyczphZSxjcmVhdGVEaWN0aW9uYXJ5OnRlLGV4dGVuZERpY3Rpb25hcnk6bmUsZmV0Y2hVcmxBc0FycmF5QnVmZmVyOkcscmVhZEJsb2JBc0FycmF5QnVmZmVyOlksY2h1bmtlZFByb3BzOmRlLG90aGVyU2VnbWVudHM6dmUsc2VnbWVudHM6cGUsdGlmZkJsb2Nrczp5ZSxzZWdtZW50c0FuZEJsb2NrczpnZSx0aWZmRXh0cmFjdGFibGVzOmtlLGluaGVyaXRhYmxlczptZSxhbGxGb3JtYXR0ZXJzOmJlLE9wdGlvbnM6UGUscGFyc2U6VGV9KTtmdW5jdGlvbiBzdChlLHQsbil7cmV0dXJuIG4/dD90KGUpOmU6KGUmJmUudGhlbnx8KGU9UHJvbWlzZS5yZXNvbHZlKGUpKSx0P2UudGhlbih0KTplKX1mdW5jdGlvbiB1dChlKXtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sbj0wO248YXJndW1lbnRzLmxlbmd0aDtuKyspdFtuXT1hcmd1bWVudHNbbl07dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoZS5hcHBseSh0aGlzLHQpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX12YXIgb3Q9dXQoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBJZSh2dCk7cmV0dXJuIHN0KHQucmVhZChlKSwoZnVuY3Rpb24oKXtyZXR1cm4gc3QodC5wYXJzZSgpLChmdW5jdGlvbihlKXtpZihlJiZlLmlmZDApcmV0dXJuIGUuaWZkMFsyNzRdfSkpfSkpfSkpLGZ0PXV0KChmdW5jdGlvbihlKXt2YXIgdD1uZXcgSWUoZHQpO3JldHVybiBzdCh0LnJlYWQoZSksKGZ1bmN0aW9uKCl7cmV0dXJuIHN0KHQucGFyc2UoKSwoZnVuY3Rpb24oZSl7aWYoZSYmZS5ncHMpe3ZhciB0PWUuZ3BzO3JldHVybntsYXRpdHVkZTp0LmxhdGl0dWRlLGxvbmdpdHVkZTp0LmxvbmdpdHVkZX19fSkpfSkpfSkpLGN0PXV0KChmdW5jdGlvbihlKXtyZXR1cm4gc3QodGhpcy50aHVtYm5haWwoZSksKGZ1bmN0aW9uKGUpe2lmKHZvaWQgMCE9PWUpe3ZhciB0PW5ldyBCbG9iKFtlXSk7cmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwodCl9fSkpfSkpLGh0PXV0KChmdW5jdGlvbihlKXt2YXIgdD1uZXcgSWUocHQpO3JldHVybiBzdCh0LnJlYWQoZSksKGZ1bmN0aW9uKCl7cmV0dXJuIHN0KHQuZXh0cmFjdFRodW1ibmFpbCgpLChmdW5jdGlvbihlKXtyZXR1cm4gZSYmXz9qLmZyb20oZSk6ZX0pKX0pKX0pKSxsdD17aWZkMDohMSxpZmQxOiExLGV4aWY6ITEsZ3BzOiExLGludGVyb3A6ITEsc2FuaXRpemU6ITEscmV2aXZlVmFsdWVzOiEwLHRyYW5zbGF0ZUtleXM6ITEsdHJhbnNsYXRlVmFsdWVzOiExLG1lcmdlT3V0cHV0OiExfSxkdD1nKHt9LGx0LHtmaXJzdENodW5rU2l6ZTo0ZTQsZ3BzOlsxLDIsMyw0XX0pLHZ0PWcoe30sbHQse2ZpcnN0Q2h1bmtTaXplOjRlNCxpZmQwOlsyNzRdfSkscHQ9Zyh7fSxsdCx7dGlmZjohMSxpZmQxOiEwLG1lcmdlT3V0cHV0OiExfSkseXQ9T2JqZWN0LmZyZWV6ZSh7MTp7ZGltZW5zaW9uU3dhcHBlZDohMSxzY2FsZVg6MSxzY2FsZVk6MSxkZWc6MCxyYWQ6MH0sMjp7ZGltZW5zaW9uU3dhcHBlZDohMSxzY2FsZVg6LTEsc2NhbGVZOjEsZGVnOjAscmFkOjB9LDM6e2RpbWVuc2lvblN3YXBwZWQ6ITEsc2NhbGVYOjEsc2NhbGVZOjEsZGVnOjE4MCxyYWQ6MTgwKk1hdGguUEkvMTgwfSw0OntkaW1lbnNpb25Td2FwcGVkOiExLHNjYWxlWDotMSxzY2FsZVk6MSxkZWc6MTgwLHJhZDoxODAqTWF0aC5QSS8xODB9LDU6e2RpbWVuc2lvblN3YXBwZWQ6ITAsc2NhbGVYOjEsc2NhbGVZOi0xLGRlZzo5MCxyYWQ6OTAqTWF0aC5QSS8xODB9LDY6e2RpbWVuc2lvblN3YXBwZWQ6ITAsc2NhbGVYOjEsc2NhbGVZOjEsZGVnOjkwLHJhZDo5MCpNYXRoLlBJLzE4MH0sNzp7ZGltZW5zaW9uU3dhcHBlZDohMCxzY2FsZVg6MSxzY2FsZVk6LTEsZGVnOjI3MCxyYWQ6MjcwKk1hdGguUEkvMTgwfSw4OntkaW1lbnNpb25Td2FwcGVkOiEwLHNjYWxlWDoxLHNjYWxlWToxLGRlZzoyNzAscmFkOjI3MCpNYXRoLlBJLzE4MH19KTtpZihlLnJvdGF0ZUNhbnZhcz0hMCxlLnJvdGF0ZUNzcz0hMCxcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yKXt2YXIgZ3Q9bmF2aWdhdG9yLnVzZXJBZ2VudDtpZihndC5pbmNsdWRlcyhcImlQYWRcIil8fGd0LmluY2x1ZGVzKFwiaVBob25lXCIpKXt2YXIga3Q9Z3QubWF0Y2goL09TIChcXGQrKV8oXFxkKykvKTtpZihrdCl7dmFyIG10PWt0WzFdLGJ0PWt0WzJdLEF0PU51bWJlcihtdCkrLjEqTnVtYmVyKGJ0KTtlLnJvdGF0ZUNhbnZhcz1BdDwxMy40LGUucm90YXRlQ3NzPSExfX1lbHNlIGlmKGd0LmluY2x1ZGVzKFwiT1MgWCAxMFwiKSl7dmFyIHd0PWd0Lm1hdGNoKC9PUyBYIDEwW18uXShcXGQrKS8pWzFdO2Uucm90YXRlQ2FudmFzPWUucm90YXRlQ3NzPU51bWJlcih3dCk8MTV9aWYoZ3QuaW5jbHVkZXMoXCJDaHJvbWUvXCIpKXt2YXIgT3Q9Z3QubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pWzFdO2Uucm90YXRlQ2FudmFzPWUucm90YXRlQ3NzPU51bWJlcihPdCk8ODF9ZWxzZSBpZihndC5pbmNsdWRlcyhcIkZpcmVmb3gvXCIpKXt2YXIgU3Q9Z3QubWF0Y2goL0ZpcmVmb3hcXC8oXFxkKykvKVsxXTtlLnJvdGF0ZUNhbnZhcz1lLnJvdGF0ZUNzcz1OdW1iZXIoU3QpPDc3fX1mdW5jdGlvbiBQdCgpe312YXIgVXQ9ZnVuY3Rpb24oZSl7YSh1LGUpO3ZhciBuPWQodSk7ZnVuY3Rpb24gdSgpe3ZhciBlO3QodGhpcyx1KTtmb3IodmFyIHI9YXJndW1lbnRzLmxlbmd0aCxhPW5ldyBBcnJheShyKSxzPTA7czxyO3MrKylhW3NdPWFyZ3VtZW50c1tzXTtyZXR1cm4gaShoKGU9bi5jYWxsLmFwcGx5KG4sW3RoaXNdLmNvbmNhdChhKSkpLFwicmFuZ2VzXCIsbmV3IHh0KSwwIT09ZS5ieXRlTGVuZ3RoJiZlLnJhbmdlcy5hZGQoMCxlLmJ5dGVMZW5ndGgpLGV9cmV0dXJuIHIodSxbe2tleTpcIl90cnlFeHRlbmRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7aWYoMD09PWUmJjA9PT10aGlzLmJ5dGVMZW5ndGgmJm4pe3ZhciByPW5ldyBEYXRhVmlldyhuLmJ1ZmZlcnx8bixuLmJ5dGVPZmZzZXQsbi5ieXRlTGVuZ3RoKTt0aGlzLl9zd2FwRGF0YVZpZXcocil9ZWxzZXt2YXIgaT1lK3Q7aWYoaT50aGlzLmJ5dGVMZW5ndGgpe3ZhciBhPXRoaXMuX2V4dGVuZChpKS5kYXRhVmlldzt0aGlzLl9zd2FwRGF0YVZpZXcoYSl9fX19LHtrZXk6XCJfZXh0ZW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ7dD1fP2ouYWxsb2NVbnNhZmUoZSk6bmV3IFVpbnQ4QXJyYXkoZSk7dmFyIG49bmV3IERhdGFWaWV3KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpO3JldHVybiB0LnNldChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcix0aGlzLmJ5dGVPZmZzZXQsdGhpcy5ieXRlTGVuZ3RoKSwwKSx7dWludFZpZXc6dCxkYXRhVmlldzpufX19LHtrZXk6XCJzdWJhcnJheVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXTtyZXR1cm4gdD10fHx0aGlzLl9sZW5ndGhUb0VuZChlKSxuJiZ0aGlzLl90cnlFeHRlbmQoZSx0KSx0aGlzLnJhbmdlcy5hZGQoZSx0KSx2KHModS5wcm90b3R5cGUpLFwic3ViYXJyYXlcIix0aGlzKS5jYWxsKHRoaXMsZSx0KX19LHtrZXk6XCJzZXRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07biYmdGhpcy5fdHJ5RXh0ZW5kKHQsZS5ieXRlTGVuZ3RoLGUpO3ZhciByPXYocyh1LnByb3RvdHlwZSksXCJzZXRcIix0aGlzKS5jYWxsKHRoaXMsZSx0KTtyZXR1cm4gdGhpcy5yYW5nZXMuYWRkKHQsci5ieXRlTGVuZ3RoKSxyfX0se2tleTpcImVuc3VyZUNodW5rXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0cnl7dmFyIG49dGhpcztpZighbi5jaHVua2VkKXJldHVybjtpZihuLnJhbmdlcy5hdmFpbGFibGUoZSx0KSlyZXR1cm47cmV0dXJuIGZ1bmN0aW9uKGUsdCl7aWYoIXQpcmV0dXJuIGUmJmUudGhlbj9lLnRoZW4oUHQpOlByb21pc2UucmVzb2x2ZSgpfShuLnJlYWRDaHVuayhlLHQpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcImF2YWlsYWJsZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMucmFuZ2VzLmF2YWlsYWJsZShlLHQpfX1dKSx1fShEKSx4dD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0KHRoaXMsZSksaSh0aGlzLFwibGlzdFwiLFtdKX1yZXR1cm4gcihlLFt7a2V5OlwibGVuZ3RoXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGlzdC5sZW5ndGh9fSx7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lK3Qscj10aGlzLmxpc3QuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gQ3QoZSx0Lm9mZnNldCxuKXx8Q3QoZSx0LmVuZCxuKX0pKTtpZihyLmxlbmd0aD4wKXtlPU1hdGgubWluLmFwcGx5KE1hdGgsW2VdLmNvbmNhdChyLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUub2Zmc2V0fSkpKSksdD0obj1NYXRoLm1heC5hcHBseShNYXRoLFtuXS5jb25jYXQoci5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmVuZH0pKSkpKS1lO3ZhciBpPXIuc2hpZnQoKTtpLm9mZnNldD1lLGkubGVuZ3RoPXQsaS5lbmQ9bix0aGlzLmxpc3Q9dGhpcy5saXN0LmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIXIuaW5jbHVkZXMoZSl9KSl9ZWxzZSB0aGlzLmxpc3QucHVzaCh7b2Zmc2V0OmUsbGVuZ3RoOnQsZW5kOm59KX19LHtrZXk6XCJhdmFpbGFibGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWUrdDtyZXR1cm4gdGhpcy5saXN0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9mZnNldDw9ZSYmbjw9dC5lbmR9KSl9fV0pLGV9KCk7ZnVuY3Rpb24gQ3QoZSx0LG4pe3JldHVybiBlPD10JiZ0PD1ufWZ1bmN0aW9uIEJ0KCl7fWZ1bmN0aW9uIGp0KGUsdCl7aWYoIXQpcmV0dXJuIGUmJmUudGhlbj9lLnRoZW4oQnQpOlByb21pc2UucmVzb2x2ZSgpfWZ1bmN0aW9uIF90KGUsdCxuKXtyZXR1cm4gbj90P3QoZSk6ZTooZSYmZS50aGVufHwoZT1Qcm9taXNlLnJlc29sdmUoZSkpLHQ/ZS50aGVuKHQpOmUpfXZhciBWdD1mdW5jdGlvbihlKXthKGksZSk7dmFyIG49ZChpKTtmdW5jdGlvbiBpKCl7cmV0dXJuIHQodGhpcyxpKSxuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gcihpLFt7a2V5OlwicmVhZFdob2xlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9dGhpcztyZXR1cm4gZS5jaHVua2VkPSExLF90KFkoZS5pbnB1dCksKGZ1bmN0aW9uKHQpe2UuX3N3YXBBcnJheUJ1ZmZlcih0KX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcInJlYWRDaHVua2VkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaHVua2VkPSEwLHRoaXMuc2l6ZT10aGlzLmlucHV0LnNpemUsdihzKGkucHJvdG90eXBlKSxcInJlYWRDaHVua2VkXCIsdGhpcykuY2FsbCh0aGlzKX19LHtrZXk6XCJfcmVhZENodW5rXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0cnl7dmFyIG49dGhpcyxyPXQ/ZSt0OnZvaWQgMCxpPW4uaW5wdXQuc2xpY2UoZSxyKTtyZXR1cm4gX3QoWShpKSwoZnVuY3Rpb24odCl7cmV0dXJuIG4uc2V0KHQsZSwhMCl9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19XSksaX0oZnVuY3Rpb24oZSl7YShzLGUpO3ZhciBuPWQocyk7ZnVuY3Rpb24gcyhlLHIpe3ZhciBhO3JldHVybiB0KHRoaXMscyksaShoKGE9bi5jYWxsKHRoaXMsMCkpLFwiY2h1bmtzUmVhZFwiLDApLGEuaW5wdXQ9ZSxhLm9wdGlvbnM9cixhfXJldHVybiByKHMsW3trZXk6XCJyZWFkV2hvbGVcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO3JldHVybiBlLmNodW5rZWQ9ITEsanQoZS5yZWFkQ2h1bmsoZS5uZXh0Q2h1bmtPZmZzZXQpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcInJlYWRDaHVua2VkXCIsdmFsdWU6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9dGhpcztyZXR1cm4gZS5jaHVua2VkPSEwLGp0KGUucmVhZENodW5rKDAsZS5vcHRpb25zLmZpcnN0Q2h1bmtTaXplKSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJyZWFkTmV4dENodW5rXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dHJ5e3ZhciB0PXRoaXM7aWYodm9pZCAwPT09ZSYmKGU9dC5uZXh0Q2h1bmtPZmZzZXQpLHQuZnVsbHlSZWFkKXJldHVybiB0LmNodW5rc1JlYWQrKywhMTt2YXIgbj10Lm9wdGlvbnMuY2h1bmtTaXplO3JldHVybiByPXQucmVhZENodW5rKGUsbiksaT1mdW5jdGlvbihlKXtyZXR1cm4hIWUmJmUuYnl0ZUxlbmd0aD09PW59LGE/aT9pKHIpOnI6KHImJnIudGhlbnx8KHI9UHJvbWlzZS5yZXNvbHZlKHIpKSxpP3IudGhlbihpKTpyKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9dmFyIHIsaSxhfX0se2tleTpcInJlYWRDaHVua1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dHJ5e3ZhciBuPXRoaXM7aWYobi5jaHVua3NSZWFkKyssMD09PSh0PW4uc2FmZVdyYXBBZGRyZXNzKGUsdCkpKXJldHVybjtyZXR1cm4gbi5fcmVhZENodW5rKGUsdCl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJzYWZlV3JhcEFkZHJlc3NcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDAhPT10aGlzLnNpemUmJmUrdD50aGlzLnNpemU/TWF0aC5tYXgoMCx0aGlzLnNpemUtZSk6dH19LHtrZXk6XCJuZXh0Q2h1bmtPZmZzZXRcIixnZXQ6ZnVuY3Rpb24oKXtpZigwIT09dGhpcy5yYW5nZXMubGlzdC5sZW5ndGgpcmV0dXJuIHRoaXMucmFuZ2VzLmxpc3RbMF0ubGVuZ3RofX0se2tleTpcImNhblJlYWROZXh0Q2h1bmtcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaHVua3NSZWFkPHRoaXMub3B0aW9ucy5jaHVua0xpbWl0fX0se2tleTpcImZ1bGx5UmVhZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB2b2lkIDAhPT10aGlzLnNpemUmJnRoaXMubmV4dENodW5rT2Zmc2V0PT09dGhpcy5zaXplfX0se2tleTpcInJlYWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMuY2h1bmtlZD90aGlzLnJlYWRDaHVua2VkKCk6dGhpcy5yZWFkV2hvbGUoKX19LHtrZXk6XCJjbG9zZVwiLHZhbHVlOmZ1bmN0aW9uKCl7fX1dKSxzfShVdCkpO0suc2V0KFwiYmxvYlwiLFZ0KSxlLkV4aWZyPUllLGUuT3B0aW9ucz1QZSxlLmFsbEZvcm1hdHRlcnM9YmUsZS5jaHVua2VkUHJvcHM9ZGUsZS5jcmVhdGVEaWN0aW9uYXJ5PXRlLGUuZGVmYXVsdD1hdCxlLmRpc2FibGVBbGxPcHRpb25zPWx0LGUuZXh0ZW5kRGljdGlvbmFyeT1uZSxlLmZldGNoVXJsQXNBcnJheUJ1ZmZlcj1HLGUuZmlsZVBhcnNlcnM9TSxlLmZpbGVSZWFkZXJzPUssZS5ncHM9ZnQsZS5ncHNPbmx5T3B0aW9ucz1kdCxlLmluaGVyaXRhYmxlcz1tZSxlLm9yaWVudGF0aW9uPW90LGUub3JpZW50YXRpb25Pbmx5T3B0aW9ucz12dCxlLm90aGVyU2VnbWVudHM9dmUsZS5wYXJzZT1UZSxlLnJlYWRCbG9iQXNBcnJheUJ1ZmZlcj1ZLGUucm90YXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIHN0KG90KHQpLChmdW5jdGlvbih0KXtyZXR1cm4gZyh7Y2FudmFzOmUucm90YXRlQ2FudmFzLGNzczplLnJvdGF0ZUNzc30seXRbdF0pfSkpfSxlLnJvdGF0aW9ucz15dCxlLnNlZ21lbnRQYXJzZXJzPVcsZS5zZWdtZW50cz1wZSxlLnNlZ21lbnRzQW5kQmxvY2tzPWdlLGUudGFnS2V5cz1yZSxlLnRhZ1Jldml2ZXJzPWFlLGUudGFnVmFsdWVzPWllLGUudGh1bWJuYWlsPWh0LGUudGh1bWJuYWlsT25seU9wdGlvbnM9cHQsZS50aHVtYm5haWxVcmw9Y3QsZS50aWZmQmxvY2tzPXllLGUudGlmZkV4dHJhY3RhYmxlcz1rZSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdldEZvcm1EYXRhO1xuZXhwb3J0cy5nZXRGaWVsZERhdGEgPSBnZXRGaWVsZERhdGE7XG52YXIgTk9ERV9MSVNUX0NMQVNTRVMgPSB7XG4gICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXSc6IHRydWUsXG4gICdbb2JqZWN0IE5vZGVMaXN0XSc6IHRydWUsXG4gICdbb2JqZWN0IFJhZGlvTm9kZUxpc3RdJzogdHJ1ZVxuXG4gIC8vIC50eXBlIHZhbHVlcyBmb3IgZWxlbWVudHMgd2hpY2ggY2FuIGFwcGVhciBpbiAuZWxlbWVudHMgYW5kIHNob3VsZCBiZSBpZ25vcmVkXG59O3ZhciBJR05PUkVEX0VMRU1FTlRfVFlQRVMgPSB7XG4gICdidXR0b24nOiB0cnVlLFxuICAnZmllbGRzZXQnOiB0cnVlLFxuICAncmVzZXQnOiB0cnVlLFxuICAnc3VibWl0JzogdHJ1ZVxufTtcblxudmFyIENIRUNLRURfSU5QVVRfVFlQRVMgPSB7XG4gICdjaGVja2JveCc6IHRydWUsXG4gICdyYWRpbyc6IHRydWVcbn07XG5cbnZhciBUUklNX1JFID0gL15cXHMrfFxccyskL2c7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywoc3RyaW5nfEFycmF5LjxzdHJpbmc+KT59IGFuIG9iamVjdCBjb250YWluaW5nXG4gKiAgIHN1Ym1pdHRhYmxlIHZhbHVlKHMpIGhlbGQgaW4gdGhlIGZvcm0ncyAuZWxlbWVudHMgY29sbGVjdGlvbiwgd2l0aFxuICogICBwcm9wZXJ0aWVzIG5hbWVkIGFzIHBlciBlbGVtZW50IG5hbWVzIG9yIGlkcy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRGb3JtRGF0YShmb3JtKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7IHRyaW06IGZhbHNlIH07XG5cbiAgaWYgKCFmb3JtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIGZvcm0gaXMgcmVxdWlyZWQgYnkgZ2V0Rm9ybURhdGEsIHdhcyBnaXZlbiBmb3JtPScgKyBmb3JtKTtcbiAgfVxuXG4gIHZhciBkYXRhID0ge307XG4gIHZhciBlbGVtZW50TmFtZSA9IHZvaWQgMDtcbiAgdmFyIGVsZW1lbnROYW1lcyA9IFtdO1xuICB2YXIgZWxlbWVudE5hbWVMb29rdXAgPSB7fTtcblxuICAvLyBHZXQgdW5pcXVlIHN1Ym1pdHRhYmxlIGVsZW1lbnQgbmFtZXMgZm9yIHRoZSBmb3JtXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZm9ybS5lbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgZWxlbWVudCA9IGZvcm0uZWxlbWVudHNbaV07XG4gICAgaWYgKElHTk9SRURfRUxFTUVOVF9UWVBFU1tlbGVtZW50LnR5cGVdIHx8IGVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBlbGVtZW50TmFtZSA9IGVsZW1lbnQubmFtZSB8fCBlbGVtZW50LmlkO1xuICAgIGlmIChlbGVtZW50TmFtZSAmJiAhZWxlbWVudE5hbWVMb29rdXBbZWxlbWVudE5hbWVdKSB7XG4gICAgICBlbGVtZW50TmFtZXMucHVzaChlbGVtZW50TmFtZSk7XG4gICAgICBlbGVtZW50TmFtZUxvb2t1cFtlbGVtZW50TmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEV4dHJhY3QgZWxlbWVudCBkYXRhIG5hbWUtYnktbmFtZSBmb3IgY29uc2lzdGVudCBoYW5kbGluZyBvZiBzcGVjaWFsIGNhc2VzXG4gIC8vIGFyb3VuZCBlbGVtZW50cyB3aGljaCBjb250YWluIG11bHRpcGxlIGlucHV0cy5cbiAgZm9yICh2YXIgX2kgPSAwLCBfbCA9IGVsZW1lbnROYW1lcy5sZW5ndGg7IF9pIDwgX2w7IF9pKyspIHtcbiAgICBlbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lc1tfaV07XG4gICAgdmFyIHZhbHVlID0gZ2V0RmllbGREYXRhKGZvcm0sIGVsZW1lbnROYW1lLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgZGF0YVtlbGVtZW50TmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxGb3JtRWxlbWVudH0gZm9ybVxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyhzdHJpbmd8QXJyYXkuPHN0cmluZz4pfSBzdWJtaXR0YWJsZSB2YWx1ZShzKSBpbiB0aGUgZm9ybSBmb3IgYVxuICogICBuYW1lZCBlbGVtZW50IGZyb20gaXRzIC5lbGVtZW50cyBjb2xsZWN0aW9uLCBvciBudWxsIGlmIHRoZXJlIHdhcyBub1xuICogICBlbGVtZW50IHdpdGggdGhhdCBuYW1lIG9yIHRoZSBlbGVtZW50IGhhZCBubyBzdWJtaXR0YWJsZSB2YWx1ZShzKS5cbiAqL1xuZnVuY3Rpb24gZ2V0RmllbGREYXRhKGZvcm0sIGZpZWxkTmFtZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogeyB0cmltOiBmYWxzZSB9O1xuXG4gIGlmICghZm9ybSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBmb3JtIGlzIHJlcXVpcmVkIGJ5IGdldEZpZWxkRGF0YSwgd2FzIGdpdmVuIGZvcm09JyArIGZvcm0pO1xuICB9XG4gIGlmICghZmllbGROYW1lICYmIHRvU3RyaW5nLmNhbGwoZmllbGROYW1lKSAhPT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgZmllbGQgbmFtZSBpcyByZXF1aXJlZCBieSBnZXRGaWVsZERhdGEsIHdhcyBnaXZlbiBmaWVsZE5hbWU9JyArIGZpZWxkTmFtZSk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGZvcm0uZWxlbWVudHNbZmllbGROYW1lXTtcbiAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghTk9ERV9MSVNUX0NMQVNTRVNbdG9TdHJpbmcuY2FsbChlbGVtZW50KV0pIHtcbiAgICByZXR1cm4gZ2V0Rm9ybUVsZW1lbnRWYWx1ZShlbGVtZW50LCBvcHRpb25zLnRyaW0pO1xuICB9XG5cbiAgLy8gRGVhbCB3aXRoIG11bHRpcGxlIGZvcm0gY29udHJvbHMgd2hpY2ggaGF2ZSB0aGUgc2FtZSBuYW1lXG4gIHZhciBkYXRhID0gW107XG4gIHZhciBhbGxSYWRpb3MgPSB0cnVlO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsZW1lbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGVsZW1lbnRbaV0uZGlzYWJsZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsUmFkaW9zICYmIGVsZW1lbnRbaV0udHlwZSAhPT0gJ3JhZGlvJykge1xuICAgICAgYWxsUmFkaW9zID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IGdldEZvcm1FbGVtZW50VmFsdWUoZWxlbWVudFtpXSwgb3B0aW9ucy50cmltKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgZGF0YSA9IGRhdGEuY29uY2F0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBTcGVjaWFsIGNhc2UgZm9yIGFuIGVsZW1lbnQgd2l0aCBtdWx0aXBsZSBzYW1lLW5hbWVkIGlucHV0cyB3aGljaCB3ZXJlIGFsbFxuICAvLyByYWRpbyBidXR0b25zOiBpZiB0aGVyZSB3YXMgYSBzZWxlY3RlZCB2YWx1ZSwgb25seSByZXR1cm4gdGhlIHZhbHVlLlxuICBpZiAoYWxsUmFkaW9zICYmIGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGRhdGFbMF07XG4gIH1cblxuICByZXR1cm4gZGF0YS5sZW5ndGggPiAwID8gZGF0YSA6IG51bGw7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBhIGZvcm0gZWxlbWVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbX0gdHJpbSBzaG91bGQgdmFsdWVzIGZvciB0ZXh0IGVudHJ5IGlucHV0cyBiZSB0cmltbWVkP1xuICogQHJldHVybiB7KHN0cmluZ3xBcnJheS48c3RyaW5nPnxGaWxlfEFycmF5LjxGaWxlPil9IHRoZSBlbGVtZW50J3Mgc3VibWl0dGFibGVcbiAqICAgdmFsdWUocyksIG9yIG51bGwgaWYgaXQgaGFkIG5vbmUuXG4gKi9cbmZ1bmN0aW9uIGdldEZvcm1FbGVtZW50VmFsdWUoZWxlbWVudCwgdHJpbSkge1xuICB2YXIgdmFsdWUgPSBudWxsO1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuXG4gIGlmICh0eXBlID09PSAnc2VsZWN0LW9uZScpIHtcbiAgICBpZiAoZWxlbWVudC5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgdmFsdWUgPSBlbGVtZW50Lm9wdGlvbnNbZWxlbWVudC5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdzZWxlY3QtbXVsdGlwbGUnKSB7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsZW1lbnQub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChlbGVtZW50Lm9wdGlvbnNbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgdmFsdWUucHVzaChlbGVtZW50Lm9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8vIElmIGEgZmlsZSBpbnB1dCBkb2Vzbid0IGhhdmUgYSBmaWxlcyBhdHRyaWJ1dGUsIGZhbGwgdGhyb3VnaCB0byB1c2luZyBpdHNcbiAgLy8gdmFsdWUgYXR0cmlidXRlLlxuICBpZiAodHlwZSA9PT0gJ2ZpbGUnICYmICdmaWxlcycgaW4gZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50Lm11bHRpcGxlKSB7XG4gICAgICB2YWx1ZSA9IHNsaWNlLmNhbGwoZWxlbWVudC5maWxlcyk7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2hvdWxkIGJlIG51bGwgaWYgbm90IHByZXNlbnQsIGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAgICAgdmFsdWUgPSBlbGVtZW50LmZpbGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoIUNIRUNLRURfSU5QVVRfVFlQRVNbdHlwZV0pIHtcbiAgICB2YWx1ZSA9IHRyaW0gPyBlbGVtZW50LnZhbHVlLnJlcGxhY2UoVFJJTV9SRSwgJycpIDogZWxlbWVudC52YWx1ZTtcbiAgfSBlbHNlIGlmIChlbGVtZW50LmNoZWNrZWQpIHtcbiAgICB2YWx1ZSA9IGVsZW1lbnQudmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIEZvciBVTUQgYnVpbGQgYWNjZXNzIHRvIGdldEZpZWxkRGF0YVxuZ2V0Rm9ybURhdGEuZ2V0RmllbGREYXRhID0gZ2V0RmllbGREYXRhOyIsIi8qIGdsb2JhbCBCbG9iIEZpbGUgKi9cblxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHRvU3RyaW5nLmNhbGwoQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nO1xudmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIEZpbGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFN1cHBvcnRzIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEJsb2IgYW5kIEZpbGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeSAob2JqKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGhhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgKHdpdGhOYXRpdmVCbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgKHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9oYXMtYmluYXJ5L3B1bGwvNFxuICBpZiAob2JqLnRvSlNPTiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGhhc0JpbmFyeShvYmoudG9KU09OKCksIHRydWUpO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIGhhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1NoYWxsb3dFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWVcbiAgZm9yICh2YXIgaSBpbiBhKSBpZiAoIShpIGluIGIpKSByZXR1cm4gZmFsc2VcbiAgZm9yICh2YXIgaSBpbiBiKSBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiB0cnVlXG59XG4iLCIvKlxuICogIGJhc2U2NC5qc1xuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQlNEIDMtQ2xhdXNlIExpY2Vuc2UuXG4gKiAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogIFJlZmVyZW5jZXM6XG4gKiAgICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NFxuICovXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZ2xvYmFsKVxuICAgICAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgICAgICA/IGRlZmluZShmYWN0b3J5KSA6IGZhY3RvcnkoZ2xvYmFsKVxufSgoXG4gICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZlxuICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93XG4gICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxcbjogdGhpc1xuKSwgZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIGV4aXN0aW5nIHZlcnNpb24gZm9yIG5vQ29uZmxpY3QoKVxuICAgIGdsb2JhbCA9IGdsb2JhbCB8fCB7fTtcbiAgICB2YXIgX0Jhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgdmFyIHZlcnNpb24gPSBcIjIuNi40XCI7XG4gICAgLy8gY29uc3RhbnRzXG4gICAgdmFyIGI2NGNoYXJzXG4gICAgICAgID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICAgIHZhciBiNjR0YWIgPSBmdW5jdGlvbihiaW4pIHtcbiAgICAgICAgdmFyIHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBiaW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB0W2Jpbi5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfShiNjRjaGFycyk7XG4gICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgLy8gZW5jb2RlciBzdHVmZlxuICAgIHZhciBjYl91dG9iID0gZnVuY3Rpb24oYykge1xuICAgICAgICBpZiAoYy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICByZXR1cm4gY2MgPCAweDgwID8gY1xuICAgICAgICAgICAgICAgIDogY2MgPCAweDgwMCA/IChmcm9tQ2hhckNvZGUoMHhjMCB8IChjYyA+Pj4gNikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoY2MgJiAweDNmKSkpXG4gICAgICAgICAgICAgICAgOiAoZnJvbUNoYXJDb2RlKDB4ZTAgfCAoKGNjID4+PiAxMikgJiAweDBmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+ICA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKCBjYyAgICAgICAgICYgMHgzZikpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYyA9IDB4MTAwMDBcbiAgICAgICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMCkgLSAweEQ4MDApICogMHg0MDBcbiAgICAgICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMSkgLSAweERDMDApO1xuICAgICAgICAgICAgcmV0dXJuIChmcm9tQ2hhckNvZGUoMHhmMCB8ICgoY2MgPj4+IDE4KSAmIDB4MDcpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKChjYyA+Pj4gMTIpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiAgNikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICggY2MgICAgICAgICAmIDB4M2YpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZV91dG9iID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRkZdfFteXFx4MDAtXFx4N0ZdL2c7XG4gICAgdmFyIHV0b2IgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiB1LnJlcGxhY2UocmVfdXRvYiwgY2JfdXRvYik7XG4gICAgfTtcbiAgICB2YXIgY2JfZW5jb2RlID0gZnVuY3Rpb24oY2NjKSB7XG4gICAgICAgIHZhciBwYWRsZW4gPSBbMCwgMiwgMV1bY2NjLmxlbmd0aCAlIDNdLFxuICAgICAgICBvcmQgPSBjY2MuY2hhckNvZGVBdCgwKSA8PCAxNlxuICAgICAgICAgICAgfCAoKGNjYy5sZW5ndGggPiAxID8gY2NjLmNoYXJDb2RlQXQoMSkgOiAwKSA8PCA4KVxuICAgICAgICAgICAgfCAoKGNjYy5sZW5ndGggPiAyID8gY2NjLmNoYXJDb2RlQXQoMikgOiAwKSksXG4gICAgICAgIGNoYXJzID0gW1xuICAgICAgICAgICAgYjY0Y2hhcnMuY2hhckF0KCBvcmQgPj4+IDE4KSxcbiAgICAgICAgICAgIGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiAxMikgJiA2MyksXG4gICAgICAgICAgICBwYWRsZW4gPj0gMiA/ICc9JyA6IGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiA2KSAmIDYzKSxcbiAgICAgICAgICAgIHBhZGxlbiA+PSAxID8gJz0nIDogYjY0Y2hhcnMuY2hhckF0KG9yZCAmIDYzKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfTtcbiAgICB2YXIgYnRvYSA9IGdsb2JhbC5idG9hICYmIHR5cGVvZiBnbG9iYWwuYnRvYSA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gZnVuY3Rpb24oYil7IHJldHVybiBnbG9iYWwuYnRvYShiKSB9IDogZnVuY3Rpb24oYikge1xuICAgICAgICBpZiAoYi5tYXRjaCgvW15cXHgwMC1cXHhGRl0vKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICAnVGhlIHN0cmluZyBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYi5yZXBsYWNlKC9bXFxzXFxTXXsxLDN9L2csIGNiX2VuY29kZSk7XG4gICAgfTtcbiAgICB2YXIgX2VuY29kZSA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIGJ0b2EodXRvYihTdHJpbmcodSkpKTtcbiAgICB9O1xuICAgIHZhciBta1VyaVNhZmUgPSBmdW5jdGlvbiAoYjY0KSB7XG4gICAgICAgIHJldHVybiBiNjQucmVwbGFjZSgvWytcXC9dL2csIGZ1bmN0aW9uKG0wKSB7XG4gICAgICAgICAgICByZXR1cm4gbTAgPT0gJysnID8gJy0nIDogJ18nO1xuICAgICAgICB9KS5yZXBsYWNlKC89L2csICcnKTtcbiAgICB9O1xuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbih1LCB1cmlzYWZlKSB7XG4gICAgICAgIHJldHVybiB1cmlzYWZlID8gbWtVcmlTYWZlKF9lbmNvZGUodSkpIDogX2VuY29kZSh1KTtcbiAgICB9O1xuICAgIHZhciBlbmNvZGVVUkkgPSBmdW5jdGlvbih1KSB7IHJldHVybiBlbmNvZGUodSwgdHJ1ZSkgfTtcbiAgICB2YXIgZnJvbVVpbnQ4QXJyYXk7XG4gICAgaWYgKGdsb2JhbC5VaW50OEFycmF5KSBmcm9tVWludDhBcnJheSA9IGZ1bmN0aW9uKGEsIHVyaXNhZmUpIHtcbiAgICAgICAgLy8gcmV0dXJuIGJ0b2EoZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGEpKTtcbiAgICAgICAgdmFyIGI2NCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG4gICAgICAgICAgICB2YXIgYTAgPSBhW2ldLCBhMSA9IGFbaSsxXSwgYTIgPSBhW2krMl07XG4gICAgICAgICAgICB2YXIgb3JkID0gYTAgPDwgMTYgfCBhMSA8PCA4IHwgYTI7XG4gICAgICAgICAgICBiNjQgKz0gICAgYjY0Y2hhcnMuY2hhckF0KCBvcmQgPj4+IDE4KVxuICAgICAgICAgICAgICAgICsgICAgIGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiAxMikgJiA2MylcbiAgICAgICAgICAgICAgICArICggdHlwZW9mIGExICE9ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+ICA2KSAmIDYzKSA6ICc9JylcbiAgICAgICAgICAgICAgICArICggdHlwZW9mIGEyICE9ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gYjY0Y2hhcnMuY2hhckF0KCBvcmQgICAgICAgICAmIDYzKSA6ICc9Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaXNhZmUgPyBta1VyaVNhZmUoYjY0KSA6IGI2NDtcbiAgICB9O1xuICAgIC8vIGRlY29kZXIgc3R1ZmZcbiAgICB2YXIgcmVfYnRvdSA9IC9bXFx4QzAtXFx4REZdW1xceDgwLVxceEJGXXxbXFx4RTAtXFx4RUZdW1xceDgwLVxceEJGXXsyfXxbXFx4RjAtXFx4RjddW1xceDgwLVxceEJGXXszfS9nO1xuICAgIHZhciBjYl9idG91ID0gZnVuY3Rpb24oY2NjYykge1xuICAgICAgICBzd2l0Y2goY2NjYy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdmFyIGNwID0gKCgweDA3ICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxOClcbiAgICAgICAgICAgICAgICB8ICAgICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgMTIpXG4gICAgICAgICAgICAgICAgfCAgICAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpIDw8ICA2KVxuICAgICAgICAgICAgICAgIHwgICAgICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDMpKSxcbiAgICAgICAgICAgIG9mZnNldCA9IGNwIC0gMHgxMDAwMDtcbiAgICAgICAgICAgIHJldHVybiAoZnJvbUNoYXJDb2RlKChvZmZzZXQgID4+PiAxMCkgKyAweEQ4MDApXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKChvZmZzZXQgJiAweDNGRikgKyAweERDMDApKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShcbiAgICAgICAgICAgICAgICAoKDB4MGYgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDEyKVxuICAgICAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpXG4gICAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICBmcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgKCgweDFmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCA2KVxuICAgICAgICAgICAgICAgICAgICB8ICAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBidG91ID0gZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gYi5yZXBsYWNlKHJlX2J0b3UsIGNiX2J0b3UpO1xuICAgIH07XG4gICAgdmFyIGNiX2RlY29kZSA9IGZ1bmN0aW9uKGNjY2MpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNjY2MubGVuZ3RoLFxuICAgICAgICBwYWRsZW4gPSBsZW4gJSA0LFxuICAgICAgICBuID0gKGxlbiA+IDAgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMCldIDw8IDE4IDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDEgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMSldIDw8IDEyIDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDIgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMildIDw8ICA2IDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDMgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMyldICAgICAgIDogMCksXG4gICAgICAgIGNoYXJzID0gW1xuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKCBuID4+PiAxNiksXG4gICAgICAgICAgICBmcm9tQ2hhckNvZGUoKG4gPj4+ICA4KSAmIDB4ZmYpLFxuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKCBuICAgICAgICAgJiAweGZmKVxuICAgICAgICBdO1xuICAgICAgICBjaGFycy5sZW5ndGggLT0gWzAsIDAsIDIsIDFdW3BhZGxlbl07XG4gICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9O1xuICAgIHZhciBfYXRvYiA9IGdsb2JhbC5hdG9iICYmIHR5cGVvZiBnbG9iYWwuYXRvYiA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gZnVuY3Rpb24oYSl7IHJldHVybiBnbG9iYWwuYXRvYihhKSB9IDogZnVuY3Rpb24oYSl7XG4gICAgICAgIHJldHVybiBhLnJlcGxhY2UoL1xcU3sxLDR9L2csIGNiX2RlY29kZSk7XG4gICAgfTtcbiAgICB2YXIgYXRvYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIF9hdG9iKFN0cmluZyhhKS5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL10vZywgJycpKTtcbiAgICB9O1xuICAgIHZhciBfZGVjb2RlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gYnRvdShfYXRvYihhKSkgfTtcbiAgICB2YXIgX2Zyb21VUkkgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYSkucmVwbGFjZSgvWy1fXS9nLCBmdW5jdGlvbihtMCkge1xuICAgICAgICAgICAgcmV0dXJuIG0wID09ICctJyA/ICcrJyA6ICcvJ1xuICAgICAgICB9KS5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL10vZywgJycpO1xuICAgIH07XG4gICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gX2RlY29kZShfZnJvbVVSSShhKSk7XG4gICAgfTtcbiAgICB2YXIgdG9VaW50OEFycmF5O1xuICAgIGlmIChnbG9iYWwuVWludDhBcnJheSkgdG9VaW50OEFycmF5ID0gZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGF0b2IoX2Zyb21VUkkoYSkpLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBCYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgICAgICBnbG9iYWwuQmFzZTY0ID0gX0Jhc2U2NDtcbiAgICAgICAgcmV0dXJuIEJhc2U2NDtcbiAgICB9O1xuICAgIC8vIGV4cG9ydCBCYXNlNjRcbiAgICBnbG9iYWwuQmFzZTY0ID0ge1xuICAgICAgICBWRVJTSU9OOiB2ZXJzaW9uLFxuICAgICAgICBhdG9iOiBhdG9iLFxuICAgICAgICBidG9hOiBidG9hLFxuICAgICAgICBmcm9tQmFzZTY0OiBkZWNvZGUsXG4gICAgICAgIHRvQmFzZTY0OiBlbmNvZGUsXG4gICAgICAgIHV0b2I6IHV0b2IsXG4gICAgICAgIGVuY29kZTogZW5jb2RlLFxuICAgICAgICBlbmNvZGVVUkk6IGVuY29kZVVSSSxcbiAgICAgICAgYnRvdTogYnRvdSxcbiAgICAgICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgICAgIG5vQ29uZmxpY3Q6IG5vQ29uZmxpY3QsXG4gICAgICAgIGZyb21VaW50OEFycmF5OiBmcm9tVWludDhBcnJheSxcbiAgICAgICAgdG9VaW50OEFycmF5OiB0b1VpbnQ4QXJyYXlcbiAgICB9O1xuICAgIC8vIGlmIEVTNSBpcyBhdmFpbGFibGUsIG1ha2UgQmFzZTY0LmV4dGVuZFN0cmluZygpIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBub0VudW0gPSBmdW5jdGlvbih2KXtcbiAgICAgICAgICAgIHJldHVybiB7dmFsdWU6dixlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9O1xuICAgICAgICB9O1xuICAgICAgICBnbG9iYWwuQmFzZTY0LmV4dGVuZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICBTdHJpbmcucHJvdG90eXBlLCAnZnJvbUJhc2U2NCcsIG5vRW51bShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodGhpcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ3RvQmFzZTY0Jywgbm9FbnVtKGZ1bmN0aW9uICh1cmlzYWZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGUodGhpcywgdXJpc2FmZSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ3RvQmFzZTY0VVJJJywgbm9FbnVtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBleHBvcnQgQmFzZTY0IHRvIHRoZSBuYW1lc3BhY2VcbiAgICAvL1xuICAgIGlmIChnbG9iYWxbJ01ldGVvciddKSB7IC8vIE1ldGVvci5qc1xuICAgICAgICBCYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIH1cbiAgICAvLyBtb2R1bGUuZXhwb3J0cyBhbmQgQU1EIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAgLy8gbW9kdWxlLmV4cG9ydHMgaGFzIHByZWNlZGVuY2UuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzLkJhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKXsgcmV0dXJuIGdsb2JhbC5CYXNlNjQgfSk7XG4gICAgfVxuICAgIC8vIHRoYXQncyBpdCFcbiAgICByZXR1cm4ge0Jhc2U2NDogZ2xvYmFsLkJhc2U2NH1cbn0pKTtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdHRsZTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5sb2cyIHx8IGZ1bmN0aW9uICh4KSB7XG5cdHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMkU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhcmVJbnB1dHNFcXVhbChuZXdJbnB1dHMsIGxhc3RJbnB1dHMpIHtcbiAgICBpZiAobmV3SW5wdXRzLmxlbmd0aCAhPT0gbGFzdElucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0lucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobmV3SW5wdXRzW2ldICE9PSBsYXN0SW5wdXRzW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemVPbmUocmVzdWx0Rm4sIGlzRXF1YWwpIHtcbiAgICBpZiAoaXNFcXVhbCA9PT0gdm9pZCAwKSB7IGlzRXF1YWwgPSBhcmVJbnB1dHNFcXVhbDsgfVxuICAgIHZhciBsYXN0VGhpcztcbiAgICB2YXIgbGFzdEFyZ3MgPSBbXTtcbiAgICB2YXIgbGFzdFJlc3VsdDtcbiAgICB2YXIgY2FsbGVkT25jZSA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIG1lbW9pemVkKCkge1xuICAgICAgICB2YXIgbmV3QXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbmV3QXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsZWRPbmNlICYmIGxhc3RUaGlzID09PSB0aGlzICYmIGlzRXF1YWwobmV3QXJncywgbGFzdEFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UmVzdWx0ID0gcmVzdWx0Rm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgICAgIGNhbGxlZE9uY2UgPSB0cnVlO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RBcmdzID0gbmV3QXJncztcbiAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBtZW1vaXplZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplT25lO1xuIiwidmFyIHdpbGRjYXJkID0gcmVxdWlyZSgnd2lsZGNhcmQnKTtcbnZhciByZU1pbWVQYXJ0U3BsaXQgPSAvW1xcL1xcK1xcLl0vO1xuXG4vKipcbiAgIyBtaW1lLW1hdGNoXG5cbiAgQSBzaW1wbGUgZnVuY3Rpb24gdG8gY2hlY2tlciB3aGV0aGVyIGEgdGFyZ2V0IG1pbWUgdHlwZSBtYXRjaGVzIGEgbWltZS10eXBlXG4gIHBhdHRlcm4gKGUuZy4gaW1hZ2UvanBlZyBtYXRjaGVzIGltYWdlL2pwZWcgT1IgaW1hZ2UvKikuXG5cbiAgIyMgRXhhbXBsZSBVc2FnZVxuXG4gIDw8PCBleGFtcGxlLmpzXG5cbioqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHBhdHRlcm4pIHtcbiAgZnVuY3Rpb24gdGVzdChwYXR0ZXJuKSB7XG4gICAgdmFyIHJlc3VsdCA9IHdpbGRjYXJkKHBhdHRlcm4sIHRhcmdldCwgcmVNaW1lUGFydFNwbGl0KTtcblxuICAgIC8vIGVuc3VyZSB0aGF0IHdlIGhhdmUgYSB2YWxpZCBtaW1lIHR5cGUgKHNob3VsZCBoYXZlIHR3byBwYXJ0cylcbiAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdC5sZW5ndGggPj0gMjtcbiAgfVxuXG4gIHJldHVybiBwYXR0ZXJuID8gdGVzdChwYXR0ZXJuLnNwbGl0KCc7JylbMF0pIDogdGVzdDtcbn07XG4iLCIvKipcbiogQ3JlYXRlIGFuIGV2ZW50IGVtaXR0ZXIgd2l0aCBuYW1lc3BhY2VzXG4qIEBuYW1lIGNyZWF0ZU5hbWVzcGFjZUVtaXR0ZXJcbiogQGV4YW1wbGVcbiogdmFyIGVtaXR0ZXIgPSByZXF1aXJlKCcuL2luZGV4JykoKVxuKlxuKiBlbWl0dGVyLm9uKCcqJywgZnVuY3Rpb24gKCkge1xuKiAgIGNvbnNvbGUubG9nKCdhbGwgZXZlbnRzIGVtaXR0ZWQnLCB0aGlzLmV2ZW50KVxuKiB9KVxuKlxuKiBlbWl0dGVyLm9uKCdleGFtcGxlJywgZnVuY3Rpb24gKCkge1xuKiAgIGNvbnNvbGUubG9nKCdleGFtcGxlIGV2ZW50IGVtaXR0ZWQnKVxuKiB9KVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlTmFtZXNwYWNlRW1pdHRlciAoKSB7XG4gIHZhciBlbWl0dGVyID0ge31cbiAgdmFyIF9mbnMgPSBlbWl0dGVyLl9mbnMgPSB7fVxuXG4gIC8qKlxuICAqIEVtaXQgYW4gZXZlbnQuIE9wdGlvbmFsbHkgbmFtZXNwYWNlIHRoZSBldmVudC4gSGFuZGxlcnMgYXJlIGZpcmVkIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQgd2l0aCBleGFjdCBtYXRjaGVzIHRha2luZyBwcmVjZWRlbmNlLiBTZXBhcmF0ZSB0aGUgbmFtZXNwYWNlIGFuZCBldmVudCB3aXRoIGEgYDpgXG4gICogQG5hbWUgZW1pdFxuICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCDigJMgdGhlIG5hbWUgb2YgdGhlIGV2ZW50LCB3aXRoIG9wdGlvbmFsIG5hbWVzcGFjZVxuICAqIEBwYXJhbSB7Li4uKn0gZGF0YSDigJMgdXAgdG8gNiBhcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSBldmVudCBsaXN0ZW5lclxuICAqIEBleGFtcGxlXG4gICogZW1pdHRlci5lbWl0KCdleGFtcGxlJylcbiAgKiBlbWl0dGVyLmVtaXQoJ2RlbW86dGVzdCcpXG4gICogZW1pdHRlci5lbWl0KCdkYXRhJywgeyBleGFtcGxlOiB0cnVlfSwgJ2Egc3RyaW5nJywgMSlcbiAgKi9cbiAgZW1pdHRlci5lbWl0ID0gZnVuY3Rpb24gZW1pdCAoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYpIHtcbiAgICB2YXIgdG9FbWl0ID0gZ2V0TGlzdGVuZXJzKGV2ZW50KVxuXG4gICAgaWYgKHRvRW1pdC5sZW5ndGgpIHtcbiAgICAgIGVtaXRBbGwoZXZlbnQsIHRvRW1pdCwgW2FyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzZdKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIENyZWF0ZSBlbiBldmVudCBsaXN0ZW5lci5cbiAgKiBAbmFtZSBvblxuICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICogQGV4YW1wbGVcbiAgKiBlbWl0dGVyLm9uKCdleGFtcGxlJywgZnVuY3Rpb24gKCkge30pXG4gICogZW1pdHRlci5vbignZGVtbycsIGZ1bmN0aW9uICgpIHt9KVxuICAqL1xuICBlbWl0dGVyLm9uID0gZnVuY3Rpb24gb24gKGV2ZW50LCBmbikge1xuICAgIGlmICghX2Zuc1tldmVudF0pIHtcbiAgICAgIF9mbnNbZXZlbnRdID0gW11cbiAgICB9XG5cbiAgICBfZm5zW2V2ZW50XS5wdXNoKGZuKVxuICB9XG5cbiAgLyoqXG4gICogQ3JlYXRlIGVuIGV2ZW50IGxpc3RlbmVyIHRoYXQgZmlyZXMgb25jZS5cbiAgKiBAbmFtZSBvbmNlXG4gICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgKiBAZXhhbXBsZVxuICAqIGVtaXR0ZXIub25jZSgnZXhhbXBsZScsIGZ1bmN0aW9uICgpIHt9KVxuICAqIGVtaXR0ZXIub25jZSgnZGVtbycsIGZ1bmN0aW9uICgpIHt9KVxuICAqL1xuICBlbWl0dGVyLm9uY2UgPSBmdW5jdGlvbiBvbmNlIChldmVudCwgZm4pIHtcbiAgICBmdW5jdGlvbiBvbmUgKCkge1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgZW1pdHRlci5vZmYoZXZlbnQsIG9uZSlcbiAgICB9XG4gICAgdGhpcy5vbihldmVudCwgb25lKVxuICB9XG5cbiAgLyoqXG4gICogU3RvcCBsaXN0ZW5pbmcgdG8gYW4gZXZlbnQuIFN0b3AgYWxsIGxpc3RlbmVycyBvbiBhbiBldmVudCBieSBvbmx5IHBhc3NpbmcgdGhlIGV2ZW50IG5hbWUuIFN0b3AgYSBzaW5nbGUgbGlzdGVuZXIgYnkgcGFzc2luZyB0aGF0IGV2ZW50IGhhbmRsZXIgYXMgYSBjYWxsYmFjay5cbiAgKiBZb3UgbXVzdCBiZSBleHBsaWNpdCBhYm91dCB3aGF0IHdpbGwgYmUgdW5zdWJzY3JpYmVkOiBgZW1pdHRlci5vZmYoJ2RlbW8nKWAgd2lsbCB1bnN1YnNjcmliZSBhbiBgZW1pdHRlci5vbignZGVtbycpYCBsaXN0ZW5lcixcbiAgKiBgZW1pdHRlci5vZmYoJ2RlbW86ZXhhbXBsZScpYCB3aWxsIHVuc3Vic2NyaWJlIGFuIGBlbWl0dGVyLm9uKCdkZW1vOmV4YW1wbGUnKWAgbGlzdGVuZXJcbiAgKiBAbmFtZSBvZmZcbiAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIOKAkyB0aGUgc3BlY2lmaWMgaGFuZGxlclxuICAqIEBleGFtcGxlXG4gICogZW1pdHRlci5vZmYoJ2V4YW1wbGUnKVxuICAqIGVtaXR0ZXIub2ZmKCdkZW1vJywgZnVuY3Rpb24gKCkge30pXG4gICovXG4gIGVtaXR0ZXIub2ZmID0gZnVuY3Rpb24gb2ZmIChldmVudCwgZm4pIHtcbiAgICB2YXIga2VlcCA9IFtdXG5cbiAgICBpZiAoZXZlbnQgJiYgZm4pIHtcbiAgICAgIHZhciBmbnMgPSB0aGlzLl9mbnNbZXZlbnRdXG4gICAgICB2YXIgaSA9IDBcbiAgICAgIHZhciBsID0gZm5zID8gZm5zLmxlbmd0aCA6IDBcblxuICAgICAgZm9yIChpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChmbnNbaV0gIT09IGZuKSB7XG4gICAgICAgICAga2VlcC5wdXNoKGZuc1tpXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGtlZXAubGVuZ3RoID8gdGhpcy5fZm5zW2V2ZW50XSA9IGtlZXAgOiBkZWxldGUgdGhpcy5fZm5zW2V2ZW50XVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGlzdGVuZXJzIChlKSB7XG4gICAgdmFyIG91dCA9IF9mbnNbZV0gPyBfZm5zW2VdIDogW11cbiAgICB2YXIgaWR4ID0gZS5pbmRleE9mKCc6JylcbiAgICB2YXIgYXJncyA9IChpZHggPT09IC0xKSA/IFtlXSA6IFtlLnN1YnN0cmluZygwLCBpZHgpLCBlLnN1YnN0cmluZyhpZHggKyAxKV1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoX2ZucylcbiAgICB2YXIgaSA9IDBcbiAgICB2YXIgbCA9IGtleXMubGVuZ3RoXG5cbiAgICBmb3IgKGk7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgICBpZiAoa2V5ID09PSAnKicpIHtcbiAgICAgICAgb3V0ID0gb3V0LmNvbmNhdChfZm5zW2tleV0pXG4gICAgICB9XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMiAmJiBhcmdzWzBdID09PSBrZXkpIHtcbiAgICAgICAgb3V0ID0gb3V0LmNvbmNhdChfZm5zW2tleV0pXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdEFsbCAoZSwgZm5zLCBhcmdzKSB7XG4gICAgdmFyIGkgPSAwXG4gICAgdmFyIGwgPSBmbnMubGVuZ3RoXG5cbiAgICBmb3IgKGk7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICghZm5zW2ldKSBicmVha1xuICAgICAgZm5zW2ldLmV2ZW50ID0gZVxuICAgICAgZm5zW2ldLmFwcGx5KGZuc1tpXSwgYXJncylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW1pdHRlclxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbi8qKlxuICogU3RyaW5naWZ5IGFuIG9iamVjdCBmb3IgdXNlIGluIGEgcXVlcnkgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCAtIFdoZW4gbmVzdGluZywgdGhlIHBhcmVudCBrZXkuXG4gKiAgICAga2V5cyBpbiBgb2JqYCB3aWxsIGJlIHN0cmluZ2lmaWVkIGFzIGBwcmVmaXhba2V5XWAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcXVlcnlTdHJpbmdpZnkgKG9iaiwgcHJlZml4KSB7XG4gIHZhciBwYWlycyA9IFtdXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoIWhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBvYmpba2V5XVxuICAgIHZhciBlbmtleSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgdmFyIHBhaXJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgcGFpciA9IHF1ZXJ5U3RyaW5naWZ5KHZhbHVlLCBwcmVmaXggPyBwcmVmaXggKyAnWycgKyBlbmtleSArICddJyA6IGVua2V5KVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWlyID0gKHByZWZpeCA/IHByZWZpeCArICdbJyArIGVua2V5ICsgJ10nIDogZW5rZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKVxuICAgIH1cbiAgICBwYWlycy5wdXNoKHBhaXIpXG4gIH1cbiAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHVuZGVmO1xuXG4vKipcbiAqIERlY29kZSBhIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd8TnVsbH0gVGhlIGRlY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBlbmNvZGUgYSBnaXZlbiBpbnB1dC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIGVuY29kZWQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfE51bGx9IFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2ltcGxlIHF1ZXJ5IHN0cmluZyBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBwYXJzZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnkpIHtcbiAgdmFyIHBhcnNlciA9IC8oW149PyMmXSspPT8oW14mXSopL2dcbiAgICAsIHJlc3VsdCA9IHt9XG4gICAgLCBwYXJ0O1xuXG4gIHdoaWxlIChwYXJ0ID0gcGFyc2VyLmV4ZWMocXVlcnkpKSB7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0WzFdKVxuICAgICAgLCB2YWx1ZSA9IGRlY29kZShwYXJ0WzJdKTtcblxuICAgIC8vXG4gICAgLy8gUHJldmVudCBvdmVycmlkaW5nIG9mIGV4aXN0aW5nIHByb3BlcnRpZXMuIFRoaXMgZW5zdXJlcyB0aGF0IGJ1aWxkLWluXG4gICAgLy8gbWV0aG9kcyBsaWtlIGB0b1N0cmluZ2Agb3IgX19wcm90b19fIGFyZSBub3Qgb3ZlcnJpZGVuIGJ5IG1hbGljaW91c1xuICAgIC8vIHF1ZXJ5c3RyaW5ncy5cbiAgICAvL1xuICAgIC8vIEluIHRoZSBjYXNlIGlmIGZhaWxlZCBkZWNvZGluZywgd2Ugd2FudCB0byBvbWl0IHRoZSBrZXkvdmFsdWUgcGFpcnNcbiAgICAvLyBmcm9tIHRoZSByZXN1bHQuXG4gICAgLy9cbiAgICBpZiAoa2V5ID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsIHx8IGtleSBpbiByZXN1bHQpIGNvbnRpbnVlO1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHF1ZXJ5IHN0cmluZyB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IE9wdGlvbmFsIHByZWZpeC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZ2lmeShvYmosIHByZWZpeCkge1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgdmFyIHBhaXJzID0gW11cbiAgICAsIHZhbHVlXG4gICAgLCBrZXk7XG5cbiAgLy9cbiAgLy8gT3B0aW9uYWxseSBwcmVmaXggd2l0aCBhICc/JyBpZiBuZWVkZWRcbiAgLy9cbiAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJlZml4KSBwcmVmaXggPSAnPyc7XG5cbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFsdWUgPSBvYmpba2V5XTtcblxuICAgICAgLy9cbiAgICAgIC8vIEVkZ2UgY2FzZXMgd2hlcmUgd2UgYWN0dWFsbHkgd2FudCB0byBlbmNvZGUgdGhlIHZhbHVlIHRvIGFuIGVtcHR5XG4gICAgICAvLyBzdHJpbmcgaW5zdGVhZCBvZiB0aGUgc3RyaW5naWZpZWQgdmFsdWUuXG4gICAgICAvL1xuICAgICAgaWYgKCF2YWx1ZSAmJiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmIHx8IGlzTmFOKHZhbHVlKSkpIHtcbiAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgIH1cblxuICAgICAga2V5ID0gZW5jb2RlKGtleSk7XG4gICAgICB2YWx1ZSA9IGVuY29kZSh2YWx1ZSk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB3ZSBmYWlsZWQgdG8gZW5jb2RlIHRoZSBzdHJpbmdzLCB3ZSBzaG91bGQgYmFpbCBvdXQgYXMgd2UgZG9uJ3RcbiAgICAgIC8vIHdhbnQgdG8gYWRkIGludmFsaWQgc3RyaW5ncyB0byB0aGUgcXVlcnkuXG4gICAgICAvL1xuICAgICAgaWYgKGtleSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBwYWlycy5wdXNoKGtleSArJz0nKyB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhaXJzLmxlbmd0aCA/IHByZWZpeCArIHBhaXJzLmpvaW4oJyYnKSA6ICcnO1xufVxuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBxdWVyeXN0cmluZ2lmeTtcbmV4cG9ydHMucGFyc2UgPSBxdWVyeXN0cmluZztcbiIsIi8qISBxdWV1ZS1taWNyb3Rhc2suIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmxldCBwcm9taXNlXG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nXG4gID8gcXVldWVNaWNyb3Rhc2suYmluZCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcbiAgLy8gcmV1c2UgcmVzb2x2ZWQgcHJvbWlzZSwgYW5kIGFsbG9jYXRlIGl0IGxhemlseVxuICA6IGNiID0+IChwcm9taXNlIHx8IChwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkpKVxuICAgIC50aGVuKGNiKVxuICAgIC5jYXRjaChlcnIgPT4gc2V0VGltZW91dCgoKSA9PiB7IHRocm93IGVyciB9LCAwKSlcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsLlJlc2l6ZU9ic2VydmVyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbGxlY3Rpb24gb2Ygc2hpbXMgdGhhdCBwcm92aWRlIG1pbmltYWwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgRVM2IGNvbGxlY3Rpb25zLlxyXG4gICAgICpcclxuICAgICAqIFRoZXNlIGltcGxlbWVudGF0aW9ucyBhcmUgbm90IG1lYW50IHRvIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJcclxuICAgICAqIG1vZHVsZXMgYXMgdGhleSBjb3ZlciBvbmx5IGEgbGltaXRlZCByYW5nZSBvZiB1c2UgY2FzZXMuXHJcbiAgICAgKi9cclxuICAgIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MsIHZhbGlkLWpzZG9jICovXHJcbiAgICB2YXIgTWFwU2hpbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgaW5kZXggaW4gcHJvdmlkZWQgYXJyYXkgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxBcnJheT59IGFyclxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBnZXRJbmRleChhcnIsIGtleSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gLTE7XHJcbiAgICAgICAgICAgIGFyci5zb21lKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbnRyeVswXSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZW50cmllc19fLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fX2VudHJpZXNfX1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMV07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfX1tpbmRleF1bMV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18ucHVzaChba2V5LCB2YWx1ZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuX19lbnRyaWVzX187XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleChlbnRyaWVzLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhfmdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5zcGxpY2UoMCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IFtjdHg9bnVsbF1cclxuICAgICAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjdHgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdHggPT09IHZvaWQgMCkgeyBjdHggPSBudWxsOyB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fX2VudHJpZXNfXzsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVudHJ5WzFdLCBlbnRyeVswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICB9KSgpO1xuXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlY3RzIHdoZXRoZXIgd2luZG93IGFuZCBkb2N1bWVudCBvYmplY3RzIGFyZSBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC5cclxuICAgICAqL1xyXG4gICAgdmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ID09PSBkb2N1bWVudDtcblxuICAgIC8vIFJldHVybnMgZ2xvYmFsIG9iamVjdCBvZiBhIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbiAgICB2YXIgZ2xvYmFsJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xyXG4gICAgICAgIHJldHVybiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG4gICAgfSkoKTtcblxuICAgIC8qKlxyXG4gICAgICogQSBzaGltIGZvciB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdoaWNoIGZhbGxzIGJhY2sgdG8gdGhlIHNldFRpbWVvdXQgaWZcclxuICAgICAqIGZpcnN0IG9uZSBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJlcXVlc3RzJyBpZGVudGlmaWVyLlxyXG4gICAgICovXHJcbiAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIEl0J3MgcmVxdWlyZWQgdG8gdXNlIGEgYm91bmRlZCBmdW5jdGlvbiBiZWNhdXNlIElFIHNvbWV0aW1lcyB0aHJvd3NcclxuICAgICAgICAgICAgLy8gYW4gXCJJbnZhbGlkIGNhbGxpbmcgb2JqZWN0XCIgZXJyb3IgaWYgckFGIGlzIGludm9rZWQgd2l0aG91dCB0aGUgZ2xvYmFsXHJcbiAgICAgICAgICAgIC8vIG9iamVjdCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUuXHJcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChnbG9iYWwkMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soRGF0ZS5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XHJcbiAgICB9KSgpO1xuXG4gICAgLy8gRGVmaW5lcyBtaW5pbXVtIHRpbWVvdXQgYmVmb3JlIGFkZGluZyBhIHRyYWlsaW5nIGNhbGwuXHJcbiAgICB2YXIgdHJhaWxpbmdUaW1lb3V0ID0gMjtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggZW5zdXJlcyB0aGF0IHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmVcclxuICAgICAqIGludm9rZWQgb25seSBvbmNlIGR1cmluZyB0aGUgc3BlY2lmaWVkIGRlbGF5IHBlcmlvZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGRlbGF5IHBlcmlvZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIERlbGF5IGFmdGVyIHdoaWNoIHRvIGludm9rZSBjYWxsYmFjay5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUgKGNhbGxiYWNrLCBkZWxheSkge1xyXG4gICAgICAgIHZhciBsZWFkaW5nQ2FsbCA9IGZhbHNlLCB0cmFpbGluZ0NhbGwgPSBmYWxzZSwgbGFzdENhbGxUaW1lID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnZva2VzIHRoZSBvcmlnaW5hbCBjYWxsYmFjayBmdW5jdGlvbiBhbmQgc2NoZWR1bGVzIG5ldyBpbnZvY2F0aW9uIGlmXHJcbiAgICAgICAgICogdGhlIFwicHJveHlcIiB3YXMgY2FsbGVkIGR1cmluZyBjdXJyZW50IHJlcXVlc3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlUGVuZGluZygpIHtcclxuICAgICAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHJhaWxpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwcm94eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxiYWNrIGludm9rZWQgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkZWxheS4gSXQgd2lsbCBmdXJ0aGVyIHBvc3Rwb25lXHJcbiAgICAgICAgICogaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gZGVsZWdhdGluZyBpdCB0byB0aGVcclxuICAgICAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiB0aW1lb3V0Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxKHJlc29sdmVQZW5kaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2NoZWR1bGVzIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcHJveHkoKSB7XHJcbiAgICAgICAgICAgIHZhciB0aW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlamVjdCBpbW1lZGlhdGVseSBmb2xsb3dpbmcgY2FsbHMuXHJcbiAgICAgICAgICAgICAgICBpZiAodGltZVN0YW1wIC0gbGFzdENhbGxUaW1lIDwgdHJhaWxpbmdUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgbmV3IGNhbGwgdG8gYmUgaW4gaW52b2tlZCB3aGVuIHRoZSBwZW5kaW5nIG9uZSBpcyByZXNvbHZlZC5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciBcInRyYW5zaXRpb25zXCIgd2hpY2ggbmV2ZXIgYWN0dWFsbHkgc3RhcnRcclxuICAgICAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHNvIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgd2UgbWlnaHQgbWlzcyBvbmUgaWYgY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAvLyBoYXBwZW5zIGFtaWRzIHRoZSBwZW5kaW5nIGludm9jYXRpb24uXHJcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0NhbGwgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWVTdGFtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb3h5O1xyXG4gICAgfVxuXG4gICAgLy8gTWluaW11bSBkZWxheSBiZWZvcmUgaW52b2tpbmcgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuXHJcbiAgICB2YXIgUkVGUkVTSF9ERUxBWSA9IDIwO1xyXG4gICAgLy8gQSBsaXN0IG9mIHN1YnN0cmluZ3Mgb2YgQ1NTIHByb3BlcnRpZXMgdXNlZCB0byBmaW5kIHRyYW5zaXRpb24gZXZlbnRzIHRoYXRcclxuICAgIC8vIG1pZ2h0IGFmZmVjdCBkaW1lbnNpb25zIG9mIG9ic2VydmVkIGVsZW1lbnRzLlxyXG4gICAgdmFyIHRyYW5zaXRpb25LZXlzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3NpemUnLCAnd2VpZ2h0J107XHJcbiAgICAvLyBDaGVjayBpZiBNdXRhdGlvbk9ic2VydmVyIGlzIGF2YWlsYWJsZS5cclxuICAgIHZhciBtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaW5nbGV0b24gY29udHJvbGxlciBjbGFzcyB3aGljaCBoYW5kbGVzIHVwZGF0ZXMgb2YgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2VzLlxyXG4gICAgICovXHJcbiAgICB2YXIgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBET00gbGlzdGVuZXJzIGhhdmUgYmVlbiBhZGRlZC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRlbGxzIHRoYXQgY29udHJvbGxlciBoYXMgc3Vic2NyaWJlZCBmb3IgTXV0YXRpb24gRXZlbnRzLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEtlZXBzIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgTXV0YXRpb25PYnNlcnZlci5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHByaXZhdGUge011dGF0aW9uT2JzZXJ2ZXJ9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGxpc3Qgb2YgY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmVyU1BJPn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzXyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZF8gPSB0aGlzLm9uVHJhbnNpdGlvbkVuZF8uYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoID0gdGhyb3R0bGUodGhpcy5yZWZyZXNoLmJpbmQodGhpcyksIFJFRlJFU0hfREVMQVkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIG9ic2VydmVyIHRvIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSBhZGRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmFkZE9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIGlmICghfnRoaXMub2JzZXJ2ZXJzXy5pbmRleE9mKG9ic2VydmVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnNfLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFkZCBsaXN0ZW5lcnMgaWYgdGhleSBoYXZlbid0IGJlZW4gYWRkZWQgeWV0LlxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBvYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBvYnNlcnZlciBpZiBpdCdzIHByZXNlbnQgaW4gcmVnaXN0cnkuXHJcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBsaXN0ZW5lcnMgaWYgY29udHJvbGxlciBoYXMgbm8gY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICAgICAgaWYgKCFvYnNlcnZlcnMubGVuZ3RoICYmIHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnZva2VzIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLiBJdCB3aWxsIGNvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpbnNvZmFyXHJcbiAgICAgICAgICogaXQgZGV0ZWN0cyBjaGFuZ2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlc0RldGVjdGVkID0gdGhpcy51cGRhdGVPYnNlcnZlcnNfKCk7XHJcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpZiBjaGFuZ2VzIGhhdmUgYmVlbiBkZXRlY3RlZCBhcyB0aGVyZSBtaWdodFxyXG4gICAgICAgICAgICAvLyBiZSBmdXR1cmUgb25lcyBjYXVzZWQgYnkgQ1NTIHRyYW5zaXRpb25zLlxyXG4gICAgICAgICAgICBpZiAoY2hhbmdlc0RldGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBldmVyeSBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0IGFuZCBub3RpZmllcyB0aGVtIG9mIHF1ZXVlZFxyXG4gICAgICAgICAqIGVudHJpZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIFwidHJ1ZVwiIGlmIGFueSBvYnNlcnZlciBoYXMgZGV0ZWN0ZWQgY2hhbmdlcyBpblxyXG4gICAgICAgICAqICAgICAgZGltZW5zaW9ucyBvZiBpdCdzIGVsZW1lbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlT2JzZXJ2ZXJzXyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gQ29sbGVjdCBvYnNlcnZlcnMgdGhhdCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgICAgIHZhciBhY3RpdmVPYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc18uZmlsdGVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmdhdGhlckFjdGl2ZSgpLCBvYnNlcnZlci5oYXNBY3RpdmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIERlbGl2ZXIgbm90aWZpY2F0aW9ucyBpbiBhIHNlcGFyYXRlIGN5Y2xlIGluIG9yZGVyIHRvIGF2b2lkIGFueVxyXG4gICAgICAgICAgICAvLyBjb2xsaXNpb25zIGJldHdlZW4gb2JzZXJ2ZXJzLCBlLmcuIHdoZW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mXHJcbiAgICAgICAgICAgIC8vIFJlc2l6ZU9ic2VydmVyIGFyZSB0cmFja2luZyB0aGUgc2FtZSBlbGVtZW50IGFuZCB0aGUgY2FsbGJhY2sgb2Ygb25lXHJcbiAgICAgICAgICAgIC8vIG9mIHRoZW0gY2hhbmdlcyBjb250ZW50IGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIHRhcmdldC4gU29tZXRpbWVzXHJcbiAgICAgICAgICAgIC8vIHRoaXMgbWF5IHJlc3VsdCBpbiBub3RpZmljYXRpb25zIGJlaW5nIGJsb2NrZWQgZm9yIHRoZSByZXN0IG9mIG9ic2VydmVycy5cclxuICAgICAgICAgICAgYWN0aXZlT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7IHJldHVybiBvYnNlcnZlci5icm9hZGNhc3RBY3RpdmUoKTsgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVPYnNlcnZlcnMubGVuZ3RoID4gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSBhZGRlZC5cclxuICAgICAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU3Vic2NyaXB0aW9uIHRvIHRoZSBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBpcyB1c2VkIGFzIGEgd29ya2Fyb3VuZCBmb3JcclxuICAgICAgICAgICAgLy8gZGVsYXllZCB0cmFuc2l0aW9ucy4gVGhpcyB3YXkgaXQncyBwb3NzaWJsZSB0byBjYXB0dXJlIGF0IGxlYXN0IHRoZVxyXG4gICAgICAgICAgICAvLyBmaW5hbCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmRfKTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5vYnNlcnZlKGRvY3VtZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBET00gbGlzdGVuZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgcmVtb3ZlZC5cclxuICAgICAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8pIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaGFuZGxlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtUcmFuc2l0aW9uRXZlbnR9IGV2ZW50XHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5vblRyYW5zaXRpb25FbmRfID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBfYiA9IF9hLnByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XHJcbiAgICAgICAgICAgIC8vIERldGVjdCB3aGV0aGVyIHRyYW5zaXRpb24gbWF5IGFmZmVjdCBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgICAgIHZhciBpc1JlZmxvd1Byb3BlcnR5ID0gdHJhbnNpdGlvbktleXMuc29tZShmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISF+cHJvcGVydHlOYW1lLmluZGV4T2Yoa2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChpc1JlZmxvd1Byb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBpbnN0YW5jZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnN0YW5jZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VfID0gbmV3IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlXztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhvbGRzIHJlZmVyZW5jZSB0byB0aGUgY29udHJvbGxlcidzIGluc3RhbmNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuaW5zdGFuY2VfID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyO1xyXG4gICAgfSgpKTtcblxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBub24td3JpdGFibGUvZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBwcm92aWRlZCB0YXJnZXQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgZm9yIHdoaWNoIHRvIGRlZmluZSBwcm9wZXJ0aWVzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gUHJvcGVydGllcyB0byBiZSBkZWZpbmVkLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGFyZ2V0IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdmFyIGRlZmluZUNvbmZpZ3VyYWJsZSA9IChmdW5jdGlvbiAodGFyZ2V0LCBwcm9wcykge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhwcm9wcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH0pO1xuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBnbG9iYWwgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHZhciBnZXRXaW5kb3dPZiA9IChmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gQXNzdW1lIHRoYXQgdGhlIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgTm9kZSwgd2hpY2ggbWVhbnMgdGhhdCBpdFxyXG4gICAgICAgIC8vIGhhcyB0aGUgXCJvd25lckRvY3VtZW50XCIgcHJvcGVydHkgZnJvbSB3aGljaCB3ZSBjYW4gcmV0cmlldmUgYVxyXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgZ2xvYmFsIG9iamVjdC5cclxuICAgICAgICB2YXIgb3duZXJHbG9iYWwgPSB0YXJnZXQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBsb2NhbCBnbG9iYWwgb2JqZWN0IGlmIGl0J3Mgbm90IHBvc3NpYmxlIGV4dHJhY3Qgb25lIGZyb21cclxuICAgICAgICAvLyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICAgIHJldHVybiBvd25lckdsb2JhbCB8fCBnbG9iYWwkMTtcclxuICAgIH0pO1xuXG4gICAgLy8gUGxhY2Vob2xkZXIgb2YgYW4gZW1wdHkgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICB2YXIgZW1wdHlSZWN0ID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHByb3ZpZGVkIHN0cmluZyB0byBhIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3RzIGJvcmRlcnMgc2l6ZSBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gICAgICogQHBhcmFtIHsuLi5zdHJpbmd9IHBvc2l0aW9ucyAtIEJvcmRlcnMgcG9zaXRpb25zICh0b3AsIHJpZ2h0LCAuLi4pXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMpIHtcclxuICAgICAgICB2YXIgcG9zaXRpb25zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgcG9zaXRpb25zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9zaXRpb25zLnJlZHVjZShmdW5jdGlvbiAoc2l6ZSwgcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydib3JkZXItJyArIHBvc2l0aW9uICsgJy13aWR0aCddO1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZSArIHRvRmxvYXQodmFsdWUpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyYWN0cyBwYWRkaW5ncyBzaXplcyBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUGFkZGluZ3MgYm94LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRQYWRkaW5ncyhzdHlsZXMpIHtcclxuICAgICAgICB2YXIgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcclxuICAgICAgICB2YXIgcGFkZGluZ3MgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHBvc2l0aW9uc18xID0gcG9zaXRpb25zOyBfaSA8IHBvc2l0aW9uc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBwb3NpdGlvbnNfMVtfaV07XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1sncGFkZGluZy0nICsgcG9zaXRpb25dO1xyXG4gICAgICAgICAgICBwYWRkaW5nc1twb3NpdGlvbl0gPSB0b0Zsb2F0KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhZGRpbmdzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIFNWRyBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U1ZHR3JhcGhpY3NFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzXHJcbiAgICAgKiAgICAgIHRvIGJlIGNhbGN1bGF0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgICAgIHZhciBiYm94ID0gdGFyZ2V0LmdldEJCb3goKTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQoMCwgMCwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIEhUTUxFbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gQ2xpZW50IHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgY2FuJ3QgYmVcclxuICAgICAgICAvLyB1c2VkIGV4Y2x1c2l2ZWx5IGFzIHRoZXkgcHJvdmlkZSByb3VuZGVkIHZhbHVlcy5cclxuICAgICAgICB2YXIgY2xpZW50V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgLy8gQnkgdGhpcyBjb25kaXRpb24gd2UgY2FuIGNhdGNoIGFsbCBub24tcmVwbGFjZWQgaW5saW5lLCBoaWRkZW4gYW5kXHJcbiAgICAgICAgLy8gZGV0YWNoZWQgZWxlbWVudHMuIFRob3VnaCBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgbGVzc1xyXG4gICAgICAgIC8vIHRoYW4gMC41IHdpbGwgYmUgZGlzY2FyZGVkIGFzIHdlbGwuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBXaXRob3V0IGl0IHdlIHdvdWxkIG5lZWQgdG8gaW1wbGVtZW50IHNlcGFyYXRlIG1ldGhvZHMgZm9yIGVhY2ggb2ZcclxuICAgICAgICAvLyB0aG9zZSBjYXNlcyBhbmQgaXQncyBub3QgcG9zc2libGUgdG8gcGVyZm9ybSBhIHByZWNpc2UgYW5kIHBlcmZvcm1hbmNlXHJcbiAgICAgICAgLy8gZWZmZWN0aXZlIHRlc3QgZm9yIGhpZGRlbiBlbGVtZW50cy4gRS5nLiBldmVuIGpRdWVyeSdzICc6dmlzaWJsZScgZmlsdGVyXHJcbiAgICAgICAgLy8gZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBsZXNzIHRoYW4gMC41LlxyXG4gICAgICAgIGlmICghY2xpZW50V2lkdGggJiYgIWNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3R5bGVzID0gZ2V0V2luZG93T2YodGFyZ2V0KS5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XHJcbiAgICAgICAgdmFyIHBhZGRpbmdzID0gZ2V0UGFkZGluZ3Moc3R5bGVzKTtcclxuICAgICAgICB2YXIgaG9yaXpQYWQgPSBwYWRkaW5ncy5sZWZ0ICsgcGFkZGluZ3MucmlnaHQ7XHJcbiAgICAgICAgdmFyIHZlcnRQYWQgPSBwYWRkaW5ncy50b3AgKyBwYWRkaW5ncy5ib3R0b207XHJcbiAgICAgICAgLy8gQ29tcHV0ZWQgc3R5bGVzIG9mIHdpZHRoICYgaGVpZ2h0IGFyZSBiZWluZyB1c2VkIGJlY2F1c2UgdGhleSBhcmUgdGhlXHJcbiAgICAgICAgLy8gb25seSBkaW1lbnNpb25zIGF2YWlsYWJsZSB0byBKUyB0aGF0IGNvbnRhaW4gbm9uLXJvdW5kZWQgdmFsdWVzLiBJdCBjb3VsZFxyXG4gICAgICAgIC8vIGJlIHBvc3NpYmxlIHRvIHV0aWxpemUgdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpZiBvbmx5IGl0J3MgZGF0YSB3YXNuJ3RcclxuICAgICAgICAvLyBhZmZlY3RlZCBieSBDU1MgdHJhbnNmb3JtYXRpb25zIGxldCBhbG9uZSBwYWRkaW5ncywgYm9yZGVycyBhbmQgc2Nyb2xsIGJhcnMuXHJcbiAgICAgICAgdmFyIHdpZHRoID0gdG9GbG9hdChzdHlsZXMud2lkdGgpLCBoZWlnaHQgPSB0b0Zsb2F0KHN0eWxlcy5oZWlnaHQpO1xyXG4gICAgICAgIC8vIFdpZHRoICYgaGVpZ2h0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgd2hlbiB0aGUgJ2JvcmRlci1ib3gnIGJveFxyXG4gICAgICAgIC8vIG1vZGVsIGlzIGFwcGxpZWQgKGV4Y2VwdCBmb3IgSUUpLlxyXG4gICAgICAgIGlmIChzdHlsZXMuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpIHtcclxuICAgICAgICAgICAgLy8gRm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGhhbmRsZSBJbnRlcm5ldCBFeHBsb3JlciB3aGljaFxyXG4gICAgICAgICAgICAvLyBkb2Vzbid0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgdG8gY29tcHV0ZWQgQ1NTIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIFdlIGNhbiBzYXkgdGhhdCBpZiBDU1MgZGltZW5zaW9ucyArIHBhZGRpbmdzIGFyZSBlcXVhbCB0byB0aGUgXCJjbGllbnRcIlxyXG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIHRoZW4gaXQncyBlaXRoZXIgSUUsIGFuZCB0aHVzIHdlIGRvbid0IG5lZWQgdG8gc3VidHJhY3RcclxuICAgICAgICAgICAgLy8gYW55dGhpbmcsIG9yIGFuIGVsZW1lbnQgbWVyZWx5IGRvZXNuJ3QgaGF2ZSBwYWRkaW5ncy9ib3JkZXJzIHN0eWxlcy5cclxuICAgICAgICAgICAgaWYgKE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgIT09IGNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICdsZWZ0JywgJ3JpZ2h0JykgKyBob3JpelBhZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAhPT0gY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAndG9wJywgJ2JvdHRvbScpICsgdmVydFBhZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGb2xsb3dpbmcgc3RlcHMgY2FuJ3QgYmUgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQncyByb290IGVsZW1lbnQgYXMgaXRzXHJcbiAgICAgICAgLy8gY2xpZW50W1dpZHRoL0hlaWdodF0gcHJvcGVydGllcyByZXByZXNlbnQgdmlld3BvcnQgYXJlYSBvZiB0aGUgd2luZG93LlxyXG4gICAgICAgIC8vIEJlc2lkZXMsIGl0J3MgYXMgd2VsbCBub3QgbmVjZXNzYXJ5IGFzIHRoZSA8aHRtbD4gaXRzZWxmIG5laXRoZXIgaGFzXHJcbiAgICAgICAgLy8gcmVuZGVyZWQgc2Nyb2xsIGJhcnMgbm9yIGl0IGNhbiBiZSBjbGlwcGVkLlxyXG4gICAgICAgIGlmICghaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIChvbmx5IGluIEZpcmVmb3gsIGFjdHVhbGx5KSBDU1Mgd2lkdGggJiBoZWlnaHRcclxuICAgICAgICAgICAgLy8gaW5jbHVkZSBzY3JvbGwgYmFycyBzaXplIHdoaWNoIGNhbiBiZSByZW1vdmVkIGF0IHRoaXMgc3RlcCBhcyBzY3JvbGxcclxuICAgICAgICAgICAgLy8gYmFycyBhcmUgdGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIHJvdW5kZWQgZGltZW5zaW9ucyArIHBhZGRpbmdzXHJcbiAgICAgICAgICAgIC8vIGFuZCBcImNsaWVudFwiIHByb3BlcnRpZXMsIHRob3VnaCB0aGF0IGlzIG5vdCBhbHdheXMgdHJ1ZSBpbiBDaHJvbWUuXHJcbiAgICAgICAgICAgIHZhciB2ZXJ0U2Nyb2xsYmFyID0gTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAtIGNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpIC0gY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICAvLyBDaHJvbWUgaGFzIGEgcmF0aGVyIHdlaXJkIHJvdW5kaW5nIG9mIFwiY2xpZW50XCIgcHJvcGVydGllcy5cclxuICAgICAgICAgICAgLy8gRS5nLiBmb3IgYW4gZWxlbWVudCB3aXRoIGNvbnRlbnQgd2lkdGggb2YgMzE0LjJweCBpdCBzb21ldGltZXMgZ2l2ZXNcclxuICAgICAgICAgICAgLy8gdGhlIGNsaWVudCB3aWR0aCBvZiAzMTVweCBhbmQgZm9yIHRoZSB3aWR0aCBvZiAzMTQuN3B4IGl0IG1heSBnaXZlXHJcbiAgICAgICAgICAgIC8vIDMxNHB4LiBBbmQgaXQgZG9lc24ndCBoYXBwZW4gYWxsIHRoZSB0aW1lLiBTbyBqdXN0IGlnbm9yZSB0aGlzIGRlbHRhXHJcbiAgICAgICAgICAgIC8vIGFzIGEgbm9uLXJlbGV2YW50LlxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModmVydFNjcm9sbGJhcikgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoIC09IHZlcnRTY3JvbGxiYXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGhvcml6U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0IC09IGhvcml6U2Nyb2xsYmFyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdChwYWRkaW5ncy5sZWZ0LCBwYWRkaW5ncy50b3AsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBTVkdHcmFwaGljc0VsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdmFyIGlzU1ZHR3JhcGhpY3NFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBTb21lIGJyb3dzZXJzLCBuYW1lbHkgSUUgYW5kIEVkZ2UsIGRvbid0IGhhdmUgdGhlIFNWR0dyYXBoaWNzRWxlbWVudFxyXG4gICAgICAgIC8vIGludGVyZmFjZS5cclxuICAgICAgICBpZiAodHlwZW9mIFNWR0dyYXBoaWNzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHR3JhcGhpY3NFbGVtZW50OyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBpdCdzIHNvLCB0aGVuIGNoZWNrIHRoYXQgZWxlbWVudCBpcyBhdCBsZWFzdCBhbiBpbnN0YW5jZSBvZiB0aGVcclxuICAgICAgICAvLyBTVkdFbGVtZW50IGFuZCB0aGF0IGl0IGhhcyB0aGUgXCJnZXRCQm94XCIgbWV0aG9kLlxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHRWxlbWVudCAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgdGFyZ2V0LmdldEJCb3ggPT09ICdmdW5jdGlvbicpOyB9O1xyXG4gICAgfSkoKTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhIGRvY3VtZW50IGVsZW1lbnQgKDxodG1sPikuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNEb2N1bWVudEVsZW1lbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldCA9PT0gZ2V0V2luZG93T2YodGFyZ2V0KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYW4gYXBwcm9wcmlhdGUgY29udGVudCByZWN0YW5nbGUgZm9yIHByb3ZpZGVkIGh0bWwgb3Igc3ZnIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldENvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgICAgIGlmICghaXNCcm93c2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1NWR0dyYXBoaWNzRWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHJlY3RhbmdsZSB3aXRoIGFuIGludGVyZmFjZSBvZiB0aGUgRE9NUmVjdFJlYWRPbmx5LlxyXG4gICAgICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RvbXJlY3RyZWFkb25seVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gT2JqZWN0IHdpdGggcmVjdGFuZ2xlJ3MgeC95IGNvb3JkaW5hdGVzIGFuZCBkaW1lbnNpb25zLlxyXG4gICAgICogQHJldHVybnMge0RPTVJlY3RSZWFkT25seX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVhZE9ubHlSZWN0KF9hKSB7XHJcbiAgICAgICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIC8vIElmIERPTVJlY3RSZWFkT25seSBpcyBhdmFpbGFibGUgdXNlIGl0IGFzIGEgcHJvdG90eXBlIGZvciB0aGUgcmVjdGFuZ2xlLlxyXG4gICAgICAgIHZhciBDb25zdHIgPSB0eXBlb2YgRE9NUmVjdFJlYWRPbmx5ICE9PSAndW5kZWZpbmVkJyA/IERPTVJlY3RSZWFkT25seSA6IE9iamVjdDtcclxuICAgICAgICB2YXIgcmVjdCA9IE9iamVjdC5jcmVhdGUoQ29uc3RyLnByb3RvdHlwZSk7XHJcbiAgICAgICAgLy8gUmVjdGFuZ2xlJ3MgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZS5cclxuICAgICAgICBkZWZpbmVDb25maWd1cmFibGUocmVjdCwge1xyXG4gICAgICAgICAgICB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICB0b3A6IHksXHJcbiAgICAgICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXHJcbiAgICAgICAgICAgIGJvdHRvbTogaGVpZ2h0ICsgeSxcclxuICAgICAgICAgICAgbGVmdDogeFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZWN0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIERPTVJlY3RJbml0IG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGltZW5zaW9ucyBhbmQgdGhlIHgveSBjb29yZGluYXRlcy5cclxuICAgICAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkaWN0ZGVmLWRvbXJlY3Rpbml0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFkgY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFJlY3RhbmdsZSdzIHdpZHRoLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFJlY3RhbmdsZSdzIGhlaWdodC5cclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVjdEluaXQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxuICAgIH1cblxuICAgIC8qKlxyXG4gICAgICogQ2xhc3MgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgY29tcHV0YXRpb25zIG9mIHRoZSBjb250ZW50IHJlY3RhbmdsZSBvZlxyXG4gICAgICogcHJvdmlkZWQgRE9NIGVsZW1lbnQgYW5kIGZvciBrZWVwaW5nIHRyYWNrIG9mIGl0J3MgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgdmFyIFJlc2l6ZU9ic2VydmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2YXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCcm9hZGNhc3RlZCB3aWR0aCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnJvYWRjYXN0ZWQgaGVpZ2h0IG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RIZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZSB7RE9NUmVjdEluaXR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBjb250ZW50IHJlY3RhbmdsZSBhbmQgdGVsbHMgd2hldGhlciBpdCdzIHdpZHRoIG9yIGhlaWdodCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICogaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGJyb2FkY2FzdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBnZXRDb250ZW50UmVjdCh0aGlzLnRhcmdldCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gcmVjdDtcclxuICAgICAgICAgICAgcmV0dXJuIChyZWN0LndpZHRoICE9PSB0aGlzLmJyb2FkY2FzdFdpZHRoIHx8XHJcbiAgICAgICAgICAgICAgICByZWN0LmhlaWdodCAhPT0gdGhpcy5icm9hZGNhc3RIZWlnaHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyAnYnJvYWRjYXN0V2lkdGgnIGFuZCAnYnJvYWRjYXN0SGVpZ2h0JyBwcm9wZXJ0aWVzIHdpdGggYSBkYXRhXHJcbiAgICAgICAgICogZnJvbSB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIG9mIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fSBMYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmF0aW9uLnByb3RvdHlwZS5icm9hZGNhc3RSZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY29udGVudFJlY3RfO1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUmVzaXplT2JzZXJ2YXRpb247XHJcbiAgICB9KCkpO1xuXG4gICAgdmFyIFJlc2l6ZU9ic2VydmVyRW50cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckVudHJ5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRoYXQgaXMgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBEYXRhIG9mIHRoZSBlbGVtZW50J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJFbnRyeSh0YXJnZXQsIHJlY3RJbml0KSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50UmVjdCA9IGNyZWF0ZVJlYWRPbmx5UmVjdChyZWN0SW5pdCk7XHJcbiAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlXHJcbiAgICAgICAgICAgIC8vIGFuZCBhcmUgYWxzbyBub3QgZW51bWVyYWJsZSBpbiB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIG5vdCBiZWluZyB1c2VkIGFzIHRoZXknZCByZXF1aXJlIHRvIGRlZmluZSBhXHJcbiAgICAgICAgICAgIC8vIHByaXZhdGUgV2Vha01hcCBzdG9yYWdlIHdoaWNoIG1heSBjYXVzZSBtZW1vcnkgbGVha3MgaW4gYnJvd3NlcnMgdGhhdFxyXG4gICAgICAgICAgICAvLyBkb24ndCBzdXBwb3J0IHRoaXMgdHlwZSBvZiBjb2xsZWN0aW9ucy5cclxuICAgICAgICAgICAgZGVmaW5lQ29uZmlndXJhYmxlKHRoaXMsIHsgdGFyZ2V0OiB0YXJnZXQsIGNvbnRlbnRSZWN0OiBjb250ZW50UmVjdCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRW50cnk7XHJcbiAgICB9KCkpO1xuXG4gICAgdmFyIFJlc2l6ZU9ic2VydmVyU1BJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkXHJcbiAgICAgICAgICogICAgICB3aGVuIG9uZSBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlcyBpdCdzIGNvbnRlbnQgZGltZW5zaW9ucy5cclxuICAgICAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn0gY29udHJvbGxlciAtIENvbnRyb2xsZXIgaW5zdGFuY2Ugd2hpY2hcclxuICAgICAgICAgKiAgICAgIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgdXBkYXRlcyBvZiBvYnNlcnZlci5cclxuICAgICAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyfSBjYWxsYmFja0N0eCAtIFJlZmVyZW5jZSB0byB0aGUgcHVibGljXHJcbiAgICAgICAgICogICAgICBSZXNpemVPYnNlcnZlciBpbnN0YW5jZSB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgY2FsbGJhY2tDdHgpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbGxlY3Rpb24gb2YgcmVzaXplIG9ic2VydmF0aW9ucyB0aGF0IGhhdmUgZGV0ZWN0ZWQgY2hhbmdlcyBpbiBkaW1lbnNpb25zXHJcbiAgICAgICAgICAgICAqIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RyeSBvZiB0aGUgUmVzaXplT2JzZXJ2YXRpb24gaW5zdGFuY2VzLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZSB7TWFwPEVsZW1lbnQsIFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXyA9IG5ldyBNYXBTaGltKCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJfID0gY29udHJvbGxlcjtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFja0N0eF8gPSBjYWxsYmFja0N0eDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RhcnRzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHRoZSBFbGVtZW50IGludGVyZmFjZS5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICAgIGlmIChvYnNlcnZhdGlvbnMuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYnNlcnZhdGlvbnMuc2V0KHRhcmdldCwgbmV3IFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLmFkZE9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgICAgICAvLyBGb3JjZSB0aGUgdXBkYXRlIG9mIG9ic2VydmF0aW9ucy5cclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdG9wcyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBzdG9wIG9ic2VydmluZy5cclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHRoZSBFbGVtZW50IGludGVyZmFjZS5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIG5vdCBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgICAgaWYgKCFvYnNlcnZhdGlvbnMuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYnNlcnZhdGlvbnMuZGVsZXRlKHRhcmdldCk7XHJcbiAgICAgICAgICAgIGlmICghb2JzZXJ2YXRpb25zLnNpemUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3BzIG9ic2VydmluZyBhbGwgZWxlbWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uY2xlYXIoKTtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3RzIG9ic2VydmF0aW9uIGluc3RhbmNlcyB0aGUgYXNzb2NpYXRlZCBlbGVtZW50IG9mIHdoaWNoIGhhcyBjaGFuZ2VkXHJcbiAgICAgICAgICogaXQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5nYXRoZXJBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2YXRpb24uaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ucHVzaChvYnNlcnZhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW52b2tlcyBpbml0aWFsIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSBsaXN0IG9mIFJlc2l6ZU9ic2VydmVyRW50cnlcclxuICAgICAgICAgKiBpbnN0YW5jZXMgY29sbGVjdGVkIGZyb20gYWN0aXZlIHJlc2l6ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuYnJvYWRjYXN0QWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG9ic2VydmVyIGRvZXNuJ3QgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYWxsYmFja0N0eF87XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBSZXNpemVPYnNlcnZlckVudHJ5IGluc3RhbmNlIGZvciBldmVyeSBhY3RpdmUgb2JzZXJ2YXRpb24uXHJcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLm1hcChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXJFbnRyeShvYnNlcnZhdGlvbi50YXJnZXQsIG9ic2VydmF0aW9uLmJyb2FkY2FzdFJlY3QoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrXy5jYWxsKGN0eCwgZW50cmllcywgY3R4KTtcclxuICAgICAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIHRoZSBjb2xsZWN0aW9uIG9mIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuY2xlYXJBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5zcGxpY2UoMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZWxscyB3aGV0aGVyIG9ic2VydmVyIGhhcyBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmhhc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5sZW5ndGggPiAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU1BJO1xyXG4gICAgfSgpKTtcblxuICAgIC8vIFJlZ2lzdHJ5IG9mIGludGVybmFsIG9ic2VydmVycy4gSWYgV2Vha01hcCBpcyBub3QgYXZhaWxhYmxlIHVzZSBjdXJyZW50IHNoaW1cclxuICAgIC8vIGZvciB0aGUgTWFwIGNvbGxlY3Rpb24gYXMgaXQgaGFzIGFsbCByZXF1aXJlZCBtZXRob2RzIGFuZCBiZWNhdXNlIFdlYWtNYXBcclxuICAgIC8vIGNhbid0IGJlIGZ1bGx5IHBvbHlmaWxsZWQgYW55d2F5LlxyXG4gICAgdmFyIG9ic2VydmVycyA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyA/IG5ldyBXZWFrTWFwKCkgOiBuZXcgTWFwU2hpbSgpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVPYnNlcnZlciBBUEkuIEVuY2Fwc3VsYXRlcyB0aGUgUmVzaXplT2JzZXJ2ZXIgU1BJIGltcGxlbWVudGF0aW9uXHJcbiAgICAgKiBleHBvc2luZyBvbmx5IHRob3NlIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGUgc3BlYy5cclxuICAgICAqL1xyXG4gICAgdmFyIFJlc2l6ZU9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdoZW5cclxuICAgICAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlcihjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzaXplT2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCB0aGlzKTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNldCh0aGlzLCBvYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxuICAgIH0oKSk7XHJcbiAgICAvLyBFeHBvc2UgcHVibGljIG1ldGhvZHMgb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICBbXHJcbiAgICAgICAgJ29ic2VydmUnLFxyXG4gICAgICAgICd1bm9ic2VydmUnLFxyXG4gICAgICAgICdkaXNjb25uZWN0J1xyXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgICAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4gKF9hID0gb2JzZXJ2ZXJzLmdldCh0aGlzKSlbbWV0aG9kXS5hcHBseShfYSwgYXJndW1lbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XG5cbiAgICB2YXIgaW5kZXggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIEV4cG9ydCBleGlzdGluZyBpbXBsZW1lbnRhdGlvbiBpZiBhdmFpbGFibGUuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XHJcbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuIGluZGV4O1xuXG59KSkpO1xuIiwiLyohIHJ1bi1wYXJhbGxlbC4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xubW9kdWxlLmV4cG9ydHMgPSBydW5QYXJhbGxlbFxuXG5jb25zdCBxdWV1ZU1pY3JvdGFzayA9IHJlcXVpcmUoJ3F1ZXVlLW1pY3JvdGFzaycpXG5cbmZ1bmN0aW9uIHJ1blBhcmFsbGVsICh0YXNrcywgY2IpIHtcbiAgbGV0IHJlc3VsdHMsIHBlbmRpbmcsIGtleXNcbiAgbGV0IGlzU3luYyA9IHRydWVcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXNrcykpIHtcbiAgICByZXN1bHRzID0gW11cbiAgICBwZW5kaW5nID0gdGFza3MubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHRhc2tzKVxuICAgIHJlc3VsdHMgPSB7fVxuICAgIHBlbmRpbmcgPSBrZXlzLmxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gICAgZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIGlmIChjYikgY2IoZXJyLCByZXN1bHRzKVxuICAgICAgY2IgPSBudWxsXG4gICAgfVxuICAgIGlmIChpc1N5bmMpIHF1ZXVlTWljcm90YXNrKGVuZClcbiAgICBlbHNlIGVuZCgpXG4gIH1cblxuICBmdW5jdGlvbiBlYWNoIChpLCBlcnIsIHJlc3VsdCkge1xuICAgIHJlc3VsdHNbaV0gPSByZXN1bHRcbiAgICBpZiAoLS1wZW5kaW5nID09PSAwIHx8IGVycikge1xuICAgICAgZG9uZShlcnIpXG4gICAgfVxuICB9XG5cbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgLy8gZW1wdHlcbiAgICBkb25lKG51bGwpXG4gIH0gZWxzZSBpZiAoa2V5cykge1xuICAgIC8vIG9iamVjdFxuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB0YXNrc1trZXldKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkgeyBlYWNoKGtleSwgZXJyLCByZXN1bHQpIH0pXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBhcnJheVxuICAgIHRhc2tzLmZvckVhY2goZnVuY3Rpb24gKHRhc2ssIGkpIHtcbiAgICAgIHRhc2soZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7IGVhY2goaSwgZXJyLCByZXN1bHQpIH0pXG4gICAgfSlcbiAgfVxuXG4gIGlzU3luYyA9IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfaXNSZWFjdE5hdGl2ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNSZWFjdE5hdGl2ZVwiKSk7XG5cbnZhciBfdXJpVG9CbG9iID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91cmlUb0Jsb2JcIikpO1xuXG52YXIgX2lzQ29yZG92YSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNDb3Jkb3ZhXCIpKTtcblxudmFyIF9yZWFkQXNCeXRlQXJyYXkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JlYWRBc0J5dGVBcnJheVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxudmFyIEZpbGVTb3VyY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBNYWtlIHRoaXMuc2l6ZSBhIG1ldGhvZFxuICBmdW5jdGlvbiBGaWxlU291cmNlKGZpbGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsZVNvdXJjZSk7XG5cbiAgICB0aGlzLl9maWxlID0gZmlsZTtcbiAgICB0aGlzLnNpemUgPSBmaWxlLnNpemU7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRmlsZVNvdXJjZSwgW3tcbiAgICBrZXk6IFwic2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgLy8gSW4gQXBhY2hlIENvcmRvdmEgYXBwbGljYXRpb25zLCBhIEZpbGUgbXVzdCBiZSByZXNvbHZlZCB1c2luZ1xuICAgICAgLy8gRmlsZVJlYWRlciBpbnN0YW5jZXMsIHNlZVxuICAgICAgLy8gaHR0cHM6Ly9jb3Jkb3ZhLmFwYWNoZS5vcmcvZG9jcy9lbi84LngvcmVmZXJlbmNlL2NvcmRvdmEtcGx1Z2luLWZpbGUvaW5kZXguaHRtbCNyZWFkLWEtZmlsZVxuICAgICAgaWYgKCgwLCBfaXNDb3Jkb3ZhLmRlZmF1bHQpKCkpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfcmVhZEFzQnl0ZUFycmF5LmRlZmF1bHQpKHRoaXMuX2ZpbGUuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9maWxlLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7Ly8gTm90aGluZyB0byBkbyBoZXJlIHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gcmVsZWFzZSBhbnkgcmVzb3VyY2VzLlxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGaWxlU291cmNlO1xufSgpO1xuXG52YXIgU3RyZWFtU291cmNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyZWFtU291cmNlKHJlYWRlciwgY2h1bmtTaXplKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmVhbVNvdXJjZSk7XG5cbiAgICB0aGlzLl9jaHVua1NpemUgPSBjaHVua1NpemU7XG4gICAgdGhpcy5fYnVmZmVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2J1ZmZlck9mZnNldCA9IDA7XG4gICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdHJlYW1Tb3VyY2UsIFt7XG4gICAga2V5OiBcInNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmIChzdGFydCA8IHRoaXMuX2J1ZmZlck9mZnNldCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdGVkIGRhdGEgaXMgYmVmb3JlIHRoZSByZWFkZXIncyBjdXJyZW50IG9mZnNldFwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVhZFVudGlsRW5vdWdoRGF0YU9yRG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVhZFVudGlsRW5vdWdoRGF0YU9yRG9uZShzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgaGFzRW5vdWdoRGF0YSA9IGVuZCA8PSB0aGlzLl9idWZmZXJPZmZzZXQgKyBsZW4odGhpcy5fYnVmZmVyKTtcblxuICAgICAgaWYgKHRoaXMuX2RvbmUgfHwgaGFzRW5vdWdoRGF0YSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXREYXRhRnJvbUJ1ZmZlcihzdGFydCwgZW5kKTtcblxuICAgICAgICB2YXIgZG9uZSA9IHZhbHVlID09IG51bGwgPyB0aGlzLl9kb25lIDogZmFsc2U7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBkb25lOiBkb25lXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICAgICAgICBkb25lID0gX3JlZi5kb25lO1xuXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgX3RoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGlzLl9idWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzLl9idWZmZXIgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5fYnVmZmVyID0gY29uY2F0KF90aGlzLl9idWZmZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpcy5fcmVhZFVudGlsRW5vdWdoRGF0YU9yRG9uZShzdGFydCwgZW5kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGF0YUZyb21CdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERhdGFGcm9tQnVmZmVyKHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8vIFJlbW92ZSBkYXRhIGZyb20gYnVmZmVyIGJlZm9yZSBgc3RhcnRgLlxuICAgICAgLy8gRGF0YSBtaWdodCBiZSByZXJlYWQgZnJvbSB0aGUgYnVmZmVyIGlmIGFuIHVwbG9hZCBmYWlscywgc28gd2UgY2FuIG9ubHlcbiAgICAgIC8vIHNhZmVseSBkZWxldGUgZGF0YSB3aGVuIGl0IGNvbWVzICpiZWZvcmUqIHdoYXQgaXMgY3VycmVudGx5IGJlaW5nIHJlYWQuXG4gICAgICBpZiAoc3RhcnQgPiB0aGlzLl9idWZmZXJPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gdGhpcy5fYnVmZmVyLnNsaWNlKHN0YXJ0IC0gdGhpcy5fYnVmZmVyT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyT2Zmc2V0ID0gc3RhcnQ7XG4gICAgICB9IC8vIElmIHRoZSBidWZmZXIgaXMgZW1wdHkgYWZ0ZXIgcmVtb3Zpbmcgb2xkIGRhdGEsIGFsbCBkYXRhIGhhcyBiZWVuIHJlYWQuXG5cblxuICAgICAgdmFyIGhhc0FsbERhdGFCZWVuUmVhZCA9IGxlbih0aGlzLl9idWZmZXIpID09PSAwO1xuXG4gICAgICBpZiAodGhpcy5fZG9uZSAmJiBoYXNBbGxEYXRhQmVlblJlYWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIFdlIGFscmVhZHkgcmVtb3ZlZCBkYXRhIGJlZm9yZSBgc3RhcnRgLCBzbyB3ZSBqdXN0IHJldHVybiB0aGUgZmlyc3RcbiAgICAgIC8vIGNodW5rIGZyb20gdGhlIGJ1ZmZlci5cblxuXG4gICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLnNsaWNlKDAsIGVuZCAtIHN0YXJ0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAodGhpcy5fcmVhZGVyLmNhbmNlbCkge1xuICAgICAgICB0aGlzLl9yZWFkZXIuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0cmVhbVNvdXJjZTtcbn0oKTtcblxuZnVuY3Rpb24gbGVuKGJsb2JPckFycmF5KSB7XG4gIGlmIChibG9iT3JBcnJheSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgaWYgKGJsb2JPckFycmF5LnNpemUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGJsb2JPckFycmF5LnNpemU7XG4gIHJldHVybiBibG9iT3JBcnJheS5sZW5ndGg7XG59XG4vKlxuICBUeXBlZCBhcnJheXMgYW5kIGJsb2JzIGRvbid0IGhhdmUgYSBjb25jYXQgbWV0aG9kLlxuICBUaGlzIGZ1bmN0aW9uIGhlbHBzIFN0cmVhbVNvdXJjZSBhY2N1bXVsYXRlIGRhdGEgdG8gcmVhY2ggY2h1bmtTaXplLlxuKi9cblxuXG5mdW5jdGlvbiBjb25jYXQoYSwgYikge1xuICBpZiAoYS5jb25jYXQpIHtcbiAgICAvLyBJcyBgYWAgYW4gQXJyYXk/XG4gICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICB9XG5cbiAgaWYgKGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iKFthLCBiXSwge1xuICAgICAgdHlwZTogYS50eXBlXG4gICAgfSk7XG4gIH1cblxuICBpZiAoYS5zZXQpIHtcbiAgICAvLyBJcyBgYWAgYSB0eXBlZCBhcnJheT9cbiAgICB2YXIgYyA9IG5ldyBhLmNvbnN0cnVjdG9yKGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICAgIGMuc2V0KGEpO1xuICAgIGMuc2V0KGIsIGEubGVuZ3RoKTtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlXCIpO1xufVxuXG52YXIgRmlsZVJlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZpbGVSZWFkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZpbGVSZWFkZXIsIFt7XG4gICAga2V5OiBcIm9wZW5GaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5GaWxlKGlucHV0LCBjaHVua1NpemUpIHtcbiAgICAgIC8vIEluIFJlYWN0IE5hdGl2ZSwgd2hlbiB1c2VyIHNlbGVjdHMgYSBmaWxlLCBpbnN0ZWFkIG9mIGEgRmlsZSBvciBCbG9iLFxuICAgICAgLy8geW91IHVzdWFsbHkgZ2V0IGEgZmlsZSBvYmplY3Qge30gd2l0aCBhIHVyaSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zXG4gICAgICAvLyBhIGxvY2FsIHBhdGggdG8gdGhlIGZpbGUuIFdlIHVzZSBYTUxIdHRwUmVxdWVzdCB0byBmZXRjaFxuICAgICAgLy8gdGhlIGZpbGUgYmxvYiwgYmVmb3JlIHVwbG9hZGluZyB3aXRoIHR1cy5cbiAgICAgIGlmICgoMCwgX2lzUmVhY3ROYXRpdmUuZGVmYXVsdCkoKSAmJiBpbnB1dCAmJiB0eXBlb2YgaW5wdXQudXJpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiAoMCwgX3VyaVRvQmxvYi5kZWZhdWx0KShpbnB1dC51cmkpLnRoZW4oZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEZpbGVTb3VyY2UoYmxvYik7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInR1czogY2Fubm90IGZldGNoIGBmaWxlLnVyaWAgYXMgQmxvYiwgbWFrZSBzdXJlIHRoZSB1cmkgaXMgY29ycmVjdCBhbmQgYWNjZXNzaWJsZS4gXCIgKyBlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gU2luY2Ugd2UgZW11bGF0ZSB0aGUgQmxvYiB0eXBlIGluIG91ciB0ZXN0cyAobm90IGFsbCB0YXJnZXQgYnJvd3NlcnNcbiAgICAgIC8vIHN1cHBvcnQgaXQpLCB3ZSBjYW5ub3QgdXNlIGBpbnN0YW5jZW9mYCBmb3IgdGVzdGluZyB3aGV0aGVyIHRoZSBpbnB1dCB2YWx1ZVxuICAgICAgLy8gY2FuIGJlIGhhbmRsZWQuIEluc3RlYWQsIHdlIHNpbXBseSBjaGVjayBpcyB0aGUgc2xpY2UoKSBmdW5jdGlvbiBhbmQgdGhlXG4gICAgICAvLyBzaXplIHByb3BlcnR5IGFyZSBhdmFpbGFibGUuXG5cblxuICAgICAgaWYgKHR5cGVvZiBpbnB1dC5zbGljZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBpbnB1dC5zaXplICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEZpbGVTb3VyY2UoaW5wdXQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnB1dC5yZWFkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2h1bmtTaXplID0gK2NodW5rU2l6ZTtcblxuICAgICAgICBpZiAoIWlzRmluaXRlKGNodW5rU2l6ZSkpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiY2Fubm90IGNyZWF0ZSBzb3VyY2UgZm9yIHN0cmVhbSB3aXRob3V0IGEgZmluaXRlIHZhbHVlIGZvciB0aGUgYGNodW5rU2l6ZWAgb3B0aW9uXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IFN0cmVhbVNvdXJjZShpbnB1dCwgY2h1bmtTaXplKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJzb3VyY2Ugb2JqZWN0IG1heSBvbmx5IGJlIGFuIGluc3RhbmNlIG9mIEZpbGUsIEJsb2IsIG9yIFJlYWRlciBpbiB0aGlzIGVudmlyb25tZW50XCIpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsZVJlYWRlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRmlsZVJlYWRlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZpbmdlcnByaW50O1xuXG52YXIgX2lzUmVhY3ROYXRpdmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzUmVhY3ROYXRpdmVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBUT0RPOiBEaWZmZXJlbmNpYXRlIGJldHdlZW4gaW5wdXQgdHlwZXNcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGZpbmdlcnByaW50IGZvciBhIGZpbGUgd2hpY2ggd2lsbCBiZSB1c2VkIHRoZSBzdG9yZSB0aGUgZW5kcG9pbnRcbiAqXG4gKiBAcGFyYW0ge0ZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBmaW5nZXJwcmludChmaWxlLCBvcHRpb25zKSB7XG4gIGlmICgoMCwgX2lzUmVhY3ROYXRpdmUuZGVmYXVsdCkoKSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhY3ROYXRpdmVGaW5nZXJwcmludChmaWxlLCBvcHRpb25zKSk7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtcInR1cy1iclwiLCBmaWxlLm5hbWUsIGZpbGUudHlwZSwgZmlsZS5zaXplLCBmaWxlLmxhc3RNb2RpZmllZCwgb3B0aW9ucy5lbmRwb2ludF0uam9pbihcIi1cIikpO1xufVxuXG5mdW5jdGlvbiByZWFjdE5hdGl2ZUZpbmdlcnByaW50KGZpbGUsIG9wdGlvbnMpIHtcbiAgdmFyIGV4aWZIYXNoID0gZmlsZS5leGlmID8gaGFzaENvZGUoSlNPTi5zdHJpbmdpZnkoZmlsZS5leGlmKSkgOiBcIm5vZXhpZlwiO1xuICByZXR1cm4gW1widHVzLXJuXCIsIGZpbGUubmFtZSB8fCBcIm5vbmFtZVwiLCBmaWxlLnNpemUgfHwgXCJub3NpemVcIiwgZXhpZkhhc2gsIG9wdGlvbnMuZW5kcG9pbnRdLmpvaW4oXCIvXCIpO1xufVxuXG5mdW5jdGlvbiBoYXNoQ29kZShzdHIpIHtcbiAgLy8gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODgzMTkzNy8xNTE2NjZcbiAgdmFyIGhhc2ggPSAwO1xuXG4gIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfY2hhciA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIF9jaGFyO1xuICAgIGhhc2ggPSBoYXNoICYgaGFzaDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gaGFzaDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5cbnZhciBYSFJIdHRwU3RhY2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYSFJIdHRwU3RhY2soKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFhIUkh0dHBTdGFjayk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWEhSSHR0cFN0YWNrLCBbe1xuICAgIGtleTogXCJjcmVhdGVSZXF1ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgICAgIHJldHVybiBuZXcgUmVxdWVzdChtZXRob2QsIHVybCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmFtZSgpIHtcbiAgICAgIHJldHVybiBcIlhIUkh0dHBTdGFja1wiO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBYSFJIdHRwU3RhY2s7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFhIUkh0dHBTdGFjaztcblxudmFyIFJlcXVlc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlcXVlc3QpO1xuXG4gICAgdGhpcy5feGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICB0aGlzLl94aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG5cbiAgICB0aGlzLl9tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy5fdXJsID0gdXJsO1xuICAgIHRoaXMuX2hlYWRlcnMgPSB7fTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXF1ZXN0LCBbe1xuICAgIGtleTogXCJnZXRNZXRob2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWV0aG9kKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VVJMXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl91cmw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIZWFkZXIoaGVhZGVyLCB2YWx1ZSkge1xuICAgICAgdGhpcy5feGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCB2YWx1ZSk7XG5cbiAgICAgIHRoaXMuX2hlYWRlcnNbaGVhZGVyXSA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZGVyKGhlYWRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNbaGVhZGVyXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UHJvZ3Jlc3NIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFByb2dyZXNzSGFuZGxlcihwcm9ncmVzc0hhbmRsZXIpIHtcbiAgICAgIC8vIFRlc3Qgc3VwcG9ydCBmb3IgcHJvZ3Jlc3MgZXZlbnRzIGJlZm9yZSBhdHRhY2hpbmcgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgIGlmICghKFwidXBsb2FkXCIgaW4gdGhpcy5feGhyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3hoci51cGxvYWQub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZS5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvZ3Jlc3NIYW5kbGVyKGUubG9hZGVkKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBib2R5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXMuX3hoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoX3RoaXMuX3hocikpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLl94aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5feGhyLnNlbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWJvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICB0aGlzLl94aHIuYWJvcnQoKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVbmRlcmx5aW5nT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVuZGVybHlpbmdPYmplY3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXF1ZXN0O1xufSgpO1xuXG52YXIgUmVzcG9uc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXNwb25zZSh4aHIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2UpO1xuXG4gICAgdGhpcy5feGhyID0geGhyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlc3BvbnNlLCBbe1xuICAgIGtleTogXCJnZXRTdGF0dXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hoci5zdGF0dXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXIoaGVhZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyLmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHIucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVbmRlcmx5aW5nT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVuZGVybHlpbmdPYmplY3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXNwb25zZTtcbn0oKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuYWJsZURlYnVnTG9nXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9sb2dnZXIuZW5hYmxlRGVidWdMb2c7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2FuU3RvcmVVUkxzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91cmxTdG9yYWdlLmNhblN0b3JlVVJMcztcbiAgfVxufSk7XG5leHBvcnRzLmlzU3VwcG9ydGVkID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuVXBsb2FkID0gdm9pZCAwO1xuXG52YXIgX3VwbG9hZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3VwbG9hZFwiKSk7XG5cbnZhciBfbm9vcFVybFN0b3JhZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ub29wVXJsU3RvcmFnZVwiKSk7XG5cbnZhciBfbG9nZ2VyID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcblxudmFyIF91cmxTdG9yYWdlID0gcmVxdWlyZShcIi4vdXJsU3RvcmFnZVwiKTtcblxudmFyIF9odHRwU3RhY2sgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2h0dHBTdGFja1wiKSk7XG5cbnZhciBfZmlsZVJlYWRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZmlsZVJlYWRlclwiKSk7XG5cbnZhciBfZmluZ2VycHJpbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ZpbmdlcnByaW50XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIF91cGxvYWQuZGVmYXVsdC5kZWZhdWx0T3B0aW9ucywge1xuICBodHRwU3RhY2s6IG5ldyBfaHR0cFN0YWNrLmRlZmF1bHQoKSxcbiAgZmlsZVJlYWRlcjogbmV3IF9maWxlUmVhZGVyLmRlZmF1bHQoKSxcbiAgdXJsU3RvcmFnZTogX3VybFN0b3JhZ2UuY2FuU3RvcmVVUkxzID8gbmV3IF91cmxTdG9yYWdlLldlYlN0b3JhZ2VVcmxTdG9yYWdlKCkgOiBuZXcgX25vb3BVcmxTdG9yYWdlLmRlZmF1bHQoKSxcbiAgZmluZ2VycHJpbnQ6IF9maW5nZXJwcmludC5kZWZhdWx0XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuXG52YXIgVXBsb2FkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVVwbG9hZCkge1xuICBfaW5oZXJpdHMoVXBsb2FkLCBfQmFzZVVwbG9hZCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihVcGxvYWQpO1xuXG4gIGZ1bmN0aW9uIFVwbG9hZCgpIHtcbiAgICB2YXIgZmlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXBsb2FkKTtcblxuICAgIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucywge30sIG9wdGlvbnMpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBmaWxlLCBvcHRpb25zKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhVcGxvYWQsIG51bGwsIFt7XG4gICAga2V5OiBcInRlcm1pbmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXJtaW5hdGUodXJsLCBvcHRpb25zLCBjYikge1xuICAgICAgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLCB7fSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gX3VwbG9hZC5kZWZhdWx0LnRlcm1pbmF0ZSh1cmwsIG9wdGlvbnMsIGNiKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVXBsb2FkO1xufShfdXBsb2FkLmRlZmF1bHQpO1xuXG5leHBvcnRzLlVwbG9hZCA9IFVwbG9hZDtcbnZhciBfd2luZG93ID0gd2luZG93LFxuICAgIFhNTEh0dHBSZXF1ZXN0ID0gX3dpbmRvdy5YTUxIdHRwUmVxdWVzdCxcbiAgICBCbG9iID0gX3dpbmRvdy5CbG9iO1xudmFyIGlzU3VwcG9ydGVkID0gWE1MSHR0cFJlcXVlc3QgJiYgQmxvYiAmJiB0eXBlb2YgQmxvYi5wcm90b3R5cGUuc2xpY2UgPT09IFwiZnVuY3Rpb25cIjtcbmV4cG9ydHMuaXNTdXBwb3J0ZWQgPSBpc1N1cHBvcnRlZDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIGlzQ29yZG92YSA9IGZ1bmN0aW9uIGlzQ29yZG92YSgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIiAmJiAodHlwZW9mIHdpbmRvdy5QaG9uZUdhcCAhPSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB3aW5kb3cuQ29yZG92YSAhPSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB3aW5kb3cuY29yZG92YSAhPSBcInVuZGVmaW5lZFwiKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IGlzQ29yZG92YTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgaXNSZWFjdE5hdGl2ZSA9IGZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJzdHJpbmdcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdC50b0xvd2VyQ2FzZSgpID09PSBcInJlYWN0bmF0aXZlXCI7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBpc1JlYWN0TmF0aXZlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZWFkQXNCeXRlQXJyYXk7XG5cbi8qKlxuICogcmVhZEFzQnl0ZUFycmF5IGNvbnZlcnRzIGEgRmlsZSBvYmplY3QgdG8gYSBVaW50OEFycmF5LlxuICogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgb24gdGhlIEFwYWNoZSBDb3Jkb3ZhIHBsYXRmb3JtLlxuICogU2VlIGh0dHBzOi8vY29yZG92YS5hcGFjaGUub3JnL2RvY3MvZW4vbGF0ZXN0L3JlZmVyZW5jZS9jb3Jkb3ZhLXBsdWdpbi1maWxlL2luZGV4Lmh0bWwjcmVhZC1hLWZpbGVcbiAqL1xuZnVuY3Rpb24gcmVhZEFzQnl0ZUFycmF5KGNodW5rKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkocmVhZGVyLnJlc3VsdCk7XG4gICAgICByZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9O1xuXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGNodW5rKTtcbiAgfSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB1cmlUb0Jsb2I7XG5cbi8qKlxuICogdXJpVG9CbG9iIHJlc29sdmVzIGEgVVJJIHRvIGEgQmxvYiBvYmplY3QuIFRoaXMgaXMgdXNlZCBmb3JcbiAqIFJlYWN0IE5hdGl2ZSB0byByZXRyaWV2ZSBhIGZpbGUgKGlkZW50aWZpZWQgYnkgYSBmaWxlOi8vXG4gKiBVUkkpIGFzIGEgYmxvYi5cbiAqL1xuZnVuY3Rpb24gdXJpVG9CbG9iKHVyaSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJibG9iXCI7XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJsb2IgPSB4aHIucmVzcG9uc2U7XG4gICAgICByZXNvbHZlKGJsb2IpO1xuICAgIH07XG5cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH07XG5cbiAgICB4aHIub3BlbihcIkdFVFwiLCB1cmkpO1xuICAgIHhoci5zZW5kKCk7XG4gIH0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5XZWJTdG9yYWdlVXJsU3RvcmFnZSA9IGV4cG9ydHMuY2FuU3RvcmVVUkxzID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG4vKiBnbG9iYWwgd2luZG93LCBsb2NhbFN0b3JhZ2UgKi9cblxuXG52YXIgaGFzU3RvcmFnZSA9IGZhbHNlO1xuXG50cnkge1xuICBoYXNTdG9yYWdlID0gXCJsb2NhbFN0b3JhZ2VcIiBpbiB3aW5kb3c7IC8vIEF0dGVtcHQgdG8gc3RvcmUgYW5kIHJlYWQgZW50cmllcyBmcm9tIHRoZSBsb2NhbCBzdG9yYWdlIHRvIGRldGVjdCBQcml2YXRlXG4gIC8vIE1vZGUgb24gU2FmYXJpIG9uIGlPUyAoc2VlICM0OSlcblxuICB2YXIga2V5ID0gXCJ0dXNTdXBwb3J0XCI7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSk7XG59IGNhdGNoIChlKSB7XG4gIC8vIElmIHdlIHRyeSB0byBhY2Nlc3MgbG9jYWxTdG9yYWdlIGluc2lkZSBhIHNhbmRib3hlZCBpZnJhbWUsIGEgU2VjdXJpdHlFcnJvclxuICAvLyBpcyB0aHJvd24uIFdoZW4gaW4gcHJpdmF0ZSBtb2RlIG9uIGlPUyBTYWZhcmksIGEgUXVvdGFFeGNlZWRlZEVycm9yIGlzXG4gIC8vIHRocm93biAoc2VlICM0OSlcbiAgaWYgKGUuY29kZSA9PT0gZS5TRUNVUklUWV9FUlIgfHwgZS5jb2RlID09PSBlLlFVT1RBX0VYQ0VFREVEX0VSUikge1xuICAgIGhhc1N0b3JhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbnZhciBjYW5TdG9yZVVSTHMgPSBoYXNTdG9yYWdlO1xuZXhwb3J0cy5jYW5TdG9yZVVSTHMgPSBjYW5TdG9yZVVSTHM7XG5cbnZhciBXZWJTdG9yYWdlVXJsU3RvcmFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdlYlN0b3JhZ2VVcmxTdG9yYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJTdG9yYWdlVXJsU3RvcmFnZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2ViU3RvcmFnZVVybFN0b3JhZ2UsIFt7XG4gICAga2V5OiBcImZpbmRBbGxVcGxvYWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRBbGxVcGxvYWRzKCkge1xuICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLl9maW5kRW50cmllcyhcInR1czo6XCIpO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KGZpbmdlcnByaW50KSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IHRoaXMuX2ZpbmRFbnRyaWVzKFwidHVzOjpcIi5jb25jYXQoZmluZ2VycHJpbnQsIFwiOjpcIikpO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlVXBsb2FkKHVybFN0b3JhZ2VLZXkpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHVybFN0b3JhZ2VLZXkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVXBsb2FkKGZpbmdlcnByaW50LCB1cGxvYWQpIHtcbiAgICAgIHZhciBpZCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTIpO1xuICAgICAgdmFyIGtleSA9IFwidHVzOjpcIi5jb25jYXQoZmluZ2VycHJpbnQsIFwiOjpcIikuY29uY2F0KGlkKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkodXBsb2FkKSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kRW50cmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEVudHJpZXMocHJlZml4KSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2tleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG5cbiAgICAgICAgaWYgKF9rZXkuaW5kZXhPZihwcmVmaXgpICE9PSAwKSBjb250aW51ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciB1cGxvYWQgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKF9rZXkpKTtcbiAgICAgICAgICB1cGxvYWQudXJsU3RvcmFnZUtleSA9IF9rZXk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHVwbG9hZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsvLyBUaGUgSlNPTiBwYXJzZSBlcnJvciBpcyBpbnRlbnRpb25hbGx5IGlnbm9yZWQgaGVyZSwgc28gYSBtYWxmb3JtZWRcbiAgICAgICAgICAvLyBlbnRyeSBpbiB0aGUgc3RvcmFnZSBjYW5ub3QgcHJldmVudCBhbiB1cGxvYWQuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdlYlN0b3JhZ2VVcmxTdG9yYWdlO1xufSgpO1xuXG5leHBvcnRzLldlYlN0b3JhZ2VVcmxTdG9yYWdlID0gV2ViU3RvcmFnZVVybFN0b3JhZ2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfTtcblxuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG52YXIgRGV0YWlsZWRFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhEZXRhaWxlZEVycm9yLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGV0YWlsZWRFcnJvcik7XG5cbiAgZnVuY3Rpb24gRGV0YWlsZWRFcnJvcihtZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIGNhdXNpbmdFcnIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgdmFyIHJlcSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERldGFpbGVkRXJyb3IpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBfdGhpcy5vcmlnaW5hbFJlcXVlc3QgPSByZXE7XG4gICAgX3RoaXMub3JpZ2luYWxSZXNwb25zZSA9IHJlcztcbiAgICBfdGhpcy5jYXVzaW5nRXJyb3IgPSBjYXVzaW5nRXJyO1xuXG4gICAgaWYgKGNhdXNpbmdFcnIgIT0gbnVsbCkge1xuICAgICAgbWVzc2FnZSArPSBcIiwgY2F1c2VkIGJ5IFwiLmNvbmNhdChjYXVzaW5nRXJyLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIGlmIChyZXEgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlcXVlc3RJZCA9IHJlcS5nZXRIZWFkZXIoXCJYLVJlcXVlc3QtSURcIikgfHwgXCJuL2FcIjtcbiAgICAgIHZhciBtZXRob2QgPSByZXEuZ2V0TWV0aG9kKCk7XG4gICAgICB2YXIgdXJsID0gcmVxLmdldFVSTCgpO1xuICAgICAgdmFyIHN0YXR1cyA9IHJlcyA/IHJlcy5nZXRTdGF0dXMoKSA6IFwibi9hXCI7XG4gICAgICB2YXIgYm9keSA9IHJlcyA/IHJlcy5nZXRCb2R5KCkgfHwgXCJcIiA6IFwibi9hXCI7XG4gICAgICBtZXNzYWdlICs9IFwiLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBcIi5jb25jYXQobWV0aG9kLCBcIiwgdXJsOiBcIikuY29uY2F0KHVybCwgXCIsIHJlc3BvbnNlIGNvZGU6IFwiKS5jb25jYXQoc3RhdHVzLCBcIiwgcmVzcG9uc2UgdGV4dDogXCIpLmNvbmNhdChib2R5LCBcIiwgcmVxdWVzdCBpZDogXCIpLmNvbmNhdChyZXF1ZXN0SWQsIFwiKVwiKTtcbiAgICB9XG5cbiAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gRGV0YWlsZWRFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbnZhciBfZGVmYXVsdCA9IERldGFpbGVkRXJyb3I7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZW5hYmxlRGVidWdMb2cgPSBlbmFibGVEZWJ1Z0xvZztcbmV4cG9ydHMubG9nID0gbG9nO1xuXG4vKiBlc2xpbnQgbm8tY29uc29sZTogXCJvZmZcIiAqL1xudmFyIGlzRW5hYmxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBlbmFibGVEZWJ1Z0xvZygpIHtcbiAgaXNFbmFibGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbG9nKG1zZykge1xuICBpZiAoIWlzRW5hYmxlZCkgcmV0dXJuO1xuICBjb25zb2xlLmxvZyhtc2cpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cblxuXG52YXIgTm9vcFVybFN0b3JhZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb29wVXJsU3RvcmFnZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9vcFVybFN0b3JhZ2UpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE5vb3BVcmxTdG9yYWdlLCBbe1xuICAgIGtleTogXCJsaXN0QWxsVXBsb2Fkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0QWxsVXBsb2FkcygpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KGZpbmdlcnByaW50KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVVwbG9hZCh1cmxTdG9yYWdlS2V5KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRVcGxvYWQoZmluZ2VycHJpbnQsIHVwbG9hZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9vcFVybFN0b3JhZ2U7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE5vb3BVcmxTdG9yYWdlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2Vycm9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9lcnJvclwiKSk7XG5cbnZhciBfdXVpZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXVpZFwiKSk7XG5cbnZhciBfanNCYXNlID0gcmVxdWlyZShcImpzLWJhc2U2NFwiKTtcblxudmFyIF91cmxQYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInVybC1wYXJzZVwiKSk7XG5cbnZhciBfbG9nZ2VyID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG4vKiBnbG9iYWwgd2luZG93ICovXG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBlbmRwb2ludDogbnVsbCxcbiAgdXBsb2FkVXJsOiBudWxsLFxuICBtZXRhZGF0YToge30sXG4gIGZpbmdlcnByaW50OiBudWxsLFxuICB1cGxvYWRTaXplOiBudWxsLFxuICBvblByb2dyZXNzOiBudWxsLFxuICBvbkNodW5rQ29tcGxldGU6IG51bGwsXG4gIG9uU3VjY2VzczogbnVsbCxcbiAgb25FcnJvcjogbnVsbCxcbiAgX29uVXBsb2FkVXJsQXZhaWxhYmxlOiBudWxsLFxuICBvdmVycmlkZVBhdGNoTWV0aG9kOiBmYWxzZSxcbiAgaGVhZGVyczoge30sXG4gIGFkZFJlcXVlc3RJZDogZmFsc2UsXG4gIG9uQmVmb3JlUmVxdWVzdDogbnVsbCxcbiAgb25BZnRlclJlc3BvbnNlOiBudWxsLFxuICBjaHVua1NpemU6IEluZmluaXR5LFxuICByZXRyeURlbGF5czogWzAsIDEwMDAsIDMwMDAsIDUwMDBdLFxuICBwYXJhbGxlbFVwbG9hZHM6IDEsXG4gIHN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZzogdHJ1ZSxcbiAgcmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3M6IGZhbHNlLFxuICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogZmFsc2UsXG4gIHVwbG9hZERhdGFEdXJpbmdDcmVhdGlvbjogZmFsc2UsXG4gIHVybFN0b3JhZ2U6IG51bGwsXG4gIGZpbGVSZWFkZXI6IG51bGwsXG4gIGh0dHBTdGFjazogbnVsbFxufTtcblxudmFyIEJhc2VVcGxvYWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlVXBsb2FkKGZpbGUsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZVVwbG9hZCk7IC8vIFdhcm4gYWJvdXQgcmVtb3ZlZCBvcHRpb25zIGZyb20gcHJldmlvdXMgdmVyc2lvbnNcblxuXG4gICAgaWYgKFwicmVzdW1lXCIgaW4gb3B0aW9ucykge1xuICAgICAgY29uc29sZS5sb2coXCJ0dXM6IFRoZSBgcmVzdW1lYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZCBpbiB0dXMtanMtY2xpZW50IHYyLiBQbGVhc2UgdXNlIHRoZSBVUkwgc3RvcmFnZSBBUEkgaW5zdGVhZC5cIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH0gLy8gVGhlIGRlZmF1bHQgb3B0aW9ucyB3aWxsIGFscmVhZHkgYmUgYWRkZWQgZnJvbSB0aGUgd3JhcHBlciBjbGFzc2VzLlxuXG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOyAvLyBUaGUgc3RvcmFnZSBtb2R1bGUgdXNlZCB0byBzdG9yZSBVUkxzXG5cbiAgICB0aGlzLl91cmxTdG9yYWdlID0gdGhpcy5vcHRpb25zLnVybFN0b3JhZ2U7IC8vIFRoZSB1bmRlcmx5aW5nIEZpbGUvQmxvYiBvYmplY3RcblxuICAgIHRoaXMuZmlsZSA9IGZpbGU7IC8vIFRoZSBVUkwgYWdhaW5zdCB3aGljaCB0aGUgZmlsZSB3aWxsIGJlIHVwbG9hZGVkXG5cbiAgICB0aGlzLnVybCA9IG51bGw7IC8vIFRoZSB1bmRlcmx5aW5nIHJlcXVlc3Qgb2JqZWN0IGZvciB0aGUgY3VycmVudCBQQVRDSCByZXF1ZXN0XG5cbiAgICB0aGlzLl9yZXEgPSBudWxsOyAvLyBUaGUgZmluZ2VycGlucnQgZm9yIHRoZSBjdXJyZW50IGZpbGUgKHNldCBhZnRlciBzdGFydCgpKVxuXG4gICAgdGhpcy5fZmluZ2VycHJpbnQgPSBudWxsOyAvLyBUaGUga2V5IHRoYXQgdGhlIFVSTCBzdG9yYWdlIHJldHVybmVkIHdoZW4gc2F2aW5nIGFuIFVSTCB3aXRoIGEgZmluZ2VycHJpbnQsXG5cbiAgICB0aGlzLl91cmxTdG9yYWdlS2V5ID0gbnVsbDsgLy8gVGhlIG9mZnNldCB1c2VkIGluIHRoZSBjdXJyZW50IFBBVENIIHJlcXVlc3RcblxuICAgIHRoaXMuX29mZnNldCA9IG51bGw7IC8vIFRydWUgaWYgdGhlIGN1cnJlbnQgUEFUQ0ggcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkXG5cbiAgICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7IC8vIFRoZSBmaWxlJ3Mgc2l6ZSBpbiBieXRlc1xuXG4gICAgdGhpcy5fc2l6ZSA9IG51bGw7IC8vIFRoZSBTb3VyY2Ugb2JqZWN0IHdoaWNoIHdpbGwgd3JhcCBhcm91bmQgdGhlIGdpdmVuIGZpbGUgYW5kIHByb3ZpZGVzIHVzXG4gICAgLy8gd2l0aCBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBnZXR0aW5nIGl0cyBzaXplIGFuZCBzbGljZSBjaHVua3MgZnJvbSBpdHNcbiAgICAvLyBjb250ZW50IGFsbG93aW5nIHVzIHRvIGVhc2lseSBoYW5kbGUgRmlsZXMsIEJsb2JzLCBCdWZmZXJzIGFuZCBTdHJlYW1zLlxuXG4gICAgdGhpcy5fc291cmNlID0gbnVsbDsgLy8gVGhlIGN1cnJlbnQgY291bnQgb2YgYXR0ZW1wdHMgd2hpY2ggaGF2ZSBiZWVuIG1hZGUuIFplcm8gaW5kaWNhdGVzIG5vbmUuXG5cbiAgICB0aGlzLl9yZXRyeUF0dGVtcHQgPSAwOyAvLyBUaGUgdGltZW91dCdzIElEIHdoaWNoIGlzIHVzZWQgdG8gZGVsYXkgdGhlIG5leHQgcmV0cnlcblxuICAgIHRoaXMuX3JldHJ5VGltZW91dCA9IG51bGw7IC8vIFRoZSBvZmZzZXQgb2YgdGhlIHJlbW90ZSB1cGxvYWQgYmVmb3JlIHRoZSBsYXRlc3QgYXR0ZW1wdCB3YXMgc3RhcnRlZC5cblxuICAgIHRoaXMuX29mZnNldEJlZm9yZVJldHJ5ID0gMDsgLy8gQW4gYXJyYXkgb2YgQmFzZVVwbG9hZCBpbnN0YW5jZXMgd2hpY2ggYXJlIHVzZWQgZm9yIHVwbG9hZGluZyB0aGUgZGlmZmVyZW50XG4gICAgLy8gcGFydHMsIGlmIHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIGlzIHVzZWQuXG5cbiAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZHMgPSBudWxsOyAvLyBBbiBhcnJheSBvZiB1cGxvYWQgVVJMcyB3aGljaCBhcmUgdXNlZCBmb3IgdXBsb2FkaW5nIHRoZSBkaWZmZXJlbnRcbiAgICAvLyBwYXJ0cywgaWYgdGhlIHBhcmFsbGVsVXBsb2FkcyBvcHRpb24gaXMgdXNlZC5cblxuICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFVzZSB0aGUgVGVybWluYXRpb24gZXh0ZW5zaW9uIHRvIGRlbGV0ZSBhbiB1cGxvYWQgZnJvbSB0aGUgc2VydmVyIGJ5IHNlbmRpbmcgYSBERUxFVEVcbiAgICogcmVxdWVzdCB0byB0aGUgc3BlY2lmaWVkIHVwbG9hZCBVUkwuIFRoaXMgaXMgb25seSBwb3NzaWJsZSBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIHRoZVxuICAgKiBUZXJtaW5hdGlvbiBleHRlbnNpb24uIElmIHRoZSBgb3B0aW9ucy5yZXRyeURlbGF5c2AgcHJvcGVydHkgaXMgc2V0LCB0aGUgbWV0aG9kIHdpbGxcbiAgICogYWxzbyByZXRyeSBpZiBhbiBlcnJvciBvY3VycnMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIHVwbG9hZCdzIFVSTCB3aGljaCB3aWxsIGJlIHRlcm1pbmF0ZWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgZm9yIGluZmx1ZW5jaW5nIEhUVFAgcmVxdWVzdHMuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSBQcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQvcmVqZWN0ZWQgd2hlbiB0aGUgcmVxdWVzdHMgZmluaXNoLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlVXBsb2FkLCBbe1xuICAgIGtleTogXCJmaW5kUHJldmlvdXNVcGxvYWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRQcmV2aW91c1VwbG9hZHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpbmdlcnByaW50KHRoaXMuZmlsZSwgdGhpcy5vcHRpb25zKS50aGVuKGZ1bmN0aW9uIChmaW5nZXJwcmludCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX3VybFN0b3JhZ2UuZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KGZpbmdlcnByaW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXN1bWVGcm9tUHJldmlvdXNVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdW1lRnJvbVByZXZpb3VzVXBsb2FkKHByZXZpb3VzVXBsb2FkKSB7XG4gICAgICB0aGlzLnVybCA9IHByZXZpb3VzVXBsb2FkLnVwbG9hZFVybCB8fCBudWxsO1xuICAgICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzID0gcHJldmlvdXNVcGxvYWQucGFyYWxsZWxVcGxvYWRVcmxzIHx8IG51bGw7XG4gICAgICB0aGlzLl91cmxTdG9yYWdlS2V5ID0gcHJldmlvdXNVcGxvYWQudXJsU3RvcmFnZUtleTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZpbGUgPSB0aGlzLmZpbGU7XG5cbiAgICAgIGlmICghZmlsZSkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiBubyBmaWxlIG9yIHN0cmVhbSB0byB1cGxvYWQgcHJvdmlkZWRcIikpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5kcG9pbnQgJiYgIXRoaXMub3B0aW9ucy51cGxvYWRVcmwpIHtcbiAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogbmVpdGhlciBhbiBlbmRwb2ludCBvciBhbiB1cGxvYWQgVVJMIGlzIHByb3ZpZGVkXCIpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXRyeURlbGF5cyA9IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5cztcblxuICAgICAgaWYgKHJldHJ5RGVsYXlzICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJldHJ5RGVsYXlzKSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IHRoZSBgcmV0cnlEZWxheXNgIG9wdGlvbiBtdXN0IGVpdGhlciBiZSBhbiBhcnJheSBvciBudWxsXCIpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyYWxsZWxVcGxvYWRzID4gMSkge1xuICAgICAgICAvLyBUZXN0IHdoaWNoIG9wdGlvbnMgYXJlIGluY29tcGF0aWJsZSB3aXRoIHBhcmFsbGVsIHVwbG9hZHMuXG4gICAgICAgIFtcInVwbG9hZFVybFwiLCBcInVwbG9hZFNpemVcIiwgXCJ1cGxvYWRMZW5ndGhEZWZlcnJlZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb25OYW1lKSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICBfdGhpczIuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCB1c2UgdGhlIFwiLmNvbmNhdChvcHRpb25OYW1lLCBcIiBvcHRpb24gd2hlbiBwYXJhbGxlbFVwbG9hZHMgaXMgZW5hYmxlZFwiKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3B0aW9ucy5maW5nZXJwcmludChmaWxlLCB0aGlzLm9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGZpbmdlcnByaW50KSB7XG4gICAgICAgIGlmIChmaW5nZXJwcmludCA9PSBudWxsKSB7XG4gICAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIk5vIGZpbmdlcnByaW50IHdhcyBjYWxjdWxhdGVkIG1lYW5pbmcgdGhhdCB0aGUgdXBsb2FkIGNhbm5vdCBiZSBzdG9yZWQgaW4gdGhlIFVSTCBzdG9yYWdlLlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiQ2FsY3VsYXRlZCBmaW5nZXJwcmludDogXCIuY29uY2F0KGZpbmdlcnByaW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczIuX2ZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQ7XG5cbiAgICAgICAgaWYgKF90aGlzMi5fc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fc291cmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfdGhpczIub3B0aW9ucy5maWxlUmVhZGVyLm9wZW5GaWxlKGZpbGUsIF90aGlzMi5vcHRpb25zLmNodW5rU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBfdGhpczIuX3NvdXJjZSA9IHNvdXJjZTsgLy8gSWYgdGhlIHVwbG9hZCB3YXMgY29uZmlndXJlZCB0byB1c2UgbXVsdGlwbGUgcmVxdWVzdHMgb3IgaWYgd2UgcmVzdW1lIGZyb21cbiAgICAgICAgLy8gYW4gdXBsb2FkIHdoaWNoIHVzZWQgbXVsdGlwbGUgcmVxdWVzdHMsIHdlIHN0YXJ0IGEgcGFyYWxsZWwgdXBsb2FkLlxuXG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHMgPiAxIHx8IF90aGlzMi5fcGFyYWxsZWxVcGxvYWRVcmxzICE9IG51bGwpIHtcbiAgICAgICAgICBfdGhpczIuX3N0YXJ0UGFyYWxsZWxVcGxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIuX3N0YXJ0U2luZ2xlVXBsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczIuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIHRoZSB1cGxvYWRpbmcgcHJvY2VkdXJlIGZvciBhIHBhcmFsbGVsaXplZCB1cGxvYWQsIHdoZXJlIG9uZSBmaWxlIGlzIHNwbGl0IGludG9cbiAgICAgKiBtdWx0aXBsZSByZXF1ZXN0IHdoaWNoIGFyZSBydW4gaW4gcGFyYWxsZWwuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydFBhcmFsbGVsVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFBhcmFsbGVsVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB0b3RhbFNpemUgPSB0aGlzLl9zaXplID0gdGhpcy5fc291cmNlLnNpemU7XG4gICAgICB2YXIgdG90YWxQcm9ncmVzcyA9IDA7XG4gICAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZHMgPSBbXTtcbiAgICAgIHZhciBwYXJ0Q291bnQgPSB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMgIT0gbnVsbCA/IHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscy5sZW5ndGggOiB0aGlzLm9wdGlvbnMucGFyYWxsZWxVcGxvYWRzOyAvLyBUaGUgaW5wdXQgZmlsZSB3aWxsIGJlIHNwbGl0IGludG8gbXVsdGlwbGUgc2xpY2VzIHdoaWNoIGFyZSB1cGxvYWRlZCBpbiBzZXBhcmF0ZVxuICAgICAgLy8gcmVxdWVzdHMuIEhlcmUgd2UgZ2VuZXJhdGUgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24gZm9yIHRoZSBzbGljZXMuXG5cbiAgICAgIHZhciBwYXJ0cyA9IHNwbGl0U2l6ZUludG9QYXJ0cyh0aGlzLl9zb3VyY2Uuc2l6ZSwgcGFydENvdW50LCB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMpOyAvLyBDcmVhdGUgYW4gZW1wdHkgbGlzdCBmb3Igc3RvcmluZyB0aGUgdXBsb2FkIFVSTHNcblxuICAgICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzID0gbmV3IEFycmF5KHBhcnRzLmxlbmd0aCk7IC8vIEdlbmVyYXRlIGEgcHJvbWlzZSBmb3IgZWFjaCBzbGljZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZSBpZiB0aGUgcmVzcGVjdGl2ZVxuICAgICAgLy8gdXBsb2FkIGlzIGNvbXBsZXRlZC5cblxuICAgICAgdmFyIHVwbG9hZHMgPSBwYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBsYXN0UGFydFByb2dyZXNzID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fc291cmNlLnNsaWNlKHBhcnQuc3RhcnQsIHBhcnQuZW5kKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gTWVyZ2Ugd2l0aCB0aGUgdXNlciBzdXBwbGllZCBvcHRpb25zIGJ1dCBvdmVyd3JpdGUgc29tZSB2YWx1ZXMuXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIF90aGlzMy5vcHRpb25zLCB7XG4gICAgICAgICAgICAgIC8vIElmIGF2YWlsYWJsZSwgdGhlIHBhcnRpYWwgdXBsb2FkIHNob3VsZCBiZSByZXN1bWVkIGZyb20gYSBwcmV2aW91cyBVUkwuXG4gICAgICAgICAgICAgIHVwbG9hZFVybDogcGFydC51cGxvYWRVcmwgfHwgbnVsbCxcbiAgICAgICAgICAgICAgLy8gV2UgdGFrZSBtYW51YWxseSBjYXJlIG9mIHJlc3VtaW5nIGZvciBwYXJ0aWFsIHVwbG9hZHMsIHNvIHRoZXkgc2hvdWxkXG4gICAgICAgICAgICAgIC8vIG5vdCBiZSBzdG9yZWQgaW4gdGhlIFVSTCBzdG9yYWdlLlxuICAgICAgICAgICAgICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IGZhbHNlLFxuICAgICAgICAgICAgICByZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIHRvIG5vdCBjYXVzZSByZWN1cnNpb24uXG4gICAgICAgICAgICAgIHBhcmFsbGVsVXBsb2FkczogMSxcbiAgICAgICAgICAgICAgbWV0YWRhdGE6IHt9LFxuICAgICAgICAgICAgICAvLyBBZGQgdGhlIGhlYWRlciB0byBpbmRpY2F0ZSB0aGUgdGhpcyBpcyBhIHBhcnRpYWwgdXBsb2FkLlxuICAgICAgICAgICAgICBoZWFkZXJzOiBfb2JqZWN0U3ByZWFkKHt9LCBfdGhpczMub3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgXCJVcGxvYWQtQ29uY2F0XCI6IFwicGFydGlhbFwiXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAvLyBSZWplY3Qgb3IgcmVzb2x2ZSB0aGUgcHJvbWlzZSBpZiB0aGUgdXBsb2FkIGVycm9ycyBvciBjb21wbGV0ZXMuXG4gICAgICAgICAgICAgIG9uU3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgb25FcnJvcjogcmVqZWN0LFxuICAgICAgICAgICAgICAvLyBCYXNlZCBpbiB0aGUgcHJvZ3Jlc3MgZm9yIHRoaXMgcGFydGlhbCB1cGxvYWQsIGNhbGN1bGF0ZSB0aGUgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgLy8gZm9yIHRoZSBlbnRpcmUgZmluYWwgdXBsb2FkLlxuICAgICAgICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiBvblByb2dyZXNzKG5ld1BhcnRQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHRvdGFsUHJvZ3Jlc3MgPSB0b3RhbFByb2dyZXNzIC0gbGFzdFBhcnRQcm9ncmVzcyArIG5ld1BhcnRQcm9ncmVzcztcbiAgICAgICAgICAgICAgICBsYXN0UGFydFByb2dyZXNzID0gbmV3UGFydFByb2dyZXNzO1xuXG4gICAgICAgICAgICAgICAgX3RoaXMzLl9lbWl0UHJvZ3Jlc3ModG90YWxQcm9ncmVzcywgdG90YWxTaXplKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCBldmVyeSBwYXJ0aWFsIHVwbG9hZCBoYXMgYW4gdXBsb2FkIFVSTCwgc28gd2UgY2FuIGFkZFxuICAgICAgICAgICAgICAvLyB0aGVtIHRvIHRoZSBVUkwgc3RvcmFnZS5cbiAgICAgICAgICAgICAgX29uVXBsb2FkVXJsQXZhaWxhYmxlOiBmdW5jdGlvbiBfb25VcGxvYWRVcmxBdmFpbGFibGUoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLl9wYXJhbGxlbFVwbG9hZFVybHNbaW5kZXhdID0gdXBsb2FkLnVybDsgLy8gVGVzdCBpZiBhbGwgdXBsb2FkcyBoYXZlIHJlY2VpdmVkIGFuIFVSTFxuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzMy5fcGFyYWxsZWxVcGxvYWRVcmxzLmZpbHRlcihmdW5jdGlvbiAodSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdTtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMzLl9zYXZlVXBsb2FkSW5VcmxTdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHVwbG9hZCA9IG5ldyBCYXNlVXBsb2FkKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHVwbG9hZC5zdGFydCgpOyAvLyBTdG9yZSB0aGUgdXBsb2FkIGluIGFuIGFycmF5LCBzbyB3ZSBjYW4gbGF0ZXIgYWJvcnQgdGhlbSBpZiBuZWNlc3NhcnkuXG5cbiAgICAgICAgICAgIF90aGlzMy5fcGFyYWxsZWxVcGxvYWRzLnB1c2godXBsb2FkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciByZXE7IC8vIFdhaXQgdW50aWwgYWxsIHBhcnRpYWwgdXBsb2FkcyBhcmUgZmluaXNoZWQgYW5kIHdlIGNhbiBzZW5kIHRoZSBQT1NUIHJlcXVlc3QgZm9yXG4gICAgICAvLyBjcmVhdGluZyB0aGUgZmluYWwgdXBsb2FkLlxuXG4gICAgICBQcm9taXNlLmFsbCh1cGxvYWRzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVxID0gX3RoaXMzLl9vcGVuUmVxdWVzdChcIlBPU1RcIiwgX3RoaXMzLm9wdGlvbnMuZW5kcG9pbnQpO1xuICAgICAgICByZXEuc2V0SGVhZGVyKFwiVXBsb2FkLUNvbmNhdFwiLCBcImZpbmFsO1wiLmNvbmNhdChfdGhpczMuX3BhcmFsbGVsVXBsb2FkVXJscy5qb2luKFwiIFwiKSkpOyAvLyBBZGQgbWV0YWRhdGEgaWYgdmFsdWVzIGhhdmUgYmVlbiBhZGRlZFxuXG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGVuY29kZU1ldGFkYXRhKF90aGlzMy5vcHRpb25zLm1ldGFkYXRhKTtcblxuICAgICAgICBpZiAobWV0YWRhdGEgIT09IFwiXCIpIHtcbiAgICAgICAgICByZXEuc2V0SGVhZGVyKFwiVXBsb2FkLU1ldGFkYXRhXCIsIG1ldGFkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpczMuX3NlbmRSZXF1ZXN0KHJlcSwgbnVsbCk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKCFpblN0YXR1c0NhdGVnb3J5KHJlcy5nZXRTdGF0dXMoKSwgMjAwKSkge1xuICAgICAgICAgIF90aGlzMy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgY3JlYXRpbmcgdXBsb2FkXCIpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmdldEhlYWRlcihcIkxvY2F0aW9uXCIpO1xuXG4gICAgICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgX3RoaXMzLl9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogaW52YWxpZCBvciBtaXNzaW5nIExvY2F0aW9uIGhlYWRlclwiKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMy51cmwgPSByZXNvbHZlVXJsKF90aGlzMy5vcHRpb25zLmVuZHBvaW50LCBsb2NhdGlvbik7XG4gICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJDcmVhdGVkIHVwbG9hZCBhdCBcIi5jb25jYXQoX3RoaXMzLnVybCkpO1xuXG4gICAgICAgIF90aGlzMy5fZW1pdFN1Y2Nlc3MoKTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczMuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIHRoZSB1cGxvYWRpbmcgcHJvY2VkdXJlIGZvciBhIG5vbi1wYXJhbGxlbCB1cGxvYWQuIEhlcmUgdGhlIGVudGlyZSBmaWxlIGlzXG4gICAgICogdXBsb2FkZWQgaW4gYSBzZXF1ZW50aWFsIG1hdHRlci5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0U2luZ2xlVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFNpbmdsZVVwbG9hZCgpIHtcbiAgICAgIC8vIEZpcnN0LCB3ZSBsb29rIGF0IHRoZSB1cGxvYWRMZW5ndGhEZWZlcnJlZCBvcHRpb24uXG4gICAgICAvLyBOZXh0LCB3ZSBjaGVjayBpZiB0aGUgY2FsbGVyIGhhcyBzdXBwbGllZCBhIG1hbnVhbCB1cGxvYWQgc2l6ZS5cbiAgICAgIC8vIEZpbmFsbHksIHdlIHRyeSB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgc2l6ZSBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICB0aGlzLl9zaXplID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnVwbG9hZFNpemUgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9zaXplID0gK3RoaXMub3B0aW9ucy51cGxvYWRTaXplO1xuXG4gICAgICAgIGlmIChpc05hTih0aGlzLl9zaXplKSkge1xuICAgICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCBjb252ZXJ0IGB1cGxvYWRTaXplYCBvcHRpb24gaW50byBhIG51bWJlclwiKSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSB0aGlzLl9zb3VyY2Uuc2l6ZTtcblxuICAgICAgICBpZiAodGhpcy5fc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogY2Fubm90IGF1dG9tYXRpY2FsbHkgZGVyaXZlIHVwbG9hZCdzIHNpemUgZnJvbSBpbnB1dCBhbmQgbXVzdCBiZSBzcGVjaWZpZWQgbWFudWFsbHkgdXNpbmcgdGhlIGB1cGxvYWRTaXplYCBvcHRpb25cIikpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlc2V0IHRoZSBhYm9ydGVkIGZsYWcgd2hlbiB0aGUgdXBsb2FkIGlzIHN0YXJ0ZWQgb3IgZWxzZSB0aGVcbiAgICAgIC8vIF9wZXJmb3JtVXBsb2FkIHdpbGwgc3RvcCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QgaWYgdGhlIHVwbG9hZCBoYXMgYmVlblxuICAgICAgLy8gYWJvcnRlZCBwcmV2aW91c2x5LlxuXG5cbiAgICAgIHRoaXMuX2Fib3J0ZWQgPSBmYWxzZTsgLy8gVGhlIHVwbG9hZCBoYWQgYmVlbiBzdGFydGVkIHByZXZpb3VzbHkgYW5kIHdlIHNob3VsZCByZXVzZSB0aGlzIFVSTC5cblxuICAgICAgaWYgKHRoaXMudXJsICE9IG51bGwpIHtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIlJlc3VtaW5nIHVwbG9hZCBmcm9tIHByZXZpb3VzIFVSTDogXCIuY29uY2F0KHRoaXMudXJsKSk7XG5cbiAgICAgICAgdGhpcy5fcmVzdW1lVXBsb2FkKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBBIFVSTCBoYXMgbWFudWFsbHkgYmVlbiBzcGVjaWZpZWQsIHNvIHdlIHRyeSB0byByZXN1bWVcblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZFVybCAhPSBudWxsKSB7XG4gICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJSZXN1bWluZyB1cGxvYWQgZnJvbSBwcm92aWRlZCBVUkw6IFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMudXJsKSk7XG4gICAgICAgIHRoaXMudXJsID0gdGhpcy5vcHRpb25zLnVwbG9hZFVybDtcblxuICAgICAgICB0aGlzLl9yZXN1bWVVcGxvYWQoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEFuIHVwbG9hZCBoYXMgbm90IHN0YXJ0ZWQgZm9yIHRoZSBmaWxlIHlldCwgc28gd2Ugc3RhcnQgYSBuZXcgb25lXG5cblxuICAgICAgKDAsIF9sb2dnZXIubG9nKShcIkNyZWF0aW5nIGEgbmV3IHVwbG9hZFwiKTtcblxuICAgICAgdGhpcy5fY3JlYXRlVXBsb2FkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0IGFueSBydW5uaW5nIHJlcXVlc3QgYW5kIHN0b3AgdGhlIGN1cnJlbnQgdXBsb2FkLiBBZnRlciBhYm9ydCBpcyBjYWxsZWQsIG5vIGV2ZW50XG4gICAgICogaGFuZGxlciB3aWxsIGJlIGludm9rZWQgYW55bW9yZS4gWW91IGNhbiB1c2UgdGhlIGBzdGFydGAgbWV0aG9kIHRvIHJlc3VtZSB0aGUgdXBsb2FkXG4gICAgICogYWdhaW4uXG4gICAgICogSWYgYHNob3VsZFRlcm1pbmF0ZWAgaXMgdHJ1ZSwgdGhlIGB0ZXJtaW5hdGVgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIHJlbW92ZSB0aGVcbiAgICAgKiBjdXJyZW50IHVwbG9hZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFRlcm1pbmF0ZSBUcnVlIGlmIHRoZSB1cGxvYWQgc2hvdWxkIGJlIGRlbGV0ZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSBQcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQvcmVqZWN0ZWQgd2hlbiB0aGUgcmVxdWVzdHMgZmluaXNoLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWJvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoc2hvdWxkVGVybWluYXRlLCBjYikge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXM6IHRoZSBhYm9ydCBmdW5jdGlvbiBkb2VzIG5vdCBhY2NlcHQgYSBjYWxsYmFjayBzaW5jZSB2MiBhbnltb3JlOyBwbGVhc2UgdXNlIHRoZSByZXR1cm5lZCBQcm9taXNlIGluc3RlYWRcIik7XG4gICAgICB9IC8vIFN0b3AgYW55IHBhcmFsbGVsIHBhcnRpYWwgdXBsb2FkcywgdGhhdCBoYXZlIGJlZW4gc3RhcnRlZCBpbiBfc3RhcnRQYXJhbGxlbFVwbG9hZHMuXG5cblxuICAgICAgaWYgKHRoaXMuX3BhcmFsbGVsVXBsb2FkcyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BhcmFsbGVsVXBsb2Fkcy5mb3JFYWNoKGZ1bmN0aW9uICh1cGxvYWQpIHtcbiAgICAgICAgICB1cGxvYWQuYWJvcnQoc2hvdWxkVGVybWluYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFN0b3AgYW55IGN1cnJlbnQgcnVubmluZyByZXF1ZXN0LlxuXG5cbiAgICAgIGlmICh0aGlzLl9yZXEgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcmVxLmFib3J0KCk7XG5cbiAgICAgICAgdGhpcy5fc291cmNlLmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Fib3J0ZWQgPSB0cnVlOyAvLyBTdG9wIGFueSB0aW1lb3V0IHVzZWQgZm9yIGluaXRpYXRpbmcgYSByZXRyeS5cblxuICAgICAgaWYgKHRoaXMuX3JldHJ5VGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZXRyeVRpbWVvdXQpO1xuICAgICAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNob3VsZFRlcm1pbmF0ZSB8fCB0aGlzLnVybCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEJhc2VVcGxvYWQudGVybWluYXRlKHRoaXMudXJsLCB0aGlzLm9wdGlvbnMpIC8vIFJlbW92ZSBlbnRyeSBmcm9tIHRoZSBVUkwgc3RvcmFnZSBzaW5jZSB0aGUgdXBsb2FkIFVSTCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuX3JlbW92ZUZyb21VcmxTdG9yYWdlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRIdHRwRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIG1lc3NhZ2UsIGNhdXNpbmdFcnIpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgX2Vycm9yLmRlZmF1bHQobWVzc2FnZSwgY2F1c2luZ0VyciwgcmVxLCByZXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdEVycm9yKGVycikge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7IC8vIERvIG5vdCBlbWl0IGVycm9ycywgZS5nLiBmcm9tIGFib3J0ZWQgSFRUUCByZXF1ZXN0cywgaWYgdGhlIHVwbG9hZCBoYXMgYmVlbiBzdG9wcGVkLlxuXG5cbiAgICAgIGlmICh0aGlzLl9hYm9ydGVkKSByZXR1cm47IC8vIENoZWNrIGlmIHdlIHNob3VsZCByZXRyeSwgd2hlbiBlbmFibGVkLCBiZWZvcmUgc2VuZGluZyB0aGUgZXJyb3IgdG8gdGhlIHVzZXIuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmV0cnlEZWxheXMgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSB3aWxsIHJlc2V0IHRoZSBhdHRlbXB0IGNvdW50ZXIgaWZcbiAgICAgICAgLy8gLSB3ZSB3ZXJlIGFscmVhZHkgYWJsZSB0byBjb25uZWN0IHRvIHRoZSBzZXJ2ZXIgKG9mZnNldCAhPSBudWxsKSBhbmRcbiAgICAgICAgLy8gLSB3ZSB3ZXJlIGFibGUgdG8gdXBsb2FkIGEgc21hbGwgY2h1bmsgb2YgZGF0YSB0byB0aGUgc2VydmVyXG4gICAgICAgIHZhciBzaG91bGRSZXNldERlbGF5cyA9IHRoaXMuX29mZnNldCAhPSBudWxsICYmIHRoaXMuX29mZnNldCA+IHRoaXMuX29mZnNldEJlZm9yZVJldHJ5O1xuXG4gICAgICAgIGlmIChzaG91bGRSZXNldERlbGF5cykge1xuICAgICAgICAgIHRoaXMuX3JldHJ5QXR0ZW1wdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkUmV0cnkoZXJyLCB0aGlzLl9yZXRyeUF0dGVtcHQsIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLm9wdGlvbnMucmV0cnlEZWxheXNbdGhpcy5fcmV0cnlBdHRlbXB0KytdO1xuICAgICAgICAgIHRoaXMuX29mZnNldEJlZm9yZVJldHJ5ID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgIHRoaXMuX3JldHJ5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM1LnN0YXJ0KCk7XG4gICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uRXJyb3IoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIG5vdGlmaWNhdGlvbiBpZiB0aGUgdXBsb2FkIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0U3VjY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFN1Y2Nlc3MoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBzdG9yZWQgZmluZ2VycHJpbnQgYW5kIGNvcnJlc3BvbmRpbmcgZW5kcG9pbnQuIFRoaXMgY2F1c2VzXG4gICAgICAgIC8vIG5ldyB1cGxvYWRzIG9mIHRoZSBzYW1lIGZpbGUgdG8gYmUgdHJlYXRlZCBhcyBhIGRpZmZlcmVudCBmaWxlLlxuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tVXJsU3RvcmFnZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vblN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25TdWNjZXNzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2hlcyBub3RpZmljYXRpb24gd2hlbiBkYXRhIGhhcyBiZWVuIHNlbnQgdG8gdGhlIHNlcnZlci4gVGhpc1xuICAgICAqIGRhdGEgbWF5IG5vdCBoYXZlIGJlZW4gYWNjZXB0ZWQgYnkgdGhlIHNlcnZlciB5ZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZXNTZW50ICBOdW1iZXIgb2YgYnl0ZXMgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc1RvdGFsIFRvdGFsIG51bWJlciBvZiBieXRlcyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdFByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0UHJvZ3Jlc3MoYnl0ZXNTZW50LCBieXRlc1RvdGFsKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vblByb2dyZXNzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uUHJvZ3Jlc3MoYnl0ZXNTZW50LCBieXRlc1RvdGFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIG5vdGlmaWNhdGlvbiB3aGVuIGEgY2h1bmsgb2YgZGF0YSBoYXMgYmVlbiBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICAgKiBhbmQgYWNjZXB0ZWQgYnkgdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2h1bmtTaXplICBTaXplIG9mIHRoZSBjaHVuayB0aGF0IHdhcyBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc0FjY2VwdGVkIFRvdGFsIG51bWJlciBvZiBieXRlcyB0aGF0IGhhdmUgYmVlblxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc1RvdGFsIFRvdGFsIG51bWJlciBvZiBieXRlcyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdENodW5rQ29tcGxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRDaHVua0NvbXBsZXRlKGNodW5rU2l6ZSwgYnl0ZXNBY2NlcHRlZCwgYnl0ZXNUb3RhbCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25DaHVua0NvbXBsZXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uQ2h1bmtDb21wbGV0ZShjaHVua1NpemUsIGJ5dGVzQWNjZXB0ZWQsIGJ5dGVzVG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXBsb2FkIHVzaW5nIHRoZSBjcmVhdGlvbiBleHRlbnNpb24gYnkgc2VuZGluZyBhIFBPU1RcbiAgICAgKiByZXF1ZXN0IHRvIHRoZSBlbmRwb2ludC4gQWZ0ZXIgc3VjY2Vzc2Z1bCBjcmVhdGlvbiB0aGUgZmlsZSB3aWxsIGJlXG4gICAgICogdXBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuZHBvaW50KSB7XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IHVuYWJsZSB0byBjcmVhdGUgdXBsb2FkIGJlY2F1c2Ugbm8gZW5kcG9pbnQgaXMgcHJvdmlkZWRcIikpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcSA9IHRoaXMuX29wZW5SZXF1ZXN0KFwiUE9TVFwiLCB0aGlzLm9wdGlvbnMuZW5kcG9pbnQpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoXCJVcGxvYWQtRGVmZXItTGVuZ3RoXCIsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcihcIlVwbG9hZC1MZW5ndGhcIiwgdGhpcy5fc2l6ZSk7XG4gICAgICB9IC8vIEFkZCBtZXRhZGF0YSBpZiB2YWx1ZXMgaGF2ZSBiZWVuIGFkZGVkXG5cblxuICAgICAgdmFyIG1ldGFkYXRhID0gZW5jb2RlTWV0YWRhdGEodGhpcy5vcHRpb25zLm1ldGFkYXRhKTtcblxuICAgICAgaWYgKG1ldGFkYXRhICE9PSBcIlwiKSB7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoXCJVcGxvYWQtTWV0YWRhdGFcIiwgbWV0YWRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWREYXRhRHVyaW5nQ3JlYXRpb24gJiYgIXRoaXMub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgICAgICBwcm9taXNlID0gdGhpcy5fYWRkQ2h1bmtUb1JlcXVlc3QocmVxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UgPSB0aGlzLl9zZW5kUmVxdWVzdChyZXEsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkocmVzLmdldFN0YXR1cygpLCAyMDApKSB7XG4gICAgICAgICAgX3RoaXM2Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSBjcmVhdGluZyB1cGxvYWRcIik7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYXRpb24gPSByZXMuZ2V0SGVhZGVyKFwiTG9jYXRpb25cIik7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICBfdGhpczYuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiBpbnZhbGlkIG9yIG1pc3NpbmcgTG9jYXRpb24gaGVhZGVyXCIpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM2LnVybCA9IHJlc29sdmVVcmwoX3RoaXM2Lm9wdGlvbnMuZW5kcG9pbnQsIGxvY2F0aW9uKTtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIkNyZWF0ZWQgdXBsb2FkIGF0IFwiLmNvbmNhdChfdGhpczYudXJsKSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczYub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIF90aGlzNi5vcHRpb25zLl9vblVwbG9hZFVybEF2YWlsYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzNi5fc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIC8vIE5vdGhpbmcgdG8gdXBsb2FkIGFuZCBmaWxlIHdhcyBzdWNjZXNzZnVsbHkgY3JlYXRlZFxuICAgICAgICAgIF90aGlzNi5fZW1pdFN1Y2Nlc3MoKTtcblxuICAgICAgICAgIF90aGlzNi5fc291cmNlLmNsb3NlKCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczYuX3NhdmVVcGxvYWRJblVybFN0b3JhZ2UoKTtcblxuICAgICAgICBpZiAoX3RoaXM2Lm9wdGlvbnMudXBsb2FkRGF0YUR1cmluZ0NyZWF0aW9uKSB7XG4gICAgICAgICAgX3RoaXM2Ll9oYW5kbGVVcGxvYWRSZXNwb25zZShyZXEsIHJlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXM2Ll9vZmZzZXQgPSAwO1xuXG4gICAgICAgICAgX3RoaXM2Ll9wZXJmb3JtVXBsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczYuX2VtaXRIdHRwRXJyb3IocmVxLCBudWxsLCBcInR1czogZmFpbGVkIHRvIGNyZWF0ZSB1cGxvYWRcIiwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFRyeSB0byByZXN1bWUgYW4gZXhpc3RpbmcgdXBsb2FkLiBGaXJzdCBhIEhFQUQgcmVxdWVzdCB3aWxsIGJlIHNlbnRcbiAgICAgKiB0byByZXRyaWV2ZSB0aGUgb2Zmc2V0LiBJZiB0aGUgcmVxdWVzdCBmYWlscyBhIG5ldyB1cGxvYWQgd2lsbCBiZVxuICAgICAqIGNyZWF0ZWQuIEluIHRoZSBjYXNlIG9mIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSB0aGUgZmlsZSB3aWxsIGJlIHVwbG9hZGVkLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVzdW1lVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN1bWVVcGxvYWQoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIHJlcSA9IHRoaXMuX29wZW5SZXF1ZXN0KFwiSEVBRFwiLCB0aGlzLnVybCk7XG5cbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fc2VuZFJlcXVlc3QocmVxLCBudWxsKTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlcy5nZXRTdGF0dXMoKTtcblxuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCAyMDApKSB7XG4gICAgICAgICAgaWYgKGluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCA0MDApKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgc3RvcmVkIGZpbmdlcnByaW50IGFuZCBjb3JyZXNwb25kaW5nIGVuZHBvaW50LFxuICAgICAgICAgICAgLy8gb24gY2xpZW50IGVycm9ycyBzaW5jZSB0aGUgZmlsZSBjYW4gbm90IGJlIGZvdW5kXG4gICAgICAgICAgICBfdGhpczcuX3JlbW92ZUZyb21VcmxTdG9yYWdlKCk7XG4gICAgICAgICAgfSAvLyBJZiB0aGUgdXBsb2FkIGlzIGxvY2tlZCAoaW5kaWNhdGVkIGJ5IHRoZSA0MjMgTG9ja2VkIHN0YXR1cyBjb2RlKSwgd2VcbiAgICAgICAgICAvLyBlbWl0IGFuIGVycm9yIGluc3RlYWQgb2YgZGlyZWN0bHkgc3RhcnRpbmcgYSBuZXcgdXBsb2FkLiBUaGlzIHdheSB0aGVcbiAgICAgICAgICAvLyByZXRyeSBsb2dpYyBjYW4gY2F0Y2ggdGhlIGVycm9yIGFuZCB3aWxsIHJldHJ5IHRoZSB1cGxvYWQuIEFuIHVwbG9hZFxuICAgICAgICAgIC8vIGlzIHVzdWFsbHkgbG9ja2VkIGZvciBhIHNob3J0IHBlcmlvZCBvZiB0aW1lIGFuZCB3aWxsIGJlIGF2YWlsYWJsZVxuICAgICAgICAgIC8vIGFmdGVyd2FyZHMuXG5cblxuICAgICAgICAgIGlmIChzdGF0dXMgPT09IDQyMykge1xuICAgICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogdXBsb2FkIGlzIGN1cnJlbnRseSBsb2NrZWQ7IHJldHJ5IGxhdGVyXCIpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFfdGhpczcub3B0aW9ucy5lbmRwb2ludCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgYXR0ZW1wdCB0byBjcmVhdGUgYSBuZXcgdXBsb2FkIGlmIG5vIGVuZHBvaW50IGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogdW5hYmxlIHRvIHJlc3VtZSB1cGxvYWQgKG5ldyB1cGxvYWQgY2Fubm90IGJlIGNyZWF0ZWQgd2l0aG91dCBhbiBlbmRwb2ludClcIik7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIFRyeSB0byBjcmVhdGUgYSBuZXcgdXBsb2FkXG5cblxuICAgICAgICAgIF90aGlzNy51cmwgPSBudWxsO1xuXG4gICAgICAgICAgX3RoaXM3Ll9jcmVhdGVVcGxvYWQoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZUludChyZXMuZ2V0SGVhZGVyKFwiVXBsb2FkLU9mZnNldFwiKSwgMTApO1xuXG4gICAgICAgIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogaW52YWxpZCBvciBtaXNzaW5nIG9mZnNldCB2YWx1ZVwiKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSBwYXJzZUludChyZXMuZ2V0SGVhZGVyKFwiVXBsb2FkLUxlbmd0aFwiKSwgMTApO1xuXG4gICAgICAgIGlmIChpc05hTihsZW5ndGgpICYmICFfdGhpczcub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IGludmFsaWQgb3IgbWlzc2luZyBsZW5ndGggdmFsdWVcIik7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIF90aGlzNy5vcHRpb25zLl9vblVwbG9hZFVybEF2YWlsYWJsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgX3RoaXM3Lm9wdGlvbnMuX29uVXBsb2FkVXJsQXZhaWxhYmxlKCk7XG4gICAgICAgIH0gLy8gVXBsb2FkIGhhcyBhbHJlYWR5IGJlZW4gY29tcGxldGVkIGFuZCB3ZSBkbyBub3QgbmVlZCB0byBzZW5kIGFkZGl0aW9uYWxcbiAgICAgICAgLy8gZGF0YSB0byB0aGUgc2VydmVyXG5cblxuICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBfdGhpczcuX2VtaXRQcm9ncmVzcyhsZW5ndGgsIGxlbmd0aCk7XG5cbiAgICAgICAgICBfdGhpczcuX2VtaXRTdWNjZXNzKCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczcuX29mZnNldCA9IG9mZnNldDtcblxuICAgICAgICBfdGhpczcuX3BlcmZvcm1VcGxvYWQoKTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCBudWxsLCBcInR1czogZmFpbGVkIHRvIHJlc3VtZSB1cGxvYWRcIiwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCB1cGxvYWRpbmcgdGhlIGZpbGUgdXNpbmcgUEFUQ0ggcmVxdWVzdHMuIFRoZSBmaWxlIHdpbGwgYmUgZGl2aWRlZFxuICAgICAqIGludG8gY2h1bmtzIGFzIHNwZWNpZmllZCBpbiB0aGUgY2h1bmtTaXplIG9wdGlvbi4gRHVyaW5nIHRoZSB1cGxvYWRcbiAgICAgKiB0aGUgb25Qcm9ncmVzcyBldmVudCBoYW5kbGVyIG1heSBiZSBpbnZva2VkIG11bHRpcGxlIHRpbWVzLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGVyZm9ybVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybVVwbG9hZCgpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzOyAvLyBJZiB0aGUgdXBsb2FkIGhhcyBiZWVuIGFib3J0ZWQsIHdlIHdpbGwgbm90IHNlbmQgdGhlIG5leHQgUEFUQ0ggcmVxdWVzdC5cbiAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGlmIHRoZSBhYm9ydCBtZXRob2Qgd2FzIGNhbGxlZCBkdXJpbmcgYSBjYWxsYmFjaywgc3VjaFxuICAgICAgLy8gYXMgb25DaHVua0NvbXBsZXRlIG9yIG9uUHJvZ3Jlc3MuXG5cblxuICAgICAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxOyAvLyBTb21lIGJyb3dzZXIgYW5kIHNlcnZlcnMgbWF5IG5vdCBzdXBwb3J0IHRoZSBQQVRDSCBtZXRob2QuIEZvciB0aG9zZVxuICAgICAgLy8gY2FzZXMsIHlvdSBjYW4gdGVsbCB0dXMtanMtY2xpZW50IHRvIHVzZSBhIFBPU1QgcmVxdWVzdCB3aXRoIHRoZVxuICAgICAgLy8gWC1IVFRQLU1ldGhvZC1PdmVycmlkZSBoZWFkZXIgZm9yIHNpbXVsYXRpbmcgYSBQQVRDSCByZXF1ZXN0LlxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJyaWRlUGF0Y2hNZXRob2QpIHtcbiAgICAgICAgcmVxID0gdGhpcy5fb3BlblJlcXVlc3QoXCJQT1NUXCIsIHRoaXMudXJsKTtcbiAgICAgICAgcmVxLnNldEhlYWRlcihcIlgtSFRUUC1NZXRob2QtT3ZlcnJpZGVcIiwgXCJQQVRDSFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcSA9IHRoaXMuX29wZW5SZXF1ZXN0KFwiUEFUQ0hcIiwgdGhpcy51cmwpO1xuICAgICAgfVxuXG4gICAgICByZXEuc2V0SGVhZGVyKFwiVXBsb2FkLU9mZnNldFwiLCB0aGlzLl9vZmZzZXQpO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX2FkZENodW5rVG9SZXF1ZXN0KHJlcSk7XG5cbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGlmICghaW5TdGF0dXNDYXRlZ29yeShyZXMuZ2V0U3RhdHVzKCksIDIwMCkpIHtcbiAgICAgICAgICBfdGhpczguX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIHVwbG9hZGluZyBjaHVua1wiKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzOC5faGFuZGxlVXBsb2FkUmVzcG9uc2UocmVxLCByZXMpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIERvbid0IGVtaXQgYW4gZXJyb3IgaWYgdGhlIHVwbG9hZCB3YXMgYWJvcnRlZCBtYW51YWxseVxuICAgICAgICBpZiAoX3RoaXM4Ll9hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM4Ll9lbWl0SHR0cEVycm9yKHJlcSwgbnVsbCwgXCJ0dXM6IGZhaWxlZCB0byB1cGxvYWQgY2h1bmsgYXQgb2Zmc2V0IFwiICsgX3RoaXM4Ll9vZmZzZXQsIGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogX2FkZENodW5rdG9SZXF1ZXN0IHJlYWRzIGEgY2h1bmsgZnJvbSB0aGUgc291cmNlIGFuZCBzZW5kcyBpdCB1c2luZyB0aGVcbiAgICAgKiBzdXBwbGllZCByZXF1ZXN0IG9iamVjdC4gSXQgd2lsbCBub3QgaGFuZGxlIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZENodW5rVG9SZXF1ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRDaHVua1RvUmVxdWVzdChyZXEpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB2YXIgZW5kID0gdGhpcy5fb2Zmc2V0ICsgdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgICAgIHJlcS5zZXRQcm9ncmVzc0hhbmRsZXIoZnVuY3Rpb24gKGJ5dGVzU2VudCkge1xuICAgICAgICBfdGhpczkuX2VtaXRQcm9ncmVzcyhzdGFydCArIGJ5dGVzU2VudCwgX3RoaXM5Ll9zaXplKTtcbiAgICAgIH0pO1xuICAgICAgcmVxLnNldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7IC8vIFRoZSBzcGVjaWZpZWQgY2h1bmtTaXplIG1heSBiZSBJbmZpbml0eSBvciB0aGUgY2FsY2x1YXRlZCBlbmQgcG9zaXRpb25cbiAgICAgIC8vIG1heSBleGNlZWQgdGhlIGZpbGUncyBzaXplLiBJbiBib3RoIGNhc2VzLCB3ZSBsaW1pdCB0aGUgZW5kIHBvc2l0aW9uIHRvXG4gICAgICAvLyB0aGUgaW5wdXQncyB0b3RhbCBzaXplIGZvciBzaW1wbGVyIGNhbGN1bGF0aW9ucyBhbmQgY29ycmVjdG5lc3MuXG5cbiAgICAgIGlmICgoZW5kID09PSBJbmZpbml0eSB8fCBlbmQgPiB0aGlzLl9zaXplKSAmJiAhdGhpcy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgIGVuZCA9IHRoaXMuX3NpemU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2Uuc2xpY2Uoc3RhcnQsIGVuZCkudGhlbihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWUsXG4gICAgICAgICAgICBkb25lID0gX3JlZjIuZG9uZTsgLy8gSWYgdGhlIHVwbG9hZCBsZW5ndGggaXMgZGVmZXJyZWQsIHRoZSB1cGxvYWQgc2l6ZSB3YXMgbm90IHNwZWNpZmllZCBkdXJpbmdcbiAgICAgICAgLy8gdXBsb2FkIGNyZWF0aW9uLiBTbywgaWYgdGhlIGZpbGUgcmVhZGVyIGlzIGRvbmUgcmVhZGluZywgd2Uga25vdyB0aGUgdG90YWxcbiAgICAgICAgLy8gdXBsb2FkIHNpemUgYW5kIGNhbiB0ZWxsIHRoZSB0dXMgc2VydmVyLlxuXG4gICAgICAgIGlmIChfdGhpczkub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCAmJiBkb25lKSB7XG4gICAgICAgICAgX3RoaXM5Ll9zaXplID0gX3RoaXM5Ll9vZmZzZXQgKyAodmFsdWUgJiYgdmFsdWUuc2l6ZSA/IHZhbHVlLnNpemUgOiAwKTtcbiAgICAgICAgICByZXEuc2V0SGVhZGVyKFwiVXBsb2FkLUxlbmd0aFwiLCBfdGhpczkuX3NpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzOS5fc2VuZFJlcXVlc3QocmVxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczkuX2VtaXRQcm9ncmVzcyhfdGhpczkuX29mZnNldCwgX3RoaXM5Ll9zaXplKTtcblxuICAgICAgICAgIHJldHVybiBfdGhpczkuX3NlbmRSZXF1ZXN0KHJlcSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogX2hhbmRsZVVwbG9hZFJlc3BvbnNlIGlzIHVzZWQgYnkgcmVxdWVzdHMgdGhhdCBoYXZlbiBiZWVuIHNlbnQgdXNpbmcgX2FkZENodW5rVG9SZXF1ZXN0XG4gICAgICogYW5kIGFscmVhZHkgaGF2ZSByZWNlaXZlZCBhIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlVXBsb2FkUmVzcG9uc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVVwbG9hZFJlc3BvbnNlKHJlcSwgcmVzKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQocmVzLmdldEhlYWRlcihcIlVwbG9hZC1PZmZzZXRcIiksIDEwKTtcblxuICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgdGhpcy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IGludmFsaWQgb3IgbWlzc2luZyBvZmZzZXQgdmFsdWVcIik7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbWl0UHJvZ3Jlc3Mob2Zmc2V0LCB0aGlzLl9zaXplKTtcblxuICAgICAgdGhpcy5fZW1pdENodW5rQ29tcGxldGUob2Zmc2V0IC0gdGhpcy5fb2Zmc2V0LCBvZmZzZXQsIHRoaXMuX3NpemUpO1xuXG4gICAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICAgIGlmIChvZmZzZXQgPT0gdGhpcy5fc2l6ZSkge1xuICAgICAgICAvLyBZYXksIGZpbmFsbHkgZG9uZSA6KVxuICAgICAgICB0aGlzLl9lbWl0U3VjY2VzcygpO1xuXG4gICAgICAgIHRoaXMuX3NvdXJjZS5jbG9zZSgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGVyZm9ybVVwbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgSFRUUCByZXF1ZXN0IG9iamVjdCB3aXRoIHRoZSBnaXZlbiBtZXRob2QgYW5kIFVSTC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX29wZW5SZXF1ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vcGVuUmVxdWVzdChtZXRob2QsIHVybCkge1xuICAgICAgdmFyIHJlcSA9IG9wZW5SZXF1ZXN0KG1ldGhvZCwgdXJsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5fcmVxID0gcmVxO1xuICAgICAgcmV0dXJuIHJlcTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBlbnRyeSBpbiB0aGUgVVJMIHN0b3JhZ2UsIGlmIGl0IGhhcyBiZWVuIHNhdmVkIGJlZm9yZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZUZyb21VcmxTdG9yYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVGcm9tVXJsU3RvcmFnZSgpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLl91cmxTdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgIHRoaXMuX3VybFN0b3JhZ2UucmVtb3ZlVXBsb2FkKHRoaXMuX3VybFN0b3JhZ2VLZXkpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczEwLl9lbWl0RXJyb3IoZXJyKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl91cmxTdG9yYWdlS2V5ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSB1cGxvYWQgVVJMIHRvIHRoZSBVUkwgc3RvcmFnZSwgaWYgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zYXZlVXBsb2FkSW5VcmxTdG9yYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zYXZlVXBsb2FkSW5VcmxTdG9yYWdlKCkge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzOyAvLyBPbmx5IGlmIGEgZmluZ2VycHJpbnQgd2FzIGNhbGN1bGF0ZWQgZm9yIHRoZSBpbnB1dCAoaS5lLiBub3QgYSBzdHJlYW0pLCB3ZSBjYW4gc3RvcmUgdGhlIHVwbG9hZCBVUkwuXG5cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc3RvcmVGaW5nZXJwcmludEZvclJlc3VtaW5nIHx8ICF0aGlzLl9maW5nZXJwcmludCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzdG9yZWRVcGxvYWQgPSB7XG4gICAgICAgIHNpemU6IHRoaXMuX3NpemUsXG4gICAgICAgIG1ldGFkYXRhOiB0aGlzLm9wdGlvbnMubWV0YWRhdGEsXG4gICAgICAgIGNyZWF0aW9uVGltZTogbmV3IERhdGUoKS50b1N0cmluZygpXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fcGFyYWxsZWxVcGxvYWRzKSB7XG4gICAgICAgIC8vIFNhdmUgbXVsdGlwbGUgVVJMcyBpZiB0aGUgcGFyYWxsZWxVcGxvYWRzIG9wdGlvbiBpcyB1c2VkIC4uLlxuICAgICAgICBzdG9yZWRVcGxvYWQucGFyYWxsZWxVcGxvYWRVcmxzID0gdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gLi4uIG90aGVyd2lzZSB3ZSBqdXN0IHNhdmUgdGhlIG9uZSBhdmFpbGFibGUgVVJMLlxuICAgICAgICBzdG9yZWRVcGxvYWQudXBsb2FkVXJsID0gdGhpcy51cmw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3VybFN0b3JhZ2UuYWRkVXBsb2FkKHRoaXMuX2ZpbmdlcnByaW50LCBzdG9yZWRVcGxvYWQpLnRoZW4oZnVuY3Rpb24gKHVybFN0b3JhZ2VLZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTEuX3VybFN0b3JhZ2VLZXkgPSB1cmxTdG9yYWdlS2V5O1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMTEuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSByZXF1ZXN0IHdpdGggdGhlIHByb3ZpZGVkIGJvZHkgd2hpbGUgaW52b2tpbmcgdGhlIG9uQmVmb3JlUmVxdWVzdFxuICAgICAqIGFuZCBvbkFmdGVyUmVzcG9uc2UgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2VuZFJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NlbmRSZXF1ZXN0KHJlcSkge1xuICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgICB2YXIgYm9keSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25CZWZvcmVSZXF1ZXN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uQmVmb3JlUmVxdWVzdChyZXEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVxLnNlbmQoYm9keSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgX3RoaXMxMi5vcHRpb25zLm9uQWZ0ZXJSZXNwb25zZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgX3RoaXMxMi5vcHRpb25zLm9uQWZ0ZXJSZXNwb25zZShyZXEsIHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwidGVybWluYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRlcm1pbmF0ZSh1cmwpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBjYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXM6IHRoZSB0ZXJtaW5hdGUgZnVuY3Rpb24gZG9lcyBub3QgYWNjZXB0IGEgY2FsbGJhY2sgc2luY2UgdjIgYW55bW9yZTsgcGxlYXNlIHVzZSB0aGUgcmV0dXJuZWQgUHJvbWlzZSBpbnN0ZWFkXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxID0gb3BlblJlcXVlc3QoXCJERUxFVEVcIiwgdXJsLCBvcHRpb25zKTtcbiAgICAgIHZhciBwcm9taXNlID0gcmVxLnNlbmQoKTtcbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAvLyBBIDIwNCByZXNwb25zZSBpbmRpY2F0ZXMgYSBzdWNjZXNzZnVsbCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXMuZ2V0U3RhdHVzKCkgPT09IDIwNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBfZXJyb3IuZGVmYXVsdChcInR1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSB0ZXJtaW5hdGluZyB1cGxvYWRcIiwgbnVsbCwgcmVxLCByZXMpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIF9lcnJvci5kZWZhdWx0KSkge1xuICAgICAgICAgIGVyciA9IG5ldyBfZXJyb3IuZGVmYXVsdChcInR1czogZmFpbGVkIHRvIHRlcm1pbmF0ZSB1cGxvYWRcIiwgZXJyLCByZXEsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaG91bGRSZXRyeShlcnIsIDAsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IC8vIEluc3RlYWQgb2Yga2VlcGluZyB0cmFjayBvZiB0aGUgcmV0cnkgYXR0ZW1wdHMsIHdlIHJlbW92ZSB0aGUgZmlyc3QgZWxlbWVudCBmcm9tIHRoZSBkZWxheXNcbiAgICAgICAgLy8gYXJyYXkuIElmIHRoZSBhcnJheSBpcyBlbXB0eSwgYWxsIHJldHJ5IGF0dGVtcHRzIGFyZSB1c2VkIHVwIGFuZCB3ZSB3aWxsIGJ1YmJsZSB1cCB0aGUgZXJyb3IuXG4gICAgICAgIC8vIFdlIHJlY3Vyc2l2ZWx5IGNhbGwgdGhlIHRlcm1pbmF0ZSBmdW5jdGlvbiB3aWxsIHJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHJldHJ5RGVsYXlzIGFycmF5LlxuXG5cbiAgICAgICAgdmFyIGRlbGF5ID0gb3B0aW9ucy5yZXRyeURlbGF5c1swXTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0RlbGF5cyA9IG9wdGlvbnMucmV0cnlEZWxheXMuc2xpY2UoMSk7XG5cbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgcmV0cnlEZWxheXM6IHJlbWFpbmluZ0RlbGF5c1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBCYXNlVXBsb2FkLnRlcm1pbmF0ZSh1cmwsIG5ld09wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlVXBsb2FkO1xufSgpO1xuXG5mdW5jdGlvbiBlbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkge1xuICB2YXIgZW5jb2RlZCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBtZXRhZGF0YSkge1xuICAgIGVuY29kZWQucHVzaChrZXkgKyBcIiBcIiArIF9qc0Jhc2UuQmFzZTY0LmVuY29kZShtZXRhZGF0YVtrZXldKSk7XG4gIH1cblxuICByZXR1cm4gZW5jb2RlZC5qb2luKFwiLFwiKTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBnaXZlbiBzdGF0dXMgaXMgaW4gdGhlIHJhbmdlIG9mIHRoZSBleHBlY3RlZCBjYXRlZ29yeS5cbiAqIEZvciBleGFtcGxlLCBvbmx5IGEgc3RhdHVzIGJldHdlZW4gMjAwIGFuZCAyOTkgd2lsbCBzYXRpc2Z5IHRoZSBjYXRlZ29yeSAyMDAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBpblN0YXR1c0NhdGVnb3J5KHN0YXR1cywgY2F0ZWdvcnkpIHtcbiAgcmV0dXJuIHN0YXR1cyA+PSBjYXRlZ29yeSAmJiBzdGF0dXMgPCBjYXRlZ29yeSArIDEwMDtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEhUVFAgcmVxdWVzdCB3aXRoIHRoZSBzcGVjaWZpZWQgbWV0aG9kIGFuZCBVUkwuXG4gKiBUaGUgbmVjZXNzYXJ5IGhlYWRlcnMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gZXZlcnkgcmVxdWVzdFxuICogd2lsbCBiZSBhZGRlZCwgaW5jbHVkaW5nIHRoZSByZXF1ZXN0IElELlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gb3BlblJlcXVlc3QobWV0aG9kLCB1cmwsIG9wdGlvbnMpIHtcbiAgdmFyIHJlcSA9IG9wdGlvbnMuaHR0cFN0YWNrLmNyZWF0ZVJlcXVlc3QobWV0aG9kLCB1cmwpO1xuICByZXEuc2V0SGVhZGVyKFwiVHVzLVJlc3VtYWJsZVwiLCBcIjEuMC4wXCIpO1xuICB2YXIgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcblxuICBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHtcbiAgICByZXEuc2V0SGVhZGVyKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYWRkUmVxdWVzdElkKSB7XG4gICAgdmFyIHJlcXVlc3RJZCA9ICgwLCBfdXVpZC5kZWZhdWx0KSgpO1xuICAgIHJlcS5zZXRIZWFkZXIoXCJYLVJlcXVlc3QtSURcIiwgcmVxdWVzdElkKTtcbiAgfVxuXG4gIHJldHVybiByZXE7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBicm93c2VyIHJ1bm5pbmcgdGhpcyBjb2RlIGhhcyBpbnRlcm5ldCBhY2Nlc3MuXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIHJldHVybiB0cnVlIGluIHRoZSBub2RlLmpzIGVudmlyb25tZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBpc09ubGluZSgpIHtcbiAgdmFyIG9ubGluZSA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJuYXZpZ2F0b3JcIiBpbiB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvci5vbkxpbmUgPT09IGZhbHNlKSB7XG4gICAgb25saW5lID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gb25saW5lO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBvciBub3QgaXQgaXMgb2sgdG8gcmV0cnkgYSByZXF1ZXN0LlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIHRoZSBlcnJvciByZXR1cm5lZCBmcm9tIHRoZSBsYXN0IHJlcXVlc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXRyeUF0dGVtcHQgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgcmVxdWVzdCBoYXMgYWxyZWFkeSBiZWVuIHJldHJpZWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHR1cyBVcGxvYWQgb3B0aW9uc1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2hvdWxkUmV0cnkoZXJyLCByZXRyeUF0dGVtcHQsIG9wdGlvbnMpIHtcbiAgLy8gV2Ugb25seSBhdHRlbXB0IGEgcmV0cnkgaWZcbiAgLy8gLSByZXRyeURlbGF5cyBvcHRpb24gaXMgc2V0XG4gIC8vIC0gd2UgZGlkbid0IGV4Y2VlZCB0aGUgbWF4aXVtIG51bWJlciBvZiByZXRyaWVzLCB5ZXQsIGFuZFxuICAvLyAtIHRoaXMgZXJyb3Igd2FzIGNhdXNlZCBieSBhIHJlcXVlc3Qgb3IgaXQncyByZXNwb25zZSBhbmRcbiAgLy8gLSB0aGUgZXJyb3IgaXMgc2VydmVyIGVycm9yIChpLmUuIG5vIGEgc3RhdHVzIDR4eCBvciBhIDQwOSBvciA0MjMpIGFuZFxuICAvLyAtIHRoZSBicm93c2VyIGRvZXMgbm90IGluZGljYXRlIHRoYXQgd2UgYXJlIG9mZmxpbmVcbiAgdmFyIHN0YXR1cyA9IGVyci5vcmlnaW5hbFJlc3BvbnNlID8gZXJyLm9yaWdpbmFsUmVzcG9uc2UuZ2V0U3RhdHVzKCkgOiAwO1xuICB2YXIgaXNTZXJ2ZXJFcnJvciA9ICFpblN0YXR1c0NhdGVnb3J5KHN0YXR1cywgNDAwKSB8fCBzdGF0dXMgPT09IDQwOSB8fCBzdGF0dXMgPT09IDQyMztcbiAgcmV0dXJuIG9wdGlvbnMucmV0cnlEZWxheXMgIT0gbnVsbCAmJiByZXRyeUF0dGVtcHQgPCBvcHRpb25zLnJldHJ5RGVsYXlzLmxlbmd0aCAmJiBlcnIub3JpZ2luYWxSZXF1ZXN0ICE9IG51bGwgJiYgaXNTZXJ2ZXJFcnJvciAmJiBpc09ubGluZSgpO1xufVxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgbGluayBnaXZlbiB0aGUgb3JpZ2luIGFzIHNvdXJjZS4gRm9yIGV4YW1wbGUsXG4gKiBpZiBhIEhUVFAgcmVxdWVzdCB0byBodHRwOi8vZXhhbXBsZS5jb20vZmlsZXMvIHJldHVybnMgYSBMb2NhdGlvblxuICogaGVhZGVyIHdpdGggdGhlIHZhbHVlIC91cGxvYWQvYWJjLCB0aGUgcmVzb2x2ZWQgVVJMIHdpbGwgYmU6XG4gKiBodHRwOi8vZXhhbXBsZS5jb20vdXBsb2FkL2FiY1xuICovXG5cblxuZnVuY3Rpb24gcmVzb2x2ZVVybChvcmlnaW4sIGxpbmspIHtcbiAgcmV0dXJuIG5ldyBfdXJsUGFyc2UuZGVmYXVsdChsaW5rLCBvcmlnaW4pLnRvU3RyaW5nKCk7XG59XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgZm9yIHRoZSBwYXJ0cyBpZiBhbiB1cGxvYWRcbiAqIGlzIHNwbGl0IGludG8gbXVsdGlwbGUgcGFyYWxsZWwgcmVxdWVzdHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsU2l6ZSBUaGUgYnl0ZSBzaXplIG9mIHRoZSB1cGxvYWQsIHdoaWNoIHdpbGwgYmUgc3BsaXQuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFydENvdW50IFRoZSBudW1iZXIgaW4gaG93IG1hbnkgcGFydHMgdGhlIHVwbG9hZCB3aWxsIGJlIHNwbGl0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcHJldmlvdXNVcmxzIFRoZSB1cGxvYWQgVVJMcyBmb3IgcHJldmlvdXMgcGFydHMuXG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc3BsaXRTaXplSW50b1BhcnRzKHRvdGFsU2l6ZSwgcGFydENvdW50LCBwcmV2aW91c1VybHMpIHtcbiAgdmFyIHBhcnRTaXplID0gTWF0aC5mbG9vcih0b3RhbFNpemUgLyBwYXJ0Q291bnQpO1xuICB2YXIgcGFydHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRDb3VudDsgaSsrKSB7XG4gICAgcGFydHMucHVzaCh7XG4gICAgICBzdGFydDogcGFydFNpemUgKiBpLFxuICAgICAgZW5kOiBwYXJ0U2l6ZSAqIChpICsgMSlcbiAgICB9KTtcbiAgfVxuXG4gIHBhcnRzW3BhcnRDb3VudCAtIDFdLmVuZCA9IHRvdGFsU2l6ZTsgLy8gQXR0YWNoIFVSTHMgZnJvbSBwcmV2aW91cyB1cGxvYWRzLCBpZiBhdmFpbGFibGUuXG5cbiAgaWYgKHByZXZpb3VzVXJscykge1xuICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQsIGluZGV4KSB7XG4gICAgICBwYXJ0LnVwbG9hZFVybCA9IHByZXZpb3VzVXJsc1tpbmRleF0gfHwgbnVsbDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuQmFzZVVwbG9hZC5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xudmFyIF9kZWZhdWx0ID0gQmFzZVVwbG9hZDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdXVpZDtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIFVVSUQgdjQgYmFzZWQgb24gcmFuZG9tIG51bWJlcnMuIFdlIGludGVudGlvYW5sbHkgdXNlIHRoZSBsZXNzXG4gKiBzZWN1cmUgTWF0aC5yYW5kb20gZnVuY3Rpb24gaGVyZSBzaW5jZSB0aGUgbW9yZSBzZWN1cmUgY3J5cHRvLmdldFJhbmRvbU51bWJlcnNcbiAqIGlzIG5vdCBhdmFpbGFibGUgb24gYWxsIHBsYXRmb3Jtcy5cbiAqIFRoaXMgaXMgbm90IGEgcHJvYmxlbSBmb3IgdXMgc2luY2Ugd2UgdXNlIHRoZSBVVUlEIG9ubHkgZm9yIGdlbmVyYXRpbmcgYVxuICogcmVxdWVzdCBJRCwgc28gd2UgY2FuIGNvcnJlbGF0ZSBzZXJ2ZXIgbG9ncyB0byBjbGllbnQgZXJyb3JzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdGFrZW4gZnJvbSBmb2xsb3dpbmcgc2l0ZTpcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9jcmVhdGUtZ3VpZC11dWlkLWluLWphdmFzY3JpcHRcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBnZW5lcmF0ZSBVVUlEXG4gKi9cbmZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiBcInh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsXG4gICAgICAgIHYgPSBjID09IFwieFwiID8gciA6IHIgJiAweDMgfCAweDg7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOltcXFxcL10rL1xuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhbXFxcXC9dezEsfSk/KFtcXFNcXHNdKikvaVxuICAsIHdoaXRlc3BhY2UgPSAnW1xcXFx4MDlcXFxceDBBXFxcXHgwQlxcXFx4MENcXFxceDBEXFxcXHgyMFxcXFx4QTBcXFxcdTE2ODBcXFxcdTE4MEVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMEFcXFxcdTIwMkZcXFxcdTIwNUZcXFxcdTMwMDBcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdUZFRkZdJ1xuICAsIGxlZnQgPSBuZXcgUmVnRXhwKCdeJysgd2hpdGVzcGFjZSArJysnKTtcblxuLyoqXG4gKiBUcmltIGEgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHRyaW0uXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICByZXR1cm4gKHN0ciA/IHN0ciA6ICcnKS50b1N0cmluZygpLnJlcGxhY2UobGVmdCwgJycpO1xufVxuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBmdW5jdGlvbiBzYW5pdGl6ZShhZGRyZXNzKSB7ICAgICAgICAgIC8vIFNhbml0aXplIHdoYXQgaXMgbGVmdCBvZiB0aGUgYWRkcmVzc1xuICAgIHJldHVybiBhZGRyZXNzLnJlcGxhY2UoJ1xcXFwnLCAnLycpO1xuICB9LFxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvOihcXGQrKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cbiAgW05hTiwgJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCAxLCAxXSAgICAvLyBTZXQgbGVmdCBvdmVyLlxuXTtcblxuLyoqXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgY29waWVkIG9yIGluaGVyaXRlZCBmcm9tLiBUaGlzIGlzIG9ubHkgbmVlZGVkXG4gKiBmb3IgYWxsIG5vbiBibG9iIFVSTCdzIGFzIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXG4gKiBvcmlnaW4uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH07XG5cbi8qKlxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXG4gKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xuICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvYyBPcHRpb25hbCBkZWZhdWx0IGxvY2F0aW9uIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvbGNhdGlvbiBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcbiAgdmFyIGdsb2JhbFZhcjtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHdpbmRvdztcbiAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IGdsb2JhbDtcbiAgZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSBzZWxmO1xuICBlbHNlIGdsb2JhbFZhciA9IHt9O1xuXG4gIHZhciBsb2NhdGlvbiA9IGdsb2JhbFZhci5sb2NhdGlvbiB8fCB7fTtcbiAgbG9jID0gbG9jIHx8IGxvY2F0aW9uO1xuXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jXG4gICAgLCBrZXk7XG5cbiAgaWYgKCdibG9iOicgPT09IGxvYy5wcm90b2NvbCkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKGxvYywge30pO1xuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkge1xuICAgIGZvciAoa2V5IGluIGxvYykge1xuICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgICAgZmluYWxkZXN0aW5hdGlvbltrZXldID0gbG9jW2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPSBzbGFzaGVzLnRlc3QobG9jLmhyZWYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc3QgUmVzdCBvZiB0aGUgVVJMIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHByb3RvY29sLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBmcm9tLlxuICogQHJldHVybiB7UHJvdG9jb2xFeHRyYWN0fSBFeHRyYWN0ZWQgaW5mb3JtYXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2woYWRkcmVzcykge1xuICBhZGRyZXNzID0gdHJpbUxlZnQoYWRkcmVzcyk7XG5cbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpXG4gICAgLCBwcm90b2NvbCA9IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnXG4gICAgLCBzbGFzaGVzID0gISEobWF0Y2hbMl0gJiYgbWF0Y2hbMl0ubGVuZ3RoID49IDIpXG4gICAgLCByZXN0ID0gIG1hdGNoWzJdICYmIG1hdGNoWzJdLmxlbmd0aCA9PT0gMSA/ICcvJyArIG1hdGNoWzNdIDogbWF0Y2hbM107XG5cbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgc2xhc2hlczogc2xhc2hlcyxcbiAgICByZXN0OiByZXN0XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZSwgYmFzZSkge1xuICBpZiAocmVsYXRpdmUgPT09ICcnKSByZXR1cm4gYmFzZTtcblxuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXG4gICAgLCBpID0gcGF0aC5sZW5ndGhcbiAgICAsIGxhc3QgPSBwYXRoW2kgLSAxXVxuICAgICwgdW5zaGlmdCA9IGZhbHNlXG4gICAgLCB1cCA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwYXRoW2ldID09PSAnLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIGlmIChpID09PSAwKSB1bnNoaWZ0ID0gdHJ1ZTtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5zaGlmdCkgcGF0aC51bnNoaWZ0KCcnKTtcbiAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4oJy8nKTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIFVSTCBpbnN0YW5jZS4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gb2JqZWN0IHdlJ3ZlIG9wdGVkLWluIHRvXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gKiBmYXN0ZXIgYW5kIGl0IHBsZWFzZXMgbXkgT0NELlxuICpcbiAqIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHdlIHNob3VsZCBub3QgdXNlIGBVUkxgIGFzIGNsYXNzIG5hbWUgdG8gcHJldmVudFxuICogY2xhc2hlcyB3aXRoIHRoZSBnbG9iYWwgVVJMIGluc3RhbmNlIHRoYXQgZ290IGludHJvZHVjZWQgaW4gYnJvd3NlcnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW2xvY2F0aW9uXSBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IFtwYXJzZXJdIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVXJsKSkge1xuICAgIHJldHVybiBuZXcgVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJyk7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoIWV4dHJhY3RlZC5zbGFzaGVzKSBpbnN0cnVjdGlvbnNbM10gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWRkcmVzcyA9IGluc3RydWN0aW9uKGFkZHJlc3MpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcblxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgIGlmICh+KGluZGV4ID0gYWRkcmVzcy5pbmRleE9mKHBhcnNlKSkpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4LmluZGV4KTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFsc28gcGFyc2UgdGhlIHN1cHBsaWVkIHF1ZXJ5IHN0cmluZyBpbiB0byBhbiBvYmplY3QuIElmIHdlJ3JlIHN1cHBsaWVkXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgLy8gcGFyc2VyLlxuICAvL1xuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAvL1xuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cbiAgLy9cbiAgaWYgKFxuICAgICAgcmVsYXRpdmVcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXG4gICAgJiYgdXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxuICApIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXNvbHZlKHVybC5wYXRobmFtZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICB9XG5cbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBhIC8gZm9yIHBhdGhuYW1lIGlmIG5vbmUgZXhpc3RzLiBUaGlzIG5vcm1hbGl6ZXMgdGhlIFVSTFxuICAvLyB0byBhbHdheXMgaGF2ZSBhIC9cbiAgLy9cbiAgaWYgKHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJyAmJiB1cmwuaG9zdG5hbWUpIHtcbiAgICB1cmwucGF0aG5hbWUgPSAnLycgKyB1cmwucGF0aG5hbWU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VcmwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VcmwudHJpbUxlZnQgPSB0cmltTGVmdDtcblVybC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVybDtcbiIsIi8qIGpzaGludCBub2RlOiB0cnVlICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICAjIHdpbGRjYXJkXG5cbiAgVmVyeSBzaW1wbGUgd2lsZGNhcmQgbWF0Y2hpbmcsIHdoaWNoIGlzIGRlc2lnbmVkIHRvIHByb3ZpZGUgdGhlIHNhbWVcbiAgZnVuY3Rpb25hbGl0eSB0aGF0IGlzIGZvdW5kIGluIHRoZVxuICBbZXZlXShodHRwczovL2dpdGh1Yi5jb20vYWRvYmUtd2VicGxhdGZvcm0vZXZlKSBldmVudGluZyBsaWJyYXJ5LlxuXG4gICMjIFVzYWdlXG5cbiAgSXQgd29ya3Mgd2l0aCBzdHJpbmdzOlxuXG4gIDw8PCBleGFtcGxlcy9zdHJpbmdzLmpzXG5cbiAgQXJyYXlzOlxuXG4gIDw8PCBleGFtcGxlcy9hcnJheXMuanNcblxuICBPYmplY3RzIChtYXRjaGluZyBhZ2FpbnN0IGtleXMpOlxuXG4gIDw8PCBleGFtcGxlcy9vYmplY3RzLmpzXG5cbiAgV2hpbGUgdGhlIGxpYnJhcnkgd29ya3MgaW4gTm9kZSwgaWYgeW91IGFyZSBhcmUgbG9va2luZyBmb3IgZmlsZS1iYXNlZFxuICB3aWxkY2FyZCBtYXRjaGluZyB0aGVuIHlvdSBzaG91bGQgaGF2ZSBhIGxvb2sgYXQ6XG5cbiAgPGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iPlxuKiovXG5cbmZ1bmN0aW9uIFdpbGRjYXJkTWF0Y2hlcih0ZXh0LCBzZXBhcmF0b3IpIHtcbiAgdGhpcy50ZXh0ID0gdGV4dCA9IHRleHQgfHwgJyc7XG4gIHRoaXMuaGFzV2lsZCA9IH50ZXh0LmluZGV4T2YoJyonKTtcbiAgdGhpcy5zZXBhcmF0b3IgPSBzZXBhcmF0b3I7XG4gIHRoaXMucGFydHMgPSB0ZXh0LnNwbGl0KHNlcGFyYXRvcik7XG59XG5cbldpbGRjYXJkTWF0Y2hlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgbWF0Y2hlcyA9IHRydWU7XG4gIHZhciBwYXJ0cyA9IHRoaXMucGFydHM7XG4gIHZhciBpaTtcbiAgdmFyIHBhcnRzQ291bnQgPSBwYXJ0cy5sZW5ndGg7XG4gIHZhciB0ZXN0UGFydHM7XG5cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIGlmICghdGhpcy5oYXNXaWxkICYmIHRoaXMudGV4dCAhPSBpbnB1dCkge1xuICAgICAgbWF0Y2hlcyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXN0UGFydHMgPSAoaW5wdXQgfHwgJycpLnNwbGl0KHRoaXMuc2VwYXJhdG9yKTtcbiAgICAgIGZvciAoaWkgPSAwOyBtYXRjaGVzICYmIGlpIDwgcGFydHNDb3VudDsgaWkrKykge1xuICAgICAgICBpZiAocGFydHNbaWldID09PSAnKicpICB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaWkgPCB0ZXN0UGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IHBhcnRzW2lpXSA9PT0gdGVzdFBhcnRzW2lpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaGVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgbWF0Y2hlcywgdGhlbiByZXR1cm4gdGhlIGNvbXBvbmVudCBwYXJ0c1xuICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMgJiYgdGVzdFBhcnRzO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgaW5wdXQuc3BsaWNlID09ICdmdW5jdGlvbicpIHtcbiAgICBtYXRjaGVzID0gW107XG5cbiAgICBmb3IgKGlpID0gaW5wdXQubGVuZ3RoOyBpaS0tOyApIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKGlucHV0W2lpXSkpIHtcbiAgICAgICAgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aF0gPSBpbnB1dFtpaV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PSAnb2JqZWN0Jykge1xuICAgIG1hdGNoZXMgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goa2V5KSkge1xuICAgICAgICBtYXRjaGVzW2tleV0gPSBpbnB1dFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0ZXh0LCB0ZXN0LCBzZXBhcmF0b3IpIHtcbiAgdmFyIG1hdGNoZXIgPSBuZXcgV2lsZGNhcmRNYXRjaGVyKHRleHQsIHNlcGFyYXRvciB8fCAvW1xcL1xcLl0vKTtcbiAgaWYgKHR5cGVvZiB0ZXN0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG1hdGNoZXIubWF0Y2godGVzdCk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJy5zcGxpdCgnJylcbiAgLCBsZW5ndGggPSA2NFxuICAsIG1hcCA9IHt9XG4gICwgc2VlZCA9IDBcbiAgLCBpID0gMFxuICAsIHByZXY7XG5cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShudW0pIHtcbiAgdmFyIGVuY29kZWQgPSAnJztcblxuICBkbyB7XG4gICAgZW5jb2RlZCA9IGFscGhhYmV0W251bSAlIGxlbmd0aF0gKyBlbmNvZGVkO1xuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcbiAgfSB3aGlsZSAobnVtID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdmFyIGRlY29kZWQgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBkZWNvZGVkID0gZGVjb2RlZCAqIGxlbmd0aCArIG1hcFtzdHIuY2hhckF0KGkpXTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVkO1xufVxuXG4vKipcbiAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB5ZWFzdCgpIHtcbiAgdmFyIG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG5cbiAgaWYgKG5vdyAhPT0gcHJldikgcmV0dXJuIHNlZWQgPSAwLCBwcmV2ID0gbm93O1xuICByZXR1cm4gbm93ICsnLicrIGVuY29kZShzZWVkKyspO1xufVxuXG4vL1xuLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbi8vXG5mb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgYHllYXN0YCwgYGVuY29kZWAgYW5kIGBkZWNvZGVgIGZ1bmN0aW9ucy5cbi8vXG55ZWFzdC5lbmNvZGUgPSBlbmNvZGU7XG55ZWFzdC5kZWNvZGUgPSBkZWNvZGU7XG5tb2R1bGUuZXhwb3J0cyA9IHllYXN0O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJDbGllbnQgbGlicmFyeSBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIENvbXBhbmlvbi4gSW50ZW5kZWQgZm9yIHVzZSBpbiBVcHB5IHBsdWdpbnMuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuMTAuMlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcImNvbXBhbmlvblwiLFxuICAgIFwicHJvdmlkZXJcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwibmFtZXNwYWNlLWVtaXR0ZXJcIjogXCJeMi4wLjFcIixcbiAgICBcInFzLXN0cmluZ2lmeVwiOiBcIl4xLjEuMFwiLFxuICAgIFwidXJsLXBhcnNlXCI6IFwiXjEuNC43XCJcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIEF1dGhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKCdBdXRob3JpemF0aW9uIHJlcXVpcmVkJylcbiAgICB0aGlzLm5hbWUgPSAnQXV0aEVycm9yJ1xuICAgIHRoaXMuaXNBdXRoRXJyb3IgPSB0cnVlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBdXRoRXJyb3JcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBxc1N0cmluZ2lmeSA9IHJlcXVpcmUoJ3FzLXN0cmluZ2lmeScpXG5jb25zdCBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxuY29uc3QgUmVxdWVzdENsaWVudCA9IHJlcXVpcmUoJy4vUmVxdWVzdENsaWVudCcpXG5jb25zdCB0b2tlblN0b3JhZ2UgPSByZXF1aXJlKCcuL3Rva2VuU3RvcmFnZScpXG5cbmNvbnN0IF9nZXROYW1lID0gKGlkKSA9PiB7XG4gIHJldHVybiBpZC5zcGxpdCgnLScpLm1hcCgocykgPT4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSkpLmpvaW4oJyAnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFByb3ZpZGVyIGV4dGVuZHMgUmVxdWVzdENsaWVudCB7XG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0cy5wcm92aWRlclxuICAgIHRoaXMuaWQgPSB0aGlzLnByb3ZpZGVyXG4gICAgdGhpcy5uYW1lID0gdGhpcy5vcHRzLm5hbWUgfHwgX2dldE5hbWUodGhpcy5pZClcbiAgICB0aGlzLnBsdWdpbklkID0gdGhpcy5vcHRzLnBsdWdpbklkXG4gICAgdGhpcy50b2tlbktleSA9IGBjb21wYW5pb24tJHt0aGlzLnBsdWdpbklkfS1hdXRoLXRva2VuYFxuICAgIHRoaXMuY29tcGFuaW9uS2V5c1BhcmFtcyA9IHRoaXMub3B0cy5jb21wYW5pb25LZXlzUGFyYW1zXG4gICAgdGhpcy5wcmVBdXRoVG9rZW4gPSBudWxsXG4gIH1cblxuICBoZWFkZXJzICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3N1cGVyLmhlYWRlcnMoKSwgdGhpcy5nZXRBdXRoVG9rZW4oKV0pXG4gICAgICAudGhlbigoW2hlYWRlcnMsIHRva2VuXSkgPT4ge1xuICAgICAgICBjb25zdCBhdXRoSGVhZGVycyA9IHt9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIGF1dGhIZWFkZXJzWyd1cHB5LWF1dGgtdG9rZW4nXSA9IHRva2VuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb21wYW5pb25LZXlzUGFyYW1zKSB7XG4gICAgICAgICAgYXV0aEhlYWRlcnNbJ3VwcHktY3JlZGVudGlhbHMtcGFyYW1zJ10gPSBidG9hKFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyBwYXJhbXM6IHRoaXMuY29tcGFuaW9uS2V5c1BhcmFtcyB9KVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAuLi5oZWFkZXJzLCAuLi5hdXRoSGVhZGVycyB9XG4gICAgICB9KVxuICB9XG5cbiAgb25SZWNlaXZlUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgcmVzcG9uc2UgPSBzdXBlci5vblJlY2VpdmVSZXNwb25zZShyZXNwb25zZSlcbiAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMucGx1Z2luSWQpXG4gICAgY29uc3Qgb2xkQXV0aGVudGljYXRlZCA9IHBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpLmF1dGhlbnRpY2F0ZWRcbiAgICBjb25zdCBhdXRoZW50aWNhdGVkID0gb2xkQXV0aGVudGljYXRlZCA/IHJlc3BvbnNlLnN0YXR1cyAhPT0gNDAxIDogcmVzcG9uc2Uuc3RhdHVzIDwgNDAwXG4gICAgcGx1Z2luLnNldFBsdWdpblN0YXRlKHsgYXV0aGVudGljYXRlZCB9KVxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLy8gQHRvZG8oaS5vbGFyZXdhanUpIGNvbnNpZGVyIHdoZXRoZXIgb3Igbm90IHRoaXMgbWV0aG9kIHNob3VsZCBiZSBleHBvc2VkXG4gIHNldEF1dGhUb2tlbiAodG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy51cHB5LmdldFBsdWdpbih0aGlzLnBsdWdpbklkKS5zdG9yYWdlLnNldEl0ZW0odGhpcy50b2tlbktleSwgdG9rZW4pXG4gIH1cblxuICBnZXRBdXRoVG9rZW4gKCkge1xuICAgIHJldHVybiB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMucGx1Z2luSWQpLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnRva2VuS2V5KVxuICB9XG5cbiAgYXV0aFVybCAocXVlcmllcyA9IHt9KSB7XG4gICAgaWYgKHRoaXMucHJlQXV0aFRva2VuKSB7XG4gICAgICBxdWVyaWVzLnVwcHlQcmVBdXRoVG9rZW4gPSB0aGlzLnByZUF1dGhUb2tlblxuICAgIH1cblxuICAgIGxldCBzdHJpZ2lmaWVkUXVlcmllcyA9IHFzU3RyaW5naWZ5KHF1ZXJpZXMpXG4gICAgc3RyaWdpZmllZFF1ZXJpZXMgPSBzdHJpZ2lmaWVkUXVlcmllcyA/IGA/JHtzdHJpZ2lmaWVkUXVlcmllc31gIDogc3RyaWdpZmllZFF1ZXJpZXNcbiAgICByZXR1cm4gYCR7dGhpcy5ob3N0bmFtZX0vJHt0aGlzLmlkfS9jb25uZWN0JHtzdHJpZ2lmaWVkUXVlcmllc31gXG4gIH1cblxuICBmaWxlVXJsIChpZCkge1xuICAgIHJldHVybiBgJHt0aGlzLmhvc3RuYW1lfS8ke3RoaXMuaWR9L2dldC8ke2lkfWBcbiAgfVxuXG4gIGZldGNoUHJlQXV0aFRva2VuICgpIHtcbiAgICBpZiAoIXRoaXMuY29tcGFuaW9uS2V5c1BhcmFtcykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucG9zdChgJHt0aGlzLmlkfS9wcmVhdXRoL2AsIHsgcGFyYW1zOiB0aGlzLmNvbXBhbmlvbktleXNQYXJhbXMgfSlcbiAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgdGhpcy5wcmVBdXRoVG9rZW4gPSByZXMudG9rZW5cbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LmxvZyhgW0NvbXBhbmlvbkNsaWVudF0gdW5hYmxlIHRvIGZldGNoIHByZUF1dGhUb2tlbiAke2Vycn1gLCAnd2FybmluZycpXG4gICAgICB9KVxuICB9XG5cbiAgbGlzdCAoZGlyZWN0b3J5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAke3RoaXMuaWR9L2xpc3QvJHtkaXJlY3RvcnkgfHwgJyd9YClcbiAgfVxuXG4gIGxvZ291dCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAke3RoaXMuaWR9L2xvZ291dGApXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IFByb21pc2UuYWxsKFtcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHRoaXMudXBweS5nZXRQbHVnaW4odGhpcy5wbHVnaW5JZCkuc3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMudG9rZW5LZXkpLFxuICAgICAgXSkpLnRoZW4oKFtyZXNwb25zZV0pID0+IHJlc3BvbnNlKVxuICB9XG5cbiAgc3RhdGljIGluaXRQbHVnaW4gKHBsdWdpbiwgb3B0cywgZGVmYXVsdE9wdHMpIHtcbiAgICBwbHVnaW4udHlwZSA9ICdhY3F1aXJlcidcbiAgICBwbHVnaW4uZmlsZXMgPSBbXVxuICAgIGlmIChkZWZhdWx0T3B0cykge1xuICAgICAgcGx1Z2luLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRzLCAuLi5vcHRzIH1cbiAgICB9XG5cbiAgICBpZiAob3B0cy5zZXJ2ZXJVcmwgfHwgb3B0cy5zZXJ2ZXJQYXR0ZXJuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BzZXJ2ZXJVcmxgIGFuZCBgc2VydmVyUGF0dGVybmAgaGF2ZSBiZWVuIHJlbmFtZWQgdG8gYGNvbXBhbmlvblVybGAgYW5kIGBjb21wYW5pb25BbGxvd2VkSG9zdHNgIHJlc3BlY3RpdmVseSBpbiB0aGUgMC4zMC41IHJlbGVhc2UuIFBsZWFzZSBjb25zdWx0IHRoZSBkb2NzIChmb3IgZXhhbXBsZSwgaHR0cHM6Ly91cHB5LmlvL2RvY3MvaW5zdGFncmFtLyBmb3IgdGhlIEluc3RhZ3JhbSBwbHVnaW4pIGFuZCB1c2UgdGhlIHVwZGF0ZWQgb3B0aW9ucy5gJylcbiAgICB9XG5cbiAgICBpZiAob3B0cy5jb21wYW5pb25BbGxvd2VkSG9zdHMpIHtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBvcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0c1xuICAgICAgLy8gdmFsaWRhdGUgY29tcGFuaW9uQWxsb3dlZEhvc3RzIHBhcmFtXG4gICAgICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KHBhdHRlcm4pICYmICEocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtwbHVnaW4uaWR9OiB0aGUgb3B0aW9uIFwiY29tcGFuaW9uQWxsb3dlZEhvc3RzXCIgbXVzdCBiZSBvbmUgb2Ygc3RyaW5nLCBBcnJheSwgUmVnRXhwYClcbiAgICAgIH1cbiAgICAgIHBsdWdpbi5vcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0cyA9IHBhdHRlcm5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG9lcyBub3Qgc3RhcnQgd2l0aCBodHRwczovL1xuICAgICAgaWYgKC9eKD8haHR0cHM/OlxcL1xcLykuKiQvaS50ZXN0KG9wdHMuY29tcGFuaW9uVXJsKSkge1xuICAgICAgICBwbHVnaW4ub3B0cy5jb21wYW5pb25BbGxvd2VkSG9zdHMgPSBgaHR0cHM6Ly8ke29wdHMuY29tcGFuaW9uVXJsLnJlcGxhY2UoL15cXC9cXC8vLCAnJyl9YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGx1Z2luLm9wdHMuY29tcGFuaW9uQWxsb3dlZEhvc3RzID0gbmV3IFVSTChvcHRzLmNvbXBhbmlvblVybCkub3JpZ2luXG4gICAgICB9XG4gICAgfVxuXG4gICAgcGx1Z2luLnN0b3JhZ2UgPSBwbHVnaW4ub3B0cy5zdG9yYWdlIHx8IHRva2VuU3RvcmFnZVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQXV0aEVycm9yID0gcmVxdWlyZSgnLi9BdXRoRXJyb3InKVxuY29uc3QgZmV0Y2hXaXRoTmV0d29ya0Vycm9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2ZldGNoV2l0aE5ldHdvcmtFcnJvcicpXG5cbi8vIFJlbW92ZSB0aGUgdHJhaWxpbmcgc2xhc2ggc28gd2UgY2FuIGFsd2F5cyBzYWZlbHkgYXBwZW5kIC94eXouXG5mdW5jdGlvbiBzdHJpcFNsYXNoICh1cmwpIHtcbiAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmVxdWVzdENsaWVudCB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgdGhpcy51cHB5ID0gdXBweVxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLm9uUmVjZWl2ZVJlc3BvbnNlID0gdGhpcy5vblJlY2VpdmVSZXNwb25zZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5hbGxvd2VkSGVhZGVycyA9IFsnYWNjZXB0JywgJ2NvbnRlbnQtdHlwZScsICd1cHB5LWF1dGgtdG9rZW4nXVxuICAgIHRoaXMucHJlZmxpZ2h0RG9uZSA9IGZhbHNlXG4gIH1cblxuICBnZXQgaG9zdG5hbWUgKCkge1xuICAgIGNvbnN0IHsgY29tcGFuaW9uIH0gPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IGhvc3QgPSB0aGlzLm9wdHMuY29tcGFuaW9uVXJsXG4gICAgcmV0dXJuIHN0cmlwU2xhc2goY29tcGFuaW9uICYmIGNvbXBhbmlvbltob3N0XSA/IGNvbXBhbmlvbltob3N0XSA6IGhvc3QpXG4gIH1cblxuICBnZXQgZGVmYXVsdEhlYWRlcnMgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnVXBweS1WZXJzaW9ucyc6IGBAdXBweS9jb21wYW5pb24tY2xpZW50PSR7UmVxdWVzdENsaWVudC5WRVJTSU9OfWAsXG4gICAgfVxuICB9XG5cbiAgaGVhZGVycyAoKSB7XG4gICAgY29uc3QgdXNlckhlYWRlcnMgPSB0aGlzLm9wdHMuY29tcGFuaW9uSGVhZGVycyB8fCB0aGlzLm9wdHMuc2VydmVySGVhZGVycyB8fCB7fVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgLi4udGhpcy5kZWZhdWx0SGVhZGVycyxcbiAgICAgIC4uLnVzZXJIZWFkZXJzLFxuICAgIH0pXG4gIH1cblxuICBfZ2V0UG9zdFJlc3BvbnNlRnVuYyAoc2tpcCkge1xuICAgIHJldHVybiAocmVzcG9uc2UpID0+IHtcbiAgICAgIGlmICghc2tpcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vblJlY2VpdmVSZXNwb25zZShyZXNwb25zZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfVxuICB9XG5cbiAgb25SZWNlaXZlUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IGNvbXBhbmlvbiA9IHN0YXRlLmNvbXBhbmlvbiB8fCB7fVxuICAgIGNvbnN0IGhvc3QgPSB0aGlzLm9wdHMuY29tcGFuaW9uVXJsXG4gICAgY29uc3QgaGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAvLyBTdG9yZSB0aGUgc2VsZi1pZGVudGlmaWVkIGRvbWFpbiBuYW1lIGZvciB0aGUgQ29tcGFuaW9uIGluc3RhbmNlIHdlIGp1c3QgaGl0LlxuICAgIGlmIChoZWFkZXJzLmhhcygnaS1hbScpICYmIGhlYWRlcnMuZ2V0KCdpLWFtJykgIT09IGNvbXBhbmlvbltob3N0XSkge1xuICAgICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgICAgY29tcGFuaW9uOiB7IC4uLmNvbXBhbmlvbiwgW2hvc3RdOiBoZWFkZXJzLmdldCgnaS1hbScpIH0sXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIF9nZXRVcmwgKHVybCkge1xuICAgIGlmICgvXihodHRwcz86fClcXC9cXC8vLnRlc3QodXJsKSkge1xuICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgICByZXR1cm4gYCR7dGhpcy5ob3N0bmFtZX0vJHt1cmx9YFxuICB9XG5cbiAgX2pzb24gKHJlcykge1xuICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgIHRocm93IG5ldyBBdXRoRXJyb3IoKVxuICAgIH1cblxuICAgIGlmIChyZXMuc3RhdHVzIDwgMjAwIHx8IHJlcy5zdGF0dXMgPiAzMDApIHtcbiAgICAgIGxldCBlcnJNc2cgPSBgRmFpbGVkIHJlcXVlc3Qgd2l0aCBzdGF0dXM6ICR7cmVzLnN0YXR1c30uICR7cmVzLnN0YXR1c1RleHR9YFxuICAgICAgcmV0dXJuIHJlcy5qc29uKClcbiAgICAgICAgLnRoZW4oKGVyckRhdGEpID0+IHtcbiAgICAgICAgICBlcnJNc2cgPSBlcnJEYXRhLm1lc3NhZ2UgPyBgJHtlcnJNc2d9IG1lc3NhZ2U6ICR7ZXJyRGF0YS5tZXNzYWdlfWAgOiBlcnJNc2dcbiAgICAgICAgICBlcnJNc2cgPSBlcnJEYXRhLnJlcXVlc3RJZCA/IGAke2Vyck1zZ30gcmVxdWVzdC1JZDogJHtlcnJEYXRhLnJlcXVlc3RJZH1gIDogZXJyTXNnXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZylcbiAgICAgICAgfSkuY2F0Y2goKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKSB9KVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpzb24oKVxuICB9XG5cbiAgcHJlZmxpZ2h0IChwYXRoKSB7XG4gICAgaWYgKHRoaXMucHJlZmxpZ2h0RG9uZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFsbG93ZWRIZWFkZXJzLnNsaWNlKCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZldGNoKHRoaXMuX2dldFVybChwYXRoKSwge1xuICAgICAgbWV0aG9kOiAnT1BUSU9OUycsXG4gICAgfSlcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVycy5oYXMoJ2FjY2Vzcy1jb250cm9sLWFsbG93LWhlYWRlcnMnKSkge1xuICAgICAgICAgIHRoaXMuYWxsb3dlZEhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnYWNjZXNzLWNvbnRyb2wtYWxsb3ctaGVhZGVycycpXG4gICAgICAgICAgICAuc3BsaXQoJywnKS5tYXAoKGhlYWRlck5hbWUpID0+IGhlYWRlck5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVmbGlnaHREb25lID0gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcy5hbGxvd2VkSGVhZGVycy5zbGljZSgpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LmxvZyhgW0NvbXBhbmlvbkNsaWVudF0gdW5hYmxlIHRvIG1ha2UgcHJlZmxpZ2h0IHJlcXVlc3QgJHtlcnJ9YCwgJ3dhcm5pbmcnKVxuICAgICAgICB0aGlzLnByZWZsaWdodERvbmUgPSB0cnVlXG4gICAgICAgIHJldHVybiB0aGlzLmFsbG93ZWRIZWFkZXJzLnNsaWNlKClcbiAgICAgIH0pXG4gIH1cblxuICBwcmVmbGlnaHRBbmRIZWFkZXJzIChwYXRoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFt0aGlzLnByZWZsaWdodChwYXRoKSwgdGhpcy5oZWFkZXJzKCldKVxuICAgICAgLnRoZW4oKFthbGxvd2VkSGVhZGVycywgaGVhZGVyc10pID0+IHtcbiAgICAgICAgLy8gZmlsdGVyIHRvIGtlZXAgb25seSBhbGxvd2VkIEhlYWRlcnNcbiAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaCgoaGVhZGVyKSA9PiB7XG4gICAgICAgICAgaWYgKGFsbG93ZWRIZWFkZXJzLmluZGV4T2YoaGVhZGVyLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy51cHB5LmxvZyhgW0NvbXBhbmlvbkNsaWVudF0gZXhjbHVkaW5nIHVuYWxsb3dlZCBoZWFkZXIgJHtoZWFkZXJ9YClcbiAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzW2hlYWRlcl1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIGhlYWRlcnNcbiAgICAgIH0pXG4gIH1cblxuICBnZXQgKHBhdGgsIHNraXBQb3N0UmVzcG9uc2UpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVmbGlnaHRBbmRIZWFkZXJzKHBhdGgpXG4gICAgICAudGhlbigoaGVhZGVycykgPT5cbiAgICAgICAgZmV0Y2hXaXRoTmV0d29ya0Vycm9yKHRoaXMuX2dldFVybChwYXRoKSwge1xuICAgICAgICAgIG1ldGhvZDogJ2dldCcsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBjcmVkZW50aWFsczogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlIHx8ICdzYW1lLW9yaWdpbicsXG4gICAgICAgIH0pKVxuICAgICAgLnRoZW4odGhpcy5fZ2V0UG9zdFJlc3BvbnNlRnVuYyhza2lwUG9zdFJlc3BvbnNlKSlcbiAgICAgIC50aGVuKChyZXMpID0+IHRoaXMuX2pzb24ocmVzKSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGlmICghZXJyLmlzQXV0aEVycm9yKSB7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgQ291bGQgbm90IGdldCAke3RoaXMuX2dldFVybChwYXRoKX0uICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXG4gICAgICB9KVxuICB9XG5cbiAgcG9zdCAocGF0aCwgZGF0YSwgc2tpcFBvc3RSZXNwb25zZSkge1xuICAgIHJldHVybiB0aGlzLnByZWZsaWdodEFuZEhlYWRlcnMocGF0aClcbiAgICAgIC50aGVuKChoZWFkZXJzKSA9PlxuICAgICAgICBmZXRjaFdpdGhOZXR3b3JrRXJyb3IodGhpcy5fZ2V0VXJsKHBhdGgpLCB7XG4gICAgICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBjcmVkZW50aWFsczogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlIHx8ICdzYW1lLW9yaWdpbicsXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgIH0pKVxuICAgICAgLnRoZW4odGhpcy5fZ2V0UG9zdFJlc3BvbnNlRnVuYyhza2lwUG9zdFJlc3BvbnNlKSlcbiAgICAgIC50aGVuKChyZXMpID0+IHRoaXMuX2pzb24ocmVzKSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGlmICghZXJyLmlzQXV0aEVycm9yKSB7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgQ291bGQgbm90IHBvc3QgJHt0aGlzLl9nZXRVcmwocGF0aCl9LiAke2Vyci5tZXNzYWdlfWBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgICAgfSlcbiAgfVxuXG4gIGRlbGV0ZSAocGF0aCwgZGF0YSwgc2tpcFBvc3RSZXNwb25zZSkge1xuICAgIHJldHVybiB0aGlzLnByZWZsaWdodEFuZEhlYWRlcnMocGF0aClcbiAgICAgIC50aGVuKChoZWFkZXJzKSA9PlxuICAgICAgICBmZXRjaFdpdGhOZXR3b3JrRXJyb3IoYCR7dGhpcy5ob3N0bmFtZX0vJHtwYXRofWAsIHtcbiAgICAgICAgICBtZXRob2Q6ICdkZWxldGUnLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgY3JlZGVudGlhbHM6IHRoaXMub3B0cy5jb21wYW5pb25Db29raWVzUnVsZSB8fCAnc2FtZS1vcmlnaW4nLFxuICAgICAgICAgIGJvZHk6IGRhdGEgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IG51bGwsXG4gICAgICAgIH0pKVxuICAgICAgLnRoZW4odGhpcy5fZ2V0UG9zdFJlc3BvbnNlRnVuYyhza2lwUG9zdFJlc3BvbnNlKSlcbiAgICAgIC50aGVuKChyZXMpID0+IHRoaXMuX2pzb24ocmVzKSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGlmICghZXJyLmlzQXV0aEVycm9yKSB7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgQ291bGQgbm90IGRlbGV0ZSAke3RoaXMuX2dldFVybChwYXRoKX0uICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXG4gICAgICB9KVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgUmVxdWVzdENsaWVudCA9IHJlcXVpcmUoJy4vUmVxdWVzdENsaWVudCcpXG5cbmNvbnN0IF9nZXROYW1lID0gKGlkKSA9PiB7XG4gIHJldHVybiBpZC5zcGxpdCgnLScpLm1hcCgocykgPT4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSkpLmpvaW4oJyAnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNlYXJjaFByb3ZpZGVyIGV4dGVuZHMgUmVxdWVzdENsaWVudCB7XG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0cy5wcm92aWRlclxuICAgIHRoaXMuaWQgPSB0aGlzLnByb3ZpZGVyXG4gICAgdGhpcy5uYW1lID0gdGhpcy5vcHRzLm5hbWUgfHwgX2dldE5hbWUodGhpcy5pZClcbiAgICB0aGlzLnBsdWdpbklkID0gdGhpcy5vcHRzLnBsdWdpbklkXG4gIH1cblxuICBmaWxlVXJsIChpZCkge1xuICAgIHJldHVybiBgJHt0aGlzLmhvc3RuYW1lfS9zZWFyY2gvJHt0aGlzLmlkfS9nZXQvJHtpZH1gXG4gIH1cblxuICBzZWFyY2ggKHRleHQsIHF1ZXJpZXMpIHtcbiAgICBxdWVyaWVzID0gcXVlcmllcyA/IGAmJHtxdWVyaWVzfWAgOiAnJ1xuICAgIHJldHVybiB0aGlzLmdldChgc2VhcmNoLyR7dGhpcy5pZH0vbGlzdD9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRleHQpfSR7cXVlcmllc31gKVxuICB9XG59XG4iLCJjb25zdCBlZSA9IHJlcXVpcmUoJ25hbWVzcGFjZS1lbWl0dGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBVcHB5U29ja2V0IHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gICAgdGhpcy5fcXVldWVkID0gW11cbiAgICB0aGlzLmlzT3BlbiA9IGZhbHNlXG4gICAgdGhpcy5lbWl0dGVyID0gZWUoKVxuXG4gICAgdGhpcy5faGFuZGxlTWVzc2FnZSA9IHRoaXMuX2hhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKVxuICAgIHRoaXMuZW1pdCA9IHRoaXMuZW1pdC5iaW5kKHRoaXMpXG4gICAgdGhpcy5vbiA9IHRoaXMub24uYmluZCh0aGlzKVxuICAgIHRoaXMub25jZSA9IHRoaXMub25jZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5zZW5kID0gdGhpcy5zZW5kLmJpbmQodGhpcylcblxuICAgIGlmICghb3B0cyB8fCBvcHRzLmF1dG9PcGVuICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5vcGVuKClcbiAgICB9XG4gIH1cblxuICBvcGVuICgpIHtcbiAgICB0aGlzLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodGhpcy5vcHRzLnRhcmdldClcblxuICAgIHRoaXMuc29ja2V0Lm9ub3BlbiA9IChlKSA9PiB7XG4gICAgICB0aGlzLmlzT3BlbiA9IHRydWVcblxuICAgICAgd2hpbGUgKHRoaXMuX3F1ZXVlZC5sZW5ndGggPiAwICYmIHRoaXMuaXNPcGVuKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5fcXVldWVkWzBdXG4gICAgICAgIHRoaXMuc2VuZChmaXJzdC5hY3Rpb24sIGZpcnN0LnBheWxvYWQpXG4gICAgICAgIHRoaXMuX3F1ZXVlZCA9IHRoaXMuX3F1ZXVlZC5zbGljZSgxKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSAoZSkgPT4ge1xuICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IHRoaXMuX2hhbmRsZU1lc3NhZ2VcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgIHRoaXMuc29ja2V0LmNsb3NlKClcbiAgICB9XG4gIH1cblxuICBzZW5kIChhY3Rpb24sIHBheWxvYWQpIHtcbiAgICAvLyBhdHRhY2ggdXVpZFxuXG4gICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgdGhpcy5fcXVldWVkLnB1c2goeyBhY3Rpb24sIHBheWxvYWQgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgYWN0aW9uLFxuICAgICAgcGF5bG9hZCxcbiAgICB9KSlcbiAgfVxuXG4gIG9uIChhY3Rpb24sIGhhbmRsZXIpIHtcbiAgICB0aGlzLmVtaXR0ZXIub24oYWN0aW9uLCBoYW5kbGVyKVxuICB9XG5cbiAgZW1pdCAoYWN0aW9uLCBwYXlsb2FkKSB7XG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoYWN0aW9uLCBwYXlsb2FkKVxuICB9XG5cbiAgb25jZSAoYWN0aW9uLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9uY2UoYWN0aW9uLCBoYW5kbGVyKVxuICB9XG5cbiAgX2hhbmRsZU1lc3NhZ2UgKGUpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZS5kYXRhKVxuICAgICAgdGhpcy5lbWl0KG1lc3NhZ2UuYWN0aW9uLCBtZXNzYWdlLnBheWxvYWQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnIpXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNYW5hZ2VzIGNvbW11bmljYXRpb25zIHdpdGggQ29tcGFuaW9uXG4gKi9cblxuY29uc3QgUmVxdWVzdENsaWVudCA9IHJlcXVpcmUoJy4vUmVxdWVzdENsaWVudCcpXG5jb25zdCBQcm92aWRlciA9IHJlcXVpcmUoJy4vUHJvdmlkZXInKVxuY29uc3QgU2VhcmNoUHJvdmlkZXIgPSByZXF1aXJlKCcuL1NlYXJjaFByb3ZpZGVyJylcbmNvbnN0IFNvY2tldCA9IHJlcXVpcmUoJy4vU29ja2V0JylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlcXVlc3RDbGllbnQsXG4gIFByb3ZpZGVyLFxuICBTZWFyY2hQcm92aWRlcixcbiAgU29ja2V0LFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogVGhpcyBtb2R1bGUgc2VydmVzIGFzIGFuIEFzeW5jIHdyYXBwZXIgZm9yIExvY2FsU3RvcmFnZVxuICovXG5tb2R1bGUuZXhwb3J0cy5zZXRJdGVtID0gKGtleSwgdmFsdWUpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSlcbiAgICByZXNvbHZlKClcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMuZ2V0SXRlbSA9IChrZXkpID0+IHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5yZW1vdmVJdGVtID0gKGtleSkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG4gICAgcmVzb2x2ZSgpXG4gIH0pXG59XG4iLCIhZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGZ1bmN0aW9uIFZOb2RlKCkge31cbiAgICBmdW5jdGlvbiBoKG5vZGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBsYXN0U2ltcGxlLCBjaGlsZCwgc2ltcGxlLCBpLCBjaGlsZHJlbiA9IEVNUFRZX0NISUxEUkVOO1xuICAgICAgICBmb3IgKGkgPSBhcmd1bWVudHMubGVuZ3RoOyBpLS0gPiAyOyApIHN0YWNrLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMgJiYgbnVsbCAhPSBhdHRyaWJ1dGVzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCkgc3RhY2sucHVzaChhdHRyaWJ1dGVzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIGlmICgoY2hpbGQgPSBzdGFjay5wb3AoKSkgJiYgdm9pZCAwICE9PSBjaGlsZC5wb3ApIGZvciAoaSA9IGNoaWxkLmxlbmd0aDsgaS0tOyApIHN0YWNrLnB1c2goY2hpbGRbaV0pOyBlbHNlIHtcbiAgICAgICAgICAgIGlmICgnYm9vbGVhbicgPT0gdHlwZW9mIGNoaWxkKSBjaGlsZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoc2ltcGxlID0gJ2Z1bmN0aW9uJyAhPSB0eXBlb2Ygbm9kZU5hbWUpIGlmIChudWxsID09IGNoaWxkKSBjaGlsZCA9ICcnOyBlbHNlIGlmICgnbnVtYmVyJyA9PSB0eXBlb2YgY2hpbGQpIGNoaWxkID0gU3RyaW5nKGNoaWxkKTsgZWxzZSBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGNoaWxkKSBzaW1wbGUgPSAhMTtcbiAgICAgICAgICAgIGlmIChzaW1wbGUgJiYgbGFzdFNpbXBsZSkgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gKz0gY2hpbGQ7IGVsc2UgaWYgKGNoaWxkcmVuID09PSBFTVBUWV9DSElMRFJFTikgY2hpbGRyZW4gPSBbIGNoaWxkIF07IGVsc2UgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICBsYXN0U2ltcGxlID0gc2ltcGxlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gbmV3IFZOb2RlKCk7XG4gICAgICAgIHAubm9kZU5hbWUgPSBub2RlTmFtZTtcbiAgICAgICAgcC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICBwLmF0dHJpYnV0ZXMgPSBudWxsID09IGF0dHJpYnV0ZXMgPyB2b2lkIDAgOiBhdHRyaWJ1dGVzO1xuICAgICAgICBwLmtleSA9IG51bGwgPT0gYXR0cmlidXRlcyA/IHZvaWQgMCA6IGF0dHJpYnV0ZXMua2V5O1xuICAgICAgICBpZiAodm9pZCAwICE9PSBvcHRpb25zLnZub2RlKSBvcHRpb25zLnZub2RlKHApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0ZW5kKG9iaiwgcHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBwcm9wcykgb2JqW2ldID0gcHJvcHNbaV07XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lRWxlbWVudCh2bm9kZSwgcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGgodm5vZGUubm9kZU5hbWUsIGV4dGVuZChleHRlbmQoe30sIHZub2RlLmF0dHJpYnV0ZXMpLCBwcm9wcyksIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogdm5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5fX2QgJiYgKGNvbXBvbmVudC5fX2QgPSAhMCkgJiYgMSA9PSBpdGVtcy5wdXNoKGNvbXBvbmVudCkpIChvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nIHx8IGRlZmVyKShyZXJlbmRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyKCkge1xuICAgICAgICB2YXIgcCwgbGlzdCA9IGl0ZW1zO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICB3aGlsZSAocCA9IGxpc3QucG9wKCkpIGlmIChwLl9fZCkgcmVuZGVyQ29tcG9uZW50KHApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1NhbWVOb2RlVHlwZShub2RlLCB2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygdm5vZGUgfHwgJ251bWJlcicgPT0gdHlwZW9mIHZub2RlKSByZXR1cm4gdm9pZCAwICE9PSBub2RlLnNwbGl0VGV4dDtcbiAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2bm9kZS5ub2RlTmFtZSkgcmV0dXJuICFub2RlLl9jb21wb25lbnRDb25zdHJ1Y3RvciAmJiBpc05hbWVkTm9kZShub2RlLCB2bm9kZS5ub2RlTmFtZSk7IGVsc2UgcmV0dXJuIGh5ZHJhdGluZyB8fCBub2RlLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9PT0gdm5vZGUubm9kZU5hbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTmFtZWROb2RlKG5vZGUsIG5vZGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBub2RlLl9fbiA9PT0gbm9kZU5hbWUgfHwgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROb2RlUHJvcHModm5vZGUpIHtcbiAgICAgICAgdmFyIHByb3BzID0gZXh0ZW5kKHt9LCB2bm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHZub2RlLm5vZGVOYW1lLmRlZmF1bHRQcm9wcztcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gZGVmYXVsdFByb3BzKSBmb3IgKHZhciBpIGluIGRlZmF1bHRQcm9wcykgaWYgKHZvaWQgMCA9PT0gcHJvcHNbaV0pIHByb3BzW2ldID0gZGVmYXVsdFByb3BzW2ldO1xuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vZGUobm9kZU5hbWUsIGlzU3ZnKSB7XG4gICAgICAgIHZhciBub2RlID0gaXNTdmcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbm9kZU5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgICAgIG5vZGUuX19uID0gbm9kZU5hbWU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRBY2Nlc3Nvcihub2RlLCBuYW1lLCBvbGQsIHZhbHVlLCBpc1N2Zykge1xuICAgICAgICBpZiAoJ2NsYXNzTmFtZScgPT09IG5hbWUpIG5hbWUgPSAnY2xhc3MnO1xuICAgICAgICBpZiAoJ2tleScgPT09IG5hbWUpIDsgZWxzZSBpZiAoJ3JlZicgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChvbGQpIG9sZChudWxsKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkgdmFsdWUobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2NsYXNzJyA9PT0gbmFtZSAmJiAhaXNTdmcpIG5vZGUuY2xhc3NOYW1lID0gdmFsdWUgfHwgJyc7IGVsc2UgaWYgKCdzdHlsZScgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUgfHwgJ3N0cmluZycgPT0gdHlwZW9mIHZhbHVlIHx8ICdzdHJpbmcnID09IHR5cGVvZiBvbGQpIG5vZGUuc3R5bGUuY3NzVGV4dCA9IHZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmICdvYmplY3QnID09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgnc3RyaW5nJyAhPSB0eXBlb2Ygb2xkKSBmb3IgKHZhciBpIGluIG9sZCkgaWYgKCEoaSBpbiB2YWx1ZSkpIG5vZGUuc3R5bGVbaV0gPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHZhbHVlKSBub2RlLnN0eWxlW2ldID0gJ251bWJlcicgPT0gdHlwZW9mIHZhbHVlW2ldICYmICExID09PSBJU19OT05fRElNRU5TSU9OQUwudGVzdChpKSA/IHZhbHVlW2ldICsgJ3B4JyA6IHZhbHVlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCdkYW5nZXJvdXNseVNldElubmVySFRNTCcgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkgbm9kZS5pbm5lckhUTUwgPSB2YWx1ZS5fX2h0bWwgfHwgJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoJ28nID09IG5hbWVbMF0gJiYgJ24nID09IG5hbWVbMV0pIHtcbiAgICAgICAgICAgIHZhciB1c2VDYXB0dXJlID0gbmFtZSAhPT0gKG5hbWUgPSBuYW1lLnJlcGxhY2UoL0NhcHR1cmUkLywgJycpKTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbGQpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudFByb3h5LCB1c2VDYXB0dXJlKTtcbiAgICAgICAgICAgIH0gZWxzZSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgZXZlbnRQcm94eSwgdXNlQ2FwdHVyZSk7XG4gICAgICAgICAgICAobm9kZS5fX2wgfHwgKG5vZGUuX19sID0ge30pKVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCdsaXN0JyAhPT0gbmFtZSAmJiAndHlwZScgIT09IG5hbWUgJiYgIWlzU3ZnICYmIG5hbWUgaW4gbm9kZSkge1xuICAgICAgICAgICAgc2V0UHJvcGVydHkobm9kZSwgbmFtZSwgbnVsbCA9PSB2YWx1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgICAgICAgaWYgKG51bGwgPT0gdmFsdWUgfHwgITEgPT09IHZhbHVlKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBucyA9IGlzU3ZnICYmIG5hbWUgIT09IChuYW1lID0gbmFtZS5yZXBsYWNlKC9eeGxpbms6Py8sICcnKSk7XG4gICAgICAgICAgICBpZiAobnVsbCA9PSB2YWx1ZSB8fCAhMSA9PT0gdmFsdWUpIGlmIChucykgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIG5hbWUudG9Mb3dlckNhc2UoKSk7IGVsc2Ugbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7IGVsc2UgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIHZhbHVlKSBpZiAobnMpIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBuYW1lLnRvTG93ZXJDYXNlKCksIHZhbHVlKTsgZWxzZSBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0UHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5vZGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgZnVuY3Rpb24gZXZlbnRQcm94eShlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbFtlLnR5cGVdKG9wdGlvbnMuZXZlbnQgJiYgb3B0aW9ucy5ldmVudChlKSB8fCBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hNb3VudHMoKSB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICB3aGlsZSAoYyA9IG1vdW50cy5wb3AoKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWZ0ZXJNb3VudCkgb3B0aW9ucy5hZnRlck1vdW50KGMpO1xuICAgICAgICAgICAgaWYgKGMuY29tcG9uZW50RGlkTW91bnQpIGMuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaWZmKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsLCBwYXJlbnQsIGNvbXBvbmVudFJvb3QpIHtcbiAgICAgICAgaWYgKCFkaWZmTGV2ZWwrKykge1xuICAgICAgICAgICAgaXNTdmdNb2RlID0gbnVsbCAhPSBwYXJlbnQgJiYgdm9pZCAwICE9PSBwYXJlbnQub3duZXJTVkdFbGVtZW50O1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gbnVsbCAhPSBkb20gJiYgISgnX19wcmVhY3RhdHRyXycgaW4gZG9tKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0ID0gaWRpZmYoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwsIGNvbXBvbmVudFJvb3QpO1xuICAgICAgICBpZiAocGFyZW50ICYmIHJldC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHBhcmVudC5hcHBlbmRDaGlsZChyZXQpO1xuICAgICAgICBpZiAoIS0tZGlmZkxldmVsKSB7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSAhMTtcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50Um9vdCkgZmx1c2hNb3VudHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpZGlmZihkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCwgY29tcG9uZW50Um9vdCkge1xuICAgICAgICB2YXIgb3V0ID0gZG9tLCBwcmV2U3ZnTW9kZSA9IGlzU3ZnTW9kZTtcbiAgICAgICAgaWYgKG51bGwgPT0gdm5vZGUgfHwgJ2Jvb2xlYW4nID09IHR5cGVvZiB2bm9kZSkgdm5vZGUgPSAnJztcbiAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2bm9kZSB8fCAnbnVtYmVyJyA9PSB0eXBlb2Ygdm5vZGUpIHtcbiAgICAgICAgICAgIGlmIChkb20gJiYgdm9pZCAwICE9PSBkb20uc3BsaXRUZXh0ICYmIGRvbS5wYXJlbnROb2RlICYmICghZG9tLl9jb21wb25lbnQgfHwgY29tcG9uZW50Um9vdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVWYWx1ZSAhPSB2bm9kZSkgZG9tLm5vZGVWYWx1ZSA9IHZub2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2bm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tLnBhcmVudE5vZGUpIGRvbS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChvdXQsIGRvbSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY29sbGVjdE5vZGVUcmVlKGRvbSwgITApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5fX3ByZWFjdGF0dHJfID0gITA7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciB2bm9kZU5hbWUgPSB2bm9kZS5ub2RlTmFtZTtcbiAgICAgICAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHZub2RlTmFtZSkgcmV0dXJuIGJ1aWxkQ29tcG9uZW50RnJvbVZOb2RlKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsKTtcbiAgICAgICAgaXNTdmdNb2RlID0gJ3N2ZycgPT09IHZub2RlTmFtZSA/ICEwIDogJ2ZvcmVpZ25PYmplY3QnID09PSB2bm9kZU5hbWUgPyAhMSA6IGlzU3ZnTW9kZTtcbiAgICAgICAgdm5vZGVOYW1lID0gU3RyaW5nKHZub2RlTmFtZSk7XG4gICAgICAgIGlmICghZG9tIHx8ICFpc05hbWVkTm9kZShkb20sIHZub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIG91dCA9IGNyZWF0ZU5vZGUodm5vZGVOYW1lLCBpc1N2Z01vZGUpO1xuICAgICAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChkb20uZmlyc3RDaGlsZCkgb3V0LmFwcGVuZENoaWxkKGRvbS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLnBhcmVudE5vZGUpIGRvbS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChvdXQsIGRvbSk7XG4gICAgICAgICAgICAgICAgcmVjb2xsZWN0Tm9kZVRyZWUoZG9tLCAhMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZjID0gb3V0LmZpcnN0Q2hpbGQsIHByb3BzID0gb3V0Ll9fcHJlYWN0YXR0cl8sIHZjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAobnVsbCA9PSBwcm9wcykge1xuICAgICAgICAgICAgcHJvcHMgPSBvdXQuX19wcmVhY3RhdHRyXyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgYSA9IG91dC5hdHRyaWJ1dGVzLCBpID0gYS5sZW5ndGg7IGktLTsgKSBwcm9wc1thW2ldLm5hbWVdID0gYVtpXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWh5ZHJhdGluZyAmJiB2Y2hpbGRyZW4gJiYgMSA9PT0gdmNoaWxkcmVuLmxlbmd0aCAmJiAnc3RyaW5nJyA9PSB0eXBlb2YgdmNoaWxkcmVuWzBdICYmIG51bGwgIT0gZmMgJiYgdm9pZCAwICE9PSBmYy5zcGxpdFRleHQgJiYgbnVsbCA9PSBmYy5uZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKGZjLm5vZGVWYWx1ZSAhPSB2Y2hpbGRyZW5bMF0pIGZjLm5vZGVWYWx1ZSA9IHZjaGlsZHJlblswXTtcbiAgICAgICAgfSBlbHNlIGlmICh2Y2hpbGRyZW4gJiYgdmNoaWxkcmVuLmxlbmd0aCB8fCBudWxsICE9IGZjKSBpbm5lckRpZmZOb2RlKG91dCwgdmNoaWxkcmVuLCBjb250ZXh0LCBtb3VudEFsbCwgaHlkcmF0aW5nIHx8IG51bGwgIT0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpO1xuICAgICAgICBkaWZmQXR0cmlidXRlcyhvdXQsIHZub2RlLmF0dHJpYnV0ZXMsIHByb3BzKTtcbiAgICAgICAgaXNTdmdNb2RlID0gcHJldlN2Z01vZGU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlubmVyRGlmZk5vZGUoZG9tLCB2Y2hpbGRyZW4sIGNvbnRleHQsIG1vdW50QWxsLCBpc0h5ZHJhdGluZykge1xuICAgICAgICB2YXIgaiwgYywgZiwgdmNoaWxkLCBjaGlsZCwgb3JpZ2luYWxDaGlsZHJlbiA9IGRvbS5jaGlsZE5vZGVzLCBjaGlsZHJlbiA9IFtdLCBrZXllZCA9IHt9LCBrZXllZExlbiA9IDAsIG1pbiA9IDAsIGxlbiA9IG9yaWdpbmFsQ2hpbGRyZW4ubGVuZ3RoLCBjaGlsZHJlbkxlbiA9IDAsIHZsZW4gPSB2Y2hpbGRyZW4gPyB2Y2hpbGRyZW4ubGVuZ3RoIDogMDtcbiAgICAgICAgaWYgKDAgIT09IGxlbikgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIF9jaGlsZCA9IG9yaWdpbmFsQ2hpbGRyZW5baV0sIHByb3BzID0gX2NoaWxkLl9fcHJlYWN0YXR0cl8sIGtleSA9IHZsZW4gJiYgcHJvcHMgPyBfY2hpbGQuX2NvbXBvbmVudCA/IF9jaGlsZC5fY29tcG9uZW50Ll9fayA6IHByb3BzLmtleSA6IG51bGw7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBrZXkpIHtcbiAgICAgICAgICAgICAgICBrZXllZExlbisrO1xuICAgICAgICAgICAgICAgIGtleWVkW2tleV0gPSBfY2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BzIHx8ICh2b2lkIDAgIT09IF9jaGlsZC5zcGxpdFRleHQgPyBpc0h5ZHJhdGluZyA/IF9jaGlsZC5ub2RlVmFsdWUudHJpbSgpIDogITAgOiBpc0h5ZHJhdGluZykpIGNoaWxkcmVuW2NoaWxkcmVuTGVuKytdID0gX2NoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwICE9PSB2bGVuKSBmb3IgKHZhciBpID0gMDsgaSA8IHZsZW47IGkrKykge1xuICAgICAgICAgICAgdmNoaWxkID0gdmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgY2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGtleSA9IHZjaGlsZC5rZXk7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ZWRMZW4gJiYgdm9pZCAwICE9PSBrZXllZFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0ga2V5ZWRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAga2V5ZWRba2V5XSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAga2V5ZWRMZW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjaGlsZCAmJiBtaW4gPCBjaGlsZHJlbkxlbikgZm9yIChqID0gbWluOyBqIDwgY2hpbGRyZW5MZW47IGorKykgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW5bal0gJiYgaXNTYW1lTm9kZVR5cGUoYyA9IGNoaWxkcmVuW2pdLCB2Y2hpbGQsIGlzSHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gYztcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltqXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gY2hpbGRyZW5MZW4gLSAxKSBjaGlsZHJlbkxlbi0tO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSBtaW4pIG1pbisrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSBpZGlmZihjaGlsZCwgdmNoaWxkLCBjb250ZXh0LCBtb3VudEFsbCk7XG4gICAgICAgICAgICBmID0gb3JpZ2luYWxDaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gZG9tICYmIGNoaWxkICE9PSBmKSBpZiAobnVsbCA9PSBmKSBkb20uYXBwZW5kQ2hpbGQoY2hpbGQpOyBlbHNlIGlmIChjaGlsZCA9PT0gZi5uZXh0U2libGluZykgcmVtb3ZlTm9kZShmKTsgZWxzZSBkb20uaW5zZXJ0QmVmb3JlKGNoaWxkLCBmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ZWRMZW4pIGZvciAodmFyIGkgaW4ga2V5ZWQpIGlmICh2b2lkIDAgIT09IGtleWVkW2ldKSByZWNvbGxlY3ROb2RlVHJlZShrZXllZFtpXSwgITEpO1xuICAgICAgICB3aGlsZSAobWluIDw9IGNoaWxkcmVuTGVuKSBpZiAodm9pZCAwICE9PSAoY2hpbGQgPSBjaGlsZHJlbltjaGlsZHJlbkxlbi0tXSkpIHJlY29sbGVjdE5vZGVUcmVlKGNoaWxkLCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY29sbGVjdE5vZGVUcmVlKG5vZGUsIHVubW91bnRPbmx5KSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBub2RlLl9jb21wb25lbnQ7XG4gICAgICAgIGlmIChjb21wb25lbnQpIHVubW91bnRDb21wb25lbnQoY29tcG9uZW50KTsgZWxzZSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBub2RlLl9fcHJlYWN0YXR0cl8gJiYgbm9kZS5fX3ByZWFjdGF0dHJfLnJlZikgbm9kZS5fX3ByZWFjdGF0dHJfLnJlZihudWxsKTtcbiAgICAgICAgICAgIGlmICghMSA9PT0gdW5tb3VudE9ubHkgfHwgbnVsbCA9PSBub2RlLl9fcHJlYWN0YXR0cl8pIHJlbW92ZU5vZGUobm9kZSk7XG4gICAgICAgICAgICByZW1vdmVDaGlsZHJlbihub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbihub2RlKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICByZWNvbGxlY3ROb2RlVHJlZShub2RlLCAhMCk7XG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaWZmQXR0cmlidXRlcyhkb20sIGF0dHJzLCBvbGQpIHtcbiAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgIGZvciAobmFtZSBpbiBvbGQpIGlmICgoIWF0dHJzIHx8IG51bGwgPT0gYXR0cnNbbmFtZV0pICYmIG51bGwgIT0gb2xkW25hbWVdKSBzZXRBY2Nlc3Nvcihkb20sIG5hbWUsIG9sZFtuYW1lXSwgb2xkW25hbWVdID0gdm9pZCAwLCBpc1N2Z01vZGUpO1xuICAgICAgICBmb3IgKG5hbWUgaW4gYXR0cnMpIGlmICghKCdjaGlsZHJlbicgPT09IG5hbWUgfHwgJ2lubmVySFRNTCcgPT09IG5hbWUgfHwgbmFtZSBpbiBvbGQgJiYgYXR0cnNbbmFtZV0gPT09ICgndmFsdWUnID09PSBuYW1lIHx8ICdjaGVja2VkJyA9PT0gbmFtZSA/IGRvbVtuYW1lXSA6IG9sZFtuYW1lXSkpKSBzZXRBY2Nlc3Nvcihkb20sIG5hbWUsIG9sZFtuYW1lXSwgb2xkW25hbWVdID0gYXR0cnNbbmFtZV0sIGlzU3ZnTW9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbGxlY3RDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBuYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIChjb21wb25lbnRzW25hbWVdIHx8IChjb21wb25lbnRzW25hbWVdID0gW10pKS5wdXNoKGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChDdG9yLCBwcm9wcywgY29udGV4dCkge1xuICAgICAgICB2YXIgaW5zdCwgbGlzdCA9IGNvbXBvbmVudHNbQ3Rvci5uYW1lXTtcbiAgICAgICAgaWYgKEN0b3IucHJvdG90eXBlICYmIEN0b3IucHJvdG90eXBlLnJlbmRlcikge1xuICAgICAgICAgICAgaW5zdCA9IG5ldyBDdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIENvbXBvbmVudC5jYWxsKGluc3QsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc3QgPSBuZXcgQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGluc3QuY29uc3RydWN0b3IgPSBDdG9yO1xuICAgICAgICAgICAgaW5zdC5yZW5kZXIgPSBkb1JlbmRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdCkgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoOyBpLS07ICkgaWYgKGxpc3RbaV0uY29uc3RydWN0b3IgPT09IEN0b3IpIHtcbiAgICAgICAgICAgIGluc3QuX19iID0gbGlzdFtpXS5fX2I7XG4gICAgICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkb1JlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRDb21wb25lbnRQcm9wcyhjb21wb25lbnQsIHByb3BzLCBvcHRzLCBjb250ZXh0LCBtb3VudEFsbCkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5fX3gpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5fX3ggPSAhMDtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuX19yID0gcHJvcHMucmVmKSBkZWxldGUgcHJvcHMucmVmO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5fX2sgPSBwcm9wcy5rZXkpIGRlbGV0ZSBwcm9wcy5rZXk7XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5iYXNlIHx8IG1vdW50QWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsTW91bnQpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQgIT09IGNvbXBvbmVudC5jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQuX19jKSBjb21wb25lbnQuX19jID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQuX19wKSBjb21wb25lbnQuX19wID0gY29tcG9uZW50LnByb3BzO1xuICAgICAgICAgICAgY29tcG9uZW50LnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICBjb21wb25lbnQuX194ID0gITE7XG4gICAgICAgICAgICBpZiAoMCAhPT0gb3B0cykgaWYgKDEgPT09IG9wdHMgfHwgITEgIT09IG9wdGlvbnMuc3luY0NvbXBvbmVudFVwZGF0ZXMgfHwgIWNvbXBvbmVudC5iYXNlKSByZW5kZXJDb21wb25lbnQoY29tcG9uZW50LCAxLCBtb3VudEFsbCk7IGVsc2UgZW5xdWV1ZVJlbmRlcihjb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5fX3IpIGNvbXBvbmVudC5fX3IoY29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50LCBvcHRzLCBtb3VudEFsbCwgaXNDaGlsZCkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5fX3gpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZCwgaW5zdCwgY2Jhc2UsIHByb3BzID0gY29tcG9uZW50LnByb3BzLCBzdGF0ZSA9IGNvbXBvbmVudC5zdGF0ZSwgY29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0LCBwcmV2aW91c1Byb3BzID0gY29tcG9uZW50Ll9fcCB8fCBwcm9wcywgcHJldmlvdXNTdGF0ZSA9IGNvbXBvbmVudC5fX3MgfHwgc3RhdGUsIHByZXZpb3VzQ29udGV4dCA9IGNvbXBvbmVudC5fX2MgfHwgY29udGV4dCwgaXNVcGRhdGUgPSBjb21wb25lbnQuYmFzZSwgbmV4dEJhc2UgPSBjb21wb25lbnQuX19iLCBpbml0aWFsQmFzZSA9IGlzVXBkYXRlIHx8IG5leHRCYXNlLCBpbml0aWFsQ2hpbGRDb21wb25lbnQgPSBjb21wb25lbnQuX2NvbXBvbmVudCwgc2tpcCA9ICExO1xuICAgICAgICAgICAgaWYgKGlzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnByb3BzID0gcHJldmlvdXNQcm9wcztcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc3RhdGUgPSBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmICgyICE9PSBvcHRzICYmIGNvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGUgJiYgITEgPT09IGNvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGUocHJvcHMsIHN0YXRlLCBjb250ZXh0KSkgc2tpcCA9ICEwOyBlbHNlIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZSkgY29tcG9uZW50LmNvbXBvbmVudFdpbGxVcGRhdGUocHJvcHMsIHN0YXRlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuX19wID0gY29tcG9uZW50Ll9fcyA9IGNvbXBvbmVudC5fX2MgPSBjb21wb25lbnQuX19iID0gbnVsbDtcbiAgICAgICAgICAgIGNvbXBvbmVudC5fX2QgPSAhMTtcbiAgICAgICAgICAgIGlmICghc2tpcCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkID0gY29tcG9uZW50LnJlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuZ2V0Q2hpbGRDb250ZXh0KSBjb250ZXh0ID0gZXh0ZW5kKGV4dGVuZCh7fSwgY29udGV4dCksIGNvbXBvbmVudC5nZXRDaGlsZENvbnRleHQoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHRvVW5tb3VudCwgYmFzZSwgY2hpbGRDb21wb25lbnQgPSByZW5kZXJlZCAmJiByZW5kZXJlZC5ub2RlTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgY2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkUHJvcHMgPSBnZXROb2RlUHJvcHMocmVuZGVyZWQpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0ID0gaW5pdGlhbENoaWxkQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdCAmJiBpbnN0LmNvbnN0cnVjdG9yID09PSBjaGlsZENvbXBvbmVudCAmJiBjaGlsZFByb3BzLmtleSA9PSBpbnN0Ll9faykgc2V0Q29tcG9uZW50UHJvcHMoaW5zdCwgY2hpbGRQcm9wcywgMSwgY29udGV4dCwgITEpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvVW5tb3VudCA9IGluc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuX2NvbXBvbmVudCA9IGluc3QgPSBjcmVhdGVDb21wb25lbnQoY2hpbGRDb21wb25lbnQsIGNoaWxkUHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdC5fX2IgPSBpbnN0Ll9fYiB8fCBuZXh0QmFzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3QuX191ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29tcG9uZW50UHJvcHMoaW5zdCwgY2hpbGRQcm9wcywgMCwgY29udGV4dCwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyQ29tcG9uZW50KGluc3QsIDEsIG1vdW50QWxsLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGluc3QuYmFzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYmFzZSA9IGluaXRpYWxCYXNlO1xuICAgICAgICAgICAgICAgICAgICB0b1VubW91bnQgPSBpbml0aWFsQ2hpbGRDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b1VubW91bnQpIGNiYXNlID0gY29tcG9uZW50Ll9jb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbEJhc2UgfHwgMSA9PT0gb3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNiYXNlKSBjYmFzZS5fY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSBkaWZmKGNiYXNlLCByZW5kZXJlZCwgY29udGV4dCwgbW91bnRBbGwgfHwgIWlzVXBkYXRlLCBpbml0aWFsQmFzZSAmJiBpbml0aWFsQmFzZS5wYXJlbnROb2RlLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxCYXNlICYmIGJhc2UgIT09IGluaXRpYWxCYXNlICYmIGluc3QgIT09IGluaXRpYWxDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVBhcmVudCA9IGluaXRpYWxCYXNlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlUGFyZW50ICYmIGJhc2UgIT09IGJhc2VQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VQYXJlbnQucmVwbGFjZUNoaWxkKGJhc2UsIGluaXRpYWxCYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdG9Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbEJhc2UuX2NvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb2xsZWN0Tm9kZVRyZWUoaW5pdGlhbEJhc2UsICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9Vbm1vdW50KSB1bm1vdW50Q29tcG9uZW50KHRvVW5tb3VudCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlICYmICFpc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRSZWYgPSBjb21wb25lbnQsIHQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0ID0gdC5fX3UpIChjb21wb25lbnRSZWYgPSB0KS5iYXNlID0gYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZS5fY29tcG9uZW50ID0gY29tcG9uZW50UmVmO1xuICAgICAgICAgICAgICAgICAgICBiYXNlLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9IGNvbXBvbmVudFJlZi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzVXBkYXRlIHx8IG1vdW50QWxsKSBtb3VudHMudW5zaGlmdChjb21wb25lbnQpOyBlbHNlIGlmICghc2tpcCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50RGlkVXBkYXRlKSBjb21wb25lbnQuY29tcG9uZW50RGlkVXBkYXRlKHByZXZpb3VzUHJvcHMsIHByZXZpb3VzU3RhdGUsIHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWZ0ZXJVcGRhdGUpIG9wdGlvbnMuYWZ0ZXJVcGRhdGUoY29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudWxsICE9IGNvbXBvbmVudC5fX2gpIHdoaWxlIChjb21wb25lbnQuX19oLmxlbmd0aCkgY29tcG9uZW50Ll9faC5wb3AoKS5jYWxsKGNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoIWRpZmZMZXZlbCAmJiAhaXNDaGlsZCkgZmx1c2hNb3VudHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZENvbXBvbmVudEZyb21WTm9kZShkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCkge1xuICAgICAgICB2YXIgYyA9IGRvbSAmJiBkb20uX2NvbXBvbmVudCwgb3JpZ2luYWxDb21wb25lbnQgPSBjLCBvbGREb20gPSBkb20sIGlzRGlyZWN0T3duZXIgPSBjICYmIGRvbS5fY29tcG9uZW50Q29uc3RydWN0b3IgPT09IHZub2RlLm5vZGVOYW1lLCBpc093bmVyID0gaXNEaXJlY3RPd25lciwgcHJvcHMgPSBnZXROb2RlUHJvcHModm5vZGUpO1xuICAgICAgICB3aGlsZSAoYyAmJiAhaXNPd25lciAmJiAoYyA9IGMuX191KSkgaXNPd25lciA9IGMuY29uc3RydWN0b3IgPT09IHZub2RlLm5vZGVOYW1lO1xuICAgICAgICBpZiAoYyAmJiBpc093bmVyICYmICghbW91bnRBbGwgfHwgYy5fY29tcG9uZW50KSkge1xuICAgICAgICAgICAgc2V0Q29tcG9uZW50UHJvcHMoYywgcHJvcHMsIDMsIGNvbnRleHQsIG1vdW50QWxsKTtcbiAgICAgICAgICAgIGRvbSA9IGMuYmFzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbENvbXBvbmVudCAmJiAhaXNEaXJlY3RPd25lcikge1xuICAgICAgICAgICAgICAgIHVubW91bnRDb21wb25lbnQob3JpZ2luYWxDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIGRvbSA9IG9sZERvbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjID0gY3JlYXRlQ29tcG9uZW50KHZub2RlLm5vZGVOYW1lLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoZG9tICYmICFjLl9fYikge1xuICAgICAgICAgICAgICAgIGMuX19iID0gZG9tO1xuICAgICAgICAgICAgICAgIG9sZERvbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDb21wb25lbnRQcm9wcyhjLCBwcm9wcywgMSwgY29udGV4dCwgbW91bnRBbGwpO1xuICAgICAgICAgICAgZG9tID0gYy5iYXNlO1xuICAgICAgICAgICAgaWYgKG9sZERvbSAmJiBkb20gIT09IG9sZERvbSkge1xuICAgICAgICAgICAgICAgIG9sZERvbS5fY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZWNvbGxlY3ROb2RlVHJlZShvbGREb20sICExKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBpZiAob3B0aW9ucy5iZWZvcmVVbm1vdW50KSBvcHRpb25zLmJlZm9yZVVubW91bnQoY29tcG9uZW50KTtcbiAgICAgICAgdmFyIGJhc2UgPSBjb21wb25lbnQuYmFzZTtcbiAgICAgICAgY29tcG9uZW50Ll9feCA9ICEwO1xuICAgICAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxVbm1vdW50KSBjb21wb25lbnQuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgICAgY29tcG9uZW50LmJhc2UgPSBudWxsO1xuICAgICAgICB2YXIgaW5uZXIgPSBjb21wb25lbnQuX2NvbXBvbmVudDtcbiAgICAgICAgaWYgKGlubmVyKSB1bm1vdW50Q29tcG9uZW50KGlubmVyKTsgZWxzZSBpZiAoYmFzZSkge1xuICAgICAgICAgICAgaWYgKGJhc2UuX19wcmVhY3RhdHRyXyAmJiBiYXNlLl9fcHJlYWN0YXR0cl8ucmVmKSBiYXNlLl9fcHJlYWN0YXR0cl8ucmVmKG51bGwpO1xuICAgICAgICAgICAgY29tcG9uZW50Ll9fYiA9IGJhc2U7XG4gICAgICAgICAgICByZW1vdmVOb2RlKGJhc2UpO1xuICAgICAgICAgICAgY29sbGVjdENvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudC5fX3IpIGNvbXBvbmVudC5fX3IobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuICAgICAgICB0aGlzLl9fZCA9ICEwO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlIHx8IHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudCwgbWVyZ2UpIHtcbiAgICAgICAgcmV0dXJuIGRpZmYobWVyZ2UsIHZub2RlLCB7fSwgITEsIHBhcmVudCwgITEpO1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBFTVBUWV9DSElMRFJFTiA9IFtdO1xuICAgIHZhciBkZWZlciA9ICdmdW5jdGlvbicgPT0gdHlwZW9mIFByb21pc2UgPyBQcm9taXNlLnJlc29sdmUoKS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpIDogc2V0VGltZW91dDtcbiAgICB2YXIgSVNfTk9OX0RJTUVOU0lPTkFMID0gL2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkL2k7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdmFyIG1vdW50cyA9IFtdO1xuICAgIHZhciBkaWZmTGV2ZWwgPSAwO1xuICAgIHZhciBpc1N2Z01vZGUgPSAhMTtcbiAgICB2YXIgaHlkcmF0aW5nID0gITE7XG4gICAgdmFyIGNvbXBvbmVudHMgPSB7fTtcbiAgICBleHRlbmQoQ29tcG9uZW50LnByb3RvdHlwZSwge1xuICAgICAgICBzZXRTdGF0ZTogZnVuY3Rpb24oc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX19zKSB0aGlzLl9fcyA9IGV4dGVuZCh7fSwgcyk7XG4gICAgICAgICAgICBleHRlbmQocywgJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3RhdGUgPyBzdGF0ZShzLCB0aGlzLnByb3BzKSA6IHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgKHRoaXMuX19oID0gdGhpcy5fX2ggfHwgW10pLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgZW5xdWV1ZVJlbmRlcih0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spICh0aGlzLl9faCA9IHRoaXMuX19oIHx8IFtdKS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJlbmRlckNvbXBvbmVudCh0aGlzLCAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHt9XG4gICAgfSk7XG4gICAgdmFyIHByZWFjdCA9IHtcbiAgICAgICAgaDogaCxcbiAgICAgICAgY3JlYXRlRWxlbWVudDogaCxcbiAgICAgICAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gICAgICAgIENvbXBvbmVudDogQ29tcG9uZW50LFxuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgcmVyZW5kZXI6IHJlcmVuZGVyLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfTtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG1vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBwcmVhY3Q7IGVsc2Ugc2VsZi5wcmVhY3QgPSBwcmVhY3Q7XG59KCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVhY3QuanMubWFwIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9jb3JlXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJDb3JlIG1vZHVsZSBmb3IgdGhlIGV4dGVuc2libGUgSmF2YVNjcmlwdCBmaWxlIHVwbG9hZCB3aWRnZXQgd2l0aCBzdXBwb3J0IGZvciBkcmFnJmRyb3AsIHJlc3VtYWJsZSB1cGxvYWRzLCBwcmV2aWV3cywgcmVzdHJpY3Rpb25zLCBmaWxlIHByb2Nlc3NpbmcvZW5jb2RpbmcsIHJlbW90ZSBwcm92aWRlcnMgbGlrZSBJbnN0YWdyYW0sIERyb3Bib3gsIEdvb2dsZSBEcml2ZSwgUzMgYW5kIG1vcmUgOmRvZzpcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4xOS4yXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJzdHlsZVwiOiBcImRpc3Qvc3R5bGUubWluLmNzc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdHJhbnNsb2FkaXQvcHJldHRpZXItYnl0ZXNcIjogXCIwLjAuN1wiLFxuICAgIFwiQHVwcHkvc3RvcmUtZGVmYXVsdFwiOiBcImZpbGU6Li4vc3RvcmUtZGVmYXVsdFwiLFxuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJjdWlkXCI6IFwiXjIuMS4xXCIsXG4gICAgXCJsb2Rhc2gudGhyb3R0bGVcIjogXCJeNC4xLjFcIixcbiAgICBcIm1pbWUtbWF0Y2hcIjogXCJeMS4wLjJcIixcbiAgICBcIm5hbWVzcGFjZS1lbWl0dGVyXCI6IFwiXjIuMC4xXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH1cbn1cbiIsImNvbnN0IHByZWFjdCA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBmaW5kRE9NRWxlbWVudCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9maW5kRE9NRWxlbWVudCcpXG5cbi8qKlxuICogRGVmZXIgYSBmcmVxdWVudCBjYWxsIHRvIHRoZSBtaWNyb3Rhc2sgcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlIChmbikge1xuICBsZXQgY2FsbGluZyA9IG51bGxcbiAgbGV0IGxhdGVzdEFyZ3MgPSBudWxsXG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGxhdGVzdEFyZ3MgPSBhcmdzXG4gICAgaWYgKCFjYWxsaW5nKSB7XG4gICAgICBjYWxsaW5nID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGNhbGxpbmcgPSBudWxsXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgYGFyZ3NgIG1heSBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgbW9zdFxuICAgICAgICAvLyByZWNlbnQgc3RhdGUsIGlmIG11bHRpcGxlIGNhbGxzIGhhcHBlbmVkIHNpbmNlIHRoaXMgdGFza1xuICAgICAgICAvLyB3YXMgcXVldWVkLiBTbyB3ZSB1c2UgdGhlIGBsYXRlc3RBcmdzYCwgd2hpY2ggZGVmaW5pdGVseVxuICAgICAgICAvLyBpcyB0aGUgbW9zdCByZWNlbnQgY2FsbC5cbiAgICAgICAgcmV0dXJuIGZuKC4uLmxhdGVzdEFyZ3MpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gY2FsbGluZ1xuICB9XG59XG5cbi8qKlxuICogQm9pbGVycGxhdGUgdGhhdCBhbGwgUGx1Z2lucyBzaGFyZSAtIGFuZCBzaG91bGQgbm90IGJlIHVzZWRcbiAqIGRpcmVjdGx5LiBJdCBhbHNvIHNob3dzIHdoaWNoIG1ldGhvZHMgZmluYWwgcGx1Z2lucyBzaG91bGQgaW1wbGVtZW50L292ZXJyaWRlLFxuICogdGhpcyBkZWNpZGluZyBvbiBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG1haW4gVXBweSBjb3JlIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCB3aXRoIHBsdWdpbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXl8c3RyaW5nfSBmaWxlcyBvciBzdWNjZXNzL2ZhaWwgbWVzc2FnZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBsdWdpbiB7XG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgdGhpcy51cHB5ID0gdXBweVxuICAgIHRoaXMub3B0cyA9IG9wdHMgfHwge31cblxuICAgIHRoaXMudXBkYXRlID0gdGhpcy51cGRhdGUuYmluZCh0aGlzKVxuICAgIHRoaXMubW91bnQgPSB0aGlzLm1vdW50LmJpbmQodGhpcylcbiAgICB0aGlzLmluc3RhbGwgPSB0aGlzLmluc3RhbGwuYmluZCh0aGlzKVxuICAgIHRoaXMudW5pbnN0YWxsID0gdGhpcy51bmluc3RhbGwuYmluZCh0aGlzKVxuICB9XG5cbiAgZ2V0UGx1Z2luU3RhdGUgKCkge1xuICAgIGNvbnN0IHsgcGx1Z2lucyB9ID0gdGhpcy51cHB5LmdldFN0YXRlKClcbiAgICByZXR1cm4gcGx1Z2luc1t0aGlzLmlkXSB8fCB7fVxuICB9XG5cbiAgc2V0UGx1Z2luU3RhdGUgKHVwZGF0ZSkge1xuICAgIGNvbnN0IHsgcGx1Z2lucyB9ID0gdGhpcy51cHB5LmdldFN0YXRlKClcblxuICAgIHRoaXMudXBweS5zZXRTdGF0ZSh7XG4gICAgICBwbHVnaW5zOiB7XG4gICAgICAgIC4uLnBsdWdpbnMsXG4gICAgICAgIFt0aGlzLmlkXToge1xuICAgICAgICAgIC4uLnBsdWdpbnNbdGhpcy5pZF0sXG4gICAgICAgICAgLi4udXBkYXRlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgc2V0T3B0aW9ucyAobmV3T3B0cykge1xuICAgIHRoaXMub3B0cyA9IHsgLi4udGhpcy5vcHRzLCAuLi5uZXdPcHRzIH1cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKCkgLy8gc28gdGhhdCBVSSByZS1yZW5kZXJzIHdpdGggbmV3IG9wdGlvbnNcbiAgfVxuXG4gIHVwZGF0ZSAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdXBkYXRlVUkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVVJKHN0YXRlKVxuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBhZnRlciBldmVyeSBzdGF0ZSB1cGRhdGUsIGFmdGVyIGV2ZXJ5dGhpbmcncyBtb3VudGVkLiBEZWJvdW5jZWQuXG4gIGFmdGVyVXBkYXRlICgpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHBsdWdpbiBpcyBtb3VudGVkLCB3aGV0aGVyIGluIERPTSBvciBpbnRvIGFub3RoZXIgcGx1Z2luLlxuICAgKiBOZWVkZWQgYmVjYXVzZSBzb21ldGltZXMgcGx1Z2lucyBhcmUgbW91bnRlZCBzZXBhcmF0ZWx5L2FmdGVyIGBpbnN0YWxsYCxcbiAgICogc28gdGhpcy5lbCBhbmQgdGhpcy5wYXJlbnQgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpbiBgaW5zdGFsbGAuXG4gICAqIFRoaXMgaXMgdGhlIGNhc2Ugd2l0aCBAdXBweS9yZWFjdCBwbHVnaW5zLCBmb3IgZXhhbXBsZS5cbiAgICovXG4gIG9uTW91bnQgKCkge1xuXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgc3VwcGxpZWQgYHRhcmdldGAgaXMgYSBET00gZWxlbWVudCBvciBhbiBgb2JqZWN0YC5cbiAgICogSWYgaXTigJlzIGFuIG9iamVjdCDigJQgdGFyZ2V0IGlzIGEgcGx1Z2luLCBhbmQgd2Ugc2VhcmNoIGBwbHVnaW5zYFxuICAgKiBmb3IgYSBwbHVnaW4gd2l0aCBzYW1lIG5hbWUgYW5kIHJldHVybiBpdHMgdGFyZ2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHRhcmdldFxuICAgKlxuICAgKi9cbiAgbW91bnQgKHRhcmdldCwgcGx1Z2luKSB7XG4gICAgY29uc3QgY2FsbGVyUGx1Z2luTmFtZSA9IHBsdWdpbi5pZFxuXG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGZpbmRET01FbGVtZW50KHRhcmdldClcblxuICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XG4gICAgICB0aGlzLmlzVGFyZ2V0RE9NRWwgPSB0cnVlXG5cbiAgICAgIC8vIEFQSSBmb3IgcGx1Z2lucyB0aGF0IHJlcXVpcmUgYSBzeW5jaHJvbm91cyByZXJlbmRlci5cbiAgICAgIHRoaXMucmVyZW5kZXIgPSAoc3RhdGUpID0+IHtcbiAgICAgICAgLy8gcGx1Z2luIGNvdWxkIGJlIHJlbW92ZWQsIGJ1dCB0aGlzLnJlcmVuZGVyIGlzIGRlYm91bmNlZCBiZWxvdyxcbiAgICAgICAgLy8gc28gaXQgY291bGQgc3RpbGwgYmUgY2FsbGVkIGV2ZW4gYWZ0ZXIgdXBweS5yZW1vdmVQbHVnaW4gb3IgdXBweS5jbG9zZVxuICAgICAgICAvLyBoZW5jZSB0aGUgY2hlY2tcbiAgICAgICAgaWYgKCF0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMuaWQpKSByZXR1cm5cbiAgICAgICAgdGhpcy5lbCA9IHByZWFjdC5yZW5kZXIodGhpcy5yZW5kZXIoc3RhdGUpLCB0YXJnZXRFbGVtZW50LCB0aGlzLmVsKVxuICAgICAgICB0aGlzLmFmdGVyVXBkYXRlKClcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZVVJID0gZGVib3VuY2UodGhpcy5yZXJlbmRlcilcblxuICAgICAgdGhpcy51cHB5LmxvZyhgSW5zdGFsbGluZyAke2NhbGxlclBsdWdpbk5hbWV9IHRvIGEgRE9NIGVsZW1lbnQgJyR7dGFyZ2V0fSdgKVxuXG4gICAgICAvLyBjbGVhciBldmVyeXRoaW5nIGluc2lkZSB0aGUgdGFyZ2V0IGNvbnRhaW5lclxuICAgICAgaWYgKHRoaXMub3B0cy5yZXBsYWNlVGFyZ2V0Q29udGVudCkge1xuICAgICAgICB0YXJnZXRFbGVtZW50LmlubmVySFRNTCA9ICcnXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwgPSBwcmVhY3QucmVuZGVyKHRoaXMucmVuZGVyKHRoaXMudXBweS5nZXRTdGF0ZSgpKSwgdGFyZ2V0RWxlbWVudClcblxuICAgICAgdGhpcy5vbk1vdW50KClcbiAgICAgIHJldHVybiB0aGlzLmVsXG4gICAgfVxuXG4gICAgbGV0IHRhcmdldFBsdWdpblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0YXJnZXQgaW5zdGFuY2VvZiBQbHVnaW4pIHtcbiAgICAgIC8vIFRhcmdldGluZyBhIHBsdWdpbiAqaW5zdGFuY2UqXG4gICAgICB0YXJnZXRQbHVnaW4gPSB0YXJnZXRcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRhcmdldGluZyBhIHBsdWdpbiB0eXBlXG4gICAgICBjb25zdCBUYXJnZXQgPSB0YXJnZXRcbiAgICAgIC8vIEZpbmQgdGhlIHRhcmdldCBwbHVnaW4gaW5zdGFuY2UuXG4gICAgICB0aGlzLnVwcHkuaXRlcmF0ZVBsdWdpbnMoKHBsdWdpbikgPT4ge1xuICAgICAgICBpZiAocGx1Z2luIGluc3RhbmNlb2YgVGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0UGx1Z2luID0gcGx1Z2luXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHRhcmdldFBsdWdpbikge1xuICAgICAgdGhpcy51cHB5LmxvZyhgSW5zdGFsbGluZyAke2NhbGxlclBsdWdpbk5hbWV9IHRvICR7dGFyZ2V0UGx1Z2luLmlkfWApXG4gICAgICB0aGlzLnBhcmVudCA9IHRhcmdldFBsdWdpblxuICAgICAgdGhpcy5lbCA9IHRhcmdldFBsdWdpbi5hZGRUYXJnZXQocGx1Z2luKVxuXG4gICAgICB0aGlzLm9uTW91bnQoKVxuICAgICAgcmV0dXJuIHRoaXMuZWxcbiAgICB9XG5cbiAgICB0aGlzLnVwcHkubG9nKGBOb3QgaW5zdGFsbGluZyAke2NhbGxlclBsdWdpbk5hbWV9YClcblxuICAgIGxldCBtZXNzYWdlID0gYEludmFsaWQgdGFyZ2V0IG9wdGlvbiBnaXZlbiB0byAke2NhbGxlclBsdWdpbk5hbWV9LmBcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbWVzc2FnZSArPSAnIFRoZSBnaXZlbiB0YXJnZXQgaXMgbm90IGEgUGx1Z2luIGNsYXNzLiAnXG4gICAgICAgICsgJ1BsZWFzZSBjaGVjayB0aGF0IHlvdVxcJ3JlIG5vdCBzcGVjaWZ5aW5nIGEgUmVhY3QgQ29tcG9uZW50IGluc3RlYWQgb2YgYSBwbHVnaW4uICdcbiAgICAgICAgKyAnSWYgeW91IGFyZSB1c2luZyBAdXBweS8qIHBhY2thZ2VzIGRpcmVjdGx5LCBtYWtlIHN1cmUgeW91IGhhdmUgb25seSAxIHZlcnNpb24gb2YgQHVwcHkvY29yZSBpbnN0YWxsZWQ6ICdcbiAgICAgICAgKyAncnVuIGBucG0gbHMgQHVwcHkvY29yZWAgb24gdGhlIGNvbW1hbmQgbGluZSBhbmQgdmVyaWZ5IHRoYXQgYWxsIHRoZSB2ZXJzaW9ucyBtYXRjaCBhbmQgYXJlIGRlZHVwZWQgY29ycmVjdGx5LidcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZSArPSAnSWYgeW91IG1lYW50IHRvIHRhcmdldCBhbiBIVE1MIGVsZW1lbnQsIHBsZWFzZSBtYWtlIHN1cmUgdGhhdCB0aGUgZWxlbWVudCBleGlzdHMuICdcbiAgICAgICAgKyAnQ2hlY2sgdGhhdCB0aGUgPHNjcmlwdD4gdGFnIGluaXRpYWxpemluZyBVcHB5IGlzIHJpZ2h0IGJlZm9yZSB0aGUgY2xvc2luZyA8L2JvZHk+IHRhZyBhdCB0aGUgZW5kIG9mIHRoZSBwYWdlLiAnXG4gICAgICAgICsgJyhzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzLzEwNDIpXFxuXFxuJ1xuICAgICAgICArICdJZiB5b3UgbWVhbnQgdG8gdGFyZ2V0IGEgcGx1Z2luLCBwbGVhc2UgY29uZmlybSB0aGF0IHlvdXIgYGltcG9ydGAgc3RhdGVtZW50cyBvciBgcmVxdWlyZWAgY2FsbHMgYXJlIGNvcnJlY3QuJ1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUpIHtcbiAgICB0aHJvdyAobmV3IEVycm9yKCdFeHRlbmQgdGhlIHJlbmRlciBtZXRob2QgdG8gYWRkIHlvdXIgcGx1Z2luIHRvIGEgRE9NIGVsZW1lbnQnKSlcbiAgfVxuXG4gIGFkZFRhcmdldCAocGx1Z2luKSB7XG4gICAgdGhyb3cgKG5ldyBFcnJvcignRXh0ZW5kIHRoZSBhZGRUYXJnZXQgbWV0aG9kIHRvIGFkZCB5b3VyIHBsdWdpbiB0byBhbm90aGVyIHBsdWdpblxcJ3MgdGFyZ2V0JykpXG4gIH1cblxuICB1bm1vdW50ICgpIHtcbiAgICBpZiAodGhpcy5pc1RhcmdldERPTUVsICYmIHRoaXMuZWwgJiYgdGhpcy5lbC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbClcbiAgICB9XG4gIH1cblxuICBpbnN0YWxsICgpIHtcblxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG59XG4iLCIvKiBnbG9iYWwgQWdncmVnYXRlRXJyb3IgKi9cbmNvbnN0IFRyYW5zbGF0b3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvVHJhbnNsYXRvcicpXG5jb25zdCBlZSA9IHJlcXVpcmUoJ25hbWVzcGFjZS1lbWl0dGVyJylcbmNvbnN0IGN1aWQgPSByZXF1aXJlKCdjdWlkJylcbmNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgnbG9kYXNoLnRocm90dGxlJylcbmNvbnN0IHByZXR0aWVyQnl0ZXMgPSByZXF1aXJlKCdAdHJhbnNsb2FkaXQvcHJldHRpZXItYnl0ZXMnKVxuY29uc3QgbWF0Y2ggPSByZXF1aXJlKCdtaW1lLW1hdGNoJylcbmNvbnN0IERlZmF1bHRTdG9yZSA9IHJlcXVpcmUoJ0B1cHB5L3N0b3JlLWRlZmF1bHQnKVxuY29uc3QgZ2V0RmlsZVR5cGUgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0RmlsZVR5cGUnKVxuY29uc3QgZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24gPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24nKVxuY29uc3QgZ2VuZXJhdGVGaWxlSUQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2VuZXJhdGVGaWxlSUQnKVxuY29uc3QgZmluZEluZGV4ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2ZpbmRJbmRleCcpXG5jb25zdCBzdXBwb3J0c1VwbG9hZFByb2dyZXNzID0gcmVxdWlyZSgnLi9zdXBwb3J0c1VwbG9hZFByb2dyZXNzJylcbmNvbnN0IHsganVzdEVycm9yc0xvZ2dlciwgZGVidWdMb2dnZXIgfSA9IHJlcXVpcmUoJy4vbG9nZ2VycycpXG5jb25zdCBQbHVnaW4gPSByZXF1aXJlKCcuL1BsdWdpbicpXG5jb25zdCB7IHZlcnNpb24gfSA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpXG5cbi8vIEV4cG9ydGVkIGZyb20gaGVyZS5cbmNsYXNzIFJlc3RyaWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLmlzUmVzdHJpY3Rpb24gPSB0cnVlXG4gIH1cbn1cblxuLyoqXG4gKiBVcHB5IENvcmUgbW9kdWxlLlxuICogTWFuYWdlcyBwbHVnaW5zLCBzdGF0ZSB1cGRhdGVzLCBhY3RzIGFzIGFuIGV2ZW50IGJ1cyxcbiAqIGFkZHMvcmVtb3ZlcyBmaWxlcyBhbmQgbWV0YWRhdGEuXG4gKi9cbmNsYXNzIFVwcHkge1xuICBzdGF0aWMgVkVSU0lPTiA9IHZlcnNpb25cblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgVXBweVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyDigJQgVXBweSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IHtcbiAgICAgIHN0cmluZ3M6IHtcbiAgICAgICAgYWRkQnVsa0ZpbGVzRmFpbGVkOiB7XG4gICAgICAgICAgMDogJ0ZhaWxlZCB0byBhZGQgJXtzbWFydF9jb3VudH0gZmlsZSBkdWUgdG8gYW4gaW50ZXJuYWwgZXJyb3InLFxuICAgICAgICAgIDE6ICdGYWlsZWQgdG8gYWRkICV7c21hcnRfY291bnR9IGZpbGVzIGR1ZSB0byBpbnRlcm5hbCBlcnJvcnMnLFxuICAgICAgICB9LFxuICAgICAgICB5b3VDYW5Pbmx5VXBsb2FkWDoge1xuICAgICAgICAgIDA6ICdZb3UgY2FuIG9ubHkgdXBsb2FkICV7c21hcnRfY291bnR9IGZpbGUnLFxuICAgICAgICAgIDE6ICdZb3UgY2FuIG9ubHkgdXBsb2FkICV7c21hcnRfY291bnR9IGZpbGVzJyxcbiAgICAgICAgfSxcbiAgICAgICAgeW91SGF2ZVRvQXRMZWFzdFNlbGVjdFg6IHtcbiAgICAgICAgICAwOiAnWW91IGhhdmUgdG8gc2VsZWN0IGF0IGxlYXN0ICV7c21hcnRfY291bnR9IGZpbGUnLFxuICAgICAgICAgIDE6ICdZb3UgaGF2ZSB0byBzZWxlY3QgYXQgbGVhc3QgJXtzbWFydF9jb3VudH0gZmlsZXMnLFxuICAgICAgICB9LFxuICAgICAgICAvLyBUaGUgZGVmYXVsdCBgZXhjZWVkc1NpemUyYCBzdHJpbmcgb25seSBjb21iaW5lcyB0aGUgYGV4Y2VlZHNTaXplYCBzdHJpbmcgKCV7YmFja3dhcmRzQ29tcGF0fSkgd2l0aCB0aGUgc2l6ZS5cbiAgICAgICAgLy8gTG9jYWxlcyBjYW4gb3ZlcnJpZGUgYGV4Y2VlZHNTaXplMmAgdG8gc3BlY2lmeSBhIGRpZmZlcmVudCB3b3JkIG9yZGVyLiBUaGlzIGlzIGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGhcbiAgICAgICAgLy8gVXBweSAxLjkueCBhbmQgYmVsb3cgd2hpY2ggZGlkIGEgbmFpdmUgY29uY2F0ZW5hdGlvbiBvZiBgZXhjZWVkc1NpemUyICsgc2l6ZWAgaW5zdGVhZCBvZiB1c2luZyBhIGxvY2FsZS1zcGVjaWZpY1xuICAgICAgICAvLyBzdWJzdGl0dXRpb24uXG4gICAgICAgIC8vIFRPRE86IEluIDIuMCBgZXhjZWVkc1NpemUyYCBzaG91bGQgYmUgcmVtb3ZlZCBpbiBhbmQgYGV4Y2VlZHNTaXplYCB1cGRhdGVkIHRvIHVzZSBzdWJzdGl0dXRpb24uXG4gICAgICAgIGV4Y2VlZHNTaXplMjogJyV7YmFja3dhcmRzQ29tcGF0fSAle3NpemV9JyxcbiAgICAgICAgZXhjZWVkc1NpemU6ICcle2ZpbGV9IGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHNpemUgb2YnLFxuICAgICAgICBpbmZlcmlvclNpemU6ICdUaGlzIGZpbGUgaXMgc21hbGxlciB0aGFuIHRoZSBhbGxvd2VkIHNpemUgb2YgJXtzaXplfScsXG4gICAgICAgIHlvdUNhbk9ubHlVcGxvYWRGaWxlVHlwZXM6ICdZb3UgY2FuIG9ubHkgdXBsb2FkOiAle3R5cGVzfScsXG4gICAgICAgIG5vTmV3QWxyZWFkeVVwbG9hZGluZzogJ0Nhbm5vdCBhZGQgbmV3IGZpbGVzOiBhbHJlYWR5IHVwbG9hZGluZycsXG4gICAgICAgIG5vRHVwbGljYXRlczogJ0Nhbm5vdCBhZGQgdGhlIGR1cGxpY2F0ZSBmaWxlIFxcJyV7ZmlsZU5hbWV9XFwnLCBpdCBhbHJlYWR5IGV4aXN0cycsXG4gICAgICAgIGNvbXBhbmlvbkVycm9yOiAnQ29ubmVjdGlvbiB3aXRoIENvbXBhbmlvbiBmYWlsZWQnLFxuICAgICAgICBjb21wYW5pb25VbmF1dGhvcml6ZUhpbnQ6ICdUbyB1bmF1dGhvcml6ZSB0byB5b3VyICV7cHJvdmlkZXJ9IGFjY291bnQsIHBsZWFzZSBnbyB0byAle3VybH0nLFxuICAgICAgICBmYWlsZWRUb1VwbG9hZDogJ0ZhaWxlZCB0byB1cGxvYWQgJXtmaWxlfScsXG4gICAgICAgIG5vSW50ZXJuZXRDb25uZWN0aW9uOiAnTm8gSW50ZXJuZXQgY29ubmVjdGlvbicsXG4gICAgICAgIGNvbm5lY3RlZFRvSW50ZXJuZXQ6ICdDb25uZWN0ZWQgdG8gdGhlIEludGVybmV0JyxcbiAgICAgICAgLy8gU3RyaW5ncyBmb3IgcmVtb3RlIHByb3ZpZGVyc1xuICAgICAgICBub0ZpbGVzRm91bmQ6ICdZb3UgaGF2ZSBubyBmaWxlcyBvciBmb2xkZXJzIGhlcmUnLFxuICAgICAgICBzZWxlY3RYOiB7XG4gICAgICAgICAgMDogJ1NlbGVjdCAle3NtYXJ0X2NvdW50fScsXG4gICAgICAgICAgMTogJ1NlbGVjdCAle3NtYXJ0X2NvdW50fScsXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdEFsbEZpbGVzRnJvbUZvbGRlck5hbWVkOiAnU2VsZWN0IGFsbCBmaWxlcyBmcm9tIGZvbGRlciAle25hbWV9JyxcbiAgICAgICAgdW5zZWxlY3RBbGxGaWxlc0Zyb21Gb2xkZXJOYW1lZDogJ1Vuc2VsZWN0IGFsbCBmaWxlcyBmcm9tIGZvbGRlciAle25hbWV9JyxcbiAgICAgICAgc2VsZWN0RmlsZU5hbWVkOiAnU2VsZWN0IGZpbGUgJXtuYW1lfScsXG4gICAgICAgIHVuc2VsZWN0RmlsZU5hbWVkOiAnVW5zZWxlY3QgZmlsZSAle25hbWV9JyxcbiAgICAgICAgb3BlbkZvbGRlck5hbWVkOiAnT3BlbiBmb2xkZXIgJXtuYW1lfScsXG4gICAgICAgIGNhbmNlbDogJ0NhbmNlbCcsXG4gICAgICAgIGxvZ091dDogJ0xvZyBvdXQnLFxuICAgICAgICBmaWx0ZXI6ICdGaWx0ZXInLFxuICAgICAgICByZXNldEZpbHRlcjogJ1Jlc2V0IGZpbHRlcicsXG4gICAgICAgIGxvYWRpbmc6ICdMb2FkaW5nLi4uJyxcbiAgICAgICAgYXV0aGVudGljYXRlV2l0aFRpdGxlOiAnUGxlYXNlIGF1dGhlbnRpY2F0ZSB3aXRoICV7cGx1Z2luTmFtZX0gdG8gc2VsZWN0IGZpbGVzJyxcbiAgICAgICAgYXV0aGVudGljYXRlV2l0aDogJ0Nvbm5lY3QgdG8gJXtwbHVnaW5OYW1lfScsXG4gICAgICAgIHNlYXJjaEltYWdlczogJ1NlYXJjaCBmb3IgaW1hZ2VzJyxcbiAgICAgICAgZW50ZXJUZXh0VG9TZWFyY2g6ICdFbnRlciB0ZXh0IHRvIHNlYXJjaCBmb3IgaW1hZ2VzJyxcbiAgICAgICAgYmFja1RvU2VhcmNoOiAnQmFjayB0byBTZWFyY2gnLFxuICAgICAgICBlbXB0eUZvbGRlckFkZGVkOiAnTm8gZmlsZXMgd2VyZSBhZGRlZCBmcm9tIGVtcHR5IGZvbGRlcicsXG4gICAgICAgIGZvbGRlckFkZGVkOiB7XG4gICAgICAgICAgMDogJ0FkZGVkICV7c21hcnRfY291bnR9IGZpbGUgZnJvbSAle2ZvbGRlcn0nLFxuICAgICAgICAgIDE6ICdBZGRlZCAle3NtYXJ0X2NvdW50fSBmaWxlcyBmcm9tICV7Zm9sZGVyfScsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgaWQ6ICd1cHB5JyxcbiAgICAgIGF1dG9Qcm9jZWVkOiBmYWxzZSxcbiAgICAgIGFsbG93TXVsdGlwbGVVcGxvYWRzOiB0cnVlLFxuICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgcmVzdHJpY3Rpb25zOiB7XG4gICAgICAgIG1heEZpbGVTaXplOiBudWxsLFxuICAgICAgICBtaW5GaWxlU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4VG90YWxGaWxlU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4TnVtYmVyT2ZGaWxlczogbnVsbCxcbiAgICAgICAgbWluTnVtYmVyT2ZGaWxlczogbnVsbCxcbiAgICAgICAgYWxsb3dlZEZpbGVUeXBlczogbnVsbCxcbiAgICAgIH0sXG4gICAgICBtZXRhOiB7fSxcbiAgICAgIG9uQmVmb3JlRmlsZUFkZGVkOiAoY3VycmVudEZpbGUpID0+IGN1cnJlbnRGaWxlLFxuICAgICAgb25CZWZvcmVVcGxvYWQ6IChmaWxlcykgPT4gZmlsZXMsXG4gICAgICBzdG9yZTogRGVmYXVsdFN0b3JlKCksXG4gICAgICBsb2dnZXI6IGp1c3RFcnJvcnNMb2dnZXIsXG4gICAgICBpbmZvVGltZW91dDogNTAwMCxcbiAgICB9XG5cbiAgICAvLyBNZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlcixcbiAgICAvLyBtYWtpbmcgc3VyZSB0byBtZXJnZSByZXN0cmljdGlvbnMgdG9vXG4gICAgdGhpcy5vcHRzID0ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRzLFxuICAgICAgcmVzdHJpY3Rpb25zOiB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLnJlc3RyaWN0aW9ucyxcbiAgICAgICAgLi4uKG9wdHMgJiYgb3B0cy5yZXN0cmljdGlvbnMpLFxuICAgICAgfSxcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IGRlYnVnOiB0cnVlIGZvciBiYWNrd2FyZHMtY29tcGF0YWJpbGl0eSwgdW5sZXNzIGxvZ2dlciBpcyBzZXQgaW4gb3B0c1xuICAgIC8vIG9wdHMgaW5zdGVhZCBvZiB0aGlzLm9wdHMgdG8gYXZvaWQgY29tcGFyaW5nIG9iamVjdHMg4oCUIHdlIHNldCBsb2dnZXI6IGp1c3RFcnJvcnNMb2dnZXIgaW4gZGVmYXVsdE9wdGlvbnNcbiAgICBpZiAob3B0cyAmJiBvcHRzLmxvZ2dlciAmJiBvcHRzLmRlYnVnKSB7XG4gICAgICB0aGlzLmxvZygnWW91IGFyZSB1c2luZyBhIGN1c3RvbSBgbG9nZ2VyYCwgYnV0IGFsc28gc2V0IGBkZWJ1ZzogdHJ1ZWAsIHdoaWNoIHVzZXMgYnVpbHQtaW4gbG9nZ2VyIHRvIG91dHB1dCBsb2dzIHRvIGNvbnNvbGUuIElnbm9yaW5nIGBkZWJ1ZzogdHJ1ZWAgYW5kIHVzaW5nIHlvdXIgY3VzdG9tIGBsb2dnZXJgLicsICd3YXJuaW5nJylcbiAgICB9IGVsc2UgaWYgKG9wdHMgJiYgb3B0cy5kZWJ1Zykge1xuICAgICAgdGhpcy5vcHRzLmxvZ2dlciA9IGRlYnVnTG9nZ2VyXG4gICAgfVxuXG4gICAgdGhpcy5sb2coYFVzaW5nIENvcmUgdiR7dGhpcy5jb25zdHJ1Y3Rvci5WRVJTSU9OfWApXG5cbiAgICBpZiAodGhpcy5vcHRzLnJlc3RyaWN0aW9ucy5hbGxvd2VkRmlsZVR5cGVzXG4gICAgICAgICYmIHRoaXMub3B0cy5yZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcyAhPT0gbnVsbFxuICAgICAgICAmJiAhQXJyYXkuaXNBcnJheSh0aGlzLm9wdHMucmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgcmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXNgIG11c3QgYmUgYW4gYXJyYXknKVxuICAgIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuXG4gICAgLy8gQ29udGFpbmVyIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgcGx1Z2luc1xuICAgIHRoaXMucGx1Z2lucyA9IHt9XG5cbiAgICB0aGlzLmdldFN0YXRlID0gdGhpcy5nZXRTdGF0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5nZXRQbHVnaW4gPSB0aGlzLmdldFBsdWdpbi5iaW5kKHRoaXMpXG4gICAgdGhpcy5zZXRGaWxlTWV0YSA9IHRoaXMuc2V0RmlsZU1ldGEuYmluZCh0aGlzKVxuICAgIHRoaXMuc2V0RmlsZVN0YXRlID0gdGhpcy5zZXRGaWxlU3RhdGUuYmluZCh0aGlzKVxuICAgIHRoaXMubG9nID0gdGhpcy5sb2cuYmluZCh0aGlzKVxuICAgIHRoaXMuaW5mbyA9IHRoaXMuaW5mby5iaW5kKHRoaXMpXG4gICAgdGhpcy5oaWRlSW5mbyA9IHRoaXMuaGlkZUluZm8uYmluZCh0aGlzKVxuICAgIHRoaXMuYWRkRmlsZSA9IHRoaXMuYWRkRmlsZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW1vdmVGaWxlID0gdGhpcy5yZW1vdmVGaWxlLmJpbmQodGhpcylcbiAgICB0aGlzLnBhdXNlUmVzdW1lID0gdGhpcy5wYXVzZVJlc3VtZS5iaW5kKHRoaXMpXG4gICAgdGhpcy52YWxpZGF0ZVJlc3RyaWN0aW9ucyA9IHRoaXMudmFsaWRhdGVSZXN0cmljdGlvbnMuYmluZCh0aGlzKVxuXG4gICAgLy8gX19fV2h5IHRocm90dGxlIGF0IDUwMG1zP1xuICAgIC8vICAgIC0gV2UgbXVzdCB0aHJvdHRsZSBhdCA+MjUwbXMgZm9yIHN1cGVyZm9jdXMgaW4gRGFzaGJvYXJkIHRvIHdvcmsgd2VsbFxuICAgIC8vICAgIChiZWNhdXNlIGFuaW1hdGlvbiB0YWtlcyAwLjI1cywgYW5kIHdlIHdhbnQgdG8gd2FpdCBmb3IgYWxsIGFuaW1hdGlvbnMgdG8gYmUgb3ZlciBiZWZvcmUgcmVmb2N1c2luZykuXG4gICAgLy8gICAgW1ByYWN0aWNhbCBDaGVja106IGlmIHRob3R0bGUgaXMgYXQgMTAwbXMsIHRoZW4gaWYgeW91IGFyZSB1cGxvYWRpbmcgYSBmaWxlLFxuICAgIC8vICAgIGFuZCBjbGljayAnQUREIE1PUkUgRklMRVMnLCAtIGZvY3VzIHdvbid0IGFjdGl2YXRlIGluIEZpcmVmb3guXG4gICAgLy8gICAgLSBXZSBtdXN0IHRocm90dGxlIGF0IGFyb3VuZCA+NTAwbXMgdG8gYXZvaWQgcGVyZm9ybWFuY2UgbGFncy5cbiAgICAvLyAgICBbUHJhY3RpY2FsIENoZWNrXSBGaXJlZm94LCB0cnkgdG8gdXBsb2FkIGEgYmlnIGZpbGUgZm9yIGEgcHJvbG9uZ2VkIHBlcmlvZCBvZiB0aW1lLiBMYXB0b3Agd2lsbCBzdGFydCB0byBoZWF0IHVwLlxuICAgIHRoaXMuY2FsY3VsYXRlUHJvZ3Jlc3MgPSB0aHJvdHRsZSh0aGlzLmNhbGN1bGF0ZVByb2dyZXNzLmJpbmQodGhpcyksIDUwMCwgeyBsZWFkaW5nOiB0cnVlLCB0cmFpbGluZzogdHJ1ZSB9KVxuXG4gICAgdGhpcy51cGRhdGVPbmxpbmVTdGF0dXMgPSB0aGlzLnVwZGF0ZU9ubGluZVN0YXR1cy5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZXNldFByb2dyZXNzID0gdGhpcy5yZXNldFByb2dyZXNzLmJpbmQodGhpcylcblxuICAgIHRoaXMucGF1c2VBbGwgPSB0aGlzLnBhdXNlQWxsLmJpbmQodGhpcylcbiAgICB0aGlzLnJlc3VtZUFsbCA9IHRoaXMucmVzdW1lQWxsLmJpbmQodGhpcylcbiAgICB0aGlzLnJldHJ5QWxsID0gdGhpcy5yZXRyeUFsbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5jYW5jZWxBbGwgPSB0aGlzLmNhbmNlbEFsbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZXRyeVVwbG9hZCA9IHRoaXMucmV0cnlVcGxvYWQuYmluZCh0aGlzKVxuICAgIHRoaXMudXBsb2FkID0gdGhpcy51cGxvYWQuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5lbWl0dGVyID0gZWUoKVxuICAgIHRoaXMub24gPSB0aGlzLm9uLmJpbmQodGhpcylcbiAgICB0aGlzLm9mZiA9IHRoaXMub2ZmLmJpbmQodGhpcylcbiAgICB0aGlzLm9uY2UgPSB0aGlzLmVtaXR0ZXIub25jZS5iaW5kKHRoaXMuZW1pdHRlcilcbiAgICB0aGlzLmVtaXQgPSB0aGlzLmVtaXR0ZXIuZW1pdC5iaW5kKHRoaXMuZW1pdHRlcilcblxuICAgIHRoaXMucHJlUHJvY2Vzc29ycyA9IFtdXG4gICAgdGhpcy51cGxvYWRlcnMgPSBbXVxuICAgIHRoaXMucG9zdFByb2Nlc3NvcnMgPSBbXVxuXG4gICAgdGhpcy5zdG9yZSA9IHRoaXMub3B0cy5zdG9yZVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgcGx1Z2luczoge30sXG4gICAgICBmaWxlczoge30sXG4gICAgICBjdXJyZW50VXBsb2Fkczoge30sXG4gICAgICBhbGxvd05ld1VwbG9hZDogdHJ1ZSxcbiAgICAgIGNhcGFiaWxpdGllczoge1xuICAgICAgICB1cGxvYWRQcm9ncmVzczogc3VwcG9ydHNVcGxvYWRQcm9ncmVzcygpLFxuICAgICAgICBpbmRpdmlkdWFsQ2FuY2VsbGF0aW9uOiB0cnVlLFxuICAgICAgICByZXN1bWFibGVVcGxvYWRzOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICB0b3RhbFByb2dyZXNzOiAwLFxuICAgICAgbWV0YTogeyAuLi50aGlzLm9wdHMubWV0YSB9LFxuICAgICAgaW5mbzoge1xuICAgICAgICBpc0hpZGRlbjogdHJ1ZSxcbiAgICAgICAgdHlwZTogJ2luZm8nLFxuICAgICAgICBtZXNzYWdlOiAnJyxcbiAgICAgIH0sXG4gICAgICByZWNvdmVyZWRTdGF0ZTogbnVsbCxcbiAgICB9KVxuXG4gICAgdGhpcy5zdG9yZVVuc3Vic2NyaWJlID0gdGhpcy5zdG9yZS5zdWJzY3JpYmUoKHByZXZTdGF0ZSwgbmV4dFN0YXRlLCBwYXRjaCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdzdGF0ZS11cGRhdGUnLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSwgcGF0Y2gpXG4gICAgICB0aGlzLnVwZGF0ZUFsbChuZXh0U3RhdGUpXG4gICAgfSlcblxuICAgIC8vIEV4cG9zaW5nIHVwcHkgb2JqZWN0IG9uIHdpbmRvdyBmb3IgZGVidWdnaW5nIGFuZCB0ZXN0aW5nXG4gICAgaWYgKHRoaXMub3B0cy5kZWJ1ZyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93W3RoaXMub3B0cy5pZF0gPSB0aGlzXG4gICAgfVxuXG4gICAgdGhpcy5hZGRMaXN0ZW5lcnMoKVxuXG4gICAgLy8gUmUtZW5hYmxlIGlmIHdl4oCZbGwgbmVlZCBzb21lIGNhcGFiaWxpdGllcyBvbiBib290LCBsaWtlIGlzTW9iaWxlRGV2aWNlXG4gICAgLy8gdGhpcy5fc2V0Q2FwYWJpbGl0aWVzKClcbiAgfVxuXG4gIC8vIF9zZXRDYXBhYmlsaXRpZXMgPSAoKSA9PiB7XG4gIC8vICAgY29uc3QgY2FwYWJpbGl0aWVzID0ge1xuICAvLyAgICAgaXNNb2JpbGVEZXZpY2U6IGlzTW9iaWxlRGV2aWNlKClcbiAgLy8gICB9XG5cbiAgLy8gICB0aGlzLnNldFN0YXRlKHtcbiAgLy8gICAgIC4uLnRoaXMuZ2V0U3RhdGUoKS5jYXBhYmlsaXRpZXMsXG4gIC8vICAgICBjYXBhYmlsaXRpZXNcbiAgLy8gICB9KVxuICAvLyB9XG5cbiAgb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlci5vbihldmVudCwgY2FsbGJhY2spXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG9mZiAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9mZihldmVudCwgY2FsbGJhY2spXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG9uIGFsbCBwbHVnaW5zIGFuZCBydW4gYHVwZGF0ZWAgb24gdGhlbS5cbiAgICogQ2FsbGVkIGVhY2ggdGltZSBzdGF0ZSBjaGFuZ2VzLlxuICAgKlxuICAgKi9cbiAgdXBkYXRlQWxsIChzdGF0ZSkge1xuICAgIHRoaXMuaXRlcmF0ZVBsdWdpbnMocGx1Z2luID0+IHtcbiAgICAgIHBsdWdpbi51cGRhdGUoc3RhdGUpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHN0YXRlIHdpdGggYSBwYXRjaFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGF0Y2gge2ZvbzogJ2Jhcid9XG4gICAqL1xuICBzZXRTdGF0ZSAocGF0Y2gpIHtcbiAgICB0aGlzLnN0b3JlLnNldFN0YXRlKHBhdGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY3VycmVudCBzdGF0ZS5cbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGdldFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogQmFjayBjb21wYXQgZm9yIHdoZW4gdXBweS5zdGF0ZSBpcyB1c2VkIGluc3RlYWQgb2YgdXBweS5nZXRTdGF0ZSgpLlxuICAgKi9cbiAgZ2V0IHN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogU2hvcnRoYW5kIHRvIHNldCBzdGF0ZSBmb3IgYSBzcGVjaWZpYyBmaWxlLlxuICAgKi9cbiAgc2V0RmlsZVN0YXRlIChmaWxlSUQsIHN0YXRlKSB7XG4gICAgaWYgKCF0aGlzLmdldFN0YXRlKCkuZmlsZXNbZmlsZUlEXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW7igJl0IHNldCBzdGF0ZSBmb3IgJHtmaWxlSUR9ICh0aGUgZmlsZSBjb3VsZCBoYXZlIGJlZW4gcmVtb3ZlZClgKVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZmlsZXM6IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzLCBbZmlsZUlEXTogeyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXNbZmlsZUlEXSwgLi4uc3RhdGUgfSB9LFxuICAgIH0pXG4gIH1cblxuICBpMThuSW5pdCAoKSB7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoW3RoaXMuZGVmYXVsdExvY2FsZSwgdGhpcy5vcHRzLmxvY2FsZV0pXG4gICAgdGhpcy5sb2NhbGUgPSB0aGlzLnRyYW5zbGF0b3IubG9jYWxlXG4gICAgdGhpcy5pMThuID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLmkxOG5BcnJheSA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGVBcnJheS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgfVxuXG4gIHNldE9wdGlvbnMgKG5ld09wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSB7XG4gICAgICAuLi50aGlzLm9wdHMsXG4gICAgICAuLi5uZXdPcHRzLFxuICAgICAgcmVzdHJpY3Rpb25zOiB7XG4gICAgICAgIC4uLnRoaXMub3B0cy5yZXN0cmljdGlvbnMsXG4gICAgICAgIC4uLihuZXdPcHRzICYmIG5ld09wdHMucmVzdHJpY3Rpb25zKSxcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgaWYgKG5ld09wdHMubWV0YSkge1xuICAgICAgdGhpcy5zZXRNZXRhKG5ld09wdHMubWV0YSlcbiAgICB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcblxuICAgIGlmIChuZXdPcHRzLmxvY2FsZSkge1xuICAgICAgdGhpcy5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICAgIHBsdWdpbi5zZXRPcHRpb25zKClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gTm90ZTogdGhpcyBpcyBub3QgdGhlIHByZWFjdCBgc2V0U3RhdGVgLCBpdCdzIGFuIGludGVybmFsIGZ1bmN0aW9uIHRoYXQgaGFzIHRoZSBzYW1lIG5hbWUuXG4gICAgdGhpcy5zZXRTdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyB3aXRoIG5ldyBvcHRpb25zXG4gIH1cblxuICByZXNldFByb2dyZXNzICgpIHtcbiAgICBjb25zdCBkZWZhdWx0UHJvZ3Jlc3MgPSB7XG4gICAgICBwZXJjZW50YWdlOiAwLFxuICAgICAgYnl0ZXNVcGxvYWRlZDogMCxcbiAgICAgIHVwbG9hZENvbXBsZXRlOiBmYWxzZSxcbiAgICAgIHVwbG9hZFN0YXJ0ZWQ6IG51bGwsXG4gICAgfVxuICAgIGNvbnN0IGZpbGVzID0geyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMgfVxuICAgIGNvbnN0IHVwZGF0ZWRGaWxlcyA9IHt9XG4gICAgT2JqZWN0LmtleXMoZmlsZXMpLmZvckVhY2goZmlsZUlEID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRGaWxlID0geyAuLi5maWxlc1tmaWxlSURdIH1cbiAgICAgIHVwZGF0ZWRGaWxlLnByb2dyZXNzID0geyAuLi51cGRhdGVkRmlsZS5wcm9ncmVzcywgLi4uZGVmYXVsdFByb2dyZXNzIH1cbiAgICAgIHVwZGF0ZWRGaWxlc1tmaWxlSURdID0gdXBkYXRlZEZpbGVcbiAgICB9KVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBmaWxlczogdXBkYXRlZEZpbGVzLFxuICAgICAgdG90YWxQcm9ncmVzczogMCxcbiAgICB9KVxuXG4gICAgdGhpcy5lbWl0KCdyZXNldC1wcm9ncmVzcycpXG4gIH1cblxuICBhZGRQcmVQcm9jZXNzb3IgKGZuKSB7XG4gICAgdGhpcy5wcmVQcm9jZXNzb3JzLnB1c2goZm4pXG4gIH1cblxuICByZW1vdmVQcmVQcm9jZXNzb3IgKGZuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMucHJlUHJvY2Vzc29ycy5pbmRleE9mKGZuKVxuICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgdGhpcy5wcmVQcm9jZXNzb3JzLnNwbGljZShpLCAxKVxuICAgIH1cbiAgfVxuXG4gIGFkZFBvc3RQcm9jZXNzb3IgKGZuKSB7XG4gICAgdGhpcy5wb3N0UHJvY2Vzc29ycy5wdXNoKGZuKVxuICB9XG5cbiAgcmVtb3ZlUG9zdFByb2Nlc3NvciAoZm4pIHtcbiAgICBjb25zdCBpID0gdGhpcy5wb3N0UHJvY2Vzc29ycy5pbmRleE9mKGZuKVxuICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgdGhpcy5wb3N0UHJvY2Vzc29ycy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gIH1cblxuICBhZGRVcGxvYWRlciAoZm4pIHtcbiAgICB0aGlzLnVwbG9hZGVycy5wdXNoKGZuKVxuICB9XG5cbiAgcmVtb3ZlVXBsb2FkZXIgKGZuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMudXBsb2FkZXJzLmluZGV4T2YoZm4pXG4gICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICB0aGlzLnVwbG9hZGVycy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gIH1cblxuICBzZXRNZXRhIChkYXRhKSB7XG4gICAgY29uc3QgdXBkYXRlZE1ldGEgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5tZXRhLCAuLi5kYXRhIH1cbiAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcyB9XG5cbiAgICBPYmplY3Qua2V5cyh1cGRhdGVkRmlsZXMpLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgdXBkYXRlZEZpbGVzW2ZpbGVJRF0gPSB7IC4uLnVwZGF0ZWRGaWxlc1tmaWxlSURdLCBtZXRhOiB7IC4uLnVwZGF0ZWRGaWxlc1tmaWxlSURdLm1ldGEsIC4uLmRhdGEgfSB9XG4gICAgfSlcblxuICAgIHRoaXMubG9nKCdBZGRpbmcgbWV0YWRhdGE6JylcbiAgICB0aGlzLmxvZyhkYXRhKVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtZXRhOiB1cGRhdGVkTWV0YSxcbiAgICAgIGZpbGVzOiB1cGRhdGVkRmlsZXMsXG4gICAgfSlcbiAgfVxuXG4gIHNldEZpbGVNZXRhIChmaWxlSUQsIGRhdGEpIHtcbiAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcyB9XG4gICAgaWYgKCF1cGRhdGVkRmlsZXNbZmlsZUlEXSkge1xuICAgICAgdGhpcy5sb2coJ1dhcyB0cnlpbmcgdG8gc2V0IG1ldGFkYXRhIGZvciBhIGZpbGUgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAnLCBmaWxlSUQpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgbmV3TWV0YSA9IHsgLi4udXBkYXRlZEZpbGVzW2ZpbGVJRF0ubWV0YSwgLi4uZGF0YSB9XG4gICAgdXBkYXRlZEZpbGVzW2ZpbGVJRF0gPSB7IC4uLnVwZGF0ZWRGaWxlc1tmaWxlSURdLCBtZXRhOiBuZXdNZXRhIH1cbiAgICB0aGlzLnNldFN0YXRlKHsgZmlsZXM6IHVwZGF0ZWRGaWxlcyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGZpbGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIFRoZSBJRCBvZiB0aGUgZmlsZSBvYmplY3QgdG8gcmV0dXJuLlxuICAgKi9cbiAgZ2V0RmlsZSAoZmlsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKS5maWxlc1tmaWxlSURdXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBmaWxlcyBpbiBhbiBhcnJheS5cbiAgICovXG4gIGdldEZpbGVzICgpIHtcbiAgICBjb25zdCB7IGZpbGVzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZmlsZXMpLm1hcCgoZmlsZUlEKSA9PiBmaWxlc1tmaWxlSURdKVxuICB9XG5cbiAgLyoqXG4gICAqIEEgcHVibGljIHdyYXBwZXIgZm9yIF9jaGVja1Jlc3RyaWN0aW9ucyDigJQgY2hlY2tzIGlmIGEgZmlsZSBwYXNzZXMgYSBzZXQgb2YgcmVzdHJpY3Rpb25zLlxuICAgKiBGb3IgdXNlIGluIFVJIHBsdWlnaW5zIChsaWtlIFByb3ZpZGVycyksIHRvIGRpc2FsbG93IHNlbGVjdGluZyBmaWxlcyB0aGF0IHdvbuKAmXQgcGFzcyByZXN0cmljdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlIG9iamVjdCB0byBjaGVja1xuICAgKiBAcGFyYW0ge0FycmF5fSBbZmlsZXNdIGFycmF5IHRvIGNoZWNrIG1heE51bWJlck9mRmlsZXMgYW5kIG1heFRvdGFsRmlsZVNpemVcbiAgICogQHJldHVybnMge29iamVjdH0geyByZXN1bHQ6IHRydWUvZmFsc2UsIHJlYXNvbjogd2h5IGZpbGUgZGlkbuKAmXQgcGFzcyByZXN0cmljdGlvbnMgfVxuICAgKi9cbiAgdmFsaWRhdGVSZXN0cmljdGlvbnMgKGZpbGUsIGZpbGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY2hlY2tSZXN0cmljdGlvbnMoZmlsZSwgZmlsZXMpXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICByZWFzb246IGVyci5tZXNzYWdlLFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBmaWxlIHBhc3NlcyBhIHNldCBvZiByZXN0cmljdGlvbnMgc2V0IGluIG9wdGlvbnM6IG1heEZpbGVTaXplLCBtaW5GaWxlU2l6ZSxcbiAgICogbWF4TnVtYmVyT2ZGaWxlcyBhbmQgYWxsb3dlZEZpbGVUeXBlcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGZpbGUgb2JqZWN0IHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtmaWxlc10gYXJyYXkgdG8gY2hlY2sgbWF4TnVtYmVyT2ZGaWxlcyBhbmQgbWF4VG90YWxGaWxlU2l6ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2hlY2tSZXN0cmljdGlvbnMgKGZpbGUsIGZpbGVzID0gdGhpcy5nZXRGaWxlcygpKSB7XG4gICAgY29uc3QgeyBtYXhGaWxlU2l6ZSwgbWluRmlsZVNpemUsIG1heFRvdGFsRmlsZVNpemUsIG1heE51bWJlck9mRmlsZXMsIGFsbG93ZWRGaWxlVHlwZXMgfSA9IHRoaXMub3B0cy5yZXN0cmljdGlvbnNcblxuICAgIGlmIChtYXhOdW1iZXJPZkZpbGVzKSB7XG4gICAgICBpZiAoZmlsZXMubGVuZ3RoICsgMSA+IG1heE51bWJlck9mRmlsZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlc3RyaWN0aW9uRXJyb3IoYCR7dGhpcy5pMThuKCd5b3VDYW5Pbmx5VXBsb2FkWCcsIHsgc21hcnRfY291bnQ6IG1heE51bWJlck9mRmlsZXMgfSl9YClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWxsb3dlZEZpbGVUeXBlcykge1xuICAgICAgY29uc3QgaXNDb3JyZWN0RmlsZVR5cGUgPSBhbGxvd2VkRmlsZVR5cGVzLnNvbWUoKHR5cGUpID0+IHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIG1pbWUtdHlwZVxuICAgICAgICBpZiAodHlwZS5pbmRleE9mKCcvJykgPiAtMSkge1xuICAgICAgICAgIGlmICghZmlsZS50eXBlKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICByZXR1cm4gbWF0Y2goZmlsZS50eXBlLnJlcGxhY2UoLzsuKj8kLywgJycpLCB0eXBlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoaXMgaXMgbGlrZWx5IGFuIGV4dGVuc2lvblxuICAgICAgICBpZiAodHlwZVswXSA9PT0gJy4nICYmIGZpbGUuZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbGUuZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkgPT09IHR5cGUuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0pXG5cbiAgICAgIGlmICghaXNDb3JyZWN0RmlsZVR5cGUpIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZEZpbGVUeXBlc1N0cmluZyA9IGFsbG93ZWRGaWxlVHlwZXMuam9pbignLCAnKVxuICAgICAgICB0aHJvdyBuZXcgUmVzdHJpY3Rpb25FcnJvcih0aGlzLmkxOG4oJ3lvdUNhbk9ubHlVcGxvYWRGaWxlVHlwZXMnLCB7IHR5cGVzOiBhbGxvd2VkRmlsZVR5cGVzU3RyaW5nIH0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IGNoZWNrIG1heFRvdGFsRmlsZVNpemUgaWYgdGhlIHNpemUgaXMgdW5rbm93bi5cbiAgICBpZiAobWF4VG90YWxGaWxlU2l6ZSAmJiBmaWxlLnNpemUgIT0gbnVsbCkge1xuICAgICAgbGV0IHRvdGFsRmlsZXNTaXplID0gMFxuICAgICAgdG90YWxGaWxlc1NpemUgKz0gZmlsZS5zaXplXG4gICAgICBmaWxlcy5mb3JFYWNoKChmKSA9PiB7XG4gICAgICAgIHRvdGFsRmlsZXNTaXplICs9IGYuc2l6ZVxuICAgICAgfSlcbiAgICAgIGlmICh0b3RhbEZpbGVzU2l6ZSA+IG1heFRvdGFsRmlsZVNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlc3RyaWN0aW9uRXJyb3IodGhpcy5pMThuKCdleGNlZWRzU2l6ZTInLCB7XG4gICAgICAgICAgYmFja3dhcmRzQ29tcGF0OiB0aGlzLmkxOG4oJ2V4Y2VlZHNTaXplJyksXG4gICAgICAgICAgc2l6ZTogcHJldHRpZXJCeXRlcyhtYXhUb3RhbEZpbGVTaXplKSxcbiAgICAgICAgICBmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IGNoZWNrIG1heEZpbGVTaXplIGlmIHRoZSBzaXplIGlzIHVua25vd24uXG4gICAgaWYgKG1heEZpbGVTaXplICYmIGZpbGUuc2l6ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoZmlsZS5zaXplID4gbWF4RmlsZVNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlc3RyaWN0aW9uRXJyb3IodGhpcy5pMThuKCdleGNlZWRzU2l6ZTInLCB7XG4gICAgICAgICAgYmFja3dhcmRzQ29tcGF0OiB0aGlzLmkxOG4oJ2V4Y2VlZHNTaXplJyksXG4gICAgICAgICAgc2l6ZTogcHJldHRpZXJCeXRlcyhtYXhGaWxlU2l6ZSksXG4gICAgICAgICAgZmlsZTogZmlsZS5uYW1lLFxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBjYW4ndCBjaGVjayBtaW5GaWxlU2l6ZSBpZiB0aGUgc2l6ZSBpcyB1bmtub3duLlxuICAgIGlmIChtaW5GaWxlU2l6ZSAmJiBmaWxlLnNpemUgIT0gbnVsbCkge1xuICAgICAgaWYgKGZpbGUuc2l6ZSA8IG1pbkZpbGVTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXN0cmljdGlvbkVycm9yKHRoaXMuaTE4bignaW5mZXJpb3JTaXplJywge1xuICAgICAgICAgIHNpemU6IHByZXR0aWVyQnl0ZXMobWluRmlsZVNpemUpLFxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgbWluTnVtYmVyT2ZGaWxlcyByZXN0cmljdGlvbiBpcyByZWFjaGVkIGJlZm9yZSB1cGxvYWRpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjaGVja01pbk51bWJlck9mRmlsZXMgKGZpbGVzKSB7XG4gICAgY29uc3QgeyBtaW5OdW1iZXJPZkZpbGVzIH0gPSB0aGlzLm9wdHMucmVzdHJpY3Rpb25zXG4gICAgaWYgKE9iamVjdC5rZXlzKGZpbGVzKS5sZW5ndGggPCBtaW5OdW1iZXJPZkZpbGVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmVzdHJpY3Rpb25FcnJvcihgJHt0aGlzLmkxOG4oJ3lvdUhhdmVUb0F0TGVhc3RTZWxlY3RYJywgeyBzbWFydF9jb3VudDogbWluTnVtYmVyT2ZGaWxlcyB9KX1gKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGFuIGVycm9yLCBzZXRzIEluZm9ybWVyIG1lc3NhZ2UsIHRoZW4gdGhyb3dzIHRoZSBlcnJvci5cbiAgICogRW1pdHMgYSAncmVzdHJpY3Rpb24tZmFpbGVkJyBldmVudCBpZiBpdOKAmXMgYSByZXN0cmljdGlvbiBlcnJvclxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdCB8IHN0cmluZ30gZXJyIOKAlCBFcnJvciBvYmplY3Qgb3IgcGxhaW4gc3RyaW5nIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNob3dJbmZvcm1lcj10cnVlXSDigJQgU29tZXRpbWVzIGRldmVsb3BlciBtaWdodCB3YW50IHRvIHNob3cgSW5mb3JtZXIgbWFudWFsbHlcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmZpbGU9bnVsbF0g4oCUIEZpbGUgb2JqZWN0IHVzZWQgdG8gZW1pdCB0aGUgcmVzdHJpY3Rpb24gZXJyb3JcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50aHJvd0Vycj10cnVlXSDigJQgRXJyb3JzIHNob3VsZG7igJl0IGJlIHRocm93biwgZm9yIGV4YW1wbGUsIGluIGB1cGxvYWQtZXJyb3JgIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzaG93T3JMb2dFcnJvckFuZFRocm93IChlcnIsIHsgc2hvd0luZm9ybWVyID0gdHJ1ZSwgZmlsZSA9IG51bGwsIHRocm93RXJyID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdHlwZW9mIGVyciA9PT0gJ29iamVjdCcgPyBlcnIubWVzc2FnZSA6IGVyclxuICAgIGNvbnN0IGRldGFpbHMgPSAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgZXJyLmRldGFpbHMpID8gZXJyLmRldGFpbHMgOiAnJ1xuXG4gICAgLy8gUmVzdHJpY3Rpb24gZXJyb3JzIHNob3VsZCBiZSBsb2dnZWQsIGJ1dCBub3QgYXMgZXJyb3JzLFxuICAgIC8vIGFzIHRoZXkgYXJlIGV4cGVjdGVkIGFuZCBzaG93biBpbiB0aGUgVUkuXG4gICAgbGV0IGxvZ01lc3NhZ2VXaXRoRGV0YWlscyA9IG1lc3NhZ2VcbiAgICBpZiAoZGV0YWlscykge1xuICAgICAgbG9nTWVzc2FnZVdpdGhEZXRhaWxzICs9IGAgJHtkZXRhaWxzfWBcbiAgICB9XG4gICAgaWYgKGVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICB0aGlzLmxvZyhsb2dNZXNzYWdlV2l0aERldGFpbHMpXG4gICAgICB0aGlzLmVtaXQoJ3Jlc3RyaWN0aW9uLWZhaWxlZCcsIGZpbGUsIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2cobG9nTWVzc2FnZVdpdGhEZXRhaWxzLCAnZXJyb3InKVxuICAgIH1cblxuICAgIC8vIFNvbWV0aW1lcyBpbmZvcm1lciBoYXMgdG8gYmUgc2hvd24gbWFudWFsbHkgYnkgdGhlIGRldmVsb3BlcixcbiAgICAvLyBmb3IgZXhhbXBsZSwgaW4gYG9uQmVmb3JlRmlsZUFkZGVkYC5cbiAgICBpZiAoc2hvd0luZm9ybWVyKSB7XG4gICAgICB0aGlzLmluZm8oeyBtZXNzYWdlLCBkZXRhaWxzIH0sICdlcnJvcicsIHRoaXMub3B0cy5pbmZvVGltZW91dClcbiAgICB9XG5cbiAgICBpZiAodGhyb3dFcnIpIHtcbiAgICAgIHRocm93ICh0eXBlb2YgZXJyID09PSAnb2JqZWN0JyA/IGVyciA6IG5ldyBFcnJvcihlcnIpKVxuICAgIH1cbiAgfVxuXG4gIGFzc2VydE5ld1VwbG9hZEFsbG93ZWQgKGZpbGUpIHtcbiAgICBjb25zdCB7IGFsbG93TmV3VXBsb2FkIH0gPSB0aGlzLmdldFN0YXRlKClcblxuICAgIGlmIChhbGxvd05ld1VwbG9hZCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhuZXcgUmVzdHJpY3Rpb25FcnJvcih0aGlzLmkxOG4oJ25vTmV3QWxyZWFkeVVwbG9hZGluZycpKSwgeyBmaWxlIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZpbGUgc3RhdGUgb2JqZWN0IGJhc2VkIG9uIHVzZXItcHJvdmlkZWQgYGFkZEZpbGUoKWAgb3B0aW9ucy5cbiAgICpcbiAgICogTm90ZSB0aGlzIGlzIGV4dHJlbWVseSBzaWRlLWVmZmVjdGZ1bCBhbmQgc2hvdWxkIG9ubHkgYmUgZG9uZSB3aGVuIGEgZmlsZSBzdGF0ZSBvYmplY3Qgd2lsbCBiZSBhZGRlZCB0byBzdGF0ZSBpbW1lZGlhdGVseSBhZnRlcndhcmQhXG4gICAqXG4gICAqIFRoZSBgZmlsZXNgIHZhbHVlIGlzIHBhc3NlZCBpbiBiZWNhdXNlIGl0IG1heSBiZSB1cGRhdGVkIGJ5IHRoZSBjYWxsZXIgd2l0aG91dCB1cGRhdGluZyB0aGUgc3RvcmUuXG4gICAqL1xuICBjaGVja0FuZENyZWF0ZUZpbGVTdGF0ZU9iamVjdCAoZmlsZXMsIGYpIHtcbiAgICBjb25zdCBmaWxlVHlwZSA9IGdldEZpbGVUeXBlKGYpXG4gICAgbGV0IGZpbGUgPSBmXG4gICAgZmlsZS50eXBlID0gZmlsZVR5cGVcblxuICAgIGNvbnN0IG9uQmVmb3JlRmlsZUFkZGVkUmVzdWx0ID0gdGhpcy5vcHRzLm9uQmVmb3JlRmlsZUFkZGVkKGZpbGUsIGZpbGVzKVxuXG4gICAgaWYgKG9uQmVmb3JlRmlsZUFkZGVkUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgLy8gRG9u4oCZdCBzaG93IFVJIGluZm8gZm9yIHRoaXMgZXJyb3IsIGFzIGl0IHNob3VsZCBiZSBkb25lIGJ5IHRoZSBkZXZlbG9wZXJcbiAgICAgIHRoaXMuc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhuZXcgUmVzdHJpY3Rpb25FcnJvcignQ2Fubm90IGFkZCB0aGUgZmlsZSBiZWNhdXNlIG9uQmVmb3JlRmlsZUFkZGVkIHJldHVybmVkIGZhbHNlLicpLCB7IHNob3dJbmZvcm1lcjogZmFsc2UsIGZpbGUgfSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9uQmVmb3JlRmlsZUFkZGVkUmVzdWx0ID09PSAnb2JqZWN0JyAmJiBvbkJlZm9yZUZpbGVBZGRlZFJlc3VsdCkge1xuICAgICAgZmlsZSA9IG9uQmVmb3JlRmlsZUFkZGVkUmVzdWx0XG4gICAgfVxuXG4gICAgbGV0IGZpbGVOYW1lXG4gICAgaWYgKGZpbGUubmFtZSkge1xuICAgICAgZmlsZU5hbWUgPSBmaWxlLm5hbWVcbiAgICB9IGVsc2UgaWYgKGZpbGVUeXBlLnNwbGl0KCcvJylbMF0gPT09ICdpbWFnZScpIHtcbiAgICAgIGZpbGVOYW1lID0gYCR7ZmlsZVR5cGUuc3BsaXQoJy8nKVswXX0uJHtmaWxlVHlwZS5zcGxpdCgnLycpWzFdfWBcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsZU5hbWUgPSAnbm9uYW1lJ1xuICAgIH1cbiAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24oZmlsZU5hbWUpLmV4dGVuc2lvblxuICAgIGNvbnN0IGlzUmVtb3RlID0gZmlsZS5pc1JlbW90ZSB8fCBmYWxzZVxuXG4gICAgY29uc3QgZmlsZUlEID0gZ2VuZXJhdGVGaWxlSUQoZmlsZSlcblxuICAgIGlmIChmaWxlc1tmaWxlSURdICYmICFmaWxlc1tmaWxlSURdLmlzR2hvc3QpIHtcbiAgICAgIHRoaXMuc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhuZXcgUmVzdHJpY3Rpb25FcnJvcih0aGlzLmkxOG4oJ25vRHVwbGljYXRlcycsIHsgZmlsZU5hbWUgfSkpLCB7IGZpbGUgfSlcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhID0gZmlsZS5tZXRhIHx8IHt9XG4gICAgbWV0YS5uYW1lID0gZmlsZU5hbWVcbiAgICBtZXRhLnR5cGUgPSBmaWxlVHlwZVxuXG4gICAgLy8gYG51bGxgIG1lYW5zIHRoZSBzaXplIGlzIHVua25vd24uXG4gICAgY29uc3Qgc2l6ZSA9IE51bWJlci5pc0Zpbml0ZShmaWxlLmRhdGEuc2l6ZSkgPyBmaWxlLmRhdGEuc2l6ZSA6IG51bGxcbiAgICBjb25zdCBuZXdGaWxlID0ge1xuICAgICAgc291cmNlOiBmaWxlLnNvdXJjZSB8fCAnJyxcbiAgICAgIGlkOiBmaWxlSUQsXG4gICAgICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgIGV4dGVuc2lvbjogZmlsZUV4dGVuc2lvbiB8fCAnJyxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4udGhpcy5nZXRTdGF0ZSgpLm1ldGEsXG4gICAgICAgIC4uLm1ldGEsXG4gICAgICB9LFxuICAgICAgdHlwZTogZmlsZVR5cGUsXG4gICAgICBkYXRhOiBmaWxlLmRhdGEsXG4gICAgICBwcm9ncmVzczoge1xuICAgICAgICBwZXJjZW50YWdlOiAwLFxuICAgICAgICBieXRlc1VwbG9hZGVkOiAwLFxuICAgICAgICBieXRlc1RvdGFsOiBzaXplLFxuICAgICAgICB1cGxvYWRDb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIHVwbG9hZFN0YXJ0ZWQ6IG51bGwsXG4gICAgICB9LFxuICAgICAgc2l6ZSxcbiAgICAgIGlzUmVtb3RlLFxuICAgICAgcmVtb3RlOiBmaWxlLnJlbW90ZSB8fCAnJyxcbiAgICAgIHByZXZpZXc6IGZpbGUucHJldmlldyxcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZmlsZXNBcnJheSA9IE9iamVjdC5rZXlzKGZpbGVzKS5tYXAoaSA9PiBmaWxlc1tpXSlcbiAgICAgIHRoaXMuY2hlY2tSZXN0cmljdGlvbnMobmV3RmlsZSwgZmlsZXNBcnJheSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhlcnIsIHsgZmlsZTogbmV3RmlsZSB9KVxuICAgIH1cblxuICAgIHJldHVybiBuZXdGaWxlXG4gIH1cblxuICAvLyBTY2hlZHVsZSBhbiB1cGxvYWQgaWYgYGF1dG9Qcm9jZWVkYCBpcyBlbmFibGVkLlxuICBzdGFydElmQXV0b1Byb2NlZWQgKCkge1xuICAgIGlmICh0aGlzLm9wdHMuYXV0b1Byb2NlZWQgJiYgIXRoaXMuc2NoZWR1bGVkQXV0b1Byb2NlZWQpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVkQXV0b1Byb2NlZWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWRBdXRvUHJvY2VlZCA9IG51bGxcbiAgICAgICAgdGhpcy51cGxvYWQoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICAgICAgdGhpcy5sb2coZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlIHx8IGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9LCA0KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgZmlsZSB0byBgc3RhdGUuZmlsZXNgLiBUaGlzIHdpbGwgcnVuIGBvbkJlZm9yZUZpbGVBZGRlZGAsXG4gICAqIHRyeSB0byBndWVzcyBmaWxlIHR5cGUgaW4gYSBjbGV2ZXIgd2F5LCBjaGVjayBmaWxlIGFnYWluc3QgcmVzdHJpY3Rpb25zLFxuICAgKiBhbmQgc3RhcnQgYW4gdXBsb2FkIGlmIGBhdXRvUHJvY2VlZCA9PT0gdHJ1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlIG9iamVjdCB0byBhZGRcbiAgICogQHJldHVybnMge3N0cmluZ30gaWQgZm9yIHRoZSBhZGRlZCBmaWxlXG4gICAqL1xuICBhZGRGaWxlIChmaWxlKSB7XG4gICAgdGhpcy5hc3NlcnROZXdVcGxvYWRBbGxvd2VkKGZpbGUpXG5cbiAgICBjb25zdCB7IGZpbGVzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICBsZXQgbmV3RmlsZSA9IHRoaXMuY2hlY2tBbmRDcmVhdGVGaWxlU3RhdGVPYmplY3QoZmlsZXMsIGZpbGUpXG5cbiAgICAvLyBVc2VycyBhcmUgYXNrZWQgdG8gcmUtc2VsZWN0IHJlY292ZXJlZCBmaWxlcyB3aXRob3V0IGRhdGEsXG4gICAgLy8gYW5kIHRvIGtlZXAgdGhlIHByb2dyZXNzLCBtZXRhIGFuZCBldmVydGhpbmcgZWxzZSwgd2Ugb25seSByZXBsYWNlIHNhaWQgZGF0YVxuICAgIGlmIChmaWxlc1tuZXdGaWxlLmlkXSAmJiBmaWxlc1tuZXdGaWxlLmlkXS5pc0dob3N0KSB7XG4gICAgICBuZXdGaWxlID0ge1xuICAgICAgICAuLi5maWxlc1tuZXdGaWxlLmlkXSxcbiAgICAgICAgZGF0YTogZmlsZS5kYXRhLFxuICAgICAgICBpc0dob3N0OiBmYWxzZSxcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKGBSZXBsYWNlZCB0aGUgYmxvYiBpbiB0aGUgcmVzdG9yZWQgZ2hvc3QgZmlsZTogJHtuZXdGaWxlLm5hbWV9LCAke25ld0ZpbGUuaWR9YClcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZpbGVzOiB7XG4gICAgICAgIC4uLmZpbGVzLFxuICAgICAgICBbbmV3RmlsZS5pZF06IG5ld0ZpbGUsXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICB0aGlzLmVtaXQoJ2ZpbGUtYWRkZWQnLCBuZXdGaWxlKVxuICAgIHRoaXMuZW1pdCgnZmlsZXMtYWRkZWQnLCBbbmV3RmlsZV0pXG4gICAgdGhpcy5sb2coYEFkZGVkIGZpbGU6ICR7bmV3RmlsZS5uYW1lfSwgJHtuZXdGaWxlLmlkfSwgbWltZSB0eXBlOiAke25ld0ZpbGUudHlwZX1gKVxuXG4gICAgdGhpcy5zdGFydElmQXV0b1Byb2NlZWQoKVxuXG4gICAgcmV0dXJuIG5ld0ZpbGUuaWRcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbXVsdGlwbGUgZmlsZXMgdG8gYHN0YXRlLmZpbGVzYC4gU2VlIHRoZSBgYWRkRmlsZSgpYCBkb2N1bWVudGF0aW9uLlxuICAgKlxuICAgKiBJZiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgYWRkaW5nIGEgZmlsZSwgaXQgaXMgbG9nZ2VkIGFuZCB0aGUgdXNlciBpcyBub3RpZmllZC5cbiAgICogVGhpcyBpcyBnb29kIGZvciBVSSBwbHVnaW5zLCBidXQgbm90IGZvciBwcm9ncmFtbWF0aWMgdXNlLlxuICAgKiBQcm9ncmFtbWF0aWMgdXNlcnMgc2hvdWxkIHVzdWFsbHkgc3RpbGwgdXNlIGBhZGRGaWxlKClgIG9uIGluZGl2aWR1YWwgZmlsZXMuXG4gICAqL1xuICBhZGRGaWxlcyAoZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgdGhpcy5hc3NlcnROZXdVcGxvYWRBbGxvd2VkKClcblxuICAgIC8vIGNyZWF0ZSBhIGNvcHkgb2YgdGhlIGZpbGVzIG9iamVjdCBvbmx5IG9uY2VcbiAgICBjb25zdCBmaWxlcyA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzIH1cbiAgICBjb25zdCBuZXdGaWxlcyA9IFtdXG4gICAgY29uc3QgZXJyb3JzID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVEZXNjcmlwdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IG5ld0ZpbGUgPSB0aGlzLmNoZWNrQW5kQ3JlYXRlRmlsZVN0YXRlT2JqZWN0KGZpbGVzLCBmaWxlRGVzY3JpcHRvcnNbaV0pXG4gICAgICAgIC8vIFVzZXJzIGFyZSBhc2tlZCB0byByZS1zZWxlY3QgcmVjb3ZlcmVkIGZpbGVzIHdpdGhvdXQgZGF0YSxcbiAgICAgICAgLy8gYW5kIHRvIGtlZXAgdGhlIHByb2dyZXNzLCBtZXRhIGFuZCBldmVydGhpbmcgZWxzZSwgd2Ugb25seSByZXBsYWNlIHNhaWQgZGF0YVxuICAgICAgICBpZiAoZmlsZXNbbmV3RmlsZS5pZF0gJiYgZmlsZXNbbmV3RmlsZS5pZF0uaXNHaG9zdCkge1xuICAgICAgICAgIG5ld0ZpbGUgPSB7XG4gICAgICAgICAgICAuLi5maWxlc1tuZXdGaWxlLmlkXSxcbiAgICAgICAgICAgIGRhdGE6IGZpbGVEZXNjcmlwdG9yc1tpXS5kYXRhLFxuICAgICAgICAgICAgaXNHaG9zdDogZmFsc2UsXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubG9nKGBSZXBsYWNlZCBibG9iIGluIGEgZ2hvc3QgZmlsZTogJHtuZXdGaWxlLm5hbWV9LCAke25ld0ZpbGUuaWR9YClcbiAgICAgICAgfVxuICAgICAgICBmaWxlc1tuZXdGaWxlLmlkXSA9IG5ld0ZpbGVcbiAgICAgICAgbmV3RmlsZXMucHVzaChuZXdGaWxlKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghZXJyLmlzUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgZmlsZXMgfSlcblxuICAgIG5ld0ZpbGVzLmZvckVhY2goKG5ld0ZpbGUpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnZmlsZS1hZGRlZCcsIG5ld0ZpbGUpXG4gICAgfSlcblxuICAgIHRoaXMuZW1pdCgnZmlsZXMtYWRkZWQnLCBuZXdGaWxlcylcblxuICAgIGlmIChuZXdGaWxlcy5sZW5ndGggPiA1KSB7XG4gICAgICB0aGlzLmxvZyhgQWRkZWQgYmF0Y2ggb2YgJHtuZXdGaWxlcy5sZW5ndGh9IGZpbGVzYClcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmtleXMobmV3RmlsZXMpLmZvckVhY2goZmlsZUlEID0+IHtcbiAgICAgICAgdGhpcy5sb2coYEFkZGVkIGZpbGU6ICR7bmV3RmlsZXNbZmlsZUlEXS5uYW1lfVxcbiBpZDogJHtuZXdGaWxlc1tmaWxlSURdLmlkfVxcbiB0eXBlOiAke25ld0ZpbGVzW2ZpbGVJRF0udHlwZX1gKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAobmV3RmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zdGFydElmQXV0b1Byb2NlZWQoKVxuICAgIH1cblxuICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IG1lc3NhZ2UgPSAnTXVsdGlwbGUgZXJyb3JzIG9jY3VycmVkIHdoaWxlIGFkZGluZyBmaWxlczpcXG4nXG4gICAgICBlcnJvcnMuZm9yRWFjaCgoc3ViRXJyb3IpID0+IHtcbiAgICAgICAgbWVzc2FnZSArPSBgXFxuICogJHtzdWJFcnJvci5tZXNzYWdlfWBcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuaW5mbyh7XG4gICAgICAgIG1lc3NhZ2U6IHRoaXMuaTE4bignYWRkQnVsa0ZpbGVzRmFpbGVkJywgeyBzbWFydF9jb3VudDogZXJyb3JzLmxlbmd0aCB9KSxcbiAgICAgICAgZGV0YWlsczogbWVzc2FnZSxcbiAgICAgIH0sICdlcnJvcicsIHRoaXMub3B0cy5pbmZvVGltZW91dClcblxuICAgICAgaWYgKHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3IoZXJyb3JzLCBtZXNzYWdlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgICAgIGVyci5lcnJvcnMgPSBlcnJvcnNcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlRmlsZXMgKGZpbGVJRHMsIHJlYXNvbikge1xuICAgIGNvbnN0IHsgZmlsZXMsIGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSB7IC4uLmZpbGVzIH1cbiAgICBjb25zdCB1cGRhdGVkVXBsb2FkcyA9IHsgLi4uY3VycmVudFVwbG9hZHMgfVxuXG4gICAgY29uc3QgcmVtb3ZlZEZpbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIGZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICBpZiAoZmlsZXNbZmlsZUlEXSkge1xuICAgICAgICByZW1vdmVkRmlsZXNbZmlsZUlEXSA9IGZpbGVzW2ZpbGVJRF1cbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRGaWxlc1tmaWxlSURdXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFJlbW92ZSBmaWxlcyBmcm9tIHRoZSBgZmlsZUlEc2AgbGlzdCBpbiBlYWNoIHVwbG9hZC5cbiAgICBmdW5jdGlvbiBmaWxlSXNOb3RSZW1vdmVkICh1cGxvYWRGaWxlSUQpIHtcbiAgICAgIHJldHVybiByZW1vdmVkRmlsZXNbdXBsb2FkRmlsZUlEXSA9PT0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXModXBkYXRlZFVwbG9hZHMpLmZvckVhY2goKHVwbG9hZElEKSA9PiB7XG4gICAgICBjb25zdCBuZXdGaWxlSURzID0gY3VycmVudFVwbG9hZHNbdXBsb2FkSURdLmZpbGVJRHMuZmlsdGVyKGZpbGVJc05vdFJlbW92ZWQpXG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgdXBsb2FkIGlmIG5vIGZpbGVzIGFyZSBhc3NvY2lhdGVkIHdpdGggaXQgYW55bW9yZS5cbiAgICAgIGlmIChuZXdGaWxlSURzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdXBkYXRlZFVwbG9hZHNbdXBsb2FkSURdXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB1cGRhdGVkVXBsb2Fkc1t1cGxvYWRJRF0gPSB7XG4gICAgICAgIC4uLmN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXSxcbiAgICAgICAgZmlsZUlEczogbmV3RmlsZUlEcyxcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3Qgc3RhdGVVcGRhdGUgPSB7XG4gICAgICBjdXJyZW50VXBsb2FkczogdXBkYXRlZFVwbG9hZHMsXG4gICAgICBmaWxlczogdXBkYXRlZEZpbGVzLFxuICAgIH1cblxuICAgIC8vIElmIGFsbCBmaWxlcyB3ZXJlIHJlbW92ZWQgLSBhbGxvdyBuZXcgdXBsb2FkcyxcbiAgICAvLyBhbmQgY2xlYXIgcmVjb3ZlcmVkU3RhdGVcbiAgICBpZiAoT2JqZWN0LmtleXModXBkYXRlZEZpbGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHN0YXRlVXBkYXRlLmFsbG93TmV3VXBsb2FkID0gdHJ1ZVxuICAgICAgc3RhdGVVcGRhdGUuZXJyb3IgPSBudWxsXG4gICAgICBzdGF0ZVVwZGF0ZS5yZWNvdmVyZWRTdGF0ZSA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHN0YXRlVXBkYXRlKVxuICAgIHRoaXMuY2FsY3VsYXRlVG90YWxQcm9ncmVzcygpXG5cbiAgICBjb25zdCByZW1vdmVkRmlsZUlEcyA9IE9iamVjdC5rZXlzKHJlbW92ZWRGaWxlcylcbiAgICByZW1vdmVkRmlsZUlEcy5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnZmlsZS1yZW1vdmVkJywgcmVtb3ZlZEZpbGVzW2ZpbGVJRF0sIHJlYXNvbilcbiAgICB9KVxuXG4gICAgaWYgKHJlbW92ZWRGaWxlSURzLmxlbmd0aCA+IDUpIHtcbiAgICAgIHRoaXMubG9nKGBSZW1vdmVkICR7cmVtb3ZlZEZpbGVJRHMubGVuZ3RofSBmaWxlc2ApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKGBSZW1vdmVkIGZpbGVzOiAke3JlbW92ZWRGaWxlSURzLmpvaW4oJywgJyl9YClcbiAgICB9XG4gIH1cblxuICByZW1vdmVGaWxlIChmaWxlSUQsIHJlYXNvbiA9IG51bGwpIHtcbiAgICB0aGlzLnJlbW92ZUZpbGVzKFtmaWxlSURdLCByZWFzb24pXG4gIH1cblxuICBwYXVzZVJlc3VtZSAoZmlsZUlEKSB7XG4gICAgaWYgKCF0aGlzLmdldFN0YXRlKCkuY2FwYWJpbGl0aWVzLnJlc3VtYWJsZVVwbG9hZHNcbiAgICAgICAgIHx8IHRoaXMuZ2V0RmlsZShmaWxlSUQpLnVwbG9hZENvbXBsZXRlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgY29uc3Qgd2FzUGF1c2VkID0gdGhpcy5nZXRGaWxlKGZpbGVJRCkuaXNQYXVzZWQgfHwgZmFsc2VcbiAgICBjb25zdCBpc1BhdXNlZCA9ICF3YXNQYXVzZWRcblxuICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGVJRCwge1xuICAgICAgaXNQYXVzZWQsXG4gICAgfSlcblxuICAgIHRoaXMuZW1pdCgndXBsb2FkLXBhdXNlJywgZmlsZUlELCBpc1BhdXNlZClcblxuICAgIHJldHVybiBpc1BhdXNlZFxuICB9XG5cbiAgcGF1c2VBbGwgKCkge1xuICAgIGNvbnN0IHVwZGF0ZWRGaWxlcyA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzIH1cbiAgICBjb25zdCBpblByb2dyZXNzVXBkYXRlZEZpbGVzID0gT2JqZWN0LmtleXModXBkYXRlZEZpbGVzKS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiAhdXBkYXRlZEZpbGVzW2ZpbGVdLnByb2dyZXNzLnVwbG9hZENvbXBsZXRlXG4gICAgICAgICAgICAgJiYgdXBkYXRlZEZpbGVzW2ZpbGVdLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgICB9KVxuXG4gICAgaW5Qcm9ncmVzc1VwZGF0ZWRGaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkRmlsZSA9IHsgLi4udXBkYXRlZEZpbGVzW2ZpbGVdLCBpc1BhdXNlZDogdHJ1ZSB9XG4gICAgICB1cGRhdGVkRmlsZXNbZmlsZV0gPSB1cGRhdGVkRmlsZVxuICAgIH0pXG5cbiAgICB0aGlzLnNldFN0YXRlKHsgZmlsZXM6IHVwZGF0ZWRGaWxlcyB9KVxuICAgIHRoaXMuZW1pdCgncGF1c2UtYWxsJylcbiAgfVxuXG4gIHJlc3VtZUFsbCAoKSB7XG4gICAgY29uc3QgdXBkYXRlZEZpbGVzID0geyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMgfVxuICAgIGNvbnN0IGluUHJvZ3Jlc3NVcGRhdGVkRmlsZXMgPSBPYmplY3Qua2V5cyh1cGRhdGVkRmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuICF1cGRhdGVkRmlsZXNbZmlsZV0ucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGVcbiAgICAgICAgICAgICAmJiB1cGRhdGVkRmlsZXNbZmlsZV0ucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZFxuICAgIH0pXG5cbiAgICBpblByb2dyZXNzVXBkYXRlZEZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRGaWxlID0ge1xuICAgICAgICAuLi51cGRhdGVkRmlsZXNbZmlsZV0sXG4gICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9XG4gICAgICB1cGRhdGVkRmlsZXNbZmlsZV0gPSB1cGRhdGVkRmlsZVxuICAgIH0pXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVzOiB1cGRhdGVkRmlsZXMgfSlcblxuICAgIHRoaXMuZW1pdCgncmVzdW1lLWFsbCcpXG4gIH1cblxuICByZXRyeUFsbCAoKSB7XG4gICAgY29uc3QgdXBkYXRlZEZpbGVzID0geyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMgfVxuICAgIGNvbnN0IGZpbGVzVG9SZXRyeSA9IE9iamVjdC5rZXlzKHVwZGF0ZWRGaWxlcykuZmlsdGVyKGZpbGUgPT4ge1xuICAgICAgcmV0dXJuIHVwZGF0ZWRGaWxlc1tmaWxlXS5lcnJvclxuICAgIH0pXG5cbiAgICBmaWxlc1RvUmV0cnkuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEZpbGUgPSB7XG4gICAgICAgIC4uLnVwZGF0ZWRGaWxlc1tmaWxlXSxcbiAgICAgICAgaXNQYXVzZWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH1cbiAgICAgIHVwZGF0ZWRGaWxlc1tmaWxlXSA9IHVwZGF0ZWRGaWxlXG4gICAgfSlcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZpbGVzOiB1cGRhdGVkRmlsZXMsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICB9KVxuXG4gICAgdGhpcy5lbWl0KCdyZXRyeS1hbGwnLCBmaWxlc1RvUmV0cnkpXG5cbiAgICBpZiAoZmlsZXNUb1JldHJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHN1Y2Nlc3NmdWw6IFtdLFxuICAgICAgICBmYWlsZWQ6IFtdLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCB1cGxvYWRJRCA9IHRoaXMuY3JlYXRlVXBsb2FkKGZpbGVzVG9SZXRyeSwge1xuICAgICAgZm9yY2VBbGxvd05ld1VwbG9hZDogdHJ1ZSwgLy8gY3JlYXRlIG5ldyB1cGxvYWQgZXZlbiBpZiBhbGxvd05ld1VwbG9hZDogZmFsc2VcbiAgICB9KVxuICAgIHJldHVybiB0aGlzLnJ1blVwbG9hZCh1cGxvYWRJRClcbiAgfVxuXG4gIGNhbmNlbEFsbCAoKSB7XG4gICAgdGhpcy5lbWl0KCdjYW5jZWwtYWxsJylcblxuICAgIGNvbnN0IHsgZmlsZXMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuXG4gICAgY29uc3QgZmlsZUlEcyA9IE9iamVjdC5rZXlzKGZpbGVzKVxuICAgIGlmIChmaWxlSURzLmxlbmd0aCkge1xuICAgICAgdGhpcy5yZW1vdmVGaWxlcyhmaWxlSURzLCAnY2FuY2VsLWFsbCcpXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB0b3RhbFByb2dyZXNzOiAwLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICByZWNvdmVyZWRTdGF0ZTogbnVsbCxcbiAgICB9KVxuICB9XG5cbiAgcmV0cnlVcGxvYWQgKGZpbGVJRCkge1xuICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGVJRCwge1xuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBpc1BhdXNlZDogZmFsc2UsXG4gICAgfSlcblxuICAgIHRoaXMuZW1pdCgndXBsb2FkLXJldHJ5JywgZmlsZUlEKVxuXG4gICAgY29uc3QgdXBsb2FkSUQgPSB0aGlzLmNyZWF0ZVVwbG9hZChbZmlsZUlEXSwge1xuICAgICAgZm9yY2VBbGxvd05ld1VwbG9hZDogdHJ1ZSwgLy8gY3JlYXRlIG5ldyB1cGxvYWQgZXZlbiBpZiBhbGxvd05ld1VwbG9hZDogZmFsc2VcbiAgICB9KVxuICAgIHJldHVybiB0aGlzLnJ1blVwbG9hZCh1cGxvYWRJRClcbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICB0aGlzLmNhbmNlbEFsbCgpXG4gIH1cblxuICBsb2dvdXQgKCkge1xuICAgIHRoaXMuaXRlcmF0ZVBsdWdpbnMocGx1Z2luID0+IHtcbiAgICAgIGlmIChwbHVnaW4ucHJvdmlkZXIgJiYgcGx1Z2luLnByb3ZpZGVyLmxvZ291dCkge1xuICAgICAgICBwbHVnaW4ucHJvdmlkZXIubG9nb3V0KClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY2FsY3VsYXRlUHJvZ3Jlc3MgKGZpbGUsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgdGhpcy5sb2coYE5vdCBzZXR0aW5nIHByb2dyZXNzIGZvciBhIGZpbGUgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAke2ZpbGUuaWR9YClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGJ5dGVzVG90YWwgbWF5IGJlIG51bGwgb3IgemVybzsgaW4gdGhhdCBjYXNlIHdlIGNhbid0IGRpdmlkZSBieSBpdFxuICAgIGNvbnN0IGNhbkhhdmVQZXJjZW50YWdlID0gTnVtYmVyLmlzRmluaXRlKGRhdGEuYnl0ZXNUb3RhbCkgJiYgZGF0YS5ieXRlc1RvdGFsID4gMFxuICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgIC4uLnRoaXMuZ2V0RmlsZShmaWxlLmlkKS5wcm9ncmVzcyxcbiAgICAgICAgYnl0ZXNVcGxvYWRlZDogZGF0YS5ieXRlc1VwbG9hZGVkLFxuICAgICAgICBieXRlc1RvdGFsOiBkYXRhLmJ5dGVzVG90YWwsXG4gICAgICAgIHBlcmNlbnRhZ2U6IGNhbkhhdmVQZXJjZW50YWdlXG4gICAgICAgICAgLy8gVE9ETyhnb3RvLWJ1cy1zdG9wKSBmbG9vcmluZyB0aGlzIHNob3VsZCBwcm9iYWJseSBiZSB0aGUgY2hvaWNlIG9mIHRoZSBVST9cbiAgICAgICAgICAvLyB3ZSBnZXQgbW9yZSBhY2N1cmF0ZSBjYWxjdWxhdGlvbnMgaWYgd2UgZG9uJ3Qgcm91bmQgdGhpcyBhdCBhbGwuXG4gICAgICAgICAgPyBNYXRoLnJvdW5kKChkYXRhLmJ5dGVzVXBsb2FkZWQgLyBkYXRhLmJ5dGVzVG90YWwpICogMTAwKVxuICAgICAgICAgIDogMCxcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIHRoaXMuY2FsY3VsYXRlVG90YWxQcm9ncmVzcygpXG4gIH1cblxuICBjYWxjdWxhdGVUb3RhbFByb2dyZXNzICgpIHtcbiAgICAvLyBjYWxjdWxhdGUgdG90YWwgcHJvZ3Jlc3MsIHVzaW5nIHRoZSBudW1iZXIgb2YgZmlsZXMgY3VycmVudGx5IHVwbG9hZGluZyxcbiAgICAvLyBtdWx0aXBsaWVkIGJ5IDEwMCBhbmQgdGhlIHN1bW0gb2YgaW5kaXZpZHVhbCBwcm9ncmVzcyBvZiBlYWNoIGZpbGVcbiAgICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0RmlsZXMoKVxuXG4gICAgY29uc3QgaW5Qcm9ncmVzcyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZFxuICAgICAgICB8fCBmaWxlLnByb2dyZXNzLnByZXByb2Nlc3NcbiAgICAgICAgfHwgZmlsZS5wcm9ncmVzcy5wb3N0cHJvY2Vzc1xuICAgIH0pXG5cbiAgICBpZiAoaW5Qcm9ncmVzcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCAwKVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRvdGFsUHJvZ3Jlc3M6IDAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHNpemVkRmlsZXMgPSBpblByb2dyZXNzLmZpbHRlcigoZmlsZSkgPT4gZmlsZS5wcm9ncmVzcy5ieXRlc1RvdGFsICE9IG51bGwpXG4gICAgY29uc3QgdW5zaXplZEZpbGVzID0gaW5Qcm9ncmVzcy5maWx0ZXIoKGZpbGUpID0+IGZpbGUucHJvZ3Jlc3MuYnl0ZXNUb3RhbCA9PSBudWxsKVxuXG4gICAgaWYgKHNpemVkRmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBwcm9ncmVzc01heCA9IGluUHJvZ3Jlc3MubGVuZ3RoICogMTAwXG4gICAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSB1bnNpemVkRmlsZXMucmVkdWNlKChhY2MsIGZpbGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGFjYyArIGZpbGUucHJvZ3Jlc3MucGVyY2VudGFnZVxuICAgICAgfSwgMClcbiAgICAgIGNvbnN0IHRvdGFsUHJvZ3Jlc3MgPSBNYXRoLnJvdW5kKChjdXJyZW50UHJvZ3Jlc3MgLyBwcm9ncmVzc01heCkgKiAxMDApXG4gICAgICB0aGlzLnNldFN0YXRlKHsgdG90YWxQcm9ncmVzcyB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHRvdGFsU2l6ZSA9IHNpemVkRmlsZXMucmVkdWNlKChhY2MsIGZpbGUpID0+IHtcbiAgICAgIHJldHVybiBhY2MgKyBmaWxlLnByb2dyZXNzLmJ5dGVzVG90YWxcbiAgICB9LCAwKVxuICAgIGNvbnN0IGF2ZXJhZ2VTaXplID0gdG90YWxTaXplIC8gc2l6ZWRGaWxlcy5sZW5ndGhcbiAgICB0b3RhbFNpemUgKz0gYXZlcmFnZVNpemUgKiB1bnNpemVkRmlsZXMubGVuZ3RoXG5cbiAgICBsZXQgdXBsb2FkZWRTaXplID0gMFxuICAgIHNpemVkRmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgdXBsb2FkZWRTaXplICs9IGZpbGUucHJvZ3Jlc3MuYnl0ZXNVcGxvYWRlZFxuICAgIH0pXG4gICAgdW5zaXplZEZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIHVwbG9hZGVkU2l6ZSArPSAoYXZlcmFnZVNpemUgKiAoZmlsZS5wcm9ncmVzcy5wZXJjZW50YWdlIHx8IDApKSAvIDEwMFxuICAgIH0pXG5cbiAgICBsZXQgdG90YWxQcm9ncmVzcyA9IHRvdGFsU2l6ZSA9PT0gMFxuICAgICAgPyAwXG4gICAgICA6IE1hdGgucm91bmQoKHVwbG9hZGVkU2l6ZSAvIHRvdGFsU2l6ZSkgKiAxMDApXG5cbiAgICAvLyBob3QgZml4LCBiZWNhdXNlOlxuICAgIC8vIHVwbG9hZGVkU2l6ZSBlbmRlZCB1cCBsYXJnZXIgdGhhbiB0b3RhbFNpemUsIHJlc3VsdGluZyBpbiAxMzI1JSB0b3RhbFxuICAgIGlmICh0b3RhbFByb2dyZXNzID4gMTAwKSB7XG4gICAgICB0b3RhbFByb2dyZXNzID0gMTAwXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IHRvdGFsUHJvZ3Jlc3MgfSlcbiAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgdG90YWxQcm9ncmVzcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgbGlzdGVuZXJzIGZvciBhbGwgZ2xvYmFsIGFjdGlvbnMsIGxpa2U6XG4gICAqIGBlcnJvcmAsIGBmaWxlLXJlbW92ZWRgLCBgdXBsb2FkLXByb2dyZXNzYFxuICAgKi9cbiAgYWRkTGlzdGVuZXJzICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZmlsZV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3Jlc3BvbnNlXVxuICAgICAqL1xuICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IChlcnJvciwgZmlsZSwgcmVzcG9uc2UpID0+IHtcbiAgICAgIGxldCBlcnJvck1zZyA9IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InXG4gICAgICBpZiAoZXJyb3IuZGV0YWlscykge1xuICAgICAgICBlcnJvck1zZyArPSBgICR7ZXJyb3IuZGV0YWlsc31gXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogZXJyb3JNc2cgfSlcblxuICAgICAgLy8gV2hlbiBhIGZpbGUgaXMgYWxzbyBnaXZlbiwgd2Ugc3RvcmUgdGhlIGVycm9yIG9uIHRoZSBmaWxlIG9iamVjdC5cbiAgICAgIGlmIChmaWxlICE9IG51bGwgJiYgdHlwZW9mIGZpbGUuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgICAgICBlcnJvcjogZXJyb3JNc2csXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vbignZXJyb3InLCBlcnJvckhhbmRsZXIpXG5cbiAgICB0aGlzLm9uKCd1cGxvYWQtZXJyb3InLCAoZmlsZSwgZXJyb3IsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBlcnJvckhhbmRsZXIoZXJyb3IsIGZpbGUsIHJlc3BvbnNlKVxuXG4gICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG5ld0Vycm9yID0gbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpXG4gICAgICAgIG5ld0Vycm9yLmRldGFpbHMgPSBlcnJvci5tZXNzYWdlXG4gICAgICAgIGlmIChlcnJvci5kZXRhaWxzKSB7XG4gICAgICAgICAgbmV3RXJyb3IuZGV0YWlscyArPSBgICR7ZXJyb3IuZGV0YWlsc31gXG4gICAgICAgIH1cbiAgICAgICAgbmV3RXJyb3IubWVzc2FnZSA9IHRoaXMuaTE4bignZmFpbGVkVG9VcGxvYWQnLCB7IGZpbGU6IGZpbGUubmFtZSB9KVxuICAgICAgICB0aGlzLnNob3dPckxvZ0Vycm9yQW5kVGhyb3cobmV3RXJyb3IsIHtcbiAgICAgICAgICB0aHJvd0VycjogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dPckxvZ0Vycm9yQW5kVGhyb3coZXJyb3IsIHtcbiAgICAgICAgICB0aHJvd0VycjogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMub24oJ3VwbG9hZCcsICgpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogbnVsbCB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCd1cGxvYWQtc3RhcnRlZCcsIChmaWxlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcHJvZ3Jlc3MgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7ZmlsZS5pZH1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICB1cGxvYWRTdGFydGVkOiBEYXRlLm5vdygpLFxuICAgICAgICAgIHVwbG9hZENvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgICBwZXJjZW50YWdlOiAwLFxuICAgICAgICAgIGJ5dGVzVXBsb2FkZWQ6IDAsXG4gICAgICAgICAgYnl0ZXNUb3RhbDogZmlsZS5zaXplLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5vbigndXBsb2FkLXByb2dyZXNzJywgdGhpcy5jYWxjdWxhdGVQcm9ncmVzcylcblxuICAgIHRoaXMub24oJ3VwbG9hZC1zdWNjZXNzJywgKGZpbGUsIHVwbG9hZFJlc3ApID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRGaWxlKGZpbGUuaWQpKSB7XG4gICAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyBwcm9ncmVzcyBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHtmaWxlLmlkfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSB0aGlzLmdldEZpbGUoZmlsZS5pZCkucHJvZ3Jlc3NcbiAgICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICAuLi5jdXJyZW50UHJvZ3Jlc3MsXG4gICAgICAgICAgcG9zdHByb2Nlc3M6IHRoaXMucG9zdFByb2Nlc3NvcnMubGVuZ3RoID4gMCA/IHtcbiAgICAgICAgICAgIG1vZGU6ICdpbmRldGVybWluYXRlJyxcbiAgICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgICB1cGxvYWRDb21wbGV0ZTogdHJ1ZSxcbiAgICAgICAgICBwZXJjZW50YWdlOiAxMDAsXG4gICAgICAgICAgYnl0ZXNVcGxvYWRlZDogY3VycmVudFByb2dyZXNzLmJ5dGVzVG90YWwsXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3BvbnNlOiB1cGxvYWRSZXNwLFxuICAgICAgICB1cGxvYWRVUkw6IHVwbG9hZFJlc3AudXBsb2FkVVJMLFxuICAgICAgICBpc1BhdXNlZDogZmFsc2UsXG4gICAgICB9KVxuXG4gICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsUHJvZ3Jlc3MoKVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCdwcmVwcm9jZXNzLXByb2dyZXNzJywgKGZpbGUsIHByb2dyZXNzKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcHJvZ3Jlc3MgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7ZmlsZS5pZH1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgICAgcHJvZ3Jlc3M6IHsgLi4udGhpcy5nZXRGaWxlKGZpbGUuaWQpLnByb2dyZXNzLCBwcmVwcm9jZXNzOiBwcm9ncmVzcyB9LFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5vbigncHJlcHJvY2Vzcy1jb21wbGV0ZScsIChmaWxlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcHJvZ3Jlc3MgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7ZmlsZS5pZH1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVzID0geyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMgfVxuICAgICAgZmlsZXNbZmlsZS5pZF0gPSB7IC4uLmZpbGVzW2ZpbGUuaWRdLCBwcm9ncmVzczogeyAuLi5maWxlc1tmaWxlLmlkXS5wcm9ncmVzcyB9IH1cbiAgICAgIGRlbGV0ZSBmaWxlc1tmaWxlLmlkXS5wcm9ncmVzcy5wcmVwcm9jZXNzXG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBmaWxlcyB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCdwb3N0cHJvY2Vzcy1wcm9ncmVzcycsIChmaWxlLCBwcm9ncmVzcykgPT4ge1xuICAgICAgaWYgKCF0aGlzLmdldEZpbGUoZmlsZS5pZCkpIHtcbiAgICAgICAgdGhpcy5sb2coYE5vdCBzZXR0aW5nIHByb2dyZXNzIGZvciBhIGZpbGUgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAke2ZpbGUuaWR9YClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLnNldEZpbGVTdGF0ZShmaWxlLmlkLCB7XG4gICAgICAgIHByb2dyZXNzOiB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlc1tmaWxlLmlkXS5wcm9ncmVzcywgcG9zdHByb2Nlc3M6IHByb2dyZXNzIH0sXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCdwb3N0cHJvY2Vzcy1jb21wbGV0ZScsIChmaWxlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcHJvZ3Jlc3MgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7ZmlsZS5pZH1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVzID0ge1xuICAgICAgICAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMsXG4gICAgICB9XG4gICAgICBmaWxlc1tmaWxlLmlkXSA9IHtcbiAgICAgICAgLi4uZmlsZXNbZmlsZS5pZF0sXG4gICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgLi4uZmlsZXNbZmlsZS5pZF0ucHJvZ3Jlc3MsXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgICBkZWxldGUgZmlsZXNbZmlsZS5pZF0ucHJvZ3Jlc3MucG9zdHByb2Nlc3NcbiAgICAgIC8vIFRPRE8gc2hvdWxkIHdlIHNldCBzb21lIGtpbmQgb2YgYGZ1bGx5Q29tcGxldGVgIHByb3BlcnR5IG9uIHRoZSBmaWxlIG9iamVjdFxuICAgICAgLy8gc28gaXQncyBlYXNpZXIgdG8gc2VlIHRoYXQgdGhlIGZpbGUgaXMgdXBsb2Fk4oCmZnVsbHkgY29tcGxldGXigKZyYXRoZXIgdGhhblxuICAgICAgLy8gd2hhdCB3ZSBoYXZlIHRvIGRvIG5vdyAoYHVwbG9hZENvbXBsZXRlICYmICFwb3N0cHJvY2Vzc2ApXG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBmaWxlcyB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCdyZXN0b3JlZCcsICgpID0+IHtcbiAgICAgIC8vIEZpbGVzIG1heSBoYXZlIGNoYW5nZWQtLWVuc3VyZSBwcm9ncmVzcyBpcyBzdGlsbCBhY2N1cmF0ZS5cbiAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxQcm9ncmVzcygpXG4gICAgfSlcblxuICAgIC8vIHNob3cgaW5mb3JtZXIgaWYgb2ZmbGluZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsICgpID0+IHRoaXMudXBkYXRlT25saW5lU3RhdHVzKCkpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsICgpID0+IHRoaXMudXBkYXRlT25saW5lU3RhdHVzKCkpXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlT25saW5lU3RhdHVzKCksIDMwMDApXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlT25saW5lU3RhdHVzICgpIHtcbiAgICBjb25zdCBvbmxpbmVcbiAgICAgID0gdHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lXG4gICAgICAgIDogdHJ1ZVxuICAgIGlmICghb25saW5lKSB7XG4gICAgICB0aGlzLmVtaXQoJ2lzLW9mZmxpbmUnKVxuICAgICAgdGhpcy5pbmZvKHRoaXMuaTE4bignbm9JbnRlcm5ldENvbm5lY3Rpb24nKSwgJ2Vycm9yJywgMClcbiAgICAgIHRoaXMud2FzT2ZmbGluZSA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdpcy1vbmxpbmUnKVxuICAgICAgaWYgKHRoaXMud2FzT2ZmbGluZSkge1xuICAgICAgICB0aGlzLmVtaXQoJ2JhY2stb25saW5lJylcbiAgICAgICAgdGhpcy5pbmZvKHRoaXMuaTE4bignY29ubmVjdGVkVG9JbnRlcm5ldCcpLCAnc3VjY2VzcycsIDMwMDApXG4gICAgICAgIHRoaXMud2FzT2ZmbGluZSA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0SUQgKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHMuaWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBwbHVnaW4gd2l0aCBDb3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luIG9iamVjdFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdHNdIG9iamVjdCB3aXRoIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIFBsdWdpblxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBzZWxmIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICB1c2UgKFBsdWdpbiwgb3B0cykge1xuICAgIGlmICh0eXBlb2YgUGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgYSBwbHVnaW4gY2xhc3MsIGJ1dCBnb3QgJHtQbHVnaW4gPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgUGx1Z2lufS5gXG4gICAgICAgICsgJyBQbGVhc2UgdmVyaWZ5IHRoYXQgdGhlIHBsdWdpbiB3YXMgaW1wb3J0ZWQgYW5kIHNwZWxsZWQgY29ycmVjdGx5LidcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobXNnKVxuICAgIH1cblxuICAgIC8vIEluc3RhbnRpYXRlXG4gICAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIGNvbnN0IHBsdWdpbklkID0gcGx1Z2luLmlkXG4gICAgdGhpcy5wbHVnaW5zW3BsdWdpbi50eXBlXSA9IHRoaXMucGx1Z2luc1twbHVnaW4udHlwZV0gfHwgW11cblxuICAgIGlmICghcGx1Z2luSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBwbHVnaW4gbXVzdCBoYXZlIGFuIGlkJylcbiAgICB9XG5cbiAgICBpZiAoIXBsdWdpbi50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgcGx1Z2luIG11c3QgaGF2ZSBhIHR5cGUnKVxuICAgIH1cblxuICAgIGNvbnN0IGV4aXN0c1BsdWdpbkFscmVhZHkgPSB0aGlzLmdldFBsdWdpbihwbHVnaW5JZClcbiAgICBpZiAoZXhpc3RzUGx1Z2luQWxyZWFkeSkge1xuICAgICAgY29uc3QgbXNnID0gYEFscmVhZHkgZm91bmQgYSBwbHVnaW4gbmFtZWQgJyR7ZXhpc3RzUGx1Z2luQWxyZWFkeS5pZH0nLiBgXG4gICAgICAgICsgYFRyaWVkIHRvIHVzZTogJyR7cGx1Z2luSWR9Jy5cXG5gXG4gICAgICAgICsgJ1VwcHkgcGx1Z2lucyBtdXN0IGhhdmUgdW5pcXVlIGBpZGAgb3B0aW9ucy4gU2VlIGh0dHBzOi8vdXBweS5pby9kb2NzL3BsdWdpbnMvI2lkLidcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpXG4gICAgfVxuXG4gICAgaWYgKFBsdWdpbi5WRVJTSU9OKSB7XG4gICAgICB0aGlzLmxvZyhgVXNpbmcgJHtwbHVnaW5JZH0gdiR7UGx1Z2luLlZFUlNJT059YClcbiAgICB9XG5cbiAgICB0aGlzLnBsdWdpbnNbcGx1Z2luLnR5cGVdLnB1c2gocGx1Z2luKVxuICAgIHBsdWdpbi5pbnN0YWxsKClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogRmluZCBvbmUgUGx1Z2luIGJ5IG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBwbHVnaW4gaWRcbiAgICogQHJldHVybnMge29iamVjdHxib29sZWFufVxuICAgKi9cbiAgZ2V0UGx1Z2luIChpZCkge1xuICAgIGxldCBmb3VuZFBsdWdpbiA9IG51bGxcbiAgICB0aGlzLml0ZXJhdGVQbHVnaW5zKChwbHVnaW4pID0+IHtcbiAgICAgIGlmIChwbHVnaW4uaWQgPT09IGlkKSB7XG4gICAgICAgIGZvdW5kUGx1Z2luID0gcGx1Z2luXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvdW5kUGx1Z2luXG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBgdXNlYGQgcGx1Z2lucy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIHRoYXQgd2lsbCBiZSBydW4gb24gZWFjaCBwbHVnaW5cbiAgICovXG4gIGl0ZXJhdGVQbHVnaW5zIChtZXRob2QpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLnBsdWdpbnMpLmZvckVhY2gocGx1Z2luVHlwZSA9PiB7XG4gICAgICB0aGlzLnBsdWdpbnNbcGx1Z2luVHlwZV0uZm9yRWFjaChtZXRob2QpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmluc3RhbGwgYW5kIHJlbW92ZSBhIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3RhbmNlIFRoZSBwbHVnaW4gaW5zdGFuY2UgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlUGx1Z2luIChpbnN0YW5jZSkge1xuICAgIHRoaXMubG9nKGBSZW1vdmluZyBwbHVnaW4gJHtpbnN0YW5jZS5pZH1gKVxuICAgIHRoaXMuZW1pdCgncGx1Z2luLXJlbW92ZScsIGluc3RhbmNlKVxuXG4gICAgaWYgKGluc3RhbmNlLnVuaW5zdGFsbCkge1xuICAgICAgaW5zdGFuY2UudW5pbnN0YWxsKClcbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ID0gdGhpcy5wbHVnaW5zW2luc3RhbmNlLnR5cGVdLnNsaWNlKClcbiAgICAvLyBsaXN0LmluZGV4T2YgZmFpbGVkIGhlcmUsIGJlY2F1c2UgVnVlMyBjb252ZXJ0ZWQgdGhlIHBsdWdpbiBpbnN0YW5jZVxuICAgIC8vIHRvIGEgUHJveHkgb2JqZWN0LCB3aGljaCBmYWlsZWQgdGhlIHN0cmljdCBjb21wYXJpc29uIHRlc3Q6XG4gICAgLy8gb2JqICE9PSBvYmpQcm94eVxuICAgIGNvbnN0IGluZGV4ID0gZmluZEluZGV4KGxpc3QsIGl0ZW0gPT4gaXRlbS5pZCA9PT0gaW5zdGFuY2UuaWQpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICB0aGlzLnBsdWdpbnNbaW5zdGFuY2UudHlwZV0gPSBsaXN0XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKClcbiAgICBjb25zdCB1cGRhdGVkU3RhdGUgPSB7XG4gICAgICBwbHVnaW5zOiB7XG4gICAgICAgIC4uLnN0YXRlLnBsdWdpbnMsXG4gICAgICAgIFtpbnN0YW5jZS5pZF06IHVuZGVmaW5lZCxcbiAgICAgIH0sXG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUodXBkYXRlZFN0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFVuaW5zdGFsbCBhbGwgcGx1Z2lucyBhbmQgY2xvc2UgZG93biB0aGlzIFVwcHkgaW5zdGFuY2UuXG4gICAqL1xuICBjbG9zZSAoKSB7XG4gICAgdGhpcy5sb2coYENsb3NpbmcgVXBweSBpbnN0YW5jZSAke3RoaXMub3B0cy5pZH06IHJlbW92aW5nIGFsbCBmaWxlcyBhbmQgdW5pbnN0YWxsaW5nIHBsdWdpbnNgKVxuXG4gICAgdGhpcy5yZXNldCgpXG5cbiAgICB0aGlzLnN0b3JlVW5zdWJzY3JpYmUoKVxuXG4gICAgdGhpcy5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZVBsdWdpbihwbHVnaW4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgaW5mbyBtZXNzYWdlIGluIGBzdGF0ZS5pbmZvYCwgc28gdGhhdCBVSSBwbHVnaW5zIGxpa2UgYEluZm9ybWVyYFxuICAgKiBjYW4gZGlzcGxheSB0aGUgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBvYmplY3R9IG1lc3NhZ2UgTWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQgYnkgdGhlIGluZm9ybWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbl1cbiAgICovXG5cbiAgaW5mbyAobWVzc2FnZSwgdHlwZSA9ICdpbmZvJywgZHVyYXRpb24gPSAzMDAwKSB7XG4gICAgY29uc3QgaXNDb21wbGV4TWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0J1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBpbmZvOiB7XG4gICAgICAgIGlzSGlkZGVuOiBmYWxzZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbWVzc2FnZTogaXNDb21wbGV4TWVzc2FnZSA/IG1lc3NhZ2UubWVzc2FnZSA6IG1lc3NhZ2UsXG4gICAgICAgIGRldGFpbHM6IGlzQ29tcGxleE1lc3NhZ2UgPyBtZXNzYWdlLmRldGFpbHMgOiBudWxsLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgdGhpcy5lbWl0KCdpbmZvLXZpc2libGUnKVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaW5mb1RpbWVvdXRJRClcbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIHRoaXMuaW5mb1RpbWVvdXRJRCA9IHVuZGVmaW5lZFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaGlkZSB0aGUgaW5mb3JtZXIgYWZ0ZXIgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHNcbiAgICB0aGlzLmluZm9UaW1lb3V0SUQgPSBzZXRUaW1lb3V0KHRoaXMuaGlkZUluZm8sIGR1cmF0aW9uKVxuICB9XG5cbiAgaGlkZUluZm8gKCkge1xuICAgIGNvbnN0IG5ld0luZm8gPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5pbmZvLCBpc0hpZGRlbjogdHJ1ZSB9XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBpbmZvOiBuZXdJbmZvLFxuICAgIH0pXG4gICAgdGhpcy5lbWl0KCdpbmZvLWhpZGRlbicpXG4gIH1cblxuICAvKipcbiAgICogUGFzc2VzIG1lc3NhZ2VzIHRvIGEgZnVuY3Rpb24sIHByb3ZpZGVkIGluIGBvcHRzLmxvZ2dlcmAuXG4gICAqIElmIGBvcHRzLmxvZ2dlcjogVXBweS5kZWJ1Z0xvZ2dlcmAgb3IgYG9wdHMuZGVidWc6IHRydWVgLCBsb2dzIHRvIHRoZSBicm93c2VyIGNvbnNvbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gbWVzc2FnZSB0byBsb2dcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBvcHRpb25hbCBgZXJyb3JgIG9yIGB3YXJuaW5nYFxuICAgKi9cbiAgbG9nIChtZXNzYWdlLCB0eXBlKSB7XG4gICAgY29uc3QgeyBsb2dnZXIgfSA9IHRoaXMub3B0c1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnZXJyb3InOiBsb2dnZXIuZXJyb3IobWVzc2FnZSk7IGJyZWFrXG4gICAgICBjYXNlICd3YXJuaW5nJzogbG9nZ2VyLndhcm4obWVzc2FnZSk7IGJyZWFrXG4gICAgICBkZWZhdWx0OiBsb2dnZXIuZGVidWcobWVzc2FnZSk7IGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ic29sZXRlLCBldmVudCBsaXN0ZW5lcnMgYXJlIG5vdyBhZGRlZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAqL1xuICBydW4gKCkge1xuICAgIHRoaXMubG9nKCdDYWxsaW5nIHJ1bigpIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkuJywgJ3dhcm5pbmcnKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSBhbiB1cGxvYWQgYnkgaXRzIElELlxuICAgKi9cbiAgcmVzdG9yZSAodXBsb2FkSUQpIHtcbiAgICB0aGlzLmxvZyhgQ29yZTogYXR0ZW1wdGluZyB0byByZXN0b3JlIHVwbG9hZCBcIiR7dXBsb2FkSUR9XCJgKVxuXG4gICAgaWYgKCF0aGlzLmdldFN0YXRlKCkuY3VycmVudFVwbG9hZHNbdXBsb2FkSURdKSB7XG4gICAgICB0aGlzLnJlbW92ZVVwbG9hZCh1cGxvYWRJRClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vbmV4aXN0ZW50IHVwbG9hZCcpKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJ1blVwbG9hZCh1cGxvYWRJRClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gdXBsb2FkIGZvciBhIGJ1bmNoIG9mIGZpbGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGZpbGVJRHMgRmlsZSBJRHMgdG8gaW5jbHVkZSBpbiB0aGlzIHVwbG9hZC5cbiAgICogQHJldHVybnMge3N0cmluZ30gSUQgb2YgdGhpcyB1cGxvYWQuXG4gICAqL1xuICBjcmVhdGVVcGxvYWQgKGZpbGVJRHMsIG9wdHMgPSB7fSkge1xuICAgIC8vIHVwcHkucmV0cnlBbGwgc2V0cyB0aGlzIHRvIHRydWUg4oCUIHdoZW4gcmV0cnlpbmcgd2Ugd2FudCB0byBpZ25vcmUgYGFsbG93TmV3VXBsb2FkOiBmYWxzZWBcbiAgICBjb25zdCB7IGZvcmNlQWxsb3dOZXdVcGxvYWQgPSBmYWxzZSB9ID0gb3B0c1xuXG4gICAgY29uc3QgeyBhbGxvd05ld1VwbG9hZCwgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgIGlmICghYWxsb3dOZXdVcGxvYWQgJiYgIWZvcmNlQWxsb3dOZXdVcGxvYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBhIG5ldyB1cGxvYWQ6IGFscmVhZHkgdXBsb2FkaW5nLicpXG4gICAgfVxuXG4gICAgY29uc3QgdXBsb2FkSUQgPSBjdWlkKClcblxuICAgIHRoaXMuZW1pdCgndXBsb2FkJywge1xuICAgICAgaWQ6IHVwbG9hZElELFxuICAgICAgZmlsZUlEcyxcbiAgICB9KVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBhbGxvd05ld1VwbG9hZDogdGhpcy5vcHRzLmFsbG93TXVsdGlwbGVVcGxvYWRzICE9PSBmYWxzZSxcblxuICAgICAgY3VycmVudFVwbG9hZHM6IHtcbiAgICAgICAgLi4uY3VycmVudFVwbG9hZHMsXG4gICAgICAgIFt1cGxvYWRJRF06IHtcbiAgICAgICAgICBmaWxlSURzLFxuICAgICAgICAgIHN0ZXA6IDAsXG4gICAgICAgICAgcmVzdWx0OiB7fSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIHJldHVybiB1cGxvYWRJRFxuICB9XG5cbiAgZ2V0VXBsb2FkICh1cGxvYWRJRCkge1xuICAgIGNvbnN0IHsgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuXG4gICAgcmV0dXJuIGN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBkYXRhIHRvIGFuIHVwbG9hZCdzIHJlc3VsdCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cGxvYWRJRCBUaGUgSUQgb2YgdGhlIHVwbG9hZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YSBwcm9wZXJ0aWVzIHRvIGFkZCB0byB0aGUgcmVzdWx0IG9iamVjdC5cbiAgICovXG4gIGFkZFJlc3VsdERhdGEgKHVwbG9hZElELCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmdldFVwbG9hZCh1cGxvYWRJRCkpIHtcbiAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyByZXN1bHQgZm9yIGFuIHVwbG9hZCB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7dXBsb2FkSUR9YClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICBjb25zdCBjdXJyZW50VXBsb2FkID0geyAuLi5jdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0sIHJlc3VsdDogeyAuLi5jdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0ucmVzdWx0LCAuLi5kYXRhIH0gfVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY3VycmVudFVwbG9hZHM6IHsgLi4uY3VycmVudFVwbG9hZHMsIFt1cGxvYWRJRF06IGN1cnJlbnRVcGxvYWQgfSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiB1cGxvYWQsIGVnLiBpZiBpdCBoYXMgYmVlbiBjYW5jZWxlZCBvciBjb21wbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cGxvYWRJRCBUaGUgSUQgb2YgdGhlIHVwbG9hZC5cbiAgICovXG4gIHJlbW92ZVVwbG9hZCAodXBsb2FkSUQpIHtcbiAgICBjb25zdCBjdXJyZW50VXBsb2FkcyA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmN1cnJlbnRVcGxvYWRzIH1cbiAgICBkZWxldGUgY3VycmVudFVwbG9hZHNbdXBsb2FkSURdXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGN1cnJlbnRVcGxvYWRzLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUnVuIGFuIHVwbG9hZC4gVGhpcyBwaWNrcyB1cCB3aGVyZSBpdCBsZWZ0IG9mZiBpbiBjYXNlIHRoZSB1cGxvYWQgaXMgYmVpbmcgcmVzdG9yZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBydW5VcGxvYWQgKHVwbG9hZElEKSB7XG4gICAgY29uc3QgdXBsb2FkRGF0YSA9IHRoaXMuZ2V0U3RhdGUoKS5jdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF1cbiAgICBjb25zdCByZXN0b3JlU3RlcCA9IHVwbG9hZERhdGEuc3RlcFxuXG4gICAgY29uc3Qgc3RlcHMgPSBbXG4gICAgICAuLi50aGlzLnByZVByb2Nlc3NvcnMsXG4gICAgICAuLi50aGlzLnVwbG9hZGVycyxcbiAgICAgIC4uLnRoaXMucG9zdFByb2Nlc3NvcnMsXG4gICAgXVxuICAgIGxldCBsYXN0U3RlcCA9IFByb21pc2UucmVzb2x2ZSgpXG4gICAgc3RlcHMuZm9yRWFjaCgoZm4sIHN0ZXApID0+IHtcbiAgICAgIC8vIFNraXAgdGhpcyBzdGVwIGlmIHdlIGFyZSByZXN0b3JpbmcgYW5kIGhhdmUgYWxyZWFkeSBjb21wbGV0ZWQgdGhpcyBzdGVwIGJlZm9yZS5cbiAgICAgIGlmIChzdGVwIDwgcmVzdG9yZVN0ZXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxhc3RTdGVwID0gbGFzdFN0ZXAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgICAgICBjb25zdCBjdXJyZW50VXBsb2FkID0gY3VycmVudFVwbG9hZHNbdXBsb2FkSURdXG4gICAgICAgIGlmICghY3VycmVudFVwbG9hZCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXBkYXRlZFVwbG9hZCA9IHtcbiAgICAgICAgICAuLi5jdXJyZW50VXBsb2FkLFxuICAgICAgICAgIHN0ZXAsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjdXJyZW50VXBsb2Fkczoge1xuICAgICAgICAgICAgLi4uY3VycmVudFVwbG9hZHMsXG4gICAgICAgICAgICBbdXBsb2FkSURdOiB1cGRhdGVkVXBsb2FkLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gVE9ETyBnaXZlIHRoaXMgdGhlIGB1cGRhdGVkVXBsb2FkYCBvYmplY3QgYXMgaXRzIG9ubHkgcGFyYW1ldGVyIG1heWJlP1xuICAgICAgICAvLyBPdGhlcndpc2Ugd2hlbiBtb3JlIG1ldGFkYXRhIG1heSBiZSBhZGRlZCB0byB0aGUgdXBsb2FkIHRoaXMgd291bGQga2VlcCBnZXR0aW5nIG1vcmUgcGFyYW1ldGVyc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgcmV0dXJuIGZuKHVwZGF0ZWRVcGxvYWQuZmlsZUlEcywgdXBsb2FkSUQpXG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIC8vIE5vdCByZXR1cm5pbmcgdGhlIGBjYXRjaGBlZCBwcm9taXNlLCBiZWNhdXNlIHdlIHN0aWxsIHdhbnQgdG8gcmV0dXJuIGEgcmVqZWN0ZWRcbiAgICAvLyBwcm9taXNlIGZyb20gdGhpcyBtZXRob2QgaWYgdGhlIHVwbG9hZCBmYWlsZWQuXG4gICAgbGFzdFN0ZXAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIHRoaXMucmVtb3ZlVXBsb2FkKHVwbG9hZElEKVxuICAgIH0pXG5cbiAgICByZXR1cm4gbGFzdFN0ZXAudGhlbigoKSA9PiB7XG4gICAgICAvLyBTZXQgcmVzdWx0IGRhdGEuXG4gICAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICAgIGNvbnN0IGN1cnJlbnRVcGxvYWQgPSBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF1cbiAgICAgIGlmICghY3VycmVudFVwbG9hZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gTWFyayBwb3N0cHJvY2Vzc2luZyBzdGVwIGFzIGNvbXBsZXRlIGlmIG5lY2Vzc2FyeTsgdGhpcyBhZGRyZXNzZXMgYSBjYXNlIHdoZXJlIHdlIG1pZ2h0IGdldFxuICAgICAgLy8gc3R1Y2sgaW4gdGhlIHBvc3Rwcm9jZXNzaW5nIFVJIHdoaWxlIHRoZSB1cGxvYWQgaXMgZnVsbHkgY29tcGxldGUuXG4gICAgICAvLyBJZiB0aGUgcG9zdHByb2Nlc3Npbmcgc3RlcHMgZG8gbm90IGRvIGFueSB3b3JrLCB0aGV5IG1heSBub3QgZW1pdCBwb3N0cHJvY2Vzc2luZyBldmVudHMgYXRcbiAgICAgIC8vIGFsbCwgYW5kIG5ldmVyIG1hcmsgdGhlIHBvc3Rwcm9jZXNzaW5nIGFzIGNvbXBsZXRlLiBUaGlzIGlzIGZpbmUgb24gaXRzIG93biBidXQgd2VcbiAgICAgIC8vIGludHJvZHVjZWQgY29kZSBpbiB0aGUgQHVwcHkvY29yZSB1cGxvYWQtc3VjY2VzcyBoYW5kbGVyIHRvIHByZXBhcmUgcG9zdHByb2Nlc3NpbmcgcHJvZ3Jlc3NcbiAgICAgIC8vIHN0YXRlIGlmIGFueSBwb3N0cHJvY2Vzc29ycyBhcmUgcmVnaXN0ZXJlZC4gVGhhdCBpcyB0byBhdm9pZCBhIFwiZmxhc2ggb2YgY29tcGxldGVkIHN0YXRlXCJcbiAgICAgIC8vIGJlZm9yZSB0aGUgcG9zdHByb2Nlc3NpbmcgcGx1Z2lucyBjYW4gZW1pdCBldmVudHMuXG4gICAgICAvL1xuICAgICAgLy8gU28sIGp1c3QgaW4gY2FzZSBhbiB1cGxvYWQgd2l0aCBwb3N0cHJvY2Vzc2luZyBwbHVnaW5zICpoYXMqIGNvbXBsZXRlZCAqd2l0aG91dCogZW1pdHRpbmdcbiAgICAgIC8vIHBvc3Rwcm9jZXNzaW5nIGNvbXBsZXRpb24sIHdlIGRvIGl0IGluc3RlYWQuXG4gICAgICBjdXJyZW50VXBsb2FkLmZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGUoZmlsZUlEKVxuICAgICAgICBpZiAoZmlsZSAmJiBmaWxlLnByb2dyZXNzLnBvc3Rwcm9jZXNzKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdwb3N0cHJvY2Vzcy1jb21wbGV0ZScsIGZpbGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGZpbGVzID0gY3VycmVudFVwbG9hZC5maWxlSURzLm1hcCgoZmlsZUlEKSA9PiB0aGlzLmdldEZpbGUoZmlsZUlEKSlcbiAgICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+ICFmaWxlLmVycm9yKVxuICAgICAgY29uc3QgZmFpbGVkID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiBmaWxlLmVycm9yKVxuICAgICAgdGhpcy5hZGRSZXN1bHREYXRhKHVwbG9hZElELCB7IHN1Y2Nlc3NmdWwsIGZhaWxlZCwgdXBsb2FkSUQgfSlcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIC8vIEVtaXQgY29tcGxldGlvbiBldmVudHMuXG4gICAgICAvLyBUaGlzIGlzIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24gc28gdGhhdCB0aGUgYGN1cnJlbnRVcGxvYWRzYCB2YXJpYWJsZVxuICAgICAgLy8gYWx3YXlzIHJlZmVycyB0byB0aGUgbGF0ZXN0IHN0YXRlLiBJbiB0aGUgaGFuZGxlciByaWdodCBhYm92ZSBpdCByZWZlcnNcbiAgICAgIC8vIHRvIGFuIG91dGRhdGVkIG9iamVjdCB3aXRob3V0IHRoZSBgLnJlc3VsdGAgcHJvcGVydHkuXG4gICAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICAgIGlmICghY3VycmVudFVwbG9hZHNbdXBsb2FkSURdKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudFVwbG9hZCA9IGN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXVxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGN1cnJlbnRVcGxvYWRcbiAgICAgIHRoaXMuZW1pdCgnY29tcGxldGUnLCByZXN1bHQpXG5cbiAgICAgIHRoaXMucmVtb3ZlVXBsb2FkKHVwbG9hZElEKVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcmVzdWx0IGZvciBhbiB1cGxvYWQgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAke3VwbG9hZElEfWApXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhbiB1cGxvYWQgZm9yIGFsbCB0aGUgZmlsZXMgdGhhdCBhcmUgbm90IGN1cnJlbnRseSBiZWluZyB1cGxvYWRlZC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICB1cGxvYWQgKCkge1xuICAgIGlmICghdGhpcy5wbHVnaW5zLnVwbG9hZGVyKSB7XG4gICAgICB0aGlzLmxvZygnTm8gdXBsb2FkZXIgdHlwZSBwbHVnaW5zIGFyZSB1c2VkJywgJ3dhcm5pbmcnKVxuICAgIH1cblxuICAgIGxldCB7IGZpbGVzIH0gPSB0aGlzLmdldFN0YXRlKClcblxuICAgIGNvbnN0IG9uQmVmb3JlVXBsb2FkUmVzdWx0ID0gdGhpcy5vcHRzLm9uQmVmb3JlVXBsb2FkKGZpbGVzKVxuXG4gICAgaWYgKG9uQmVmb3JlVXBsb2FkUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm90IHN0YXJ0aW5nIHRoZSB1cGxvYWQgYmVjYXVzZSBvbkJlZm9yZVVwbG9hZCByZXR1cm5lZCBmYWxzZScpKVxuICAgIH1cblxuICAgIGlmIChvbkJlZm9yZVVwbG9hZFJlc3VsdCAmJiB0eXBlb2Ygb25CZWZvcmVVcGxvYWRSZXN1bHQgPT09ICdvYmplY3QnKSB7XG4gICAgICBmaWxlcyA9IG9uQmVmb3JlVXBsb2FkUmVzdWx0XG4gICAgICAvLyBVcGRhdGluZyBmaWxlcyBpbiBzdGF0ZSwgYmVjYXVzZSB1cGxvYWRlciBwbHVnaW5zIHJlY2VpdmUgZmlsZSBJRHMsXG4gICAgICAvLyBhbmQgdGhlbiBmZXRjaCB0aGUgYWN0dWFsIGZpbGUgb2JqZWN0IGZyb20gc3RhdGVcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBmaWxlcyxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmNoZWNrTWluTnVtYmVyT2ZGaWxlcyhmaWxlcykpXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnNob3dPckxvZ0Vycm9yQW5kVGhyb3coZXJyKVxuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VXBsb2FkcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgICAgIC8vIGdldCBhIGxpc3Qgb2YgZmlsZXMgdGhhdCBhcmUgY3VycmVudGx5IGFzc2lnbmVkIHRvIHVwbG9hZHNcbiAgICAgICAgY29uc3QgY3VycmVudGx5VXBsb2FkaW5nRmlsZXMgPSBPYmplY3Qua2V5cyhjdXJyZW50VXBsb2FkcylcbiAgICAgICAgICAucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBwcmV2LmNvbmNhdChjdXJyZW50VXBsb2Fkc1tjdXJyXS5maWxlSURzKSwgW10pXG5cbiAgICAgICAgY29uc3Qgd2FpdGluZ0ZpbGVJRHMgPSBbXVxuICAgICAgICBPYmplY3Qua2V5cyhmaWxlcykuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZShmaWxlSUQpXG4gICAgICAgICAgLy8gaWYgdGhlIGZpbGUgaGFzbid0IHN0YXJ0ZWQgdXBsb2FkaW5nIGFuZCBoYXNuJ3QgYWxyZWFkeSBiZWVuIGFzc2lnbmVkIHRvIGFuIHVwbG9hZC4uXG4gICAgICAgICAgaWYgKCghZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkKSAmJiAoY3VycmVudGx5VXBsb2FkaW5nRmlsZXMuaW5kZXhPZihmaWxlSUQpID09PSAtMSkpIHtcbiAgICAgICAgICAgIHdhaXRpbmdGaWxlSURzLnB1c2goZmlsZS5pZClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgdXBsb2FkSUQgPSB0aGlzLmNyZWF0ZVVwbG9hZCh3YWl0aW5nRmlsZUlEcylcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuVXBsb2FkKHVwbG9hZElEKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhlcnIsIHtcbiAgICAgICAgICBzaG93SW5mb3JtZXI6IGZhbHNlLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvcmUgKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBVcHB5KG9wdHMpXG59XG5cbi8vIEV4cG9zZSBjbGFzcyBjb25zdHJ1Y3Rvci5cbm1vZHVsZS5leHBvcnRzLlVwcHkgPSBVcHB5XG5tb2R1bGUuZXhwb3J0cy5QbHVnaW4gPSBQbHVnaW5cbm1vZHVsZS5leHBvcnRzLmRlYnVnTG9nZ2VyID0gZGVidWdMb2dnZXJcbiIsImNvbnN0IGdldFRpbWVTdGFtcCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRUaW1lU3RhbXAnKVxuXG4vLyBTd2FsbG93IGFsbCBsb2dzLCBleGNlcHQgZXJyb3JzLlxuLy8gZGVmYXVsdCBpZiBsb2dnZXIgaXMgbm90IHNldCBvciBkZWJ1ZzogZmFsc2VcbmNvbnN0IGp1c3RFcnJvcnNMb2dnZXIgPSB7XG4gIGRlYnVnOiAoLi4uYXJncykgPT4ge30sXG4gIHdhcm46ICguLi5hcmdzKSA9PiB7fSxcbiAgZXJyb3I6ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKGBbVXBweV0gWyR7Z2V0VGltZVN0YW1wKCl9XWAsIC4uLmFyZ3MpLFxufVxuXG4vLyBQcmludCBsb2dzIHRvIGNvbnNvbGUgd2l0aCBuYW1lc3BhY2UgKyB0aW1lc3RhbXAsXG4vLyBzZXQgYnkgbG9nZ2VyOiBVcHB5LmRlYnVnTG9nZ2VyIG9yIGRlYnVnOiB0cnVlXG5jb25zdCBkZWJ1Z0xvZ2dlciA9IHtcbiAgZGVidWc6ICguLi5hcmdzKSA9PiB7XG4gICAgLy8gSUUgMTAgZG9lc27igJl0IHN1cHBvcnQgY29uc29sZS5kZWJ1Z1xuICAgIGNvbnN0IGRlYnVnID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZ1xuICAgIGRlYnVnLmNhbGwoY29uc29sZSwgYFtVcHB5XSBbJHtnZXRUaW1lU3RhbXAoKX1dYCwgLi4uYXJncylcbiAgfSxcbiAgd2FybjogKC4uLmFyZ3MpID0+IGNvbnNvbGUud2FybihgW1VwcHldIFske2dldFRpbWVTdGFtcCgpfV1gLCAuLi5hcmdzKSxcbiAgZXJyb3I6ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKGBbVXBweV0gWyR7Z2V0VGltZVN0YW1wKCl9XWAsIC4uLmFyZ3MpLFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAganVzdEVycm9yc0xvZ2dlcixcbiAgZGVidWdMb2dnZXIsXG59XG4iLCIvLyBFZGdlIDE1LnggZG9lcyBub3QgZmlyZSAncHJvZ3Jlc3MnIGV2ZW50cyBvbiB1cGxvYWRzLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlcy85NDVcbi8vIEFuZCBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMjIyNDUxMC9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyAodXNlckFnZW50KSB7XG4gIC8vIEFsbG93IHBhc3NpbmcgaW4gdXNlckFnZW50IGZvciB0ZXN0c1xuICBpZiAodXNlckFnZW50ID09IG51bGwpIHtcbiAgICB1c2VyQWdlbnQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci51c2VyQWdlbnQgOiBudWxsXG4gIH1cbiAgLy8gQXNzdW1lIGl0IHdvcmtzIGJlY2F1c2UgYmFzaWNhbGx5IGV2ZXJ5dGhpbmcgc3VwcG9ydHMgcHJvZ3Jlc3MgZXZlbnRzLlxuICBpZiAoIXVzZXJBZ2VudCkgcmV0dXJuIHRydWVcblxuICBjb25zdCBtID0gL0VkZ2VcXC8oXFxkK1xcLlxcZCspLy5leGVjKHVzZXJBZ2VudClcbiAgaWYgKCFtKSByZXR1cm4gdHJ1ZVxuXG4gIGNvbnN0IGVkZ2VWZXJzaW9uID0gbVsxXVxuICBsZXQgW21ham9yLCBtaW5vcl0gPSBlZGdlVmVyc2lvbi5zcGxpdCgnLicpXG4gIG1ham9yID0gcGFyc2VJbnQobWFqb3IsIDEwKVxuICBtaW5vciA9IHBhcnNlSW50KG1pbm9yLCAxMClcblxuICAvLyBXb3JrZWQgYmVmb3JlOlxuICAvLyBFZGdlIDQwLjE1MDYzLjAuMFxuICAvLyBNaWNyb3NvZnQgRWRnZUhUTUwgMTUuMTUwNjNcbiAgaWYgKG1ham9yIDwgMTUgfHwgKG1ham9yID09PSAxNSAmJiBtaW5vciA8IDE1MDYzKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBGaXhlZCBpbjpcbiAgLy8gTWljcm9zb2Z0IEVkZ2VIVE1MIDE4LjE4MjE4XG4gIGlmIChtYWpvciA+IDE4IHx8IChtYWpvciA9PT0gMTggJiYgbWlub3IgPj0gMTgyMTgpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIG90aGVyIHZlcnNpb25zIGRvbid0IHdvcmsuXG4gIHJldHVybiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9kYXNoYm9hcmRcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlVuaXZlcnNhbCBVSSBwbHVnaW4gZm9yIFVwcHkuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuMjAuMlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwic3R5bGVcIjogXCJkaXN0L3N0eWxlLm1pbi5jc3NcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwiZGFzaGJvYXJkXCIsXG4gICAgXCJ1aVwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzXCI6IFwiMC4wLjdcIixcbiAgICBcIkB1cHB5L2luZm9ybWVyXCI6IFwiZmlsZTouLi9pbmZvcm1lclwiLFxuICAgIFwiQHVwcHkvcHJvdmlkZXItdmlld3NcIjogXCJmaWxlOi4uL3Byb3ZpZGVyLXZpZXdzXCIsXG4gICAgXCJAdXBweS9zdGF0dXMtYmFyXCI6IFwiZmlsZTouLi9zdGF0dXMtYmFyXCIsXG4gICAgXCJAdXBweS90aHVtYm5haWwtZ2VuZXJhdG9yXCI6IFwiZmlsZTouLi90aHVtYm5haWwtZ2VuZXJhdG9yXCIsXG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIixcbiAgICBcImNsYXNzbmFtZXNcIjogXCJeMi4yLjZcIixcbiAgICBcImN1aWRcIjogXCJeMi4xLjFcIixcbiAgICBcImlzLXNoYWxsb3ctZXF1YWxcIjogXCJeMS4wLjFcIixcbiAgICBcImxvZGFzaC5kZWJvdW5jZVwiOiBcIl40LjAuOFwiLFxuICAgIFwibG9kYXNoLnRocm90dGxlXCI6IFwiXjQuMS4xXCIsXG4gICAgXCJtZW1vaXplLW9uZVwiOiBcIl41LjAuNFwiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIixcbiAgICBcInJlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbFwiOiBcIl4xLjUuMFwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNsYXNzIEFkZEZpbGVzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgdHJpZ2dlckZpbGVJbnB1dENsaWNrID0gKCkgPT4ge1xuICAgIHRoaXMuZmlsZUlucHV0LmNsaWNrKClcbiAgfVxuXG4gIHRyaWdnZXJGb2xkZXJJbnB1dENsaWNrID0gKCkgPT4ge1xuICAgIHRoaXMuZm9sZGVySW5wdXQuY2xpY2soKVxuICB9XG5cbiAgb25GaWxlSW5wdXRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICB0aGlzLnByb3BzLmhhbmRsZUlucHV0Q2hhbmdlKGV2ZW50KVxuXG4gICAgLy8gV2UgY2xlYXIgdGhlIGlucHV0IGFmdGVyIGEgZmlsZSBpcyBzZWxlY3RlZCwgYmVjYXVzZSBvdGhlcndpc2VcbiAgICAvLyBjaGFuZ2UgZXZlbnQgaXMgbm90IGZpcmVkIGluIENocm9tZSBhbmQgU2FmYXJpIHdoZW4gYSBmaWxlXG4gICAgLy8gd2l0aCB0aGUgc2FtZSBuYW1lIGlzIHNlbGVjdGVkLlxuICAgIC8vIF9fX1doeSBub3QgdXNlIHZhbHVlPVwiXCIgb24gPGlucHV0Lz4gaW5zdGVhZD9cbiAgICAvLyAgICBCZWNhdXNlIGlmIHdlIHVzZSB0aGF0IG1ldGhvZCBvZiBjbGVhcmluZyB0aGUgaW5wdXQsXG4gICAgLy8gICAgQ2hyb21lIHdpbGwgbm90IHRyaWdnZXIgY2hhbmdlIGlmIHdlIGRyb3AgdGhlIHNhbWUgZmlsZSB0d2ljZSAoSXNzdWUgIzc2OCkuXG4gICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gbnVsbFxuICB9XG5cbiAgcmVuZGVyUG93ZXJlZEJ5VXBweSAoKSB7XG4gICAgY29uc3QgdXBweUJyYW5kaW5nID0gKFxuICAgICAgPHNwYW4+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvbiB1cHB5LURhc2hib2FyZC1wb3dlcmVkQnlJY29uXCIgd2lkdGg9XCIxMVwiIGhlaWdodD1cIjExXCIgdmlld0JveD1cIjAgMCAxMSAxMVwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNNy4zNjUgMTAuNWwtLjAxLTQuMDQ1aDIuNjEyTDUuNS44MDZsLTQuNDY3IDUuNjVoMi42MDRsLjAxIDQuMDQ0aDMuNzE4elwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1wb3dlcmVkQnlVcHB5XCI+VXBweTwvc3Bhbj5cbiAgICAgIDwvc3Bhbj5cbiAgICApXG5cbiAgICAvLyBTdXBwb3J0IGJvdGggdGhlIG9sZCB3b3JkLW9yZGVyLWluc2Vuc2l0aXZlIHN0cmluZyBgcG93ZXJlZEJ5YCBhbmQgdGhlIG5ldyB3b3JkLW9yZGVyLXNlbnNpdGl2ZSBzdHJpbmcgYHBvd2VyZWRCeTJgXG4gICAgY29uc3QgbGlua1RleHQgPSB0aGlzLnByb3BzLmkxOG5BcnJheSgncG93ZXJlZEJ5MicsIHtcbiAgICAgIGJhY2t3YXJkc0NvbXBhdDogdGhpcy5wcm9wcy5pMThuKCdwb3dlcmVkQnknKSxcbiAgICAgIHVwcHk6IHVwcHlCcmFuZGluZyxcbiAgICB9KVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxhXG4gICAgICAgIHRhYkluZGV4PVwiLTFcIlxuICAgICAgICBocmVmPVwiaHR0cHM6Ly91cHB5LmlvXCJcbiAgICAgICAgcmVsPVwibm9yZWZlcnJlciBub29wZW5lclwiXG4gICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLXBvd2VyZWRCeVwiXG4gICAgICA+XG4gICAgICAgIHtsaW5rVGV4dH1cbiAgICAgIDwvYT5cbiAgICApXG4gIH1cblxuICByZW5kZXJIaWRkZW5JbnB1dCA9IChpc0ZvbGRlciwgcmVmQ2FsbGJhY2spID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPGlucHV0XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLWlucHV0XCJcbiAgICAgICAgaGlkZGVuXG4gICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgIHRhYkluZGV4PXstMX1cbiAgICAgICAgd2Via2l0ZGlyZWN0b3J5PXtpc0ZvbGRlcn1cbiAgICAgICAgdHlwZT1cImZpbGVcIlxuICAgICAgICBuYW1lPVwiZmlsZXNbXVwiXG4gICAgICAgIG11bHRpcGxlPXt0aGlzLnByb3BzLm1heE51bWJlck9mRmlsZXMgIT09IDF9XG4gICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uRmlsZUlucHV0Q2hhbmdlfVxuICAgICAgICBhY2NlcHQ9e3RoaXMucHJvcHMuYWxsb3dlZEZpbGVUeXBlc31cbiAgICAgICAgcmVmPXtyZWZDYWxsYmFja31cbiAgICAgIC8+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyTXlEZXZpY2VBY3F1aXJlciA9ICgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZFRhYlwiXG4gICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICBkYXRhLXVwcHktYWNxdWlyZXItaWQ9XCJNeURldmljZVwiXG4gICAgICA+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LURhc2hib2FyZFRhYi1idG5cIlxuICAgICAgICAgIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgIHRhYkluZGV4PXswfVxuICAgICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLnRyaWdnZXJGaWxlSW5wdXRDbGlja31cbiAgICAgICAgPlxuICAgICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIGZpbGw9XCIjMjI3NUQ3XCIgLz5cbiAgICAgICAgICAgICAgPHBhdGggZD1cIk0yMS45NzMgMjEuMTUySDkuODYzbC0xLjEwOC01LjA4N2gxNC40NjRsLTEuMjQ2IDUuMDg3ek05LjkzNSAxMS4zN2gzLjk1OGwuODg2IDEuNDQ0YS42NzMuNjczIDAgMCAwIC41ODUuMzE2aDYuNTA2djEuMzdIOS45MzV2LTMuMTN6bTE0Ljg5OCAzLjQ0YS43OTMuNzkzIDAgMCAwLS42MTYtLjMxaC0uOTc4di0yLjEyNmMwLS4zNzktLjI3NS0uNjEzLS42NTMtLjYxM0gxNS43NWwtLjg4Ni0xLjQ0NWEuNjczLjY3MyAwIDAgMC0uNTg1LS4zMTZIOS4yMzJjLS4zNzggMC0uNjY3LjIwOS0uNjY3LjU4N1YxNC41aC0uNzgyYS43OTMuNzkzIDAgMCAwLS42MS4zMDMuNzk1Ljc5NSAwIDAgMC0uMTU1LjY2M2wxLjQ1IDYuNjMzYy4wNzguMzYuMzk2LjYxOC43NjQuNjE4aDEzLjM1NGMuMzYgMCAuNjc0LS4yNDYuNzYtLjU5NWwxLjYzMS02LjYzNmEuNzk1Ljc5NSAwIDAgMC0uMTQ0LS42NzV6XCIgZmlsbD1cIiNGRkZcIiAvPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRUYWItbmFtZVwiPnt0aGlzLnByb3BzLmkxOG4oJ215RGV2aWNlJyl9PC9kaXY+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyQnJvd3NlQnV0dG9uID0gKHRleHQsIG9uQ2xpY2tGbikgPT4ge1xuICAgIGNvbnN0IG51bWJlck9mQWNxdWlyZXJzID0gdGhpcy5wcm9wcy5hY3F1aXJlcnMubGVuZ3RoXG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LURhc2hib2FyZC1icm93c2VcIlxuICAgICAgICBvbkNsaWNrPXtvbkNsaWNrRm59XG4gICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGU9e251bWJlck9mQWNxdWlyZXJzID09PSAwfVxuICAgICAgPlxuICAgICAgICB7dGV4dH1cbiAgICAgIDwvYnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIC8vIFRPRE8oMi54KSByZW1vdmUgYWxsIHRoZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBnYXJiYWdlIGhlcmVcbiAgcmVuZGVyRHJvcFBhc3RlQnJvd3NlVGFnbGluZSA9ICgpID0+IHtcbiAgICBjb25zdCBudW1iZXJPZkFjcXVpcmVycyA9IHRoaXMucHJvcHMuYWNxdWlyZXJzLmxlbmd0aFxuICAgIC8vIGluIG9yZGVyIHRvIGtlZXAgdGhlIGkxOG4gQ2FtZWxDYXNlIGFuZCBvcHRpb25zIGxvd2VyIChhcyBhcmUgZGVmYXVsdHMpIHdlIHdpbGwgd2FudCB0byB0cmFuc2Zvcm0gYSBsb3dlclxuICAgIC8vIHRvIENhbWVsXG4gICAgY29uc3QgbG93ZXJGTVNlbGVjdGlvblR5cGUgPSB0aGlzLnByb3BzLmZpbGVNYW5hZ2VyU2VsZWN0aW9uVHlwZVxuICAgIGNvbnN0IGNhbWVsRk1TZWxlY3Rpb25UeXBlID0gbG93ZXJGTVNlbGVjdGlvblR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBsb3dlckZNU2VsZWN0aW9uVHlwZS5zbGljZSgxKVxuXG4gICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3ZSBuZWVkIHRvIHN1cHBvcnQgYm90aCAnYnJvd3NlJyBhbmQgJ2Jyb3dzZUZpbGVzJy8nYnJvd3NlRm9sZGVycycgYXMgc3RyaW5ncyBoZXJlLlxuICAgIGxldCBicm93c2VUZXh0ID0gJ2Jyb3dzZSdcbiAgICBsZXQgYnJvd3NlRmlsZXNUZXh0ID0gJ2Jyb3dzZSdcbiAgICBsZXQgYnJvd3NlRm9sZGVyc1RleHQgPSAnYnJvd3NlJ1xuICAgIGlmIChsb3dlckZNU2VsZWN0aW9uVHlwZSA9PT0gJ2ZpbGVzJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYnJvd3NlVGV4dCA9IHRoaXMucHJvcHMuaTE4bignYnJvd3NlJylcbiAgICAgICAgYnJvd3NlRmlsZXNUZXh0ID0gdGhpcy5wcm9wcy5pMThuKCdicm93c2UnKVxuICAgICAgICBicm93c2VGb2xkZXJzVGV4dCA9IHRoaXMucHJvcHMuaTE4bignYnJvd3NlJylcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBJZ25vcmUsIGhvcGVmdWxseSB3ZSBjYW4gdXNlIHRoZSAnYnJvd3NlRmlsZXMnIC8gJ2Jyb3dzZUZvbGRlcnMnIHN0cmluZ3NcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGJyb3dzZUZpbGVzVGV4dCA9IHRoaXMucHJvcHMuaTE4bignYnJvd3NlRmlsZXMnKVxuICAgICAgYnJvd3NlRm9sZGVyc1RleHQgPSB0aGlzLnByb3BzLmkxOG4oJ2Jyb3dzZUZvbGRlcnMnKVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWdub3JlLCB1c2UgdGhlICdicm93c2UnIHN0cmluZ1xuICAgIH1cblxuICAgIGNvbnN0IGJyb3dzZSA9IHRoaXMucmVuZGVyQnJvd3NlQnV0dG9uKGJyb3dzZVRleHQsIHRoaXMudHJpZ2dlckZpbGVJbnB1dENsaWNrKVxuICAgIGNvbnN0IGJyb3dzZUZpbGVzID0gdGhpcy5yZW5kZXJCcm93c2VCdXR0b24oYnJvd3NlRmlsZXNUZXh0LCB0aGlzLnRyaWdnZXJGaWxlSW5wdXRDbGljaylcbiAgICBjb25zdCBicm93c2VGb2xkZXJzID0gdGhpcy5yZW5kZXJCcm93c2VCdXR0b24oYnJvd3NlRm9sZGVyc1RleHQsIHRoaXMudHJpZ2dlckZvbGRlcklucHV0Q2xpY2spXG5cbiAgICAvLyBCZWZvcmUgdGhlIGBmaWxlTWFuYWdlclNlbGVjdGlvblR5cGVgIGZlYXR1cmUgZXhpc3RlZCwgd2UgaGFkIHR3byBwb3NzaWJsZVxuICAgIC8vIHN0cmluZ3MgaGVyZSwgYnV0IG5vdyB3ZSBoYXZlIHNpeC4gV2UgdXNlIHRoZSBuZXctc3R5bGUgc3RyaW5ncyBieSBkZWZhdWx0OlxuICAgIGxldCB0aXRsZVRleHRcbiAgICBpZiAobnVtYmVyT2ZBY3F1aXJlcnMgPiAwKSB7XG4gICAgICB0aXRsZVRleHQgPSB0aGlzLnByb3BzLmkxOG5BcnJheShgZHJvcFBhc3RlSW1wb3J0JHtjYW1lbEZNU2VsZWN0aW9uVHlwZX1gLCB7IGJyb3dzZUZpbGVzLCBicm93c2VGb2xkZXJzLCBicm93c2UgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVUZXh0ID0gdGhpcy5wcm9wcy5pMThuQXJyYXkoYGRyb3BQYXN0ZSR7Y2FtZWxGTVNlbGVjdGlvblR5cGV9YCwgeyBicm93c2VGaWxlcywgYnJvd3NlRm9sZGVycywgYnJvd3NlIH0pXG4gICAgfVxuXG4gICAgLy8gV2UgdXNlIHRoZSBvbGQtc3R5bGUgc3RyaW5ncyBpZiBhdmFpbGFibGU6IHRoaXMgaW1wbGllcyB0aGF0IHRoZSB1c2VyIGhhc1xuICAgIC8vIG1hbnVhbGx5IHNwZWNpZmllZCB0aGVtLCBzbyB0aGV5IHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGUgbmV3LXN0eWxlXG4gICAgLy8gZGVmYXVsdHMuXG4gICAgaWYgKGxvd2VyRk1TZWxlY3Rpb25UeXBlID09PSAnZmlsZXMnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAobnVtYmVyT2ZBY3F1aXJlcnMgPiAwKSB7XG4gICAgICAgICAgdGl0bGVUZXh0ID0gdGhpcy5wcm9wcy5pMThuQXJyYXkoJ2Ryb3BQYXN0ZUltcG9ydCcsIHsgYnJvd3NlIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGl0bGVUZXh0ID0gdGhpcy5wcm9wcy5pMThuQXJyYXkoJ2Ryb3BQYXN0ZScsIHsgYnJvd3NlIH0pXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBJZ25vcmUsIHRoZSBuZXctc3R5bGUgc3RyaW5ncyB3aWxsIGJlIHVzZWQuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZUxvY2FsRmlsZXMpIHtcbiAgICAgIHRpdGxlVGV4dCA9IHRoaXMucHJvcHMuaTE4bignaW1wb3J0RmlsZXMnKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUFkZEZpbGVzLXRpdGxlXCI+XG4gICAgICAgIHt0aXRsZVRleHR9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZW5kZXJBY3F1aXJlciA9IChhY3F1aXJlcikgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkVGFiXCJcbiAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgIGRhdGEtdXBweS1hY3F1aXJlci1pZD17YWNxdWlyZXIuaWR9XG4gICAgICA+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LURhc2hib2FyZFRhYi1idG5cIlxuICAgICAgICAgIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgIHRhYkluZGV4PXswfVxuICAgICAgICAgIGFyaWEtY29udHJvbHM9e2B1cHB5LURhc2hib2FyZENvbnRlbnQtcGFuZWwtLSR7YWNxdWlyZXIuaWR9YH1cbiAgICAgICAgICBhcmlhLXNlbGVjdGVkPXt0aGlzLnByb3BzLmFjdGl2ZVBpY2tlclBhbmVsLmlkID09PSBhY3F1aXJlci5pZH1cbiAgICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gdGhpcy5wcm9wcy5zaG93UGFuZWwoYWNxdWlyZXIuaWQpfVxuICAgICAgICA+XG4gICAgICAgICAge2FjcXVpcmVyLmljb24oKX1cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkVGFiLW5hbWVcIj57YWNxdWlyZXIubmFtZX08L2Rpdj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZW5kZXJBY3F1aXJlcnMgPSAoYWNxdWlyZXJzLCBkaXNhYmxlTG9jYWxGaWxlcykgPT4ge1xuICAgIC8vIEdyb3VwIGxhc3QgdHdvIGJ1dHRvbnMsIHNvIHdlIGRvbuKAmXQgZW5kIHVwIHdpdGhcbiAgICAvLyBqdXN0IG9uZSBidXR0b24gb24gYSBuZXcgbGluZVxuICAgIGNvbnN0IGFjcXVpcmVyc1dpdGhvdXRMYXN0VHdvID0gWy4uLmFjcXVpcmVyc11cbiAgICBjb25zdCBsYXN0VHdvQWNxdWlyZXJzID0gYWNxdWlyZXJzV2l0aG91dExhc3RUd28uc3BsaWNlKGFjcXVpcmVycy5sZW5ndGggLSAyLCBhY3F1aXJlcnMubGVuZ3RoKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtQWRkRmlsZXMtbGlzdFwiIHJvbGU9XCJ0YWJsaXN0XCI+XG4gICAgICAgIHshZGlzYWJsZUxvY2FsRmlsZXMgJiYgdGhpcy5yZW5kZXJNeURldmljZUFjcXVpcmVyKCl9XG4gICAgICAgIHthY3F1aXJlcnNXaXRob3V0TGFzdFR3by5tYXAoKGFjcXVpcmVyKSA9PiB0aGlzLnJlbmRlckFjcXVpcmVyKGFjcXVpcmVyKSl9XG4gICAgICAgIDxzcGFuIHJvbGU9XCJwcmVzZW50YXRpb25cIiBzdHlsZT1cIndoaXRlLXNwYWNlOiBub3dyYXA7XCI+XG4gICAgICAgICAge2xhc3RUd29BY3F1aXJlcnMubWFwKChhY3F1aXJlcikgPT4gdGhpcy5yZW5kZXJBY3F1aXJlcihhY3F1aXJlcikpfVxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUFkZEZpbGVzXCI+XG4gICAgICAgIHt0aGlzLnJlbmRlckhpZGRlbklucHV0KGZhbHNlLCAocmVmKSA9PiB7IHRoaXMuZmlsZUlucHV0ID0gcmVmIH0pfVxuICAgICAgICB7dGhpcy5yZW5kZXJIaWRkZW5JbnB1dCh0cnVlLCAocmVmKSA9PiB7IHRoaXMuZm9sZGVySW5wdXQgPSByZWYgfSl9XG4gICAgICAgIHt0aGlzLnJlbmRlckRyb3BQYXN0ZUJyb3dzZVRhZ2xpbmUoKX1cbiAgICAgICAge3RoaXMucHJvcHMuYWNxdWlyZXJzLmxlbmd0aCA+IDAgJiYgdGhpcy5yZW5kZXJBY3F1aXJlcnModGhpcy5wcm9wcy5hY3F1aXJlcnMsIHRoaXMucHJvcHMuZGlzYWJsZUxvY2FsRmlsZXMpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUFkZEZpbGVzLWluZm9cIj5cbiAgICAgICAgICB7dGhpcy5wcm9wcy5ub3RlICYmIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtbm90ZVwiPnt0aGlzLnByb3BzLm5vdGV9PC9kaXY+fVxuICAgICAgICAgIHt0aGlzLnByb3BzLnByb3VkbHlEaXNwbGF5UG93ZXJlZEJ5VXBweSAmJiB0aGlzLnJlbmRlclBvd2VyZWRCeVVwcHkodGhpcy5wcm9wcyl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWRkRmlsZXNcbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IEFkZEZpbGVzID0gcmVxdWlyZSgnLi9BZGRGaWxlcycpXG5cbmNvbnN0IEFkZEZpbGVzUGFuZWwgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3VwcHktRGFzaGJvYXJkLUFkZEZpbGVzUGFuZWwnLCBwcm9wcy5jbGFzc05hbWUpfVxuICAgICAgZGF0YS11cHB5LXBhbmVsVHlwZT1cIkFkZEZpbGVzXCJcbiAgICAgIGFyaWEtaGlkZGVuPXtwcm9wcy5zaG93QWRkRmlsZXNQYW5lbH1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC1iYXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtdGl0bGVcIiByb2xlPVwiaGVhZGluZ1wiIGFyaWEtbGV2ZWw9XCIxXCI+XG4gICAgICAgICAge3Byb3BzLmkxOG4oJ2FkZGluZ01vcmVGaWxlcycpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC1iYWNrXCJcbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBvbkNsaWNrPXsoZXYpID0+IHByb3BzLnRvZ2dsZUFkZEZpbGVzUGFuZWwoZmFsc2UpfVxuICAgICAgICA+XG4gICAgICAgICAge3Byb3BzLmkxOG4oJ2JhY2snKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxBZGRGaWxlcyB7Li4ucHJvcHN9IC8+XG4gICAgPC9kaXY+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBZGRGaWxlc1BhbmVsXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBGaWxlTGlzdCA9IHJlcXVpcmUoJy4vRmlsZUxpc3QnKVxuY29uc3QgQWRkRmlsZXMgPSByZXF1aXJlKCcuL0FkZEZpbGVzJylcbmNvbnN0IEFkZEZpbGVzUGFuZWwgPSByZXF1aXJlKCcuL0FkZEZpbGVzUGFuZWwnKVxuY29uc3QgUGlja2VyUGFuZWxDb250ZW50ID0gcmVxdWlyZSgnLi9QaWNrZXJQYW5lbENvbnRlbnQnKVxuY29uc3QgRWRpdG9yUGFuZWwgPSByZXF1aXJlKCcuL0VkaXRvclBhbmVsJylcbmNvbnN0IFBhbmVsVG9wQmFyID0gcmVxdWlyZSgnLi9QaWNrZXJQYW5lbFRvcEJhcicpXG5jb25zdCBGaWxlQ2FyZCA9IHJlcXVpcmUoJy4vRmlsZUNhcmQnKVxuY29uc3QgU2xpZGUgPSByZXF1aXJlKCcuL1NsaWRlJylcbmNvbnN0IGlzRHJhZ0Ryb3BTdXBwb3J0ZWQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaXNEcmFnRHJvcFN1cHBvcnRlZCcpXG5cbi8vIGh0dHA6Ly9kZXYuZWRlbnNwaWVrZXJtYW5uLmNvbS8yMDE2LzAyLzExL2ludHJvZHVjaW5nLWFjY2Vzc2libGUtbW9kYWwtZGlhbG9nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2hvc2gvbWljcm9tb2RhbFxuXG5jb25zdCBXSURUSF9YTCA9IDkwMFxuY29uc3QgV0lEVEhfTEcgPSA3MDBcbmNvbnN0IFdJRFRIX01EID0gNTc2XG5jb25zdCBIRUlHSFRfTUQgPSA0MDBcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBEYXNoYm9hcmQgKHByb3BzKSB7XG4gIGNvbnN0IG5vRmlsZXMgPSBwcm9wcy50b3RhbEZpbGVDb3VudCA9PT0gMFxuICBjb25zdCBpc1NpemVNRCA9IHByb3BzLmNvbnRhaW5lcldpZHRoID4gV0lEVEhfTURcblxuICBjb25zdCB3cmFwcGVyQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyh7XG4gICAgJ3VwcHktUm9vdCc6IHByb3BzLmlzVGFyZ2V0RE9NRWwsXG4gIH0pXG5cbiAgY29uc3QgZGFzaGJvYXJkQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyh7XG4gICAgJ3VwcHktRGFzaGJvYXJkJzogdHJ1ZSxcbiAgICAndXBweS1EYXNoYm9hcmQtLWlzRGlzYWJsZWQnOiBwcm9wcy5kaXNhYmxlZCxcbiAgICAndXBweS1EYXNoYm9hcmQtLWFuaW1hdGVPcGVuQ2xvc2UnOiBwcm9wcy5hbmltYXRlT3BlbkNsb3NlLFxuICAgICd1cHB5LURhc2hib2FyZC0taXNDbG9zaW5nJzogcHJvcHMuaXNDbG9zaW5nLFxuICAgICd1cHB5LURhc2hib2FyZC0taXNEcmFnZ2luZ092ZXInOiBwcm9wcy5pc0RyYWdnaW5nT3ZlcixcbiAgICAndXBweS1EYXNoYm9hcmQtLW1vZGFsJzogIXByb3BzLmlubGluZSxcbiAgICAndXBweS1zaXplLS1tZCc6IHByb3BzLmNvbnRhaW5lcldpZHRoID4gV0lEVEhfTUQsXG4gICAgJ3VwcHktc2l6ZS0tbGcnOiBwcm9wcy5jb250YWluZXJXaWR0aCA+IFdJRFRIX0xHLFxuICAgICd1cHB5LXNpemUtLXhsJzogcHJvcHMuY29udGFpbmVyV2lkdGggPiBXSURUSF9YTCxcbiAgICAndXBweS1zaXplLS1oZWlnaHQtbWQnOiBwcm9wcy5jb250YWluZXJIZWlnaHQgPiBIRUlHSFRfTUQsXG4gICAgJ3VwcHktRGFzaGJvYXJkLS1pc0FkZEZpbGVzUGFuZWxWaXNpYmxlJzogcHJvcHMuc2hvd0FkZEZpbGVzUGFuZWwsXG4gICAgJ3VwcHktRGFzaGJvYXJkLS1pc0lubmVyV3JhcFZpc2libGUnOiBwcm9wcy5hcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZSxcbiAgfSlcblxuICAvLyBJbXBvcnRhbnQ6IGtlZXAgdGhlc2UgaW4gc3luYyB3aXRoIHRoZSBwZXJjZW50IHdpZHRoIHZhbHVlcyBpbiBgc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vaW5kZXguc2Nzc2AuXG4gIGxldCBpdGVtc1BlclJvdyA9IDEgLy8gbW9iaWxlXG4gIGlmIChwcm9wcy5jb250YWluZXJXaWR0aCA+IFdJRFRIX1hMKSB7XG4gICAgaXRlbXNQZXJSb3cgPSA1XG4gIH0gZWxzZSBpZiAocHJvcHMuY29udGFpbmVyV2lkdGggPiBXSURUSF9MRykge1xuICAgIGl0ZW1zUGVyUm93ID0gNFxuICB9IGVsc2UgaWYgKHByb3BzLmNvbnRhaW5lcldpZHRoID4gV0lEVEhfTUQpIHtcbiAgICBpdGVtc1BlclJvdyA9IDNcbiAgfVxuXG4gIGNvbnN0IHNob3dGaWxlTGlzdCA9IHByb3BzLnNob3dTZWxlY3RlZEZpbGVzICYmICFub0ZpbGVzXG5cbiAgY29uc3QgbnVtYmVyT2ZGaWxlc0ZvclJlY292ZXJ5ID0gcHJvcHMucmVjb3ZlcmVkU3RhdGUgPyBPYmplY3Qua2V5cyhwcm9wcy5yZWNvdmVyZWRTdGF0ZS5maWxlcykubGVuZ3RoIDogbnVsbFxuICBjb25zdCBudW1iZXJPZkdob3N0cyA9IHByb3BzLmZpbGVzID8gT2JqZWN0LmtleXMocHJvcHMuZmlsZXMpLmZpbHRlcigoZmlsZUlEKSA9PiBwcm9wcy5maWxlc1tmaWxlSURdLmlzR2hvc3QpLmxlbmd0aCA6IG51bGxcblxuICBjb25zdCByZW5kZXJSZXN0b3JlZFRleHQgPSAoKSA9PiB7XG4gICAgaWYgKG51bWJlck9mR2hvc3RzID4gMCkge1xuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3JlY292ZXJlZFhGaWxlcycsIHtcbiAgICAgICAgc21hcnRfY291bnQ6IG51bWJlck9mR2hvc3RzLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHMuaTE4bigncmVjb3ZlcmVkQWxsRmlsZXMnKVxuICB9XG5cbiAgY29uc3QgZGFzaGJvYXJkID0gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17ZGFzaGJvYXJkQ2xhc3NOYW1lfVxuICAgICAgZGF0YS11cHB5LXRoZW1lPXtwcm9wcy50aGVtZX1cbiAgICAgIGRhdGEtdXBweS1udW0tYWNxdWlyZXJzPXtwcm9wcy5hY3F1aXJlcnMubGVuZ3RofVxuICAgICAgZGF0YS11cHB5LWRyYWctZHJvcC1zdXBwb3J0ZWQ9eyFwcm9wcy5kaXNhYmxlTG9jYWxGaWxlcyAmJiBpc0RyYWdEcm9wU3VwcG9ydGVkKCl9XG4gICAgICBhcmlhLWhpZGRlbj17cHJvcHMuaW5saW5lID8gJ2ZhbHNlJyA6IHByb3BzLmlzSGlkZGVufVxuICAgICAgYXJpYS1kaXNhYmxlZD17cHJvcHMuZGlzYWJsZWR9XG4gICAgICBhcmlhLWxhYmVsPXshcHJvcHMuaW5saW5lID8gcHJvcHMuaTE4bignZGFzaGJvYXJkV2luZG93VGl0bGUnKSA6IHByb3BzLmkxOG4oJ2Rhc2hib2FyZFRpdGxlJyl9XG4gICAgICBvblBhc3RlPXtwcm9wcy5oYW5kbGVQYXN0ZX1cbiAgICAgIG9uRHJhZ092ZXI9e3Byb3BzLmhhbmRsZURyYWdPdmVyfVxuICAgICAgb25EcmFnTGVhdmU9e3Byb3BzLmhhbmRsZURyYWdMZWF2ZX1cbiAgICAgIG9uRHJvcD17cHJvcHMuaGFuZGxlRHJvcH1cbiAgICA+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLW92ZXJsYXlcIlxuICAgICAgICB0YWJJbmRleD17LTF9XG4gICAgICAgIG9uQ2xpY2s9e3Byb3BzLmhhbmRsZUNsaWNrT3V0c2lkZX1cbiAgICAgIC8+XG5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtaW5uZXJcIlxuICAgICAgICBhcmlhLW1vZGFsPXshcHJvcHMuaW5saW5lICYmICd0cnVlJ31cbiAgICAgICAgcm9sZT17IXByb3BzLmlubGluZSAmJiAnZGlhbG9nJ31cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICB3aWR0aDogcHJvcHMuaW5saW5lICYmIHByb3BzLndpZHRoID8gcHJvcHMud2lkdGggOiAnJyxcbiAgICAgICAgICBoZWlnaHQ6IHByb3BzLmlubGluZSAmJiBwcm9wcy5oZWlnaHQgPyBwcm9wcy5oZWlnaHQgOiAnJyxcbiAgICAgICAgfX1cbiAgICAgID5cblxuICAgICAgICB7IXByb3BzLmlubGluZSA/IChcbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1EYXNoYm9hcmQtY2xvc2VcIlxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBhcmlhLWxhYmVsPXtwcm9wcy5pMThuKCdjbG9zZU1vZGFsJyl9XG4gICAgICAgICAgICB0aXRsZT17cHJvcHMuaTE4bignY2xvc2VNb2RhbCcpfVxuICAgICAgICAgICAgb25DbGljaz17cHJvcHMuY2xvc2VNb2RhbH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApIDogbnVsbH1cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLWlubmVyV3JhcFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtZHJvcEZpbGVzSGVyZUhpbnRcIj5cbiAgICAgICAgICAgIHtwcm9wcy5pMThuKCdkcm9wSGludCcpfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAge3Nob3dGaWxlTGlzdCAmJiA8UGFuZWxUb3BCYXIgey4uLnByb3BzfSAvPn1cblxuICAgICAgICAgIHtudW1iZXJPZkZpbGVzRm9yUmVjb3ZlcnkgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1zZXJ2aWNlTXNnXCI+XG4gICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtc2VydmljZU1zZy1pY29uXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjIxXCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDE5XCI+XG4gICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAgLTEpXCIgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTIuODU3IDEuNDNsMTAuMjM0IDE3LjA1NkExIDEgMCAwMTIyLjIzNCAyMEgxLjc2NmExIDEgMCAwMS0uODU3LTEuNTE0TDExLjE0MyAxLjQyOWExIDEgMCAwMTEuNzE0IDB6XCIgZmlsbD1cIiNGRkQzMDBcIiAvPlxuICAgICAgICAgICAgICAgICAgPHBhdGggZmlsbD1cIiMwMDBcIiBkPVwiTTExIDZoMmwtLjMgOGgtMS40elwiIC8+XG4gICAgICAgICAgICAgICAgICA8Y2lyY2xlIGZpbGw9XCIjMDAwXCIgY3g9XCIxMlwiIGN5PVwiMTdcIiByPVwiMVwiIC8+XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgPHN0cm9uZyBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1zZXJ2aWNlTXNnLXRpdGxlXCI+XG4gICAgICAgICAgICAgICAge3Byb3BzLmkxOG4oJ3Nlc3Npb25SZXN0b3JlZCcpfVxuICAgICAgICAgICAgICA8L3N0cm9uZz5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkLXNlcnZpY2VNc2ctdGV4dFwiPlxuICAgICAgICAgICAgICAgIHtyZW5kZXJSZXN0b3JlZFRleHQoKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuXG4gICAgICAgICAge3Nob3dGaWxlTGlzdCA/IChcbiAgICAgICAgICAgIDxGaWxlTGlzdFxuICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICAgIGl0ZW1zUGVyUm93PXtpdGVtc1BlclJvd31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxBZGRGaWxlcyB7Li4ucHJvcHN9IGlzU2l6ZU1EPXtpc1NpemVNRH0gLz5cbiAgICAgICAgICApfVxuXG4gICAgICAgICAgPFNsaWRlPlxuICAgICAgICAgICAge3Byb3BzLnNob3dBZGRGaWxlc1BhbmVsID8gPEFkZEZpbGVzUGFuZWwga2V5PVwiQWRkRmlsZXNcIiB7Li4ucHJvcHN9IGlzU2l6ZU1EPXtpc1NpemVNRH0gLz4gOiBudWxsfVxuICAgICAgICAgIDwvU2xpZGU+XG5cbiAgICAgICAgICA8U2xpZGU+XG4gICAgICAgICAgICB7cHJvcHMuZmlsZUNhcmRGb3IgPyA8RmlsZUNhcmQga2V5PVwiRmlsZUNhcmRcIiB7Li4ucHJvcHN9IC8+IDogbnVsbH1cbiAgICAgICAgICA8L1NsaWRlPlxuXG4gICAgICAgICAgPFNsaWRlPlxuICAgICAgICAgICAge3Byb3BzLmFjdGl2ZVBpY2tlclBhbmVsID8gPFBpY2tlclBhbmVsQ29udGVudCBrZXk9XCJQaWNrZXJcIiB7Li4ucHJvcHN9IC8+IDogbnVsbH1cbiAgICAgICAgICA8L1NsaWRlPlxuXG4gICAgICAgICAgPFNsaWRlPlxuICAgICAgICAgICAge3Byb3BzLnNob3dGaWxlRWRpdG9yID8gPEVkaXRvclBhbmVsIGtleT1cIkVkaXRvclwiIHsuLi5wcm9wc30gLz4gOiBudWxsfVxuICAgICAgICAgIDwvU2xpZGU+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLXByb2dyZXNzaW5kaWNhdG9yc1wiPlxuICAgICAgICAgICAge3Byb3BzLnByb2dyZXNzaW5kaWNhdG9ycy5tYXAoKHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuZ2V0UGx1Z2luKHRhcmdldC5pZCkucmVuZGVyKHByb3BzLnN0YXRlKVxuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcblxuICByZXR1cm4gKFxuICAgIC8vIFdyYXAgaXQgZm9yIFJUTCBsYW5ndWFnZSBzdXBwb3J0XG4gICAgPGRpdiBjbGFzc05hbWU9e3dyYXBwZXJDbGFzc05hbWV9IGRpcj17cHJvcHMuZGlyZWN0aW9ufT5cbiAgICAgIHtkYXNoYm9hcmR9XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcblxuZnVuY3Rpb24gRWRpdG9yUGFuZWwgKHByb3BzKSB7XG4gIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVzW3RoaXMucHJvcHMuZmlsZUNhcmRGb3JdXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3VwcHktRGFzaGJvYXJkQ29udGVudC1wYW5lbCcsIHByb3BzLmNsYXNzTmFtZSl9XG4gICAgICByb2xlPVwidGFicGFuZWxcIlxuICAgICAgZGF0YS11cHB5LXBhbmVsVHlwZT1cIkZpbGVFZGl0b3JcIlxuICAgICAgaWQ9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtcGFuZWwtLWVkaXRvclwiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXRpdGxlXCIgcm9sZT1cImhlYWRpbmdcIiBhcmlhLWxldmVsPVwiMVwiPlxuICAgICAgICAgIHtwcm9wcy5pMThuQXJyYXkoJ2VkaXRpbmcnLCB7XG4gICAgICAgICAgICBmaWxlOiA8c3BhbiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtdGl0bGVGaWxlXCI+e2ZpbGUubWV0YSA/IGZpbGUubWV0YS5uYW1lIDogZmlsZS5uYW1lfTwvc3Bhbj4sXG4gICAgICAgICAgfSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhY2tcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9e3Byb3BzLmhpZGVBbGxQYW5lbHN9XG4gICAgICAgID5cbiAgICAgICAgICB7cHJvcHMuaTE4bignY2FuY2VsJyl9XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXNhdmVcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9e3Byb3BzLnNhdmVGaWxlRWRpdG9yfVxuICAgICAgICA+XG4gICAgICAgICAge3Byb3BzLmkxOG4oJ3NhdmUnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXBhbmVsQm9keVwiPlxuICAgICAgICB7cHJvcHMuZWRpdG9ycy5tYXAoKHRhcmdldCkgPT4ge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5nZXRQbHVnaW4odGFyZ2V0LmlkKS5yZW5kZXIocHJvcHMuc3RhdGUpXG4gICAgICAgIH0pfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFZGl0b3JQYW5lbFxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBnZXRGaWxlVHlwZUljb24gPSByZXF1aXJlKCcuLi8uLi91dGlscy9nZXRGaWxlVHlwZUljb24nKVxuY29uc3QgaWdub3JlRXZlbnQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZ25vcmVFdmVudC5qcycpXG5jb25zdCBGaWxlUHJldmlldyA9IHJlcXVpcmUoJy4uL0ZpbGVQcmV2aWV3JylcblxuY2xhc3MgRmlsZUNhcmQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcblxuICAgIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVzW3RoaXMucHJvcHMuZmlsZUNhcmRGb3JdXG4gICAgY29uc3QgbWV0YUZpZWxkcyA9IHRoaXMuZ2V0TWV0YUZpZWxkcygpIHx8IFtdXG5cbiAgICBjb25zdCBzdG9yZWRNZXRhRGF0YSA9IHt9XG4gICAgbWV0YUZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgc3RvcmVkTWV0YURhdGFbZmllbGQuaWRdID0gZmlsZS5tZXRhW2ZpZWxkLmlkXSB8fCAnJ1xuICAgIH0pXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZm9ybVN0YXRlOiBzdG9yZWRNZXRhRGF0YSxcbiAgICB9XG4gIH1cblxuICBzYXZlT25FbnRlciA9IChldikgPT4ge1xuICAgIGlmIChldi5rZXlDb2RlID09PSAxMykge1xuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVzW3RoaXMucHJvcHMuZmlsZUNhcmRGb3JdXG4gICAgICB0aGlzLnByb3BzLnNhdmVGaWxlQ2FyZCh0aGlzLnN0YXRlLmZvcm1TdGF0ZSwgZmlsZS5pZClcbiAgICB9XG4gIH1cblxuICB1cGRhdGVNZXRhID0gKG5ld1ZhbCwgbmFtZSkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZm9ybVN0YXRlOiB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUuZm9ybVN0YXRlLFxuICAgICAgICBbbmFtZV06IG5ld1ZhbCxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZVNhdmUgPSAoKSA9PiB7XG4gICAgY29uc3QgZmlsZUlEID0gdGhpcy5wcm9wcy5maWxlQ2FyZEZvclxuICAgIHRoaXMucHJvcHMuc2F2ZUZpbGVDYXJkKHRoaXMuc3RhdGUuZm9ybVN0YXRlLCBmaWxlSUQpXG4gIH1cblxuICBoYW5kbGVDYW5jZWwgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy50b2dnbGVGaWxlQ2FyZChmYWxzZSlcbiAgfVxuXG4gIHJlbmRlck1ldGFGaWVsZHMgPSAoKSA9PiB7XG4gICAgY29uc3QgbWV0YUZpZWxkcyA9IHRoaXMuZ2V0TWV0YUZpZWxkcygpIHx8IFtdXG4gICAgY29uc3QgZmllbGRDU1NDbGFzc2VzID0ge1xuICAgICAgdGV4dDogJ3VwcHktdS1yZXNldCB1cHB5LWMtdGV4dElucHV0IHVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWlucHV0JyxcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YUZpZWxkcy5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICBjb25zdCBpZCA9IGB1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1pbnB1dC0ke2ZpZWxkLmlkfWBcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxmaWVsZHNldCBrZXk9e2ZpZWxkLmlkfSBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1maWVsZHNldFwiPlxuICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1sYWJlbFwiIGh0bWxGb3I9e2lkfT57ZmllbGQubmFtZX08L2xhYmVsPlxuICAgICAgICAgIHtmaWVsZC5yZW5kZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBmaWVsZC5yZW5kZXIoe1xuICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5mb3JtU3RhdGVbZmllbGQuaWRdLFxuICAgICAgICAgICAgICBvbkNoYW5nZTogKG5ld1ZhbCkgPT4gdGhpcy51cGRhdGVNZXRhKG5ld1ZhbCwgZmllbGQuaWQpLFxuICAgICAgICAgICAgICBmaWVsZENTU0NsYXNzZXMsXG4gICAgICAgICAgICB9LCBoKVxuICAgICAgICAgICAgOiAoXG4gICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17ZmllbGRDU1NDbGFzc2VzLnRleHR9XG4gICAgICAgICAgICAgICAgaWQ9e2lkfVxuICAgICAgICAgICAgICAgIHR5cGU9e2ZpZWxkLnR5cGUgfHwgJ3RleHQnfVxuICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmZvcm1TdGF0ZVtmaWVsZC5pZF19XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2ZpZWxkLnBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgIG9uS2V5VXA9e3RoaXMuc2F2ZU9uRW50ZXJ9XG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLnNhdmVPbkVudGVyfVxuICAgICAgICAgICAgICAgIG9uS2V5UHJlc3M9e3RoaXMuc2F2ZU9uRW50ZXJ9XG4gICAgICAgICAgICAgICAgb25JbnB1dD17ZXYgPT4gdGhpcy51cGRhdGVNZXRhKGV2LnRhcmdldC52YWx1ZSwgZmllbGQuaWQpfVxuICAgICAgICAgICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICl9XG4gICAgICAgIDwvZmllbGRzZXQ+XG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIGdldE1ldGFGaWVsZHMgKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5wcm9wcy5tZXRhRmllbGRzID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHRoaXMucHJvcHMubWV0YUZpZWxkcyh0aGlzLnByb3BzLmZpbGVzW3RoaXMucHJvcHMuZmlsZUNhcmRGb3JdKVxuICAgICAgOiB0aGlzLnByb3BzLm1ldGFGaWVsZHNcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMucHJvcHMuZmlsZXNbdGhpcy5wcm9wcy5maWxlQ2FyZEZvcl1cbiAgICBjb25zdCBzaG93RWRpdEJ1dHRvbiA9IHRoaXMucHJvcHMuY2FuRWRpdEZpbGUoZmlsZSlcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcygndXBweS1EYXNoYm9hcmQtRmlsZUNhcmQnLCB0aGlzLnByb3BzLmNsYXNzTmFtZSl9XG4gICAgICAgIGRhdGEtdXBweS1wYW5lbFR5cGU9XCJGaWxlQ2FyZFwiXG4gICAgICAgIG9uRHJhZ092ZXI9e2lnbm9yZUV2ZW50fVxuICAgICAgICBvbkRyYWdMZWF2ZT17aWdub3JlRXZlbnR9XG4gICAgICAgIG9uRHJvcD17aWdub3JlRXZlbnR9XG4gICAgICAgIG9uUGFzdGU9e2lnbm9yZUV2ZW50fVxuICAgICAgPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC1iYXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC10aXRsZVwiIHJvbGU9XCJoZWFkaW5nXCIgYXJpYS1sZXZlbD1cIjFcIj5cbiAgICAgICAgICAgIHt0aGlzLnByb3BzLmkxOG5BcnJheSgnZWRpdGluZycsIHtcbiAgICAgICAgICAgICAgZmlsZTogPHNwYW4gY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXRpdGxlRmlsZVwiPntmaWxlLm1ldGEgPyBmaWxlLm1ldGEubmFtZSA6IGZpbGUubmFtZX08L3NwYW4+LFxuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhY2tcIlxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICB0aXRsZT17dGhpcy5wcm9wcy5pMThuKCdmaW5pc2hFZGl0aW5nRmlsZScpfVxuICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDYW5jZWx9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge3RoaXMucHJvcHMuaTE4bignY2FuY2VsJyl9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtaW5uZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLXByZXZpZXdcIiBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6IGdldEZpbGVUeXBlSWNvbihmaWxlLnR5cGUpLmNvbG9yIH19PlxuICAgICAgICAgICAgPEZpbGVQcmV2aWV3IGZpbGU9e2ZpbGV9IC8+XG4gICAgICAgICAgICB7c2hvd0VkaXRCdXR0b25cbiAgICAgICAgICAgICAgJiYgKFxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtZWRpdFwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gdGhpcy5wcm9wcy5vcGVuRmlsZUVkaXRvcihmaWxlKX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmkxOG4oJ2VkaXRGaWxlJyl9XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1pbmZvXCI+XG4gICAgICAgICAgICB7dGhpcy5yZW5kZXJNZXRhRmllbGRzKCl9XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWFjdGlvbnNcIj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1jLWJ0bi1wcmltYXJ5IHVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWFjdGlvbnNCdG5cIlxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVTYXZlfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5pMThuKCdzYXZlQ2hhbmdlcycpfVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tbGluayB1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1hY3Rpb25zQnRuXCJcbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2FuY2VsfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGVDYXJkXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjb3B5VG9DbGlwYm9hcmQgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9jb3B5VG9DbGlwYm9hcmQnKVxuXG5mdW5jdGlvbiBFZGl0QnV0dG9uICh7XG4gIGZpbGUsXG4gIHVwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlLFxuICBtZXRhRmllbGRzLFxuICBjYW5FZGl0RmlsZSxcbiAgaTE4bixcbiAgb25DbGljayxcbn0pIHtcbiAgaWYgKFxuICAgICghdXBsb2FkSW5Qcm9ncmVzc09yQ29tcGxldGUgJiYgbWV0YUZpZWxkcyAmJiBtZXRhRmllbGRzLmxlbmd0aCA+IDApXG4gICAgfHwgKCF1cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZSAmJiBjYW5FZGl0RmlsZShmaWxlKSlcbiAgKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uIHVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uLS1lZGl0XCJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGFyaWEtbGFiZWw9e2Ake2kxOG4oJ2VkaXRGaWxlJyl9ICR7ZmlsZS5tZXRhLm5hbWV9YH1cbiAgICAgICAgdGl0bGU9e2kxOG4oJ2VkaXRGaWxlJyl9XG4gICAgICAgIG9uQ2xpY2s9eygpID0+IG9uQ2xpY2soKX1cbiAgICAgID5cbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCIgdmlld0JveD1cIjAgMCAxNCAxNFwiPlxuICAgICAgICAgIDxnIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk0xLjUgMTAuNzkzaDIuNzkzQTEgMSAwIDAgMCA1IDEwLjVMMTEuNSA0YTEgMSAwIDAgMCAwLTEuNDE0TDkuNzA3Ljc5M2ExIDEgMCAwIDAtMS40MTQgMGwtNi41IDYuNUExIDEgMCAwIDAgMS41IDh2Mi43OTN6bTEtMVY4TDkgMS41bDEuNzkzIDEuNzkzLTYuNSA2LjVIMi41elwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICAgICAgICA8cmVjdCB4PVwiMVwiIHk9XCIxMi4yOTNcIiB3aWR0aD1cIjExXCIgaGVpZ2h0PVwiMVwiIHJ4PVwiLjVcIiAvPlxuICAgICAgICAgICAgPHBhdGggZmlsbFJ1bGU9XCJub256ZXJvXCIgZD1cIk02Ljc5MyAyLjVMOS41IDUuMjA3bC43MDctLjcwN0w3LjUgMS43OTN6XCIgLz5cbiAgICAgICAgICA8L2c+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9idXR0b24+XG4gICAgKVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIFJlbW92ZUJ1dHRvbiAoeyBpMThuLCBvbkNsaWNrIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1EYXNoYm9hcmQtSXRlbS1hY3Rpb24gdXBweS1EYXNoYm9hcmQtSXRlbS1hY3Rpb24tLXJlbW92ZVwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3JlbW92ZUZpbGUnKX1cbiAgICAgIHRpdGxlPXtpMThuKCdyZW1vdmVGaWxlJyl9XG4gICAgICBvbkNsaWNrPXsoKSA9PiBvbkNsaWNrKCl9XG4gICAgPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxOFwiIGhlaWdodD1cIjE4XCIgdmlld0JveD1cIjAgMCAxOCAxOFwiPlxuICAgICAgICA8cGF0aCBkPVwiTTkgMEM0LjAzNCAwIDAgNC4wMzQgMCA5czQuMDM0IDkgOSA5IDktNC4wMzQgOS05LTQuMDM0LTktOS05elwiIC8+XG4gICAgICAgIDxwYXRoIGZpbGw9XCIjRkZGXCIgZD1cIk0xMyAxMi4yMjJsLS43NzguNzc4TDkgOS43NzggNS43NzggMTMgNSAxMi4yMjIgOC4yMjIgOSA1IDUuNzc4IDUuNzc4IDUgOSA4LjIyMiAxMi4yMjIgNWwuNzc4Ljc3OEw5Ljc3OCA5elwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5jb25zdCBjb3B5TGlua1RvQ2xpcGJvYXJkID0gKGV2ZW50LCBwcm9wcykgPT4ge1xuICBjb3B5VG9DbGlwYm9hcmQocHJvcHMuZmlsZS51cGxvYWRVUkwsIHByb3BzLmkxOG4oJ2NvcHlMaW5rVG9DbGlwYm9hcmRGYWxsYmFjaycpKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHByb3BzLmxvZygnTGluayBjb3BpZWQgdG8gY2xpcGJvYXJkLicpXG4gICAgICBwcm9wcy5pbmZvKHByb3BzLmkxOG4oJ2NvcHlMaW5rVG9DbGlwYm9hcmRTdWNjZXNzJyksICdpbmZvJywgMzAwMClcbiAgICB9KVxuICAgIC5jYXRjaChwcm9wcy5sb2cpXG4gICAgLy8gYXZvaWQgbG9zaW5nIGZvY3VzXG4gICAgLnRoZW4oKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KSlcbn1cblxuZnVuY3Rpb24gQ29weUxpbmtCdXR0b24gKHByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uIHVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uLS1jb3B5TGlua1wiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ2NvcHlMaW5rJyl9XG4gICAgICB0aXRsZT17cHJvcHMuaTE4bignY29weUxpbmsnKX1cbiAgICAgIG9uQ2xpY2s9eyhldmVudCkgPT4gY29weUxpbmtUb0NsaXBib2FyZChldmVudCwgcHJvcHMpfVxuICAgID5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHZpZXdCb3g9XCIwIDAgMTQgMTJcIj5cbiAgICAgICAgPHBhdGggZD1cIk03Ljk0IDcuNzAzYTIuNjEzIDIuNjEzIDAgMCAxLS42MjYgMi42ODFsLS44NTIuODUxYTIuNTk3IDIuNTk3IDAgMCAxLTEuODQ5Ljc2NkEyLjYxNiAyLjYxNiAwIDAgMSAyLjc2NCA3LjU0bC44NTItLjg1MmEyLjU5NiAyLjU5NiAwIDAgMSAyLjY5LS42MjVMNS4yNjcgNy4wOTlhMS40NCAxLjQ0IDAgMCAwLS44MzMuNDA3bC0uODUyLjg1MWExLjQ1OCAxLjQ1OCAwIDAgMCAxLjAzIDIuNDg2Yy4zOSAwIC43NTUtLjE1MiAxLjAzLS40MjZsLjg1Mi0uODUyYy4yMzEtLjIzMS4zNjMtLjUyMi40MDYtLjgyNGwxLjA0LTEuMDM4em00LjI5NS01LjkzN0EyLjU5NiAyLjU5NiAwIDAgMCAxMC4zODcgMWMtLjY5OCAwLTEuMzU1LjI3Mi0xLjg0OS43NjZsLS44NTIuODUxYTIuNjE0IDIuNjE0IDAgMCAwLS42MjQgMi42ODhsMS4wMzYtMS4wMzZjLjA0MS0uMzA0LjE3My0uNi40MDctLjgzM2wuODUyLS44NTJjLjI3NS0uMjc1LjY0LS40MjYgMS4wMy0uNDI2YTEuNDU4IDEuNDU4IDAgMCAxIDEuMDMgMi40ODZsLS44NTIuODUxYTEuNDQyIDEuNDQyIDAgMCAxLS44MjQuNDA2bC0xLjA0IDEuMDRhMi41OTYgMi41OTYgMCAwIDAgMi42ODMtLjYyOGwuODUxLS44NWEyLjYxNiAyLjYxNiAwIDAgMCAwLTMuNjk3em0tNi44OCA2Ljg4M2EuNTc3LjU3NyAwIDAgMCAuODIgMGwzLjQ3NC0zLjQ3NGEuNTc5LjU3OSAwIDEgMC0uODE5LS44Mkw1LjM1NSA3LjgzYS41NzkuNTc5IDAgMCAwIDAgLjgxOXpcIiAvPlxuICAgICAgPC9zdmc+XG4gICAgPC9idXR0b24+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBCdXR0b25zIChwcm9wcykge1xuICBjb25zdCB7XG4gICAgZmlsZSxcbiAgICB1cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZSxcbiAgICBjYW5FZGl0RmlsZSxcbiAgICBtZXRhRmllbGRzLFxuICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0LFxuICAgIHNob3dSZW1vdmVCdXR0b24sXG4gICAgaTE4bixcbiAgICByZW1vdmVGaWxlLFxuICAgIHRvZ2dsZUZpbGVDYXJkLFxuICAgIG9wZW5GaWxlRWRpdG9yLFxuICAgIGxvZyxcbiAgICBpbmZvLFxuICB9ID0gcHJvcHNcblxuICBjb25zdCBlZGl0QWN0aW9uID0gKCkgPT4ge1xuICAgIGlmIChtZXRhRmllbGRzICYmIG1ldGFGaWVsZHMubGVuZ3RoID4gMCkge1xuICAgICAgdG9nZ2xlRmlsZUNhcmQodHJ1ZSwgZmlsZS5pZClcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlbkZpbGVFZGl0b3IoZmlsZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1hY3Rpb25XcmFwcGVyXCI+XG4gICAgICA8RWRpdEJ1dHRvblxuICAgICAgICBpMThuPXtpMThufVxuICAgICAgICBmaWxlPXtmaWxlfVxuICAgICAgICB1cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZT17dXBsb2FkSW5Qcm9ncmVzc09yQ29tcGxldGV9XG4gICAgICAgIGNhbkVkaXRGaWxlPXtjYW5FZGl0RmlsZX1cbiAgICAgICAgbWV0YUZpZWxkcz17bWV0YUZpZWxkc31cbiAgICAgICAgb25DbGljaz17ZWRpdEFjdGlvbn1cbiAgICAgIC8+XG4gICAgICB7c2hvd0xpbmtUb0ZpbGVVcGxvYWRSZXN1bHQgJiYgZmlsZS51cGxvYWRVUkwgPyAoXG4gICAgICAgIDxDb3B5TGlua0J1dHRvblxuICAgICAgICAgIGZpbGU9e2ZpbGV9XG4gICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICBpbmZvPXtpbmZvfVxuICAgICAgICAgIGxvZz17bG9nfVxuICAgICAgICAvPlxuICAgICAgKSA6IG51bGx9XG4gICAgICB7c2hvd1JlbW92ZUJ1dHRvbiA/IChcbiAgICAgICAgPFJlbW92ZUJ1dHRvblxuICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgaW5mbz17cHJvcHMuaW5mb31cbiAgICAgICAgICBsb2c9e3Byb3BzLmxvZ31cbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiByZW1vdmVGaWxlKGZpbGUuaWQsICdyZW1vdmVkLWJ5LXVzZXInKX1cbiAgICAgICAgLz5cbiAgICAgICkgOiBudWxsfVxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBwcmV0dGllckJ5dGVzID0gcmVxdWlyZSgnQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzJylcbmNvbnN0IHRydW5jYXRlU3RyaW5nID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3RydW5jYXRlU3RyaW5nJylcblxuY29uc3QgcmVuZGVyQWNxdWlyZXJJY29uID0gKGFjcXVpcmVyLCBwcm9wcykgPT4gKFxuICA8c3BhbiB0aXRsZT17cHJvcHMuaTE4bignZmlsZVNvdXJjZScsIHsgbmFtZTogYWNxdWlyZXIubmFtZSB9KX0+XG4gICAge2FjcXVpcmVyLmljb24oKX1cbiAgPC9zcGFuPlxuKVxuXG5jb25zdCByZW5kZXJGaWxlTmFtZSA9IChwcm9wcykgPT4ge1xuICAvLyBUYWtlIHVwIGF0IG1vc3QgMiBsaW5lcyBvbiBhbnkgc2NyZWVuXG4gIGxldCBtYXhOYW1lTGVuZ3RoXG4gIC8vIEZvciB2ZXJ5IHNtYWxsIG1vYmlsZSBzY3JlZW5zXG4gIGlmIChwcm9wcy5jb250YWluZXJXaWR0aCA8PSAzNTIpIHtcbiAgICBtYXhOYW1lTGVuZ3RoID0gMzVcbiAgLy8gRm9yIHJlZ3VsYXIgbW9iaWxlIHNjcmVlbnNcbiAgfSBlbHNlIGlmIChwcm9wcy5jb250YWluZXJXaWR0aCA8PSA1NzYpIHtcbiAgICBtYXhOYW1lTGVuZ3RoID0gNjBcbiAgLy8gRm9yIGRlc2t0b3BzXG4gIH0gZWxzZSB7XG4gICAgbWF4TmFtZUxlbmd0aCA9IDMwXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1uYW1lXCIgdGl0bGU9e3Byb3BzLmZpbGUubWV0YS5uYW1lfT5cbiAgICAgIHt0cnVuY2F0ZVN0cmluZyhwcm9wcy5maWxlLm1ldGEubmFtZSwgbWF4TmFtZUxlbmd0aCl9XG4gICAgPC9kaXY+XG4gIClcbn1cblxuY29uc3QgcmVuZGVyRmlsZVNpemUgPSAocHJvcHMpID0+IChcbiAgcHJvcHMuZmlsZS5zaXplXG4gICAgJiYgKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1zdGF0dXNTaXplXCI+XG4gICAgICB7cHJldHRpZXJCeXRlcyhwcm9wcy5maWxlLnNpemUpfVxuICAgIDwvZGl2PlxuICAgIClcbilcblxuY29uc3QgUmVTZWxlY3RCdXR0b24gPSAocHJvcHMpID0+IChcbiAgcHJvcHMuZmlsZS5pc0dob3N0XG4gICAgJiYgKFxuICAgICAgPHNwYW4+XG4gICAgICAgIHsnIFxcdTIwMjIgJ31cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktRGFzaGJvYXJkLUl0ZW0tcmVTZWxlY3RcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9e3Byb3BzLnRvZ2dsZUFkZEZpbGVzUGFuZWx9XG4gICAgICAgID5cbiAgICAgICAgICB7cHJvcHMuaTE4bigncmVTZWxlY3QnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L3NwYW4+XG4gICAgKVxuKVxuXG5jb25zdCBFcnJvckJ1dHRvbiA9ICh7IGZpbGUsIG9uQ2xpY2sgfSkgPT4ge1xuICBpZiAoZmlsZS5lcnJvcikge1xuICAgIHJldHVybiAoXG4gICAgICA8c3BhblxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLWVycm9yRGV0YWlsc1wiXG4gICAgICAgIGFyaWEtbGFiZWw9e2ZpbGUuZXJyb3J9XG4gICAgICAgIGRhdGEtbWljcm90aXAtcG9zaXRpb249XCJib3R0b21cIlxuICAgICAgICBkYXRhLW1pY3JvdGlwLXNpemU9XCJtZWRpdW1cIlxuICAgICAgICByb2xlPVwidG9vbHRpcFwiXG4gICAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICA+XG4gICAgICAgID9cbiAgICAgIDwvc3Bhbj5cbiAgICApXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGaWxlSW5mbyAocHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tZmlsZUluZm9cIiBkYXRhLXVwcHktZmlsZS1zb3VyY2U9e3Byb3BzLmZpbGUuc291cmNlfT5cbiAgICAgIHtyZW5kZXJGaWxlTmFtZShwcm9wcyl9XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tc3RhdHVzXCI+XG4gICAgICAgIHtyZW5kZXJGaWxlU2l6ZShwcm9wcyl9XG4gICAgICAgIHtSZVNlbGVjdEJ1dHRvbihwcm9wcyl9XG4gICAgICAgIDxFcnJvckJ1dHRvblxuICAgICAgICAgIGZpbGU9e3Byb3BzLmZpbGV9XG4gICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgYWxlcnQocHJvcHMuZmlsZS5lcnJvcilcbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IEZpbGVQcmV2aWV3ID0gcmVxdWlyZSgnLi4vLi4vRmlsZVByZXZpZXcnKVxuY29uc3QgZ2V0RmlsZVR5cGVJY29uID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvZ2V0RmlsZVR5cGVJY29uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGaWxlUHJldmlld0FuZExpbmsgKHByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3SW5uZXJXcmFwXCJcbiAgICAgIHN0eWxlPXt7IGJhY2tncm91bmRDb2xvcjogZ2V0RmlsZVR5cGVJY29uKHByb3BzLmZpbGUudHlwZSkuY29sb3IgfX1cbiAgICA+XG4gICAgICB7XG4gICAgICAgIHByb3BzLnNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0XG4gICAgICAgICYmIHByb3BzLmZpbGUudXBsb2FkVVJMXG4gICAgICAgICAgJiYgKFxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByZXZpZXdMaW5rXCJcbiAgICAgICAgICAgIGhyZWY9e3Byb3BzLmZpbGUudXBsb2FkVVJMfVxuICAgICAgICAgICAgcmVsPVwibm9yZWZlcnJlciBub29wZW5lclwiXG4gICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgYXJpYS1sYWJlbD17cHJvcHMuZmlsZS5tZXRhLm5hbWV9XG4gICAgICAgICAgLz5cbiAgICAgICAgICApXG4gICAgICB9XG4gICAgICA8RmlsZVByZXZpZXcgZmlsZT17cHJvcHMuZmlsZX0gLz5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5mdW5jdGlvbiBvblBhdXNlUmVzdW1lQ2FuY2VsUmV0cnkgKHByb3BzKSB7XG4gIGlmIChwcm9wcy5pc1VwbG9hZGVkKSByZXR1cm5cblxuICBpZiAocHJvcHMuZXJyb3IgJiYgIXByb3BzLmhpZGVSZXRyeUJ1dHRvbikge1xuICAgIHByb3BzLnJldHJ5VXBsb2FkKHByb3BzLmZpbGUuaWQpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocHJvcHMucmVzdW1hYmxlVXBsb2FkcyAmJiAhcHJvcHMuaGlkZVBhdXNlUmVzdW1lQnV0dG9uKSB7XG4gICAgcHJvcHMucGF1c2VVcGxvYWQocHJvcHMuZmlsZS5pZClcbiAgfSBlbHNlIGlmIChwcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uICYmICFwcm9wcy5oaWRlQ2FuY2VsQnV0dG9uKSB7XG4gICAgcHJvcHMuY2FuY2VsVXBsb2FkKHByb3BzLmZpbGUuaWQpXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvZ3Jlc3NJbmRpY2F0b3JUaXRsZSAocHJvcHMpIHtcbiAgaWYgKHByb3BzLmlzVXBsb2FkZWQpIHtcbiAgICByZXR1cm4gcHJvcHMuaTE4bigndXBsb2FkQ29tcGxldGUnKVxuICB9XG5cbiAgaWYgKHByb3BzLmVycm9yKSB7XG4gICAgcmV0dXJuIHByb3BzLmkxOG4oJ3JldHJ5VXBsb2FkJylcbiAgfVxuXG4gIGlmIChwcm9wcy5yZXN1bWFibGVVcGxvYWRzKSB7XG4gICAgaWYgKHByb3BzLmZpbGUuaXNQYXVzZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcy5pMThuKCdyZXN1bWVVcGxvYWQnKVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHMuaTE4bigncGF1c2VVcGxvYWQnKVxuICB9IGlmIChwcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uKSB7XG4gICAgcmV0dXJuIHByb3BzLmkxOG4oJ2NhbmNlbFVwbG9hZCcpXG4gIH1cblxuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gUHJvZ3Jlc3NJbmRpY2F0b3JCdXR0b24gKHByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzXCI+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSW5kaWNhdG9yXCJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGFyaWEtbGFiZWw9e3Byb2dyZXNzSW5kaWNhdG9yVGl0bGUocHJvcHMpfVxuICAgICAgICB0aXRsZT17cHJvZ3Jlc3NJbmRpY2F0b3JUaXRsZShwcm9wcyl9XG4gICAgICAgIG9uQ2xpY2s9eygpID0+IG9uUGF1c2VSZXN1bWVDYW5jZWxSZXRyeShwcm9wcyl9XG4gICAgICA+XG4gICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICApXG59XG5cbmZ1bmN0aW9uIFByb2dyZXNzQ2lyY2xlQ29udGFpbmVyICh7IGNoaWxkcmVuIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgd2lkdGg9XCI3MFwiXG4gICAgICBoZWlnaHQ9XCI3MFwiXG4gICAgICB2aWV3Qm94PVwiMCAwIDM2IDM2XCJcbiAgICAgIGNsYXNzTmFtZT1cInVwcHktYy1pY29uIHVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJY29uLS1jaXJjbGVcIlxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBQcm9ncmVzc0NpcmNsZSAoeyBwcm9ncmVzcyB9KSB7XG4gIC8vIGNpcmNsZSBsZW5ndGggZXF1YWxzIDIgKiBQSSAqIFJcbiAgY29uc3QgY2lyY2xlTGVuZ3RoID0gMiAqIE1hdGguUEkgKiAxNVxuXG4gIHJldHVybiAoXG4gICAgPGc+XG4gICAgICA8Y2lyY2xlXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJY29uLS1iZ1wiXG4gICAgICAgIHI9XCIxNVwiXG4gICAgICAgIGN4PVwiMThcIlxuICAgICAgICBjeT1cIjE4XCJcbiAgICAgICAgc3Ryb2tlLXdpZHRoPVwiMlwiXG4gICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgIC8+XG4gICAgICA8Y2lyY2xlXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJY29uLS1wcm9ncmVzc1wiXG4gICAgICAgIHI9XCIxNVwiXG4gICAgICAgIGN4PVwiMThcIlxuICAgICAgICBjeT1cIjE4XCJcbiAgICAgICAgdHJhbnNmb3JtPVwicm90YXRlKC05MCwgMTgsIDE4KVwiXG4gICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgc3Ryb2tlLXdpZHRoPVwiMlwiXG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk9e2NpcmNsZUxlbmd0aH1cbiAgICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ9e2NpcmNsZUxlbmd0aCAtICgoY2lyY2xlTGVuZ3RoIC8gMTAwKSAqIHByb2dyZXNzKX1cbiAgICAgIC8+XG4gICAgPC9nPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRmlsZVByb2dyZXNzIChwcm9wcykge1xuICAvLyBOb3RoaW5nIGlmIHVwbG9hZCBoYXMgbm90IHN0YXJ0ZWRcbiAgaWYgKCFwcm9wcy5maWxlLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gR3JlZW4gY2hlY2ttYXJrIHdoZW4gY29tcGxldGVcbiAgaWYgKHByb3BzLmlzVXBsb2FkZWQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc0luZGljYXRvclwiPlxuICAgICAgICAgIDxQcm9ncmVzc0NpcmNsZUNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxjaXJjbGUgcj1cIjE1XCIgY3g9XCIxOFwiIGN5PVwiMThcIiBmaWxsPVwiIzFiYjI0MFwiIC8+XG4gICAgICAgICAgICA8cG9seWdvbiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSWNvbi0tY2hlY2tcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMiwgMylcIiBwb2ludHM9XCIxNCAyMi41IDcgMTUuMjQ1NzA2NSA4Ljk5OTg1ODU3IDEzLjE3MzI4MTUgMTQgMTguMzU0NzEwNCAyMi45NzI5ODgzIDkgMjUgMTEuMTAwNTYzNFwiIC8+XG4gICAgICAgICAgPC9Qcm9ncmVzc0NpcmNsZUNvbnRhaW5lcj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICBpZiAocHJvcHMucmVjb3ZlcmVkU3RhdGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIFJldHJ5IGJ1dHRvbiBmb3IgZXJyb3JcbiAgaWYgKHByb3BzLmVycm9yICYmICFwcm9wcy5oaWRlUmV0cnlCdXR0b24pIHtcbiAgICByZXR1cm4gKFxuICAgICAgPFByb2dyZXNzSW5kaWNhdG9yQnV0dG9uIHsuLi5wcm9wc30+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvbiB1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSWNvbi0tcmV0cnlcIiB3aWR0aD1cIjI4XCIgaGVpZ2h0PVwiMzFcIiB2aWV3Qm94PVwiMCAwIDE2IDE5XCI+XG4gICAgICAgICAgPHBhdGggZD1cIk0xNiAxMWE4IDggMCAxIDEtOC04djJhNiA2IDAgMSAwIDYgNmgyelwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk03LjkgM0gxMHYySDcuOXpcIiAvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNOC41MzYuNWwzLjUzNSAzLjUzNi0xLjQxNCAxLjQxNEw3LjEyIDEuOTE0elwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMC42NTcgMi42MjFsMS40MTQgMS40MTVMOC41MzYgNy41NyA3LjEyIDYuMTU3elwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9Qcm9ncmVzc0luZGljYXRvckJ1dHRvbj5cbiAgICApXG4gIH1cblxuICAvLyBQYXVzZS9yZXN1bWUgYnV0dG9uIGZvciByZXN1bWFibGUgdXBsb2Fkc1xuICBpZiAocHJvcHMucmVzdW1hYmxlVXBsb2FkcyAmJiAhcHJvcHMuaGlkZVBhdXNlUmVzdW1lQnV0dG9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxQcm9ncmVzc0luZGljYXRvckJ1dHRvbiB7Li4ucHJvcHN9PlxuICAgICAgICA8UHJvZ3Jlc3NDaXJjbGVDb250YWluZXI+XG4gICAgICAgICAgPFByb2dyZXNzQ2lyY2xlIHByb2dyZXNzPXtwcm9wcy5maWxlLnByb2dyZXNzLnBlcmNlbnRhZ2V9IC8+XG4gICAgICAgICAge1xuICAgICAgICAgICAgcHJvcHMuZmlsZS5pc1BhdXNlZFxuICAgICAgICAgICAgICA/IDxwb2x5Z29uIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJY29uLS1wbGF5XCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDMsIDMpXCIgcG9pbnRzPVwiMTIgMjAgMTIgMTAgMjAgMTVcIiAvPlxuICAgICAgICAgICAgICA6IChcbiAgICAgICAgICAgICAgICA8ZyBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSWNvbi0tcGF1c2VcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTQuNSwgMTMpXCI+XG4gICAgICAgICAgICAgICAgICA8cmVjdCB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCIyXCIgaGVpZ2h0PVwiMTBcIiByeD1cIjBcIiAvPlxuICAgICAgICAgICAgICAgICAgPHJlY3QgeD1cIjVcIiB5PVwiMFwiIHdpZHRoPVwiMlwiIGhlaWdodD1cIjEwXCIgcng9XCIwXCIgLz5cbiAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIDwvUHJvZ3Jlc3NDaXJjbGVDb250YWluZXI+XG4gICAgICA8L1Byb2dyZXNzSW5kaWNhdG9yQnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIC8vIENhbmNlbCBidXR0b24gZm9yIG5vbi1yZXN1bWFibGUgdXBsb2FkcyBpZiBpbmRpdmlkdWFsQ2FuY2VsbGF0aW9uIGlzIHN1cHBvcnRlZCAobm90IGJ1bmRsZWQpXG4gIGlmICghcHJvcHMucmVzdW1hYmxlVXBsb2FkcyAmJiBwcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uICYmICFwcm9wcy5oaWRlQ2FuY2VsQnV0dG9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxQcm9ncmVzc0luZGljYXRvckJ1dHRvbiB7Li4ucHJvcHN9PlxuICAgICAgICA8UHJvZ3Jlc3NDaXJjbGVDb250YWluZXI+XG4gICAgICAgICAgPFByb2dyZXNzQ2lyY2xlIHByb2dyZXNzPXtwcm9wcy5maWxlLnByb2dyZXNzLnBlcmNlbnRhZ2V9IC8+XG4gICAgICAgICAgPHBvbHlnb24gY2xhc3NOYW1lPVwiY2FuY2VsXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIsIDIpXCIgcG9pbnRzPVwiMTkuODg1NjUxNiAxMS4wNjI1IDE2IDE0Ljk0ODE1MTYgMTIuMTAxOTczNyAxMS4wNjI1IDExLjA2MjUgMTIuMTE0MzQ4NCAxNC45NDgxNTE2IDE2IDExLjA2MjUgMTkuODk4MDI2MyAxMi4xMDE5NzM3IDIwLjkzNzUgMTYgMTcuMDUxODQ4NCAxOS44ODU2NTE2IDIwLjkzNzUgMjAuOTM3NSAxOS44OTgwMjYzIDE3LjA1MTg0ODQgMTYgMjAuOTM3NSAxMlwiIC8+XG4gICAgICAgIDwvUHJvZ3Jlc3NDaXJjbGVDb250YWluZXI+XG4gICAgICA8L1Byb2dyZXNzSW5kaWNhdG9yQnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIC8vIEp1c3QgcHJvZ3Jlc3Mgd2hlbiBidXR0b25zIGFyZSBkaXNhYmxlZFxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc1wiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSW5kaWNhdG9yXCI+XG4gICAgICAgIDxQcm9ncmVzc0NpcmNsZUNvbnRhaW5lcj5cbiAgICAgICAgICA8UHJvZ3Jlc3NDaXJjbGUgcHJvZ3Jlc3M9e3Byb3BzLmZpbGUucHJvZ3Jlc3MucGVyY2VudGFnZX0gLz5cbiAgICAgICAgPC9Qcm9ncmVzc0NpcmNsZUNvbnRhaW5lcj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2lzLXNoYWxsb3ctZXF1YWwnKVxuY29uc3QgRmlsZVByZXZpZXdBbmRMaW5rID0gcmVxdWlyZSgnLi9GaWxlUHJldmlld0FuZExpbmsnKVxuY29uc3QgRmlsZVByb2dyZXNzID0gcmVxdWlyZSgnLi9GaWxlUHJvZ3Jlc3MnKVxuY29uc3QgRmlsZUluZm8gPSByZXF1aXJlKCcuL0ZpbGVJbmZvJylcbmNvbnN0IEJ1dHRvbnMgPSByZXF1aXJlKCcuL0J1dHRvbnMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEZpbGVJdGVtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlIChuZXh0UHJvcHMpIHtcbiAgICByZXR1cm4gIXNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMucHJvcHMuZmlsZVxuICAgIGlmICghZmlsZS5wcmV2aWV3KSB7XG4gICAgICB0aGlzLnByb3BzLmhhbmRsZVJlcXVlc3RUaHVtYm5haWwoZmlsZSlcbiAgICB9XG4gIH1cblxuICAvLyBWaXJ0dWFsTGlzdCBtb3VudHMgRmlsZUl0ZW1zIGFnYWluIGFuZCB0aGV5IGVtaXQgYHRodW1ibmFpbDpyZXF1ZXN0YFxuICAvLyBPdGhlcndpc2UgdGh1bWJuYWlscyBhcmUgYnJva2VuIG9yIG1pc3NpbmcgYWZ0ZXIgR29sZGVuIFJldHJpZXZlciByZXN0b3JlcyBmaWxlc1xuICBjb21wb25lbnREaWRVcGRhdGUgKCkge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVcbiAgICBpZiAoIWZpbGUucHJldmlldykge1xuICAgICAgdGhpcy5wcm9wcy5oYW5kbGVSZXF1ZXN0VGh1bWJuYWlsKGZpbGUpXG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVcbiAgICBpZiAoIWZpbGUucHJldmlldykge1xuICAgICAgdGhpcy5wcm9wcy5oYW5kbGVDYW5jZWxUaHVtYm5haWwoZmlsZSlcbiAgICB9XG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVcblxuICAgIGNvbnN0IGlzUHJvY2Vzc2luZyA9IGZpbGUucHJvZ3Jlc3MucHJlcHJvY2VzcyB8fCBmaWxlLnByb2dyZXNzLnBvc3Rwcm9jZXNzXG4gICAgY29uc3QgaXNVcGxvYWRlZCA9IGZpbGUucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGUgJiYgIWlzUHJvY2Vzc2luZyAmJiAhZmlsZS5lcnJvclxuICAgIGNvbnN0IHVwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlID0gZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkIHx8IGlzUHJvY2Vzc2luZ1xuICAgIGNvbnN0IHVwbG9hZEluUHJvZ3Jlc3MgPSAoZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkICYmICFmaWxlLnByb2dyZXNzLnVwbG9hZENvbXBsZXRlKSB8fCBpc1Byb2Nlc3NpbmdcbiAgICBjb25zdCBlcnJvciA9IGZpbGUuZXJyb3IgfHwgZmFsc2VcblxuICAgIC8vIEZpbGUgdGhhdCBHb2xkZW4gUmV0cmlldmVyIHdhcyBhYmxlIHRvIHBhcnRseSByZXN0b3JlIChvbmx5IG1ldGEsIG5vdCBibG9iKSxcbiAgICAvLyB1c2VycyBzdGlsbCBuZWVkIHRvIHJlLWFkZCBpdCwgc28gaXTigJlzIGEgZ2hvc3RcbiAgICBjb25zdCBpc0dob3N0ID0gZmlsZS5pc0dob3N0XG5cbiAgICBsZXQgc2hvd1JlbW92ZUJ1dHRvbiA9IHRoaXMucHJvcHMuaW5kaXZpZHVhbENhbmNlbGxhdGlvblxuICAgICAgPyAhaXNVcGxvYWRlZFxuICAgICAgOiAhdXBsb2FkSW5Qcm9ncmVzcyAmJiAhaXNVcGxvYWRlZFxuXG4gICAgaWYgKGlzVXBsb2FkZWQgJiYgdGhpcy5wcm9wcy5zaG93UmVtb3ZlQnV0dG9uQWZ0ZXJDb21wbGV0ZSkge1xuICAgICAgc2hvd1JlbW92ZUJ1dHRvbiA9IHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBkYXNoYm9hcmRJdGVtQ2xhc3MgPSBjbGFzc05hbWVzKHtcbiAgICAgICd1cHB5LURhc2hib2FyZC1JdGVtJzogdHJ1ZSxcbiAgICAgICdpcy1pbnByb2dyZXNzJzogdXBsb2FkSW5Qcm9ncmVzcyAmJiAhdGhpcy5wcm9wcy5yZWNvdmVyZWRTdGF0ZSxcbiAgICAgICdpcy1wcm9jZXNzaW5nJzogaXNQcm9jZXNzaW5nLFxuICAgICAgJ2lzLWNvbXBsZXRlJzogaXNVcGxvYWRlZCxcbiAgICAgICdpcy1lcnJvcic6ICEhZXJyb3IsXG4gICAgICAnaXMtcmVzdW1hYmxlJzogdGhpcy5wcm9wcy5yZXN1bWFibGVVcGxvYWRzLFxuICAgICAgJ2lzLW5vSW5kaXZpZHVhbENhbmNlbGxhdGlvbic6ICF0aGlzLnByb3BzLmluZGl2aWR1YWxDYW5jZWxsYXRpb24sXG4gICAgICAnaXMtZ2hvc3QnOiBpc0dob3N0LFxuICAgIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2Rhc2hib2FyZEl0ZW1DbGFzc31cbiAgICAgICAgaWQ9e2B1cHB5XyR7ZmlsZS5pZH1gfVxuICAgICAgICByb2xlPXt0aGlzLnByb3BzLnJvbGV9XG4gICAgICA+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3XCI+XG4gICAgICAgICAgPEZpbGVQcmV2aWV3QW5kTGlua1xuICAgICAgICAgICAgZmlsZT17ZmlsZX1cbiAgICAgICAgICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0PXt0aGlzLnByb3BzLnNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0fVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEZpbGVQcm9ncmVzc1xuICAgICAgICAgICAgZmlsZT17ZmlsZX1cbiAgICAgICAgICAgIGVycm9yPXtlcnJvcn1cbiAgICAgICAgICAgIGlzVXBsb2FkZWQ9e2lzVXBsb2FkZWR9XG4gICAgICAgICAgICBoaWRlUmV0cnlCdXR0b249e3RoaXMucHJvcHMuaGlkZVJldHJ5QnV0dG9ufVxuICAgICAgICAgICAgaGlkZUNhbmNlbEJ1dHRvbj17dGhpcy5wcm9wcy5oaWRlQ2FuY2VsQnV0dG9ufVxuICAgICAgICAgICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uPXt0aGlzLnByb3BzLmhpZGVQYXVzZVJlc3VtZUJ1dHRvbn1cbiAgICAgICAgICAgIHJlY292ZXJlZFN0YXRlPXt0aGlzLnByb3BzLnJlY292ZXJlZFN0YXRlfVxuICAgICAgICAgICAgc2hvd1JlbW92ZUJ1dHRvbkFmdGVyQ29tcGxldGU9e3RoaXMucHJvcHMuc2hvd1JlbW92ZUJ1dHRvbkFmdGVyQ29tcGxldGV9XG4gICAgICAgICAgICByZXN1bWFibGVVcGxvYWRzPXt0aGlzLnByb3BzLnJlc3VtYWJsZVVwbG9hZHN9XG4gICAgICAgICAgICBpbmRpdmlkdWFsQ2FuY2VsbGF0aW9uPXt0aGlzLnByb3BzLmluZGl2aWR1YWxDYW5jZWxsYXRpb259XG4gICAgICAgICAgICBwYXVzZVVwbG9hZD17dGhpcy5wcm9wcy5wYXVzZVVwbG9hZH1cbiAgICAgICAgICAgIGNhbmNlbFVwbG9hZD17dGhpcy5wcm9wcy5jYW5jZWxVcGxvYWR9XG4gICAgICAgICAgICByZXRyeVVwbG9hZD17dGhpcy5wcm9wcy5yZXRyeVVwbG9hZH1cbiAgICAgICAgICAgIGkxOG49e3RoaXMucHJvcHMuaTE4bn1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tZmlsZUluZm9BbmRCdXR0b25zXCI+XG4gICAgICAgICAgPEZpbGVJbmZvXG4gICAgICAgICAgICBmaWxlPXtmaWxlfVxuICAgICAgICAgICAgaWQ9e3RoaXMucHJvcHMuaWR9XG4gICAgICAgICAgICBhY3F1aXJlcnM9e3RoaXMucHJvcHMuYWNxdWlyZXJzfVxuICAgICAgICAgICAgY29udGFpbmVyV2lkdGg9e3RoaXMucHJvcHMuY29udGFpbmVyV2lkdGh9XG4gICAgICAgICAgICBpMThuPXt0aGlzLnByb3BzLmkxOG59XG4gICAgICAgICAgICB0b2dnbGVBZGRGaWxlc1BhbmVsPXt0aGlzLnByb3BzLnRvZ2dsZUFkZEZpbGVzUGFuZWx9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8QnV0dG9uc1xuICAgICAgICAgICAgZmlsZT17ZmlsZX1cbiAgICAgICAgICAgIG1ldGFGaWVsZHM9e3RoaXMucHJvcHMubWV0YUZpZWxkc31cbiAgICAgICAgICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0PXt0aGlzLnByb3BzLnNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0fVxuICAgICAgICAgICAgc2hvd1JlbW92ZUJ1dHRvbj17c2hvd1JlbW92ZUJ1dHRvbn1cbiAgICAgICAgICAgIGNhbkVkaXRGaWxlPXt0aGlzLnByb3BzLmNhbkVkaXRGaWxlfVxuICAgICAgICAgICAgdXBsb2FkSW5Qcm9ncmVzc09yQ29tcGxldGU9e3VwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlfVxuICAgICAgICAgICAgcmVtb3ZlRmlsZT17dGhpcy5wcm9wcy5yZW1vdmVGaWxlfVxuICAgICAgICAgICAgdG9nZ2xlRmlsZUNhcmQ9e3RoaXMucHJvcHMudG9nZ2xlRmlsZUNhcmR9XG4gICAgICAgICAgICBvcGVuRmlsZUVkaXRvcj17dGhpcy5wcm9wcy5vcGVuRmlsZUVkaXRvcn1cbiAgICAgICAgICAgIGkxOG49e3RoaXMucHJvcHMuaTE4bn1cbiAgICAgICAgICAgIGxvZz17dGhpcy5wcm9wcy5sb2d9XG4gICAgICAgICAgICBpbmZvPXt0aGlzLnByb3BzLmluZm99XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cbiIsImNvbnN0IEZpbGVJdGVtID0gcmVxdWlyZSgnLi9GaWxlSXRlbS9pbmRleC5qcycpXG5jb25zdCBWaXJ0dWFsTGlzdCA9IHJlcXVpcmUoJy4vVmlydHVhbExpc3QnKVxuY29uc3QgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKVxuY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5mdW5jdGlvbiBjaHVua3MgKGxpc3QsIHNpemUpIHtcbiAgY29uc3QgY2h1bmtlZCA9IFtdXG4gIGxldCBjdXJyZW50Q2h1bmsgPSBbXVxuICBsaXN0LmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICBpZiAoY3VycmVudENodW5rLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIGN1cnJlbnRDaHVuay5wdXNoKGl0ZW0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNodW5rZWQucHVzaChjdXJyZW50Q2h1bmspXG4gICAgICBjdXJyZW50Q2h1bmsgPSBbaXRlbV1cbiAgICB9XG4gIH0pXG4gIGlmIChjdXJyZW50Q2h1bmsubGVuZ3RoKSBjaHVua2VkLnB1c2goY3VycmVudENodW5rKVxuICByZXR1cm4gY2h1bmtlZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBjb25zdCBub0ZpbGVzID0gcHJvcHMudG90YWxGaWxlQ291bnQgPT09IDBcbiAgY29uc3QgZGFzaGJvYXJkRmlsZXNDbGFzcyA9IGNsYXNzTmFtZXMoXG4gICAgJ3VwcHktRGFzaGJvYXJkLWZpbGVzJyxcbiAgICB7ICd1cHB5LURhc2hib2FyZC1maWxlcy0tbm9GaWxlcyc6IG5vRmlsZXMgfVxuICApXG5cbiAgLy8gSXQncyBub3QgZ3JlYXQgdGhhdCB0aGlzIGlzIGhhcmRjb2RlZCFcbiAgLy8gSXQncyBFU1BFQ0lBTExZIG5vdCBncmVhdCB0aGF0IHRoaXMgaXMgY2hlY2tpbmcgYWdhaW5zdCBgaXRlbXNQZXJSb3dgIVxuICBjb25zdCByb3dIZWlnaHQgPSBwcm9wcy5pdGVtc1BlclJvdyA9PT0gMVxuICAgIC8vIE1vYmlsZVxuICAgID8gNzFcbiAgICAvLyAxOTBweCBoZWlnaHQgKyAyICogNXB4IG1hcmdpblxuICAgIDogMjAwXG5cbiAgY29uc3QgZmlsZVByb3BzID0ge1xuICAgIC8vIEZJWE1FIFRoaXMgaXMgY29uZnVzaW5nLCBpdCdzIGFjdHVhbGx5IHRoZSBEYXNoYm9hcmQncyBwbHVnaW4gSURcbiAgICBpZDogcHJvcHMuaWQsXG4gICAgZXJyb3I6IHByb3BzLmVycm9yLFxuICAgIC8vIFRPRE8gbW92ZSB0aGlzIHRvIGNvbnRleHRcbiAgICBpMThuOiBwcm9wcy5pMThuLFxuICAgIGxvZzogcHJvcHMubG9nLFxuICAgIGluZm86IHByb3BzLmluZm8sXG4gICAgLy8gZmVhdHVyZXNcbiAgICBhY3F1aXJlcnM6IHByb3BzLmFjcXVpcmVycyxcbiAgICByZXN1bWFibGVVcGxvYWRzOiBwcm9wcy5yZXN1bWFibGVVcGxvYWRzLFxuICAgIGluZGl2aWR1YWxDYW5jZWxsYXRpb246IHByb3BzLmluZGl2aWR1YWxDYW5jZWxsYXRpb24sXG4gICAgLy8gdmlzdWFsIG9wdGlvbnNcbiAgICBoaWRlUmV0cnlCdXR0b246IHByb3BzLmhpZGVSZXRyeUJ1dHRvbixcbiAgICBoaWRlUGF1c2VSZXN1bWVCdXR0b246IHByb3BzLmhpZGVQYXVzZVJlc3VtZUJ1dHRvbixcbiAgICBoaWRlQ2FuY2VsQnV0dG9uOiBwcm9wcy5oaWRlQ2FuY2VsQnV0dG9uLFxuICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0OiBwcm9wcy5zaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdCxcbiAgICBzaG93UmVtb3ZlQnV0dG9uQWZ0ZXJDb21wbGV0ZTogcHJvcHMuc2hvd1JlbW92ZUJ1dHRvbkFmdGVyQ29tcGxldGUsXG4gICAgaXNXaWRlOiBwcm9wcy5pc1dpZGUsXG4gICAgbWV0YUZpZWxkczogcHJvcHMubWV0YUZpZWxkcyxcbiAgICByZWNvdmVyZWRTdGF0ZTogcHJvcHMucmVjb3ZlcmVkU3RhdGUsXG4gICAgLy8gY2FsbGJhY2tzXG4gICAgcmV0cnlVcGxvYWQ6IHByb3BzLnJldHJ5VXBsb2FkLFxuICAgIHBhdXNlVXBsb2FkOiBwcm9wcy5wYXVzZVVwbG9hZCxcbiAgICBjYW5jZWxVcGxvYWQ6IHByb3BzLmNhbmNlbFVwbG9hZCxcbiAgICB0b2dnbGVGaWxlQ2FyZDogcHJvcHMudG9nZ2xlRmlsZUNhcmQsXG4gICAgcmVtb3ZlRmlsZTogcHJvcHMucmVtb3ZlRmlsZSxcbiAgICBoYW5kbGVSZXF1ZXN0VGh1bWJuYWlsOiBwcm9wcy5oYW5kbGVSZXF1ZXN0VGh1bWJuYWlsLFxuICAgIGhhbmRsZUNhbmNlbFRodW1ibmFpbDogcHJvcHMuaGFuZGxlQ2FuY2VsVGh1bWJuYWlsLFxuICB9XG5cbiAgY29uc3Qgc29ydEJ5R2hvc3RDb21lc0ZpcnN0ID0gKGZpbGUxLCBmaWxlMikgPT4ge1xuICAgIHJldHVybiBwcm9wcy5maWxlc1tmaWxlMl0uaXNHaG9zdCAtIHByb3BzLmZpbGVzW2ZpbGUxXS5pc0dob3N0XG4gIH1cblxuICAvLyBTb3J0IGZpbGVzIGJ5IGZpbGUuaXNHaG9zdCwgZ2hvc3QgZmlsZXMgZmlyc3QsIG9ubHkgaWYgcmVjb3ZlcmVkU3RhdGUgaXMgcHJlc2VudFxuICBjb25zdCBmaWxlcyA9IE9iamVjdC5rZXlzKHByb3BzLmZpbGVzKVxuICBpZiAocHJvcHMucmVjb3ZlcmVkU3RhdGUpIGZpbGVzLnNvcnQoc29ydEJ5R2hvc3RDb21lc0ZpcnN0KVxuICBjb25zdCByb3dzID0gY2h1bmtzKGZpbGVzLCBwcm9wcy5pdGVtc1BlclJvdylcblxuICBmdW5jdGlvbiByZW5kZXJSb3cgKHJvdykge1xuICAgIHJldHVybiAoXG4gICAgICAvLyBUaGUgYHJvbGU9XCJwcmVzZW50YXRpb25gIGF0dHJpYnV0ZSBlbnN1cmVzIHRoYXQgdGhlIGxpc3QgaXRlbXMgYXJlIHByb3Blcmx5IGFzc29jaWF0ZWQgd2l0aCB0aGUgYFZpcnR1YWxMaXN0YCBlbGVtZW50XG4gICAgICAvLyBXZSB1c2UgdGhlIGZpcnN0IGZpbGUgSUQgYXMgdGhlIGtleeKAlHRoaXMgc2hvdWxkIG5vdCBjaGFuZ2UgYWNyb3NzIHNjcm9sbCByZXJlbmRlcnNcbiAgICAgIDxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGtleT17cm93WzBdfT5cbiAgICAgICAge3Jvdy5tYXAoKGZpbGVJRCkgPT4gKFxuICAgICAgICAgIDxGaWxlSXRlbVxuICAgICAgICAgICAga2V5PXtmaWxlSUR9XG4gICAgICAgICAgICB7Li4uZmlsZVByb3BzfVxuICAgICAgICAgICAgcm9sZT1cImxpc3RpdGVtXCJcbiAgICAgICAgICAgIG9wZW5GaWxlRWRpdG9yPXtwcm9wcy5vcGVuRmlsZUVkaXRvcn1cbiAgICAgICAgICAgIGNhbkVkaXRGaWxlPXtwcm9wcy5jYW5FZGl0RmlsZX1cbiAgICAgICAgICAgIHRvZ2dsZUFkZEZpbGVzUGFuZWw9e3Byb3BzLnRvZ2dsZUFkZEZpbGVzUGFuZWx9XG4gICAgICAgICAgICBmaWxlPXtwcm9wcy5maWxlc1tmaWxlSURdfVxuICAgICAgICAgIC8+XG4gICAgICAgICkpfVxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8VmlydHVhbExpc3RcbiAgICAgIGNsYXNzPXtkYXNoYm9hcmRGaWxlc0NsYXNzfVxuICAgICAgcm9sZT1cImxpc3RcIlxuICAgICAgZGF0YT17cm93c31cbiAgICAgIHJlbmRlclJvdz17cmVuZGVyUm93fVxuICAgICAgcm93SGVpZ2h0PXtyb3dIZWlnaHR9XG4gICAgLz5cbiAgKVxufVxuIiwiY29uc3QgZ2V0RmlsZVR5cGVJY29uID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2V0RmlsZVR5cGVJY29uJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGaWxlUHJldmlldyAocHJvcHMpIHtcbiAgY29uc3QgZmlsZSA9IHByb3BzLmZpbGVcblxuICBpZiAoZmlsZS5wcmV2aWV3KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxpbWdcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3SW1nXCJcbiAgICAgICAgYWx0PXtmaWxlLm5hbWV9XG4gICAgICAgIHNyYz17ZmlsZS5wcmV2aWV3fVxuICAgICAgLz5cbiAgICApXG4gIH1cblxuICBjb25zdCB7IGNvbG9yLCBpY29uIH0gPSBnZXRGaWxlVHlwZUljb24oZmlsZS50eXBlKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByZXZpZXdJY29uV3JhcFwiPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3SWNvblwiIHN0eWxlPXt7IGNvbG9yIH19PntpY29ufTwvc3Bhbj5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByZXZpZXdJY29uQmdcIiB3aWR0aD1cIjU4XCIgaGVpZ2h0PVwiNzZcIiB2aWV3Qm94PVwiMCAwIDU4IDc2XCI+XG4gICAgICAgIDxyZWN0IGZpbGw9XCIjRkZGXCIgd2lkdGg9XCI1OFwiIGhlaWdodD1cIjc2XCIgcng9XCIzXCIgZmlsbFJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBpZ25vcmVFdmVudCA9IHJlcXVpcmUoJy4uL3V0aWxzL2lnbm9yZUV2ZW50LmpzJylcblxuZnVuY3Rpb24gUGlja2VyUGFuZWxDb250ZW50IChwcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcygndXBweS1EYXNoYm9hcmRDb250ZW50LXBhbmVsJywgcHJvcHMuY2xhc3NOYW1lKX1cbiAgICAgIHJvbGU9XCJ0YWJwYW5lbFwiXG4gICAgICBkYXRhLXVwcHktcGFuZWxUeXBlPVwiUGlja2VyUGFuZWxcIlxuICAgICAgaWQ9e2B1cHB5LURhc2hib2FyZENvbnRlbnQtcGFuZWwtLSR7cHJvcHMuYWN0aXZlUGlja2VyUGFuZWwuaWR9YH1cbiAgICAgIG9uRHJhZ092ZXI9e2lnbm9yZUV2ZW50fVxuICAgICAgb25EcmFnTGVhdmU9e2lnbm9yZUV2ZW50fVxuICAgICAgb25Ecm9wPXtpZ25vcmVFdmVudH1cbiAgICAgIG9uUGFzdGU9e2lnbm9yZUV2ZW50fVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC10aXRsZVwiIHJvbGU9XCJoZWFkaW5nXCIgYXJpYS1sZXZlbD1cIjFcIj5cbiAgICAgICAgICB7cHJvcHMuaTE4bignaW1wb3J0RnJvbScsIHsgbmFtZTogcHJvcHMuYWN0aXZlUGlja2VyUGFuZWwubmFtZSB9KX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFja1wiXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgb25DbGljaz17cHJvcHMuaGlkZUFsbFBhbmVsc31cbiAgICAgICAgPlxuICAgICAgICAgIHtwcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXBhbmVsQm9keVwiPlxuICAgICAgICB7cHJvcHMuZ2V0UGx1Z2luKHByb3BzLmFjdGl2ZVBpY2tlclBhbmVsLmlkKS5yZW5kZXIocHJvcHMuc3RhdGUpfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQaWNrZXJQYW5lbENvbnRlbnRcbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuY29uc3QgdXBsb2FkU3RhdGVzID0ge1xuICBTVEFURV9FUlJPUjogJ2Vycm9yJyxcbiAgU1RBVEVfV0FJVElORzogJ3dhaXRpbmcnLFxuICBTVEFURV9QUkVQUk9DRVNTSU5HOiAncHJlcHJvY2Vzc2luZycsXG4gIFNUQVRFX1VQTE9BRElORzogJ3VwbG9hZGluZycsXG4gIFNUQVRFX1BPU1RQUk9DRVNTSU5HOiAncG9zdHByb2Nlc3NpbmcnLFxuICBTVEFURV9DT01QTEVURTogJ2NvbXBsZXRlJyxcbiAgU1RBVEVfUEFVU0VEOiAncGF1c2VkJyxcbn1cblxuZnVuY3Rpb24gZ2V0VXBsb2FkaW5nU3RhdGUgKGlzQWxsRXJyb3JlZCwgaXNBbGxDb21wbGV0ZSwgaXNBbGxQYXVzZWQsIGZpbGVzID0ge30pIHtcbiAgaWYgKGlzQWxsRXJyb3JlZCkge1xuICAgIHJldHVybiB1cGxvYWRTdGF0ZXMuU1RBVEVfRVJST1JcbiAgfVxuXG4gIGlmIChpc0FsbENvbXBsZXRlKSB7XG4gICAgcmV0dXJuIHVwbG9hZFN0YXRlcy5TVEFURV9DT01QTEVURVxuICB9XG5cbiAgaWYgKGlzQWxsUGF1c2VkKSB7XG4gICAgcmV0dXJuIHVwbG9hZFN0YXRlcy5TVEFURV9QQVVTRURcbiAgfVxuXG4gIGxldCBzdGF0ZSA9IHVwbG9hZFN0YXRlcy5TVEFURV9XQUlUSU5HXG4gIGNvbnN0IGZpbGVJRHMgPSBPYmplY3Qua2V5cyhmaWxlcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBmaWxlc1tmaWxlSURzW2ldXS5wcm9ncmVzc1xuICAgIC8vIElmIEFOWSBmaWxlcyBhcmUgYmVpbmcgdXBsb2FkZWQgcmlnaHQgbm93LCBzaG93IHRoZSB1cGxvYWRpbmcgc3RhdGUuXG4gICAgaWYgKHByb2dyZXNzLnVwbG9hZFN0YXJ0ZWQgJiYgIXByb2dyZXNzLnVwbG9hZENvbXBsZXRlKSB7XG4gICAgICByZXR1cm4gdXBsb2FkU3RhdGVzLlNUQVRFX1VQTE9BRElOR1xuICAgIH1cbiAgICAvLyBJZiBmaWxlcyBhcmUgYmVpbmcgcHJlcHJvY2Vzc2VkIEFORCBwb3N0cHJvY2Vzc2VkIGF0IHRoaXMgdGltZSwgd2Ugc2hvdyB0aGVcbiAgICAvLyBwcmVwcm9jZXNzIHN0YXRlLiBJZiBhbnkgZmlsZXMgYXJlIGJlaW5nIHVwbG9hZGVkIHdlIHNob3cgdXBsb2FkaW5nLlxuICAgIGlmIChwcm9ncmVzcy5wcmVwcm9jZXNzICYmIHN0YXRlICE9PSB1cGxvYWRTdGF0ZXMuU1RBVEVfVVBMT0FESU5HKSB7XG4gICAgICBzdGF0ZSA9IHVwbG9hZFN0YXRlcy5TVEFURV9QUkVQUk9DRVNTSU5HXG4gICAgfVxuICAgIC8vIElmIE5PIGZpbGVzIGFyZSBiZWluZyBwcmVwcm9jZXNzZWQgb3IgdXBsb2FkZWQgcmlnaHQgbm93LCBidXQgc29tZSBmaWxlcyBhcmVcbiAgICAvLyBiZWluZyBwb3N0cHJvY2Vzc2VkLCBzaG93IHRoZSBwb3N0cHJvY2VzcyBzdGF0ZS5cbiAgICBpZiAocHJvZ3Jlc3MucG9zdHByb2Nlc3MgJiYgc3RhdGUgIT09IHVwbG9hZFN0YXRlcy5TVEFURV9VUExPQURJTkcgJiYgc3RhdGUgIT09IHVwbG9hZFN0YXRlcy5TVEFURV9QUkVQUk9DRVNTSU5HKSB7XG4gICAgICBzdGF0ZSA9IHVwbG9hZFN0YXRlcy5TVEFURV9QT1NUUFJPQ0VTU0lOR1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGVcbn1cblxuZnVuY3Rpb24gVXBsb2FkU3RhdHVzIChwcm9wcykge1xuICBjb25zdCB1cGxvYWRpbmdTdGF0ZSA9IGdldFVwbG9hZGluZ1N0YXRlKFxuICAgIHByb3BzLmlzQWxsRXJyb3JlZCxcbiAgICBwcm9wcy5pc0FsbENvbXBsZXRlLFxuICAgIHByb3BzLmlzQWxsUGF1c2VkLFxuICAgIHByb3BzLmZpbGVzXG4gIClcblxuICBzd2l0Y2ggKHVwbG9hZGluZ1N0YXRlKSB7XG4gICAgY2FzZSAndXBsb2FkaW5nJzpcbiAgICAgIHJldHVybiBwcm9wcy5pMThuKCd1cGxvYWRpbmdYRmlsZXMnLCB7IHNtYXJ0X2NvdW50OiBwcm9wcy5pblByb2dyZXNzTm90UGF1c2VkRmlsZXMubGVuZ3RoIH0pXG4gICAgY2FzZSAncHJlcHJvY2Vzc2luZyc6XG4gICAgY2FzZSAncG9zdHByb2Nlc3NpbmcnOlxuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3Byb2Nlc3NpbmdYRmlsZXMnLCB7IHNtYXJ0X2NvdW50OiBwcm9wcy5wcm9jZXNzaW5nRmlsZXMubGVuZ3RoIH0pXG4gICAgY2FzZSAncGF1c2VkJzpcbiAgICAgIHJldHVybiBwcm9wcy5pMThuKCd1cGxvYWRQYXVzZWQnKVxuICAgIGNhc2UgJ3dhaXRpbmcnOlxuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3hGaWxlc1NlbGVjdGVkJywgeyBzbWFydF9jb3VudDogcHJvcHMubmV3RmlsZXMubGVuZ3RoIH0pXG4gICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3VwbG9hZENvbXBsZXRlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBQYW5lbFRvcEJhciAocHJvcHMpIHtcbiAgbGV0IGFsbG93TmV3VXBsb2FkID0gcHJvcHMuYWxsb3dOZXdVcGxvYWRcbiAgLy8gVE9ETyBtYXliZSB0aGlzIHNob3VsZCBiZSBkb25lIGluIC4uL2luZGV4LmpzLCB0aGVuIGp1c3QgcGFzcyB0aGF0IGRvd24gYXMgYGFsbG93TmV3VXBsb2FkYFxuICBpZiAoYWxsb3dOZXdVcGxvYWQgJiYgcHJvcHMubWF4TnVtYmVyT2ZGaWxlcykge1xuICAgIGFsbG93TmV3VXBsb2FkID0gcHJvcHMudG90YWxGaWxlQ291bnQgPCBwcm9wcy5tYXhOdW1iZXJPZkZpbGVzXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhclwiPlxuICAgICAgeyFwcm9wcy5pc0FsbENvbXBsZXRlICYmICFwcm9wcy5oaWRlQ2FuY2VsQnV0dG9uID8gKFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhY2tcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9e3Byb3BzLmNhbmNlbEFsbH1cbiAgICAgICAgPlxuICAgICAgICAgIHtwcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICApIDogKFxuICAgICAgICA8ZGl2IC8+XG4gICAgICApfVxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC10aXRsZVwiIHJvbGU9XCJoZWFkaW5nXCIgYXJpYS1sZXZlbD1cIjFcIj5cbiAgICAgICAgPFVwbG9hZFN0YXR1cyB7Li4ucHJvcHN9IC8+XG4gICAgICA8L2Rpdj5cblxuICAgICAge2FsbG93TmV3VXBsb2FkID8gKFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWFkZE1vcmVcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ2FkZE1vcmVGaWxlcycpfVxuICAgICAgICAgIHRpdGxlPXtwcm9wcy5pMThuKCdhZGRNb3JlRmlsZXMnKX1cbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBwcm9wcy50b2dnbGVBZGRGaWxlc1BhbmVsKHRydWUpfVxuICAgICAgICA+XG4gICAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxNVwiIGhlaWdodD1cIjE1XCIgdmlld0JveD1cIjAgMCAxNSAxNVwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk04IDYuNWg2YS41LjUgMCAwIDEgLjUuNXYuNWEuNS41IDAgMCAxLS41LjVIOHY2YS41LjUgMCAwIDEtLjUuNUg3YS41LjUgMCAwIDEtLjUtLjVWOGgtNmEuNS41IDAgMCAxLS41LS41VjdhLjUuNSAwIDAgMSAuNS0uNWg2di02QS41LjUgMCAwIDEgNyAwaC41YS41LjUgMCAwIDEgLjUuNXY2elwiIC8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWFkZE1vcmVDYXB0aW9uXCI+e3Byb3BzLmkxOG4oJ2FkZE1vcmUnKX08L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgKSA6IChcbiAgICAgICAgPGRpdiAvPlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhbmVsVG9wQmFyXG4iLCJjb25zdCB7IGNsb25lRWxlbWVudCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKVxuXG5jb25zdCB0cmFuc2l0aW9uTmFtZSA9ICd1cHB5LXRyYW5zaXRpb24tc2xpZGVEb3duVXAnXG5jb25zdCBkdXJhdGlvbiA9IDI1MFxuXG4vKipcbiAqIFZlcnRpY2FsIHNsaWRlIHRyYW5zaXRpb24uXG4gKlxuICogVGhpcyBjYW4gdGFrZSBhIF9zaW5nbGVfIGNoaWxkIGNvbXBvbmVudCwgd2hpY2ggX211c3RfIGFjY2VwdCBhIGBjbGFzc05hbWVgIHByb3AuXG4gKlxuICogQ3VycmVudGx5IHRoaXMgaXMgc3BlY2lmaWMgdG8gdGhlIGB1cHB5LXRyYW5zaXRpb24tc2xpZGVEb3duVXBgIHRyYW5zaXRpb24sXG4gKiBidXQgaXQgc2hvdWxkIGJlIHNpbXBsZSB0byBleHRlbmQgdGhpcyBmb3IgYW55IHR5cGUgb2Ygc2luZ2xlLWVsZW1lbnRcbiAqIHRyYW5zaXRpb24gYnkgc2V0dGluZyB0aGUgQ1NTIG5hbWUgYW5kIGR1cmF0aW9uIGFzIHByb3BzLlxuICovXG5jbGFzcyBTbGlkZSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGNhY2hlZENoaWxkcmVuOiBudWxsLFxuICAgICAgY2xhc3NOYW1lOiAnJyxcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVXBkYXRlIChuZXh0UHJvcHMpIHtcbiAgICBjb25zdCB7IGNhY2hlZENoaWxkcmVuIH0gPSB0aGlzLnN0YXRlXG4gICAgY29uc3QgY2hpbGQgPSBuZXh0UHJvcHMuY2hpbGRyZW5bMF1cblxuICAgIGlmIChjYWNoZWRDaGlsZHJlbiA9PT0gY2hpbGQpIHJldHVyblxuXG4gICAgY29uc3QgcGF0Y2ggPSB7XG4gICAgICBjYWNoZWRDaGlsZHJlbjogY2hpbGQsXG4gICAgfVxuXG4gICAgLy8gRW50ZXIgdHJhbnNpdGlvblxuICAgIGlmIChjaGlsZCAmJiAhY2FjaGVkQ2hpbGRyZW4pIHtcbiAgICAgIHBhdGNoLmNsYXNzTmFtZSA9IGAke3RyYW5zaXRpb25OYW1lfS1lbnRlcmBcblxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZSlcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmxlYXZlVGltZW91dClcbiAgICAgIHRoaXMubGVhdmVUaW1lb3V0ID0gdW5kZWZpbmVkXG5cbiAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAvLyBGb3JjZSBpdCB0byByZW5kZXIgYmVmb3JlIHdlIGFkZCB0aGUgYWN0aXZlIGNsYXNzXG4gICAgICAgIHRoaXMuYmFzZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGNsYXNzTmFtZTogYCR7dHJhbnNpdGlvbk5hbWV9LWVudGVyICR7dHJhbnNpdGlvbk5hbWV9LWVudGVyLWFjdGl2ZWAsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5lbnRlclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgY2xhc3NOYW1lOiAnJyB9KVxuICAgICAgICB9LCBkdXJhdGlvbilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gTGVhdmUgdHJhbnNpdGlvblxuICAgIGlmIChjYWNoZWRDaGlsZHJlbiAmJiAhY2hpbGQgJiYgdGhpcy5sZWF2ZVRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGF0Y2guY2FjaGVkQ2hpbGRyZW4gPSBjYWNoZWRDaGlsZHJlblxuICAgICAgcGF0Y2guY2xhc3NOYW1lID0gYCR7dHJhbnNpdGlvbk5hbWV9LWxlYXZlYFxuXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lKVxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZW50ZXJUaW1lb3V0KVxuICAgICAgdGhpcy5lbnRlclRpbWVvdXQgPSB1bmRlZmluZWRcbiAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjbGFzc05hbWU6IGAke3RyYW5zaXRpb25OYW1lfS1sZWF2ZSAke3RyYW5zaXRpb25OYW1lfS1sZWF2ZS1hY3RpdmVgLFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMubGVhdmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjYWNoZWRDaGlsZHJlbjogbnVsbCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJycsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSwgZHVyYXRpb24pXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUocGF0Y2gpXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHsgY2FjaGVkQ2hpbGRyZW4sIGNsYXNzTmFtZSB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgaWYgKCFjYWNoZWRDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmVFbGVtZW50KGNhY2hlZENoaWxkcmVuLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoY2xhc3NOYW1lLCBjYWNoZWRDaGlsZHJlbi5hdHRyaWJ1dGVzLmNsYXNzTmFtZSksXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNsaWRlXG4iLCIvKipcbiAqIEFkYXB0ZWQgZnJvbSBwcmVhY3QtdmlydHVhbC1saXN0OiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC12aXJ0dWFsLWxpc3RcbiAqXG4gKiDCqSAyMDE2IEphc29uIE1pbGxlclxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKlxuICogQWRhcHRhdGlvbnM6XG4gKiAtIEFkZGVkIHJvbGU9cHJlc2VudGF0aW9uIHRvIGhlbHBlciBlbGVtZW50c1xuICogLSBUd2Vha2VkIHN0eWxlcyBmb3IgVXBweSdzIERhc2hib2FyZCB1c2UgY2FzZVxuICovXG5cbmNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5jb25zdCBTVFlMRV9JTk5FUiA9IHtcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gIC8vIERpc2FibGVkIGZvciBvdXIgdXNlIGNhc2U6IHRoZSB3cmFwcGVyIGVsZW1lbnRzIGFyb3VuZCBGaWxlTGlzdCBhbHJlYWR5IGRlYWwgd2l0aCBvdmVyZmxvdyxcbiAgLy8gYW5kIHRoaXMgYWRkaXRpb25hbCBwcm9wZXJ0eSB3b3VsZCBoaWRlIHRoaW5ncyB0aGF0IHdlIHdhbnQgdG8gc2hvdy5cbiAgLy9cbiAgLy8gb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICB3aWR0aDogJzEwMCUnLFxuICBtaW5IZWlnaHQ6ICcxMDAlJyxcbn1cblxuY29uc3QgU1RZTEVfQ09OVEVOVCA9IHtcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHRvcDogMCxcbiAgbGVmdDogMCxcbiAgLy8gQmVjYXVzZSB0aGUgYHRvcGAgdmFsdWUgZ2V0cyBzZXQgdG8gc29tZSBvZmZzZXQsIHRoaXMgYGhlaWdodGAgYmVpbmcgMTAwJSB3b3VsZCBtYWtlIHRoZSBzY3JvbGxiYXJcbiAgLy8gc3RyZXRjaCBmYXIgYmV5b25kIHRoZSBjb250ZW50LiBGb3Igb3VyIHVzZSBjYXNlLCB0aGUgY29udGVudCBkaXYgYWN0dWFsbHkgY2FuIGdldCBpdHMgaGVpZ2h0IGZyb21cbiAgLy8gdGhlIGVsZW1lbnRzIGluc2lkZSBpdCwgc28gd2UgZG9uJ3QgbmVlZCB0byBzcGVjaWZ5IGEgYGhlaWdodGAgcHJvcGVydHkgYXQgYWxsLlxuICAvL1xuICAvLyBoZWlnaHQ6ICcxMDAlJyxcbiAgd2lkdGg6ICcxMDAlJyxcbiAgb3ZlcmZsb3c6ICd2aXNpYmxlJyxcbn1cblxuY2xhc3MgVmlydHVhbExpc3QgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcblxuICAgIC8vIFRoZSBjdXJyZW50bHkgZm9jdXNlZCBub2RlLCB1c2VkIHRvIHJldGFpbiBmb2N1cyB3aGVuIHRoZSB2aXNpYmxlIHJvd3MgY2hhbmdlLlxuICAgIC8vIFRvIGF2b2lkIHVwZGF0ZSBsb29wcywgdGhpcyBzaG91bGQgbm90IGNhdXNlIHN0YXRlIHVwZGF0ZXMsIHNvIGl0J3Mga2VwdCBhcyBhIHBsYWluIHByb3BlcnR5LlxuICAgIHRoaXMuZm9jdXNFbGVtZW50ID0gbnVsbFxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICB9XG4gIH1cblxuICByZXNpemUgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmhlaWdodCAhPT0gdGhpcy5iYXNlLm9mZnNldEhlaWdodCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGhlaWdodDogdGhpcy5iYXNlLm9mZnNldEhlaWdodCxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgIHRoaXMucmVzaXplKClcbiAgfVxuXG4gIGhhbmRsZVNjcm9sbCA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG9mZnNldDogdGhpcy5iYXNlLnNjcm9sbFRvcCxcbiAgICB9KVxuICAgIGlmICh0aGlzLnByb3BzLnN5bmMpIHtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVcGRhdGUgKCkge1xuICAgIGlmICh0aGlzLmJhc2UuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHRoaXMuZm9jdXNFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSAoKSB7XG4gICAgLy8gTWFpbnRhaW4gZm9jdXMgd2hlbiByb3dzIGFyZSBhZGRlZCBhbmQgcmVtb3ZlZC5cbiAgICBpZiAodGhpcy5mb2N1c0VsZW1lbnQgJiYgdGhpcy5mb2N1c0VsZW1lbnQucGFyZW50Tm9kZVxuICAgICAgICAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0aGlzLmZvY3VzRWxlbWVudCkge1xuICAgICAgdGhpcy5mb2N1c0VsZW1lbnQuZm9jdXMoKVxuICAgIH1cbiAgICB0aGlzLmZvY3VzRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLnJlc2l6ZSgpXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgdGhpcy5yZXNpemUoKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSlcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpXG4gIH1cblxuICByZW5kZXIgKHtcbiAgICBkYXRhLFxuICAgIHJvd0hlaWdodCxcbiAgICByZW5kZXJSb3csXG4gICAgb3ZlcnNjYW5Db3VudCA9IDEwLFxuICAgIHN5bmMsXG4gICAgLi4ucHJvcHNcbiAgfSkge1xuICAgIGNvbnN0IHsgb2Zmc2V0LCBoZWlnaHQgfSA9IHRoaXMuc3RhdGVcbiAgICAvLyBmaXJzdCB2aXNpYmxlIHJvdyBpbmRleFxuICAgIGxldCBzdGFydCA9IE1hdGguZmxvb3Iob2Zmc2V0IC8gcm93SGVpZ2h0KVxuXG4gICAgLy8gYWN0dWFsIG51bWJlciBvZiB2aXNpYmxlIHJvd3MgKHdpdGhvdXQgb3ZlcnNjYW4pXG4gICAgbGV0IHZpc2libGVSb3dDb3VudCA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gcm93SGVpZ2h0KVxuXG4gICAgLy8gT3ZlcnNjYW46IHJlbmRlciBibG9ja3Mgb2Ygcm93cyBtb2R1bG8gYW4gb3ZlcnNjYW4gcm93IGNvdW50XG4gICAgLy8gVGhpcyBkcmFtYXRpY2FsbHkgcmVkdWNlcyBET00gd3JpdGVzIGR1cmluZyBzY3JvbGxpbmdcbiAgICBpZiAob3ZlcnNjYW5Db3VudCkge1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCAtIChzdGFydCAlIG92ZXJzY2FuQ291bnQpKVxuICAgICAgdmlzaWJsZVJvd0NvdW50ICs9IG92ZXJzY2FuQ291bnRcbiAgICB9XG5cbiAgICAvLyBsYXN0IHZpc2libGUgKyBvdmVyc2NhbiByb3cgaW5kZXggKyBwYWRkaW5nIHRvIGFsbG93IGtleWJvYXJkIGZvY3VzIHRvIHRyYXZlbCBwYXN0IHRoZSB2aXNpYmxlIGFyZWFcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIHZpc2libGVSb3dDb3VudCArIDRcblxuICAgIC8vIGRhdGEgc2xpY2UgY3VycmVudGx5IGluIHZpZXdwb3J0IHBsdXMgb3ZlcnNjYW4gaXRlbXNcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgICBjb25zdCBzdHlsZUlubmVyID0geyAuLi5TVFlMRV9JTk5FUiwgaGVpZ2h0OiBkYXRhLmxlbmd0aCAqIHJvd0hlaWdodCB9XG4gICAgY29uc3Qgc3R5bGVDb250ZW50ID0geyAuLi5TVFlMRV9DT05URU5ULCB0b3A6IHN0YXJ0ICogcm93SGVpZ2h0IH1cblxuICAgIC8vIFRoZSBgcm9sZT1cInByZXNlbnRhdGlvblwiYCBhdHRyaWJ1dGVzIGVuc3VyZSB0aGF0IHRoZXNlIHdyYXBwZXIgZWxlbWVudHMgYXJlIG5vdCB0cmVhdGVkIGFzIGxpc3RcbiAgICAvLyBpdGVtcyBieSBhY2Nlc3NpYmlsaXR5IGFuZCBvdXRsaW5lIHRvb2xzLlxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IG9uU2Nyb2xsPXt0aGlzLmhhbmRsZVNjcm9sbH0gey4uLnByb3BzfT5cbiAgICAgICAgPGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgc3R5bGU9e3N0eWxlSW5uZXJ9PlxuICAgICAgICAgIDxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIHN0eWxlPXtzdHlsZUNvbnRlbnR9PlxuICAgICAgICAgICAge3NlbGVjdGlvbi5tYXAocmVuZGVyUm93KX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWaXJ0dWFsTGlzdFxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9UcmFuc2xhdG9yJylcbmNvbnN0IERhc2hib2FyZFVJID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0Rhc2hib2FyZCcpXG5jb25zdCBTdGF0dXNCYXIgPSByZXF1aXJlKCdAdXBweS9zdGF0dXMtYmFyJylcbmNvbnN0IEluZm9ybWVyID0gcmVxdWlyZSgnQHVwcHkvaW5mb3JtZXInKVxuY29uc3QgVGh1bWJuYWlsR2VuZXJhdG9yID0gcmVxdWlyZSgnQHVwcHkvdGh1bWJuYWlsLWdlbmVyYXRvcicpXG5jb25zdCBmaW5kQWxsRE9NRWxlbWVudHMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZmluZEFsbERPTUVsZW1lbnRzJylcbmNvbnN0IHRvQXJyYXkgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvdG9BcnJheScpXG5jb25zdCBnZXREcm9wcGVkRmlsZXMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0RHJvcHBlZEZpbGVzJylcbmNvbnN0IGdldFRleHREaXJlY3Rpb24gPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0VGV4dERpcmVjdGlvbicpXG5jb25zdCB0cmFwRm9jdXMgPSByZXF1aXJlKCcuL3V0aWxzL3RyYXBGb2N1cycpXG5jb25zdCBjdWlkID0gcmVxdWlyZSgnY3VpZCcpXG5jb25zdCBSZXNpemVPYnNlcnZlciA9IHJlcXVpcmUoJ3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbCcpLmRlZmF1bHQgfHwgcmVxdWlyZSgncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJylcbmNvbnN0IGNyZWF0ZVN1cGVyRm9jdXMgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZVN1cGVyRm9jdXMnKVxuY29uc3QgbWVtb2l6ZSA9IHJlcXVpcmUoJ21lbW9pemUtb25lJykuZGVmYXVsdCB8fCByZXF1aXJlKCdtZW1vaXplLW9uZScpXG5jb25zdCBGT0NVU0FCTEVfRUxFTUVOVFMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvRk9DVVNBQkxFX0VMRU1FTlRTJylcblxuY29uc3QgVEFCX0tFWSA9IDlcbmNvbnN0IEVTQ19LRVkgPSAyN1xuXG5mdW5jdGlvbiBjcmVhdGVQcm9taXNlICgpIHtcbiAgY29uc3QgbyA9IHt9XG4gIG8ucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBvLnJlc29sdmUgPSByZXNvbHZlXG4gICAgby5yZWplY3QgPSByZWplY3RcbiAgfSlcbiAgcmV0dXJuIG9cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFBpY2tlckljb24gKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMwXCIgaGVpZ2h0PVwiMzBcIiB2aWV3Qm94PVwiMCAwIDMwIDMwXCI+XG4gICAgICA8cGF0aCBkPVwiTTE1IDMwYzguMjg0IDAgMTUtNi43MTYgMTUtMTUgMC04LjI4NC02LjcxNi0xNS0xNS0xNUM2LjcxNiAwIDAgNi43MTYgMCAxNWMwIDguMjg0IDYuNzE2IDE1IDE1IDE1em00LjI1OC0xMi42NzZ2Ni44NDZoLTguNDI2di02Ljg0Nkg1LjIwNGw5LjgyLTEyLjM2NCA5LjgyIDEyLjM2NEgxOS4yNnpcIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbi8qKlxuICogRGFzaGJvYXJkIFVJIHdpdGggcHJldmlld3MsIG1ldGFkYXRhIGVkaXRpbmcsIHRhYnMgZm9yIHZhcmlvdXMgc2VydmljZXMgYW5kIG1vcmVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEYXNoYm9hcmQgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnRGFzaGJvYXJkJ1xuICAgIHRoaXMudGl0bGUgPSAnRGFzaGJvYXJkJ1xuICAgIHRoaXMudHlwZSA9ICdvcmNoZXN0cmF0b3InXG4gICAgdGhpcy5tb2RhbE5hbWUgPSBgdXBweS1EYXNoYm9hcmQtJHtjdWlkKCl9YFxuXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0ge1xuICAgICAgc3RyaW5nczoge1xuICAgICAgICBjbG9zZU1vZGFsOiAnQ2xvc2UgTW9kYWwnLFxuICAgICAgICBpbXBvcnRGcm9tOiAnSW1wb3J0IGZyb20gJXtuYW1lfScsXG4gICAgICAgIGFkZGluZ01vcmVGaWxlczogJ0FkZGluZyBtb3JlIGZpbGVzJyxcbiAgICAgICAgYWRkTW9yZUZpbGVzOiAnQWRkIG1vcmUgZmlsZXMnLFxuICAgICAgICBkYXNoYm9hcmRXaW5kb3dUaXRsZTogJ0ZpbGUgVXBsb2FkZXIgV2luZG93IChQcmVzcyBlc2NhcGUgdG8gY2xvc2UpJyxcbiAgICAgICAgZGFzaGJvYXJkVGl0bGU6ICdGaWxlIFVwbG9hZGVyJyxcbiAgICAgICAgY29weUxpbmtUb0NsaXBib2FyZFN1Y2Nlc3M6ICdMaW5rIGNvcGllZCB0byBjbGlwYm9hcmQnLFxuICAgICAgICBjb3B5TGlua1RvQ2xpcGJvYXJkRmFsbGJhY2s6ICdDb3B5IHRoZSBVUkwgYmVsb3cnLFxuICAgICAgICBjb3B5TGluazogJ0NvcHkgbGluaycsXG4gICAgICAgIGZpbGVTb3VyY2U6ICdGaWxlIHNvdXJjZTogJXtuYW1lfScsXG4gICAgICAgIGJhY2s6ICdCYWNrJyxcbiAgICAgICAgYWRkTW9yZTogJ0FkZCBtb3JlJyxcbiAgICAgICAgcmVtb3ZlRmlsZTogJ1JlbW92ZSBmaWxlJyxcbiAgICAgICAgZWRpdEZpbGU6ICdFZGl0IGZpbGUnLFxuICAgICAgICBlZGl0aW5nOiAnRWRpdGluZyAle2ZpbGV9JyxcbiAgICAgICAgZmluaXNoRWRpdGluZ0ZpbGU6ICdGaW5pc2ggZWRpdGluZyBmaWxlJyxcbiAgICAgICAgc2F2ZTogJ1NhdmUnLFxuICAgICAgICBzYXZlQ2hhbmdlczogJ1NhdmUgY2hhbmdlcycsXG4gICAgICAgIGNhbmNlbDogJ0NhbmNlbCcsXG4gICAgICAgIG15RGV2aWNlOiAnTXkgRGV2aWNlJyxcbiAgICAgICAgZHJvcFBhc3RlRmlsZXM6ICdEcm9wIGZpbGVzIGhlcmUgb3IgJXticm93c2VGaWxlc30nLFxuICAgICAgICBkcm9wUGFzdGVGb2xkZXJzOiAnRHJvcCBmaWxlcyBoZXJlIG9yICV7YnJvd3NlRm9sZGVyc30nLFxuICAgICAgICBkcm9wUGFzdGVCb3RoOiAnRHJvcCBmaWxlcyBoZXJlLCAle2Jyb3dzZUZpbGVzfSBvciAle2Jyb3dzZUZvbGRlcnN9JyxcbiAgICAgICAgZHJvcFBhc3RlSW1wb3J0RmlsZXM6ICdEcm9wIGZpbGVzIGhlcmUsICV7YnJvd3NlRmlsZXN9IG9yIGltcG9ydCBmcm9tOicsXG4gICAgICAgIGRyb3BQYXN0ZUltcG9ydEZvbGRlcnM6ICdEcm9wIGZpbGVzIGhlcmUsICV7YnJvd3NlRm9sZGVyc30gb3IgaW1wb3J0IGZyb206JyxcbiAgICAgICAgZHJvcFBhc3RlSW1wb3J0Qm90aDogJ0Ryb3AgZmlsZXMgaGVyZSwgJXticm93c2VGaWxlc30sICV7YnJvd3NlRm9sZGVyc30gb3IgaW1wb3J0IGZyb206JyxcbiAgICAgICAgaW1wb3J0RmlsZXM6ICdJbXBvcnQgZmlsZXMgZnJvbTonLFxuICAgICAgICBkcm9wSGludDogJ0Ryb3AgeW91ciBmaWxlcyBoZXJlJyxcbiAgICAgICAgYnJvd3NlRmlsZXM6ICdicm93c2UgZmlsZXMnLFxuICAgICAgICBicm93c2VGb2xkZXJzOiAnYnJvd3NlIGZvbGRlcnMnLFxuICAgICAgICB1cGxvYWRDb21wbGV0ZTogJ1VwbG9hZCBjb21wbGV0ZScsXG4gICAgICAgIHVwbG9hZFBhdXNlZDogJ1VwbG9hZCBwYXVzZWQnLFxuICAgICAgICByZXN1bWVVcGxvYWQ6ICdSZXN1bWUgdXBsb2FkJyxcbiAgICAgICAgcGF1c2VVcGxvYWQ6ICdQYXVzZSB1cGxvYWQnLFxuICAgICAgICByZXRyeVVwbG9hZDogJ1JldHJ5IHVwbG9hZCcsXG4gICAgICAgIGNhbmNlbFVwbG9hZDogJ0NhbmNlbCB1cGxvYWQnLFxuICAgICAgICB4RmlsZXNTZWxlY3RlZDoge1xuICAgICAgICAgIDA6ICcle3NtYXJ0X2NvdW50fSBmaWxlIHNlbGVjdGVkJyxcbiAgICAgICAgICAxOiAnJXtzbWFydF9jb3VudH0gZmlsZXMgc2VsZWN0ZWQnLFxuICAgICAgICB9LFxuICAgICAgICB1cGxvYWRpbmdYRmlsZXM6IHtcbiAgICAgICAgICAwOiAnVXBsb2FkaW5nICV7c21hcnRfY291bnR9IGZpbGUnLFxuICAgICAgICAgIDE6ICdVcGxvYWRpbmcgJXtzbWFydF9jb3VudH0gZmlsZXMnLFxuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzaW5nWEZpbGVzOiB7XG4gICAgICAgICAgMDogJ1Byb2Nlc3NpbmcgJXtzbWFydF9jb3VudH0gZmlsZScsXG4gICAgICAgICAgMTogJ1Byb2Nlc3NpbmcgJXtzbWFydF9jb3VudH0gZmlsZXMnLFxuICAgICAgICB9LFxuICAgICAgICByZWNvdmVyZWRYRmlsZXM6IHtcbiAgICAgICAgICAwOiAnV2UgY291bGQgbm90IGZ1bGx5IHJlY292ZXIgMSBmaWxlLiBQbGVhc2UgcmUtc2VsZWN0IGl0IGFuZCByZXN1bWUgdGhlIHVwbG9hZC4nLFxuICAgICAgICAgIDE6ICdXZSBjb3VsZCBub3QgZnVsbHkgcmVjb3ZlciAle3NtYXJ0X2NvdW50fSBmaWxlcy4gUGxlYXNlIHJlLXNlbGVjdCB0aGVtIGFuZCByZXN1bWUgdGhlIHVwbG9hZC4nLFxuICAgICAgICB9LFxuICAgICAgICByZWNvdmVyZWRBbGxGaWxlczogJ1dlIHJlc3RvcmVkIGFsbCBmaWxlcy4gWW91IGNhbiBub3cgcmVzdW1lIHRoZSB1cGxvYWQuJyxcbiAgICAgICAgc2Vzc2lvblJlc3RvcmVkOiAnU2Vzc2lvbiByZXN0b3JlZCcsXG4gICAgICAgIHJlU2VsZWN0OiAnUmUtc2VsZWN0JyxcbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgYHBvd2VyZWRCeTJgIHN0cmluZyBvbmx5IGNvbWJpbmVzIHRoZSBgcG93ZXJlZEJ5YCBzdHJpbmcgKCV7YmFja3dhcmRzQ29tcGF0fSkgd2l0aCB0aGUgc2l6ZS5cbiAgICAgICAgLy8gTG9jYWxlcyBjYW4gb3ZlcnJpZGUgYHBvd2VyZWRCeTJgIHRvIHNwZWNpZnkgYSBkaWZmZXJlbnQgd29yZCBvcmRlci4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoXG4gICAgICAgIC8vIFVwcHkgMS45LnggYW5kIGJlbG93IHdoaWNoIGRpZCBhIG5haXZlIGNvbmNhdGVuYXRpb24gb2YgYHBvd2VyZWRCeTIgKyBzaXplYCBpbnN0ZWFkIG9mIHVzaW5nIGEgbG9jYWxlLXNwZWNpZmljXG4gICAgICAgIC8vIHN1YnN0aXR1dGlvbi5cbiAgICAgICAgLy8gVE9ETzogSW4gMi4wIGBwb3dlcmVkQnkyYCBzaG91bGQgYmUgcmVtb3ZlZCBpbiBhbmQgYHBvd2VyZWRCeWAgdXBkYXRlZCB0byB1c2Ugc3Vic3RpdHV0aW9uLlxuICAgICAgICBwb3dlcmVkQnkyOiAnJXtiYWNrd2FyZHNDb21wYXR9ICV7dXBweX0nLFxuICAgICAgICBwb3dlcmVkQnk6ICdQb3dlcmVkIGJ5JyxcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdGFyZ2V0OiAnYm9keScsXG4gICAgICBtZXRhRmllbGRzOiBbXSxcbiAgICAgIHRyaWdnZXI6ICcjdXBweS1zZWxlY3QtZmlsZXMnLFxuICAgICAgaW5saW5lOiBmYWxzZSxcbiAgICAgIHdpZHRoOiA3NTAsXG4gICAgICBoZWlnaHQ6IDU1MCxcbiAgICAgIHRodW1ibmFpbFdpZHRoOiAyODAsXG4gICAgICB0aHVtYm5haWxUeXBlOiAnaW1hZ2UvanBlZycsXG4gICAgICB3YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZDogZmFsc2UsXG4gICAgICBkZWZhdWx0UGlja2VySWNvbixcbiAgICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0OiB0cnVlLFxuICAgICAgc2hvd1Byb2dyZXNzRGV0YWlsczogZmFsc2UsXG4gICAgICBoaWRlVXBsb2FkQnV0dG9uOiBmYWxzZSxcbiAgICAgIGhpZGVDYW5jZWxCdXR0b246IGZhbHNlLFxuICAgICAgaGlkZVJldHJ5QnV0dG9uOiBmYWxzZSxcbiAgICAgIGhpZGVQYXVzZVJlc3VtZUJ1dHRvbjogZmFsc2UsXG4gICAgICBoaWRlUHJvZ3Jlc3NBZnRlckZpbmlzaDogZmFsc2UsXG4gICAgICBkb25lQnV0dG9uSGFuZGxlcjogKCkgPT4ge1xuICAgICAgICB0aGlzLnVwcHkucmVzZXQoKVxuICAgICAgICB0aGlzLnJlcXVlc3RDbG9zZU1vZGFsKClcbiAgICAgIH0sXG4gICAgICBub3RlOiBudWxsLFxuICAgICAgY2xvc2VNb2RhbE9uQ2xpY2tPdXRzaWRlOiBmYWxzZSxcbiAgICAgIGNsb3NlQWZ0ZXJGaW5pc2g6IGZhbHNlLFxuICAgICAgZGlzYWJsZVN0YXR1c0JhcjogZmFsc2UsXG4gICAgICBkaXNhYmxlSW5mb3JtZXI6IGZhbHNlLFxuICAgICAgZGlzYWJsZVRodW1ibmFpbEdlbmVyYXRvcjogZmFsc2UsXG4gICAgICBkaXNhYmxlUGFnZVNjcm9sbFdoZW5Nb2RhbE9wZW46IHRydWUsXG4gICAgICBhbmltYXRlT3BlbkNsb3NlOiB0cnVlLFxuICAgICAgZmlsZU1hbmFnZXJTZWxlY3Rpb25UeXBlOiAnZmlsZXMnLFxuICAgICAgcHJvdWRseURpc3BsYXlQb3dlcmVkQnlVcHB5OiB0cnVlLFxuICAgICAgb25SZXF1ZXN0Q2xvc2VNb2RhbDogKCkgPT4gdGhpcy5jbG9zZU1vZGFsKCksXG4gICAgICBzaG93U2VsZWN0ZWRGaWxlczogdHJ1ZSxcbiAgICAgIHNob3dSZW1vdmVCdXR0b25BZnRlckNvbXBsZXRlOiBmYWxzZSxcbiAgICAgIGJyb3dzZXJCYWNrQnV0dG9uQ2xvc2U6IGZhbHNlLFxuICAgICAgdGhlbWU6ICdsaWdodCcsXG4gICAgICBhdXRvT3BlbkZpbGVFZGl0b3I6IGZhbHNlLFxuICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgZGlzYWJsZUxvY2FsRmlsZXM6IGZhbHNlLFxuICAgIH1cblxuICAgIC8vIG1lcmdlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBvbmVzIHNldCBieSB1c2VyXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcblxuICAgIHRoaXMuc3VwZXJGb2N1cyA9IGNyZWF0ZVN1cGVyRm9jdXMoKVxuICAgIHRoaXMuaWZGb2N1c2VkT25VcHB5UmVjZW50bHkgPSBmYWxzZVxuXG4gICAgLy8gVGltZW91dHNcbiAgICB0aGlzLm1ha2VEYXNoYm9hcmRJbnNpZGVzVmlzaWJsZUFueXdheVRpbWVvdXQgPSBudWxsXG4gICAgdGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dCA9IG51bGxcbiAgfVxuXG4gIHNldE9wdGlvbnMgPSAobmV3T3B0cykgPT4ge1xuICAgIHN1cGVyLnNldE9wdGlvbnMobmV3T3B0cylcbiAgICB0aGlzLmkxOG5Jbml0KClcbiAgfVxuXG4gIGkxOG5Jbml0ID0gKCkgPT4ge1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKFt0aGlzLmRlZmF1bHRMb2NhbGUsIHRoaXMudXBweS5sb2NhbGUsIHRoaXMub3B0cy5sb2NhbGVdKVxuICAgIHRoaXMuaTE4biA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5pMThuQXJyYXkgPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlQXJyYXkuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyBhbmQgd2Ugc2VlIHRoZSB1cGRhdGVkIGxvY2FsZVxuICB9XG5cbiAgcmVtb3ZlVGFyZ2V0ID0gKHBsdWdpbikgPT4ge1xuICAgIGNvbnN0IHBsdWdpblN0YXRlID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgLy8gZmlsdGVyIG91dCB0aGUgb25lIHdlIHdhbnQgdG8gcmVtb3ZlXG4gICAgY29uc3QgbmV3VGFyZ2V0cyA9IHBsdWdpblN0YXRlLnRhcmdldHMuZmlsdGVyKHRhcmdldCA9PiB0YXJnZXQuaWQgIT09IHBsdWdpbi5pZClcblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgdGFyZ2V0czogbmV3VGFyZ2V0cyxcbiAgICB9KVxuICB9XG5cbiAgYWRkVGFyZ2V0ID0gKHBsdWdpbikgPT4ge1xuICAgIGNvbnN0IGNhbGxlclBsdWdpbklkID0gcGx1Z2luLmlkIHx8IHBsdWdpbi5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgY29uc3QgY2FsbGVyUGx1Z2luTmFtZSA9IHBsdWdpbi50aXRsZSB8fCBjYWxsZXJQbHVnaW5JZFxuICAgIGNvbnN0IGNhbGxlclBsdWdpblR5cGUgPSBwbHVnaW4udHlwZVxuXG4gICAgaWYgKGNhbGxlclBsdWdpblR5cGUgIT09ICdhY3F1aXJlcidcbiAgICAgICAgJiYgY2FsbGVyUGx1Z2luVHlwZSAhPT0gJ3Byb2dyZXNzaW5kaWNhdG9yJ1xuICAgICAgICAmJiBjYWxsZXJQbHVnaW5UeXBlICE9PSAnZWRpdG9yJykge1xuICAgICAgY29uc3QgbXNnID0gJ0Rhc2hib2FyZDogY2FuIG9ubHkgYmUgdGFyZ2V0ZWQgYnkgcGx1Z2lucyBvZiB0eXBlczogYWNxdWlyZXIsIHByb2dyZXNzaW5kaWNhdG9yLCBlZGl0b3InXG4gICAgICB0aGlzLnVwcHkubG9nKG1zZywgJ2Vycm9yJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IHtcbiAgICAgIGlkOiBjYWxsZXJQbHVnaW5JZCxcbiAgICAgIG5hbWU6IGNhbGxlclBsdWdpbk5hbWUsXG4gICAgICB0eXBlOiBjYWxsZXJQbHVnaW5UeXBlLFxuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgbmV3VGFyZ2V0cyA9IHN0YXRlLnRhcmdldHMuc2xpY2UoKVxuICAgIG5ld1RhcmdldHMucHVzaCh0YXJnZXQpXG5cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIHRhcmdldHM6IG5ld1RhcmdldHMsXG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzLmVsXG4gIH1cblxuICBoaWRlQWxsUGFuZWxzID0gKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHtcbiAgICAgIGFjdGl2ZVBpY2tlclBhbmVsOiBmYWxzZSxcbiAgICAgIHNob3dBZGRGaWxlc1BhbmVsOiBmYWxzZSxcbiAgICAgIGFjdGl2ZU92ZXJsYXlUeXBlOiBudWxsLFxuICAgICAgZmlsZUNhcmRGb3I6IG51bGwsXG4gICAgICBzaG93RmlsZUVkaXRvcjogZmFsc2UsXG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGlmIChjdXJyZW50LmFjdGl2ZVBpY2tlclBhbmVsID09PSB1cGRhdGUuYWN0aXZlUGlja2VyUGFuZWxcbiAgICAgICAgJiYgY3VycmVudC5zaG93QWRkRmlsZXNQYW5lbCA9PT0gdXBkYXRlLnNob3dBZGRGaWxlc1BhbmVsXG4gICAgICAgICYmIGN1cnJlbnQuc2hvd0ZpbGVFZGl0b3IgPT09IHVwZGF0ZS5zaG93RmlsZUVkaXRvclxuICAgICAgICAmJiBjdXJyZW50LmFjdGl2ZU92ZXJsYXlUeXBlID09PSB1cGRhdGUuYWN0aXZlT3ZlcmxheVR5cGUpIHtcbiAgICAgIC8vIGF2b2lkIGRvaW5nIGEgc3RhdGUgdXBkYXRlIGlmIG5vdGhpbmcgY2hhbmdlZFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh1cGRhdGUpXG4gIH1cblxuICBzaG93UGFuZWwgPSAoaWQpID0+IHtcbiAgICBjb25zdCB7IHRhcmdldHMgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgY29uc3QgYWN0aXZlUGlja2VyUGFuZWwgPSB0YXJnZXRzLmZpbHRlcigodGFyZ2V0KSA9PiB7XG4gICAgICByZXR1cm4gdGFyZ2V0LnR5cGUgPT09ICdhY3F1aXJlcicgJiYgdGFyZ2V0LmlkID09PSBpZFxuICAgIH0pWzBdXG5cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGFjdGl2ZVBpY2tlclBhbmVsLFxuICAgICAgYWN0aXZlT3ZlcmxheVR5cGU6ICdQaWNrZXJQYW5lbCcsXG4gICAgfSlcbiAgfVxuXG4gIGNhbkVkaXRGaWxlID0gKGZpbGUpID0+IHtcbiAgICBjb25zdCB7IHRhcmdldHMgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IGVkaXRvcnMgPSB0aGlzLl9nZXRFZGl0b3JzKHRhcmdldHMpXG5cbiAgICByZXR1cm4gZWRpdG9ycy5zb21lKCh0YXJnZXQpID0+IChcbiAgICAgIHRoaXMudXBweS5nZXRQbHVnaW4odGFyZ2V0LmlkKS5jYW5FZGl0RmlsZShmaWxlKVxuICAgICkpXG4gIH1cblxuICBvcGVuRmlsZUVkaXRvciA9IChmaWxlKSA9PiB7XG4gICAgY29uc3QgeyB0YXJnZXRzIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBlZGl0b3JzID0gdGhpcy5fZ2V0RWRpdG9ycyh0YXJnZXRzKVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBzaG93RmlsZUVkaXRvcjogdHJ1ZSxcbiAgICAgIGZpbGVDYXJkRm9yOiBmaWxlLmlkIHx8IG51bGwsXG4gICAgICBhY3RpdmVPdmVybGF5VHlwZTogJ0ZpbGVFZGl0b3InLFxuICAgIH0pXG5cbiAgICBlZGl0b3JzLmZvckVhY2goKGVkaXRvcikgPT4ge1xuICAgICAgdGhpcy51cHB5LmdldFBsdWdpbihlZGl0b3IuaWQpLnNlbGVjdEZpbGUoZmlsZSlcbiAgICB9KVxuICB9XG5cbiAgc2F2ZUZpbGVFZGl0b3IgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB0YXJnZXRzIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBlZGl0b3JzID0gdGhpcy5fZ2V0RWRpdG9ycyh0YXJnZXRzKVxuXG4gICAgZWRpdG9ycy5mb3JFYWNoKChlZGl0b3IpID0+IHtcbiAgICAgIHRoaXMudXBweS5nZXRQbHVnaW4oZWRpdG9yLmlkKS5zYXZlKClcbiAgICB9KVxuXG4gICAgdGhpcy5oaWRlQWxsUGFuZWxzKClcbiAgfVxuXG4gIG9wZW5Nb2RhbCA9ICgpID0+IHtcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZVByb21pc2UoKVxuICAgIC8vIHNhdmUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgdGhpcy5zYXZlZFNjcm9sbFBvc2l0aW9uID0gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgLy8gc2F2ZSBhY3RpdmUgZWxlbWVudCwgc28gd2UgY2FuIHJlc3RvcmUgZm9jdXMgd2hlbiBtb2RhbCBpcyBjbG9zZWRcbiAgICB0aGlzLnNhdmVkQWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcblxuICAgIGlmICh0aGlzLm9wdHMuZGlzYWJsZVBhZ2VTY3JvbGxXaGVuTW9kYWxPcGVuKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ3VwcHktRGFzaGJvYXJkLWlzRml4ZWQnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdHMuYW5pbWF0ZU9wZW5DbG9zZSAmJiB0aGlzLmdldFBsdWdpblN0YXRlKCkuaXNDbG9zaW5nKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICBpc0hpZGRlbjogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgaGFuZGxlciwgZmFsc2UpXG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfVxuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCBoYW5kbGVyLCBmYWxzZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGlzSGlkZGVuOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgICByZXNvbHZlKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmJyb3dzZXJCYWNrQnV0dG9uQ2xvc2UpIHtcbiAgICAgIHRoaXMudXBkYXRlQnJvd3Nlckhpc3RvcnkoKVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSBFU0MgYW5kIFRBQiBrZXlzIGluIG1vZGFsIGRpYWxvZ1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd25Jbk1vZGFsKVxuXG4gICAgdGhpcy51cHB5LmVtaXQoJ2Rhc2hib2FyZDptb2RhbC1vcGVuJylcblxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBjbG9zZU1vZGFsID0gKG9wdHMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG1hbnVhbENsb3NlID0gdHJ1ZSwgLy8gV2hldGhlciB0aGUgbW9kYWwgaXMgYmVpbmcgY2xvc2VkIGJ5IHRoZSB1c2VyIChgdHJ1ZWApIG9yIGJ5IG90aGVyIG1lYW5zIChlLmcuIGJyb3dzZXIgYmFjayBidXR0b24pXG4gICAgfSA9IG9wdHNcblxuICAgIGNvbnN0IHsgaXNIaWRkZW4sIGlzQ2xvc2luZyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgaWYgKGlzSGlkZGVuIHx8IGlzQ2xvc2luZykge1xuICAgICAgLy8gc2hvcnQtY2lyY3VpdCBpZiBhbmltYXRpb24gaXMgb25nb2luZ1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBjcmVhdGVQcm9taXNlKClcblxuICAgIGlmICh0aGlzLm9wdHMuZGlzYWJsZVBhZ2VTY3JvbGxXaGVuTW9kYWxPcGVuKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ3VwcHktRGFzaGJvYXJkLWlzRml4ZWQnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdHMuYW5pbWF0ZU9wZW5DbG9zZSkge1xuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGlzQ2xvc2luZzogdHJ1ZSxcbiAgICAgIH0pXG4gICAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICBpc0hpZGRlbjogdHJ1ZSxcbiAgICAgICAgICBpc0Nsb3Npbmc6IGZhbHNlLFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuc3VwZXJGb2N1cy5jYW5jZWwoKVxuICAgICAgICB0aGlzLnNhdmVkQWN0aXZlRWxlbWVudC5mb2N1cygpXG5cbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCBoYW5kbGVyLCBmYWxzZSlcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIGhhbmRsZXIsIGZhbHNlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgaXNIaWRkZW46IHRydWUsXG4gICAgICB9KVxuXG4gICAgICB0aGlzLnN1cGVyRm9jdXMuY2FuY2VsKClcbiAgICAgIHRoaXMuc2F2ZWRBY3RpdmVFbGVtZW50LmZvY3VzKClcblxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIEVTQyBhbmQgVEFCIGtleXMgaW4gbW9kYWwgZGlhbG9nXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bkluTW9kYWwpXG5cbiAgICBpZiAobWFudWFsQ2xvc2UpIHtcbiAgICAgIGlmICh0aGlzLm9wdHMuYnJvd3NlckJhY2tCdXR0b25DbG9zZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgbGF0ZXN0IGVudHJ5IGluIHRoZSBoaXN0b3J5IHN0YXRlIGlzIG91ciBtb2RhbCBuYW1lXG4gICAgICAgIGlmIChoaXN0b3J5LnN0YXRlICYmIGhpc3Rvcnkuc3RhdGVbdGhpcy5tb2RhbE5hbWVdKSB7XG4gICAgICAgICAgLy8gR28gYmFjayBpbiBoaXN0b3J5IHRvIGNsZWFyIG91dCB0aGUgZW50cnkgd2UgY3JlYXRlZCAodWx0aW1hdGVseSBjbG9zaW5nIHRoZSBtb2RhbClcbiAgICAgICAgICBoaXN0b3J5LmdvKC0xKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cHB5LmVtaXQoJ2Rhc2hib2FyZDptb2RhbC1jbG9zZWQnKVxuXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGlzTW9kYWxPcGVuID0gKCkgPT4ge1xuICAgIHJldHVybiAhdGhpcy5nZXRQbHVnaW5TdGF0ZSgpLmlzSGlkZGVuIHx8IGZhbHNlXG4gIH1cblxuICByZXF1ZXN0Q2xvc2VNb2RhbCA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5vcHRzLm9uUmVxdWVzdENsb3NlTW9kYWwpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdHMub25SZXF1ZXN0Q2xvc2VNb2RhbCgpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb3NlTW9kYWwoKVxuICB9XG5cbiAgc2V0RGFya01vZGVDYXBhYmlsaXR5ID0gKGlzRGFya01vZGVPbikgPT4ge1xuICAgIGNvbnN0IHsgY2FwYWJpbGl0aWVzIH0gPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuICAgIHRoaXMudXBweS5zZXRTdGF0ZSh7XG4gICAgICBjYXBhYmlsaXRpZXM6IHtcbiAgICAgICAgLi4uY2FwYWJpbGl0aWVzLFxuICAgICAgICBkYXJrTW9kZTogaXNEYXJrTW9kZU9uLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlU3lzdGVtRGFya01vZGVDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBpc0RhcmtNb2RlT25Ob3cgPSBldmVudC5tYXRjaGVzXG4gICAgdGhpcy51cHB5LmxvZyhgW0Rhc2hib2FyZF0gRGFyayBtb2RlIGlzICR7aXNEYXJrTW9kZU9uTm93ID8gJ29uJyA6ICdvZmYnfWApXG4gICAgdGhpcy5zZXREYXJrTW9kZUNhcGFiaWxpdHkoaXNEYXJrTW9kZU9uTm93KVxuICB9XG5cbiAgdG9nZ2xlRmlsZUNhcmQgPSAoc2hvdywgZmlsZUlEKSA9PiB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRClcbiAgICBpZiAoc2hvdykge1xuICAgICAgdGhpcy51cHB5LmVtaXQoJ2Rhc2hib2FyZDpmaWxlLWVkaXQtc3RhcnQnLCBmaWxlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwcHkuZW1pdCgnZGFzaGJvYXJkOmZpbGUtZWRpdC1jb21wbGV0ZScsIGZpbGUpXG4gICAgfVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBmaWxlQ2FyZEZvcjogc2hvdyA/IGZpbGVJRCA6IG51bGwsXG4gICAgICBhY3RpdmVPdmVybGF5VHlwZTogc2hvdyA/ICdGaWxlQ2FyZCcgOiBudWxsLFxuICAgIH0pXG4gIH1cblxuICB0b2dnbGVBZGRGaWxlc1BhbmVsID0gKHNob3cpID0+IHtcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIHNob3dBZGRGaWxlc1BhbmVsOiBzaG93LFxuICAgICAgYWN0aXZlT3ZlcmxheVR5cGU6IHNob3cgPyAnQWRkRmlsZXMnIDogbnVsbCxcbiAgICB9KVxuICB9XG5cbiAgYWRkRmlsZXMgPSAoZmlsZXMpID0+IHtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IGZpbGVzLm1hcCgoZmlsZSkgPT4gKHtcbiAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgIGRhdGE6IGZpbGUsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC8vIHBhdGggb2YgdGhlIGZpbGUgcmVsYXRpdmUgdG8gdGhlIGFuY2VzdG9yIGRpcmVjdG9yeSB0aGUgdXNlciBzZWxlY3RlZC5cbiAgICAgICAgLy8gZS5nLiAnZG9jcy9PbGQgUHJhZ3VlL2FpcmJuYi5wZGYnXG4gICAgICAgIHJlbGF0aXZlUGF0aDogZmlsZS5yZWxhdGl2ZVBhdGggfHwgbnVsbCxcbiAgICAgIH0sXG4gICAgfSkpXG5cbiAgICB0cnkge1xuICAgICAgdGhpcy51cHB5LmFkZEZpbGVzKGRlc2NyaXB0b3JzKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgfVxuICB9XG5cbiAgLy8gX19fV2h5IG1ha2UgaW5zaWRlcyBvZiBEYXNoYm9hcmQgaW52aXNpYmxlIHVudGlsIGZpcnN0IFJlc2l6ZU9ic2VydmVyIGV2ZW50IGlzIGVtaXR0ZWQ/XG4gIC8vICAgIFJlc2l6ZU9iZXJzZXJ2ZXIgZG9lc24ndCBlbWl0IHRoZSBmaXJzdCByZXNpemUgZXZlbnQgZmFzdCBlbm91Z2gsIHVzZXJzIGNhbiBzZWUgdGhlIGp1bXAgZnJvbSBvbmUgLnVwcHktc2l6ZS0tIHRvIGFub3RoZXIgKGUuZy4gaW4gU2FmYXJpKVxuICAvLyBfX19XaHkgbm90IGFwcGx5IHZpc2liaWxpdHkgcHJvcGVydHkgdG8gLnVwcHktRGFzaGJvYXJkLWlubmVyP1xuICAvLyAgICBCZWNhdXNlIGlkZWFsbHksIGFjYyB0byBzcGVjcywgUmVzaXplT2JzZXJ2ZXIgc2hvdWxkIHNlZSBpbnZpc2libGUgZWxlbWVudHMgYXMgb2Ygd2lkdGggMC4gU28gZXZlbiB0aG91Z2ggYXBwbHlpbmcgaW52aXNpYmlsaXR5IHRvIC51cHB5LURhc2hib2FyZC1pbm5lciB3b3JrcyBub3csIGl0IG1heSBub3Qgd29yayBpbiB0aGUgZnV0dXJlLlxuICBzdGFydExpc3RlbmluZ1RvUmVzaXplID0gKCkgPT4ge1xuICAgIC8vIFdhdGNoIGZvciBEYXNoYm9hcmQgY29udGFpbmVyIChgLnVwcHktRGFzaGJvYXJkLWlubmVyYCkgcmVzaXplXG4gICAgLy8gYW5kIHVwZGF0ZSBjb250YWluZXJXaWR0aC9jb250YWluZXJIZWlnaHQgaW4gcGx1Z2luIHN0YXRlIGFjY29yZGluZ2x5LlxuICAgIC8vIEVtaXRzIGZpcnN0IGV2ZW50IG9uIGluaXRpYWxpemF0aW9uLlxuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICBjb25zdCB1cHB5RGFzaGJvYXJkSW5uZXJFbCA9IGVudHJpZXNbMF1cblxuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB1cHB5RGFzaGJvYXJkSW5uZXJFbC5jb250ZW50UmVjdFxuXG4gICAgICB0aGlzLnVwcHkubG9nKGBbRGFzaGJvYXJkXSByZXNpemVkOiAke3dpZHRofSAvICR7aGVpZ2h0fWAsICdkZWJ1ZycpXG5cbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBjb250YWluZXJXaWR0aDogd2lkdGgsXG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogaGVpZ2h0LFxuICAgICAgICBhcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZTogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcudXBweS1EYXNoYm9hcmQtaW5uZXInKSlcblxuICAgIC8vIElmIFJlc2l6ZU9ic2VydmVyIGZhaWxzIHRvIGVtaXQgYW4gZXZlbnQgdGVsbGluZyB1cyB3aGF0IHNpemUgdG8gdXNlIC0gZGVmYXVsdCB0byB0aGUgbW9iaWxlIHZpZXdcbiAgICB0aGlzLm1ha2VEYXNoYm9hcmRJbnNpZGVzVmlzaWJsZUFueXdheVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IHBsdWdpblN0YXRlID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgICBjb25zdCBpc01vZGFsQW5kQ2xvc2VkID0gIXRoaXMub3B0cy5pbmxpbmUgJiYgcGx1Z2luU3RhdGUuaXNIaWRkZW5cbiAgICAgIGlmIChcbiAgICAgICAgLy8gaWYgUmVzaXplT2JzZXJ2ZXIgaGFzbid0IHlldCBmaXJlZCxcbiAgICAgICAgIXBsdWdpblN0YXRlLmFyZUluc2lkZXNSZWFkeVRvQmVWaXNpYmxlXG4gICAgICAgIC8vIGFuZCBpdCdzIG5vdCBkdWUgdG8gdGhlIG1vZGFsIGJlaW5nIGNsb3NlZFxuICAgICAgICAmJiAhaXNNb2RhbEFuZENsb3NlZFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMudXBweS5sb2coXCJbRGFzaGJvYXJkXSByZXNpemUgZXZlbnQgZGlkbid0IGZpcmUgb24gdGltZTogZGVmYXVsdGVkIHRvIG1vYmlsZSBsYXlvdXRcIiwgJ2RlYnVnJylcblxuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICBhcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LCAxMDAwKVxuICB9XG5cbiAgc3RvcExpc3RlbmluZ1RvUmVzaXplID0gKCkgPT4ge1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5tYWtlRGFzaGJvYXJkSW5zaWRlc1Zpc2libGVBbnl3YXlUaW1lb3V0KVxuICB9XG5cbiAgLy8gUmVjb3JkcyB3aGV0aGVyIHdlIGhhdmUgYmVlbiBpbnRlcmFjdGluZyB3aXRoIHVwcHkgcmlnaHQgbm93LCB3aGljaCBpcyB0aGVuIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgc3RhdGUgdXBkYXRlcyBzaG91bGQgdHJpZ2dlciBhIHJlZm9jdXNpbmcuXG4gIHJlY29yZElmRm9jdXNlZE9uVXBweVJlY2VudGx5ID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKHRoaXMuZWwuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseSA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseSA9IGZhbHNlXG4gICAgICAvLyBfX19XaHkgcnVuIHRoaXMuc3VwZXJGb2N1cy5jYW5jZWwgaGVyZSB3aGVuIGl0IGFscmVhZHkgcnVucyBpbiBzdXBlckZvY3VzT25FYWNoVXBkYXRlP1xuICAgICAgLy8gICAgQmVjYXVzZSBzdXBlckZvY3VzIGlzIGRlYm91bmNlZCwgd2hlbiB3ZSBtb3ZlIGZyb20gVXBweSB0byBzb21lIG90aGVyIGVsZW1lbnQgb24gdGhlIHBhZ2UsXG4gICAgICAvLyAgICBwcmV2aW91c2x5IHJ1biBzdXBlckZvY3VzIHNvbWV0aW1lcyBoaXRzIGFuZCBtb3ZlcyBmb2N1cyBiYWNrIHRvIFVwcHkuXG4gICAgICB0aGlzLnN1cGVyRm9jdXMuY2FuY2VsKClcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlQWxsRm9jdXNhYmxlRWxlbWVudHMgPSAoZGlzYWJsZSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzYWJsZU5vZGVzID0gdG9BcnJheSh0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoRk9DVVNBQkxFX0VMRU1FTlRTKSlcbiAgICBpZiAoZGlzYWJsZSkge1xuICAgICAgZm9jdXNhYmxlTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAvLyBzYXZlIHByZXZpb3VzIHRhYmluZGV4IGluIGEgZGF0YS1hdHRyaWJ1dGUsIHRvIHJlc3RvcmUgd2hlbiBlbmFibGluZ1xuICAgICAgICBjb25zdCBjdXJyZW50VGFiSW5kZXggPSBub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKVxuICAgICAgICBpZiAoY3VycmVudFRhYkluZGV4KSB7XG4gICAgICAgICAgbm9kZS5kYXRhc2V0LmluZXJ0VGFiaW5kZXggPSBjdXJyZW50VGFiSW5kZXhcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZm9jdXNhYmxlTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAoJ2luZXJ0VGFiaW5kZXgnIGluIG5vZGUuZGF0YXNldCkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIG5vZGUuZGF0YXNldC5pbmVydFRhYmluZGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMuZGFzaGJvYXJkSXNEaXNhYmxlZCA9IGRpc2FibGVcbiAgfVxuXG4gIHVwZGF0ZUJyb3dzZXJIaXN0b3J5ID0gKCkgPT4ge1xuICAgIC8vIEVuc3VyZSBoaXN0b3J5IHN0YXRlIGRvZXMgbm90IGFscmVhZHkgY29udGFpbiBvdXIgbW9kYWwgbmFtZSB0byBhdm9pZCBkb3VibGUtcHVzaGluZ1xuICAgIGlmICghaGlzdG9yeS5zdGF0ZSB8fCAhaGlzdG9yeS5zdGF0ZVt0aGlzLm1vZGFsTmFtZV0pIHtcbiAgICAgIC8vIFB1c2ggdG8gaGlzdG9yeSBzbyB0aGF0IHRoZSBwYWdlIGlzIG5vdCBsb3N0IG9uIGJyb3dzZXIgYmFjayBidXR0b24gcHJlc3NcbiAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHtcbiAgICAgICAgLi4uaGlzdG9yeS5zdGF0ZSxcbiAgICAgICAgW3RoaXMubW9kYWxOYW1lXTogdHJ1ZSxcbiAgICAgIH0sICcnKVxuICAgIH1cblxuICAgIC8vIExpc3RlbiBmb3IgYmFjayBidXR0b24gcHJlc3Nlc1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuaGFuZGxlUG9wU3RhdGUsIGZhbHNlKVxuICB9XG5cbiAgaGFuZGxlUG9wU3RhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAvLyBDbG9zZSB0aGUgbW9kYWwgaWYgdGhlIGhpc3Rvcnkgc3RhdGUgbm8gbG9uZ2VyIGNvbnRhaW5zIG91ciBtb2RhbCBuYW1lXG4gICAgaWYgKHRoaXMuaXNNb2RhbE9wZW4oKSAmJiAoIWV2ZW50LnN0YXRlIHx8ICFldmVudC5zdGF0ZVt0aGlzLm1vZGFsTmFtZV0pKSB7XG4gICAgICB0aGlzLmNsb3NlTW9kYWwoeyBtYW51YWxDbG9zZTogZmFsc2UgfSlcbiAgICB9XG5cbiAgICAvLyBXaGVuIHRoZSBicm93c2VyIGJhY2sgYnV0dG9uIGlzIHByZXNzZWQgYW5kIHVwcHkgaXMgbm93IHRoZSBsYXRlc3QgZW50cnkgaW4gdGhlIGhpc3RvcnkgYnV0IHRoZSBtb2RhbCBpcyBjbG9zZWQsIGZpeCB0aGUgaGlzdG9yeSBieSByZW1vdmluZyB0aGUgdXBweSBoaXN0b3J5IGVudHJ5XG4gICAgLy8gVGhpcyBvY2N1cnMgd2hlbiBhbm90aGVyIGVudHJ5IGlzIGFkZGVkIGludG8gdGhlIGhpc3Rvcnkgc3RhdGUgd2hpbGUgdGhlIG1vZGFsIGlzIG9wZW4sIGFuZCB0aGVuIHRoZSBtb2RhbCBnZXRzIG1hbnVhbGx5IGNsb3NlZFxuICAgIC8vIFNvbHZlcyBQUiAjNTc1IChodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9wdWxsLzU3NSlcbiAgICBpZiAoIXRoaXMuaXNNb2RhbE9wZW4oKSAmJiBldmVudC5zdGF0ZSAmJiBldmVudC5zdGF0ZVt0aGlzLm1vZGFsTmFtZV0pIHtcbiAgICAgIGhpc3RvcnkuZ28oLTEpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlS2V5RG93bkluTW9kYWwgPSAoZXZlbnQpID0+IHtcbiAgICAvLyBjbG9zZSBtb2RhbCBvbiBlc2Mga2V5IHByZXNzXG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ19LRVkpIHRoaXMucmVxdWVzdENsb3NlTW9kYWwoZXZlbnQpXG4gICAgLy8gdHJhcCBmb2N1cyBvbiB0YWIga2V5IHByZXNzXG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IFRBQl9LRVkpIHRyYXBGb2N1cy5mb3JNb2RhbChldmVudCwgdGhpcy5nZXRQbHVnaW5TdGF0ZSgpLmFjdGl2ZU92ZXJsYXlUeXBlLCB0aGlzLmVsKVxuICB9XG5cbiAgaGFuZGxlQ2xpY2tPdXRzaWRlID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLm9wdHMuY2xvc2VNb2RhbE9uQ2xpY2tPdXRzaWRlKSB0aGlzLnJlcXVlc3RDbG9zZU1vZGFsKClcbiAgfVxuXG4gIGhhbmRsZVBhc3RlID0gKGV2ZW50KSA9PiB7XG4gICAgLy8gMS4gTGV0IGFueSBhY3F1aXJlciBwbHVnaW4gKFVybC9XZWJjYW0vZXRjLikgaGFuZGxlIHBhc3RlcyB0byB0aGUgcm9vdFxuICAgIHRoaXMudXBweS5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICBpZiAocGx1Z2luLnR5cGUgPT09ICdhY3F1aXJlcicpIHtcbiAgICAgICAgLy8gRXZlcnkgUGx1Z2luIHdpdGggLnR5cGUgYWNxdWlyZXIgY2FuIGRlZmluZSBoYW5kbGVSb290UGFzdGUoZXZlbnQpXG4gICAgICAgIHBsdWdpbi5oYW5kbGVSb290UGFzdGUgJiYgcGx1Z2luLmhhbmRsZVJvb3RQYXN0ZShldmVudClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gMi4gQWRkIGFsbCBkcm9wcGVkIGZpbGVzXG4gICAgY29uc3QgZmlsZXMgPSB0b0FycmF5KGV2ZW50LmNsaXBib2FyZERhdGEuZmlsZXMpXG4gICAgdGhpcy5hZGRGaWxlcyhmaWxlcylcbiAgfVxuXG4gIGhhbmRsZUlucHV0Q2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGNvbnN0IGZpbGVzID0gdG9BcnJheShldmVudC50YXJnZXQuZmlsZXMpXG4gICAgdGhpcy5hZGRGaWxlcyhmaWxlcylcbiAgfVxuXG4gIGhhbmRsZURyYWdPdmVyID0gKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBpZiAodGhpcy5vcHRzLmRpc2FibGVkIHx8IHRoaXMub3B0cy5kaXNhYmxlTG9jYWxGaWxlcykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMS4gQWRkIGEgc21hbGwgKCspIGljb24gb24gZHJvcFxuICAgIC8vIChhbmQgcHJldmVudCBicm93c2VycyBmcm9tIGludGVycHJldGluZyB0aGlzIGFzIGZpbGVzIGJlaW5nIF9tb3ZlZF8gaW50byB0aGUgYnJvd3NlciwgaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzLzE5NzgpXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSdcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0KVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyBpc0RyYWdnaW5nT3ZlcjogdHJ1ZSB9KVxuICB9XG5cbiAgaGFuZGxlRHJhZ0xlYXZlID0gKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBpZiAodGhpcy5vcHRzLmRpc2FibGVkIHx8IHRoaXMub3B0cy5kaXNhYmxlTG9jYWxGaWxlcykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVtb3ZlRHJhZ092ZXJDbGFzc1RpbWVvdXQpXG4gICAgLy8gVGltZW91dCBhZ2FpbnN0IGZsaWNrZXJpbmcsIHRoaXMgc29sdXRpb24gaXMgdGFrZW4gZnJvbSBkcmFnLWRyb3AgbGlicmFyeS4gU29sdXRpb24gd2l0aCAncG9pbnRlci1ldmVudHM6IG5vbmUnIGRpZG4ndCB3b3JrIGFjcm9zcyBicm93c2Vycy5cbiAgICB0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgaXNEcmFnZ2luZ092ZXI6IGZhbHNlIH0pXG4gICAgfSwgNTApXG4gIH1cblxuICBoYW5kbGVEcm9wID0gKGV2ZW50LCBkcm9wQ2F0ZWdvcnkpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGlmICh0aGlzLm9wdHMuZGlzYWJsZWQgfHwgdGhpcy5vcHRzLmRpc2FibGVMb2NhbEZpbGVzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dClcblxuICAgIC8vIDIuIFJlbW92ZSBkcmFnb3ZlciBjbGFzc1xuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyBpc0RyYWdnaW5nT3ZlcjogZmFsc2UgfSlcblxuICAgIC8vIDMuIExldCBhbnkgYWNxdWlyZXIgcGx1Z2luIChVcmwvV2ViY2FtL2V0Yy4pIGhhbmRsZSBkcm9wcyB0byB0aGUgcm9vdFxuICAgIHRoaXMudXBweS5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICBpZiAocGx1Z2luLnR5cGUgPT09ICdhY3F1aXJlcicpIHtcbiAgICAgICAgLy8gRXZlcnkgUGx1Z2luIHdpdGggLnR5cGUgYWNxdWlyZXIgY2FuIGRlZmluZSBoYW5kbGVSb290RHJvcChldmVudClcbiAgICAgICAgcGx1Z2luLmhhbmRsZVJvb3REcm9wICYmIHBsdWdpbi5oYW5kbGVSb290RHJvcChldmVudClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gNC4gQWRkIGFsbCBkcm9wcGVkIGZpbGVzXG4gICAgbGV0IGV4ZWN1dGVkRHJvcEVycm9yT25jZSA9IGZhbHNlXG4gICAgY29uc3QgbG9nRHJvcEVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKGVycm9yLCAnZXJyb3InKVxuXG4gICAgICAvLyBJbiBwcmFjdGljZSBhbGwgZHJvcCBlcnJvcnMgYXJlIG1vc3QgbGlrZWx5IHRoZSBzYW1lLCBzbyBsZXQncyBqdXN0IHNob3cgb25lIHRvIGF2b2lkIG92ZXJ3aGVsbWluZyB0aGUgdXNlclxuICAgICAgaWYgKCFleGVjdXRlZERyb3BFcnJvck9uY2UpIHtcbiAgICAgICAgdGhpcy51cHB5LmluZm8oZXJyb3IubWVzc2FnZSwgJ2Vycm9yJylcbiAgICAgICAgZXhlY3V0ZWREcm9wRXJyb3JPbmNlID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGdldERyb3BwZWRGaWxlcyhldmVudC5kYXRhVHJhbnNmZXIsIHsgbG9nRHJvcEVycm9yIH0pXG4gICAgICAudGhlbigoZmlsZXMpID0+IHtcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKCdbRGFzaGJvYXJkXSBGaWxlcyB3ZXJlIGRyb3BwZWQnKVxuICAgICAgICAgIHRoaXMuYWRkRmlsZXMoZmlsZXMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICBoYW5kbGVSZXF1ZXN0VGh1bWJuYWlsID0gKGZpbGUpID0+IHtcbiAgICBpZiAoIXRoaXMub3B0cy53YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZCkge1xuICAgICAgdGhpcy51cHB5LmVtaXQoJ3RodW1ibmFpbDpyZXF1ZXN0JywgZmlsZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2UgY2FuY2VsIHRodW1ibmFpbCByZXF1ZXN0cyB3aGVuIGEgZmlsZSBpdGVtIGNvbXBvbmVudCB1bm1vdW50cyB0byBhdm9pZCBjbG9nZ2luZyB1cCB0aGUgcXVldWUgd2hlbiB0aGUgdXNlciBzY3JvbGxzIHBhc3QgbWFueSBlbGVtZW50cy5cbiAgICovXG4gIGhhbmRsZUNhbmNlbFRodW1ibmFpbCA9IChmaWxlKSA9PiB7XG4gICAgaWYgKCF0aGlzLm9wdHMud2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQpIHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCd0aHVtYm5haWw6Y2FuY2VsJywgZmlsZSlcbiAgICB9XG4gIH1cblxuICBoYW5kbGVLZXlEb3duSW5JbmxpbmUgPSAoZXZlbnQpID0+IHtcbiAgICAvLyBUcmFwIGZvY3VzIG9uIHRhYiBrZXkgcHJlc3MuXG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IFRBQl9LRVkpIHRyYXBGb2N1cy5mb3JJbmxpbmUoZXZlbnQsIHRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5hY3RpdmVPdmVybGF5VHlwZSwgdGhpcy5lbClcbiAgfVxuXG4gIC8vIF9fX1doeSBkbyB3ZSBsaXN0ZW4gdG8gdGhlICdwYXN0ZScgZXZlbnQgb24gYSBkb2N1bWVudCBpbnN0ZWFkIG9mIG9uUGFzdGU9e3Byb3BzLmhhbmRsZVBhc3RlfSBwcm9wLCBvciB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJyk/XG4gIC8vICAgIEJlY2F1c2UgKGF0IGxlYXN0KSBDaHJvbWUgZG9lc24ndCBoYW5kbGUgcGFzdGUgaWYgZm9jdXMgaXMgb24gc29tZSBidXR0b24sIGUuZy4gJ015IERldmljZScuXG4gIC8vICAgID0+IFRoZXJlZm9yZSwgdGhlIGJlc3Qgb3B0aW9uIGlzIHRvIGxpc3RlbiB0byBhbGwgJ3Bhc3RlJyBldmVudHMsIGFuZCBvbmx5IHJlYWN0IHRvIHRoZW0gd2hlbiB3ZSBhcmUgZm9jdXNlZCBvbiBvdXIgcGFydGljdWxhciBVcHB5IGluc3RhbmNlLlxuICAvLyBfX19XaHkgZG8gd2Ugc3RpbGwgbmVlZCBvblBhc3RlPXtwcm9wcy5oYW5kbGVQYXN0ZX0gZm9yIHRoZSBEYXNoYm9hcmRVaT9cbiAgLy8gICAgQmVjYXVzZSBpZiB3ZSBjbGljayBvbiB0aGUgJ0Ryb3AgZmlsZXMgaGVyZScgY2FwdGlvbiBlLmcuLCBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgd2lsbCBiZSAnYm9keScuIFdoaWNoIG1lYW5zIG91ciBzdGFuZGFyZCBkZXRlcm1pbmF0aW9uIG9mIHdoZXRoZXIgd2UncmUgcGFzdGluZyBpbnRvIG91ciBVcHB5IGluc3RhbmNlIHdvbid0IHdvcmsuXG4gIC8vICAgID0+IFRoZXJlZm9yZSwgd2UgbmVlZCBhIHRyYWRpdGlvbmFsIG9uUGFzdGU9e3Byb3BzLmhhbmRsZVBhc3RlfSBoYW5kbGVyIHRvby5cbiAgaGFuZGxlUGFzdGVPbkJvZHkgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBpc0ZvY3VzSW5PdmVybGF5ID0gdGhpcy5lbC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgIGlmIChpc0ZvY3VzSW5PdmVybGF5KSB7XG4gICAgICB0aGlzLmhhbmRsZVBhc3RlKGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNvbXBsZXRlID0gKHsgZmFpbGVkIH0pID0+IHtcbiAgICBpZiAodGhpcy5vcHRzLmNsb3NlQWZ0ZXJGaW5pc2ggJiYgZmFpbGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gQWxsIHVwbG9hZHMgYXJlIGRvbmVcbiAgICAgIHRoaXMucmVxdWVzdENsb3NlTW9kYWwoKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNhbmNlbFJlc3RvcmUgPSAoKSA9PiB7XG4gICAgdGhpcy51cHB5LmVtaXQoJ3Jlc3RvcmUtY2FuY2VsZWQnKVxuICB9XG5cbiAgX29wZW5GaWxlRWRpdG9yV2hlbkZpbGVzQWRkZWQgPSAoZmlsZXMpID0+IHtcbiAgICBjb25zdCBmaXJzdEZpbGUgPSBmaWxlc1swXVxuICAgIGlmICh0aGlzLmNhbkVkaXRGaWxlKGZpcnN0RmlsZSkpIHtcbiAgICAgIHRoaXMub3BlbkZpbGVFZGl0b3IoZmlyc3RGaWxlKVxuICAgIH1cbiAgfVxuXG4gIGluaXRFdmVudHMgPSAoKSA9PiB7XG4gICAgLy8gTW9kYWwgb3BlbiBidXR0b25cbiAgICBpZiAodGhpcy5vcHRzLnRyaWdnZXIgJiYgIXRoaXMub3B0cy5pbmxpbmUpIHtcbiAgICAgIGNvbnN0IHNob3dNb2RhbFRyaWdnZXIgPSBmaW5kQWxsRE9NRWxlbWVudHModGhpcy5vcHRzLnRyaWdnZXIpXG4gICAgICBpZiAoc2hvd01vZGFsVHJpZ2dlcikge1xuICAgICAgICBzaG93TW9kYWxUcmlnZ2VyLmZvckVhY2godHJpZ2dlciA9PiB0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vcGVuTW9kYWwpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cHB5LmxvZygnRGFzaGJvYXJkIG1vZGFsIHRyaWdnZXIgbm90IGZvdW5kLiBNYWtlIHN1cmUgYHRyaWdnZXJgIGlzIHNldCBpbiBEYXNoYm9hcmQgb3B0aW9ucywgdW5sZXNzIHlvdSBhcmUgcGxhbm5pbmcgdG8gY2FsbCBgZGFzaGJvYXJkLm9wZW5Nb2RhbCgpYCBtZXRob2QgeW91cnNlbGYnLCAnd2FybmluZycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydExpc3RlbmluZ1RvUmVzaXplKClcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIHRoaXMuaGFuZGxlUGFzdGVPbkJvZHkpXG5cbiAgICB0aGlzLnVwcHkub24oJ3BsdWdpbi1yZW1vdmUnLCB0aGlzLnJlbW92ZVRhcmdldClcbiAgICB0aGlzLnVwcHkub24oJ2ZpbGUtYWRkZWQnLCB0aGlzLmhpZGVBbGxQYW5lbHMpXG4gICAgdGhpcy51cHB5Lm9uKCdkYXNoYm9hcmQ6bW9kYWwtY2xvc2VkJywgdGhpcy5oaWRlQWxsUGFuZWxzKVxuICAgIHRoaXMudXBweS5vbignZmlsZS1lZGl0b3I6Y29tcGxldGUnLCB0aGlzLmhpZGVBbGxQYW5lbHMpXG4gICAgdGhpcy51cHB5Lm9uKCdjb21wbGV0ZScsIHRoaXMuaGFuZGxlQ29tcGxldGUpXG5cbiAgICAvLyBfX19XaHkgZmlyZSBvbiBjYXB0dXJlP1xuICAgIC8vICAgIEJlY2F1c2UgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseSBuZWVkcyB0byBjaGFuZ2UgYmVmb3JlIG9uVXBkYXRlKCkgZmlyZXMuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlY29yZElmRm9jdXNlZE9uVXBweVJlY2VudGx5LCB0cnVlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5yZWNvcmRJZkZvY3VzZWRPblVwcHlSZWNlbnRseSwgdHJ1ZSlcblxuICAgIGlmICh0aGlzLm9wdHMuaW5saW5lKSB7XG4gICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd25JbklubGluZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmF1dG9PcGVuRmlsZUVkaXRvcikge1xuICAgICAgdGhpcy51cHB5Lm9uKCdmaWxlcy1hZGRlZCcsIHRoaXMuX29wZW5GaWxlRWRpdG9yV2hlbkZpbGVzQWRkZWQpXG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlRXZlbnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IHNob3dNb2RhbFRyaWdnZXIgPSBmaW5kQWxsRE9NRWxlbWVudHModGhpcy5vcHRzLnRyaWdnZXIpXG4gICAgaWYgKCF0aGlzLm9wdHMuaW5saW5lICYmIHNob3dNb2RhbFRyaWdnZXIpIHtcbiAgICAgIHNob3dNb2RhbFRyaWdnZXIuZm9yRWFjaCh0cmlnZ2VyID0+IHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9wZW5Nb2RhbCkpXG4gICAgfVxuXG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nVG9SZXNpemUoKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgdGhpcy5oYW5kbGVQYXN0ZU9uQm9keSlcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuaGFuZGxlUG9wU3RhdGUsIGZhbHNlKVxuICAgIHRoaXMudXBweS5vZmYoJ3BsdWdpbi1yZW1vdmUnLCB0aGlzLnJlbW92ZVRhcmdldClcbiAgICB0aGlzLnVwcHkub2ZmKCdmaWxlLWFkZGVkJywgdGhpcy5oaWRlQWxsUGFuZWxzKVxuICAgIHRoaXMudXBweS5vZmYoJ2Rhc2hib2FyZDptb2RhbC1jbG9zZWQnLCB0aGlzLmhpZGVBbGxQYW5lbHMpXG4gICAgdGhpcy51cHB5Lm9mZignZmlsZS1lZGl0b3I6Y29tcGxldGUnLCB0aGlzLmhpZGVBbGxQYW5lbHMpXG4gICAgdGhpcy51cHB5Lm9mZignY29tcGxldGUnLCB0aGlzLmhhbmRsZUNvbXBsZXRlKVxuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlY29yZElmRm9jdXNlZE9uVXBweVJlY2VudGx5KVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5yZWNvcmRJZkZvY3VzZWRPblVwcHlSZWNlbnRseSlcblxuICAgIGlmICh0aGlzLm9wdHMuaW5saW5lKSB7XG4gICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd25JbklubGluZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmF1dG9PcGVuRmlsZUVkaXRvcikge1xuICAgICAgdGhpcy51cHB5Lm9mZignZmlsZXMtYWRkZWQnLCB0aGlzLl9vcGVuRmlsZUVkaXRvcldoZW5GaWxlc0FkZGVkKVxuICAgIH1cbiAgfVxuXG4gIHN1cGVyRm9jdXNPbkVhY2hVcGRhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgaXNGb2N1c0luVXBweSA9IHRoaXMuZWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICAvLyBXaGVuIGZvY3VzIGlzIGxvc3Qgb24gdGhlIHBhZ2UgKD09IGZvY3VzIGlzIG9uIGJvZHkgZm9yIG1vc3QgYnJvd3NlcnMsIG9yIGZvY3VzIGlzIG51bGwgZm9yIElFMTEpXG4gICAgY29uc3QgaXNGb2N1c05vd2hlcmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IG51bGxcbiAgICBjb25zdCBpc0luZm9ybWVySGlkZGVuID0gdGhpcy51cHB5LmdldFN0YXRlKCkuaW5mby5pc0hpZGRlblxuICAgIGNvbnN0IGlzTW9kYWwgPSAhdGhpcy5vcHRzLmlubGluZVxuXG4gICAgaWYgKFxuICAgICAgLy8gSWYgdXBkYXRlIGlzIGNvbm5lY3RlZCB0byBzaG93aW5nIHRoZSBJbmZvcm1lciAtIGxldCB0aGUgc2NyZWVuIHJlYWRlciBjYWxtbHkgcmVhZCBpdC5cbiAgICAgIGlzSW5mb3JtZXJIaWRkZW5cbiAgICAgICYmIChcbiAgICAgICAgLy8gSWYgd2UgYXJlIGluIGEgbW9kYWwgLSBhbHdheXMgc3VwZXJmb2N1cyB3aXRob3V0IGNvbmNlcm4gZm9yIG90aGVyIGVsZW1lbnRzIG9uIHRoZSBwYWdlICh1c2VyIGlzIHVubGlrZWx5IHRvIHdhbnQgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgcmVzdCBvZiB0aGUgcGFnZSlcbiAgICAgICAgaXNNb2RhbFxuICAgICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBpbnNpZGUgb2YgVXBweSwgb3JcbiAgICAgICAgfHwgaXNGb2N1c0luVXBweVxuICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGZvY3VzZWQgb24gYW55dGhpbmcgQlVUIHdlIGhhdmUgYWxyZWFkeSwgYXQgbGVhc3Qgb25jZSwgZm9jdXNlZCBvbiB1cHB5XG4gICAgICAgIC8vICAgMS4gV2UgZm9jdXMgd2hlbiBpc0ZvY3VzTm93aGVyZSwgYmVjYXVzZSB3aGVuIHRoZSBlbGVtZW50IHdlIHdlcmUgZm9jdXNlZCBvbiBkaXNhcHBlYXJzIChlLmcuIGFuIG92ZXJsYXkpLCAtIGZvY3VzIGdldHMgbG9zdC4gSWYgdXNlciBpcyB0eXBpbmcgc29tZXRoaW5nIHNvbWV3aGVyZSBlbHNlIG9uIHRoZSBwYWdlLCAtIGZvY3VzIHdvbid0IGJlICdub3doZXJlJy5cbiAgICAgICAgLy8gICAyLiBXZSBvbmx5IGZvY3VzIHdoZW4gZm9jdXMgaXMgbm93aGVyZSBBTkQgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseSwgdG8gYXZvaWQgZm9jdXMganVtcHMgaWYgd2UgZG8gc29tZXRoaW5nIGVsc2Ugb24gdGhlIHBhZ2UuXG4gICAgICAgIC8vICAgW1ByYWN0aWNhbCBjaGVja10gV2l0aG91dCAnJiYgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseScsIGluIFNhZmFyaSwgaW4gaW5saW5lIG1vZGUsIHdoZW4gZmlsZSBpcyB1cGxvYWRpbmcsIC0gbmF2aWdhdGUgdmlhIHRhYiB0byB0aGUgY2hlY2tib3gsIHRyeSB0byBwcmVzcyBzcGFjZSBtdWx0aXBsZSB0aW1lcy4gRm9jdXMgd2lsbCBqdW1wIHRvIFVwcHkuXG4gICAgICAgIHx8IChpc0ZvY3VzTm93aGVyZSAmJiB0aGlzLmlmRm9jdXNlZE9uVXBweVJlY2VudGx5KVxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhpcy5zdXBlckZvY3VzKHRoaXMuZWwsIHRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5hY3RpdmVPdmVybGF5VHlwZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdXBlckZvY3VzLmNhbmNlbCgpXG4gICAgfVxuICB9XG5cbiAgYWZ0ZXJVcGRhdGUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMub3B0cy5kaXNhYmxlZCAmJiAhdGhpcy5kYXNoYm9hcmRJc0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLmRpc2FibGVBbGxGb2N1c2FibGVFbGVtZW50cyh0cnVlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZWQgJiYgdGhpcy5kYXNoYm9hcmRJc0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLmRpc2FibGVBbGxGb2N1c2FibGVFbGVtZW50cyhmYWxzZSlcbiAgICB9XG5cbiAgICB0aGlzLnN1cGVyRm9jdXNPbkVhY2hVcGRhdGUoKVxuICB9XG5cbiAgY2FuY2VsVXBsb2FkID0gKGZpbGVJRCkgPT4ge1xuICAgIHRoaXMudXBweS5yZW1vdmVGaWxlKGZpbGVJRClcbiAgfVxuXG4gIHNhdmVGaWxlQ2FyZCA9IChtZXRhLCBmaWxlSUQpID0+IHtcbiAgICB0aGlzLnVwcHkuc2V0RmlsZU1ldGEoZmlsZUlELCBtZXRhKVxuICAgIHRoaXMudG9nZ2xlRmlsZUNhcmQoZmFsc2UsIGZpbGVJRClcbiAgfVxuXG4gIF9hdHRhY2hSZW5kZXJGdW5jdGlvblRvVGFyZ2V0ID0gKHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMudXBweS5nZXRQbHVnaW4odGFyZ2V0LmlkKVxuICAgIHJldHVybiB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBpY29uOiBwbHVnaW4uaWNvbiB8fCB0aGlzLm9wdHMuZGVmYXVsdFBpY2tlckljb24sXG4gICAgICByZW5kZXI6IHBsdWdpbi5yZW5kZXIsXG4gICAgfVxuICB9XG5cbiAgX2lzVGFyZ2V0U3VwcG9ydGVkID0gKHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMudXBweS5nZXRQbHVnaW4odGFyZ2V0LmlkKVxuICAgIC8vIElmIHRoZSBwbHVnaW4gZG9lcyBub3QgcHJvdmlkZSBhIGBzdXBwb3J0ZWRgIGNoZWNrLCBhc3N1bWUgdGhlIHBsdWdpbiB3b3JrcyBldmVyeXdoZXJlLlxuICAgIGlmICh0eXBlb2YgcGx1Z2luLmlzU3VwcG9ydGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gcGx1Z2luLmlzU3VwcG9ydGVkKClcbiAgfVxuXG4gIF9nZXRBY3F1aXJlcnMgPSBtZW1vaXplKCh0YXJnZXRzKSA9PiB7XG4gICAgcmV0dXJuIHRhcmdldHNcbiAgICAgIC5maWx0ZXIodGFyZ2V0ID0+IHRhcmdldC50eXBlID09PSAnYWNxdWlyZXInICYmIHRoaXMuX2lzVGFyZ2V0U3VwcG9ydGVkKHRhcmdldCkpXG4gICAgICAubWFwKHRoaXMuX2F0dGFjaFJlbmRlckZ1bmN0aW9uVG9UYXJnZXQpXG4gIH0pXG5cbiAgX2dldFByb2dyZXNzSW5kaWNhdG9ycyA9IG1lbW9pemUoKHRhcmdldHMpID0+IHtcbiAgICByZXR1cm4gdGFyZ2V0c1xuICAgICAgLmZpbHRlcih0YXJnZXQgPT4gdGFyZ2V0LnR5cGUgPT09ICdwcm9ncmVzc2luZGljYXRvcicpXG4gICAgICAubWFwKHRoaXMuX2F0dGFjaFJlbmRlckZ1bmN0aW9uVG9UYXJnZXQpXG4gIH0pXG5cbiAgX2dldEVkaXRvcnMgPSBtZW1vaXplKCh0YXJnZXRzKSA9PiB7XG4gICAgcmV0dXJuIHRhcmdldHNcbiAgICAgIC5maWx0ZXIodGFyZ2V0ID0+IHRhcmdldC50eXBlID09PSAnZWRpdG9yJylcbiAgICAgIC5tYXAodGhpcy5fYXR0YWNoUmVuZGVyRnVuY3Rpb25Ub1RhcmdldClcbiAgfSlcblxuICByZW5kZXIgPSAoc3RhdGUpID0+IHtcbiAgICBjb25zdCBwbHVnaW5TdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IHsgZmlsZXMsIGNhcGFiaWxpdGllcywgYWxsb3dOZXdVcGxvYWQgfSA9IHN0YXRlXG5cbiAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgdG8gQ29yZSwgdG8gc2hhcmUgYmV0d2VlbiBTdGF0dXMgQmFyIGFuZCBEYXNoYm9hcmRcbiAgICAvLyAoYW5kIGFueSBvdGhlciBwbHVnaW4gdGhhdCBtaWdodCBuZWVkIGl0LCB0b28pXG4gICAgY29uc3QgbmV3RmlsZXMgPSBPYmplY3Qua2V5cyhmaWxlcykuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gIWZpbGVzW2ZpbGVdLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgICB9KVxuXG4gICAgY29uc3QgdXBsb2FkU3RhcnRlZEZpbGVzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGVzW2ZpbGVdLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgICB9KVxuXG4gICAgY29uc3QgcGF1c2VkRmlsZXMgPSBPYmplY3Qua2V5cyhmaWxlcykuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gZmlsZXNbZmlsZV0uaXNQYXVzZWRcbiAgICB9KVxuXG4gICAgY29uc3QgY29tcGxldGVGaWxlcyA9IE9iamVjdC5rZXlzKGZpbGVzKS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiBmaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZVxuICAgIH0pXG5cbiAgICBjb25zdCBlcnJvcmVkRmlsZXMgPSBPYmplY3Qua2V5cyhmaWxlcykuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gZmlsZXNbZmlsZV0uZXJyb3JcbiAgICB9KVxuXG4gICAgY29uc3QgaW5Qcm9ncmVzc0ZpbGVzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuICFmaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZVxuICAgICAgICAgICAgICYmIGZpbGVzW2ZpbGVdLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgICB9KVxuXG4gICAgY29uc3QgaW5Qcm9ncmVzc05vdFBhdXNlZEZpbGVzID0gaW5Qcm9ncmVzc0ZpbGVzLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuICFmaWxlc1tmaWxlXS5pc1BhdXNlZFxuICAgIH0pXG5cbiAgICBjb25zdCBwcm9jZXNzaW5nRmlsZXMgPSBPYmplY3Qua2V5cyhmaWxlcykuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gZmlsZXNbZmlsZV0ucHJvZ3Jlc3MucHJlcHJvY2VzcyB8fCBmaWxlc1tmaWxlXS5wcm9ncmVzcy5wb3N0cHJvY2Vzc1xuICAgIH0pXG5cbiAgICBjb25zdCBpc1VwbG9hZFN0YXJ0ZWQgPSB1cGxvYWRTdGFydGVkRmlsZXMubGVuZ3RoID4gMFxuXG4gICAgY29uc3QgaXNBbGxDb21wbGV0ZSA9IHN0YXRlLnRvdGFsUHJvZ3Jlc3MgPT09IDEwMFxuICAgICAgJiYgY29tcGxldGVGaWxlcy5sZW5ndGggPT09IE9iamVjdC5rZXlzKGZpbGVzKS5sZW5ndGhcbiAgICAgICYmIHByb2Nlc3NpbmdGaWxlcy5sZW5ndGggPT09IDBcblxuICAgIGNvbnN0IGlzQWxsRXJyb3JlZCA9IGlzVXBsb2FkU3RhcnRlZFxuICAgICAgJiYgZXJyb3JlZEZpbGVzLmxlbmd0aCA9PT0gdXBsb2FkU3RhcnRlZEZpbGVzLmxlbmd0aFxuXG4gICAgY29uc3QgaXNBbGxQYXVzZWQgPSBpblByb2dyZXNzRmlsZXMubGVuZ3RoICE9PSAwXG4gICAgICAmJiBwYXVzZWRGaWxlcy5sZW5ndGggPT09IGluUHJvZ3Jlc3NGaWxlcy5sZW5ndGhcblxuICAgIGNvbnN0IGFjcXVpcmVycyA9IHRoaXMuX2dldEFjcXVpcmVycyhwbHVnaW5TdGF0ZS50YXJnZXRzKVxuICAgIGNvbnN0IHByb2dyZXNzaW5kaWNhdG9ycyA9IHRoaXMuX2dldFByb2dyZXNzSW5kaWNhdG9ycyhwbHVnaW5TdGF0ZS50YXJnZXRzKVxuICAgIGNvbnN0IGVkaXRvcnMgPSB0aGlzLl9nZXRFZGl0b3JzKHBsdWdpblN0YXRlLnRhcmdldHMpXG5cbiAgICBsZXQgdGhlbWVcbiAgICBpZiAodGhpcy5vcHRzLnRoZW1lID09PSAnYXV0bycpIHtcbiAgICAgIHRoZW1lID0gY2FwYWJpbGl0aWVzLmRhcmtNb2RlID8gJ2RhcmsnIDogJ2xpZ2h0J1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGVtZSA9IHRoaXMub3B0cy50aGVtZVxuICAgIH1cblxuICAgIGlmIChbJ2ZpbGVzJywgJ2ZvbGRlcnMnLCAnYm90aCddLmluZGV4T2YodGhpcy5vcHRzLmZpbGVNYW5hZ2VyU2VsZWN0aW9uVHlwZSkgPCAwKSB7XG4gICAgICB0aGlzLm9wdHMuZmlsZU1hbmFnZXJTZWxlY3Rpb25UeXBlID0gJ2ZpbGVzJ1xuICAgICAgY29uc29sZS5lcnJvcihgVW5zdXBwb3J0ZWQgb3B0aW9uIGZvciBcImZpbGVNYW5hZ2VyU2VsZWN0aW9uVHlwZVwiLiBVc2luZyBkZWZhdWx0IG9mIFwiJHt0aGlzLm9wdHMuZmlsZU1hbmFnZXJTZWxlY3Rpb25UeXBlfVwiLmApXG4gICAgfVxuXG4gICAgcmV0dXJuIERhc2hib2FyZFVJKHtcbiAgICAgIHN0YXRlLFxuICAgICAgaXNIaWRkZW46IHBsdWdpblN0YXRlLmlzSGlkZGVuLFxuICAgICAgZmlsZXMsXG4gICAgICBuZXdGaWxlcyxcbiAgICAgIHVwbG9hZFN0YXJ0ZWRGaWxlcyxcbiAgICAgIGNvbXBsZXRlRmlsZXMsXG4gICAgICBlcnJvcmVkRmlsZXMsXG4gICAgICBpblByb2dyZXNzRmlsZXMsXG4gICAgICBpblByb2dyZXNzTm90UGF1c2VkRmlsZXMsXG4gICAgICBwcm9jZXNzaW5nRmlsZXMsXG4gICAgICBpc1VwbG9hZFN0YXJ0ZWQsXG4gICAgICBpc0FsbENvbXBsZXRlLFxuICAgICAgaXNBbGxFcnJvcmVkLFxuICAgICAgaXNBbGxQYXVzZWQsXG4gICAgICB0b3RhbEZpbGVDb3VudDogT2JqZWN0LmtleXMoZmlsZXMpLmxlbmd0aCxcbiAgICAgIHRvdGFsUHJvZ3Jlc3M6IHN0YXRlLnRvdGFsUHJvZ3Jlc3MsXG4gICAgICBhbGxvd05ld1VwbG9hZCxcbiAgICAgIGFjcXVpcmVycyxcbiAgICAgIHRoZW1lLFxuICAgICAgZGlzYWJsZWQ6IHRoaXMub3B0cy5kaXNhYmxlZCxcbiAgICAgIGRpc2FibGVMb2NhbEZpbGVzOiB0aGlzLm9wdHMuZGlzYWJsZUxvY2FsRmlsZXMsXG4gICAgICBkaXJlY3Rpb246IHRoaXMub3B0cy5kaXJlY3Rpb24sXG4gICAgICBhY3RpdmVQaWNrZXJQYW5lbDogcGx1Z2luU3RhdGUuYWN0aXZlUGlja2VyUGFuZWwsXG4gICAgICBzaG93RmlsZUVkaXRvcjogcGx1Z2luU3RhdGUuc2hvd0ZpbGVFZGl0b3IsXG4gICAgICBzYXZlRmlsZUVkaXRvcjogdGhpcy5zYXZlRmlsZUVkaXRvcixcbiAgICAgIGRpc2FibGVBbGxGb2N1c2FibGVFbGVtZW50czogdGhpcy5kaXNhYmxlQWxsRm9jdXNhYmxlRWxlbWVudHMsXG4gICAgICBhbmltYXRlT3BlbkNsb3NlOiB0aGlzLm9wdHMuYW5pbWF0ZU9wZW5DbG9zZSxcbiAgICAgIGlzQ2xvc2luZzogcGx1Z2luU3RhdGUuaXNDbG9zaW5nLFxuICAgICAgZ2V0UGx1Z2luOiB0aGlzLnVwcHkuZ2V0UGx1Z2luLFxuICAgICAgcHJvZ3Jlc3NpbmRpY2F0b3JzLFxuICAgICAgZWRpdG9ycyxcbiAgICAgIGF1dG9Qcm9jZWVkOiB0aGlzLnVwcHkub3B0cy5hdXRvUHJvY2VlZCxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgY2xvc2VNb2RhbDogdGhpcy5yZXF1ZXN0Q2xvc2VNb2RhbCxcbiAgICAgIGhhbmRsZUNsaWNrT3V0c2lkZTogdGhpcy5oYW5kbGVDbGlja091dHNpZGUsXG4gICAgICBoYW5kbGVJbnB1dENoYW5nZTogdGhpcy5oYW5kbGVJbnB1dENoYW5nZSxcbiAgICAgIGhhbmRsZVBhc3RlOiB0aGlzLmhhbmRsZVBhc3RlLFxuICAgICAgaW5saW5lOiB0aGlzLm9wdHMuaW5saW5lLFxuICAgICAgc2hvd1BhbmVsOiB0aGlzLnNob3dQYW5lbCxcbiAgICAgIGhpZGVBbGxQYW5lbHM6IHRoaXMuaGlkZUFsbFBhbmVscyxcbiAgICAgIGxvZzogdGhpcy51cHB5LmxvZyxcbiAgICAgIGkxOG46IHRoaXMuaTE4bixcbiAgICAgIGkxOG5BcnJheTogdGhpcy5pMThuQXJyYXksXG4gICAgICByZW1vdmVGaWxlOiB0aGlzLnVwcHkucmVtb3ZlRmlsZSxcbiAgICAgIHVwcHk6IHRoaXMudXBweSxcbiAgICAgIGluZm86IHRoaXMudXBweS5pbmZvLFxuICAgICAgbm90ZTogdGhpcy5vcHRzLm5vdGUsXG4gICAgICByZWNvdmVyZWRTdGF0ZTogc3RhdGUucmVjb3ZlcmVkU3RhdGUsXG4gICAgICBtZXRhRmllbGRzOiBwbHVnaW5TdGF0ZS5tZXRhRmllbGRzLFxuICAgICAgcmVzdW1hYmxlVXBsb2FkczogY2FwYWJpbGl0aWVzLnJlc3VtYWJsZVVwbG9hZHMgfHwgZmFsc2UsXG4gICAgICBpbmRpdmlkdWFsQ2FuY2VsbGF0aW9uOiBjYXBhYmlsaXRpZXMuaW5kaXZpZHVhbENhbmNlbGxhdGlvbixcbiAgICAgIGlzTW9iaWxlRGV2aWNlOiBjYXBhYmlsaXRpZXMuaXNNb2JpbGVEZXZpY2UsXG4gICAgICBwYXVzZVVwbG9hZDogdGhpcy51cHB5LnBhdXNlUmVzdW1lLFxuICAgICAgcmV0cnlVcGxvYWQ6IHRoaXMudXBweS5yZXRyeVVwbG9hZCxcbiAgICAgIGNhbmNlbFVwbG9hZDogdGhpcy5jYW5jZWxVcGxvYWQsXG4gICAgICBjYW5jZWxBbGw6IHRoaXMudXBweS5jYW5jZWxBbGwsXG4gICAgICBmaWxlQ2FyZEZvcjogcGx1Z2luU3RhdGUuZmlsZUNhcmRGb3IsXG4gICAgICB0b2dnbGVGaWxlQ2FyZDogdGhpcy50b2dnbGVGaWxlQ2FyZCxcbiAgICAgIHRvZ2dsZUFkZEZpbGVzUGFuZWw6IHRoaXMudG9nZ2xlQWRkRmlsZXNQYW5lbCxcbiAgICAgIHNob3dBZGRGaWxlc1BhbmVsOiBwbHVnaW5TdGF0ZS5zaG93QWRkRmlsZXNQYW5lbCxcbiAgICAgIHNhdmVGaWxlQ2FyZDogdGhpcy5zYXZlRmlsZUNhcmQsXG4gICAgICBvcGVuRmlsZUVkaXRvcjogdGhpcy5vcGVuRmlsZUVkaXRvcixcbiAgICAgIGNhbkVkaXRGaWxlOiB0aGlzLmNhbkVkaXRGaWxlLFxuICAgICAgd2lkdGg6IHRoaXMub3B0cy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5vcHRzLmhlaWdodCxcbiAgICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0OiB0aGlzLm9wdHMuc2hvd0xpbmtUb0ZpbGVVcGxvYWRSZXN1bHQsXG4gICAgICBmaWxlTWFuYWdlclNlbGVjdGlvblR5cGU6IHRoaXMub3B0cy5maWxlTWFuYWdlclNlbGVjdGlvblR5cGUsXG4gICAgICBwcm91ZGx5RGlzcGxheVBvd2VyZWRCeVVwcHk6IHRoaXMub3B0cy5wcm91ZGx5RGlzcGxheVBvd2VyZWRCeVVwcHksXG4gICAgICBoaWRlQ2FuY2VsQnV0dG9uOiB0aGlzLm9wdHMuaGlkZUNhbmNlbEJ1dHRvbixcbiAgICAgIGhpZGVSZXRyeUJ1dHRvbjogdGhpcy5vcHRzLmhpZGVSZXRyeUJ1dHRvbixcbiAgICAgIGhpZGVQYXVzZVJlc3VtZUJ1dHRvbjogdGhpcy5vcHRzLmhpZGVQYXVzZVJlc3VtZUJ1dHRvbixcbiAgICAgIHNob3dSZW1vdmVCdXR0b25BZnRlckNvbXBsZXRlOiB0aGlzLm9wdHMuc2hvd1JlbW92ZUJ1dHRvbkFmdGVyQ29tcGxldGUsXG4gICAgICBjb250YWluZXJXaWR0aDogcGx1Z2luU3RhdGUuY29udGFpbmVyV2lkdGgsXG4gICAgICBjb250YWluZXJIZWlnaHQ6IHBsdWdpblN0YXRlLmNvbnRhaW5lckhlaWdodCxcbiAgICAgIGFyZUluc2lkZXNSZWFkeVRvQmVWaXNpYmxlOiBwbHVnaW5TdGF0ZS5hcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZSxcbiAgICAgIGlzVGFyZ2V0RE9NRWw6IHRoaXMuaXNUYXJnZXRET01FbCxcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHRoaXMuZWwsXG4gICAgICBhbGxvd2VkRmlsZVR5cGVzOiB0aGlzLnVwcHkub3B0cy5yZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcyxcbiAgICAgIG1heE51bWJlck9mRmlsZXM6IHRoaXMudXBweS5vcHRzLnJlc3RyaWN0aW9ucy5tYXhOdW1iZXJPZkZpbGVzLFxuICAgICAgc2hvd1NlbGVjdGVkRmlsZXM6IHRoaXMub3B0cy5zaG93U2VsZWN0ZWRGaWxlcyxcbiAgICAgIGhhbmRsZUNhbmNlbFJlc3RvcmU6IHRoaXMuaGFuZGxlQ2FuY2VsUmVzdG9yZSxcbiAgICAgIGhhbmRsZVJlcXVlc3RUaHVtYm5haWw6IHRoaXMuaGFuZGxlUmVxdWVzdFRodW1ibmFpbCxcbiAgICAgIGhhbmRsZUNhbmNlbFRodW1ibmFpbDogdGhpcy5oYW5kbGVDYW5jZWxUaHVtYm5haWwsXG4gICAgICAvLyBkcmFnIHByb3BzXG4gICAgICBpc0RyYWdnaW5nT3ZlcjogcGx1Z2luU3RhdGUuaXNEcmFnZ2luZ092ZXIsXG4gICAgICBoYW5kbGVEcmFnT3ZlcjogdGhpcy5oYW5kbGVEcmFnT3ZlcixcbiAgICAgIGhhbmRsZURyYWdMZWF2ZTogdGhpcy5oYW5kbGVEcmFnTGVhdmUsXG4gICAgICBoYW5kbGVEcm9wOiB0aGlzLmhhbmRsZURyb3AsXG4gICAgfSlcbiAgfVxuXG4gIGRpc2NvdmVyUHJvdmlkZXJQbHVnaW5zID0gKCkgPT4ge1xuICAgIHRoaXMudXBweS5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICBpZiAocGx1Z2luICYmICFwbHVnaW4udGFyZ2V0ICYmIHBsdWdpbi5vcHRzICYmIHBsdWdpbi5vcHRzLnRhcmdldCA9PT0gdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLmFkZFRhcmdldChwbHVnaW4pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIC8vIFNldCB0aGUgdGV4dCBkaXJlY3Rpb24gaWYgdGhlIHBhZ2UgaGFzIG5vdCBkZWZpbmVkIG9uZS5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbFxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGdldFRleHREaXJlY3Rpb24oZWxlbWVudClcbiAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgZWxlbWVudC5kaXIgPSAnbHRyJ1xuICAgIH1cbiAgfVxuXG4gIGluc3RhbGwgPSAoKSA9PiB7XG4gICAgLy8gU2V0IGRlZmF1bHQgc3RhdGUgZm9yIERhc2hib2FyZFxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgaXNIaWRkZW46IHRydWUsXG4gICAgICBmaWxlQ2FyZEZvcjogbnVsbCxcbiAgICAgIGFjdGl2ZU92ZXJsYXlUeXBlOiBudWxsLFxuICAgICAgc2hvd0FkZEZpbGVzUGFuZWw6IGZhbHNlLFxuICAgICAgYWN0aXZlUGlja2VyUGFuZWw6IGZhbHNlLFxuICAgICAgc2hvd0ZpbGVFZGl0b3I6IGZhbHNlLFxuICAgICAgbWV0YUZpZWxkczogdGhpcy5vcHRzLm1ldGFGaWVsZHMsXG4gICAgICB0YXJnZXRzOiBbXSxcbiAgICAgIC8vIFdlJ2xsIG1ha2UgdGhlbSB2aXNpYmxlIG9uY2UgLmNvbnRhaW5lcldpZHRoIGlzIGRldGVybWluZWRcbiAgICAgIGFyZUluc2lkZXNSZWFkeVRvQmVWaXNpYmxlOiBmYWxzZSxcbiAgICAgIGlzRHJhZ2dpbmdPdmVyOiBmYWxzZSxcbiAgICB9KVxuXG4gICAgY29uc3QgeyBpbmxpbmUsIGNsb3NlQWZ0ZXJGaW5pc2ggfSA9IHRoaXMub3B0c1xuICAgIGlmIChpbmxpbmUgJiYgY2xvc2VBZnRlckZpbmlzaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbRGFzaGJvYXJkXSBgY2xvc2VBZnRlckZpbmlzaDogdHJ1ZWAgY2Fubm90IGJlIHVzZWQgb24gYW4gaW5saW5lIERhc2hib2FyZCwgYmVjYXVzZSBhbiBpbmxpbmUgRGFzaGJvYXJkIGNhbm5vdCBiZSBjbG9zZWQgYXQgYWxsLiBFaXRoZXIgc2V0IGBpbmxpbmU6IGZhbHNlYCwgb3IgZGlzYWJsZSB0aGUgYGNsb3NlQWZ0ZXJGaW5pc2hgIG9wdGlvbi4nKVxuICAgIH1cblxuICAgIGNvbnN0IHsgYWxsb3dNdWx0aXBsZVVwbG9hZHMgfSA9IHRoaXMudXBweS5vcHRzXG4gICAgaWYgKGFsbG93TXVsdGlwbGVVcGxvYWRzICYmIGNsb3NlQWZ0ZXJGaW5pc2gpIHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tEYXNoYm9hcmRdIFdoZW4gdXNpbmcgYGNsb3NlQWZ0ZXJGaW5pc2hgLCB3ZSByZWNvbW1lbmRlZCBzZXR0aW5nIHRoZSBgYWxsb3dNdWx0aXBsZVVwbG9hZHNgIG9wdGlvbiB0byBgZmFsc2VgIGluIHRoZSBVcHB5IGNvbnN0cnVjdG9yLiBTZWUgaHR0cHM6Ly91cHB5LmlvL2RvY3MvdXBweS8jYWxsb3dNdWx0aXBsZVVwbG9hZHMtdHJ1ZScsICd3YXJuaW5nJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuXG4gICAgY29uc3QgcGx1Z2lucyA9IHRoaXMub3B0cy5wbHVnaW5zIHx8IFtdXG4gICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW5JRCkgPT4ge1xuICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy51cHB5LmdldFBsdWdpbihwbHVnaW5JRClcbiAgICAgIGlmIChwbHVnaW4pIHtcbiAgICAgICAgcGx1Z2luLm1vdW50KHRoaXMsIHBsdWdpbilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZVN0YXR1c0Jhcikge1xuICAgICAgdGhpcy51cHB5LnVzZShTdGF0dXNCYXIsIHtcbiAgICAgICAgaWQ6IGAke3RoaXMuaWR9OlN0YXR1c0JhcmAsXG4gICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgaGlkZVVwbG9hZEJ1dHRvbjogdGhpcy5vcHRzLmhpZGVVcGxvYWRCdXR0b24sXG4gICAgICAgIGhpZGVSZXRyeUJ1dHRvbjogdGhpcy5vcHRzLmhpZGVSZXRyeUJ1dHRvbixcbiAgICAgICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uOiB0aGlzLm9wdHMuaGlkZVBhdXNlUmVzdW1lQnV0dG9uLFxuICAgICAgICBoaWRlQ2FuY2VsQnV0dG9uOiB0aGlzLm9wdHMuaGlkZUNhbmNlbEJ1dHRvbixcbiAgICAgICAgc2hvd1Byb2dyZXNzRGV0YWlsczogdGhpcy5vcHRzLnNob3dQcm9ncmVzc0RldGFpbHMsXG4gICAgICAgIGhpZGVBZnRlckZpbmlzaDogdGhpcy5vcHRzLmhpZGVQcm9ncmVzc0FmdGVyRmluaXNoLFxuICAgICAgICBsb2NhbGU6IHRoaXMub3B0cy5sb2NhbGUsXG4gICAgICAgIGRvbmVCdXR0b25IYW5kbGVyOiB0aGlzLm9wdHMuZG9uZUJ1dHRvbkhhbmRsZXIsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRzLmRpc2FibGVJbmZvcm1lcikge1xuICAgICAgdGhpcy51cHB5LnVzZShJbmZvcm1lciwge1xuICAgICAgICBpZDogYCR7dGhpcy5pZH06SW5mb3JtZXJgLFxuICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRzLmRpc2FibGVUaHVtYm5haWxHZW5lcmF0b3IpIHtcbiAgICAgIHRoaXMudXBweS51c2UoVGh1bWJuYWlsR2VuZXJhdG9yLCB7XG4gICAgICAgIGlkOiBgJHt0aGlzLmlkfTpUaHVtYm5haWxHZW5lcmF0b3JgLFxuICAgICAgICB0aHVtYm5haWxXaWR0aDogdGhpcy5vcHRzLnRodW1ibmFpbFdpZHRoLFxuICAgICAgICB0aHVtYm5haWxUeXBlOiB0aGlzLm9wdHMudGh1bWJuYWlsVHlwZSxcbiAgICAgICAgd2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQ6IHRoaXMub3B0cy53YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZCxcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgYmxvY2sgb24gdGh1bWJuYWlscywgd2UgY2FuIGxhemlseSBnZW5lcmF0ZSB0aGVtXG4gICAgICAgIGxhenk6ICF0aGlzLm9wdHMud2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQsXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIERhcmsgTW9kZSAvIHRoZW1lXG4gICAgdGhpcy5kYXJrTW9kZU1lZGlhUXVlcnkgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm1hdGNoTWVkaWEpXG4gICAgICA/IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJylcbiAgICAgIDogbnVsbFxuXG4gICAgY29uc3QgaXNEYXJrTW9kZU9uRnJvbVRoZVN0YXJ0ID0gdGhpcy5kYXJrTW9kZU1lZGlhUXVlcnkgPyB0aGlzLmRhcmtNb2RlTWVkaWFRdWVyeS5tYXRjaGVzIDogZmFsc2VcbiAgICB0aGlzLnVwcHkubG9nKGBbRGFzaGJvYXJkXSBEYXJrIG1vZGUgaXMgJHtpc0RhcmtNb2RlT25Gcm9tVGhlU3RhcnQgPyAnb24nIDogJ29mZid9YClcbiAgICB0aGlzLnNldERhcmtNb2RlQ2FwYWJpbGl0eShpc0RhcmtNb2RlT25Gcm9tVGhlU3RhcnQpXG5cbiAgICBpZiAodGhpcy5vcHRzLnRoZW1lID09PSAnYXV0bycpIHtcbiAgICAgIHRoaXMuZGFya01vZGVNZWRpYVF1ZXJ5LmFkZExpc3RlbmVyKHRoaXMuaGFuZGxlU3lzdGVtRGFya01vZGVDaGFuZ2UpXG4gICAgfVxuXG4gICAgdGhpcy5kaXNjb3ZlclByb3ZpZGVyUGx1Z2lucygpXG4gICAgdGhpcy5pbml0RXZlbnRzKClcbiAgfVxuXG4gIHVuaW5zdGFsbCA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMub3B0cy5kaXNhYmxlSW5mb3JtZXIpIHtcbiAgICAgIGNvbnN0IGluZm9ybWVyID0gdGhpcy51cHB5LmdldFBsdWdpbihgJHt0aGlzLmlkfTpJbmZvcm1lcmApXG4gICAgICAvLyBDaGVja2luZyBpZiB0aGlzIHBsdWdpbiBleGlzdHMsIGluIGNhc2UgaXQgd2FzIHJlbW92ZWQgYnkgdXBweS1jb3JlXG4gICAgICAvLyBiZWZvcmUgdGhlIERhc2hib2FyZCB3YXMuXG4gICAgICBpZiAoaW5mb3JtZXIpIHRoaXMudXBweS5yZW1vdmVQbHVnaW4oaW5mb3JtZXIpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZVN0YXR1c0Jhcikge1xuICAgICAgY29uc3Qgc3RhdHVzQmFyID0gdGhpcy51cHB5LmdldFBsdWdpbihgJHt0aGlzLmlkfTpTdGF0dXNCYXJgKVxuICAgICAgaWYgKHN0YXR1c0JhcikgdGhpcy51cHB5LnJlbW92ZVBsdWdpbihzdGF0dXNCYXIpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZVRodW1ibmFpbEdlbmVyYXRvcikge1xuICAgICAgY29uc3QgdGh1bWJuYWlsID0gdGhpcy51cHB5LmdldFBsdWdpbihgJHt0aGlzLmlkfTpUaHVtYm5haWxHZW5lcmF0b3JgKVxuICAgICAgaWYgKHRodW1ibmFpbCkgdGhpcy51cHB5LnJlbW92ZVBsdWdpbih0aHVtYm5haWwpXG4gICAgfVxuXG4gICAgY29uc3QgcGx1Z2lucyA9IHRoaXMub3B0cy5wbHVnaW5zIHx8IFtdXG4gICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW5JRCkgPT4ge1xuICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy51cHB5LmdldFBsdWdpbihwbHVnaW5JRClcbiAgICAgIGlmIChwbHVnaW4pIHBsdWdpbi51bm1vdW50KClcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMub3B0cy50aGVtZSA9PT0gJ2F1dG8nKSB7XG4gICAgICB0aGlzLmRhcmtNb2RlTWVkaWFRdWVyeS5yZW1vdmVMaXN0ZW5lcih0aGlzLmhhbmRsZVN5c3RlbURhcmtNb2RlQ2hhbmdlKVxuICAgIH1cblxuICAgIHRoaXMudW5tb3VudCgpXG4gICAgdGhpcy5yZW1vdmVFdmVudHMoKVxuICB9XG59XG4iLCIvKipcbiAqIENvcGllcyB0ZXh0IHRvIGNsaXBib2FyZCBieSBjcmVhdGluZyBhbiBhbG1vc3QgaW52aXNpYmxlIHRleHRhcmVhLFxuICogYWRkaW5nIHRleHQgdGhlcmUsIHRoZW4gcnVubmluZyBleGVjQ29tbWFuZCgnY29weScpLlxuICogRmFsbHMgYmFjayB0byBwcm9tcHQoKSB3aGVuIHRoZSBlYXN5IHdheSBmYWlscyAoaGVsbG8sIFNhZmFyaSEpXG4gKiBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMwODEwMzIyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRUb0NvcHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBmYWxsYmFja1N0cmluZ1xuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29weVRvQ2xpcGJvYXJkICh0ZXh0VG9Db3B5LCBmYWxsYmFja1N0cmluZykge1xuICBmYWxsYmFja1N0cmluZyA9IGZhbGxiYWNrU3RyaW5nIHx8ICdDb3B5IHRoZSBVUkwgYmVsb3cnXG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgdGV4dEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpXG4gICAgdGV4dEFyZWEuc2V0QXR0cmlidXRlKCdzdHlsZScsIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHdpZHRoOiAnMmVtJyxcbiAgICAgIGhlaWdodDogJzJlbScsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICBib3hTaGFkb3c6ICdub25lJyxcbiAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsXG4gICAgfSlcblxuICAgIHRleHRBcmVhLnZhbHVlID0gdGV4dFRvQ29weVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGV4dEFyZWEpXG4gICAgdGV4dEFyZWEuc2VsZWN0KClcblxuICAgIGNvbnN0IG1hZ2ljQ29weUZhaWxlZCA9ICgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGV4dEFyZWEpXG4gICAgICB3aW5kb3cucHJvbXB0KGZhbGxiYWNrU3RyaW5nLCB0ZXh0VG9Db3B5KVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpXG4gICAgICBpZiAoIXN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgcmV0dXJuIG1hZ2ljQ29weUZhaWxlZCgnY29weSBjb21tYW5kIHVuYXZhaWxhYmxlJylcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGV4dEFyZWEpXG4gICAgICByZXR1cm4gcmVzb2x2ZSgpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRleHRBcmVhKVxuICAgICAgcmV0dXJuIG1hZ2ljQ29weUZhaWxlZChlcnIpXG4gICAgfVxuICB9KVxufVxuIiwiY29uc3QgZGVib3VuY2UgPSByZXF1aXJlKCdsb2Rhc2guZGVib3VuY2UnKVxuY29uc3QgRk9DVVNBQkxFX0VMRU1FTlRTID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL0ZPQ1VTQUJMRV9FTEVNRU5UUycpXG5jb25zdCBnZXRBY3RpdmVPdmVybGF5RWwgPSByZXF1aXJlKCcuL2dldEFjdGl2ZU92ZXJsYXlFbCcpXG5cbi8qXG4gIEZvY3VzZXMgb24gc29tZSBlbGVtZW50IGluIHRoZSBjdXJyZW50bHkgdG9wbW9zdCBvdmVybGF5LlxuXG4gIDEuIElmIHRoZXJlIGFyZSBzb21lIFtkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXSBlbGVtZW50cyByZW5kZXJlZCBhbHJlYWR5IC0gZm9jdXNlcyBvbiB0aGUgZmlyc3Qgc3VwZXJmb2N1c2FibGUgZWxlbWVudCwgYW5kIGxlYXZlcyBmb2N1cyB1cCB0byB0aGUgY29udHJvbCBvZiBhIHVzZXIgKHVudGlsIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQgZGlzYXBwZWFycyBmcm9tIHRoZSBzY3JlZW4gW3doaWNoIGNhbiBoYXBwZW4gd2hlbiBvdmVybGF5IGNoYW5nZXMsIG9yLCBlLmcuLCB3aGVuIHdlIGNsaWNrIG9uIGEgZm9sZGVyIGluIGdvb2dsZWRyaXZlXSkuXG4gIDIuIElmIHRoZXJlIGFyZSBubyBbZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZV0gZWxlbWVudHMgeWV0IChvciBldmVyKSAtIGZvY3VzZXMgb24gdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50LCBidXQgc3dpdGNoZXMgZm9jdXMgaWYgc3VwZXJmb2N1c2FibGUgZWxlbWVudHMgYXBwZWFyIG9uIG5leHQgcmVuZGVyLlxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlU3VwZXJGb2N1cyAoKSB7XG4gIGxldCBsYXN0Rm9jdXNXYXNPblN1cGVyRm9jdXNhYmxlRWwgPSBmYWxzZVxuXG4gIGNvbnN0IHN1cGVyRm9jdXMgPSAoZGFzaGJvYXJkRWwsIGFjdGl2ZU92ZXJsYXlUeXBlKSA9PiB7XG4gICAgY29uc3Qgb3ZlcmxheUVsID0gZ2V0QWN0aXZlT3ZlcmxheUVsKGRhc2hib2FyZEVsLCBhY3RpdmVPdmVybGF5VHlwZSlcblxuICAgIGNvbnN0IGlzRm9jdXNJbk92ZXJsYXkgPSBvdmVybGF5RWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICAvLyBJZiBmb2N1cyBpcyBhbHJlYWR5IGluIHRoZSB0b3Btb3N0IG92ZXJsYXksIEFORCBvbiBsYXN0IHVwZGF0ZSB3ZSBmb2N1c2VkIG9uIHRoZSBzdXBlcmZvY3VzYWJsZSBlbGVtZW50IC0gdGhlbiBsZWF2ZSBmb2N1cyB1cCB0byB0aGUgdXNlci5cbiAgICAvLyBbUHJhY3RpY2FsIGNoZWNrXSB3aXRob3V0IHRoaXMgbGluZSwgdHlwaW5nIGluIHRoZSBzZWFyY2ggaW5wdXQgaW4gZ29vZ2xlZHJpdmUgb3ZlcmxheSB3b24ndCB3b3JrLlxuICAgIGlmIChpc0ZvY3VzSW5PdmVybGF5ICYmIGxhc3RGb2N1c1dhc09uU3VwZXJGb2N1c2FibGVFbCkgcmV0dXJuXG5cbiAgICBjb25zdCBzdXBlckZvY3VzYWJsZUVsID0gb3ZlcmxheUVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXScpXG4gICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgaW4gdGhlIHRvcG1vc3Qgb3ZlcmxheSwgQU5EIHRoZXJlIGFyZSBubyBzdXBlciBmb2N1c2FibGUgZWxlbWVudHMgeWV0LCAtIGxlYXZlIGZvY3VzIHVwIHRvIHRoZSB1c2VyLlxuICAgIC8vIFtQcmFjdGljYWwgY2hlY2tdIHdpdGhvdXQgdGhpcyBsaW5lLCBpZiB5b3UgYXJlIGluIGFuIGVtcHR5IGZvbGRlciBpbiBnb29nbGUgZHJpdmUsIGFuZCBzb21ldGhpbmcncyB1cGxvYWRpbmcgaW4gdGhlIGJnLCAtIGZvY3VzIHdpbGwgYmUganVtcGluZyB0byBEb25lIGFsbCB0aGUgdGltZS5cbiAgICBpZiAoaXNGb2N1c0luT3ZlcmxheSAmJiAhc3VwZXJGb2N1c2FibGVFbCkgcmV0dXJuXG5cbiAgICBpZiAoc3VwZXJGb2N1c2FibGVFbCkge1xuICAgICAgc3VwZXJGb2N1c2FibGVFbC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSlcbiAgICAgIGxhc3RGb2N1c1dhc09uU3VwZXJGb2N1c2FibGVFbCA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZmlyc3RFbCA9IG92ZXJsYXlFbC5xdWVyeVNlbGVjdG9yKEZPQ1VTQUJMRV9FTEVNRU5UUylcbiAgICAgIGZpcnN0RWwgJiYgZmlyc3RFbC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSlcbiAgICAgIGxhc3RGb2N1c1dhc09uU3VwZXJGb2N1c2FibGVFbCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gX19fV2h5IGRvIHdlIG5lZWQgdG8gZGVib3VuY2U/XG4gIC8vICAgIDEuIFRvIGRlYWwgd2l0aCBhbmltYXRpb25zOiBvdmVybGF5IGNoYW5nZXMgdmlhIGFuaW1hdGlvbnMsIHdoaWNoIHJlc3VsdHMgaW4gdGhlIERPTSB1cGRhdGluZyBBRlRFUiBwbHVnaW4udXBkYXRlKCkgYWxyZWFkeSBleGVjdXRlZC5cbiAgLy8gICAgW1ByYWN0aWNhbCBjaGVja10gd2l0aG91dCBkZWJvdW5jZSwgaWYgd2Ugb3BlbiB0aGUgVXJsIG92ZXJsYXksIGFuZCBjbGljayAnRG9uZScsIERhc2hib2FyZCB3b24ndCBnZXQgZm9jdXNlZCBhZ2Fpbi5cbiAgLy8gICAgW1ByYWN0aWNhbCBjaGVja10gaWYgd2UgZGVsYXkgMjUwbXMgaW5zdGVhZCBvZiAyNjBtcyAtIElFMTEgd29uJ3QgZ2V0IGZvY3VzZWQgaW4gc2FtZSBzaXR1YXRpb24uXG4gIC8vICAgIDIuIFBlcmZvcm1hbmNlOiB0aGVyZSBjYW4gYmUgbWFueSBzdGF0ZSB1cGRhdGUoKXMgaW4gYSBzZWNvbmQsIGFuZCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBldmVyeSB0aW1lLlxuICByZXR1cm4gZGVib3VuY2Uoc3VwZXJGb2N1cywgMjYwKVxufVxuIiwiLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IC0gZWl0aGVyIGRhc2hib2FyZCBlbGVtZW50LCBvciB0aGUgb3ZlcmxheSB0aGF0J3MgbW9zdCBvbiB0b3BcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRBY3RpdmVPdmVybGF5RWwgKGRhc2hib2FyZEVsLCBhY3RpdmVPdmVybGF5VHlwZSkge1xuICBpZiAoYWN0aXZlT3ZlcmxheVR5cGUpIHtcbiAgICBjb25zdCBvdmVybGF5RWwgPSBkYXNoYm9hcmRFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS11cHB5LXBhbmVsdHlwZT1cIiR7YWN0aXZlT3ZlcmxheVR5cGV9XCJdYClcbiAgICAvLyBpZiBhbiBvdmVybGF5IGlzIGFscmVhZHkgbW91bnRlZFxuICAgIGlmIChvdmVybGF5RWwpIHJldHVybiBvdmVybGF5RWxcbiAgfVxuICByZXR1cm4gZGFzaGJvYXJkRWxcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuZnVuY3Rpb24gaWNvbkltYWdlICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPGcgZmlsbD1cIiM2ODZERTBcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgPHBhdGggZD1cIk01IDd2MTBoMTVWN0g1em0wLTFoMTVhMSAxIDAgMCAxIDEgMXYxMGExIDEgMCAwIDEtMSAxSDVhMSAxIDAgMCAxLTEtMVY3YTEgMSAwIDAgMSAxLTF6XCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk02LjM1IDE3LjE3Mmw0Ljk5NC01LjAyNmEuNS41IDAgMCAxIC43MDcgMGwyLjE2IDIuMTYgMy41MDUtMy41MDVhLjUuNSAwIDAgMSAuNzA3IDBsMi4zMzYgMi4zMS0uNzA3LjcyLTEuOTgzLTEuOTctMy41MDUgMy41MDVhLjUuNSAwIDAgMS0uNzA3IDBsLTIuMTYtMi4xNTktMy45MzggMy45MzktMS40MDkuMDI2elwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICAgIDxjaXJjbGUgY3g9XCI3LjVcIiBjeT1cIjkuNVwiIHI9XCIxLjVcIiAvPlxuICAgICAgPC9nPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIGljb25BdWRpbyAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPHBhdGggZD1cIk05LjUgMTguNjRjMCAxLjE0LTEuMTQ1IDItMi41IDJzLTIuNS0uODYtMi41LTJjMC0xLjE0IDEuMTQ1LTIgMi41LTIgLjU1NyAwIDEuMDc5LjE0NSAxLjUuMzk2VjcuMjVhLjUuNSAwIDAgMSAuMzc5LS40ODVsOS0yLjI1QS41LjUgMCAwIDEgMTguNSA1djExLjY0YzAgMS4xNC0xLjE0NSAyLTIuNSAycy0yLjUtLjg2LTIuNS0yYzAtMS4xNCAxLjE0NS0yIDIuNS0yIC41NTcgMCAxLjA3OS4xNDUgMS41LjM5NlY4LjY3bC04IDJ2Ny45N3ptOC0xMXYtMmwtOCAydjJsOC0yek03IDE5LjY0Yy44NTUgMCAxLjUtLjQ4NCAxLjUtMXMtLjY0NS0xLTEuNS0xLTEuNS40ODQtMS41IDEgLjY0NSAxIDEuNSAxem05LTJjLjg1NSAwIDEuNS0uNDg0IDEuNS0xcy0uNjQ1LTEtMS41LTEtMS41LjQ4NC0xLjUgMSAuNjQ1IDEgMS41IDF6XCIgZmlsbD1cIiMwNDlCQ0ZcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIGljb25WaWRlbyAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPHBhdGggZD1cIk0xNiAxMS44MzRsNC40ODYtMi42OTFBMSAxIDAgMCAxIDIyIDEwdjZhMSAxIDAgMCAxLTEuNTE0Ljg1N0wxNiAxNC4xNjdWMTdhMSAxIDAgMCAxLTEgMUg1YTEgMSAwIDAgMS0xLTFWOWExIDEgMCAwIDEgMS0xaDEwYTEgMSAwIDAgMSAxIDF2Mi44MzR6TTE1IDlINXY4aDEwVjl6bTEgNGw1IDN2LTZsLTUgM3pcIiBmaWxsPVwiIzE5QUY2N1wiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvblBERiAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPHBhdGggZD1cIk05Ljc2NiA4LjI5NWMtLjY5MS0xLjg0My0uNTM5LTMuNDAxLjc0Ny0zLjcyNiAxLjY0My0uNDE0IDIuNTA1LjkzOCAyLjM5IDMuMjk5LS4wMzkuNzktLjE5NCAxLjY2Mi0uNTM3IDMuMTQ4LjMyNC40OS42Ni45NjcgMS4wNTUgMS41MS4xNy4yMzEuMzgyLjQ4OC42MjkuNzU3IDEuODY2LS4xMjggMy42NTMuMTE0IDQuOTE4LjY1NSAxLjQ4Ny42MzUgMi4xOTIgMS42ODUgMS42MTQgMi44NC0uNTY2IDEuMTMzLTEuODM5IDEuMDg0LTMuNDE2LjI0OS0xLjE0MS0uNjA0LTIuNDU3LTEuNjM0LTMuNTEtMi43MDdhMTMuNDY3IDEzLjQ2NyAwIDAgMC0yLjIzOC40MjZjLTEuMzkyIDQuMDUxLTQuNTM0IDYuNDUzLTUuNzA3IDQuNTcyLS45ODYtMS41OCAxLjM4LTQuMjA2IDQuOTE0LTUuMzc1LjA5Ny0uMzIyLjE4NS0uNjU2LjI2NC0xLjAwMS4wOC0uMzUzLjMwNi0xLjMxLjQwNy0xLjczNy0uNjc4LTEuMDU5LTEuMi0yLjAzMS0xLjUzLTIuOTF6bTIuMDk4IDQuODdjLS4wMzMuMTQ0LS4wNjguMjg3LS4xMDQuNDI3bC4wMzMtLjAxLS4wMTIuMDM4YTE0LjA2NSAxNC4wNjUgMCAwIDEgMS4wMi0uMTk3bC0uMDMyLS4wMzMuMDUyLS4wMDRhNy45MDIgNy45MDIgMCAwIDEtLjIwOC0uMjcxYy0uMTk3LS4yNy0uMzgtLjUyNi0uNTU1LS43NzVsLS4wMDYuMDI4LS4wMDItLjAwM2MtLjA3Ni4zMjMtLjE0OC42MzItLjE4Ni44em01Ljc3IDIuOTc4YzEuMTQzLjYwNSAxLjgzMi42MzIgMi4wNTQuMTg3LjI2LS41MTktLjA4Ny0xLjAzNC0xLjExMy0xLjQ3My0uOTExLS4zOS0yLjE3NS0uNjA4LTMuNTUtLjYwOC44NDUuNzY2IDEuNzg3IDEuNDU5IDIuNjA5IDEuODk0ek02LjU1OSAxOC43ODljLjE0LjIyMy42OTMuMTYgMS40MjUtLjQxMy44MjctLjY0OCAxLjYxLTEuNzQ3IDIuMjA4LTMuMjA2LTIuNTYzIDEuMDY0LTQuMTAyIDIuODY3LTMuNjMzIDMuNjJ6bTUuMzQ1LTEwLjk3Yy4wODgtMS43OTMtLjM1MS0yLjQ4LTEuMTQ2LTIuMjgtLjQ3My4xMTktLjU2NCAxLjA1LS4wNTYgMi40MDUuMjEzLjU2Ni41MiAxLjE4OC45MDggMS44NTkuMTgtLjg1OC4yNjgtMS40NTMuMjk0LTEuOTg0elwiIGZpbGw9XCIjRTI1MTRBXCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBpY29uQXJjaGl2ZSAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMTAuNDUgMi4wNWgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI0YS41LjUgMCAwIDEtLjUuNWgtMS4wNWEuNS41IDAgMCAxLS41LS41VjIuNTVhLjUuNSAwIDAgMSAuNS0uNXptMi4wNSAxLjAyNGgxLjA1YS41LjUgMCAwIDEgLjUuNVYzLjZhLjUuNSAwIDAgMS0uNS41SDEyLjVhLjUuNSAwIDAgMS0uNS0uNXYtLjAyNWEuNS41IDAgMCAxIC41LS41di0uMDAxek0xMC40NSAwaDEuMDVhLjUuNSAwIDAgMSAuNS41di4wMjVhLjUuNSAwIDAgMS0uNS41aC0xLjA1YS41LjUgMCAwIDEtLjUtLjVWLjVhLjUuNSAwIDAgMSAuNS0uNXptMi4wNSAxLjAyNWgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI0YS41LjUgMCAwIDEtLjUuNUgxMi41YS41LjUgMCAwIDEtLjUtLjV2LS4wMjRhLjUuNSAwIDAgMSAuNS0uNXptLTIuMDUgMy4wNzRoMS4wNWEuNS41IDAgMCAxIC41LjV2LjAyNWEuNS41IDAgMCAxLS41LjVoLTEuMDVhLjUuNSAwIDAgMS0uNS0uNXYtLjAyNWEuNS41IDAgMCAxIC41LS41em0yLjA1IDEuMDI1aDEuMDVhLjUuNSAwIDAgMSAuNS41di4wMjRhLjUuNSAwIDAgMS0uNS41SDEyLjVhLjUuNSAwIDAgMS0uNS0uNXYtLjAyNGEuNS41IDAgMCAxIC41LS41em0tMi4wNSAxLjAyNGgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI1YS41LjUgMCAwIDEtLjUuNWgtMS4wNWEuNS41IDAgMCAxLS41LS41di0uMDI1YS41LjUgMCAwIDEgLjUtLjV6bTIuMDUgMS4wMjVoMS4wNWEuNS41IDAgMCAxIC41LjV2LjAyNWEuNS41IDAgMCAxLS41LjVIMTIuNWEuNS41IDAgMCAxLS41LS41di0uMDI1YS41LjUgMCAwIDEgLjUtLjV6bS0yLjA1IDEuMDI1aDEuMDVhLjUuNSAwIDAgMSAuNS41di4wMjVhLjUuNSAwIDAgMS0uNS41aC0xLjA1YS41LjUgMCAwIDEtLjUtLjV2LS4wMjVhLjUuNSAwIDAgMSAuNS0uNXptMi4wNSAxLjAyNWgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI0YS41LjUgMCAwIDEtLjUuNUgxMi41YS41LjUgMCAwIDEtLjUtLjV2LS4wMjRhLjUuNSAwIDAgMSAuNS0uNXptLTEuNjU2IDMuMDc0bC0uODIgNS45NDZjLjUyLjMwMiAxLjE3NC40NTggMS45NzYuNDU4LjgwMyAwIDEuNDU1LS4xNTYgMS45NzUtLjQ1OGwtLjgyLTUuOTQ2aC0yLjMxMXptMC0xLjAyNWgyLjMxMmMuNTEyIDAgLjk0Ni4zNzggMS4wMTUuODg1bC44MiA1Ljk0NmMuMDU2LjQxMi0uMTQyLjgxNy0uNTAxIDEuMDI2LS42ODYuMzk4LTEuNTE1LjU5Ny0yLjQ5LjU5Ny0uOTc0IDAtMS44MDQtLjE5OS0yLjQ5LS41OTdhMS4wMjUgMS4wMjUgMCAwIDEtLjUtMS4wMjZsLjgxOS01Ljk0NmMuMDctLjUwNy41MDMtLjg4NSAxLjAxNS0uODg1em0uNTQ1IDYuNmEuNS41IDAgMCAxLS4zOTctLjU2MWwuMTQzLS45OTlhLjUuNSAwIDAgMSAuNDk1LS40MjloLjc0YS41LjUgMCAwIDEgLjQ5NS40M2wuMTQzLjk5OGEuNS41IDAgMCAxLS4zOTcuNTYxYy0uNDA0LjA4LS44MTkuMDgtMS4yMjIgMHpcIiBmaWxsPVwiIzAwQzQ2OVwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvbkZpbGUgKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxnIGZpbGw9XCIjQTdBRkI3XCIgZmlsbFJ1bGU9XCJub256ZXJvXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNNS41IDIyYS41LjUgMCAwIDEtLjUtLjV2LTE4YS41LjUgMCAwIDEgLjUtLjVoMTAuNzE5YS41LjUgMCAwIDEgLjM2Ny4xNmwzLjI4MSAzLjU1NmEuNS41IDAgMCAxIC4xMzMuMzM5VjIxLjVhLjUuNSAwIDAgMS0uNS41aC0xNHptLjUtMWgxM1Y3LjI1TDE2IDRINnYxN3pcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTE1IDR2M2ExIDEgMCAwIDAgMSAxaDNWN2gtM1Y0aC0xelwiIC8+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvblRleHQgKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxwYXRoIGQ9XCJNNC41IDdoMTNhLjUuNSAwIDEgMSAwIDFoLTEzYS41LjUgMCAwIDEgMC0xem0wIDNoMTVhLjUuNSAwIDEgMSAwIDFoLTE1YS41LjUgMCAxIDEgMC0xem0wIDNoMTVhLjUuNSAwIDEgMSAwIDFoLTE1YS41LjUgMCAxIDEgMC0xem0wIDNoMTBhLjUuNSAwIDEgMSAwIDFoLTEwYS41LjUgMCAxIDEgMC0xelwiIGZpbGw9XCIjNUE1RTY5XCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEljb25CeU1pbWUgKGZpbGVUeXBlKSB7XG4gIGNvbnN0IGRlZmF1bHRDaG9pY2UgPSB7XG4gICAgY29sb3I6ICcjODM4OTk5JyxcbiAgICBpY29uOiBpY29uRmlsZSgpLFxuICB9XG5cbiAgaWYgKCFmaWxlVHlwZSkgcmV0dXJuIGRlZmF1bHRDaG9pY2VcblxuICBjb25zdCBmaWxlVHlwZUdlbmVyYWwgPSBmaWxlVHlwZS5zcGxpdCgnLycpWzBdXG4gIGNvbnN0IGZpbGVUeXBlU3BlY2lmaWMgPSBmaWxlVHlwZS5zcGxpdCgnLycpWzFdXG5cbiAgLy8gVGV4dFxuICBpZiAoZmlsZVR5cGVHZW5lcmFsID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6ICcjNWE1ZTY5JyxcbiAgICAgIGljb246IGljb25UZXh0KCksXG4gICAgfVxuICB9XG5cbiAgLy8gSW1hZ2VcbiAgaWYgKGZpbGVUeXBlR2VuZXJhbCA9PT0gJ2ltYWdlJykge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyM2ODZkZTAnLFxuICAgICAgaWNvbjogaWNvbkltYWdlKCksXG4gICAgfVxuICB9XG5cbiAgLy8gQXVkaW9cbiAgaWYgKGZpbGVUeXBlR2VuZXJhbCA9PT0gJ2F1ZGlvJykge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyMwNjhkYmInLFxuICAgICAgaWNvbjogaWNvbkF1ZGlvKCksXG4gICAgfVxuICB9XG5cbiAgLy8gVmlkZW9cbiAgaWYgKGZpbGVUeXBlR2VuZXJhbCA9PT0gJ3ZpZGVvJykge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyMxOWFmNjcnLFxuICAgICAgaWNvbjogaWNvblZpZGVvKCksXG4gICAgfVxuICB9XG5cbiAgLy8gUERGXG4gIGlmIChmaWxlVHlwZUdlbmVyYWwgPT09ICdhcHBsaWNhdGlvbicgJiYgZmlsZVR5cGVTcGVjaWZpYyA9PT0gJ3BkZicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6ICcjZTI1MTQ5JyxcbiAgICAgIGljb246IGljb25QREYoKSxcbiAgICB9XG4gIH1cblxuICAvLyBBcmNoaXZlXG4gIGNvbnN0IGFyY2hpdmVUeXBlcyA9IFsnemlwJywgJ3gtN3otY29tcHJlc3NlZCcsICd4LXJhci1jb21wcmVzc2VkJywgJ3gtdGFyJywgJ3gtZ3ppcCcsICd4LWFwcGxlLWRpc2tpbWFnZSddXG4gIGlmIChmaWxlVHlwZUdlbmVyYWwgPT09ICdhcHBsaWNhdGlvbicgJiYgYXJjaGl2ZVR5cGVzLmluZGV4T2YoZmlsZVR5cGVTcGVjaWZpYykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiAnIzAwQzQ2OScsXG4gICAgICBpY29uOiBpY29uQXJjaGl2ZSgpLFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0Q2hvaWNlXG59XG4iLCIvLyBpZ25vcmUgZHJvcC9wYXN0ZSBldmVudHMgaWYgdGhleSBhcmUgbm90IGluIGlucHV0IG9yIHRleHRhcmVhIOKAlFxuLy8gb3RoZXJ3aXNlIHdoZW4gVXJsIHBsdWdpbiBhZGRzIGRyb3AvcGFzdGUgbGlzdGVuZXJzIHRvIHRoaXMuZWwsXG4vLyBkcmFnaW5nIFVJIGVsZW1lbnRzIG9yIHBhc3RpbmcgYW55dGhpbmcgaW50byBhbnkgZmllbGQgdHJpZ2dlcnMgdGhvc2UgZXZlbnRzIOKAlFxuLy8gVXJsIHRyZWF0cyB0aGVtIGFzIFVSTHMgdGhhdCBuZWVkIHRvIGJlIGltcG9ydGVkXG5cbmZ1bmN0aW9uIGlnbm9yZUV2ZW50IChldikge1xuICBjb25zdCB0YWdOYW1lID0gZXYudGFyZ2V0LnRhZ05hbWVcbiAgaWYgKHRhZ05hbWUgPT09ICdJTlBVVCdcbiAgICAgIHx8IHRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICBldi5zdG9wUHJvcGFnYXRpb24oKVxuICAgIHJldHVyblxuICB9XG4gIGV2LnByZXZlbnREZWZhdWx0KClcbiAgZXYuc3RvcFByb3BhZ2F0aW9uKClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZ25vcmVFdmVudFxuIiwiY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi90b0FycmF5JylcbmNvbnN0IGdldEFjdGl2ZU92ZXJsYXlFbCA9IHJlcXVpcmUoJy4vZ2V0QWN0aXZlT3ZlcmxheUVsJylcbmNvbnN0IEZPQ1VTQUJMRV9FTEVNRU5UUyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9GT0NVU0FCTEVfRUxFTUVOVFMnKVxuXG5mdW5jdGlvbiBmb2N1c09uRmlyc3ROb2RlIChldmVudCwgbm9kZXMpIHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVzWzBdXG4gIGlmIChub2RlKSB7XG4gICAgbm9kZS5mb2N1cygpXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZvY3VzT25MYXN0Tm9kZSAoZXZlbnQsIG5vZGVzKSB7XG4gIGNvbnN0IG5vZGUgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXVxuICBpZiAobm9kZSkge1xuICAgIG5vZGUuZm9jdXMoKVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgfVxufVxuXG4vLyBfX19XaHkgbm90IGp1c3QgdXNlIChmb2N1c2VkSXRlbUluZGV4ID09PSAtMSk/XG4vLyAgICBGaXJlZm94IHRoaW5rcyA8dWw+IGlzIGZvY3VzYWJsZSwgYnV0IHdlIGRvbid0IGhhdmUgPHVsPnMgaW4gb3VyIEZPQ1VTQUJMRV9FTEVNRU5UUy4gV2hpY2ggbWVhbnMgdGhhdCBpZiB3ZSB0YWIgaW50byB0aGUgPHVsPiwgY29kZSB3aWxsIHRoaW5rIHRoYXQgd2UgYXJlIG5vdCBpbiB0aGUgYWN0aXZlIG92ZXJsYXksIGFuZCB3ZSBzaG91bGQgZm9jdXNPbkZpcnN0Tm9kZSgpIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIG92ZXJsYXkhXG4vLyAgICBbUHJhY3RpY2FsIGNoZWNrXSBpZiB3ZSB1c2UgKGZvY3VzZWRJdGVtSW5kZXggPT09IC0xKSwgaW5zdGFncmFtIHByb3ZpZGVyIGluIGZpcmVmb3ggd2lsbCBuZXZlciBnZXQgZm9jdXMgb24gaXRzIHBpY3MgaW4gdGhlIDx1bD4uXG5mdW5jdGlvbiBpc0ZvY3VzSW5PdmVybGF5IChhY3RpdmVPdmVybGF5RWwpIHtcbiAgcmV0dXJuIGFjdGl2ZU92ZXJsYXlFbC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxufVxuXG5mdW5jdGlvbiB0cmFwRm9jdXMgKGV2ZW50LCBhY3RpdmVPdmVybGF5VHlwZSwgZGFzaGJvYXJkRWwpIHtcbiAgY29uc3QgYWN0aXZlT3ZlcmxheUVsID0gZ2V0QWN0aXZlT3ZlcmxheUVsKGRhc2hib2FyZEVsLCBhY3RpdmVPdmVybGF5VHlwZSlcbiAgY29uc3QgZm9jdXNhYmxlTm9kZXMgPSB0b0FycmF5KGFjdGl2ZU92ZXJsYXlFbC5xdWVyeVNlbGVjdG9yQWxsKEZPQ1VTQUJMRV9FTEVNRU5UUykpXG5cbiAgY29uc3QgZm9jdXNlZEl0ZW1JbmRleCA9IGZvY3VzYWJsZU5vZGVzLmluZGV4T2YoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcblxuICAvLyBJZiB3ZSBwcmVzc2VkIHRhYiwgYW5kIGZvY3VzIGlzIG5vdCB5ZXQgd2l0aGluIHRoZSBjdXJyZW50IG92ZXJsYXkgLSBmb2N1cyBvbiB0aGUgZmlyc3QgZWxlbWVudCB3aXRoaW4gdGhlIGN1cnJlbnQgb3ZlcmxheS5cbiAgLy8gVGhpcyBpcyBhIHNhZmV0eSBtZWFzdXJlIChmb3Igd2hlbiB1c2VyIHJldHVybnMgZnJvbSBhbm90aGVyIHRhYiBlLmcuKSwgbW9zdCBwbHVnaW5zIHdpbGwgdHJ5IHRvIGZvY3VzIG9uIHNvbWUgaW1wb3J0YW50IGVsZW1lbnQgYXMgaXQgbG9hZHMuXG4gIGlmICghaXNGb2N1c0luT3ZlcmxheShhY3RpdmVPdmVybGF5RWwpKSB7XG4gICAgZm9jdXNPbkZpcnN0Tm9kZShldmVudCwgZm9jdXNhYmxlTm9kZXMpXG4gIC8vIElmIHdlIHByZXNzZWQgc2hpZnQgKyB0YWIsIGFuZCB3ZSdyZSBvbiB0aGUgZmlyc3QgZWxlbWVudCBvZiBhIG1vZGFsXG4gIH0gZWxzZSBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgZm9jdXNlZEl0ZW1JbmRleCA9PT0gMCkge1xuICAgIGZvY3VzT25MYXN0Tm9kZShldmVudCwgZm9jdXNhYmxlTm9kZXMpXG4gIC8vIElmIHdlIHByZXNzZWQgdGFiLCBhbmQgd2UncmUgb24gdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbW9kYWxcbiAgfSBlbHNlIGlmICghZXZlbnQuc2hpZnRLZXkgJiYgZm9jdXNlZEl0ZW1JbmRleCA9PT0gZm9jdXNhYmxlTm9kZXMubGVuZ3RoIC0gMSkge1xuICAgIGZvY3VzT25GaXJzdE5vZGUoZXZlbnQsIGZvY3VzYWJsZU5vZGVzKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBUcmFwcyBmb2N1cyBpbnNpZGUgb2YgdGhlIGN1cnJlbnRseSBvcGVuIG92ZXJsYXkgKGUuZy4gRGFzaGJvYXJkLCBvciBlLmcuIEluc3RhZ3JhbSksIG5ldmVyIGxldHMgZm9jdXMgZGlzYXBwZWFyIGZyb20gdGhlIG1vZGFsLlxuICBmb3JNb2RhbDogKGV2ZW50LCBhY3RpdmVPdmVybGF5VHlwZSwgZGFzaGJvYXJkRWwpID0+IHtcbiAgICB0cmFwRm9jdXMoZXZlbnQsIGFjdGl2ZU92ZXJsYXlUeXBlLCBkYXNoYm9hcmRFbClcbiAgfSxcblxuICAvLyBUcmFwcyBmb2N1cyBpbnNpZGUgb2YgdGhlIGN1cnJlbnRseSBvcGVuIG92ZXJsYXksIHVubGVzcyBvdmVybGF5IGlzIG51bGwgLSB0aGVuIGxldCB0aGUgdXNlciB0YWIgYXdheS5cbiAgZm9ySW5saW5lOiAoZXZlbnQsIGFjdGl2ZU92ZXJsYXlUeXBlLCBkYXNoYm9hcmRFbCkgPT4ge1xuICAgIC8vIF9fX1doZW4gd2UncmUgaW4gdGhlIGJhcmUgJ0Ryb3AgZmlsZXMgaGVyZSwgcGFzdGUsIGJyb3dzZSBvciBpbXBvcnQgZnJvbScgc2NyZWVuXG4gICAgaWYgKGFjdGl2ZU92ZXJsYXlUeXBlID09PSBudWxsKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGFuZCBsZXQgdGhlIGJyb3dzZXIgaGFuZGxlIGl0LCB1c2VyIGNhbiB0YWIgYXdheSBmcm9tIFVwcHkgdG8gb3RoZXIgZWxlbWVudHMgb24gdGhlIHBhZ2VcbiAgICAvLyBfX19XaGVuIHRoZXJlIGlzIHNvbWUgb3ZlcmxheSB3aXRoICdEb25lJyBidXR0b25cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhcCB0aGUgZm9jdXMgaW5zaWRlIHRoaXMgb3ZlcmxheSFcbiAgICAgIC8vIFVzZXIgY2FuIGNsb3NlIHRoZSBvdmVybGF5IChjbGljayAnRG9uZScpIGlmIHRoZXkgd2FudCB0byB0cmF2ZWwgYXdheSBmcm9tIFVwcHkuXG4gICAgICB0cmFwRm9jdXMoZXZlbnQsIGFjdGl2ZU92ZXJsYXlUeXBlLCBkYXNoYm9hcmRFbClcbiAgICB9XG4gIH0sXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L2Ryb3Bib3hcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkltcG9ydCBmaWxlcyBmcm9tIERyb3Bib3gsIGludG8gVXBweS5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS41LjJcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJkcm9wYm94XCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgeyBQcm92aWRlclZpZXdzIH0gPSByZXF1aXJlKCdAdXBweS9wcm92aWRlci12aWV3cycpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRHJvcGJveCBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdEcm9wYm94J1xuICAgIFByb3ZpZGVyLmluaXRQbHVnaW4odGhpcywgb3B0cylcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdEcm9wYm94J1xuICAgIHRoaXMuaWNvbiA9ICgpID0+IChcbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIGZpbGw9XCIjMEQyNDgxXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMSA4bDUgMy4xODUtNSAzLjE4Ni01LTMuMTg2TDExIDh6bTEwIDBsNSAzLjE4NS01IDMuMTg2LTUtMy4xODZMMjEgOHpNNiAxNy41NTZsNS0zLjE4NSA1IDMuMTg1LTUgMy4xODYtNS0zLjE4NnptMTUtMy4xODVsNSAzLjE4NS01IDMuMTg2LTUtMy4xODYgNS0zLjE4NXptLTEwIDcuNDMybDUtMy4xODUgNSAzLjE4NS01IDMuMTg2LTUtMy4xODZ6XCIgZmlsbD1cIiNGRkZcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L3N2Zz5cbiAgICApXG5cbiAgICB0aGlzLnByb3ZpZGVyID0gbmV3IFByb3ZpZGVyKHVwcHksIHtcbiAgICAgIGNvbXBhbmlvblVybDogdGhpcy5vcHRzLmNvbXBhbmlvblVybCxcbiAgICAgIGNvbXBhbmlvbkhlYWRlcnM6IHRoaXMub3B0cy5jb21wYW5pb25IZWFkZXJzIHx8IHRoaXMub3B0cy5zZXJ2ZXJIZWFkZXJzLFxuICAgICAgY29tcGFuaW9uS2V5c1BhcmFtczogdGhpcy5vcHRzLmNvbXBhbmlvbktleXNQYXJhbXMsXG4gICAgICBjb21wYW5pb25Db29raWVzUnVsZTogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlLFxuICAgICAgcHJvdmlkZXI6ICdkcm9wYm94JyxcbiAgICAgIHBsdWdpbklkOiB0aGlzLmlkLFxuICAgIH0pXG5cbiAgICB0aGlzLm9uRmlyc3RSZW5kZXIgPSB0aGlzLm9uRmlyc3RSZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3ID0gbmV3IFByb3ZpZGVyVmlld3ModGhpcywge1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgfSlcblxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0cy50YXJnZXRcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1vdW50KHRhcmdldCwgdGhpcylcbiAgICB9XG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldy50ZWFyRG93bigpXG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxuXG4gIG9uRmlyc3RSZW5kZXIgKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnByb3ZpZGVyLmZldGNoUHJlQXV0aFRva2VuKCksXG4gICAgICB0aGlzLnZpZXcuZ2V0Rm9sZGVyKCksXG4gICAgXSlcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnJlbmRlcihzdGF0ZSlcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9mYWNlYm9va1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiSW1wb3J0IGZpbGVzIGZyb20gRmFjZWJvb2ssIGludG8gVXBweS5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4yLjJcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJmYWNlYm9va1wiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29tcGFuaW9uLWNsaWVudFwiOiBcImZpbGU6Li4vY29tcGFuaW9uLWNsaWVudFwiLFxuICAgIFwiQHVwcHkvcHJvdmlkZXItdmlld3NcIjogXCJmaWxlOi4uL3Byb3ZpZGVyLXZpZXdzXCIsXG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIixcbiAgICBcInByZWFjdFwiOiBcIjguMi45XCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvcmVcIjogXCJeMS4wLjBcIlxuICB9XG59XG4iLCJjb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCB7IFByb3ZpZGVyIH0gPSByZXF1aXJlKCdAdXBweS9jb21wYW5pb24tY2xpZW50JylcbmNvbnN0IHsgUHJvdmlkZXJWaWV3cyB9ID0gcmVxdWlyZSgnQHVwcHkvcHJvdmlkZXItdmlld3MnKVxuY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEZhY2Vib29rIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0ZhY2Vib29rJ1xuICAgIFByb3ZpZGVyLmluaXRQbHVnaW4odGhpcywgb3B0cylcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdGYWNlYm9vaydcbiAgICB0aGlzLmljb24gPSAoKSA9PiAoXG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiPlxuICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgIDxyZWN0IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJJY29uQmdcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiByeD1cIjE2XCIgZmlsbD1cIiMzQzVBOTlcIiAvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTcuODQyIDI2di04LjY2N2gyLjY1M2wuMzk4LTMuMzc3aC0zLjA1MXYtMi4xNTdjMC0uOTc4LjI0OC0xLjY0NCAxLjUyNy0xLjY0NEgyMVY3LjEzMkExOS45MTQgMTkuOTE0IDAgMCAwIDE4LjYyMyA3Yy0yLjM1MiAwLTMuOTYzIDEuNTc0LTMuOTYzIDQuNDY1djIuNDlIMTJ2My4zNzhoMi42NlYyNmgzLjE4MnpcIiBmaWxsPVwiI0ZGRlwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMgfHwgdGhpcy5vcHRzLnNlcnZlckhlYWRlcnMsXG4gICAgICBjb21wYW5pb25LZXlzUGFyYW1zOiB0aGlzLm9wdHMuY29tcGFuaW9uS2V5c1BhcmFtcyxcbiAgICAgIGNvbXBhbmlvbkNvb2tpZXNSdWxlOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUsXG4gICAgICBwcm92aWRlcjogJ2ZhY2Vib29rJyxcbiAgICAgIHBsdWdpbklkOiB0aGlzLmlkLFxuICAgIH0pXG5cbiAgICB0aGlzLm9uRmlyc3RSZW5kZXIgPSB0aGlzLm9uRmlyc3RSZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3ID0gbmV3IFByb3ZpZGVyVmlld3ModGhpcywge1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgfSlcblxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0cy50YXJnZXRcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1vdW50KHRhcmdldCwgdGhpcylcbiAgICB9XG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldy50ZWFyRG93bigpXG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxuXG4gIG9uRmlyc3RSZW5kZXIgKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnByb3ZpZGVyLmZldGNoUHJlQXV0aFRva2VuKCksXG4gICAgICB0aGlzLnZpZXcuZ2V0Rm9sZGVyKCksXG4gICAgXSlcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUpIHtcbiAgICBjb25zdCB2aWV3T3B0aW9ucyA9IHt9XG4gICAgaWYgKHRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5maWxlcy5sZW5ndGggJiYgIXRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5mb2xkZXJzLmxlbmd0aCkge1xuICAgICAgdmlld09wdGlvbnMudmlld1R5cGUgPSAnZ3JpZCdcbiAgICAgIHZpZXdPcHRpb25zLnNob3dGaWx0ZXIgPSBmYWxzZVxuICAgICAgdmlld09wdGlvbnMuc2hvd1RpdGxlcyA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyKHN0YXRlLCB2aWV3T3B0aW9ucylcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9mb3JtXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJDb25uZWN0IFVwcHkgdG8gYW4gZXhpc3RpbmcgSFRNTCA8Zm9ybT4uXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuMy4zMVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcImZvcm1cIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwiZ2V0LWZvcm0tZGF0YVwiOiBcIl4yLjAuMFwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgZmluZERPTUVsZW1lbnQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZmluZERPTUVsZW1lbnQnKVxuY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi90b0FycmF5Jylcbi8vIFJvbGx1cCB1c2VzIGdldC1mb3JtLWRhdGEncyBFUyBtb2R1bGVzIGJ1aWxkLCBhbmQgcm9sbHVwLXBsdWdpbi1jb21tb25qcyBhdXRvbWF0aWNhbGx5IHJlc29sdmVzIGAuZGVmYXVsdGAuXG4vLyBTbywgaWYgd2UgYXJlIGJlaW5nIGJ1aWx0IHVzaW5nIHJvbGx1cCwgdGhpcyByZXF1aXJlKCkgd29uJ3QgaGF2ZSBhIGAuZGVmYXVsdGAgcHJvcGVydHkuXG5jb25zdCBnZXRGb3JtRGF0YSA9IHJlcXVpcmUoJ2dldC1mb3JtLWRhdGEnKS5kZWZhdWx0IHx8IHJlcXVpcmUoJ2dldC1mb3JtLWRhdGEnKVxuXG4vKipcbiAqIEZvcm1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBGb3JtIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMudHlwZSA9ICdhY3F1aXJlcidcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdGb3JtJ1xuICAgIHRoaXMudGl0bGUgPSAnRm9ybSdcblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgIHJlc3VsdE5hbWU6ICd1cHB5UmVzdWx0JyxcbiAgICAgIGdldE1ldGFGcm9tRm9ybTogdHJ1ZSxcbiAgICAgIGFkZFJlc3VsdFRvRm9ybTogdHJ1ZSxcbiAgICAgIG11bHRpcGxlUmVzdWx0czogZmFsc2UsXG4gICAgICBzdWJtaXRPblN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgdHJpZ2dlclVwbG9hZE9uU3VibWl0OiBmYWxzZSxcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlclxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgdGhpcy5oYW5kbGVGb3JtU3VibWl0ID0gdGhpcy5oYW5kbGVGb3JtU3VibWl0LmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZVVwbG9hZFN0YXJ0ID0gdGhpcy5oYW5kbGVVcGxvYWRTdGFydC5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVTdWNjZXNzID0gdGhpcy5oYW5kbGVTdWNjZXNzLmJpbmQodGhpcylcbiAgICB0aGlzLmFkZFJlc3VsdFRvRm9ybSA9IHRoaXMuYWRkUmVzdWx0VG9Gb3JtLmJpbmQodGhpcylcbiAgICB0aGlzLmdldE1ldGFGcm9tRm9ybSA9IHRoaXMuZ2V0TWV0YUZyb21Gb3JtLmJpbmQodGhpcylcbiAgfVxuXG4gIGhhbmRsZVVwbG9hZFN0YXJ0ICgpIHtcbiAgICBpZiAodGhpcy5vcHRzLmdldE1ldGFGcm9tRm9ybSkge1xuICAgICAgdGhpcy5nZXRNZXRhRnJvbUZvcm0oKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVN1Y2Nlc3MgKHJlc3VsdCkge1xuICAgIGlmICh0aGlzLm9wdHMuYWRkUmVzdWx0VG9Gb3JtKSB7XG4gICAgICB0aGlzLmFkZFJlc3VsdFRvRm9ybShyZXN1bHQpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy5zdWJtaXRPblN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuZm9ybS5zdWJtaXQoKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUZvcm1TdWJtaXQgKGV2KSB7XG4gICAgaWYgKHRoaXMub3B0cy50cmlnZ2VyVXBsb2FkT25TdWJtaXQpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gdG9BcnJheShldi50YXJnZXQuZWxlbWVudHMpXG4gICAgICBjb25zdCBkaXNhYmxlZEJ5VXBweSA9IFtdXG4gICAgICBlbGVtZW50cy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBjb25zdCBpc0J1dHRvbiA9IGVsLnRhZ05hbWUgPT09ICdCVVRUT04nIHx8IChlbC50YWdOYW1lID09PSAnSU5QVVQnICYmIGVsLnR5cGUgPT09ICdzdWJtaXQnKVxuICAgICAgICBpZiAoaXNCdXR0b24gJiYgIWVsLmRpc2FibGVkKSB7XG4gICAgICAgICAgZWwuZGlzYWJsZWQgPSB0cnVlXG4gICAgICAgICAgZGlzYWJsZWRCeVVwcHkucHVzaChlbClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRoaXMudXBweS51cGxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgZGlzYWJsZWRCeVVwcHkuZm9yRWFjaCgoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgYnV0dG9uLmRpc2FibGVkID0gZmFsc2VcbiAgICAgICAgfSlcbiAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgZGlzYWJsZWRCeVVwcHkuZm9yRWFjaCgoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgYnV0dG9uLmRpc2FibGVkID0gZmFsc2VcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycilcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LmxvZyhlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UgfHwgZXJyKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBhZGRSZXN1bHRUb0Zvcm0gKHJlc3VsdCkge1xuICAgIHRoaXMudXBweS5sb2coJ1tGb3JtXSBBZGRpbmcgcmVzdWx0IHRvIHRoZSBvcmlnaW5hbCBmb3JtOicpXG4gICAgdGhpcy51cHB5LmxvZyhyZXN1bHQpXG5cbiAgICBsZXQgcmVzdWx0SW5wdXQgPSB0aGlzLmZvcm0ucXVlcnlTZWxlY3RvcihgW25hbWU9XCIke3RoaXMub3B0cy5yZXN1bHROYW1lfVwiXWApXG4gICAgaWYgKHJlc3VsdElucHV0KSB7XG4gICAgICBpZiAodGhpcy5vcHRzLm11bHRpcGxlUmVzdWx0cykge1xuICAgICAgICAvLyBBcHBlbmQgbmV3IHJlc3VsdCB0byB0aGUgcHJldmlvdXMgcmVzdWx0IGFycmF5LlxuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgcmVzdWx0IGlzIGVtcHR5LCBvciBub3QgYW4gYXJyYXksXG4gICAgICAgIC8vIHNldCBpdCB0byBhbiBlbXB0eSBhcnJheS5cbiAgICAgICAgbGV0IHVwZGF0ZWRSZXN1bHRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cGRhdGVkUmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHRJbnB1dC52YWx1ZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gTm90aGluZywgc2luY2Ugd2UgY2hlY2sgZm9yIGFycmF5IGJlbG93IGFueXdheVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHVwZGF0ZWRSZXN1bHQpKSB7XG4gICAgICAgICAgdXBkYXRlZFJlc3VsdCA9IFtdXG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlZFJlc3VsdC5wdXNoKHJlc3VsdClcbiAgICAgICAgcmVzdWx0SW5wdXQudmFsdWUgPSBKU09OLnN0cmluZ2lmeSh1cGRhdGVkUmVzdWx0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVwbGFjZSBleGlzdGluZyByZXN1bHQgd2l0aCB0aGUgbmV3ZXIgcmVzdWx0IG9uIGBjb21wbGV0ZWAgZXZlbnQuXG4gICAgICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgbm90IGlkZWFsLCBzaW5jZSB5b3UgbW9zdCBsaWtlbHkgd2FudCB0byBhbHdheXMga2VlcFxuICAgICAgICAvLyBhbGwgcmVzdWx0cyBpbiB0aGUgaW5wdXQuIFRoaXMgaXMga2VwdCBmb3IgYmFja3dhcmRzIGNvbXBhdGFiaWxpdHkgdW50aWwgMi4wLlxuICAgICAgICByZXN1bHRJbnB1dC52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJlc3VsdElucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgIHJlc3VsdElucHV0Lm5hbWUgPSB0aGlzLm9wdHMucmVzdWx0TmFtZVxuICAgIHJlc3VsdElucHV0LnR5cGUgPSAnaGlkZGVuJ1xuXG4gICAgaWYgKHRoaXMub3B0cy5tdWx0aXBsZVJlc3VsdHMpIHtcbiAgICAgIC8vIFdyYXAgcmVzdWx0IGluIGFuIGFycmF5IHNvIHdlIGNhbiBoYXZlIG11bHRpcGxlIHJlc3VsdHNcbiAgICAgIHJlc3VsdElucHV0LnZhbHVlID0gSlNPTi5zdHJpbmdpZnkoW3Jlc3VsdF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc3VsdCBpcyBhbiBvYmplY3QsIGtlcHQgZm9yIGJhY2t3YXJkcyBjb21wYXRhYmlsaXR5IHVudGlsIDIuMFxuICAgICAgcmVzdWx0SW5wdXQudmFsdWUgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpXG4gICAgfVxuXG4gICAgdGhpcy5mb3JtLmFwcGVuZENoaWxkKHJlc3VsdElucHV0KVxuICB9XG5cbiAgZ2V0TWV0YUZyb21Gb3JtICgpIHtcbiAgICBjb25zdCBmb3JtTWV0YSA9IGdldEZvcm1EYXRhKHRoaXMuZm9ybSlcbiAgICAvLyBXZSB3YW50IHRvIGV4Y2x1ZGUgbWV0YSB0aGUgdGhlIEZvcm0gcGx1Z2luIGl0c2VsZiBoYXMgYWRkZWRcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzLzE2MzdcbiAgICBkZWxldGUgZm9ybU1ldGFbdGhpcy5vcHRzLnJlc3VsdE5hbWVdXG4gICAgdGhpcy51cHB5LnNldE1ldGEoZm9ybU1ldGEpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLmZvcm0gPSBmaW5kRE9NRWxlbWVudCh0aGlzLm9wdHMudGFyZ2V0KVxuICAgIGlmICghdGhpcy5mb3JtIHx8IHRoaXMuZm9ybS5ub2RlTmFtZSAhPT0gJ0ZPUk0nKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKCdGb3JtIHBsdWdpbiByZXF1aXJlcyBhIDxmb3JtPiB0YXJnZXQgZWxlbWVudCBwYXNzZWQgaW4gb3B0aW9ucyB0byBvcGVyYXRlLCBub25lIHdhcyBmb3VuZCcsICdlcnJvcicpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgdGhpcy5oYW5kbGVGb3JtU3VibWl0KVxuICAgIHRoaXMudXBweS5vbigndXBsb2FkJywgdGhpcy5oYW5kbGVVcGxvYWRTdGFydClcbiAgICB0aGlzLnVwcHkub24oJ2NvbXBsZXRlJywgdGhpcy5oYW5kbGVTdWNjZXNzKVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLmZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3VibWl0JywgdGhpcy5oYW5kbGVGb3JtU3VibWl0KVxuICAgIHRoaXMudXBweS5vZmYoJ3VwbG9hZCcsIHRoaXMuaGFuZGxlVXBsb2FkU3RhcnQpXG4gICAgdGhpcy51cHB5Lm9mZignY29tcGxldGUnLCB0aGlzLmhhbmRsZVN1Y2Nlc3MpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvZ29vZ2xlLWRyaXZlXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgR29vZ2xlIERyaXZlIHBsdWdpbiBmb3IgVXBweSBsZXRzIHVzZXJzIGltcG9ydCBmaWxlcyBmcm9tIHRoZWlyIEdvb2dsZSBEcml2ZSBhY2NvdW50XCIsXG4gIFwidmVyc2lvblwiOiBcIjEuNy4yXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJnb29nbGUgZHJpdmVcIixcbiAgICBcImNsb3VkIHN0b3JhZ2VcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUHJvdmlkZXJWaWV3cyB9ID0gcmVxdWlyZSgnQHVwcHkvcHJvdmlkZXItdmlld3MnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIERyaXZlUHJvdmlkZXJWaWV3cyBleHRlbmRzIFByb3ZpZGVyVmlld3Mge1xuICB0b2dnbGVDaGVja2JveCAoZSwgZmlsZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIC8vIFNoYXJlZCBEcml2ZXMgYXJlbid0IHNlbGVjdGFibGU7IGZvciBhbGwgZWxzZSwgZGVmZXIgdG8gdGhlIGJhc2UgUHJvdmlkZXJWaWV3LlxuICAgIC8vIEB0b2RvIGlzVGVhbURyaXZlIGlzIGxlZnQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIFdlIHNob3VsZCByZW1vdmUgaXQgaW4gdGhlIG5leHRcbiAgICAvLyBtYWpvciByZWxlYXNlLlxuICAgIGlmICghZmlsZS5jdXN0b20uaXNUZWFtRHJpdmUgJiYgIWZpbGUuY3VzdG9tLmlzU2hhcmVkRHJpdmUpIHtcbiAgICAgIHN1cGVyLnRvZ2dsZUNoZWNrYm94KGUsIGZpbGUpXG4gICAgfVxuICB9XG59XG4iLCJjb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCB7IFByb3ZpZGVyIH0gPSByZXF1aXJlKCdAdXBweS9jb21wYW5pb24tY2xpZW50JylcbmNvbnN0IERyaXZlUHJvdmlkZXJWaWV3cyA9IHJlcXVpcmUoJy4vRHJpdmVQcm92aWRlclZpZXdzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBHb29nbGVEcml2ZSBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdHb29nbGVEcml2ZSdcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdHb29nbGUgRHJpdmUnXG4gICAgUHJvdmlkZXIuaW5pdFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ0dvb2dsZSBEcml2ZSdcbiAgICB0aGlzLmljb24gPSAoKSA9PiAoXG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiPlxuICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgIDxyZWN0IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJJY29uQmdcIiBmaWxsPVwiIzQyODVGNFwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHJ4PVwiMTZcIiAvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTAuMzI0IDIzLjNsMy01LjFIMjVsLTMgNS4xSDEwLjMyNHpNMTMgMTguMmwtMyA1LjEtMy01LjEgNS44MzktOS45MjQgMi45OTkgNS4xTDEzIDE4LjJ6bTExLjgzOC0uMjc2aC02TDEzIDhoNmw1Ljg0IDkuOTI0aC0uMDAyelwiIGZpbGw9XCIjRkZGXCIgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgKVxuXG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyBQcm92aWRlcih1cHB5LCB7XG4gICAgICBjb21wYW5pb25Vcmw6IHRoaXMub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICBjb21wYW5pb25IZWFkZXJzOiB0aGlzLm9wdHMuY29tcGFuaW9uSGVhZGVycyB8fCB0aGlzLm9wdHMuc2VydmVySGVhZGVycyxcbiAgICAgIGNvbXBhbmlvbktleXNQYXJhbXM6IHRoaXMub3B0cy5jb21wYW5pb25LZXlzUGFyYW1zLFxuICAgICAgY29tcGFuaW9uQ29va2llc1J1bGU6IHRoaXMub3B0cy5jb21wYW5pb25Db29raWVzUnVsZSxcbiAgICAgIHByb3ZpZGVyOiAnZHJpdmUnLFxuICAgICAgcGx1Z2luSWQ6IHRoaXMuaWQsXG4gICAgfSlcblxuICAgIHRoaXMub25GaXJzdFJlbmRlciA9IHRoaXMub25GaXJzdFJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcgPSBuZXcgRHJpdmVQcm92aWRlclZpZXdzKHRoaXMsIHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgIH0pXG5cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLm9wdHMudGFyZ2V0XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcudGVhckRvd24oKVxuICAgIHRoaXMudW5tb3VudCgpXG4gIH1cblxuICBvbkZpcnN0UmVuZGVyICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5wcm92aWRlci5mZXRjaFByZUF1dGhUb2tlbigpLFxuICAgICAgdGhpcy52aWV3LmdldEZvbGRlcigncm9vdCcsICcvJyksXG4gICAgXSlcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnJlbmRlcihzdGF0ZSlcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9pbmZvcm1lclwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBub3RpZmljYXRpb24gYW5kIGVycm9yIHBvcC11cCBiYXIgZm9yIFVwcHkuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuNi42XCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJzdHlsZVwiOiBcImRpc3Qvc3R5bGUubWluLmNzc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJub3RpZmljYXRpb25cIixcbiAgICBcImJhclwiLFxuICAgIFwidWlcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuLyoqXG4gKiBJbmZvcm1lclxuICogU2hvd3MgcmFkIG1lc3NhZ2UgYnViYmxlc1xuICogdXNlZCBsaWtlIHRoaXM6IGB1cHB5LmluZm8oJ2hlbGxvIHdvcmxkJywgJ2luZm8nLCA1MDAwKWBcbiAqIG9yIGZvciBlcnJvcnM6IGB1cHB5LmluZm8oJ0Vycm9yIHVwbG9hZGluZyBpbWcuanBnJywgJ2Vycm9yJywgNTAwMClgXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEluZm9ybWVyIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMudHlwZSA9ICdwcm9ncmVzc2luZGljYXRvcidcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdJbmZvcm1lcidcbiAgICB0aGlzLnRpdGxlID0gJ0luZm9ybWVyJ1xuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge31cbiAgICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlclxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuICB9XG5cbiAgcmVuZGVyID0gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyBpc0hpZGRlbiwgbWVzc2FnZSwgZGV0YWlscyB9ID0gc3RhdGUuaW5mb1xuXG4gICAgZnVuY3Rpb24gZGlzcGxheUVycm9yQWxlcnQgKCkge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYCR7bWVzc2FnZX0gXFxuXFxuICR7ZGV0YWlsc31gXG4gICAgICBhbGVydChlcnJvck1lc3NhZ2UpXG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlTW91c2VPdmVyID0gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudXBweS5pbmZvVGltZW91dElEKVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZU1vdXNlTGVhdmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnVwcHkuaW5mb1RpbWVvdXRJRCA9IHNldFRpbWVvdXQodGhpcy51cHB5LmhpZGVJbmZvLCAyMDAwKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHkgdXBweS1JbmZvcm1lclwiXG4gICAgICAgIGFyaWEtaGlkZGVuPXtpc0hpZGRlbn1cbiAgICAgID5cbiAgICAgICAgPHAgcm9sZT1cImFsZXJ0XCI+XG4gICAgICAgICAge21lc3NhZ2V9XG4gICAgICAgICAgeycgJ31cbiAgICAgICAgICB7ZGV0YWlscyAmJiAoXG4gICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICBhcmlhLWxhYmVsPXtkZXRhaWxzfVxuICAgICAgICAgICAgICBkYXRhLW1pY3JvdGlwLXBvc2l0aW9uPVwidG9wLWxlZnRcIlxuICAgICAgICAgICAgICBkYXRhLW1pY3JvdGlwLXNpemU9XCJtZWRpdW1cIlxuICAgICAgICAgICAgICByb2xlPVwidG9vbHRpcFwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2Rpc3BsYXlFcnJvckFsZXJ0fVxuICAgICAgICAgICAgICBvbk1vdXNlT3Zlcj17aGFuZGxlTW91c2VPdmVyfVxuICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9e2hhbmRsZU1vdXNlTGVhdmV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgID9cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICApfVxuICAgICAgICA8L3A+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLm9wdHMudGFyZ2V0XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L2luc3RhZ3JhbVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiSW1wb3J0IHBob3RvcyBhbmQgdmlkZW9zIGZyb20gSW5zdGFncmFtLCBpbnRvIFVwcHkuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuNS4yXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwiaW5zdGFncmFtXCIsXG4gICAgXCJwcm92aWRlclwiLFxuICAgIFwicGhvdG9zXCIsXG4gICAgXCJ2aWRlb3NcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvbXBhbmlvbi1jbGllbnRcIjogXCJmaWxlOi4uL2NvbXBhbmlvbi1jbGllbnRcIixcbiAgICBcIkB1cHB5L3Byb3ZpZGVyLXZpZXdzXCI6IFwiZmlsZTouLi9wcm92aWRlci12aWV3c1wiLFxuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgeyBQcm92aWRlciB9ID0gcmVxdWlyZSgnQHVwcHkvY29tcGFuaW9uLWNsaWVudCcpXG5jb25zdCB7IFByb3ZpZGVyVmlld3MgfSA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBJbnN0YWdyYW0gZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnSW5zdGFncmFtJ1xuICAgIFByb3ZpZGVyLmluaXRQbHVnaW4odGhpcywgb3B0cylcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdJbnN0YWdyYW0nXG4gICAgdGhpcy5pY29uID0gKCkgPT4gKFxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIj5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgZmlsbD1cIiNFMTMwNkNcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiByeD1cIjE2XCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTE2IDguNjIyYzIuNDAzIDAgMi42ODguMDA5IDMuNjM3LjA1Mi44NzcuMDQgMS4zNTQuMTg3IDEuNjcuMzEuMzkyLjE0NC43NDUuMzc0IDEuMDM2LjY3My4yOTkuMjkuNTI5LjY0NC42NzMgMS4wMzUuMTIzLjMxNy4yNy43OTQuMzEgMS42NzEuMDQzLjk1LjA1MiAxLjIzNC4wNTIgMy42MzdzLS4wMDkgMi42ODgtLjA1MiAzLjYzN2MtLjA0Ljg3Ny0uMTg3IDEuMzU0LS4zMSAxLjY3MWEyLjk4IDIuOTggMCAwIDEtMS43MDggMS43MDhjLS4zMTcuMTIzLS43OTQuMjctMS42NzEuMzEtLjk1LjA0My0xLjIzNC4wNTMtMy42MzcuMDUzcy0yLjY4OC0uMDEtMy42MzctLjA1M2MtLjg3Ny0uMDQtMS4zNTQtLjE4Ny0xLjY3MS0uMzFhMi43ODggMi43ODggMCAwIDEtMS4wMzUtLjY3MyAyLjc4OCAyLjc4OCAwIDAgMS0uNjczLTEuMDM1Yy0uMTIzLS4zMTctLjI3LS43OTQtLjMxLTEuNjcxLS4wNDMtLjk0OS0uMDUyLTEuMjM0LS4wNTItMy42MzdzLjAwOS0yLjY4OC4wNTItMy42MzdjLjA0LS44NzcuMTg3LTEuMzU0LjMxLTEuNjcuMTQ0LS4zOTIuMzc0LS43NDUuNjczLTEuMDM2LjI5LS4yOTkuNjQ0LS41MjkgMS4wMzUtLjY3My4zMTctLjEyMy43OTQtLjI3IDEuNjcxLS4zMS45NS0uMDQzIDEuMjM0LS4wNTIgMy42MzctLjA1MnpNMTYgN2MtMi40NDQgMC0yLjc1LjAxLTMuNzEuMDU0LS45NTkuMDQ0LTEuNjEzLjE5Ni0yLjE4NS40MTktLjYuMjI1LTEuMTQ1LjU4LTEuNTk0IDEuMDM4LS40NTguNDUtLjgxMy45OTMtMS4wMzkgMS41OTQtLjIyMi41NzItLjM3NCAxLjIyNi0uNDE4IDIuMTg0QzcuMDEgMTMuMjUgNyAxMy41NTYgNyAxNnMuMDEgMi43NS4wNTQgMy43MWMuMDQ0Ljk1OS4xOTYgMS42MTMuNDE5IDIuMTg1LjIyNi42LjU4IDEuMTQ1IDEuMDM4IDEuNTk0LjQ1LjQ1OC45OTMuODEzIDEuNTk0IDEuMDM4LjU3Mi4yMjMgMS4yMjcuMzc1IDIuMTg0LjQxOS45Ni4wNDQgMS4yNjcuMDU0IDMuNzExLjA1NHMyLjc1LS4wMSAzLjcxLS4wNTRjLjk1OS0uMDQ0IDEuNjEzLS4xOTYgMi4xODUtLjQxOWE0LjYwMiA0LjYwMiAwIDAgMCAyLjYzMi0yLjYzMmMuMjIzLS41NzIuMzc1LTEuMjI2LjQxOS0yLjE4NC4wNDQtLjk2LjA1NC0xLjI2Ny4wNTQtMy43MTFzLS4wMS0yLjc1LS4wNTQtMy43MWMtLjA0NC0uOTU5LS4xOTYtMS42MTMtLjQxOS0yLjE4NUE0LjQxMiA0LjQxMiAwIDAgMCAyMy40OSA4LjUxYTQuNDEyIDQuNDEyIDAgMCAwLTEuNTk0LTEuMDM5Yy0uNTcyLS4yMjItMS4yMjYtLjM3NC0yLjE4NC0uNDE4QzE4Ljc1IDcuMDEgMTguNDQ0IDcgMTYgN3ptMCA0LjVhNC41IDQuNSAwIDEgMCAwIDkgNC41IDQuNSAwIDAgMCAwLTl6bTAgNy40MjFhMi45MjEgMi45MjEgMCAxIDEgMC01Ljg0MiAyLjkyMSAyLjkyMSAwIDAgMSAwIDUuODQyem00Ljg3NS02LjY3MWExLjEyNSAxLjEyNSAwIDEgMSAwLTIuMjUgMS4xMjUgMS4xMjUgMCAwIDEgMCAyLjI1elwiIGZpbGw9XCIjRkZGXCIgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgKVxuXG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyBQcm92aWRlcih1cHB5LCB7XG4gICAgICBjb21wYW5pb25Vcmw6IHRoaXMub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICBjb21wYW5pb25IZWFkZXJzOiB0aGlzLm9wdHMuY29tcGFuaW9uSGVhZGVycyB8fCB0aGlzLm9wdHMuc2VydmVySGVhZGVycyxcbiAgICAgIGNvbXBhbmlvbktleXNQYXJhbXM6IHRoaXMub3B0cy5jb21wYW5pb25LZXlzUGFyYW1zLFxuICAgICAgY29tcGFuaW9uQ29va2llc1J1bGU6IHRoaXMub3B0cy5jb21wYW5pb25Db29raWVzUnVsZSxcbiAgICAgIHByb3ZpZGVyOiAnaW5zdGFncmFtJyxcbiAgICAgIHBsdWdpbklkOiB0aGlzLmlkLFxuICAgIH0pXG5cbiAgICB0aGlzLm9uRmlyc3RSZW5kZXIgPSB0aGlzLm9uRmlyc3RSZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3ID0gbmV3IFByb3ZpZGVyVmlld3ModGhpcywge1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICB2aWV3VHlwZTogJ2dyaWQnLFxuICAgICAgc2hvd1RpdGxlczogZmFsc2UsXG4gICAgICBzaG93RmlsdGVyOiBmYWxzZSxcbiAgICAgIHNob3dCcmVhZGNydW1iczogZmFsc2UsXG4gICAgfSlcblxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0cy50YXJnZXRcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1vdW50KHRhcmdldCwgdGhpcylcbiAgICB9XG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldy50ZWFyRG93bigpXG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxuXG4gIG9uRmlyc3RSZW5kZXIgKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnByb3ZpZGVyLmZldGNoUHJlQXV0aFRva2VuKCksXG4gICAgICB0aGlzLnZpZXcuZ2V0Rm9sZGVyKCdyZWNlbnQnKSxcbiAgICBdKVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyKHN0YXRlKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L29uZWRyaXZlXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJJbXBvcnQgZmlsZXMgZnJvbSBPbmVEcml2ZSwgaW50byBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIxLjIuMlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcIm9uZWRyaXZlXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgeyBQcm92aWRlclZpZXdzIH0gPSByZXF1aXJlKCdAdXBweS9wcm92aWRlci12aWV3cycpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgT25lRHJpdmUgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnT25lRHJpdmUnXG4gICAgUHJvdmlkZXIuaW5pdFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ09uZURyaXZlJ1xuICAgIHRoaXMuaWNvbiA9ICgpID0+IChcbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHJ4PVwiMTZcIiBmaWxsPVwiIzAyNjJDMFwiIC8+XG4gICAgICAgICAgPGcgZmlsbD1cIiNGRkZcIiBmaWxsUnVsZT1cIm5vbnplcm9cIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMjQuMTU3IDIyczEuNDkyLS4yMDUgMS43OS0xLjY1NWEyLjYyNCAyLjYyNCAwIDAgMCAuMDMtLjg3OGMtLjIyLTEuNjQtMS45ODgtMi4wMS0xLjk4OC0yLjAxcy4zMDctMS43NjUtMS4zMTItMi42OWMtMS42Mi0uOTI1LTMuMSAwLTMuMSAwUzE4LjcxMSAxMyAxNi4zNjYgMTNjLTMuMDE2IDAtMy41MTkgMy40NDgtMy41MTkgMy40NDhTMTAgMTYuNjE4IDEwIDE5LjE0YzAgMi41MjMgMi41OTcgMi44NiAyLjU5NyAyLjg2aDExLjU2elwiIC8+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTkuNDIxIDE5LjI0NmMwLTIuMTk3IDEuNjA2LTMuMTU5IDIuODcxLTMuNDcyLjQ0LTEuNDc3IDEuNjU0LTMuNDM5IDQuMTM1LTMuNDM5SDE2LjQ0NWMxLjcyMSAwIDIuNzkuODIzIDMuMzY4IDEuNDc2YTMuOTkgMy45OSAwIDAgMSAxLjE0Ny0uMTcxaC4wMWwuMDMuMDAyQzIxLjAxNyAxMy41IDIwLjY5MSAxMCAxNi43NTcgMTBjLTIuNjkgMC0zLjYzOSAyLjM0NS0zLjYzOSAyLjM0NXMtMS45NS0xLjQ4Mi0zLjk1NS41NjdjLTEuMDI4IDEuMDUyLS43OSAyLjY2OS0uNzkgMi42NjlTNiAxNS44MjQgNiAxOC40MTJDNiAyMC43NTcgOC40NTIgMjEgOC40NTIgMjFoMS4zNzJhMy43NyAzLjc3IDAgMCAxLS40MDMtMS43NTR6XCIgLz5cbiAgICAgICAgICA8L2c+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMgfHwgdGhpcy5vcHRzLnNlcnZlckhlYWRlcnMsXG4gICAgICBjb21wYW5pb25Db29raWVzUnVsZTogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlLFxuICAgICAgcHJvdmlkZXI6ICdvbmVkcml2ZScsXG4gICAgICBwbHVnaW5JZDogdGhpcy5pZCxcbiAgICB9KVxuXG4gICAgdGhpcy5vbkZpcnN0UmVuZGVyID0gdGhpcy5vbkZpcnN0UmVuZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldyA9IG5ldyBQcm92aWRlclZpZXdzKHRoaXMsIHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgIH0pXG5cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLm9wdHMudGFyZ2V0XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcudGVhckRvd24oKVxuICAgIHRoaXMudW5tb3VudCgpXG4gIH1cblxuICBvbkZpcnN0UmVuZGVyICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5wcm92aWRlci5mZXRjaFByZUF1dGhUb2tlbigpLFxuICAgICAgdGhpcy52aWV3LmdldEZvbGRlcigpLFxuICAgIF0pXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5yZW5kZXIoc3RhdGUpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvcHJvdmlkZXItdmlld3NcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlZpZXcgbGlicmFyeSBmb3IgVXBweSByZW1vdGUgcHJvdmlkZXIgcGx1Z2lucy5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4xMi4zXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJzdHlsZVwiOiBcImRpc3Qvc3R5bGUubWluLmNzc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwiY2xhc3NuYW1lc1wiOiBcIl4yLjIuNlwiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuLy8gVE9ETyB1c2UgRnJhZ21lbnQgd2hlbiB1cGdyYWRpbmcgdG8gcHJlYWN0IFhcbmNvbnN0IEJyZWFkY3J1bWIgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3Bhbj5cbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldFwiXG4gICAgICAgIG9uQ2xpY2s9e3Byb3BzLmdldEZvbGRlcn1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLnRpdGxlfVxuICAgICAgPC9idXR0b24+XG4gICAgICB7IXByb3BzLmlzTGFzdCA/ICcgLyAnIDogJyd9XG4gICAgPC9zcGFuPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyLWJyZWFkY3J1bWJzXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItYnJlYWRjcnVtYnNJY29uXCI+e3Byb3BzLmJyZWFkY3J1bWJzSWNvbn08L2Rpdj5cbiAgICAgIHtcbiAgICAgICAgcHJvcHMuZGlyZWN0b3JpZXMubWFwKChkaXJlY3RvcnksIGkpID0+IChcbiAgICAgICAgICA8QnJlYWRjcnVtYlxuICAgICAgICAgICAga2V5PXtkaXJlY3RvcnkuaWR9XG4gICAgICAgICAgICBnZXRGb2xkZXI9eygpID0+IHByb3BzLmdldEZvbGRlcihkaXJlY3RvcnkuaWQpfVxuICAgICAgICAgICAgdGl0bGU9e2kgPT09IDAgPyBwcm9wcy50aXRsZSA6IGRpcmVjdG9yeS50aXRsZX1cbiAgICAgICAgICAgIGlzTGFzdD17aSArIDEgPT09IHByb3BzLmRpcmVjdG9yaWVzLmxlbmd0aH1cbiAgICAgICAgICAvPlxuICAgICAgICApKVxuICAgICAgfVxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBGaWx0ZXIgPSByZXF1aXJlKCcuL0ZpbHRlcicpXG5jb25zdCBJdGVtTGlzdCA9IHJlcXVpcmUoJy4vSXRlbUxpc3QnKVxuY29uc3QgRm9vdGVyQWN0aW9ucyA9IHJlcXVpcmUoJy4vRm9vdGVyQWN0aW9ucycpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNvbnN0IEJyb3dzZXIgPSAocHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIGN1cnJlbnRTZWxlY3Rpb24sXG4gICAgZm9sZGVycyxcbiAgICBmaWxlcyxcbiAgICB1cHB5RmlsZXMsXG4gICAgZmlsdGVySXRlbXMsXG4gICAgZmlsdGVySW5wdXQsXG4gIH0gPSBwcm9wc1xuXG4gIGxldCBmaWx0ZXJlZEZvbGRlcnMgPSBmb2xkZXJzXG4gIGxldCBmaWx0ZXJlZEZpbGVzID0gZmlsZXNcblxuICBpZiAoZmlsdGVySW5wdXQgIT09ICcnKSB7XG4gICAgZmlsdGVyZWRGb2xkZXJzID0gZmlsdGVySXRlbXMoZm9sZGVycylcbiAgICBmaWx0ZXJlZEZpbGVzID0gZmlsdGVySXRlbXMoZmlsZXMpXG4gIH1cblxuICBjb25zdCBzZWxlY3RlZCA9IGN1cnJlbnRTZWxlY3Rpb24ubGVuZ3RoXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lcygndXBweS1Qcm92aWRlckJyb3dzZXInLCBgdXBweS1Qcm92aWRlckJyb3dzZXItdmlld1R5cGUtLSR7cHJvcHMudmlld1R5cGV9YCl9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlci1oZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3VwcHktUHJvdmlkZXJCcm93c2VyLWhlYWRlckJhcicsICFwcm9wcy5zaG93QnJlYWRjcnVtYnMgJiYgJ3VwcHktUHJvdmlkZXJCcm93c2VyLWhlYWRlckJhci0tc2ltcGxlJyl9PlxuICAgICAgICAgIHtwcm9wcy5oZWFkZXJDb21wb25lbnR9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICB7cHJvcHMuc2hvd0ZpbHRlciAmJiA8RmlsdGVyIHsuLi5wcm9wc30gLz59XG4gICAgICA8SXRlbUxpc3RcbiAgICAgICAgY29sdW1ucz17W3tcbiAgICAgICAgICBuYW1lOiAnTmFtZScsXG4gICAgICAgICAga2V5OiAndGl0bGUnLFxuICAgICAgICB9XX1cbiAgICAgICAgZm9sZGVycz17ZmlsdGVyZWRGb2xkZXJzfVxuICAgICAgICBmaWxlcz17ZmlsdGVyZWRGaWxlc31cbiAgICAgICAgc29ydEJ5VGl0bGU9e3Byb3BzLnNvcnRCeVRpdGxlfVxuICAgICAgICBzb3J0QnlEYXRlPXtwcm9wcy5zb3J0QnlEYXRlfVxuICAgICAgICBpc0NoZWNrZWQ9e3Byb3BzLmlzQ2hlY2tlZH1cbiAgICAgICAgaGFuZGxlRm9sZGVyQ2xpY2s9e3Byb3BzLmdldE5leHRGb2xkZXJ9XG4gICAgICAgIHRvZ2dsZUNoZWNrYm94PXtwcm9wcy50b2dnbGVDaGVja2JveH1cbiAgICAgICAgaGFuZGxlU2Nyb2xsPXtwcm9wcy5oYW5kbGVTY3JvbGx9XG4gICAgICAgIHRpdGxlPXtwcm9wcy50aXRsZX1cbiAgICAgICAgc2hvd1RpdGxlcz17cHJvcHMuc2hvd1RpdGxlc31cbiAgICAgICAgaTE4bj17cHJvcHMuaTE4bn1cbiAgICAgICAgdmlld1R5cGU9e3Byb3BzLnZpZXdUeXBlfVxuICAgICAgICB2YWxpZGF0ZVJlc3RyaWN0aW9ucz17cHJvcHMudmFsaWRhdGVSZXN0cmljdGlvbnN9XG4gICAgICAgIHVwcHlGaWxlcz17dXBweUZpbGVzfVxuICAgICAgICBjdXJyZW50U2VsZWN0aW9uPXtjdXJyZW50U2VsZWN0aW9ufVxuICAgICAgLz5cbiAgICAgIHtzZWxlY3RlZCA+IDAgJiYgPEZvb3RlckFjdGlvbnMgc2VsZWN0ZWQ9e3NlbGVjdGVkfSB7Li4ucHJvcHN9IC8+fVxuICAgIDwvZGl2PlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnJvd3NlclxuIiwiY29uc3QgeyBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ2xvc2VXcmFwcGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIHRoaXMucHJvcHMub25Vbm1vdW50KClcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW5bMF1cbiAgfVxufVxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRmlsdGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5wcmV2ZW50RW50ZXJQcmVzcyA9IHRoaXMucHJldmVudEVudGVyUHJlc3MuYmluZCh0aGlzKVxuICB9XG5cbiAgcHJldmVudEVudGVyUHJlc3MgKGV2KSB7XG4gICAgaWYgKGV2LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgZXYucHJldmVudERlZmF1bHQoKVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXItc2VhcmNoXCI+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlci1zZWFyY2hJbnB1dFwiXG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPXt0aGlzLnByb3BzLmkxOG4oJ2ZpbHRlcicpfVxuICAgICAgICAgIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuaTE4bignZmlsdGVyJyl9XG4gICAgICAgICAgb25LZXlVcD17dGhpcy5wcmV2ZW50RW50ZXJQcmVzc31cbiAgICAgICAgICBvbktleURvd249e3RoaXMucHJldmVudEVudGVyUHJlc3N9XG4gICAgICAgICAgb25LZXlQcmVzcz17dGhpcy5wcmV2ZW50RW50ZXJQcmVzc31cbiAgICAgICAgICBvbklucHV0PXsoZSkgPT4gdGhpcy5wcm9wcy5maWx0ZXJRdWVyeShlKX1cbiAgICAgICAgICB2YWx1ZT17dGhpcy5wcm9wcy5maWx0ZXJJbnB1dH1cbiAgICAgICAgLz5cbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uIHVwcHktUHJvdmlkZXJCcm93c2VyLXNlYXJjaEljb25cIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiMTJcIiB2aWV3Qm94PVwiMCAwIDEyIDEyXCI+XG4gICAgICAgICAgPHBhdGggZD1cIk04LjYzOCA3Ljk5bDMuMTcyIDMuMTcyYS40OTIuNDkyIDAgMSAxLS42OTcuNjk3TDcuOTEgOC42NTZhNC45NzcgNC45NzcgMCAwIDEtMi45ODMuOTgzQzIuMjA2IDkuNjM5IDAgNy40ODEgMCA0LjgxOSAwIDIuMTU4IDIuMjA2IDAgNC45MjcgMGMyLjcyMSAwIDQuOTI3IDIuMTU4IDQuOTI3IDQuODJhNC43NCA0Ljc0IDAgMCAxLTEuMjE2IDMuMTd6bS0zLjcxLjY4NWMyLjE3NiAwIDMuOTQtMS43MjYgMy45NC0zLjg1NiAwLTIuMTI5LTEuNzY0LTMuODU1LTMuOTQtMy44NTVDMi43NS45NjQuOTg0IDIuNjkuOTg0IDQuODE5YzAgMi4xMyAxLjc2NSAzLjg1NiAzLjk0MiAzLjg1NnpcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAge3RoaXMucHJvcHMuZmlsdGVySW5wdXQgJiYgKFxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlci1zZWFyY2hDbG9zZVwiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuaTE4bigncmVzZXRGaWx0ZXInKX1cbiAgICAgICAgICAgIHRpdGxlPXt0aGlzLnByb3BzLmkxOG4oJ3Jlc2V0RmlsdGVyJyl9XG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLnByb3BzLmZpbHRlclF1ZXJ5fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHZpZXdCb3g9XCIwIDAgMTkgMTlcIj5cbiAgICAgICAgICAgICAgPHBhdGggZD1cIk0xNy4zMTggMTcuMjMyTDkuOTQgOS44NTQgOS41ODYgOS41bC0uMzU0LjM1NC03LjM3OCA3LjM3OGguNzA3bC0uNjItLjYydi43MDZMOS4zMTggOS45NGwuMzU0LS4zNTQtLjM1NC0uMzU0TDEuOTQgMS44NTR2LjcwN2wuNjItLjYyaC0uNzA2bDcuMzc4IDcuMzc4LjM1NC4zNTQuMzU0LS4zNTQgNy4zNzgtNy4zNzhoLS43MDdsLjYyMi42MnYtLjcwNkw5Ljg1NCA5LjIzMmwtLjM1NC4zNTQuMzU0LjM1NCA3LjM3OCA3LjM3OC43MDgtLjcwNy03LjM4LTcuMzc4di43MDhsNy4zOC03LjM4LjM1My0uMzUzLS4zNTMtLjM1My0uNjIyLS42MjItLjM1My0uMzUzLS4zNTQuMzUyLTcuMzc4IDcuMzhoLjcwOEwyLjU2IDEuMjMgMi4yMDguODhsLS4zNTMuMzUzLS42MjIuNjItLjM1My4zNTUuMzUyLjM1MyA3LjM4IDcuMzh2LS43MDhsLTcuMzggNy4zOC0uMzUzLjM1My4zNTIuMzUzLjYyMi42MjIuMzUzLjM1My4zNTQtLjM1MyA3LjM4LTcuMzhoLS43MDhsNy4zOCA3LjM4elwiIC8+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXItZm9vdGVyXCI+XG4gICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tcHJpbWFyeVwiIG9uQ2xpY2s9e3Byb3BzLmRvbmV9PlxuICAgICAgICB7cHJvcHMuaTE4bignc2VsZWN0WCcsIHtcbiAgICAgICAgICBzbWFydF9jb3VudDogcHJvcHMuc2VsZWN0ZWQsXG4gICAgICAgIH0pfVxuICAgICAgPC9idXR0b24+XG4gICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tbGlua1wiIG9uQ2xpY2s9e3Byb3BzLmNhbmNlbH0+XG4gICAgICAgIHtwcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbi8vIGl0IGNvdWxkIGJlIGEgPGxpPjxidXR0b24gY2xhc3M9XCJmYWtlLWNoZWNrYm94XCIvPiA8YnV0dG9uLz48L2xpPlxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8bGkgY2xhc3NOYW1lPXtwcm9wcy5jbGFzc05hbWV9IHRpdGxlPXtwcm9wcy5pc0Rpc2FibGVkID8gcHJvcHMucmVzdHJpY3Rpb25SZWFzb24gOiBudWxsfT5cbiAgICAgIDxkaXYgYXJpYS1oaWRkZW4gY2xhc3NOYW1lPXtgdXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWZha2VDaGVja2JveCAke3Byb3BzLmlzQ2hlY2tlZCA/ICd1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tZmFrZUNoZWNrYm94LS1pcy1jaGVja2VkJyA6ICcnfWB9IC8+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWlubmVyXCJcbiAgICAgICAgb25DbGljaz17cHJvcHMudG9nZ2xlQ2hlY2tib3h9XG4gICAgICAgIHJvbGU9XCJvcHRpb25cIlxuICAgICAgICBhcmlhLWxhYmVsPXtwcm9wcy5pc0NoZWNrZWQgPyBwcm9wcy5pMThuKCd1bnNlbGVjdEZpbGVOYW1lZCcsIHsgbmFtZTogcHJvcHMudGl0bGUgfSkgOiBwcm9wcy5pMThuKCdzZWxlY3RGaWxlTmFtZWQnLCB7IG5hbWU6IHByb3BzLnRpdGxlIH0pfVxuICAgICAgICBhcmlhLXNlbGVjdGVkPXtwcm9wcy5pc0NoZWNrZWR9XG4gICAgICAgIGFyaWEtZGlzYWJsZWQ9e3Byb3BzLmlzRGlzYWJsZWR9XG4gICAgICAgIGRpc2FibGVkPXtwcm9wcy5pc0Rpc2FibGVkfVxuICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICA+XG4gICAgICAgIHtwcm9wcy5pdGVtSWNvbkVsfVxuICAgICAgICB7cHJvcHMuc2hvd1RpdGxlcyAmJiBwcm9wcy50aXRsZX1cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvbGk+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuZnVuY3Rpb24gRmlsZUljb24gKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPXsxMX0gaGVpZ2h0PXsxNC41fSB2aWV3Qm94PVwiMCAwIDQ0IDU4XCI+XG4gICAgICA8cGF0aCBkPVwiTTI3LjQzNy41MTdhMSAxIDAgMCAwLS4wOTQuMDNINC4yNUMyLjAzNy41NDguMjE3IDIuMzY4LjIxNyA0LjU4djQ4LjQwNWMwIDIuMjEyIDEuODIgNC4wMyA0LjAzIDQuMDNIMzkuMDNjMi4yMSAwIDQuMDMtMS44MTggNC4wMy00LjAzVjE1LjYxYTEgMSAwIDAgMC0uMDMtLjI4IDEgMSAwIDAgMCAwLS4wOTMgMSAxIDAgMCAwLS4wMy0uMDMyIDEgMSAwIDAgMCAwLS4wMyAxIDEgMCAwIDAtLjAzMi0uMDYzIDEgMSAwIDAgMC0uMDMtLjA2MyAxIDEgMCAwIDAtLjAzMiAwIDEgMSAwIDAgMC0uMDMtLjA2MyAxIDEgMCAwIDAtLjAzMi0uMDMgMSAxIDAgMCAwLS4wMy0uMDYzIDEgMSAwIDAgMC0uMDYzLS4wNjJsLTE0LjU5My0xNGExIDEgMCAwIDAtLjA2Mi0uMDYyQTEgMSAwIDAgMCAyOCAuNzA4YTEgMSAwIDAgMC0uMzc0LS4xNTcgMSAxIDAgMCAwLS4xNTYgMCAxIDEgMCAwIDAtLjAzLS4wM2wtLjAwMy0uMDAzek00LjI1IDIuNTQ3aDIyLjIxOHY5Ljk3YzAgMi4yMSAxLjgyIDQuMDMgNC4wMyA0LjAzaDEwLjU2NHYzNi40MzhhMi4wMiAyLjAyIDAgMCAxLTIuMDMyIDIuMDMySDQuMjVjLTEuMTMgMC0yLjAzMi0uOS0yLjAzMi0yLjAzMlY0LjU4YzAtMS4xMy45MDItMi4wMzIgMi4wMy0yLjAzMnptMjQuMjE4IDEuMzQ1bDEwLjM3NSA5LjkzNy43NS43MThIMzAuNWMtMS4xMyAwLTIuMDMyLS45LTIuMDMyLTIuMDNWMy44OXpcIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIEZvbGRlckljb24gKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHN0eWxlPXt7IG1pbldpZHRoOiAxNiwgbWFyZ2luUmlnaHQ6IDMgfX0gdmlld0JveD1cIjAgMCAyNzYuMTU3IDI3Ni4xNTdcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMjczLjA4IDEwMS4zNzhjLTMuMy00LjY1LTguODYtNy4zMi0xNS4yNTQtNy4zMmgtMjQuMzRWNjcuNTljMC0xMC4yLTguMy0xOC41LTE4LjUtMTguNWgtODUuMzIyYy0zLjYzIDAtOS4yOTUtMi44NzUtMTEuNDM2LTUuODA1bC02LjM4Ni04LjczNWMtNC45ODItNi44MTQtMTUuMTA0LTExLjk1NC0yMy41NDYtMTEuOTU0SDU4LjczYy05LjI5MiAwLTE4LjYzOCA2LjYwOC0yMS43MzcgMTUuMzcybC0yLjAzMyA1Ljc1MmMtLjk1OCAyLjcxLTQuNzIgNS4zNy03LjU5NiA1LjM3SDE4LjVDOC4zIDQ5LjA5IDAgNTcuMzkgMCA2Ny41OXYxNjcuMDdjMCAuODg2LjE2IDEuNzMuNDQzIDIuNTIuMTUyIDMuMzA2IDEuMTggNi40MjQgMy4wNTMgOS4wNjQgMy4zIDQuNjUyIDguODYgNy4zMiAxNS4yNTUgNy4zMmgxODguNDg3YzExLjM5NSAwIDIzLjI3LTguNDI1IDI3LjAzNS0xOS4xOGw0MC42NzctMTE2LjE4OGMyLjExLTYuMDM1IDEuNDMtMTIuMTY0LTEuODctMTYuODE2ek0xOC41IDY0LjA4OGg4Ljg2NGM5LjI5NSAwIDE4LjY0LTYuNjA3IDIxLjczOC0xNS4zN2wyLjAzMi01Ljc1Yy45Ni0yLjcxMiA0LjcyMi01LjM3MyA3LjU5Ny01LjM3M2gyOS41NjVjMy42MyAwIDkuMjk1IDIuODc2IDExLjQzNyA1LjgwNmw2LjM4NiA4LjczNWM0Ljk4MiA2LjgxNSAxNS4xMDQgMTEuOTU0IDIzLjU0NiAxMS45NTRoODUuMzIyYzEuODk4IDAgMy41IDEuNjAyIDMuNSAzLjV2MjYuNDdINjkuMzRjLTExLjM5NSAwLTIzLjI3IDguNDIzLTI3LjAzNSAxOS4xNzhMMTUgMTkxLjIzVjY3LjU5YzAtMS44OTggMS42MDMtMy41IDMuNS0zLjV6bTI0Mi4yOSA0OS4xNWwtNDAuNjc2IDExNi4xODhjLTEuNjc0IDQuNzgtNy44MTIgOS4xMzUtMTIuODc3IDkuMTM1SDE4Ljc1Yy0xLjQ0NyAwLTIuNTc2LS4zNzItMy4wMi0uOTk3LS40NDItLjYyNS0uNDIyLTEuODE0LjA1Ny0zLjE4bDQwLjY3Ny0xMTYuMTljMS42NzQtNC43OCA3LjgxMi05LjEzNCAxMi44NzctOS4xMzRoMTg4LjQ4N2MxLjQ0OCAwIDIuNTc3LjM3MiAzLjAyLjk5Ny40NDMuNjI1LjQyMyAxLjgxNC0uMDU2IDMuMTh6XCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBWaWRlb0ljb24gKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBzdHlsZT17eyB3aWR0aDogMTYsIG1hcmdpblJpZ2h0OiA0IH19IHZpZXdCb3g9XCIwIDAgNTggNThcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMzYuNTM3IDI4LjE1NmwtMTEtN2ExLjAwNSAxLjAwNSAwIDAgMC0xLjAyLS4wMzNDMjQuMiAyMS4zIDI0IDIxLjYzNSAyNCAyMnYxNGExIDEgMCAwIDAgMS41MzcuODQ0bDExLTdhMS4wMDIgMS4wMDIgMCAwIDAgMC0xLjY4OHpNMjYgMzQuMThWMjMuODJMMzQuMTM3IDI5IDI2IDM0LjE4elwiIC8+XG4gICAgICA8cGF0aCBkPVwiTTU3IDZIMWExIDEgMCAwIDAtMSAxdjQ0YTEgMSAwIDAgMCAxIDFoNTZhMSAxIDAgMCAwIDEtMVY3YTEgMSAwIDAgMC0xLTF6TTEwIDI4SDJ2LTloOHY5em0tOCAyaDh2OUgydi05em0xMCAxMFY4aDM0djQySDEyVjQwem00NC0xMmgtOHYtOWg4djl6bS04IDJoOHY5aC04di05em04LTIydjloLThWOGg4ek0yIDhoOHY5SDJWOHptMCA0MnYtOWg4djlIMnptNTQgMGgtOHYtOWg4djl6XCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBpZiAocHJvcHMuaXRlbUljb25TdHJpbmcgPT09IG51bGwpIHJldHVyblxuXG4gIHN3aXRjaCAocHJvcHMuaXRlbUljb25TdHJpbmcpIHtcbiAgICBjYXNlICdmaWxlJzpcbiAgICAgIHJldHVybiA8RmlsZUljb24gLz5cbiAgICBjYXNlICdmb2xkZXInOlxuICAgICAgcmV0dXJuIDxGb2xkZXJJY29uIC8+XG4gICAgY2FzZSAndmlkZW8nOlxuICAgICAgcmV0dXJuIDxWaWRlb0ljb24gLz5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDxpbWcgc3JjPXtwcm9wcy5pdGVtSWNvblN0cmluZ30gLz5cbiAgfVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5jb25zdCBnZXRBcmlhTGFiZWxPZkNoZWNrYm94ID0gKHByb3BzKSA9PiB7XG4gIGlmIChwcm9wcy50eXBlID09PSAnZm9sZGVyJykge1xuICAgIGlmIChwcm9wcy5pc0NoZWNrZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcy5pMThuKCd1bnNlbGVjdEFsbEZpbGVzRnJvbUZvbGRlck5hbWVkJywgeyBuYW1lOiBwcm9wcy50aXRsZSB9KVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHMuaTE4bignc2VsZWN0QWxsRmlsZXNGcm9tRm9sZGVyTmFtZWQnLCB7IG5hbWU6IHByb3BzLnRpdGxlIH0pXG4gIH1cbiAgaWYgKHByb3BzLmlzQ2hlY2tlZCkge1xuICAgIHJldHVybiBwcm9wcy5pMThuKCd1bnNlbGVjdEZpbGVOYW1lZCcsIHsgbmFtZTogcHJvcHMudGl0bGUgfSlcbiAgfVxuICByZXR1cm4gcHJvcHMuaTE4bignc2VsZWN0RmlsZU5hbWVkJywgeyBuYW1lOiBwcm9wcy50aXRsZSB9KVxufVxuXG4vLyBpZiBmb2xkZXI6XG4vLyAgICsgY2hlY2tib3ggKHNlbGVjdHMgYWxsIGZpbGVzIGZyb20gZm9sZGVyKVxuLy8gICArIGZvbGRlciBuYW1lIChvcGVucyBmb2xkZXIpXG4vLyBpZiBmaWxlOlxuLy8gICArIGNoZWNrYm94IChzZWxlY3RzIGZpbGUpXG4vLyAgICsgZmlsZSBuYW1lIChzZWxlY3RzIGZpbGUpXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxsaSBjbGFzc05hbWU9e3Byb3BzLmNsYXNzTmFtZX0gdGl0bGU9e3Byb3BzLmlzRGlzYWJsZWQgPyBwcm9wcy5yZXN0cmljdGlvblJlYXNvbiA6IG51bGx9PlxuICAgICAgeyFwcm9wcy5pc0NoZWNrYm94RGlzYWJsZWQgPyAoXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzc05hbWU9e2B1cHB5LXUtcmVzZXQgdXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWZha2VDaGVja2JveCAke3Byb3BzLmlzQ2hlY2tlZCA/ICd1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tZmFrZUNoZWNrYm94LS1pcy1jaGVja2VkJyA6ICcnfWB9XG4gICAgICAgICAgb25DbGljaz17cHJvcHMudG9nZ2xlQ2hlY2tib3h9XG4gICAgICAgICAgLy8gZm9yIHRoZSA8bGFiZWwvPlxuICAgICAgICAgIGlkPXtwcm9wcy5pZH1cbiAgICAgICAgICByb2xlPVwib3B0aW9uXCJcbiAgICAgICAgICBhcmlhLWxhYmVsPXtnZXRBcmlhTGFiZWxPZkNoZWNrYm94KHByb3BzKX1cbiAgICAgICAgICBhcmlhLXNlbGVjdGVkPXtwcm9wcy5pc0NoZWNrZWR9XG4gICAgICAgICAgYXJpYS1kaXNhYmxlZD17cHJvcHMuaXNEaXNhYmxlZH1cbiAgICAgICAgICBkaXNhYmxlZD17cHJvcHMuaXNEaXNhYmxlZH1cbiAgICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICAgIC8+XG4gICAgICApIDogbnVsbH1cblxuICAgICAge3Byb3BzLnR5cGUgPT09ICdmaWxlJyA/IChcbiAgICAgICAgLy8gbGFiZWwgZm9yIGEgY2hlY2tib3hcbiAgICAgICAgPGxhYmVsIGh0bWxGb3I9e3Byb3BzLmlkfSBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWlubmVyXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0taWNvbldyYXBcIj5cbiAgICAgICAgICAgIHtwcm9wcy5pdGVtSWNvbkVsfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHtwcm9wcy5zaG93VGl0bGVzICYmIHByb3BzLnRpdGxlfVxuICAgICAgICA8L2xhYmVsPlxuICAgICAgKSA6IChcbiAgICAgICAgLy8gYnV0dG9uIHRvIG9wZW4gYSBmb2xkZXJcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0taW5uZXJcIlxuICAgICAgICAgIG9uQ2xpY2s9e3Byb3BzLmhhbmRsZUZvbGRlckNsaWNrfVxuICAgICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ29wZW5Gb2xkZXJOYW1lZCcsIHsgbmFtZTogcHJvcHMudGl0bGUgfSl9XG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJCcm93c2VySXRlbS1pY29uV3JhcFwiPlxuICAgICAgICAgICAge3Byb3BzLml0ZW1JY29uRWx9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge3Byb3BzLnNob3dUaXRsZXMgJiYgPHNwYW4+e3Byb3BzLnRpdGxlfTwvc3Bhbj59XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgKX1cbiAgICA8L2xpPlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBJdGVtSWNvbiA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9JdGVtSWNvbicpXG5jb25zdCBHcmlkTGkgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvR3JpZExpJylcbmNvbnN0IExpc3RMaSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9MaXN0TGknKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBjb25zdCBpdGVtSWNvblN0cmluZyA9IHByb3BzLmdldEl0ZW1JY29uKClcblxuICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc05hbWVzKFxuICAgICd1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0nLFxuICAgIHsgJ3VwcHktUHJvdmlkZXJCcm93c2VySXRlbS0tc2VsZWN0ZWQnOiBwcm9wcy5pc0NoZWNrZWQgfSxcbiAgICB7ICd1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tLWRpc2FibGVkJzogcHJvcHMuaXNEaXNhYmxlZCB9LFxuICAgIHsgJ3VwcHktUHJvdmlkZXJCcm93c2VySXRlbS0tbm9QcmV2aWV3JzogaXRlbUljb25TdHJpbmcgPT09ICd2aWRlbycgfVxuICApXG5cbiAgY29uc3QgaXRlbUljb25FbCA9IDxJdGVtSWNvbiBpdGVtSWNvblN0cmluZz17aXRlbUljb25TdHJpbmd9IC8+XG5cbiAgc3dpdGNoIChwcm9wcy52aWV3VHlwZSkge1xuICAgIGNhc2UgJ2dyaWQnOlxuICAgICAgcmV0dXJuIDxHcmlkTGkgey4uLnByb3BzfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gaXRlbUljb25FbD17aXRlbUljb25FbH0gLz5cbiAgICBjYXNlICdsaXN0JzpcbiAgICAgIHJldHVybiA8TGlzdExpIHsuLi5wcm9wc30gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGl0ZW1JY29uRWw9e2l0ZW1JY29uRWx9IC8+XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gc3VjaCB0eXBlICR7cHJvcHMudmlld1R5cGV9YClcbiAgfVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgcmVtb3RlRmlsZU9ialRvTG9jYWwgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvcmVtb3RlRmlsZU9ialRvTG9jYWwnKVxuY29uc3QgSXRlbSA9IHJlcXVpcmUoJy4vSXRlbS9pbmRleCcpXG5cbi8vIEhvcGVmdWxseSB0aGlzIG5hbWUgd2lsbCBub3QgYmUgdXNlZCBieSBHb29nbGVcbmNvbnN0IFZJUlRVQUxfU0hBUkVEX0RJUiA9ICdzaGFyZWQtd2l0aC1tZSdcblxuY29uc3QgZ2V0U2hhcmVkUHJvcHMgPSAoZmlsZU9yRm9sZGVyLCBwcm9wcykgPT4gKHtcbiAgaWQ6IGZpbGVPckZvbGRlci5pZCxcbiAgdGl0bGU6IGZpbGVPckZvbGRlci5uYW1lLFxuICBnZXRJdGVtSWNvbjogKCkgPT4gZmlsZU9yRm9sZGVyLmljb24sXG4gIGlzQ2hlY2tlZDogcHJvcHMuaXNDaGVja2VkKGZpbGVPckZvbGRlciksXG4gIHRvZ2dsZUNoZWNrYm94OiAoZSkgPT4gcHJvcHMudG9nZ2xlQ2hlY2tib3goZSwgZmlsZU9yRm9sZGVyKSxcbiAgY29sdW1uczogcHJvcHMuY29sdW1ucyxcbiAgc2hvd1RpdGxlczogcHJvcHMuc2hvd1RpdGxlcyxcbiAgdmlld1R5cGU6IHByb3BzLnZpZXdUeXBlLFxuICBpMThuOiBwcm9wcy5pMThuLFxufSlcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBmb2xkZXJzLCBmaWxlcywgaGFuZGxlU2Nyb2xsLCBpc0NoZWNrZWQgfSA9IHByb3BzXG5cbiAgaWYgKCFmb2xkZXJzLmxlbmd0aCAmJiAhZmlsZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlci1lbXB0eVwiPntwcm9wcy5pMThuKCdub0ZpbGVzRm91bmQnKX08L2Rpdj5cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlci1ib2R5XCI+XG4gICAgICA8dWxcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXItbGlzdFwiXG4gICAgICAgIG9uU2Nyb2xsPXtoYW5kbGVTY3JvbGx9XG4gICAgICAgIHJvbGU9XCJsaXN0Ym94XCJcbiAgICAgICAgLy8gbWFraW5nIDx1bD4gbm90IGZvY3VzYWJsZSBmb3IgZmlyZWZveFxuICAgICAgICB0YWJJbmRleD1cIi0xXCJcbiAgICAgID5cbiAgICAgICAge2ZvbGRlcnMubWFwKGZvbGRlciA9PiB7XG4gICAgICAgICAgcmV0dXJuIEl0ZW0oe1xuICAgICAgICAgICAgLi4uZ2V0U2hhcmVkUHJvcHMoZm9sZGVyLCBwcm9wcyksXG4gICAgICAgICAgICB0eXBlOiAnZm9sZGVyJyxcbiAgICAgICAgICAgIGlzRGlzYWJsZWQ6IGlzQ2hlY2tlZChmb2xkZXIpID8gaXNDaGVja2VkKGZvbGRlcikubG9hZGluZyA6IGZhbHNlLFxuICAgICAgICAgICAgaXNDaGVja2JveERpc2FibGVkOiBmb2xkZXIuaWQgPT09IFZJUlRVQUxfU0hBUkVEX0RJUixcbiAgICAgICAgICAgIGhhbmRsZUZvbGRlckNsaWNrOiAoKSA9PiBwcm9wcy5oYW5kbGVGb2xkZXJDbGljayhmb2xkZXIpLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pfVxuICAgICAgICB7ZmlsZXMubWFwKGZpbGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRlUmVzdHJpY3Rpb25zID0gcHJvcHMudmFsaWRhdGVSZXN0cmljdGlvbnMoXG4gICAgICAgICAgICByZW1vdGVGaWxlT2JqVG9Mb2NhbChmaWxlKSxcbiAgICAgICAgICAgIFsuLi5wcm9wcy51cHB5RmlsZXMsIC4uLnByb3BzLmN1cnJlbnRTZWxlY3Rpb25dXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IHNoYXJlZFByb3BzID0gZ2V0U2hhcmVkUHJvcHMoZmlsZSwgcHJvcHMpXG4gICAgICAgICAgY29uc3QgcmVzdHJpY3Rpb25SZWFzb24gPSB2YWxpZGF0ZVJlc3RyaWN0aW9ucy5yZWFzb25cblxuICAgICAgICAgIHJldHVybiBJdGVtKHtcbiAgICAgICAgICAgIC4uLnNoYXJlZFByb3BzLFxuICAgICAgICAgICAgdHlwZTogJ2ZpbGUnLFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogIXZhbGlkYXRlUmVzdHJpY3Rpb25zLnJlc3VsdCAmJiAhc2hhcmVkUHJvcHMuaXNDaGVja2VkLFxuICAgICAgICAgICAgcmVzdHJpY3Rpb25SZWFzb24sXG4gICAgICAgICAgfSlcbiAgICAgICAgfSl9XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyLWxvYWRpbmdcIj5cbiAgICAgIDxzcGFuPntwcm9wcy5pMThuKCdsb2FkaW5nJyl9PC9zcGFuPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuY2xhc3MgQXV0aFZpZXcgZXh0ZW5kcyBDb21wb25lbnQge1xuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHBsdWdpbk5hbWVDb21wb25lbnQgPSAoXG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyLWF1dGhUaXRsZU5hbWVcIj5cbiAgICAgICAge3RoaXMucHJvcHMucGx1Z2luTmFtZX1cbiAgICAgICAgPGJyIC8+XG4gICAgICA8L3NwYW4+XG4gICAgKVxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItYXV0aFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItYXV0aEljb25cIj57dGhpcy5wcm9wcy5wbHVnaW5JY29uKCl9PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlci1hdXRoVGl0bGVcIj5cbiAgICAgICAgICB7dGhpcy5wcm9wcy5pMThuQXJyYXkoJ2F1dGhlbnRpY2F0ZVdpdGhUaXRsZScsIHsgcGx1Z2luTmFtZTogcGx1Z2luTmFtZUNvbXBvbmVudCB9KX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LWMtYnRuLXByaW1hcnkgdXBweS1Qcm92aWRlci1hdXRoQnRuXCJcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLnByb3BzLmhhbmRsZUF1dGh9XG4gICAgICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgICAgICA+XG4gICAgICAgICAge3RoaXMucHJvcHMuaTE4bkFycmF5KCdhdXRoZW50aWNhdGVXaXRoJywgeyBwbHVnaW5OYW1lOiB0aGlzLnByb3BzLnBsdWdpbk5hbWUgfSl9XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0aFZpZXdcbiIsImNvbnN0IFVzZXIgPSByZXF1aXJlKCcuL1VzZXInKVxuY29uc3QgQnJlYWRjcnVtYnMgPSByZXF1aXJlKCcuLi9CcmVhZGNydW1icycpXG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXVxuICBpZiAocHJvcHMuc2hvd0JyZWFkY3J1bWJzKSB7XG4gICAgY29tcG9uZW50cy5wdXNoKEJyZWFkY3J1bWJzKHtcbiAgICAgIGdldEZvbGRlcjogcHJvcHMuZ2V0Rm9sZGVyLFxuICAgICAgZGlyZWN0b3JpZXM6IHByb3BzLmRpcmVjdG9yaWVzLFxuICAgICAgYnJlYWRjcnVtYnNJY29uOiBwcm9wcy5wbHVnaW5JY29uICYmIHByb3BzLnBsdWdpbkljb24oKSxcbiAgICAgIHRpdGxlOiBwcm9wcy50aXRsZSxcbiAgICB9KSlcbiAgfVxuXG4gIGNvbXBvbmVudHMucHVzaChVc2VyKHtcbiAgICBsb2dvdXQ6IHByb3BzLmxvZ291dCxcbiAgICB1c2VybmFtZTogcHJvcHMudXNlcm5hbWUsXG4gICAgaTE4bjogcHJvcHMuaTE4bixcbiAgfSkpXG5cbiAgcmV0dXJuIGNvbXBvbmVudHNcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IEF1dGhWaWV3ID0gcmVxdWlyZSgnLi9BdXRoVmlldycpXG5jb25zdCBIZWFkZXIgPSByZXF1aXJlKCcuL0hlYWRlcicpXG5jb25zdCBCcm93c2VyID0gcmVxdWlyZSgnLi4vQnJvd3NlcicpXG5jb25zdCBMb2FkZXJWaWV3ID0gcmVxdWlyZSgnLi4vTG9hZGVyJylcbmNvbnN0IGdlbmVyYXRlRmlsZUlEID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dlbmVyYXRlRmlsZUlEJylcbmNvbnN0IGdldEZpbGVUeXBlID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldEZpbGVUeXBlJylcbmNvbnN0IGZpbmRJbmRleCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9maW5kSW5kZXgnKVxuY29uc3QgaXNQcmV2aWV3U3VwcG9ydGVkID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2lzUHJldmlld1N1cHBvcnRlZCcpXG5jb25zdCBTaGFyZWRIYW5kbGVyID0gcmVxdWlyZSgnLi4vU2hhcmVkSGFuZGxlcicpXG5jb25zdCBDbG9zZVdyYXBwZXIgPSByZXF1aXJlKCcuLi9DbG9zZVdyYXBwZXInKVxuXG4vLyBsb2NhdGlvbi5vcmlnaW4gZG9lcyBub3QgZXhpc3QgaW4gSUVcbmZ1bmN0aW9uIGdldE9yaWdpbiAoKSB7XG4gIGlmICgnb3JpZ2luJyBpbiBsb2NhdGlvbikge1xuICAgIHJldHVybiBsb2NhdGlvbi5vcmlnaW4gLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb21wYXQvY29tcGF0XG4gIH1cbiAgcmV0dXJuIGAke2xvY2F0aW9uLnByb3RvY29sfS8vJHtsb2NhdGlvbi5ob3N0bmFtZX0ke2xvY2F0aW9uLnBvcnQgPyBgOiR7bG9jYXRpb24ucG9ydH1gIDogJyd9YFxufVxuXG4vKipcbiAqIENsYXNzIHRvIGVhc2lseSBnZW5lcmF0ZSBnZW5lcmljIHZpZXdzIGZvciBQcm92aWRlciBwbHVnaW5zXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUHJvdmlkZXJWaWV3IHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwbHVnaW4gaW5zdGFuY2Ugb2YgdGhlIHBsdWdpblxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHBsdWdpbiwgb3B0cykge1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luXG4gICAgdGhpcy5wcm92aWRlciA9IG9wdHMucHJvdmlkZXJcbiAgICB0aGlzLl9zaGFyZWRIYW5kbGVyID0gbmV3IFNoYXJlZEhhbmRsZXIocGx1Z2luKVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdmlld1R5cGU6ICdsaXN0JyxcbiAgICAgIHNob3dUaXRsZXM6IHRydWUsXG4gICAgICBzaG93RmlsdGVyOiB0cnVlLFxuICAgICAgc2hvd0JyZWFkY3J1bWJzOiB0cnVlLFxuICAgIH1cblxuICAgIC8vIG1lcmdlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBvbmVzIHNldCBieSB1c2VyXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICAvLyBMb2dpY1xuICAgIHRoaXMuYWRkRmlsZSA9IHRoaXMuYWRkRmlsZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5maWx0ZXJRdWVyeSA9IHRoaXMuZmlsdGVyUXVlcnkuYmluZCh0aGlzKVxuICAgIHRoaXMuZ2V0Rm9sZGVyID0gdGhpcy5nZXRGb2xkZXIuYmluZCh0aGlzKVxuICAgIHRoaXMuZ2V0TmV4dEZvbGRlciA9IHRoaXMuZ2V0TmV4dEZvbGRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5sb2dvdXQgPSB0aGlzLmxvZ291dC5iaW5kKHRoaXMpXG4gICAgdGhpcy5wcmVGaXJzdFJlbmRlciA9IHRoaXMucHJlRmlyc3RSZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlQXV0aCA9IHRoaXMuaGFuZGxlQXV0aC5iaW5kKHRoaXMpXG4gICAgdGhpcy5zb3J0QnlUaXRsZSA9IHRoaXMuc29ydEJ5VGl0bGUuYmluZCh0aGlzKVxuICAgIHRoaXMuc29ydEJ5RGF0ZSA9IHRoaXMuc29ydEJ5RGF0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVFcnJvciA9IHRoaXMuaGFuZGxlRXJyb3IuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gdGhpcy5oYW5kbGVTY3JvbGwuYmluZCh0aGlzKVxuICAgIHRoaXMubGlzdEFsbEZpbGVzID0gdGhpcy5saXN0QWxsRmlsZXMuYmluZCh0aGlzKVxuICAgIHRoaXMuZG9uZVBpY2tpbmcgPSB0aGlzLmRvbmVQaWNraW5nLmJpbmQodGhpcylcbiAgICB0aGlzLmNhbmNlbFBpY2tpbmcgPSB0aGlzLmNhbmNlbFBpY2tpbmcuYmluZCh0aGlzKVxuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24gPSB0aGlzLmNsZWFyU2VsZWN0aW9uLmJpbmQodGhpcylcblxuICAgIC8vIFZpc3VhbFxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbigpXG5cbiAgICAvLyBTZXQgZGVmYXVsdCBzdGF0ZSBmb3IgdGhlIHBsdWdpblxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGF1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgZmlsZXM6IFtdLFxuICAgICAgZm9sZGVyczogW10sXG4gICAgICBkaXJlY3RvcmllczogW10sXG4gICAgICBmaWx0ZXJJbnB1dDogJycsXG4gICAgICBpc1NlYXJjaFZpc2libGU6IGZhbHNlLFxuICAgIH0pXG4gIH1cblxuICB0ZWFyRG93biAoKSB7XG4gICAgLy8gTm90aGluZy5cbiAgfVxuXG4gIF91cGRhdGVGaWxlc0FuZEZvbGRlcnMgKHJlcywgZmlsZXMsIGZvbGRlcnMpIHtcbiAgICB0aGlzLm5leHRQYWdlUGF0aCA9IHJlcy5uZXh0UGFnZVBhdGhcbiAgICByZXMuaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uaXNGb2xkZXIpIHtcbiAgICAgICAgZm9sZGVycy5wdXNoKGl0ZW0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWxlcy5wdXNoKGl0ZW0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgZm9sZGVycywgZmlsZXMgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgb25seSB0aGUgZmlyc3QgdGltZSB0aGUgcHJvdmlkZXIgdmlldyBpcyByZW5kZXJlZC5cbiAgICogS2luZCBvZiBsaWtlIGFuIGluaXQgZnVuY3Rpb24uXG4gICAqL1xuICBwcmVGaXJzdFJlbmRlciAoKSB7XG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBkaWRGaXJzdFJlbmRlcjogdHJ1ZSB9KVxuICAgIHRoaXMucGx1Z2luLm9uRmlyc3RSZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEJhc2VkIG9uIGZvbGRlciBJRCwgZmV0Y2ggYSBuZXcgZm9sZGVyIGFuZCB1cGRhdGUgaXQgdG8gc3RhdGVcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCBGb2xkZXIgaWRcbiAgICogQHJldHVybnMge1Byb21pc2V9ICAgRm9sZGVycy9maWxlcyBpbiBmb2xkZXJcbiAgICovXG4gIGdldEZvbGRlciAoaWQsIG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkSGFuZGxlci5sb2FkZXJXcmFwcGVyKFxuICAgICAgdGhpcy5wcm92aWRlci5saXN0KGlkKSxcbiAgICAgIChyZXMpID0+IHtcbiAgICAgICAgY29uc3QgZm9sZGVycyA9IFtdXG4gICAgICAgIGNvbnN0IGZpbGVzID0gW11cbiAgICAgICAgbGV0IHVwZGF0ZWREaXJlY3Rvcmllc1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgICBjb25zdCBpbmRleCA9IGZpbmRJbmRleChzdGF0ZS5kaXJlY3RvcmllcywgKGRpcikgPT4gaWQgPT09IGRpci5pZClcblxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgdXBkYXRlZERpcmVjdG9yaWVzID0gc3RhdGUuZGlyZWN0b3JpZXMuc2xpY2UoMCwgaW5kZXggKyAxKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwZGF0ZWREaXJlY3RvcmllcyA9IHN0YXRlLmRpcmVjdG9yaWVzLmNvbmNhdChbeyBpZCwgdGl0bGU6IG5hbWUgfV0pXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVzZXJuYW1lID0gcmVzLnVzZXJuYW1lIHx8IHRoaXMudXNlcm5hbWVcbiAgICAgICAgdGhpcy5fdXBkYXRlRmlsZXNBbmRGb2xkZXJzKHJlcywgZmlsZXMsIGZvbGRlcnMpXG4gICAgICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgZGlyZWN0b3JpZXM6IHVwZGF0ZWREaXJlY3RvcmllcyB9KVxuICAgICAgfSxcbiAgICAgIHRoaXMuaGFuZGxlRXJyb3JcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBuZXcgZm9sZGVyXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gZm9sZGVyXG4gICAqL1xuICBnZXROZXh0Rm9sZGVyIChmb2xkZXIpIHtcbiAgICB0aGlzLmdldEZvbGRlcihmb2xkZXIucmVxdWVzdFBhdGgsIGZvbGRlci5uYW1lKVxuICAgIHRoaXMubGFzdENoZWNrYm94ID0gdW5kZWZpbmVkXG4gIH1cblxuICBhZGRGaWxlIChmaWxlKSB7XG4gICAgY29uc3QgdGFnRmlsZSA9IHtcbiAgICAgIGlkOiB0aGlzLnByb3ZpZGVyRmlsZVRvSWQoZmlsZSksXG4gICAgICBzb3VyY2U6IHRoaXMucGx1Z2luLmlkLFxuICAgICAgZGF0YTogZmlsZSxcbiAgICAgIG5hbWU6IGZpbGUubmFtZSB8fCBmaWxlLmlkLFxuICAgICAgdHlwZTogZmlsZS5taW1lVHlwZSxcbiAgICAgIGlzUmVtb3RlOiB0cnVlLFxuICAgICAgYm9keToge1xuICAgICAgICBmaWxlSWQ6IGZpbGUuaWQsXG4gICAgICB9LFxuICAgICAgcmVtb3RlOiB7XG4gICAgICAgIGNvbXBhbmlvblVybDogdGhpcy5wbHVnaW4ub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICAgIHVybDogYCR7dGhpcy5wcm92aWRlci5maWxlVXJsKGZpbGUucmVxdWVzdFBhdGgpfWAsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBmaWxlSWQ6IGZpbGUuaWQsXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogdGhpcy5wcm92aWRlci5vcHRzLFxuICAgICAgfSxcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlVHlwZSA9IGdldEZpbGVUeXBlKHRhZ0ZpbGUpXG4gICAgLy8gVE9ETyBTaG91bGQgd2UganVzdCBhbHdheXMgdXNlIHRoZSB0aHVtYm5haWwgVVJMIGlmIGl0IGV4aXN0cz9cbiAgICBpZiAoZmlsZVR5cGUgJiYgaXNQcmV2aWV3U3VwcG9ydGVkKGZpbGVUeXBlKSkge1xuICAgICAgdGFnRmlsZS5wcmV2aWV3ID0gZmlsZS50aHVtYm5haWxcbiAgICB9XG4gICAgdGhpcy5wbHVnaW4udXBweS5sb2coJ0FkZGluZyByZW1vdGUgZmlsZScpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGx1Z2luLnVwcHkuYWRkRmlsZSh0YWdGaWxlKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghZXJyLmlzUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgdGhpcy5wbHVnaW4udXBweS5sb2coZXJyKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc2Vzc2lvbiB0b2tlbiBvbiBjbGllbnQgc2lkZS5cbiAgICovXG4gIGxvZ291dCAoKSB7XG4gICAgdGhpcy5wcm92aWRlci5sb2dvdXQoKVxuICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgICAgaWYgKCFyZXMucmV2b2tlZCkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMucGx1Z2luLnVwcHkuaTE4bignY29tcGFuaW9uVW5hdXRob3JpemVIaW50Jywge1xuICAgICAgICAgICAgICBwcm92aWRlcjogdGhpcy5wbHVnaW4udGl0bGUsXG4gICAgICAgICAgICAgIHVybDogcmVzLm1hbnVhbF9yZXZva2VfdXJsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnVwcHkuaW5mbyhtZXNzYWdlLCAnaW5mbycsIDcwMDApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICBhdXRoZW50aWNhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVzOiBbXSxcbiAgICAgICAgICAgIGZvbGRlcnM6IFtdLFxuICAgICAgICAgICAgZGlyZWN0b3JpZXM6IFtdLFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZShuZXdTdGF0ZSlcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2godGhpcy5oYW5kbGVFcnJvcilcbiAgfVxuXG4gIGZpbHRlclF1ZXJ5IChlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyAuLi5zdGF0ZSwgZmlsdGVySW5wdXQ6IGUgPyBlLnRhcmdldC52YWx1ZSA6ICcnIH0pXG4gIH1cblxuICBzb3J0QnlUaXRsZSAoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7IC4uLnRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKCkgfVxuICAgIGNvbnN0IHsgZmlsZXMsIGZvbGRlcnMsIHNvcnRpbmcgfSA9IHN0YXRlXG5cbiAgICBjb25zdCBzb3J0ZWRGaWxlcyA9IGZpbGVzLnNvcnQoKGZpbGVBLCBmaWxlQikgPT4ge1xuICAgICAgaWYgKHNvcnRpbmcgPT09ICd0aXRsZURlc2NlbmRpbmcnKSB7XG4gICAgICAgIHJldHVybiBmaWxlQi5uYW1lLmxvY2FsZUNvbXBhcmUoZmlsZUEubmFtZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWxlQS5uYW1lLmxvY2FsZUNvbXBhcmUoZmlsZUIubmFtZSlcbiAgICB9KVxuXG4gICAgY29uc3Qgc29ydGVkRm9sZGVycyA9IGZvbGRlcnMuc29ydCgoZm9sZGVyQSwgZm9sZGVyQikgPT4ge1xuICAgICAgaWYgKHNvcnRpbmcgPT09ICd0aXRsZURlc2NlbmRpbmcnKSB7XG4gICAgICAgIHJldHVybiBmb2xkZXJCLm5hbWUubG9jYWxlQ29tcGFyZShmb2xkZXJBLm5hbWUpXG4gICAgICB9XG4gICAgICByZXR1cm4gZm9sZGVyQS5uYW1lLmxvY2FsZUNvbXBhcmUoZm9sZGVyQi5uYW1lKVxuICAgIH0pXG5cbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGZpbGVzOiBzb3J0ZWRGaWxlcyxcbiAgICAgIGZvbGRlcnM6IHNvcnRlZEZvbGRlcnMsXG4gICAgICBzb3J0aW5nOiAoc29ydGluZyA9PT0gJ3RpdGxlRGVzY2VuZGluZycpID8gJ3RpdGxlQXNjZW5kaW5nJyA6ICd0aXRsZURlc2NlbmRpbmcnLFxuICAgIH0pXG4gIH1cblxuICBzb3J0QnlEYXRlICgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHsgLi4udGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKSB9XG4gICAgY29uc3QgeyBmaWxlcywgZm9sZGVycywgc29ydGluZyB9ID0gc3RhdGVcblxuICAgIGNvbnN0IHNvcnRlZEZpbGVzID0gZmlsZXMuc29ydCgoZmlsZUEsIGZpbGVCKSA9PiB7XG4gICAgICBjb25zdCBhID0gbmV3IERhdGUoZmlsZUEubW9kaWZpZWREYXRlKVxuICAgICAgY29uc3QgYiA9IG5ldyBEYXRlKGZpbGVCLm1vZGlmaWVkRGF0ZSlcblxuICAgICAgaWYgKHNvcnRpbmcgPT09ICdkYXRlRGVzY2VuZGluZycpIHtcbiAgICAgICAgcmV0dXJuIGEgPiBiID8gLTEgOiBhIDwgYiA/IDEgOiAwXG4gICAgICB9XG4gICAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDBcbiAgICB9KVxuXG4gICAgY29uc3Qgc29ydGVkRm9sZGVycyA9IGZvbGRlcnMuc29ydCgoZm9sZGVyQSwgZm9sZGVyQikgPT4ge1xuICAgICAgY29uc3QgYSA9IG5ldyBEYXRlKGZvbGRlckEubW9kaWZpZWREYXRlKVxuICAgICAgY29uc3QgYiA9IG5ldyBEYXRlKGZvbGRlckIubW9kaWZpZWREYXRlKVxuXG4gICAgICBpZiAoc29ydGluZyA9PT0gJ2RhdGVEZXNjZW5kaW5nJykge1xuICAgICAgICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPCBiID8gMSA6IDBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwXG4gICAgfSlcblxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZmlsZXM6IHNvcnRlZEZpbGVzLFxuICAgICAgZm9sZGVyczogc29ydGVkRm9sZGVycyxcbiAgICAgIHNvcnRpbmc6IChzb3J0aW5nID09PSAnZGF0ZURlc2NlbmRpbmcnKSA/ICdkYXRlQXNjZW5kaW5nJyA6ICdkYXRlRGVzY2VuZGluZycsXG4gICAgfSlcbiAgfVxuXG4gIHNvcnRCeVNpemUgKCkge1xuICAgIGNvbnN0IHN0YXRlID0geyAuLi50aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpIH1cbiAgICBjb25zdCB7IGZpbGVzLCBzb3J0aW5nIH0gPSBzdGF0ZVxuXG4gICAgLy8gY2hlY2sgdGhhdCBwbHVnaW4gc3VwcG9ydHMgZmlsZSBzaXplc1xuICAgIGlmICghZmlsZXMubGVuZ3RoIHx8ICF0aGlzLnBsdWdpbi5nZXRJdGVtRGF0YShmaWxlc1swXSkuc2l6ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc29ydGVkRmlsZXMgPSBmaWxlcy5zb3J0KChmaWxlQSwgZmlsZUIpID0+IHtcbiAgICAgIGNvbnN0IGEgPSBmaWxlQS5zaXplXG4gICAgICBjb25zdCBiID0gZmlsZUIuc2l6ZVxuXG4gICAgICBpZiAoc29ydGluZyA9PT0gJ3NpemVEZXNjZW5kaW5nJykge1xuICAgICAgICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPCBiID8gMSA6IDBcbiAgICAgIH1cbiAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMFxuICAgIH0pXG5cbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGZpbGVzOiBzb3J0ZWRGaWxlcyxcbiAgICAgIHNvcnRpbmc6IChzb3J0aW5nID09PSAnc2l6ZURlc2NlbmRpbmcnKSA/ICdzaXplQXNjZW5kaW5nJyA6ICdzaXplRGVzY2VuZGluZycsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFsbCBmaWxlcyBmb3VuZCBpbnNpZGUgb2Ygc3BlY2lmaWVkIGZvbGRlci5cbiAgICpcbiAgICogVXNlcyBzZXBhcmF0ZWQgc3RhdGUgd2hpbGUgZm9sZGVyIGNvbnRlbnRzIGFyZSBiZWluZyBmZXRjaGVkIGFuZFxuICAgKiBtYW50YWlucyBsaXN0IG9mIHNlbGVjdGVkIGZvbGRlcnMsIHdoaWNoIGFyZSBzZXBhcmF0ZWQgZnJvbSBmaWxlcy5cbiAgICovXG4gIGFkZEZvbGRlciAoZm9sZGVyKSB7XG4gICAgY29uc3QgZm9sZGVySWQgPSB0aGlzLnByb3ZpZGVyRmlsZVRvSWQoZm9sZGVyKVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IGZvbGRlcnMgPSB7IC4uLnN0YXRlLnNlbGVjdGVkRm9sZGVycyB9XG4gICAgaWYgKGZvbGRlcklkIGluIGZvbGRlcnMgJiYgZm9sZGVyc1tmb2xkZXJJZF0ubG9hZGluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvbGRlcnNbZm9sZGVySWRdID0geyBsb2FkaW5nOiB0cnVlLCBmaWxlczogW10gfVxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgc2VsZWN0ZWRGb2xkZXJzOiB7IC4uLmZvbGRlcnMgfSB9KVxuICAgIHJldHVybiB0aGlzLmxpc3RBbGxGaWxlcyhmb2xkZXIucmVxdWVzdFBhdGgpLnRoZW4oKGZpbGVzKSA9PiB7XG4gICAgICBsZXQgY291bnQgPSAwXG4gICAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSB0aGlzLmFkZEZpbGUoZmlsZSlcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIGNvdW50KytcbiAgICAgIH0pXG4gICAgICBjb25zdCBpZHMgPSBmaWxlcy5tYXAodGhpcy5wcm92aWRlckZpbGVUb0lkKVxuICAgICAgZm9sZGVyc1tmb2xkZXJJZF0gPSB7XG4gICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICBmaWxlczogaWRzLFxuICAgICAgfVxuICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBzZWxlY3RlZEZvbGRlcnM6IGZvbGRlcnMgfSlcblxuICAgICAgbGV0IG1lc3NhZ2VcbiAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMucGx1Z2luLnVwcHkuaTE4bignZm9sZGVyQWRkZWQnLCB7XG4gICAgICAgICAgc21hcnRfY291bnQ6IGNvdW50LCBmb2xkZXI6IGZvbGRlci5uYW1lLFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMucGx1Z2luLnVwcHkuaTE4bignZW1wdHlGb2xkZXJBZGRlZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnBsdWdpbi51cHB5LmluZm8obWVzc2FnZSlcbiAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgICBjb25zdCBzZWxlY3RlZEZvbGRlcnMgPSB7IC4uLnN0YXRlLnNlbGVjdGVkRm9sZGVycyB9XG4gICAgICBkZWxldGUgc2VsZWN0ZWRGb2xkZXJzW2ZvbGRlcklkXVxuICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBzZWxlY3RlZEZvbGRlcnMgfSlcbiAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSlcbiAgICB9KVxuICB9XG5cbiAgcHJvdmlkZXJGaWxlVG9JZCAoZmlsZSkge1xuICAgIHJldHVybiBnZW5lcmF0ZUZpbGVJRCh7XG4gICAgICBkYXRhOiBmaWxlLFxuICAgICAgbmFtZTogZmlsZS5uYW1lIHx8IGZpbGUuaWQsXG4gICAgICB0eXBlOiBmaWxlLm1pbWVUeXBlLFxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVBdXRoICgpIHtcbiAgICBjb25zdCBhdXRoU3RhdGUgPSBidG9hKEpTT04uc3RyaW5naWZ5KHsgb3JpZ2luOiBnZXRPcmlnaW4oKSB9KSlcbiAgICBjb25zdCBjbGllbnRWZXJzaW9uID0gYEB1cHB5L3Byb3ZpZGVyLXZpZXdzPSR7UHJvdmlkZXJWaWV3LlZFUlNJT059YFxuICAgIGNvbnN0IGxpbmsgPSB0aGlzLnByb3ZpZGVyLmF1dGhVcmwoeyBzdGF0ZTogYXV0aFN0YXRlLCB1cHB5VmVyc2lvbnM6IGNsaWVudFZlcnNpb24gfSlcblxuICAgIGNvbnN0IGF1dGhXaW5kb3cgPSB3aW5kb3cub3BlbihsaW5rLCAnX2JsYW5rJylcbiAgICBjb25zdCBoYW5kbGVUb2tlbiA9IChlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2lzT3JpZ2luQWxsb3dlZChlLm9yaWdpbiwgdGhpcy5wbHVnaW4ub3B0cy5jb21wYW5pb25BbGxvd2VkSG9zdHMpIHx8IGUuc291cmNlICE9PSBhdXRoV2luZG93KSB7XG4gICAgICAgIHRoaXMucGx1Z2luLnVwcHkubG9nKGByZWplY3RpbmcgZXZlbnQgZnJvbSAke2Uub3JpZ2lufSB2cyBhbGxvd2VkIHBhdHRlcm4gJHt0aGlzLnBsdWdpbi5vcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0c31gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIHN0cmluZyBiZWZvcmUgZG9pbmcgdGhlIEpTT04ucGFyc2UgdG8gbWFpbnRhaW4gc3VwcG9ydFxuICAgICAgLy8gZm9yIG9sZGVyIENvbXBhbmlvbiB2ZXJzaW9ucyB0aGF0IHVzZWQgb2JqZWN0IHJlZmVyZW5jZXNcbiAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgZS5kYXRhID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoZS5kYXRhKSA6IGUuZGF0YVxuXG4gICAgICBpZiAoIWRhdGEudG9rZW4pIHtcbiAgICAgICAgdGhpcy5wbHVnaW4udXBweS5sb2coJ2RpZCBub3QgcmVjZWl2ZSB0b2tlbiBmcm9tIGF1dGggd2luZG93JylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGF1dGhXaW5kb3cuY2xvc2UoKVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVUb2tlbilcbiAgICAgIHRoaXMucHJvdmlkZXIuc2V0QXV0aFRva2VuKGRhdGEudG9rZW4pXG4gICAgICB0aGlzLnByZUZpcnN0UmVuZGVyKClcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVUb2tlbilcbiAgfVxuXG4gIF9pc09yaWdpbkFsbG93ZWQgKG9yaWdpbiwgYWxsb3dlZE9yaWdpbikge1xuICAgIGNvbnN0IGdldFJlZ2V4ID0gKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dmFsdWV9JGApXG4gICAgICB9IGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYXR0ZXJucyA9IEFycmF5LmlzQXJyYXkoYWxsb3dlZE9yaWdpbikgPyBhbGxvd2VkT3JpZ2luLm1hcChnZXRSZWdleCkgOiBbZ2V0UmVnZXgoYWxsb3dlZE9yaWdpbildXG4gICAgcmV0dXJuIHBhdHRlcm5zXG4gICAgICAuZmlsdGVyKChwYXR0ZXJuKSA9PiBwYXR0ZXJuICE9IG51bGwpIC8vIGxvb3NlIGNvbXBhcmlzb24gdG8gY2F0Y2ggdW5kZWZpbmVkXG4gICAgICAuc29tZSgocGF0dGVybikgPT4gcGF0dGVybi50ZXN0KG9yaWdpbikgfHwgcGF0dGVybi50ZXN0KGAke29yaWdpbn0vYCkpIC8vIGFsbG93aW5nIGZvciB0cmFpbGluZyAnLydcbiAgfVxuXG4gIGhhbmRsZUVycm9yIChlcnJvcikge1xuICAgIGNvbnN0IHVwcHkgPSB0aGlzLnBsdWdpbi51cHB5XG4gICAgdXBweS5sb2coZXJyb3IudG9TdHJpbmcoKSlcbiAgICBpZiAoZXJyb3IuaXNBdXRoRXJyb3IpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gdXBweS5pMThuKCdjb21wYW5pb25FcnJvcicpXG4gICAgdXBweS5pbmZvKHsgbWVzc2FnZSwgZGV0YWlsczogZXJyb3IudG9TdHJpbmcoKSB9LCAnZXJyb3InLCA1MDAwKVxuICB9XG5cbiAgaGFuZGxlU2Nyb2xsIChlKSB7XG4gICAgY29uc3Qgc2Nyb2xsUG9zID0gZS50YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gKGUudGFyZ2V0LnNjcm9sbFRvcCArIGUudGFyZ2V0Lm9mZnNldEhlaWdodClcbiAgICBjb25zdCBwYXRoID0gdGhpcy5uZXh0UGFnZVBhdGggfHwgbnVsbFxuXG4gICAgaWYgKHNjcm9sbFBvcyA8IDUwICYmIHBhdGggJiYgIXRoaXMuX2lzSGFuZGxpbmdTY3JvbGwpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIubGlzdChwYXRoKVxuICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBmaWxlcywgZm9sZGVycyB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUZpbGVzQW5kRm9sZGVycyhyZXMsIGZpbGVzLCBmb2xkZXJzKVxuICAgICAgICB9KS5jYXRjaCh0aGlzLmhhbmRsZUVycm9yKVxuICAgICAgICAudGhlbigoKSA9PiB7IHRoaXMuX2lzSGFuZGxpbmdTY3JvbGwgPSBmYWxzZSB9KSAvLyBhbHdheXMgY2FsbGVkXG5cbiAgICAgIHRoaXMuX2lzSGFuZGxpbmdTY3JvbGwgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgbGlzdEFsbEZpbGVzIChwYXRoLCBmaWxlcyA9IG51bGwpIHtcbiAgICBmaWxlcyA9IGZpbGVzIHx8IFtdXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucHJvdmlkZXIubGlzdChwYXRoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgcmVzLml0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoIWl0ZW0uaXNGb2xkZXIpIHtcbiAgICAgICAgICAgIGZpbGVzLnB1c2goaXRlbSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRGb2xkZXIoaXRlbSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IG1vcmVGaWxlcyA9IHJlcy5uZXh0UGFnZVBhdGggfHwgbnVsbFxuICAgICAgICBpZiAobW9yZUZpbGVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGlzdEFsbEZpbGVzKG1vcmVGaWxlcywgZmlsZXMpXG4gICAgICAgICAgICAudGhlbigoZmlsZXMpID0+IHJlc29sdmUoZmlsZXMpKVxuICAgICAgICAgICAgLmNhdGNoKGUgPT4gcmVqZWN0KGUpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKGZpbGVzKVxuICAgICAgfSkuY2F0Y2goZSA9PiByZWplY3QoZSkpXG4gICAgfSlcbiAgfVxuXG4gIGRvbmVQaWNraW5nICgpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRTZWxlY3Rpb24gfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBwcm9taXNlcyA9IGN1cnJlbnRTZWxlY3Rpb24ubWFwKChmaWxlKSA9PiB7XG4gICAgICBpZiAoZmlsZS5pc0ZvbGRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRGb2xkZXIoZmlsZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSlcbiAgICB9KVxuXG4gICAgdGhpcy5fc2hhcmVkSGFuZGxlci5sb2FkZXJXcmFwcGVyKFByb21pc2UuYWxsKHByb21pc2VzKSwgKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpXG4gICAgfSwgKCkgPT4ge30pXG4gIH1cblxuICBjYW5jZWxQaWNraW5nICgpIHtcbiAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKClcblxuICAgIGNvbnN0IGRhc2hib2FyZCA9IHRoaXMucGx1Z2luLnVwcHkuZ2V0UGx1Z2luKCdEYXNoYm9hcmQnKVxuICAgIGlmIChkYXNoYm9hcmQpIGRhc2hib2FyZC5oaWRlQWxsUGFuZWxzKClcbiAgfVxuXG4gIGNsZWFyU2VsZWN0aW9uICgpIHtcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGN1cnJlbnRTZWxlY3Rpb246IFtdIH0pXG4gIH1cblxuICByZW5kZXIgKHN0YXRlLCB2aWV3T3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhdXRoZW50aWNhdGVkLCBkaWRGaXJzdFJlbmRlciB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGlmICghZGlkRmlyc3RSZW5kZXIpIHtcbiAgICAgIHRoaXMucHJlRmlyc3RSZW5kZXIoKVxuICAgIH1cblxuICAgIC8vIHJlbG9hZCBwbHVnaW5TdGF0ZSBmb3IgXCJsb2FkaW5nXCIgYXR0cmlidXRlIGJlY2F1c2UgaXQgbWlnaHRcbiAgICAvLyBoYXZlIGNoYW5nZWQgYWJvdmUuXG4gICAgaWYgKHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKCkubG9hZGluZykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPENsb3NlV3JhcHBlciBvblVubW91bnQ9e3RoaXMuY2xlYXJTZWxlY3Rpb259PlxuICAgICAgICAgIDxMb2FkZXJWaWV3IGkxOG49e3RoaXMucGx1Z2luLnVwcHkuaTE4bn0gLz5cbiAgICAgICAgPC9DbG9zZVdyYXBwZXI+XG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKCFhdXRoZW50aWNhdGVkKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgICAgPEF1dGhWaWV3XG4gICAgICAgICAgICBwbHVnaW5OYW1lPXt0aGlzLnBsdWdpbi50aXRsZX1cbiAgICAgICAgICAgIHBsdWdpbkljb249e3RoaXMucGx1Z2luLmljb259XG4gICAgICAgICAgICBoYW5kbGVBdXRoPXt0aGlzLmhhbmRsZUF1dGh9XG4gICAgICAgICAgICBpMThuPXt0aGlzLnBsdWdpbi51cHB5LmkxOG59XG4gICAgICAgICAgICBpMThuQXJyYXk9e3RoaXMucGx1Z2luLnVwcHkuaTE4bkFycmF5fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvQ2xvc2VXcmFwcGVyPlxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldFZpZXdPcHRpb25zID0geyAuLi50aGlzLm9wdHMsIC4uLnZpZXdPcHRpb25zIH1cbiAgICBjb25zdCBoZWFkZXJQcm9wcyA9IHtcbiAgICAgIHNob3dCcmVhZGNydW1iczogdGFyZ2V0Vmlld09wdGlvbnMuc2hvd0JyZWFkY3J1bWJzLFxuICAgICAgZ2V0Rm9sZGVyOiB0aGlzLmdldEZvbGRlcixcbiAgICAgIGRpcmVjdG9yaWVzOiB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpLmRpcmVjdG9yaWVzLFxuICAgICAgcGx1Z2luSWNvbjogdGhpcy5wbHVnaW4uaWNvbixcbiAgICAgIHRpdGxlOiB0aGlzLnBsdWdpbi50aXRsZSxcbiAgICAgIGxvZ291dDogdGhpcy5sb2dvdXQsXG4gICAgICB1c2VybmFtZTogdGhpcy51c2VybmFtZSxcbiAgICAgIGkxOG46IHRoaXMucGx1Z2luLnVwcHkuaTE4bixcbiAgICB9XG5cbiAgICBjb25zdCBicm93c2VyUHJvcHMgPSB7XG4gICAgICAuLi50aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpLFxuICAgICAgdXNlcm5hbWU6IHRoaXMudXNlcm5hbWUsXG4gICAgICBnZXROZXh0Rm9sZGVyOiB0aGlzLmdldE5leHRGb2xkZXIsXG4gICAgICBnZXRGb2xkZXI6IHRoaXMuZ2V0Rm9sZGVyLFxuICAgICAgZmlsdGVySXRlbXM6IHRoaXMuX3NoYXJlZEhhbmRsZXIuZmlsdGVySXRlbXMsXG4gICAgICBmaWx0ZXJRdWVyeTogdGhpcy5maWx0ZXJRdWVyeSxcbiAgICAgIHNvcnRCeVRpdGxlOiB0aGlzLnNvcnRCeVRpdGxlLFxuICAgICAgc29ydEJ5RGF0ZTogdGhpcy5zb3J0QnlEYXRlLFxuICAgICAgbG9nb3V0OiB0aGlzLmxvZ291dCxcbiAgICAgIGlzQ2hlY2tlZDogdGhpcy5fc2hhcmVkSGFuZGxlci5pc0NoZWNrZWQsXG4gICAgICB0b2dnbGVDaGVja2JveDogdGhpcy5fc2hhcmVkSGFuZGxlci50b2dnbGVDaGVja2JveCxcbiAgICAgIGhhbmRsZVNjcm9sbDogdGhpcy5oYW5kbGVTY3JvbGwsXG4gICAgICBsaXN0QWxsRmlsZXM6IHRoaXMubGlzdEFsbEZpbGVzLFxuICAgICAgZG9uZTogdGhpcy5kb25lUGlja2luZyxcbiAgICAgIGNhbmNlbDogdGhpcy5jYW5jZWxQaWNraW5nLFxuICAgICAgaGVhZGVyQ29tcG9uZW50OiBIZWFkZXIoaGVhZGVyUHJvcHMpLFxuICAgICAgdGl0bGU6IHRoaXMucGx1Z2luLnRpdGxlLFxuICAgICAgdmlld1R5cGU6IHRhcmdldFZpZXdPcHRpb25zLnZpZXdUeXBlLFxuICAgICAgc2hvd1RpdGxlczogdGFyZ2V0Vmlld09wdGlvbnMuc2hvd1RpdGxlcyxcbiAgICAgIHNob3dGaWx0ZXI6IHRhcmdldFZpZXdPcHRpb25zLnNob3dGaWx0ZXIsXG4gICAgICBzaG93QnJlYWRjcnVtYnM6IHRhcmdldFZpZXdPcHRpb25zLnNob3dCcmVhZGNydW1icyxcbiAgICAgIHBsdWdpbkljb246IHRoaXMucGx1Z2luLmljb24sXG4gICAgICBpMThuOiB0aGlzLnBsdWdpbi51cHB5LmkxOG4sXG4gICAgICB1cHB5RmlsZXM6IHRoaXMucGx1Z2luLnVwcHkuZ2V0RmlsZXMoKSxcbiAgICAgIHZhbGlkYXRlUmVzdHJpY3Rpb25zOiB0aGlzLnBsdWdpbi51cHB5LnZhbGlkYXRlUmVzdHJpY3Rpb25zLFxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgIDxCcm93c2VyIHsuLi5icm93c2VyUHJvcHN9IC8+XG4gICAgICA8L0Nsb3NlV3JhcHBlcj5cbiAgICApXG4gIH1cbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChbXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXItdXNlclwiIGtleT1cInVzZXJuYW1lXCI+e3Byb3BzLnVzZXJuYW1lfTwvc3Bhbj4sXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17cHJvcHMubG9nb3V0fSBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1Qcm92aWRlckJyb3dzZXItdXNlckxvZ291dFwiIGtleT1cImxvZ291dFwiPlxuICAgICAge3Byb3BzLmkxOG4oJ2xvZ091dCcpfVxuICAgIDwvYnV0dG9uPixcbiAgXSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9Qcm92aWRlclZpZXcnKVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9e3Byb3BzLnRyaWdnZXJTZWFyY2hJbnB1dH0gY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktUHJvdmlkZXJCcm93c2VyLXVzZXJMb2dvdXRcIj5cbiAgICAgIHtwcm9wcy5pMThuKCdiYWNrVG9TZWFyY2gnKX1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBsZXQgaW5wdXRcbiAgY29uc3QgaGFuZGxlS2V5UHJlc3MgPSAoZXYpID0+IHtcbiAgICBpZiAoZXYua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIHZhbGlkYXRlQW5kU2VhcmNoKClcbiAgICB9XG4gIH1cblxuICBjb25zdCB2YWxpZGF0ZUFuZFNlYXJjaCA9ICgpID0+IHtcbiAgICBpZiAoaW5wdXQudmFsdWUpIHtcbiAgICAgIHByb3BzLnNlYXJjaChpbnB1dC52YWx1ZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TZWFyY2hQcm92aWRlclwiPlxuICAgICAgPGlucHV0XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtdGV4dElucHV0IHVwcHktU2VhcmNoUHJvdmlkZXItaW5wdXRcIlxuICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ2VudGVyVGV4dFRvU2VhcmNoJyl9XG4gICAgICAgIHBsYWNlaG9sZGVyPXtwcm9wcy5pMThuKCdlbnRlclRleHRUb1NlYXJjaCcpfVxuICAgICAgICBvbktleVVwPXtoYW5kbGVLZXlQcmVzc31cbiAgICAgICAgcmVmPXsoaW5wdXRfKSA9PiB7IGlucHV0ID0gaW5wdXRfIH19XG4gICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgIC8+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tcHJpbWFyeSB1cHB5LVNlYXJjaFByb3ZpZGVyLXNlYXJjaEJ1dHRvblwiXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBvbkNsaWNrPXt2YWxpZGF0ZUFuZFNlYXJjaH1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmkxOG4oJ3NlYXJjaEltYWdlcycpfVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IFNlYXJjaElucHV0ID0gcmVxdWlyZSgnLi9JbnB1dFZpZXcnKVxuY29uc3QgQnJvd3NlciA9IHJlcXVpcmUoJy4uL0Jyb3dzZXInKVxuY29uc3QgTG9hZGVyVmlldyA9IHJlcXVpcmUoJy4uL0xvYWRlcicpXG5jb25zdCBnZW5lcmF0ZUZpbGVJRCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZW5lcmF0ZUZpbGVJRCcpXG5jb25zdCBnZXRGaWxlVHlwZSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRGaWxlVHlwZScpXG5jb25zdCBpc1ByZXZpZXdTdXBwb3J0ZWQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaXNQcmV2aWV3U3VwcG9ydGVkJylcbmNvbnN0IEhlYWRlciA9IHJlcXVpcmUoJy4vSGVhZGVyJylcbmNvbnN0IFNoYXJlZEhhbmRsZXIgPSByZXF1aXJlKCcuLi9TaGFyZWRIYW5kbGVyJylcbmNvbnN0IENsb3NlV3JhcHBlciA9IHJlcXVpcmUoJy4uL0Nsb3NlV3JhcHBlcicpXG5cbi8qKlxuICogQ2xhc3MgdG8gZWFzaWx5IGdlbmVyYXRlIGdlbmVyaWMgdmlld3MgZm9yIFByb3ZpZGVyIHBsdWdpbnNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQcm92aWRlclZpZXcge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IHBsdWdpbiBpbnN0YW5jZSBvZiB0aGUgcGx1Z2luXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAocGx1Z2luLCBvcHRzKSB7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW5cbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0cy5wcm92aWRlclxuICAgIHRoaXMuX3NoYXJlZEhhbmRsZXIgPSBuZXcgU2hhcmVkSGFuZGxlcihwbHVnaW4pXG5cbiAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB2aWV3VHlwZTogJ2dyaWQnLFxuICAgICAgc2hvd1RpdGxlczogZmFsc2UsXG4gICAgICBzaG93RmlsdGVyOiBmYWxzZSxcbiAgICAgIHNob3dCcmVhZGNydW1iczogZmFsc2UsXG4gICAgfVxuXG4gICAgLy8gbWVyZ2UgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIG9uZXMgc2V0IGJ5IHVzZXJcbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIC8vIExvZ2ljXG4gICAgdGhpcy5zZWFyY2ggPSB0aGlzLnNlYXJjaC5iaW5kKHRoaXMpXG4gICAgdGhpcy50cmlnZ2VyU2VhcmNoSW5wdXQgPSB0aGlzLnRyaWdnZXJTZWFyY2hJbnB1dC5iaW5kKHRoaXMpXG4gICAgdGhpcy5hZGRGaWxlID0gdGhpcy5hZGRGaWxlLmJpbmQodGhpcylcbiAgICB0aGlzLnByZUZpcnN0UmVuZGVyID0gdGhpcy5wcmVGaXJzdFJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVFcnJvciA9IHRoaXMuaGFuZGxlRXJyb3IuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gdGhpcy5oYW5kbGVTY3JvbGwuYmluZCh0aGlzKVxuICAgIHRoaXMuZG9uZVBpY2tpbmcgPSB0aGlzLmRvbmVQaWNraW5nLmJpbmQodGhpcylcbiAgICB0aGlzLmNhbmNlbFBpY2tpbmcgPSB0aGlzLmNhbmNlbFBpY2tpbmcuYmluZCh0aGlzKVxuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24gPSB0aGlzLmNsZWFyU2VsZWN0aW9uLmJpbmQodGhpcylcblxuICAgIC8vIFZpc3VhbFxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbigpXG5cbiAgICAvLyBTZXQgZGVmYXVsdCBzdGF0ZSBmb3IgdGhlIHBsdWdpblxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGlzSW5wdXRNb2RlOiB0cnVlLFxuICAgICAgZmlsZXM6IFtdLFxuICAgICAgZm9sZGVyczogW10sXG4gICAgICBkaXJlY3RvcmllczogW10sXG4gICAgICBmaWx0ZXJJbnB1dDogJycsXG4gICAgICBpc1NlYXJjaFZpc2libGU6IGZhbHNlLFxuICAgIH0pXG4gIH1cblxuICB0ZWFyRG93biAoKSB7XG4gICAgLy8gTm90aGluZy5cbiAgfVxuXG4gIF91cGRhdGVGaWxlc0FuZElucHV0TW9kZSAocmVzLCBmaWxlcykge1xuICAgIHRoaXMubmV4dFBhZ2VRdWVyeSA9IHJlcy5uZXh0UGFnZVF1ZXJ5XG4gICAgdGhpcy5fc2VhcmNoVGVybSA9IHJlcy5zZWFyY2hlZEZvclxuICAgIHJlcy5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7IGZpbGVzLnB1c2goaXRlbSkgfSlcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGlzSW5wdXRNb2RlOiBmYWxzZSwgZmlsZXMgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgb25seSB0aGUgZmlyc3QgdGltZSB0aGUgcHJvdmlkZXIgdmlldyBpcyByZW5kZXJlZC5cbiAgICogS2luZCBvZiBsaWtlIGFuIGluaXQgZnVuY3Rpb24uXG4gICAqL1xuICBwcmVGaXJzdFJlbmRlciAoKSB7XG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBkaWRGaXJzdFJlbmRlcjogdHJ1ZSB9KVxuICAgIHRoaXMucGx1Z2luLm9uRmlyc3RSZW5kZXIoKVxuICB9XG5cbiAgc2VhcmNoIChxdWVyeSkge1xuICAgIGlmIChxdWVyeSAmJiBxdWVyeSA9PT0gdGhpcy5fc2VhcmNoVGVybSkge1xuICAgICAgLy8gbm8gbmVlZCB0byBzZWFyY2ggYWdhaW4gYXMgdGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgc2VhcmNoXG4gICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGlzSW5wdXRNb2RlOiBmYWxzZSB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZEhhbmRsZXIubG9hZGVyV3JhcHBlcihcbiAgICAgIHRoaXMucHJvdmlkZXIuc2VhcmNoKHF1ZXJ5KSxcbiAgICAgIChyZXMpID0+IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlRmlsZXNBbmRJbnB1dE1vZGUocmVzLCBbXSlcbiAgICAgIH0sXG4gICAgICB0aGlzLmhhbmRsZUVycm9yXG4gICAgKVxuICB9XG5cbiAgdHJpZ2dlclNlYXJjaElucHV0ICgpIHtcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGlzSW5wdXRNb2RlOiB0cnVlIH0pXG4gIH1cblxuICAvLyBAdG9kbyB0aGlzIGZ1bmN0aW9uIHNob3VsZCByZWFsbHkgYmUgYSBmdW5jdGlvbiBvZiB0aGUgcGx1Z2luIGFuZCBub3QgdGhlIHZpZXcuXG4gIC8vIG1heWJlIHdlIHNob3VsZCBjb25zaWRlciBjcmVhdGluZyBhIGJhc2UgUHJvdmlkZXJQbHVnaW4gY2xhc3MgdGhhdCBoYXMgdGhpcyBtZXRob2RcbiAgYWRkRmlsZSAoZmlsZSkge1xuICAgIGNvbnN0IHRhZ0ZpbGUgPSB7XG4gICAgICBpZDogdGhpcy5wcm92aWRlckZpbGVUb0lkKGZpbGUpLFxuICAgICAgc291cmNlOiB0aGlzLnBsdWdpbi5pZCxcbiAgICAgIGRhdGE6IGZpbGUsXG4gICAgICBuYW1lOiBmaWxlLm5hbWUgfHwgZmlsZS5pZCxcbiAgICAgIHR5cGU6IGZpbGUubWltZVR5cGUsXG4gICAgICBpc1JlbW90ZTogdHJ1ZSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgZmlsZUlkOiBmaWxlLmlkLFxuICAgICAgfSxcbiAgICAgIHJlbW90ZToge1xuICAgICAgICBjb21wYW5pb25Vcmw6IHRoaXMucGx1Z2luLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgICB1cmw6IGAke3RoaXMucHJvdmlkZXIuZmlsZVVybChmaWxlLnJlcXVlc3RQYXRoKX1gLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZmlsZUlkOiBmaWxlLmlkLFxuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IHsgLi4udGhpcy5wcm92aWRlci5vcHRzLCBwcm92aWRlcjogbnVsbCB9LFxuICAgICAgfSxcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlVHlwZSA9IGdldEZpbGVUeXBlKHRhZ0ZpbGUpXG4gICAgLy8gVE9ETyBTaG91bGQgd2UganVzdCBhbHdheXMgdXNlIHRoZSB0aHVtYm5haWwgVVJMIGlmIGl0IGV4aXN0cz9cbiAgICBpZiAoZmlsZVR5cGUgJiYgaXNQcmV2aWV3U3VwcG9ydGVkKGZpbGVUeXBlKSkge1xuICAgICAgdGFnRmlsZS5wcmV2aWV3ID0gZmlsZS50aHVtYm5haWxcbiAgICB9XG4gICAgdGhpcy5wbHVnaW4udXBweS5sb2coJ0FkZGluZyByZW1vdGUgZmlsZScpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGx1Z2luLnVwcHkuYWRkRmlsZSh0YWdGaWxlKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICB0aGlzLnBsdWdpbi51cHB5LmxvZyhlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdmlkZXJGaWxlVG9JZCAoZmlsZSkge1xuICAgIHJldHVybiBnZW5lcmF0ZUZpbGVJRCh7XG4gICAgICBkYXRhOiBmaWxlLFxuICAgICAgbmFtZTogZmlsZS5uYW1lIHx8IGZpbGUuaWQsXG4gICAgICB0eXBlOiBmaWxlLm1pbWVUeXBlLFxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVFcnJvciAoZXJyb3IpIHtcbiAgICBjb25zdCB1cHB5ID0gdGhpcy5wbHVnaW4udXBweVxuICAgIHVwcHkubG9nKGVycm9yLnRvU3RyaW5nKCkpXG4gICAgY29uc3QgbWVzc2FnZSA9IHVwcHkuaTE4bignY29tcGFuaW9uRXJyb3InKVxuICAgIHVwcHkuaW5mbyh7IG1lc3NhZ2UsIGRldGFpbHM6IGVycm9yLnRvU3RyaW5nKCkgfSwgJ2Vycm9yJywgNTAwMClcbiAgfVxuXG4gIGhhbmRsZVNjcm9sbCAoZSkge1xuICAgIGNvbnN0IHNjcm9sbFBvcyA9IGUudGFyZ2V0LnNjcm9sbEhlaWdodCAtIChlLnRhcmdldC5zY3JvbGxUb3AgKyBlLnRhcmdldC5vZmZzZXRIZWlnaHQpXG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLm5leHRQYWdlUXVlcnkgfHwgbnVsbFxuXG4gICAgaWYgKHNjcm9sbFBvcyA8IDUwICYmIHF1ZXJ5ICYmICF0aGlzLl9pc0hhbmRsaW5nU2Nyb2xsKSB7XG4gICAgICB0aGlzLnByb3ZpZGVyLnNlYXJjaCh0aGlzLl9zZWFyY2hUZXJtLCBxdWVyeSlcbiAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZmlsZXMgfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICAgICAgICB0aGlzLl91cGRhdGVGaWxlc0FuZElucHV0TW9kZShyZXMsIGZpbGVzKVxuICAgICAgICB9KS5jYXRjaCh0aGlzLmhhbmRsZUVycm9yKVxuICAgICAgICAudGhlbigoKSA9PiB7IHRoaXMuX2lzSGFuZGxpbmdTY3JvbGwgPSBmYWxzZSB9KSAvLyBhbHdheXMgY2FsbGVkXG5cbiAgICAgIHRoaXMuX2lzSGFuZGxpbmdTY3JvbGwgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgZG9uZVBpY2tpbmcgKCkge1xuICAgIGNvbnN0IHsgY3VycmVudFNlbGVjdGlvbiB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IHByb21pc2VzID0gY3VycmVudFNlbGVjdGlvbi5tYXAoKGZpbGUpID0+IHRoaXMuYWRkRmlsZShmaWxlKSlcblxuICAgIHRoaXMuX3NoYXJlZEhhbmRsZXIubG9hZGVyV3JhcHBlcihQcm9taXNlLmFsbChwcm9taXNlcyksICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKVxuICAgIH0sICgpID0+IHt9KVxuICB9XG5cbiAgY2FuY2VsUGlja2luZyAoKSB7XG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbigpXG5cbiAgICBjb25zdCBkYXNoYm9hcmQgPSB0aGlzLnBsdWdpbi51cHB5LmdldFBsdWdpbignRGFzaGJvYXJkJylcbiAgICBpZiAoZGFzaGJvYXJkKSBkYXNoYm9hcmQuaGlkZUFsbFBhbmVscygpXG4gIH1cblxuICBjbGVhclNlbGVjdGlvbiAoKSB7XG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBjdXJyZW50U2VsZWN0aW9uOiBbXSB9KVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSwgdmlld09wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlkRmlyc3RSZW5kZXIsIGlzSW5wdXRNb2RlIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgaWYgKCFkaWRGaXJzdFJlbmRlcikge1xuICAgICAgdGhpcy5wcmVGaXJzdFJlbmRlcigpXG4gICAgfVxuXG4gICAgLy8gcmVsb2FkIHBsdWdpblN0YXRlIGZvciBcImxvYWRpbmdcIiBhdHRyaWJ1dGUgYmVjYXVzZSBpdCBtaWdodFxuICAgIC8vIGhhdmUgY2hhbmdlZCBhYm92ZS5cbiAgICBpZiAodGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKS5sb2FkaW5nKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgICAgPExvYWRlclZpZXcgaTE4bj17dGhpcy5wbHVnaW4udXBweS5pMThufSAvPlxuICAgICAgICA8L0Nsb3NlV3JhcHBlcj5cbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoaXNJbnB1dE1vZGUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxDbG9zZVdyYXBwZXIgb25Vbm1vdW50PXt0aGlzLmNsZWFyU2VsZWN0aW9ufT5cbiAgICAgICAgICA8U2VhcmNoSW5wdXRcbiAgICAgICAgICAgIHNlYXJjaD17dGhpcy5zZWFyY2h9XG4gICAgICAgICAgICBpMThuPXt0aGlzLnBsdWdpbi51cHB5LmkxOG59XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9DbG9zZVdyYXBwZXI+XG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0Vmlld09wdGlvbnMgPSB7IC4uLnRoaXMub3B0cywgLi4udmlld09wdGlvbnMgfVxuICAgIGNvbnN0IGJyb3dzZXJQcm9wcyA9IHtcbiAgICAgIC4uLnRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKCksXG4gICAgICBpc0NoZWNrZWQ6IHRoaXMuX3NoYXJlZEhhbmRsZXIuaXNDaGVja2VkLFxuICAgICAgdG9nZ2xlQ2hlY2tib3g6IHRoaXMuX3NoYXJlZEhhbmRsZXIudG9nZ2xlQ2hlY2tib3gsXG4gICAgICBoYW5kbGVTY3JvbGw6IHRoaXMuaGFuZGxlU2Nyb2xsLFxuICAgICAgZG9uZTogdGhpcy5kb25lUGlja2luZyxcbiAgICAgIGNhbmNlbDogdGhpcy5jYW5jZWxQaWNraW5nLFxuICAgICAgaGVhZGVyQ29tcG9uZW50OiBIZWFkZXIoe1xuICAgICAgICB0cmlnZ2VyU2VhcmNoSW5wdXQ6IHRoaXMudHJpZ2dlclNlYXJjaElucHV0LFxuICAgICAgICBpMThuOiB0aGlzLnBsdWdpbi51cHB5LmkxOG4sXG4gICAgICB9KSxcbiAgICAgIHRpdGxlOiB0aGlzLnBsdWdpbi50aXRsZSxcbiAgICAgIHZpZXdUeXBlOiB0YXJnZXRWaWV3T3B0aW9ucy52aWV3VHlwZSxcbiAgICAgIHNob3dUaXRsZXM6IHRhcmdldFZpZXdPcHRpb25zLnNob3dUaXRsZXMsXG4gICAgICBzaG93RmlsdGVyOiB0YXJnZXRWaWV3T3B0aW9ucy5zaG93RmlsdGVyLFxuICAgICAgc2hvd0JyZWFkY3J1bWJzOiB0YXJnZXRWaWV3T3B0aW9ucy5zaG93QnJlYWRjcnVtYnMsXG4gICAgICBwbHVnaW5JY29uOiB0aGlzLnBsdWdpbi5pY29uLFxuICAgICAgaTE4bjogdGhpcy5wbHVnaW4udXBweS5pMThuLFxuICAgICAgdXBweUZpbGVzOiB0aGlzLnBsdWdpbi51cHB5LmdldEZpbGVzKCksXG4gICAgICB2YWxpZGF0ZVJlc3RyaWN0aW9uczogdGhpcy5wbHVnaW4udXBweS52YWxpZGF0ZVJlc3RyaWN0aW9ucyxcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPENsb3NlV3JhcHBlciBvblVubW91bnQ9e3RoaXMuY2xlYXJTZWxlY3Rpb259PlxuICAgICAgICA8QnJvd3NlciB7Li4uYnJvd3NlclByb3BzfSAvPlxuICAgICAgPC9DbG9zZVdyYXBwZXI+XG4gICAgKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vU2VhcmNoUHJvdmlkZXJWaWV3JylcbiIsImNvbnN0IHJlbW90ZUZpbGVPYmpUb0xvY2FsID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3JlbW90ZUZpbGVPYmpUb0xvY2FsJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTaGFyZWRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKHBsdWdpbikge1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luXG4gICAgdGhpcy5maWx0ZXJJdGVtcyA9IHRoaXMuZmlsdGVySXRlbXMuYmluZCh0aGlzKVxuICAgIHRoaXMudG9nZ2xlQ2hlY2tib3ggPSB0aGlzLnRvZ2dsZUNoZWNrYm94LmJpbmQodGhpcylcbiAgICB0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuaXNDaGVja2VkLmJpbmQodGhpcylcbiAgICB0aGlzLmxvYWRlcldyYXBwZXIgPSB0aGlzLmxvYWRlcldyYXBwZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgZmlsdGVySXRlbXMgKGl0ZW1zKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgaWYgKCFzdGF0ZS5maWx0ZXJJbnB1dCB8fCBzdGF0ZS5maWx0ZXJJbnB1dCA9PT0gJycpIHtcbiAgICAgIHJldHVybiBpdGVtc1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChmb2xkZXIpID0+IHtcbiAgICAgIHJldHVybiBmb2xkZXIubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RhdGUuZmlsdGVySW5wdXQudG9Mb3dlckNhc2UoKSkgIT09IC0xXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIGZpbGUvZm9sZGVyIGNoZWNrYm94IHRvIG9uL29mZiBzdGF0ZSB3aGlsZSB1cGRhdGluZyBmaWxlcyBsaXN0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgc29tZSBleHRyYSBjb21wbGV4aXR5IGNvbWVzIGZyb20gc3VwcG9ydGluZyBzaGlmdCtjbGljayB0b1xuICAgKiB0b2dnbGUgbXVsdGlwbGUgY2hlY2tib3hlcyBhdCBvbmNlLCB3aGljaCBpcyBkb25lIGJ5IGdldHRpbmcgYWxsIGZpbGVzXG4gICAqIGluIGJldHdlZW4gbGFzdCBjaGVja2VkIGZpbGUgYW5kIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgdG9nZ2xlQ2hlY2tib3ggKGUsIGZpbGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5jdXJyZW50VGFyZ2V0LmZvY3VzKClcbiAgICBjb25zdCB7IGZvbGRlcnMsIGZpbGVzIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLmZpbHRlckl0ZW1zKGZvbGRlcnMuY29uY2F0KGZpbGVzKSlcblxuICAgIC8vIFNoaWZ0LWNsaWNraW5nIHNlbGVjdHMgYSBzaW5nbGUgY29uc2VjdXRpdmUgbGlzdCBvZiBpdGVtc1xuICAgIC8vIHN0YXJ0aW5nIGF0IHRoZSBwcmV2aW91cyBjbGljayBhbmQgZGVzZWxlY3RzIGV2ZXJ5dGhpbmcgZWxzZS5cbiAgICBpZiAodGhpcy5sYXN0Q2hlY2tib3ggJiYgZS5zaGlmdEtleSkge1xuICAgICAgbGV0IGN1cnJlbnRTZWxlY3Rpb25cbiAgICAgIGNvbnN0IHByZXZJbmRleCA9IGl0ZW1zLmluZGV4T2YodGhpcy5sYXN0Q2hlY2tib3gpXG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBpdGVtcy5pbmRleE9mKGZpbGUpXG4gICAgICBpZiAocHJldkluZGV4IDwgY3VycmVudEluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSBpdGVtcy5zbGljZShwcmV2SW5kZXgsIGN1cnJlbnRJbmRleCArIDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50U2VsZWN0aW9uID0gaXRlbXMuc2xpY2UoY3VycmVudEluZGV4LCBwcmV2SW5kZXggKyAxKVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgcmVzdHJpY3Rpb25zIG9uIGVhY2ggZmlsZSBpbiBjdXJyZW50U2VsZWN0aW9uLFxuICAgICAgLy8gcmVkdWNlIGl0IHRvIG9ubHkgY29udGFpbiBmaWxlcyB0aGF0IHBhc3MgcmVzdHJpY3Rpb25zXG4gICAgICBjdXJyZW50U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbi5yZWR1Y2UoKHJlZHVjZWRDdXJyZW50U2VsZWN0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwcHkgPSB0aGlzLnBsdWdpbi51cHB5XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZFJlc3RyaWN0aW9ucyA9IHVwcHkudmFsaWRhdGVSZXN0cmljdGlvbnMoXG4gICAgICAgICAgcmVtb3RlRmlsZU9ialRvTG9jYWwoaXRlbSksXG4gICAgICAgICAgWy4uLnVwcHkuZ2V0RmlsZXMoKSwgLi4ucmVkdWNlZEN1cnJlbnRTZWxlY3Rpb25dXG4gICAgICAgIClcbiAgICAgICAgaWYgKCF2YWxpZGF0ZWRSZXN0cmljdGlvbnMucmVzdWx0KSB7XG4gICAgICAgICAgdXBweS5pbmZvKHsgbWVzc2FnZTogdmFsaWRhdGVkUmVzdHJpY3Rpb25zLnJlYXNvbiB9LCAnZXJyb3InLCB1cHB5Lm9wdHMuaW5mb1RpbWVvdXQpXG4gICAgICAgICAgcmV0dXJuIHJlZHVjZWRDdXJyZW50U2VsZWN0aW9uXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi5yZWR1Y2VkQ3VycmVudFNlbGVjdGlvbiwgaXRlbV1cbiAgICAgIH0pXG4gICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGN1cnJlbnRTZWxlY3Rpb24gfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMubGFzdENoZWNrYm94ID0gZmlsZVxuICAgIGNvbnN0IHsgY3VycmVudFNlbGVjdGlvbiB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGlmICh0aGlzLmlzQ2hlY2tlZChmaWxlKSkge1xuICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBjdXJyZW50U2VsZWN0aW9uOiBjdXJyZW50U2VsZWN0aW9uLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5pZCAhPT0gZmlsZS5pZCksXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGN1cnJlbnRTZWxlY3Rpb246IGN1cnJlbnRTZWxlY3Rpb24uY29uY2F0KFtmaWxlXSksXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlzQ2hlY2tlZCAoZmlsZSkge1xuICAgIGNvbnN0IHsgY3VycmVudFNlbGVjdGlvbiB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgIC8vIGNvbXBhcmluZyBpZCBpbnN0ZWFkIG9mIHRoZSBmaWxlIG9iamVjdCwgYmVjYXVzZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBvYmplY3RcbiAgICAvLyBjaGFuZ2VzIHdoZW4gd2Ugc3dpdGNoIGZvbGRlcnMsIGFuZCB0aGUgZmlsZSBsaXN0IGlzIHVwZGF0ZWRcbiAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbi5zb21lKChpdGVtKSA9PiBpdGVtLmlkID09PSBmaWxlLmlkKVxuICB9XG5cbiAgbG9hZGVyV3JhcHBlciAocHJvbWlzZSwgdGhlbiwgY2F0Y2hfKSB7XG4gICAgcHJvbWlzZVxuICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGxvYWRpbmc6IGZhbHNlIH0pXG4gICAgICAgIHRoZW4ocmVzdWx0KVxuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGxvYWRpbmc6IGZhbHNlIH0pXG4gICAgICAgIGNhdGNoXyhlcnIpXG4gICAgICB9KVxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgbG9hZGluZzogdHJ1ZSB9KVxuICB9XG59XG4iLCJjb25zdCBQcm92aWRlclZpZXdzID0gcmVxdWlyZSgnLi9Qcm92aWRlclZpZXcnKVxuY29uc3QgU2VhcmNoUHJvdmlkZXJWaWV3cyA9IHJlcXVpcmUoJy4vU2VhcmNoUHJvdmlkZXJWaWV3JylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFByb3ZpZGVyVmlld3MsXG4gIFNlYXJjaFByb3ZpZGVyVmlld3MsXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L3JvYm9kb2dcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlRyYW5zbG9hZGl0IFNESyBmb3IgYnJvd3NlcnMgYmFzZWQgb24gVXBweVwiLFxuICBcInZlcnNpb25cIjogXCIxLjEwLjEyXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJqc25leHQ6bWFpblwiOiBcInNyYy9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInRyYW5zbG9hZGl0XCIsXG4gICAgXCJmaWxlIGVuY29kaW5nXCIsXG4gICAgXCJlbmNvZGluZ1wiLFxuICAgIFwiZmlsZSBwcm9jZXNzaW5nXCIsXG4gICAgXCJ2aWRlbyBlbmNvZGluZ1wiLFxuICAgIFwiY3JvcFwiLFxuICAgIFwicmVzaXplXCIsXG4gICAgXCJ3YXRlcm1hcmtcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiZmlsZTouLi9jb3JlXCIsXG4gICAgXCJAdXBweS9kYXNoYm9hcmRcIjogXCJmaWxlOi4uL2Rhc2hib2FyZFwiLFxuICAgIFwiQHVwcHkvZHJvcGJveFwiOiBcImZpbGU6Li4vZHJvcGJveFwiLFxuICAgIFwiQHVwcHkvZmFjZWJvb2tcIjogXCJmaWxlOi4uL2ZhY2Vib29rXCIsXG4gICAgXCJAdXBweS9mb3JtXCI6IFwiZmlsZTouLi9mb3JtXCIsXG4gICAgXCJAdXBweS9nb29nbGUtZHJpdmVcIjogXCJmaWxlOi4uL2dvb2dsZS1kcml2ZVwiLFxuICAgIFwiQHVwcHkvaW5zdGFncmFtXCI6IFwiZmlsZTouLi9pbnN0YWdyYW1cIixcbiAgICBcIkB1cHB5L29uZWRyaXZlXCI6IFwiZmlsZTouLi9vbmVkcml2ZVwiLFxuICAgIFwiQHVwcHkvc3RhdHVzLWJhclwiOiBcImZpbGU6Li4vc3RhdHVzLWJhclwiLFxuICAgIFwiQHVwcHkvdHJhbnNsb2FkaXRcIjogXCJmaWxlOi4uL3RyYW5zbG9hZGl0XCIsXG4gICAgXCJAdXBweS91cmxcIjogXCJmaWxlOi4uL3VybFwiLFxuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJAdXBweS93ZWJjYW1cIjogXCJmaWxlOi4uL3dlYmNhbVwiLFxuICAgIFwiZXM2LXByb21pc2VcIjogXCI0LjIuNVwiLFxuICAgIFwid2hhdHdnLWZldGNoXCI6IFwiMy42LjJcIlxuICB9XG59XG4iLCJjb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3RvQXJyYXknKVxuY29uc3QgZmluZERPTUVsZW1lbnQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZmluZERPTUVsZW1lbnQnKVxuXG4vKipcbiAqIEFkZCBmaWxlcyBmcm9tIGV4aXN0aW5nIGZpbGUgaW5wdXRzIHRvIFVwcHkuXG4gKi9cbmNsYXNzIEF0dGFjaEZpbGVJbnB1dHMgZXh0ZW5kcyBQbHVnaW4ge1xuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG5cbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdBdHRhY2hGaWxlSW5wdXRzJ1xuICAgIHRoaXMudHlwZSA9ICdhY3F1aXJlcidcblxuICAgIHRoaXMuaGFuZGxlQ2hhbmdlID0gdGhpcy5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzKVxuICAgIHRoaXMuaW5wdXRzID0gbnVsbFxuICB9XG5cbiAgaGFuZGxlQ2hhbmdlIChldmVudCkge1xuICAgIHRoaXMuYWRkRmlsZXMoZXZlbnQudGFyZ2V0KVxuICB9XG5cbiAgYWRkRmlsZXMgKGlucHV0KSB7XG4gICAgY29uc3QgZmlsZXMgPSB0b0FycmF5KGlucHV0LmZpbGVzKVxuICAgIGZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMudXBweS5hZGRGaWxlKHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICBkYXRhOiBmaWxlLFxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghZXJyLmlzUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKGVycilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLmVsID0gZmluZERPTUVsZW1lbnQodGhpcy5vcHRzLnRhcmdldClcbiAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignW0F0dGFjaEZpbGVJbnB1dHNdIFRhcmdldCBmb3JtIGRvZXMgbm90IGV4aXN0JylcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlc3RyaWN0aW9ucyB9ID0gdGhpcy51cHB5Lm9wdHNcblxuICAgIHRoaXMuaW5wdXRzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiZmlsZVwiXScpXG4gICAgdGhpcy5pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuaGFuZGxlQ2hhbmdlKVxuXG4gICAgICBpZiAoIWlucHV0Lmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICBpZiAocmVzdHJpY3Rpb25zLm1heE51bWJlck9mRmlsZXMgIT09IDEpIHtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ211bHRpcGxlJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlucHV0Lmhhc0F0dHJpYnV0ZSgnYWNjZXB0JykgJiYgcmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXMpIHtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhY2NlcHQnLCByZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcy5qb2luKCcsJykpXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaW5wdXQgYWxyZWFkeSBjb250YWlucyBmaWxlcyAoZWcuIHVzZXIgc2VsZWN0ZWQgdGhlbSBiZWZvcmUgVXBweSBsb2FkZWQsXG4gICAgICAvLyBvciB0aGUgcGFnZSB3YXMgcmVmcmVzaGVkIGFuZCB0aGUgYnJvd3NlciBrZXB0IGZpbGVzIHNlbGVjdGVkKVxuICAgICAgdGhpcy5hZGRGaWxlcyhpbnB1dClcbiAgICB9KVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLmlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5oYW5kbGVDaGFuZ2UpXG4gICAgfSlcbiAgICB0aGlzLmlucHV0cyA9IG51bGxcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dGFjaEZpbGVJbnB1dHNcbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IGZpbmRET01FbGVtZW50ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2ZpbmRET01FbGVtZW50JylcblxuLyoqXG4gKiBBZnRlciBhbiB1cGxvYWQgY29tcGxldGVzLCBpbmplY3QgcmVzdWx0IGRhdGEgZnJvbSBUcmFuc2xvYWRpdCBpbiBhIGhpZGRlbiBpbnB1dC5cbiAqXG4gKiBNdXN0IGJlIGFkZGVkIF9hZnRlcl8gdGhlIFRyYW5zbG9hZGl0IHBsdWdpbi5cbiAqL1xuY2xhc3MgVHJhbnNsb2FkaXRGb3JtUmVzdWx0IGV4dGVuZHMgUGx1Z2luIHtcbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnVHJhbnNsb2FkaXRGb3JtUmVzdWx0J1xuICAgIHRoaXMudHlwZSA9ICdtb2RpZmllcidcblxuICAgIHRoaXMuaGFuZGxlVXBsb2FkID0gdGhpcy5oYW5kbGVVcGxvYWQuYmluZCh0aGlzKVxuICB9XG5cbiAgZ2V0QXNzZW1ibHlTdGF0dXNlcyAoZmlsZUlEcykge1xuICAgIGNvbnN0IGFzc2VtYmx5SWRzID0gW11cbiAgICBmaWxlSURzLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRClcbiAgICAgIGNvbnN0IGFzc2VtYmx5ID0gZmlsZS50cmFuc2xvYWRpdCAmJiBmaWxlLnRyYW5zbG9hZGl0LmFzc2VtYmx5XG4gICAgICBpZiAoYXNzZW1ibHkgJiYgYXNzZW1ibHlJZHMuaW5kZXhPZihhc3NlbWJseSkgPT09IC0xKSB7XG4gICAgICAgIGFzc2VtYmx5SWRzLnB1c2goYXNzZW1ibHkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IHRsID0gdGhpcy51cHB5LmdldFBsdWdpbih0aGlzLm9wdHMudHJhbnNsb2FkaXRQbHVnaW5JZCB8fCAnVHJhbnNsb2FkaXQnKVxuICAgIHJldHVybiBhc3NlbWJseUlkcy5tYXAoKGlkKSA9PiB0bC5nZXRBc3NlbWJseShpZCkpXG4gIH1cblxuICBoYW5kbGVVcGxvYWQgKGZpbGVJRHMpIHtcbiAgICBjb25zdCBhc3NlbWJsaWVzID0gdGhpcy5nZXRBc3NlbWJseVN0YXR1c2VzKGZpbGVJRHMpXG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgaW5wdXQudHlwZSA9ICdoaWRkZW4nXG4gICAgaW5wdXQubmFtZSA9IHRoaXMub3B0cy5uYW1lXG4gICAgaW5wdXQudmFsdWUgPSBKU09OLnN0cmluZ2lmeShhc3NlbWJsaWVzKVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gZmluZERPTUVsZW1lbnQodGhpcy5vcHRzLnRhcmdldClcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoaW5wdXQpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnVwcHkuYWRkUG9zdFByb2Nlc3Nvcih0aGlzLmhhbmRsZVVwbG9hZClcbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51cHB5LnJlbW92ZVBvc3RQcm9jZXNzb3IodGhpcy5oYW5kbGVVcGxvYWQpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2xvYWRpdEZvcm1SZXN1bHRcbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcblxuLyoqXG4gKiBBZGQgYSBgcmVzdWx0c2Aga2V5IHRvIHRoZSB1cGxvYWQgcmVzdWx0IGRhdGEsIGNvbnRhaW5pbmcgYWxsIFRyYW5zbG9hZGl0IEFzc2VtYmx5IHJlc3VsdHMuXG4gKi9cbmNsYXNzIFRyYW5zbG9hZGl0UmVzdWx0c1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcblxuICAgIHRoaXMudHlwZSA9ICdtb2RpZmllcidcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdUcmFuc2xvYWRpdFJlc3VsdHNQbHVnaW4nXG4gICAgdGhpcy5fYWZ0ZXJVcGxvYWQgPSB0aGlzLl9hZnRlclVwbG9hZC5iaW5kKHRoaXMpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnVwcHkuYWRkUG9zdFByb2Nlc3Nvcih0aGlzLl9hZnRlclVwbG9hZClcbiAgfVxuXG4gIF9hZnRlclVwbG9hZCAoZmlsZUlEcywgdXBsb2FkSUQpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF1cbiAgICBjb25zdCBhc3NlbWJsaWVzID0gcmVzdWx0ICYmIEFycmF5LmlzQXJyYXkocmVzdWx0LnRyYW5zbG9hZGl0KSA/IHJlc3VsdC50cmFuc2xvYWRpdCA6IFtdXG5cbiAgICAvLyBNZXJnZSB0aGUgYXNzZW1ibHkucmVzdWx0c1sqXSBhcnJheXMgYW5kIGFkZCBgc3RlcE5hbWVgIGFuZFxuICAgIC8vIGBhc3NlbWJseUlkYCBwcm9wZXJ0aWVzLlxuICAgIGNvbnN0IGFzc2VtYmx5UmVzdWx0cyA9IFtdXG4gICAgYXNzZW1ibGllcy5mb3JFYWNoKChhc3NlbWJseSkgPT4ge1xuICAgICAgT2JqZWN0LmtleXMoYXNzZW1ibHkucmVzdWx0cykuZm9yRWFjaCgoc3RlcE5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGFzc2VtYmx5LnJlc3VsdHNbc3RlcE5hbWVdXG4gICAgICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgYXNzZW1ibHlSZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgYXNzZW1ibHlJZDogYXNzZW1ibHkuYXNzZW1ibHlfaWQsXG4gICAgICAgICAgICBzdGVwTmFtZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy51cHB5LmFkZFJlc3VsdERhdGEodXBsb2FkSUQsIHtcbiAgICAgIHJlc3VsdHM6IGFzc2VtYmx5UmVzdWx0cyxcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNsb2FkaXRSZXN1bHRzUGx1Z2luXG4iLCJjb25zdCBEYXNoYm9hcmQgPSByZXF1aXJlKCdAdXBweS9kYXNoYm9hcmQnKVxuY29uc3QgaGFzID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2hhc1Byb3BlcnR5JylcblxuY29uc3QgZGFzaGJvYXJkT3B0aW9uTmFtZXMgPSBbXG4gICdtZXRhRmllbGRzJyxcbiAgJ3dpZHRoJyxcbiAgJ2hlaWdodCcsXG4gICd0aHVtYm5haWxXaWR0aCcsXG4gICdzaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdCcsXG4gICdzaG93UHJvZ3Jlc3NEZXRhaWxzJyxcbiAgJ2hpZGVSZXRyeUJ1dHRvbicsXG4gICdoaWRlQ2FuY2VsQnV0dG9uJyxcbiAgJ2hpZGVVcGxvYWRCdXR0b24nLFxuICAnaGlkZVByb2dyZXNzQWZ0ZXJGaW5pc2gnLFxuICAnbm90ZScsXG4gICdkaXNhYmxlU3RhdHVzQmFyJyxcbiAgJ2Rpc2FibGVJbmZvcm1lcicsXG4gICdkaXNhYmxlVGh1bWJuYWlsR2VuZXJhdG9yJyxcbiAgJ3Nob3dTZWxlY3RlZEZpbGVzJyxcbiAgJ3Byb3VkbHlEaXNwbGF5UG93ZXJlZEJ5VXBweScsXG4gICd0aGVtZScsXG5dXG5cbmNvbnN0IG1vZGFsRGFzaGJvYXJkT3B0aW9uTmFtZXMgPSBbXG4gICd0cmlnZ2VyJyxcbiAgJ2Nsb3NlTW9kYWxPbkNsaWNrT3V0c2lkZScsXG4gICdjbG9zZUFmdGVyRmluaXNoJyxcbiAgJ2Rpc2FibGVQYWdlU2Nyb2xsV2hlbk1vZGFsT3BlbicsXG4gICdhbmltYXRlT3BlbkNsb3NlJyxcbiAgJ29uUmVxdWVzdENsb3NlTW9kYWwnLFxuICAnYnJvd3NlckJhY2tCdXR0b25DbG9zZScsXG5dXG5cbmZ1bmN0aW9uIGFkZERhc2hib2FyZFBsdWdpbiAodXBweSwgb3B0cywgb3ZlcnJpZGVPcHRzKSB7XG4gIGNvbnN0IGRhc2hib2FyZE9wdHMgPSB7fVxuICBkYXNoYm9hcmRPcHRpb25OYW1lcy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoaGFzKG9wdHMsIGtleSkpIHtcbiAgICAgIGRhc2hib2FyZE9wdHNba2V5XSA9IG9wdHNba2V5XVxuICAgIH1cbiAgfSlcblxuICBjb25zdCBpbmxpbmUgPSBvdmVycmlkZU9wdHMuaW5saW5lID09IG51bGwgPyBkYXNoYm9hcmRPcHRzLmlubGluZSA6IG92ZXJyaWRlT3B0cy5pbmxpbmVcbiAgaWYgKCFpbmxpbmUpIHtcbiAgICBtb2RhbERhc2hib2FyZE9wdGlvbk5hbWVzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGhhcyhvcHRzLCBrZXkpKSB7XG4gICAgICAgIGRhc2hib2FyZE9wdHNba2V5XSA9IG9wdHNba2V5XVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB1cHB5LnVzZShEYXNoYm9hcmQsIHtcbiAgICAuLi5kYXNoYm9hcmRPcHRzLFxuICAgIC4uLm92ZXJyaWRlT3B0cyxcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGREYXNoYm9hcmRQbHVnaW5cbiIsImNvbnN0IFRyYW5zbG9hZGl0ID0gcmVxdWlyZSgnQHVwcHkvdHJhbnNsb2FkaXQnKVxuY29uc3QgaGFzID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2hhc1Byb3BlcnR5JylcblxuY29uc3QgcmVtb3RlUHJvdmlkZXJzID0ge1xuICBkcm9wYm94OiByZXF1aXJlKCdAdXBweS9kcm9wYm94JyksXG4gICdnb29nbGUtZHJpdmUnOiByZXF1aXJlKCdAdXBweS9nb29nbGUtZHJpdmUnKSxcbiAgaW5zdGFncmFtOiByZXF1aXJlKCdAdXBweS9pbnN0YWdyYW0nKSxcbiAgZmFjZWJvb2s6IHJlcXVpcmUoJ0B1cHB5L2ZhY2Vib29rJyksXG4gIG9uZWRyaXZlOiByZXF1aXJlKCdAdXBweS9vbmVkcml2ZScpLFxuICB1cmw6IHJlcXVpcmUoJ0B1cHB5L3VybCcpLFxufVxuXG5jb25zdCBsb2NhbFByb3ZpZGVycyA9IHtcbiAgd2ViY2FtOiByZXF1aXJlKCdAdXBweS93ZWJjYW0nKSxcbn1cblxuY29uc3QgcmVtb3RlUHJvdmlkZXJPcHRpb25OYW1lcyA9IFtcbiAgJ2NvbXBhbmlvblVybCcsXG4gICdjb21wYW5pb25BbGxvd2VkSG9zdHMnLFxuICAnY29tcGFuaW9uSGVhZGVycycsXG4gICdzZXJ2ZXJIZWFkZXJzJyxcbiAgJ3RhcmdldCcsXG5dXG5cbi8vIE5vIHNoYXJlZCBvcHRpb25zLlxuY29uc3QgbG9jYWxQcm92aWRlck9wdGlvbk5hbWVzID0gW1xuICAndGFyZ2V0Jyxcbl1cblxuZnVuY3Rpb24gYWRkUmVtb3RlUHJvdmlkZXIgKHVwcHksIG5hbWUsIG9wdHMpIHtcbiAgY29uc3QgUHJvdmlkZXIgPSByZW1vdGVQcm92aWRlcnNbbmFtZV1cbiAgY29uc3QgcHJvdmlkZXJPcHRpb25zID0ge1xuICAgIC8vIERlZmF1bHQgdG8gdGhlIDp0bDogQ29tcGFuaW9uIHNlcnZlcnMuXG4gICAgY29tcGFuaW9uVXJsOiBUcmFuc2xvYWRpdC5DT01QQU5JT04sXG4gICAgY29tcGFuaW9uQWxsb3dlZEhvc3RzOiBUcmFuc2xvYWRpdC5DT01QQU5JT05fUEFUVEVSTixcbiAgfVxuXG4gIHJlbW90ZVByb3ZpZGVyT3B0aW9uTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGlmIChoYXMob3B0cywgbmFtZSkpIHByb3ZpZGVyT3B0aW9uc1tuYW1lXSA9IG9wdHNbbmFtZV1cbiAgfSlcbiAgLy8gQXBwbHkgb3ZlcnJpZGVzIGZvciBhIHNwZWNpZmljIHByb3ZpZGVyIHBsdWdpbi5cbiAgaWYgKHR5cGVvZiBvcHRzW25hbWVdID09PSAnb2JqZWN0Jykge1xuICAgIE9iamVjdC5hc3NpZ24ocHJvdmlkZXJPcHRpb25zLCBvcHRzW25hbWVdKVxuICB9XG5cbiAgdXBweS51c2UoUHJvdmlkZXIsIHByb3ZpZGVyT3B0aW9ucylcbn1cblxuZnVuY3Rpb24gYWRkTG9jYWxQcm92aWRlciAodXBweSwgbmFtZSwgb3B0cykge1xuICBjb25zdCBQcm92aWRlciA9IGxvY2FsUHJvdmlkZXJzW25hbWVdXG4gIGNvbnN0IHByb3ZpZGVyT3B0aW9ucyA9IHt9XG5cbiAgbG9jYWxQcm92aWRlck9wdGlvbk5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBpZiAoaGFzKG9wdHMsIG5hbWUpKSBwcm92aWRlck9wdGlvbnNbbmFtZV0gPSBvcHRzW25hbWVdXG4gIH0pXG4gIC8vIEFwcGx5IG92ZXJyaWRlcyBmb3IgYSBzcGVjaWZpYyBwcm92aWRlciBwbHVnaW4uXG4gIGlmICh0eXBlb2Ygb3B0c1tuYW1lXSA9PT0gJ29iamVjdCcpIHtcbiAgICBPYmplY3QuYXNzaWduKHByb3ZpZGVyT3B0aW9ucywgb3B0c1tuYW1lXSlcbiAgfVxuXG4gIHVwcHkudXNlKFByb3ZpZGVyLCBwcm92aWRlck9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGFkZFByb3ZpZGVycyAodXBweSwgbmFtZXMsIG9wdHMgPSB7fSkge1xuICBuYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgaWYgKGhhcyhyZW1vdGVQcm92aWRlcnMsIG5hbWUpKSB7XG4gICAgICBhZGRSZW1vdGVQcm92aWRlcih1cHB5LCBuYW1lLCBvcHRzKVxuICAgIH0gZWxzZSBpZiAoaGFzKGxvY2FsUHJvdmlkZXJzLCBuYW1lKSkge1xuICAgICAgYWRkTG9jYWxQcm92aWRlcih1cHB5LCBuYW1lLCBvcHRzKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2YWxpZE5hbWVzID0gW1xuICAgICAgICAuLi5PYmplY3Qua2V5cyhyZW1vdGVQcm92aWRlcnMpLFxuICAgICAgICAuLi5PYmplY3Qua2V5cyhsb2NhbFByb3ZpZGVycyksXG4gICAgICBdXG4gICAgICBjb25zdCBleHBlY3RlZE5hbWVTdHJpbmcgPSB2YWxpZE5hbWVzXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLm1hcCgodmFsaWROYW1lKSA9PiBgJyR7dmFsaWROYW1lfSdgKVxuICAgICAgICAuam9pbignLCAnKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHByb3ZpZGVyICcke25hbWV9JywgZXhwZWN0ZWQgb25lIG9mIFske2V4cGVjdGVkTmFtZVN0cmluZ31dYClcbiAgICB9XG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkUHJvdmlkZXJzXG4iLCJjb25zdCBUcmFuc2xvYWRpdCA9IHJlcXVpcmUoJ0B1cHB5L3RyYW5zbG9hZGl0JylcbmNvbnN0IGhhcyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9oYXNQcm9wZXJ0eScpXG5jb25zdCBUcmFuc2xvYWRpdFJlc3VsdHMgPSByZXF1aXJlKCcuL1RyYW5zbG9hZGl0UmVzdWx0c1BsdWdpbicpXG5cbmNvbnN0IHRyYW5zbG9hZGl0T3B0aW9uTmFtZXMgPSBbXG4gICdzZXJ2aWNlJyxcbiAgJ3dhaXRGb3JFbmNvZGluZycsXG4gICd3YWl0Rm9yTWV0YWRhdGEnLFxuICAnYWx3YXlzUnVuQXNzZW1ibHknLFxuICAnaW1wb3J0RnJvbVVwbG9hZFVSTHMnLFxuICAnc2lnbmF0dXJlJyxcbiAgJ3BhcmFtcycsXG4gICdmaWVsZHMnLFxuICAnbGltaXQnLFxuICAnbG9jYWxlJyxcbiAgJ2dldEFzc2VtYmx5T3B0aW9ucycsXG5dXG5cbmZ1bmN0aW9uIGFkZFRyYW5zbG9hZGl0UGx1Z2luICh1cHB5LCBvcHRzKSB7XG4gIGNvbnN0IHRyYW5zbG9hZGl0T3B0aW9ucyA9IHt9XG4gIHRyYW5zbG9hZGl0T3B0aW9uTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGlmIChoYXMob3B0cywgbmFtZSkpIHRyYW5zbG9hZGl0T3B0aW9uc1tuYW1lXSA9IG9wdHNbbmFtZV1cbiAgfSlcbiAgdXBweS51c2UoVHJhbnNsb2FkaXQsIHRyYW5zbG9hZGl0T3B0aW9ucylcblxuICAvLyBBZGRzIGEgYHJlc3VsdHNgIGtleSB0byB0aGUgdXBsb2FkIHJlc3VsdCBkYXRhIGNvbnRhaW5pbmcgYSBmbGF0IGFycmF5IG9mIGFsbCByZXN1bHRzIGZyb20gYWxsIEFzc2VtYmxpZXMuXG4gIGlmICh0cmFuc2xvYWRpdE9wdGlvbnMud2FpdEZvckVuY29kaW5nKSB7XG4gICAgdXBweS51c2UoVHJhbnNsb2FkaXRSZXN1bHRzKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkVHJhbnNsb2FkaXRQbHVnaW5cbiIsImNvbnN0IFVwcHkgPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IGhhcyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9oYXNQcm9wZXJ0eScpXG5cbmNvbnN0IGV2ZW50TmFtZXMgPSB7XG4gIC8vIEZpbGUgbWFuYWdlbWVudCBldmVudHNcbiAgb25GaWxlQWRkZWQ6ICdmaWxlLWFkZGVkJyxcbiAgb25GaWxlUmVtb3ZlZDogJ2ZpbGUtcmVtb3ZlZCcsXG5cbiAgLy8gVHJhbnNsb2FkaXQgZXZlbnRzXG4gIG9uSW1wb3J0RXJyb3I6ICd0cmFuc2xvYWRpdDppbXBvcnQtZXJyb3InLFxuICBvbkFzc2VtYmx5Q3JlYXRlZDogJ3RyYW5zbG9hZGl0OmFzc2VtYmx5LWNyZWF0ZWQnLFxuICBvbkFzc2VtYmx5RXhlY3V0aW5nOiAndHJhbnNsb2FkaXQ6YXNzZW1ibHktZXhlY3V0aW5nJyxcbiAgb25Bc3NlbWJseUVycm9yOiAndHJhbnNsb2FkaXQ6YXNzZW1ibHktZXJyb3InLFxuICBvbkFzc2VtYmx5Q29tcGxldGU6ICd0cmFuc2xvYWRpdDpjb21wbGV0ZScsXG4gIG9uUmVzdWx0OiAndHJhbnNsb2FkaXQ6cmVzdWx0JyxcblxuICAvLyBVcGxvYWQgZXZlbnRzXG4gIG9uU3RhcnQ6ICd1cGxvYWQnLFxuICBvblBhdXNlOiAncGF1c2UtYWxsJyxcbiAgb25GaWxlUGF1c2U6ICd1cGxvYWQtcGF1c2UnLFxuICBvbkNhbmNlbDogJ2NhbmNlbC1hbGwnLFxuICBvbkVycm9yOiAnZXJyb3InLCAvLyBtb3N0bHkgYWtpbiB0byBwcm9taXNlIHJlamVjdGlvblxuICBvbkZpbGVDYW5jZWw6ICd1cGxvYWQtY2FuY2VsJyxcbiAgb25GaWxlUHJvZ3Jlc3M6ICd1cGxvYWQtcHJvZ3Jlc3MnLFxuICBvbkZpbGVFcnJvcjogJ3VwbG9hZC1lcnJvcicsXG4gIG9uVXBsb2FkZWQ6ICd0cmFuc2xvYWRpdDp1cGxvYWQnLFxuICBvbkNvbXBsZXRlOiAnY29tcGxldGUnLCAvLyBtb3N0bHkgYWtpbiB0byBwcm9taXNlIHJlc29sdXRpb25cbn1cblxuY29uc3QgdXBweU9wdGlvbk5hbWVzID0gW1xuICAnYXV0b1Byb2NlZWQnLFxuICAncmVzdHJpY3Rpb25zJyxcbiAgJ21ldGEnLFxuICAnb25CZWZvcmVGaWxlQWRkZWQnLFxuICAnb25CZWZvcmVVcGxvYWQnLFxuICAnZGVidWcnLFxuXVxuZnVuY3Rpb24gY3JlYXRlVXBweSAob3B0cywgb3ZlcnJpZGVzID0ge30pIHtcbiAgY29uc3QgdXBweU9wdGlvbnMgPSB7fVxuICB1cHB5T3B0aW9uTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGlmIChoYXMob3B0cywgbmFtZSkpIHVwcHlPcHRpb25zW25hbWVdID0gb3B0c1tuYW1lXVxuICB9KVxuICBPYmplY3QuYXNzaWduKHVwcHlPcHRpb25zLCBvdmVycmlkZXMpXG5cbiAgY29uc3QgdXBweSA9IG5ldyBVcHB5KHVwcHlPcHRpb25zKVxuXG4gIC8vIEJ1aWx0aW4gZXZlbnQgYWxpYXNlc1xuICBPYmplY3Qua2V5cyhldmVudE5hbWVzKS5mb3JFYWNoKChvcHRpb25OYW1lKSA9PiB7XG4gICAgY29uc3QgZXZlbnROYW1lID0gZXZlbnROYW1lc1tvcHRpb25OYW1lXVxuICAgIGlmICh0eXBlb2Ygb3B0c1tvcHRpb25OYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdXBweS5vbihldmVudE5hbWUsIG9wdHNbb3B0aW9uTmFtZV0pXG4gICAgfVxuICB9KVxuXG4gIC8vIEN1c3RvbSBldmVudHMgKHRoZXNlIHNob3VsZCBwcm9iYWJseSBiZSBhZGRlZCB0byBjb3JlKVxuICBpZiAodHlwZW9mIG9wdHMub25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVwcHkub24oJ3VwbG9hZC1wcm9ncmVzcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgdG90YWxQcm9ncmVzcyB9ID0gdXBweS5nZXRTdGF0ZSgpXG4gICAgICBvcHRzLm9uUHJvZ3Jlc3MuY2FsbCh1cHB5LCB0b3RhbFByb2dyZXNzKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdXBweVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVVwcHlcbiIsImNvbnN0IGNyZWF0ZVVwcHkgPSByZXF1aXJlKCcuL2NyZWF0ZVVwcHknKVxuY29uc3QgYWRkRGFzaGJvYXJkUGx1Z2luID0gcmVxdWlyZSgnLi9hZGREYXNoYm9hcmRQbHVnaW4nKVxuY29uc3QgYWRkVHJhbnNsb2FkaXRQbHVnaW4gPSByZXF1aXJlKCcuL2FkZFRyYW5zbG9hZGl0UGx1Z2luJylcbmNvbnN0IGFkZFByb3ZpZGVycyA9IHJlcXVpcmUoJy4vYWRkUHJvdmlkZXJzJylcblxuZnVuY3Rpb24gZGFzaGJvYXJkICh0YXJnZXQsIG9wdHMgPSB7fSkge1xuICBjb25zdCBpbmxpbmUgPSBvcHRzLmlubGluZSA9PSBudWxsID8gdHJ1ZSA6IG9wdHMuaW5saW5lXG5cbiAgY29uc3QgcGx1Z2luSWQgPSAnRGFzaGJvYXJkJ1xuICBjb25zdCB1cHB5ID0gY3JlYXRlVXBweShvcHRzKVxuICBhZGRUcmFuc2xvYWRpdFBsdWdpbih1cHB5LCBvcHRzKVxuICBhZGREYXNoYm9hcmRQbHVnaW4odXBweSwgb3B0cywge1xuICAgIGlkOiBwbHVnaW5JZCxcbiAgICBpbmxpbmUsXG4gICAgdGFyZ2V0LFxuICAgIGNsb3NlQWZ0ZXJGaW5pc2g6IGZhbHNlLFxuICB9KVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdHMucHJvdmlkZXJzKSkge1xuICAgIGFkZFByb3ZpZGVycyh1cHB5LCBvcHRzLnByb3ZpZGVycywge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIC8vIEluc3RhbGwgcHJvdmlkZXJzIGludG8gdGhlIERhc2hib2FyZC5cbiAgICAgIHRhcmdldDogdXBweS5nZXRQbHVnaW4ocGx1Z2luSWQpLFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdXBweVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhc2hib2FyZFxuIiwiY29uc3QgVXBweSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgRm9ybSA9IHJlcXVpcmUoJ0B1cHB5L2Zvcm0nKVxuY29uc3QgU3RhdHVzQmFyID0gcmVxdWlyZSgnQHVwcHkvc3RhdHVzLWJhcicpXG5jb25zdCBmaW5kRE9NRWxlbWVudCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9maW5kRE9NRWxlbWVudCcpXG5jb25zdCBoYXMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaGFzUHJvcGVydHknKVxuY29uc3QgQXR0YWNoRmlsZUlucHV0cyA9IHJlcXVpcmUoJy4vQXR0YWNoRmlsZUlucHV0cycpXG5jb25zdCBUcmFuc2xvYWRpdEZvcm1SZXN1bHQgPSByZXF1aXJlKCcuL1RyYW5zbG9hZGl0Rm9ybVJlc3VsdCcpXG5jb25zdCBhZGREYXNoYm9hcmRQbHVnaW4gPSByZXF1aXJlKCcuL2FkZERhc2hib2FyZFBsdWdpbicpXG5jb25zdCBhZGRUcmFuc2xvYWRpdFBsdWdpbiA9IHJlcXVpcmUoJy4vYWRkVHJhbnNsb2FkaXRQbHVnaW4nKVxuY29uc3QgYWRkUHJvdmlkZXJzID0gcmVxdWlyZSgnLi9hZGRQcm92aWRlcnMnKVxuXG5jb25zdCBkZWZhdWx0TG9jYWxlU3RyaW5ncyA9IHtcbiAgY2hvb3NlRmlsZXM6ICdDaG9vc2UgZmlsZXMnLFxufVxuXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRMb2NhbGUgKGRlZmF1bHRzLCB1c2VyUHJvdmlkZWQgPSB7fSkge1xuICBjb25zdCBzdHJpbmdzID0gdXNlclByb3ZpZGVkLnN0cmluZ3MgfHwge31cbiAgcmV0dXJuIHtcbiAgICAuLi51c2VyUHJvdmlkZWQsXG4gICAgc3RyaW5nczogeyAuLi5kZWZhdWx0cywgLi4uc3RyaW5ncyB9LFxuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm0gKHRhcmdldCwgb3B0cykge1xuICBpZiAoIW9wdHMpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JvYm9kb2cuZm9ybTogbXVzdCBwcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0JylcblxuICBvcHRzID0ge1xuICAgIC4uLm9wdHMsXG4gICAgbG9jYWxlOiBtZXJnZURlZmF1bHRMb2NhbGUoZGVmYXVsdExvY2FsZVN0cmluZ3MsIG9wdHMubG9jYWxlKSxcbiAgfVxuXG4gIGNvbnN0IHVwcHkgPSBuZXcgVXBweShvcHRzKVxuICBhZGRUcmFuc2xvYWRpdFBsdWdpbih1cHB5LCBvcHRzKVxuXG4gIHVwcHkudXNlKFRyYW5zbG9hZGl0Rm9ybVJlc3VsdCwge1xuICAgIHRhcmdldCxcbiAgICB0cmFuc2xvYWRpdFBsdWdpbklkOiAnVHJhbnNsb2FkaXQnLFxuICAgIG5hbWU6ICd0cmFuc2xvYWRpdCcsXG4gIH0pXG5cbiAgbGV0IHN1Ym1pdE9uU3VjY2VzcyA9IHRydWVcbiAgaWYgKGhhcyhvcHRzLCAnc3VibWl0T25TdWNjZXNzJykpIHtcbiAgICBzdWJtaXRPblN1Y2Nlc3MgPSAhIW9wdHMuc3VibWl0T25TdWNjZXNzXG4gIH1cblxuICBjb25zdCBmb3JtT3B0aW9ucyA9IHtcbiAgICB0YXJnZXQsXG4gICAgdHJpZ2dlclVwbG9hZE9uU3VibWl0OiB0cnVlLFxuICAgIHN1Ym1pdE9uU3VjY2VzcyxcbiAgICBhZGRSZXN1bHRUb0Zvcm06IGZhbHNlLCAvLyB1c2luZyBjdXN0b20gaW1wbGVtZW50YXRpb24gaW5zdGVhZFxuICB9XG4gIGlmIChoYXMob3B0cywgJ3RyaWdnZXJVcGxvYWRPblN1Ym1pdCcpKSB7XG4gICAgZm9ybU9wdGlvbnMudHJpZ2dlclVwbG9hZE9uU3VibWl0ID0gb3B0cy50cmlnZ2VyVXBsb2FkT25TdWJtaXRcbiAgfVxuXG4gIHVwcHkudXNlKEZvcm0sIGZvcm1PcHRpb25zKVxuXG4gIGNvbnN0IHVzZURhc2hib2FyZCA9IG9wdHMuZGFzaGJvYXJkIHx8IG9wdHMubW9kYWxcblxuICBpZiAodXNlRGFzaGJvYXJkKSB7XG4gICAgY29uc3QgZGFzaGJvYXJkVGFyZ2V0ID0gZmluZERPTUVsZW1lbnQob3B0cy5kYXNoYm9hcmQpIHx8IGRvY3VtZW50LmJvZHlcbiAgICBjb25zdCBkYXNoYm9hcmRJZCA9ICdmb3JtOkRhc2hib2FyZCdcbiAgICBjb25zdCBkYXNoYm9hcmRPcHRzID0ge1xuICAgICAgaWQ6IGRhc2hib2FyZElkLFxuICAgICAgdGFyZ2V0OiBkYXNoYm9hcmRUYXJnZXQsXG4gICAgfVxuICAgIGlmIChvcHRzLm1vZGFsKSB7XG4gICAgICBjb25zdCB0cmlnZ2VyID0gJ2lucHV0W3R5cGU9XCJmaWxlXCJdJ1xuICAgICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJylcbiAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IHVwcHkuaTE4bignY2hvb3NlRmlsZXMnKVxuICAgICAgYnV0dG9uLnR5cGUgPSAnYnV0dG9uJ1xuICAgICAgY29uc3Qgb2xkID0gZmluZERPTUVsZW1lbnQodHJpZ2dlciwgZmluZERPTUVsZW1lbnQodGFyZ2V0KSlcbiAgICAgIG9sZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChidXR0b24sIG9sZClcbiAgICAgIGRhc2hib2FyZE9wdHMuaW5saW5lID0gZmFsc2VcbiAgICAgIGRhc2hib2FyZE9wdHMudHJpZ2dlciA9IGJ1dHRvblxuICAgIH0gZWxzZSB7XG4gICAgICBkYXNoYm9hcmRPcHRzLmlubGluZSA9IHRydWVcbiAgICAgIGRhc2hib2FyZE9wdHMuaGlkZVVwbG9hZEJ1dHRvbiA9IHRydWVcbiAgICB9XG4gICAgYWRkRGFzaGJvYXJkUGx1Z2luKHVwcHksIG9wdHMsIGRhc2hib2FyZE9wdHMpXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzLnByb3ZpZGVycykpIHtcbiAgICAgIGFkZFByb3ZpZGVycyh1cHB5LCBvcHRzLnByb3ZpZGVycywge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICB0YXJnZXQ6IHVwcHkuZ2V0UGx1Z2luKGRhc2hib2FyZElkKSxcbiAgICAgIH0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVwcHkudXNlKEF0dGFjaEZpbGVJbnB1dHMsIHsgdGFyZ2V0IH0pXG4gIH1cblxuICBpZiAob3B0cy5zdGF0dXNCYXIpIHtcbiAgICB1cHB5LnVzZShTdGF0dXNCYXIsIHtcbiAgICAgIHRhcmdldDogb3B0cy5zdGF0dXNCYXIsXG4gICAgICAvLyBoaWRlIG1vc3Qgb2YgdGhlIHRoaW5ncyB0byBrZWVwIG91ciBhcGkgc2ltcGxlLFxuICAgICAgLy8gd2UgY2FuIGNoYW5nZSB0aGlzIGluIHRoZSBmdXR1cmUgaWYgc29tZW9uZSBuZWVkcyBpdFxuICAgICAgaGlkZVVwbG9hZEJ1dHRvbjogdHJ1ZSxcbiAgICAgIGhpZGVBZnRlckZpbmlzaDogdHJ1ZSxcbiAgICAgIGhpZGVSZXRyeUJ1dHRvbjogdHJ1ZSxcbiAgICAgIGhpZGVQYXVzZVJlc3VtZUJ1dHRvbnM6IHRydWUsXG4gICAgICBoaWRlQ2FuY2VsQnV0dG9uczogdHJ1ZSxcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHVwcHlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JtXG4iLCJjb25zdCBmb3JtID0gcmVxdWlyZSgnLi9mb3JtJylcbmNvbnN0IGRhc2hib2FyZCA9IHJlcXVpcmUoJy4vZGFzaGJvYXJkJylcbmNvbnN0IHBpY2sgPSByZXF1aXJlKCcuL3BpY2snKVxuY29uc3QgdXBsb2FkID0gcmVxdWlyZSgnLi91cGxvYWQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGFzaGJvYXJkLFxuICBmb3JtLFxuICBwaWNrLFxuICB1cGxvYWQsXG4gIFZFUlNJT046IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24sXG59XG4iLCJjb25zdCBjcmVhdGVVcHB5ID0gcmVxdWlyZSgnLi9jcmVhdGVVcHB5JylcbmNvbnN0IGFkZERhc2hib2FyZFBsdWdpbiA9IHJlcXVpcmUoJy4vYWRkRGFzaGJvYXJkUGx1Z2luJylcbmNvbnN0IGFkZFRyYW5zbG9hZGl0UGx1Z2luID0gcmVxdWlyZSgnLi9hZGRUcmFuc2xvYWRpdFBsdWdpbicpXG5jb25zdCBhZGRQcm92aWRlcnMgPSByZXF1aXJlKCcuL2FkZFByb3ZpZGVycycpXG5cbmNvbnN0IENBTkNFTCA9IHt9XG5cbmZ1bmN0aW9uIHBpY2sgKG9wdHMgPSB7fSkge1xuICBjb25zdCB0YXJnZXQgPSBvcHRzLnRhcmdldCB8fCBkb2N1bWVudC5ib2R5XG5cbiAgY29uc3QgcGx1Z2luSWQgPSAncGljaydcbiAgY29uc3QgdXBweSA9IGNyZWF0ZVVwcHkob3B0cywge1xuICAgIGFsbG93TXVsdGlwbGVVcGxvYWRzOiBmYWxzZSxcbiAgfSlcbiAgYWRkVHJhbnNsb2FkaXRQbHVnaW4odXBweSwgb3B0cylcbiAgYWRkRGFzaGJvYXJkUGx1Z2luKHVwcHksIG9wdHMsIHtcbiAgICBpZDogcGx1Z2luSWQsXG4gICAgdGFyZ2V0LFxuICAgIGNsb3NlQWZ0ZXJGaW5pc2g6IHRydWUsXG4gIH0pXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5wcm92aWRlcnMpKSB7XG4gICAgYWRkUHJvdmlkZXJzKHVwcHksIG9wdHMucHJvdmlkZXJzLCB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgLy8gSW5zdGFsbCBwcm92aWRlcnMgaW50byB0aGUgRGFzaGJvYXJkLlxuICAgICAgdGFyZ2V0OiB1cHB5LmdldFBsdWdpbihwbHVnaW5JZCksXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdXBweS5vbignY29tcGxldGUnLCAocmVzdWx0KSA9PiB7XG4gICAgICBpZiAocmVzdWx0LmZhaWxlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgICB9XG4gICAgfSlcbiAgICB1cHB5Lm9uKCdlcnJvcicsIHJlamVjdClcbiAgICB1cHB5Lm9uKCdjYW5jZWwtYWxsJywgKCkgPT4gcmVqZWN0KENBTkNFTCkpXG4gICAgdXBweS5nZXRQbHVnaW4ocGx1Z2luSWQpXG4gICAgICAub3Blbk1vZGFsKClcbiAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9LCAoZXJyKSA9PiB7XG4gICAgaWYgKGVyciA9PT0gQ0FOQ0VMKSB7XG4gICAgICB1cHB5LmdldFBsdWdpbihwbHVnaW5JZClcbiAgICAgICAgLnJlcXVlc3RDbG9zZU1vZGFsKClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHRocm93IGVyclxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpY2tcbiIsImNvbnN0IHRvQXJyYXkgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvdG9BcnJheScpXG5jb25zdCBjcmVhdGVVcHB5ID0gcmVxdWlyZSgnLi9jcmVhdGVVcHB5JylcbmNvbnN0IGFkZFRyYW5zbG9hZGl0UGx1Z2luID0gcmVxdWlyZSgnLi9hZGRUcmFuc2xvYWRpdFBsdWdpbicpXG5cbmZ1bmN0aW9uIHVwbG9hZCAoZmlsZXMsIG9wdHMgPSB7fSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsZXMpICYmIHR5cGVvZiBmaWxlcy5sZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgZmlsZXMgPSB0b0FycmF5KGZpbGVzKVxuICB9XG5cbiAgY29uc3QgdXBweSA9IGNyZWF0ZVVwcHkob3B0cywge1xuICAgIGFsbG93TXVsdGlwbGVVcGxvYWRzOiBmYWxzZSxcbiAgfSlcblxuICBhZGRUcmFuc2xvYWRpdFBsdWdpbih1cHB5LCBvcHRzKVxuXG4gIGZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICB1cHB5LmFkZEZpbGUoe1xuICAgICAgZGF0YTogZmlsZSxcbiAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgIG1ldGE6IGZpbGUubWV0YSB8fCB7fSxcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiB1cHB5LnVwbG9hZCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdXBsb2FkXG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L3N0YXR1cy1iYXJcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgcHJvZ3Jlc3MgYmFyIGZvciBVcHB5LCB3aXRoIG1hbnkgYmVsbHMgYW5kIHdoaXN0bGVzLlwiLFxuICBcInZlcnNpb25cIjogXCIxLjkuNlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwic3R5bGVcIjogXCJkaXN0L3N0eWxlLm1pbi5jc3NcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwicHJvZ3Jlc3MgYmFyXCIsXG4gICAgXCJzdGF0dXMgYmFyXCIsXG4gICAgXCJwcm9ncmVzc1wiLFxuICAgIFwidXBsb2FkXCIsXG4gICAgXCJldGFcIixcbiAgICBcInNwZWVkXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdHJhbnNsb2FkaXQvcHJldHRpZXItYnl0ZXNcIjogXCIwLjAuN1wiLFxuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJjbGFzc25hbWVzXCI6IFwiXjIuMi42XCIsXG4gICAgXCJsb2Rhc2gudGhyb3R0bGVcIjogXCJeNC4xLjFcIixcbiAgICBcInByZWFjdFwiOiBcIjguMi45XCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvcmVcIjogXCJeMS4wLjBcIlxuICB9XG59XG4iLCJjb25zdCB0aHJvdHRsZSA9IHJlcXVpcmUoJ2xvZGFzaC50aHJvdHRsZScpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBzdGF0dXNCYXJTdGF0ZXMgPSByZXF1aXJlKCcuL1N0YXR1c0JhclN0YXRlcycpXG5jb25zdCBwcmV0dGllckJ5dGVzID0gcmVxdWlyZSgnQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzJylcbmNvbnN0IHByZXR0eUVUQSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9wcmV0dHlFVEEnKVxuY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQcm9jZXNzaW5nUHJvZ3Jlc3MgKGZpbGVzKSB7XG4gIC8vIENvbGxlY3QgcHJlIG9yIHBvc3Rwcm9jZXNzaW5nIHByb2dyZXNzIHN0YXRlcy5cbiAgY29uc3QgcHJvZ3Jlc3NlcyA9IFtdXG4gIE9iamVjdC5rZXlzKGZpbGVzKS5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICBjb25zdCB7IHByb2dyZXNzIH0gPSBmaWxlc1tmaWxlSURdXG4gICAgaWYgKHByb2dyZXNzLnByZXByb2Nlc3MpIHtcbiAgICAgIHByb2dyZXNzZXMucHVzaChwcm9ncmVzcy5wcmVwcm9jZXNzKVxuICAgIH1cbiAgICBpZiAocHJvZ3Jlc3MucG9zdHByb2Nlc3MpIHtcbiAgICAgIHByb2dyZXNzZXMucHVzaChwcm9ncmVzcy5wb3N0cHJvY2VzcylcbiAgICB9XG4gIH0pXG5cbiAgLy8gSW4gdGhlIGZ1dHVyZSB3ZSBzaG91bGQgcHJvYmFibHkgZG8gdGhpcyBkaWZmZXJlbnRseS4gRm9yIG5vdyB3ZSdsbCB0YWtlIHRoZVxuICAvLyBtb2RlIGFuZCBtZXNzYWdlIGZyb20gdGhlIGZpcnN0IGZpbGXigKZcbiAgY29uc3QgeyBtb2RlLCBtZXNzYWdlIH0gPSBwcm9ncmVzc2VzWzBdXG4gIGNvbnN0IHZhbHVlID0gcHJvZ3Jlc3Nlcy5maWx0ZXIoaXNEZXRlcm1pbmF0ZSkucmVkdWNlKCh0b3RhbCwgcHJvZ3Jlc3MsIGluZGV4LCBhbGwpID0+IHtcbiAgICByZXR1cm4gdG90YWwgKyBwcm9ncmVzcy52YWx1ZSAvIGFsbC5sZW5ndGhcbiAgfSwgMClcbiAgZnVuY3Rpb24gaXNEZXRlcm1pbmF0ZSAocHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gcHJvZ3Jlc3MubW9kZSA9PT0gJ2RldGVybWluYXRlJ1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtb2RlLFxuICAgIG1lc3NhZ2UsXG4gICAgdmFsdWUsXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9nZ2xlUGF1c2VSZXN1bWUgKHByb3BzKSB7XG4gIGlmIChwcm9wcy5pc0FsbENvbXBsZXRlKSByZXR1cm5cblxuICBpZiAoIXByb3BzLnJlc3VtYWJsZVVwbG9hZHMpIHtcbiAgICByZXR1cm4gcHJvcHMuY2FuY2VsQWxsKClcbiAgfVxuXG4gIGlmIChwcm9wcy5pc0FsbFBhdXNlZCkge1xuICAgIHJldHVybiBwcm9wcy5yZXN1bWVBbGwoKVxuICB9XG5cbiAgcmV0dXJuIHByb3BzLnBhdXNlQWxsKClcbn1cblxuZnVuY3Rpb24gUmVuZGVyUmVTZWxlY3RHaG9zdHMgKHsgaTE4biB9KSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zZXJ2aWNlTXNnXCI+XG4gICAgICB7aTE4bigncmVTZWxlY3RHaG9zdHMnKX1cbiAgICAgIDxzdmcgY2xhc3NOYW1lPVwidXBweS1jLWljb24gdXBweS1TdGF0dXNCYXItc2VydmljZU1zZy1naG9zdHNJY29uXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgd2lkdGg9XCIxNVwiIGhlaWdodD1cIjE5XCIgdmlld0JveD1cIjAgMCAzNSAzOVwiPlxuICAgICAgICA8cGF0aCBkPVwiTTEuNzA4IDM4LjY2YzEuNzA5IDAgMy40MTctMy40MTcgNi44MzQtMy40MTcgMy40MTYgMCA1LjEyNSAzLjQxNyA4LjYxIDMuNDE3IDMuMzQ4IDAgNS4wNTYtMy40MTcgOC40NzMtMy40MTcgNC4zMDUgMCA1LjEyNSAzLjQxNyA2LjgzMyAzLjQxNy44ODkgMCAxLjcwOS0uODg5IDEuNzA5LTEuNzA5di0xOS42OEMzNC4xNjctNS43NTcgMC01Ljc1NyAwIDE3LjI3MXYxOS42OGMwIC44Mi44ODggMS43MDkgMS43MDggMS43MDl6bTguNTQyLTE3LjA4NGEzLjM4MyAzLjM4MyAwIDAxLTMuNDE3LTMuNDE2IDMuMzgzIDMuMzgzIDAgMDEzLjQxNy0zLjQxNyAzLjM4MyAzLjM4MyAwIDAxMy40MTcgMy40MTcgMy4zODMgMy4zODMgMCAwMS0zLjQxNyAzLjQxNnptMTMuNjY3IDBBMy4zODMgMy4zODMgMCAwMTIwLjUgMTguMTZhMy4zODMgMy4zODMgMCAwMTMuNDE3LTMuNDE3IDMuMzgzIDMuMzgzIDAgMDEzLjQxNiAzLjQxNyAzLjM4MyAzLjM4MyAwIDAxLTMuNDE2IDMuNDE2elwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBwcm9wcyA9IHByb3BzIHx8IHt9XG5cbiAgY29uc3Qge1xuICAgIG5ld0ZpbGVzLFxuICAgIGFsbG93TmV3VXBsb2FkLFxuICAgIGlzVXBsb2FkSW5Qcm9ncmVzcyxcbiAgICBpc0FsbFBhdXNlZCxcbiAgICByZXN1bWFibGVVcGxvYWRzLFxuICAgIGVycm9yLFxuICAgIGhpZGVVcGxvYWRCdXR0b24sXG4gICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uLFxuICAgIGhpZGVDYW5jZWxCdXR0b24sXG4gICAgaGlkZVJldHJ5QnV0dG9uLFxuICAgIHJlY292ZXJlZFN0YXRlLFxuICB9ID0gcHJvcHNcblxuICBjb25zdCB1cGxvYWRTdGF0ZSA9IHByb3BzLnVwbG9hZFN0YXRlXG5cbiAgbGV0IHByb2dyZXNzVmFsdWUgPSBwcm9wcy50b3RhbFByb2dyZXNzXG4gIGxldCBwcm9ncmVzc01vZGVcbiAgbGV0IHByb2dyZXNzQmFyQ29udGVudFxuXG4gIGlmICh1cGxvYWRTdGF0ZSA9PT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1BSRVBST0NFU1NJTkcgfHwgdXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9QT1NUUFJPQ0VTU0lORykge1xuICAgIGNvbnN0IHByb2dyZXNzID0gY2FsY3VsYXRlUHJvY2Vzc2luZ1Byb2dyZXNzKHByb3BzLmZpbGVzKVxuICAgIHByb2dyZXNzTW9kZSA9IHByb2dyZXNzLm1vZGVcbiAgICBpZiAocHJvZ3Jlc3NNb2RlID09PSAnZGV0ZXJtaW5hdGUnKSB7XG4gICAgICBwcm9ncmVzc1ZhbHVlID0gcHJvZ3Jlc3MudmFsdWUgKiAxMDBcbiAgICB9XG5cbiAgICBwcm9ncmVzc0JhckNvbnRlbnQgPSBQcm9ncmVzc0JhclByb2Nlc3NpbmcocHJvZ3Jlc3MpXG4gIH0gZWxzZSBpZiAodXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9DT01QTEVURSkge1xuICAgIHByb2dyZXNzQmFyQ29udGVudCA9IFByb2dyZXNzQmFyQ29tcGxldGUocHJvcHMpXG4gIH0gZWxzZSBpZiAodXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9VUExPQURJTkcpIHtcbiAgICBpZiAoIXByb3BzLnN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICAgIHByb2dyZXNzTW9kZSA9ICdpbmRldGVybWluYXRlJ1xuICAgICAgcHJvZ3Jlc3NWYWx1ZSA9IG51bGxcbiAgICB9XG5cbiAgICBwcm9ncmVzc0JhckNvbnRlbnQgPSBQcm9ncmVzc0JhclVwbG9hZGluZyhwcm9wcylcbiAgfSBlbHNlIGlmICh1cGxvYWRTdGF0ZSA9PT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX0VSUk9SKSB7XG4gICAgcHJvZ3Jlc3NWYWx1ZSA9IHVuZGVmaW5lZFxuICAgIHByb2dyZXNzQmFyQ29udGVudCA9IFByb2dyZXNzQmFyRXJyb3IocHJvcHMpXG4gIH1cblxuICBjb25zdCB3aWR0aCA9IHR5cGVvZiBwcm9ncmVzc1ZhbHVlID09PSAnbnVtYmVyJyA/IHByb2dyZXNzVmFsdWUgOiAxMDBcbiAgbGV0IGlzSGlkZGVuID0gKHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfV0FJVElORyAmJiBwcm9wcy5oaWRlVXBsb2FkQnV0dG9uKVxuICAgIHx8ICh1cGxvYWRTdGF0ZSA9PT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1dBSVRJTkcgJiYgIXByb3BzLm5ld0ZpbGVzID4gMClcbiAgICB8fCAodXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9DT01QTEVURSAmJiBwcm9wcy5oaWRlQWZ0ZXJGaW5pc2gpXG5cbiAgbGV0IHNob3dVcGxvYWRCdG4gPSAhZXJyb3IgJiYgbmV3RmlsZXNcbiAgICAmJiAhaXNVcGxvYWRJblByb2dyZXNzICYmICFpc0FsbFBhdXNlZFxuICAgICYmIGFsbG93TmV3VXBsb2FkICYmICFoaWRlVXBsb2FkQnV0dG9uXG5cbiAgaWYgKHJlY292ZXJlZFN0YXRlKSB7XG4gICAgaXNIaWRkZW4gPSBmYWxzZVxuICAgIHNob3dVcGxvYWRCdG4gPSB0cnVlXG4gIH1cblxuICBjb25zdCBzaG93Q2FuY2VsQnRuID0gIWhpZGVDYW5jZWxCdXR0b25cbiAgICAmJiB1cGxvYWRTdGF0ZSAhPT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1dBSVRJTkdcbiAgICAmJiB1cGxvYWRTdGF0ZSAhPT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX0NPTVBMRVRFXG4gIGNvbnN0IHNob3dQYXVzZVJlc3VtZUJ0biA9IHJlc3VtYWJsZVVwbG9hZHMgJiYgIWhpZGVQYXVzZVJlc3VtZUJ1dHRvblxuICAgICYmIHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfVVBMT0FESU5HXG5cbiAgY29uc3Qgc2hvd1JldHJ5QnRuID0gZXJyb3IgJiYgIWhpZGVSZXRyeUJ1dHRvblxuXG4gIGNvbnN0IHNob3dEb25lQnRuID0gcHJvcHMuZG9uZUJ1dHRvbkhhbmRsZXIgJiYgdXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9DT01QTEVURVxuXG4gIGNvbnN0IHByb2dyZXNzQ2xhc3NOYW1lcyA9IGB1cHB5LVN0YXR1c0Jhci1wcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtwcm9ncmVzc01vZGUgPyBgaXMtJHtwcm9ncmVzc01vZGV9YCA6ICcnfWBcblxuICBjb25zdCBzdGF0dXNCYXJDbGFzc05hbWVzID0gY2xhc3NOYW1lcyhcbiAgICB7ICd1cHB5LVJvb3QnOiBwcm9wcy5pc1RhcmdldERPTUVsIH0sXG4gICAgJ3VwcHktU3RhdHVzQmFyJyxcbiAgICBgaXMtJHt1cGxvYWRTdGF0ZX1gLFxuICAgIHsgJ2hhcy1naG9zdHMnOiBwcm9wcy5pc1NvbWVHaG9zdCB9XG4gIClcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdGF0dXNCYXJDbGFzc05hbWVzfSBhcmlhLWhpZGRlbj17aXNIaWRkZW59PlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e3Byb2dyZXNzQ2xhc3NOYW1lc31cbiAgICAgICAgc3R5bGU9e3sgd2lkdGg6IGAke3dpZHRofSVgIH19XG4gICAgICAgIHJvbGU9XCJwcm9ncmVzc2JhclwiXG4gICAgICAgIGFyaWEtdmFsdWVtaW49XCIwXCJcbiAgICAgICAgYXJpYS12YWx1ZW1heD1cIjEwMFwiXG4gICAgICAgIGFyaWEtdmFsdWVub3c9e3Byb2dyZXNzVmFsdWV9XG4gICAgICAvPlxuICAgICAge3Byb2dyZXNzQmFyQ29udGVudH1cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItYWN0aW9uc1wiPlxuICAgICAgICB7c2hvd1VwbG9hZEJ0biA/IDxVcGxvYWRCdG4gey4uLnByb3BzfSB1cGxvYWRTdGF0ZT17dXBsb2FkU3RhdGV9IC8+IDogbnVsbH1cbiAgICAgICAge3Nob3dSZXRyeUJ0biA/IDxSZXRyeUJ0biB7Li4ucHJvcHN9IC8+IDogbnVsbH1cbiAgICAgICAge3Nob3dQYXVzZVJlc3VtZUJ0biA/IDxQYXVzZVJlc3VtZUJ1dHRvbiB7Li4ucHJvcHN9IC8+IDogbnVsbH1cbiAgICAgICAge3Nob3dDYW5jZWxCdG4gPyA8Q2FuY2VsQnRuIHsuLi5wcm9wc30gLz4gOiBudWxsfVxuICAgICAgICB7c2hvd0RvbmVCdG4gPyA8RG9uZUJ0biB7Li4ucHJvcHN9IC8+IDogbnVsbH1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IFVwbG9hZEJ0biA9IChwcm9wcykgPT4ge1xuICBjb25zdCB1cGxvYWRCdG5DbGFzc05hbWVzID0gY2xhc3NOYW1lcyhcbiAgICAndXBweS11LXJlc2V0JyxcbiAgICAndXBweS1jLWJ0bicsXG4gICAgJ3VwcHktU3RhdHVzQmFyLWFjdGlvbkJ0bicsXG4gICAgJ3VwcHktU3RhdHVzQmFyLWFjdGlvbkJ0bi0tdXBsb2FkJyxcbiAgICB7ICd1cHB5LWMtYnRuLXByaW1hcnknOiBwcm9wcy51cGxvYWRTdGF0ZSA9PT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1dBSVRJTkcgfSxcbiAgICB7ICd1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4tLWRpc2FibGVkJzogcHJvcHMuaXNTb21lR2hvc3QgfVxuICApXG5cbiAgY29uc3QgdXBsb2FkQnRuVGV4dCA9IHByb3BzLm5ld0ZpbGVzICYmIHByb3BzLmlzVXBsb2FkU3RhcnRlZCAmJiAhcHJvcHMucmVjb3ZlcmVkU3RhdGVcbiAgICA/IHByb3BzLmkxOG4oJ3VwbG9hZFhOZXdGaWxlcycsIHsgc21hcnRfY291bnQ6IHByb3BzLm5ld0ZpbGVzIH0pXG4gICAgOiBwcm9wcy5pMThuKCd1cGxvYWRYRmlsZXMnLCB7IHNtYXJ0X2NvdW50OiBwcm9wcy5uZXdGaWxlcyB9KVxuXG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBjbGFzc05hbWU9e3VwbG9hZEJ0bkNsYXNzTmFtZXN9XG4gICAgICBhcmlhLWxhYmVsPXtwcm9wcy5pMThuKCd1cGxvYWRYRmlsZXMnLCB7IHNtYXJ0X2NvdW50OiBwcm9wcy5uZXdGaWxlcyB9KX1cbiAgICAgIG9uQ2xpY2s9e3Byb3BzLnN0YXJ0VXBsb2FkfVxuICAgICAgZGlzYWJsZWQ9e3Byb3BzLmlzU29tZUdob3N0fVxuICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgID5cbiAgICAgIHt1cGxvYWRCdG5UZXh0fVxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbmNvbnN0IFJldHJ5QnRuID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4gdXBweS1TdGF0dXNCYXItYWN0aW9uQnRuLS1yZXRyeVwiXG4gICAgICBhcmlhLWxhYmVsPXtwcm9wcy5pMThuKCdyZXRyeVVwbG9hZCcpfVxuICAgICAgb25DbGljaz17cHJvcHMucmV0cnlBbGx9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCI4XCIgaGVpZ2h0PVwiMTBcIiB2aWV3Qm94PVwiMCAwIDggMTBcIj5cbiAgICAgICAgPHBhdGggZD1cIk00IDIuNDA4YTIuNzUgMi43NSAwIDEgMCAyLjc1IDIuNzUuNjI2LjYyNiAwIDAgMSAxLjI1LjAxOHYuMDIzYTQgNCAwIDEgMS00LTQuMDQxVi4yNWEuMjUuMjUgMCAwIDEgLjM4OS0uMjA4bDIuMjk5IDEuNTMzYS4yNS4yNSAwIDAgMSAwIC40MTZsLTIuMyAxLjUzM0EuMjUuMjUgMCAwIDEgNCAzLjMxNnYtLjkwOHpcIiAvPlxuICAgICAgPC9zdmc+XG4gICAgICB7cHJvcHMuaTE4bigncmV0cnknKX1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5jb25zdCBDYW5jZWxCdG4gPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LVN0YXR1c0Jhci1hY3Rpb25DaXJjbGVCdG5cIlxuICAgICAgdGl0bGU9e3Byb3BzLmkxOG4oJ2NhbmNlbCcpfVxuICAgICAgYXJpYS1sYWJlbD17cHJvcHMuaTE4bignY2FuY2VsJyl9XG4gICAgICBvbkNsaWNrPXtwcm9wcy5jYW5jZWxBbGx9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAxNiAxNlwiPlxuICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgIDxjaXJjbGUgZmlsbD1cIiM4ODhcIiBjeD1cIjhcIiBjeT1cIjhcIiByPVwiOFwiIC8+XG4gICAgICAgICAgPHBhdGggZmlsbD1cIiNGRkZcIiBkPVwiTTkuMjgzIDhsMi41NjcgMi41NjctMS4yODMgMS4yODNMOCA5LjI4MyA1LjQzMyAxMS44NSA0LjE1IDEwLjU2NyA2LjcxNyA4IDQuMTUgNS40MzMgNS40MzMgNC4xNSA4IDYuNzE3bDIuNTY3LTIuNTY3IDEuMjgzIDEuMjgzelwiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbmNvbnN0IFBhdXNlUmVzdW1lQnV0dG9uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgaXNBbGxQYXVzZWQsIGkxOG4gfSA9IHByb3BzXG4gIGNvbnN0IHRpdGxlID0gaXNBbGxQYXVzZWQgPyBpMThuKCdyZXN1bWUnKSA6IGkxOG4oJ3BhdXNlJylcblxuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIHRpdGxlPXt0aXRsZX1cbiAgICAgIGFyaWEtbGFiZWw9e3RpdGxlfVxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktU3RhdHVzQmFyLWFjdGlvbkNpcmNsZUJ0blwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIG9uQ2xpY2s9eygpID0+IHRvZ2dsZVBhdXNlUmVzdW1lKHByb3BzKX1cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICB7aXNBbGxQYXVzZWQgPyAoXG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIj5cbiAgICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgICAgPGNpcmNsZSBmaWxsPVwiIzg4OFwiIGN4PVwiOFwiIGN5PVwiOFwiIHI9XCI4XCIgLz5cbiAgICAgICAgICAgIDxwYXRoIGZpbGw9XCIjRkZGXCIgZD1cIk02IDQuMjVMMTEuNSA4IDYgMTEuNzV6XCIgLz5cbiAgICAgICAgICA8L2c+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgKSA6IChcbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAxNiAxNlwiPlxuICAgICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgICA8Y2lyY2xlIGZpbGw9XCIjODg4XCIgY3g9XCI4XCIgY3k9XCI4XCIgcj1cIjhcIiAvPlxuICAgICAgICAgICAgPHBhdGggZD1cIk01IDQuNWgydjdINXYtN3ptNCAwaDJ2N0g5di03elwiIGZpbGw9XCIjRkZGXCIgLz5cbiAgICAgICAgICA8L2c+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgKX1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5jb25zdCBEb25lQnRuID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgaTE4biB9ID0gcHJvcHNcbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktU3RhdHVzQmFyLWFjdGlvbkJ0biB1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4tLWRvbmVcIlxuICAgICAgb25DbGljaz17cHJvcHMuZG9uZUJ1dHRvbkhhbmRsZXJ9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAge2kxOG4oJ2RvbmUnKX1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5jb25zdCBMb2FkaW5nU3Bpbm5lciA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXNwaW5uZXJcIiBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiPlxuICAgICAgPHBhdGggZD1cIk0xMy45ODMgNi41NDdjLS4xMi0yLjUwOS0xLjY0LTQuODkzLTMuOTM5LTUuOTM2LTIuNDgtMS4xMjctNS40ODgtLjY1Ni03LjU1NiAxLjA5NEMuNTI0IDMuMzY3LS4zOTggNi4wNDguMTYyIDguNTYyYy41NTYgMi40OTUgMi40NiA0LjUyIDQuOTQgNS4xODMgMi45MzIuNzg0IDUuNjEtLjYwMiA3LjI1Ni0zLjAxNS0xLjQ5MyAxLjk5My0zLjc0NSAzLjMwOS02LjI5OCAyLjg2OC0yLjUxNC0uNDM0LTQuNTc4LTIuMzQ5LTUuMTUzLTQuODRhNi4yMjYgNi4yMjYgMCAwIDEgMi45OC02Ljc3OEM2LjM0LjU4NiA5Ljc0IDEuMSAxMS4zNzMgMy40OTNjLjQwNy41OTYuNjkzIDEuMjgyLjg0MiAxLjk4OC4xMjcuNTk4LjA3MyAxLjE5Ny4xNjEgMS43OTQuMDc4LjUyNS41NDMgMS4yNTcgMS4xNS44NjQuNTI1LS4zNDEuNDktMS4wNS40NTYtMS41OTItLjAwNy0uMTUuMDIuMyAwIDBcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmNvbnN0IFByb2dyZXNzQmFyUHJvY2Vzc2luZyA9IChwcm9wcykgPT4ge1xuICBjb25zdCB2YWx1ZSA9IE1hdGgucm91bmQocHJvcHMudmFsdWUgKiAxMDApXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLWNvbnRlbnRcIj5cbiAgICAgIDxMb2FkaW5nU3Bpbm5lciAvPlxuICAgICAge3Byb3BzLm1vZGUgPT09ICdkZXRlcm1pbmF0ZScgPyBgJHt2YWx1ZX0lIFxcdTAwQjcgYCA6ICcnfVxuICAgICAge3Byb3BzLm1lc3NhZ2V9XG4gICAgPC9kaXY+XG4gIClcbn1cblxuY29uc3QgcmVuZGVyRG90ID0gKCkgPT5cbiAgJyBcXHUwMEI3ICdcblxuY29uc3QgUHJvZ3Jlc3NEZXRhaWxzID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGlmU2hvd0ZpbGVzVXBsb2FkZWRPZlRvdGFsID0gcHJvcHMubnVtVXBsb2FkcyA+IDFcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3RhdHVzU2Vjb25kYXJ5XCI+XG4gICAgICB7XG4gICAgICAgIGlmU2hvd0ZpbGVzVXBsb2FkZWRPZlRvdGFsXG4gICAgICAgICYmIHByb3BzLmkxOG4oJ2ZpbGVzVXBsb2FkZWRPZlRvdGFsJywge1xuICAgICAgICAgIGNvbXBsZXRlOiBwcm9wcy5jb21wbGV0ZSxcbiAgICAgICAgICBzbWFydF9jb3VudDogcHJvcHMubnVtVXBsb2FkcyxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLWFkZGl0aW9uYWxJbmZvXCI+XG4gICAgICAgIHsvKiBXaGVuIHNob3VsZCB3ZSByZW5kZXIgdGhpcyBkb3Q/XG4gICAgICAgICAgMS4gLi1hZGRpdGlvbmFsSW5mbyBpcyBzaG93biAoaGFwcGVucyBvbmx5IG9uIGRlc2t0b3BzKVxuICAgICAgICAgIDIuIEFORCAnZmlsZXNVcGxvYWRlZE9mVG90YWwnIHdhcyBzaG93blxuICAgICAgICAqL31cbiAgICAgICAge2lmU2hvd0ZpbGVzVXBsb2FkZWRPZlRvdGFsICYmIHJlbmRlckRvdCgpfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBwcm9wcy5pMThuKCdkYXRhVXBsb2FkZWRPZlRvdGFsJywge1xuICAgICAgICAgICAgY29tcGxldGU6IHByZXR0aWVyQnl0ZXMocHJvcHMudG90YWxVcGxvYWRlZFNpemUpLFxuICAgICAgICAgICAgdG90YWw6IHByZXR0aWVyQnl0ZXMocHJvcHMudG90YWxTaXplKSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAge3JlbmRlckRvdCgpfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBwcm9wcy5pMThuKCd4VGltZUxlZnQnLCB7XG4gICAgICAgICAgICB0aW1lOiBwcmV0dHlFVEEocHJvcHMudG90YWxFVEEpLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIDwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5jb25zdCBVbmtub3duUHJvZ3Jlc3NEZXRhaWxzID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNTZWNvbmRhcnlcIj5cbiAgICAgIHtwcm9wcy5pMThuKCdmaWxlc1VwbG9hZGVkT2ZUb3RhbCcsIHsgY29tcGxldGU6IHByb3BzLmNvbXBsZXRlLCBzbWFydF9jb3VudDogcHJvcHMubnVtVXBsb2FkcyB9KX1cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5jb25zdCBVcGxvYWROZXdseUFkZGVkRmlsZXMgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdXBsb2FkQnRuQ2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMoXG4gICAgJ3VwcHktdS1yZXNldCcsXG4gICAgJ3VwcHktYy1idG4nLFxuICAgICd1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4nLFxuICAgICd1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4tLXVwbG9hZE5ld2x5QWRkZWQnXG4gIClcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3RhdHVzU2Vjb25kYXJ5XCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1NlY29uZGFyeUhpbnRcIj5cbiAgICAgICAge3Byb3BzLmkxOG4oJ3hNb3JlRmlsZXNBZGRlZCcsIHsgc21hcnRfY291bnQ6IHByb3BzLm5ld0ZpbGVzIH0pfVxuICAgICAgPC9kaXY+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzc05hbWU9e3VwbG9hZEJ0bkNsYXNzTmFtZXN9XG4gICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ3VwbG9hZFhGaWxlcycsIHsgc21hcnRfY291bnQ6IHByb3BzLm5ld0ZpbGVzIH0pfVxuICAgICAgICBvbkNsaWNrPXtwcm9wcy5zdGFydFVwbG9hZH1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmkxOG4oJ3VwbG9hZCcpfVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuY29uc3QgVGhyb3R0bGVkUHJvZ3Jlc3NEZXRhaWxzID0gdGhyb3R0bGUoUHJvZ3Jlc3NEZXRhaWxzLCA1MDAsIHsgbGVhZGluZzogdHJ1ZSwgdHJhaWxpbmc6IHRydWUgfSlcblxuY29uc3QgUHJvZ3Jlc3NCYXJVcGxvYWRpbmcgPSAocHJvcHMpID0+IHtcbiAgaWYgKCFwcm9wcy5pc1VwbG9hZFN0YXJ0ZWQgfHwgcHJvcHMuaXNBbGxDb21wbGV0ZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCB0aXRsZSA9IHByb3BzLmlzQWxsUGF1c2VkID8gcHJvcHMuaTE4bigncGF1c2VkJykgOiBwcm9wcy5pMThuKCd1cGxvYWRpbmcnKVxuICBjb25zdCBzaG93VXBsb2FkTmV3bHlBZGRlZEZpbGVzID0gcHJvcHMubmV3RmlsZXMgJiYgcHJvcHMuaXNVcGxvYWRTdGFydGVkXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLWNvbnRlbnRcIiBhcmlhLWxhYmVsPXt0aXRsZX0gdGl0bGU9e3RpdGxlfT5cbiAgICAgIHshcHJvcHMuaXNBbGxQYXVzZWQgPyA8TG9hZGluZ1NwaW5uZXIgLz4gOiBudWxsfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNQcmltYXJ5XCI+XG4gICAgICAgICAge3Byb3BzLnN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MgPyBgJHt0aXRsZX06ICR7cHJvcHMudG90YWxQcm9ncmVzc30lYCA6IHRpdGxlfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgeyFwcm9wcy5pc0FsbFBhdXNlZCAmJiAhc2hvd1VwbG9hZE5ld2x5QWRkZWRGaWxlcyAmJiBwcm9wcy5zaG93UHJvZ3Jlc3NEZXRhaWxzXG4gICAgICAgICAgPyAocHJvcHMuc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyA/IDxUaHJvdHRsZWRQcm9ncmVzc0RldGFpbHMgey4uLnByb3BzfSAvPiA6IDxVbmtub3duUHJvZ3Jlc3NEZXRhaWxzIHsuLi5wcm9wc30gLz4pXG4gICAgICAgICAgOiBudWxsfVxuICAgICAgICB7c2hvd1VwbG9hZE5ld2x5QWRkZWRGaWxlcyA/IDxVcGxvYWROZXdseUFkZGVkRmlsZXMgey4uLnByb3BzfSAvPiA6IG51bGx9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5jb25zdCBQcm9ncmVzc0JhckNvbXBsZXRlID0gKHsgdG90YWxQcm9ncmVzcywgaTE4biB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1jb250ZW50XCIgcm9sZT1cInN0YXR1c1wiIHRpdGxlPXtpMThuKCdjb21wbGV0ZScpfT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3RhdHVzXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3RhdHVzUHJpbWFyeVwiPlxuICAgICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNJbmRpY2F0b3IgdXBweS1jLWljb25cIiB3aWR0aD1cIjE1XCIgaGVpZ2h0PVwiMTFcIiB2aWV3Qm94PVwiMCAwIDE1IDExXCI+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTS40MTQgNS44NDNMMS42MjcgNC42M2wzLjQ3MiAzLjQ3MkwxMy4yMDIgMGwxLjIxMiAxLjIxM0w1LjEgMTAuNTI4elwiIC8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgICAge2kxOG4oJ2NvbXBsZXRlJyl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuY29uc3QgUHJvZ3Jlc3NCYXJFcnJvciA9ICh7IGVycm9yLCByZXRyeUFsbCwgaGlkZVJldHJ5QnV0dG9uLCBpMThuIH0pID0+IHtcbiAgZnVuY3Rpb24gZGlzcGxheUVycm9yQWxlcnQgKCkge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGAke2kxOG4oJ3VwbG9hZEZhaWxlZCcpfSBcXG5cXG4gJHtlcnJvcn1gXG4gICAgYWxlcnQoZXJyb3JNZXNzYWdlKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLWNvbnRlbnRcIiByb2xlPVwiYWxlcnRcIiB0aXRsZT17aTE4bigndXBsb2FkRmFpbGVkJyl9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNQcmltYXJ5XCI+XG4gICAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c0luZGljYXRvciB1cHB5LWMtaWNvblwiIHdpZHRoPVwiMTFcIiBoZWlnaHQ9XCIxMVwiIHZpZXdCb3g9XCIwIDAgMTEgMTFcIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNNC4yNzggNS41TDAgMS4yMjIgMS4yMjIgMCA1LjUgNC4yNzggOS43NzggMCAxMSAxLjIyMiA2LjcyMiA1LjUgMTEgOS43NzggOS43NzggMTEgNS41IDYuNzIyIDEuMjIyIDExIDAgOS43Nzh6XCIgLz5cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICB7aTE4bigndXBsb2FkRmFpbGVkJyl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8c3BhblxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1kZXRhaWxzXCJcbiAgICAgICAgYXJpYS1sYWJlbD17ZXJyb3J9XG4gICAgICAgIGRhdGEtbWljcm90aXAtcG9zaXRpb249XCJ0b3AtcmlnaHRcIlxuICAgICAgICBkYXRhLW1pY3JvdGlwLXNpemU9XCJtZWRpdW1cIlxuICAgICAgICByb2xlPVwidG9vbHRpcFwiXG4gICAgICAgIG9uQ2xpY2s9e2Rpc3BsYXlFcnJvckFsZXJ0fVxuICAgICAgPlxuICAgICAgICA/XG4gICAgICA8L3NwYW4+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBTVEFURV9FUlJPUjogJ2Vycm9yJyxcbiAgU1RBVEVfV0FJVElORzogJ3dhaXRpbmcnLFxuICBTVEFURV9QUkVQUk9DRVNTSU5HOiAncHJlcHJvY2Vzc2luZycsXG4gIFNUQVRFX1VQTE9BRElORzogJ3VwbG9hZGluZycsXG4gIFNUQVRFX1BPU1RQUk9DRVNTSU5HOiAncG9zdHByb2Nlc3NpbmcnLFxuICBTVEFURV9DT01QTEVURTogJ2NvbXBsZXRlJyxcbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IFRyYW5zbGF0b3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvVHJhbnNsYXRvcicpXG5jb25zdCBTdGF0dXNCYXJVSSA9IHJlcXVpcmUoJy4vU3RhdHVzQmFyJylcbmNvbnN0IHN0YXR1c0JhclN0YXRlcyA9IHJlcXVpcmUoJy4vU3RhdHVzQmFyU3RhdGVzJylcbmNvbnN0IGdldFNwZWVkID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldFNwZWVkJylcbmNvbnN0IGdldEJ5dGVzUmVtYWluaW5nID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldEJ5dGVzUmVtYWluaW5nJylcbmNvbnN0IGdldFRleHREaXJlY3Rpb24gPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0VGV4dERpcmVjdGlvbicpXG5cbi8qKlxuICogU3RhdHVzQmFyOiByZW5kZXJzIGEgc3RhdHVzIGJhciB3aXRoIHVwbG9hZC9wYXVzZS9yZXN1bWUvY2FuY2VsL3JldHJ5IGJ1dHRvbnMsXG4gKiBwcm9ncmVzcyBwZXJjZW50YWdlIGFuZCB0aW1lIHJlbWFpbmluZy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTdGF0dXNCYXIgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnU3RhdHVzQmFyJ1xuICAgIHRoaXMudGl0bGUgPSAnU3RhdHVzQmFyJ1xuICAgIHRoaXMudHlwZSA9ICdwcm9ncmVzc2luZGljYXRvcidcblxuICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IHtcbiAgICAgIHN0cmluZ3M6IHtcbiAgICAgICAgdXBsb2FkaW5nOiAnVXBsb2FkaW5nJyxcbiAgICAgICAgdXBsb2FkOiAnVXBsb2FkJyxcbiAgICAgICAgY29tcGxldGU6ICdDb21wbGV0ZScsXG4gICAgICAgIHVwbG9hZEZhaWxlZDogJ1VwbG9hZCBmYWlsZWQnLFxuICAgICAgICBwYXVzZWQ6ICdQYXVzZWQnLFxuICAgICAgICByZXRyeTogJ1JldHJ5JyxcbiAgICAgICAgcmV0cnlVcGxvYWQ6ICdSZXRyeSB1cGxvYWQnLFxuICAgICAgICBjYW5jZWw6ICdDYW5jZWwnLFxuICAgICAgICBwYXVzZTogJ1BhdXNlJyxcbiAgICAgICAgcmVzdW1lOiAnUmVzdW1lJyxcbiAgICAgICAgZG9uZTogJ0RvbmUnLFxuICAgICAgICBmaWxlc1VwbG9hZGVkT2ZUb3RhbDoge1xuICAgICAgICAgIDA6ICcle2NvbXBsZXRlfSBvZiAle3NtYXJ0X2NvdW50fSBmaWxlIHVwbG9hZGVkJyxcbiAgICAgICAgICAxOiAnJXtjb21wbGV0ZX0gb2YgJXtzbWFydF9jb3VudH0gZmlsZXMgdXBsb2FkZWQnLFxuICAgICAgICB9LFxuICAgICAgICBkYXRhVXBsb2FkZWRPZlRvdGFsOiAnJXtjb21wbGV0ZX0gb2YgJXt0b3RhbH0nLFxuICAgICAgICB4VGltZUxlZnQ6ICcle3RpbWV9IGxlZnQnLFxuICAgICAgICB1cGxvYWRYRmlsZXM6IHtcbiAgICAgICAgICAwOiAnVXBsb2FkICV7c21hcnRfY291bnR9IGZpbGUnLFxuICAgICAgICAgIDE6ICdVcGxvYWQgJXtzbWFydF9jb3VudH0gZmlsZXMnLFxuICAgICAgICB9LFxuICAgICAgICB1cGxvYWRYTmV3RmlsZXM6IHtcbiAgICAgICAgICAwOiAnVXBsb2FkICsle3NtYXJ0X2NvdW50fSBmaWxlJyxcbiAgICAgICAgICAxOiAnVXBsb2FkICsle3NtYXJ0X2NvdW50fSBmaWxlcycsXG4gICAgICAgIH0sXG4gICAgICAgIHhNb3JlRmlsZXNBZGRlZDoge1xuICAgICAgICAgIDA6ICcle3NtYXJ0X2NvdW50fSBtb3JlIGZpbGUgYWRkZWQnLFxuICAgICAgICAgIDE6ICcle3NtYXJ0X2NvdW50fSBtb3JlIGZpbGVzIGFkZGVkJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdGFyZ2V0OiAnYm9keScsXG4gICAgICBoaWRlVXBsb2FkQnV0dG9uOiBmYWxzZSxcbiAgICAgIGhpZGVSZXRyeUJ1dHRvbjogZmFsc2UsXG4gICAgICBoaWRlUGF1c2VSZXN1bWVCdXR0b246IGZhbHNlLFxuICAgICAgaGlkZUNhbmNlbEJ1dHRvbjogZmFsc2UsXG4gICAgICBzaG93UHJvZ3Jlc3NEZXRhaWxzOiBmYWxzZSxcbiAgICAgIGhpZGVBZnRlckZpbmlzaDogdHJ1ZSxcbiAgICAgIGRvbmVCdXR0b25IYW5kbGVyOiBudWxsLFxuICAgIH1cblxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgdGhpcy5pMThuSW5pdCgpXG5cbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLmluc3RhbGwgPSB0aGlzLmluc3RhbGwuYmluZCh0aGlzKVxuICB9XG5cbiAgc2V0T3B0aW9ucyAobmV3T3B0cykge1xuICAgIHN1cGVyLnNldE9wdGlvbnMobmV3T3B0cylcbiAgICB0aGlzLmkxOG5Jbml0KClcbiAgfVxuXG4gIGkxOG5Jbml0ICgpIHtcbiAgICB0aGlzLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcihbdGhpcy5kZWZhdWx0TG9jYWxlLCB0aGlzLnVwcHkubG9jYWxlLCB0aGlzLm9wdHMubG9jYWxlXSlcbiAgICB0aGlzLmkxOG4gPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlLmJpbmQodGhpcy50cmFuc2xhdG9yKVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoKSAvLyBzbyB0aGF0IFVJIHJlLXJlbmRlcnMgYW5kIHdlIHNlZSB0aGUgdXBkYXRlZCBsb2NhbGVcbiAgfVxuXG4gIGdldFRvdGFsU3BlZWQgKGZpbGVzKSB7XG4gICAgbGV0IHRvdGFsU3BlZWQgPSAwXG4gICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgdG90YWxTcGVlZCArPSBnZXRTcGVlZChmaWxlLnByb2dyZXNzKVxuICAgIH0pXG4gICAgcmV0dXJuIHRvdGFsU3BlZWRcbiAgfVxuXG4gIGdldFRvdGFsRVRBIChmaWxlcykge1xuICAgIGNvbnN0IHRvdGFsU3BlZWQgPSB0aGlzLmdldFRvdGFsU3BlZWQoZmlsZXMpXG4gICAgaWYgKHRvdGFsU3BlZWQgPT09IDApIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgY29uc3QgdG90YWxCeXRlc1JlbWFpbmluZyA9IGZpbGVzLnJlZHVjZSgodG90YWwsIGZpbGUpID0+IHtcbiAgICAgIHJldHVybiB0b3RhbCArIGdldEJ5dGVzUmVtYWluaW5nKGZpbGUucHJvZ3Jlc3MpXG4gICAgfSwgMClcblxuICAgIHJldHVybiBNYXRoLnJvdW5kKHRvdGFsQnl0ZXNSZW1haW5pbmcgLyB0b3RhbFNwZWVkICogMTApIC8gMTBcbiAgfVxuXG4gIHN0YXJ0VXBsb2FkID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVjb3ZlcmVkU3RhdGUgfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG4gICAgaWYgKHJlY292ZXJlZFN0YXRlKSB7XG4gICAgICB0aGlzLnVwcHkuZW1pdCgncmVzdG9yZS1jb25maXJtZWQnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVwcHkudXBsb2FkKCkuY2F0Y2goKCkgPT4ge1xuICAgICAgLy8gRXJyb3IgbG9nZ2VkIGluIENvcmVcbiAgICB9KVxuICB9XG5cbiAgZ2V0VXBsb2FkaW5nU3RhdGUgKGlzQWxsRXJyb3JlZCwgaXNBbGxDb21wbGV0ZSwgcmVjb3ZlcmVkU3RhdGUsIGZpbGVzKSB7XG4gICAgaWYgKGlzQWxsRXJyb3JlZCkge1xuICAgICAgcmV0dXJuIHN0YXR1c0JhclN0YXRlcy5TVEFURV9FUlJPUlxuICAgIH1cblxuICAgIGlmIChpc0FsbENvbXBsZXRlKSB7XG4gICAgICByZXR1cm4gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX0NPTVBMRVRFXG4gICAgfVxuXG4gICAgaWYgKHJlY292ZXJlZFN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1dBSVRJTkdcbiAgICB9XG5cbiAgICBsZXQgc3RhdGUgPSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfV0FJVElOR1xuICAgIGNvbnN0IGZpbGVJRHMgPSBPYmplY3Qua2V5cyhmaWxlcylcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHByb2dyZXNzID0gZmlsZXNbZmlsZUlEc1tpXV0ucHJvZ3Jlc3NcbiAgICAgIC8vIElmIEFOWSBmaWxlcyBhcmUgYmVpbmcgdXBsb2FkZWQgcmlnaHQgbm93LCBzaG93IHRoZSB1cGxvYWRpbmcgc3RhdGUuXG4gICAgICBpZiAocHJvZ3Jlc3MudXBsb2FkU3RhcnRlZCAmJiAhcHJvZ3Jlc3MudXBsb2FkQ29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1c0JhclN0YXRlcy5TVEFURV9VUExPQURJTkdcbiAgICAgIH1cbiAgICAgIC8vIElmIGZpbGVzIGFyZSBiZWluZyBwcmVwcm9jZXNzZWQgQU5EIHBvc3Rwcm9jZXNzZWQgYXQgdGhpcyB0aW1lLCB3ZSBzaG93IHRoZVxuICAgICAgLy8gcHJlcHJvY2VzcyBzdGF0ZS4gSWYgYW55IGZpbGVzIGFyZSBiZWluZyB1cGxvYWRlZCB3ZSBzaG93IHVwbG9hZGluZy5cbiAgICAgIGlmIChwcm9ncmVzcy5wcmVwcm9jZXNzICYmIHN0YXRlICE9PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfVVBMT0FESU5HKSB7XG4gICAgICAgIHN0YXRlID0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1BSRVBST0NFU1NJTkdcbiAgICAgIH1cbiAgICAgIC8vIElmIE5PIGZpbGVzIGFyZSBiZWluZyBwcmVwcm9jZXNzZWQgb3IgdXBsb2FkZWQgcmlnaHQgbm93LCBidXQgc29tZSBmaWxlcyBhcmVcbiAgICAgIC8vIGJlaW5nIHBvc3Rwcm9jZXNzZWQsIHNob3cgdGhlIHBvc3Rwcm9jZXNzIHN0YXRlLlxuICAgICAgaWYgKHByb2dyZXNzLnBvc3Rwcm9jZXNzICYmIHN0YXRlICE9PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfVVBMT0FESU5HICYmIHN0YXRlICE9PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfUFJFUFJPQ0VTU0lORykge1xuICAgICAgICBzdGF0ZSA9IHN0YXR1c0JhclN0YXRlcy5TVEFURV9QT1NUUFJPQ0VTU0lOR1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGVcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjYXBhYmlsaXRpZXMsXG4gICAgICBmaWxlcyxcbiAgICAgIGFsbG93TmV3VXBsb2FkLFxuICAgICAgdG90YWxQcm9ncmVzcyxcbiAgICAgIGVycm9yLFxuICAgICAgcmVjb3ZlcmVkU3RhdGUsXG4gICAgfSA9IHN0YXRlXG5cbiAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgdG8gQ29yZSwgdG8gc2hhcmUgYmV0d2VlbiBTdGF0dXMgQmFyIGFuZCBEYXNoYm9hcmRcbiAgICAvLyAoYW5kIGFueSBvdGhlciBwbHVnaW4gdGhhdCBtaWdodCBuZWVkIGl0LCB0b28pXG5cbiAgICBjb25zdCBmaWxlc0FycmF5ID0gT2JqZWN0LmtleXMoZmlsZXMpLm1hcChmaWxlID0+IGZpbGVzW2ZpbGVdKVxuXG4gICAgbGV0IG5ld0ZpbGVzID0gZmlsZXNBcnJheS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiAhZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gICAgICAgICYmICFmaWxlLnByb2dyZXNzLnByZXByb2Nlc3NcbiAgICAgICAgJiYgIWZpbGUucHJvZ3Jlc3MucG9zdHByb2Nlc3NcbiAgICB9KVxuXG4gICAgLy8gSWYgc29tZSBzdGF0ZSB3YXMgcmVjb3ZlcmVkLCB3ZSB3YW50IHRvIHNob3cgVXBsb2FkIGJ1dHRvbi9jb3VudGVyXG4gICAgLy8gZm9yIGFsbCB0aGUgZmlsZXMsIGJlY2F1c2UgaW4gdGhpcyBjYXNlIGl04oCZcyBub3QgYW4gVXBsb2FkIGJ1dHRvbixcbiAgICAvLyBidXQg4oCcQ29uZmlybSBSZXN0b3JlIEJ1dHRvbuKAnVxuICAgIGlmIChyZWNvdmVyZWRTdGF0ZSkge1xuICAgICAgbmV3RmlsZXMgPSBmaWxlc0FycmF5XG4gICAgfVxuXG4gICAgY29uc3QgdXBsb2FkU3RhcnRlZEZpbGVzID0gZmlsZXNBcnJheS5maWx0ZXIoZmlsZSA9PiBmaWxlLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWQpXG4gICAgY29uc3QgcGF1c2VkRmlsZXMgPSB1cGxvYWRTdGFydGVkRmlsZXMuZmlsdGVyKGZpbGUgPT4gZmlsZS5pc1BhdXNlZClcbiAgICBjb25zdCBjb21wbGV0ZUZpbGVzID0gZmlsZXNBcnJheS5maWx0ZXIoZmlsZSA9PiBmaWxlLnByb2dyZXNzLnVwbG9hZENvbXBsZXRlKVxuICAgIGNvbnN0IGVycm9yZWRGaWxlcyA9IGZpbGVzQXJyYXkuZmlsdGVyKGZpbGUgPT4gZmlsZS5lcnJvcilcblxuICAgIGNvbnN0IGluUHJvZ3Jlc3NGaWxlcyA9IGZpbGVzQXJyYXkuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gIWZpbGUucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGVcbiAgICAgICAgICAgICAmJiBmaWxlLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgICB9KVxuXG4gICAgY29uc3QgaW5Qcm9ncmVzc05vdFBhdXNlZEZpbGVzID0gaW5Qcm9ncmVzc0ZpbGVzLmZpbHRlcihmaWxlID0+ICFmaWxlLmlzUGF1c2VkKVxuXG4gICAgY29uc3Qgc3RhcnRlZEZpbGVzID0gZmlsZXNBcnJheS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiBmaWxlLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgICAgICAgfHwgZmlsZS5wcm9ncmVzcy5wcmVwcm9jZXNzXG4gICAgICAgIHx8IGZpbGUucHJvZ3Jlc3MucG9zdHByb2Nlc3NcbiAgICB9KVxuXG4gICAgY29uc3QgcHJvY2Vzc2luZ0ZpbGVzID0gZmlsZXNBcnJheS5maWx0ZXIoZmlsZSA9PiBmaWxlLnByb2dyZXNzLnByZXByb2Nlc3MgfHwgZmlsZS5wcm9ncmVzcy5wb3N0cHJvY2VzcylcblxuICAgIGNvbnN0IHRvdGFsRVRBID0gdGhpcy5nZXRUb3RhbEVUQShpblByb2dyZXNzTm90UGF1c2VkRmlsZXMpXG5cbiAgICBsZXQgdG90YWxTaXplID0gMFxuICAgIGxldCB0b3RhbFVwbG9hZGVkU2l6ZSA9IDBcbiAgICBzdGFydGVkRmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgdG90YWxTaXplICs9IChmaWxlLnByb2dyZXNzLmJ5dGVzVG90YWwgfHwgMClcbiAgICAgIHRvdGFsVXBsb2FkZWRTaXplICs9IChmaWxlLnByb2dyZXNzLmJ5dGVzVXBsb2FkZWQgfHwgMClcbiAgICB9KVxuXG4gICAgY29uc3QgaXNVcGxvYWRTdGFydGVkID0gc3RhcnRlZEZpbGVzLmxlbmd0aCA+IDBcblxuICAgIGNvbnN0IGlzQWxsQ29tcGxldGUgPSB0b3RhbFByb2dyZXNzID09PSAxMDBcbiAgICAgICYmIGNvbXBsZXRlRmlsZXMubGVuZ3RoID09PSBPYmplY3Qua2V5cyhmaWxlcykubGVuZ3RoXG4gICAgICAmJiBwcm9jZXNzaW5nRmlsZXMubGVuZ3RoID09PSAwXG5cbiAgICBjb25zdCBpc0FsbEVycm9yZWQgPSBlcnJvciAmJiBlcnJvcmVkRmlsZXMubGVuZ3RoID09PSBmaWxlc0FycmF5Lmxlbmd0aFxuXG4gICAgY29uc3QgaXNBbGxQYXVzZWQgPSBpblByb2dyZXNzRmlsZXMubGVuZ3RoICE9PSAwXG4gICAgICAmJiBwYXVzZWRGaWxlcy5sZW5ndGggPT09IGluUHJvZ3Jlc3NGaWxlcy5sZW5ndGhcblxuICAgIGNvbnN0IGlzVXBsb2FkSW5Qcm9ncmVzcyA9IGluUHJvZ3Jlc3NGaWxlcy5sZW5ndGggPiAwXG4gICAgY29uc3QgcmVzdW1hYmxlVXBsb2FkcyA9IGNhcGFiaWxpdGllcy5yZXN1bWFibGVVcGxvYWRzIHx8IGZhbHNlXG4gICAgY29uc3Qgc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyA9IGNhcGFiaWxpdGllcy51cGxvYWRQcm9ncmVzcyAhPT0gZmFsc2VcbiAgICBjb25zdCBpc1NvbWVHaG9zdCA9IGZpbGVzQXJyYXkuc29tZSgoZmlsZSkgPT4gZmlsZS5pc0dob3N0KVxuXG4gICAgcmV0dXJuIFN0YXR1c0JhclVJKHtcbiAgICAgIGVycm9yLFxuICAgICAgdXBsb2FkU3RhdGU6IHRoaXMuZ2V0VXBsb2FkaW5nU3RhdGUoaXNBbGxFcnJvcmVkLCBpc0FsbENvbXBsZXRlLCByZWNvdmVyZWRTdGF0ZSwgc3RhdGUuZmlsZXMgfHwge30pLFxuICAgICAgYWxsb3dOZXdVcGxvYWQsXG4gICAgICB0b3RhbFByb2dyZXNzLFxuICAgICAgdG90YWxTaXplLFxuICAgICAgdG90YWxVcGxvYWRlZFNpemUsXG4gICAgICBpc0FsbENvbXBsZXRlLFxuICAgICAgaXNBbGxQYXVzZWQsXG4gICAgICBpc0FsbEVycm9yZWQsXG4gICAgICBpc1VwbG9hZFN0YXJ0ZWQsXG4gICAgICBpc1VwbG9hZEluUHJvZ3Jlc3MsXG4gICAgICBpc1NvbWVHaG9zdCxcbiAgICAgIHJlY292ZXJlZFN0YXRlLFxuICAgICAgY29tcGxldGU6IGNvbXBsZXRlRmlsZXMubGVuZ3RoLFxuICAgICAgbmV3RmlsZXM6IG5ld0ZpbGVzLmxlbmd0aCxcbiAgICAgIG51bVVwbG9hZHM6IHN0YXJ0ZWRGaWxlcy5sZW5ndGgsXG4gICAgICB0b3RhbEVUQSxcbiAgICAgIGZpbGVzLFxuICAgICAgaTE4bjogdGhpcy5pMThuLFxuICAgICAgcGF1c2VBbGw6IHRoaXMudXBweS5wYXVzZUFsbCxcbiAgICAgIHJlc3VtZUFsbDogdGhpcy51cHB5LnJlc3VtZUFsbCxcbiAgICAgIHJldHJ5QWxsOiB0aGlzLnVwcHkucmV0cnlBbGwsXG4gICAgICBjYW5jZWxBbGw6IHRoaXMudXBweS5jYW5jZWxBbGwsXG4gICAgICBzdGFydFVwbG9hZDogdGhpcy5zdGFydFVwbG9hZCxcbiAgICAgIGRvbmVCdXR0b25IYW5kbGVyOiB0aGlzLm9wdHMuZG9uZUJ1dHRvbkhhbmRsZXIsXG4gICAgICByZXN1bWFibGVVcGxvYWRzLFxuICAgICAgc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyxcbiAgICAgIHNob3dQcm9ncmVzc0RldGFpbHM6IHRoaXMub3B0cy5zaG93UHJvZ3Jlc3NEZXRhaWxzLFxuICAgICAgaGlkZVVwbG9hZEJ1dHRvbjogdGhpcy5vcHRzLmhpZGVVcGxvYWRCdXR0b24sXG4gICAgICBoaWRlUmV0cnlCdXR0b246IHRoaXMub3B0cy5oaWRlUmV0cnlCdXR0b24sXG4gICAgICBoaWRlUGF1c2VSZXN1bWVCdXR0b246IHRoaXMub3B0cy5oaWRlUGF1c2VSZXN1bWVCdXR0b24sXG4gICAgICBoaWRlQ2FuY2VsQnV0dG9uOiB0aGlzLm9wdHMuaGlkZUNhbmNlbEJ1dHRvbixcbiAgICAgIGhpZGVBZnRlckZpbmlzaDogdGhpcy5vcHRzLmhpZGVBZnRlckZpbmlzaCxcbiAgICAgIGlzVGFyZ2V0RE9NRWw6IHRoaXMuaXNUYXJnZXRET01FbCxcbiAgICB9KVxuICB9XG5cbiAgb25Nb3VudCAoKSB7XG4gICAgLy8gU2V0IHRoZSB0ZXh0IGRpcmVjdGlvbiBpZiB0aGUgcGFnZSBoYXMgbm90IGRlZmluZWQgb25lLlxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsXG4gICAgY29uc3QgZGlyZWN0aW9uID0gZ2V0VGV4dERpcmVjdGlvbihlbGVtZW50KVxuICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICBlbGVtZW50LmRpciA9ICdsdHInXG4gICAgfVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9zdG9yZS1kZWZhdWx0XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgZGVmYXVsdCBzaW1wbGUgb2JqZWN0LWJhc2VkIHN0b3JlIGZvciBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIxLjIuN1wiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1zdG9yZVwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfVxufVxuIiwiLyoqXG4gKiBEZWZhdWx0IHN0b3JlIHRoYXQga2VlcHMgc3RhdGUgaW4gYSBzaW1wbGUgb2JqZWN0LlxuICovXG5jbGFzcyBEZWZhdWx0U3RvcmUge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHt9XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXVxuICB9XG5cbiAgZ2V0U3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlXG4gIH1cblxuICBzZXRTdGF0ZSAocGF0Y2gpIHtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB7IC4uLnRoaXMuc3RhdGUgfVxuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHsgLi4udGhpcy5zdGF0ZSwgLi4ucGF0Y2ggfVxuXG4gICAgdGhpcy5zdGF0ZSA9IG5leHRTdGF0ZVxuICAgIHRoaXMuX3B1Ymxpc2gocHJldlN0YXRlLCBuZXh0U3RhdGUsIHBhdGNoKVxuICB9XG5cbiAgc3Vic2NyaWJlIChsaXN0ZW5lcikge1xuICAgIHRoaXMuY2FsbGJhY2tzLnB1c2gobGlzdGVuZXIpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAgICB0aGlzLmNhbGxiYWNrcy5zcGxpY2UoXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmluZGV4T2YobGlzdGVuZXIpLFxuICAgICAgICAxXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgX3B1Ymxpc2ggKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgbGlzdGVuZXIoLi4uYXJncylcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmYXVsdFN0b3JlICgpIHtcbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3RvcmUoKVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS90aHVtYm5haWwtZ2VuZXJhdG9yXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJVcHB5IHBsdWdpbiB0aGF0IGdlbmVyYXRlcyBzbWFsbCBwcmV2aWV3cyBvZiBpbWFnZXMgdG8gc2hvdyBvbiB5b3VyIHVwbG9hZCBVSS5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS43LjExXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwidGh1bWJuYWlsXCIsXG4gICAgXCJwcmV2aWV3XCIsXG4gICAgXCJyZXNpemVcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwiZXhpZnJcIjogXCJeNi4wLjBcIixcbiAgICBcIm1hdGgtbG9nMlwiOiBcIl4xLjAuMVwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIm5hbWVzcGFjZS1lbWl0dGVyXCI6IFwiMi4wLjFcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IFRyYW5zbGF0b3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvVHJhbnNsYXRvcicpXG5jb25zdCBkYXRhVVJJdG9CbG9iID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2RhdGFVUkl0b0Jsb2InKVxuY29uc3QgaXNPYmplY3RVUkwgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaXNPYmplY3RVUkwnKVxuY29uc3QgaXNQcmV2aWV3U3VwcG9ydGVkID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2lzUHJldmlld1N1cHBvcnRlZCcpXG5jb25zdCBNYXRoTG9nMiA9IHJlcXVpcmUoJ21hdGgtbG9nMicpIC8vIFBvbHlmaWxsIGZvciBJRS5cbmNvbnN0IGV4aWZyID0gcmVxdWlyZSgnZXhpZnIvZGlzdC9taW5pLmxlZ2FjeS51bWQuanMnKVxuXG4vKipcbiAqIFRoZSBUaHVtYm5haWwgR2VuZXJhdG9yIHBsdWdpblxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVGh1bWJuYWlsR2VuZXJhdG9yIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMudHlwZSA9ICdtb2RpZmllcidcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdUaHVtYm5haWxHZW5lcmF0b3InXG4gICAgdGhpcy50aXRsZSA9ICdUaHVtYm5haWwgR2VuZXJhdG9yJ1xuICAgIHRoaXMucXVldWUgPSBbXVxuICAgIHRoaXMucXVldWVQcm9jZXNzaW5nID0gZmFsc2VcbiAgICB0aGlzLmRlZmF1bHRUaHVtYm5haWxEaW1lbnNpb24gPSAyMDBcbiAgICB0aGlzLnRodW1ibmFpbFR5cGUgPSB0aGlzLm9wdHMudGh1bWJuYWlsVHlwZSB8fCAnaW1hZ2UvanBlZydcblxuICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IHtcbiAgICAgIHN0cmluZ3M6IHtcbiAgICAgICAgZ2VuZXJhdGluZ1RodW1ibmFpbHM6ICdHZW5lcmF0aW5nIHRodW1ibmFpbHMuLi4nLFxuICAgICAgfSxcbiAgICB9XG5cbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHRodW1ibmFpbFdpZHRoOiBudWxsLFxuICAgICAgdGh1bWJuYWlsSGVpZ2h0OiBudWxsLFxuICAgICAgd2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQ6IGZhbHNlLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgfVxuXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmxhenkgJiYgdGhpcy5vcHRzLndhaXRGb3JUaHVtYm5haWxzQmVmb3JlVXBsb2FkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RodW1ibmFpbEdlbmVyYXRvcjogVGhlIGBsYXp5YCBhbmQgYHdhaXRGb3JUaHVtYm5haWxzQmVmb3JlVXBsb2FkYCBvcHRpb25zIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuIFBsZWFzZSBlbnN1cmUgYXQgbW9zdCBvbmUgb2YgdGhlbSBpcyBzZXQgdG8gYHRydWVgLicpXG4gICAgfVxuXG4gICAgdGhpcy5pMThuSW5pdCgpXG4gIH1cblxuICBzZXRPcHRpb25zIChuZXdPcHRzKSB7XG4gICAgc3VwZXIuc2V0T3B0aW9ucyhuZXdPcHRzKVxuICAgIHRoaXMuaTE4bkluaXQoKVxuICB9XG5cbiAgaTE4bkluaXQgKCkge1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKFt0aGlzLmRlZmF1bHRMb2NhbGUsIHRoaXMudXBweS5sb2NhbGUsIHRoaXMub3B0cy5sb2NhbGVdKVxuICAgIHRoaXMuaTE4biA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyBhbmQgd2Ugc2VlIHRoZSB1cGRhdGVkIGxvY2FsZVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRodW1ibmFpbCBmb3IgdGhlIGdpdmVuIFVwcHkgZmlsZSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7e2RhdGE6IEJsb2J9fSBmaWxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRXaWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0SGVpZ2h0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgY3JlYXRlVGh1bWJuYWlsIChmaWxlLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KSB7XG4gICAgLy8gYnVnIGluIHRoZSBjb21wYXRpYmlsaXR5IGRhdGFcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICAgIGNvbnN0IG9yaWdpbmFsVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlLmRhdGEpXG5cbiAgICBjb25zdCBvbmxvYWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpXG4gICAgICBpbWFnZS5zcmMgPSBvcmlnaW5hbFVybFxuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgLy8gYnVnIGluIHRoZSBjb21wYXRpYmlsaXR5IGRhdGFcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvcmlnaW5hbFVybClcbiAgICAgICAgcmVzb2x2ZShpbWFnZSlcbiAgICAgIH0pXG4gICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4ge1xuICAgICAgICAvLyBidWcgaW4gdGhlIGNvbXBhdGliaWxpdHkgZGF0YVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKG9yaWdpbmFsVXJsKVxuICAgICAgICByZWplY3QoZXZlbnQuZXJyb3IgfHwgbmV3IEVycm9yKCdDb3VsZCBub3QgY3JlYXRlIHRodW1ibmFpbCcpKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY29uc3Qgb3JpZW50YXRpb25Qcm9taXNlID0gZXhpZnIucm90YXRpb24oZmlsZS5kYXRhKS5jYXRjaChfZXJyID0+IDEpXG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW29ubG9hZCwgb3JpZW50YXRpb25Qcm9taXNlXSlcbiAgICAgIC50aGVuKChbaW1hZ2UsIG9yaWVudGF0aW9uXSkgPT4ge1xuICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gdGhpcy5nZXRQcm9wb3J0aW9uYWxEaW1lbnNpb25zKGltYWdlLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCBvcmllbnRhdGlvbi5kZWcpXG4gICAgICAgIGNvbnN0IHJvdGF0ZWRJbWFnZSA9IHRoaXMucm90YXRlSW1hZ2UoaW1hZ2UsIG9yaWVudGF0aW9uKVxuICAgICAgICBjb25zdCByZXNpemVkSW1hZ2UgPSB0aGlzLnJlc2l6ZUltYWdlKHJvdGF0ZWRJbWFnZSwgZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc1RvQmxvYihyZXNpemVkSW1hZ2UsIHRoaXMudGh1bWJuYWlsVHlwZSwgODApXG4gICAgICB9KVxuICAgICAgLnRoZW4oYmxvYiA9PiB7XG4gICAgICAgIC8vIGJ1ZyBpbiB0aGUgY29tcGF0aWJpbGl0eSBkYXRhXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV3IGNhbGN1bGF0ZWQgZGltZW5zaW9ucyBmb3IgdGhlIGdpdmVuIGltYWdlIGFuZCBhIHRhcmdldCB3aWR0aFxuICAgKiBvciBoZWlnaHQuIElmIGJvdGggd2lkdGggYW5kIGhlaWdodCBhcmUgZ2l2ZW4sIG9ubHkgd2lkdGggaXMgdGFrZW4gaW50b1xuICAgKiBhY2NvdW50LiBJZiBuZWl0aGVyIHdpZHRoIG5vciBoZWlnaHQgYXJlIGdpdmVuLCB0aGUgZGVmYXVsdCBkaW1lbnNpb25cbiAgICogaXMgdXNlZC5cbiAgICovXG4gIGdldFByb3BvcnRpb25hbERpbWVuc2lvbnMgKGltZywgd2lkdGgsIGhlaWdodCwgcm90YXRpb24pIHtcbiAgICB2YXIgYXNwZWN0ID0gaW1nLndpZHRoIC8gaW1nLmhlaWdodFxuICAgIGlmIChyb3RhdGlvbiA9PT0gOTAgfHwgcm90YXRpb24gPT09IDI3MCkge1xuICAgICAgYXNwZWN0ID0gaW1nLmhlaWdodCAvIGltZy53aWR0aFxuICAgIH1cblxuICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHdpZHRoIC8gYXNwZWN0KSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKGhlaWdodCAqIGFzcGVjdCksXG4gICAgICAgIGhlaWdodCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRoaXMuZGVmYXVsdFRodW1ibmFpbERpbWVuc2lvbixcbiAgICAgIGhlaWdodDogTWF0aC5yb3VuZCh0aGlzLmRlZmF1bHRUaHVtYm5haWxEaW1lbnNpb24gLyBhc3BlY3QpLFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHN1cmUgdGhlIGltYWdlIGRvZXNu4oCZdCBleGNlZWQgYnJvd3Nlci9kZXZpY2UgY2FudmFzIGxpbWl0cy5cbiAgICogRm9yIGlvcyB3aXRoIDI1NiBSQU0gYW5kIGllXG4gICAqL1xuICBwcm90ZWN0IChpbWFnZSkge1xuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYwODE0ODMvbWF4aW11bS1zaXplLW9mLWEtY2FudmFzLWVsZW1lbnRcblxuICAgIHZhciByYXRpbyA9IGltYWdlLndpZHRoIC8gaW1hZ2UuaGVpZ2h0XG5cbiAgICB2YXIgbWF4U3F1YXJlID0gNTAwMDAwMCAvLyBpb3MgbWF4IGNhbnZhcyBzcXVhcmVcbiAgICB2YXIgbWF4U2l6ZSA9IDQwOTYgLy8gaWUgbWF4IGNhbnZhcyBkaW1lbnNpb25zXG5cbiAgICB2YXIgbWF4VyA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KG1heFNxdWFyZSAqIHJhdGlvKSlcbiAgICB2YXIgbWF4SCA9IE1hdGguZmxvb3IobWF4U3F1YXJlIC8gTWF0aC5zcXJ0KG1heFNxdWFyZSAqIHJhdGlvKSlcbiAgICBpZiAobWF4VyA+IG1heFNpemUpIHtcbiAgICAgIG1heFcgPSBtYXhTaXplXG4gICAgICBtYXhIID0gTWF0aC5yb3VuZChtYXhXIC8gcmF0aW8pXG4gICAgfVxuICAgIGlmIChtYXhIID4gbWF4U2l6ZSkge1xuICAgICAgbWF4SCA9IG1heFNpemVcbiAgICAgIG1heFcgPSBNYXRoLnJvdW5kKHJhdGlvICogbWF4SClcbiAgICB9XG4gICAgaWYgKGltYWdlLndpZHRoID4gbWF4Vykge1xuICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICBjYW52YXMud2lkdGggPSBtYXhXXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gbWF4SFxuICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBtYXhXLCBtYXhIKVxuICAgICAgaW1hZ2UgPSBjYW52YXNcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemUgYW4gaW1hZ2UgdG8gdGhlIHRhcmdldCBgd2lkdGhgIGFuZCBgaGVpZ2h0YC5cbiAgICpcbiAgICogUmV0dXJucyBhIENhbnZhcyB3aXRoIHRoZSByZXNpemVkIGltYWdlIG9uIGl0LlxuICAgKi9cbiAgcmVzaXplSW1hZ2UgKGltYWdlLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KSB7XG4gICAgLy8gUmVzaXppbmcgaW4gc3RlcHMgcmVmYWN0b3JlZCB0byB1c2UgYSBzb2x1dGlvbiBmcm9tXG4gICAgLy8gaHR0cHM6Ly9ibG9nLnVwbG9hZGNhcmUuY29tL2ltYWdlLXJlc2l6ZS1pbi1icm93c2Vycy1pcy1icm9rZW4tZTM4ZWVkMDhkZjAxXG5cbiAgICBpbWFnZSA9IHRoaXMucHJvdGVjdChpbWFnZSlcblxuICAgIHZhciBzdGVwcyA9IE1hdGguY2VpbChNYXRoTG9nMihpbWFnZS53aWR0aCAvIHRhcmdldFdpZHRoKSlcbiAgICBpZiAoc3RlcHMgPCAxKSB7XG4gICAgICBzdGVwcyA9IDFcbiAgICB9XG4gICAgdmFyIHNXID0gdGFyZ2V0V2lkdGggKiBNYXRoLnBvdygyLCBzdGVwcyAtIDEpXG4gICAgdmFyIHNIID0gdGFyZ2V0SGVpZ2h0ICogTWF0aC5wb3coMiwgc3RlcHMgLSAxKVxuICAgIHZhciB4ID0gMlxuXG4gICAgd2hpbGUgKHN0ZXBzLS0pIHtcbiAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgY2FudmFzLndpZHRoID0gc1dcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBzSFxuICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBzVywgc0gpXG4gICAgICBpbWFnZSA9IGNhbnZhc1xuXG4gICAgICBzVyA9IE1hdGgucm91bmQoc1cgLyB4KVxuICAgICAgc0ggPSBNYXRoLnJvdW5kKHNIIC8geClcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2VcbiAgfVxuXG4gIHJvdGF0ZUltYWdlIChpbWFnZSwgdHJhbnNsYXRlKSB7XG4gICAgdmFyIHcgPSBpbWFnZS53aWR0aFxuICAgIHZhciBoID0gaW1hZ2UuaGVpZ2h0XG5cbiAgICBpZiAodHJhbnNsYXRlLmRlZyA9PT0gOTAgfHwgdHJhbnNsYXRlLmRlZyA9PT0gMjcwKSB7XG4gICAgICB3ID0gaW1hZ2UuaGVpZ2h0XG4gICAgICBoID0gaW1hZ2Uud2lkdGhcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjYW52YXMud2lkdGggPSB3XG4gICAgY2FudmFzLmhlaWdodCA9IGhcblxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh3IC8gMiwgaCAvIDIpXG4gICAgaWYgKHRyYW5zbGF0ZS5jYW52YXMpIHtcbiAgICAgIGNvbnRleHQucm90YXRlKHRyYW5zbGF0ZS5yYWQpXG4gICAgICBjb250ZXh0LnNjYWxlKHRyYW5zbGF0ZS5zY2FsZVgsIHRyYW5zbGF0ZS5zY2FsZVkpXG4gICAgfVxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAtaW1hZ2Uud2lkdGggLyAyLCAtaW1hZ2UuaGVpZ2h0IC8gMiwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodClcblxuICAgIHJldHVybiBjYW52YXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlIGEgPGNhbnZhcz4gZWxlbWVudCdzIGNvbnRlbnQgdG8gYSBCbG9iIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgY2FudmFzVG9CbG9iIChjYW52YXMsIHR5cGUsIHF1YWxpdHkpIHtcbiAgICB0cnkge1xuICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09IDE4KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Nhbm5vdCByZWFkIGltYWdlLCBwcm9iYWJseSBhbiBzdmcgd2l0aCBleHRlcm5hbCByZXNvdXJjZXMnKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2FudmFzLnRvQmxvYikge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjYW52YXMudG9CbG9iKHJlc29sdmUsIHR5cGUsIHF1YWxpdHkpXG4gICAgICB9KS50aGVuKChibG9iKSA9PiB7XG4gICAgICAgIGlmIChibG9iID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVhZCBpbWFnZSwgcHJvYmFibHkgYW4gc3ZnIHdpdGggZXh0ZXJuYWwgcmVzb3VyY2VzJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvYlxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIGRhdGFVUkl0b0Jsb2IoY2FudmFzLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KSwge30pXG4gICAgfSkudGhlbigoYmxvYikgPT4ge1xuICAgICAgaWYgKGJsb2IgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZXh0cmFjdCBibG9iLCBwcm9iYWJseSBhbiBvbGQgYnJvd3NlcicpXG4gICAgICB9XG4gICAgICByZXR1cm4gYmxvYlxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBwcmV2aWV3IFVSTCBmb3IgYSBmaWxlLlxuICAgKi9cbiAgc2V0UHJldmlld1VSTCAoZmlsZUlELCBwcmV2aWV3KSB7XG4gICAgdGhpcy51cHB5LnNldEZpbGVTdGF0ZShmaWxlSUQsIHsgcHJldmlldyB9KVxuICB9XG5cbiAgYWRkVG9RdWV1ZSAoaXRlbSkge1xuICAgIHRoaXMucXVldWUucHVzaChpdGVtKVxuICAgIGlmICh0aGlzLnF1ZXVlUHJvY2Vzc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucHJvY2Vzc1F1ZXVlKClcbiAgICB9XG4gIH1cblxuICBwcm9jZXNzUXVldWUgKCkge1xuICAgIHRoaXMucXVldWVQcm9jZXNzaW5nID0gdHJ1ZVxuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnVwcHkuZ2V0RmlsZSh0aGlzLnF1ZXVlLnNoaWZ0KCkpXG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgdGhpcy51cHB5LmxvZygnW1RodW1ibmFpbEdlbmVyYXRvcl0gZmlsZSB3YXMgcmVtb3ZlZCBiZWZvcmUgYSB0aHVtYm5haWwgY291bGQgYmUgZ2VuZXJhdGVkLCBidXQgbm90IHJlbW92ZWQgZnJvbSB0aGUgcXVldWUuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcnLCAnZXJyb3InKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RUaHVtYm5haWwoY3VycmVudClcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7fSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBoYW5kbGUtY2FsbGJhY2stZXJyXG4gICAgICAgIC50aGVuKCgpID0+IHRoaXMucHJvY2Vzc1F1ZXVlKCkpXG4gICAgfVxuICAgIHRoaXMucXVldWVQcm9jZXNzaW5nID0gZmFsc2VcbiAgICB0aGlzLnVwcHkubG9nKCdbVGh1bWJuYWlsR2VuZXJhdG9yXSBFbXB0aWVkIHRodW1ibmFpbCBxdWV1ZScpXG4gICAgdGhpcy51cHB5LmVtaXQoJ3RodW1ibmFpbDphbGwtZ2VuZXJhdGVkJylcbiAgfVxuXG4gIHJlcXVlc3RUaHVtYm5haWwgKGZpbGUpIHtcbiAgICBpZiAoaXNQcmV2aWV3U3VwcG9ydGVkKGZpbGUudHlwZSkgJiYgIWZpbGUuaXNSZW1vdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRodW1ibmFpbChmaWxlLCB0aGlzLm9wdHMudGh1bWJuYWlsV2lkdGgsIHRoaXMub3B0cy50aHVtYm5haWxIZWlnaHQpXG4gICAgICAgIC50aGVuKHByZXZpZXcgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0UHJldmlld1VSTChmaWxlLmlkLCBwcmV2aWV3KVxuICAgICAgICAgIHRoaXMudXBweS5sb2coYFtUaHVtYm5haWxHZW5lcmF0b3JdIEdlbmVyYXRlZCB0aHVtYm5haWwgZm9yICR7ZmlsZS5pZH1gKVxuICAgICAgICAgIHRoaXMudXBweS5lbWl0KCd0aHVtYm5haWw6Z2VuZXJhdGVkJywgdGhpcy51cHB5LmdldEZpbGUoZmlsZS5pZCksIHByZXZpZXcpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coYFtUaHVtYm5haWxHZW5lcmF0b3JdIEZhaWxlZCB0aHVtYm5haWwgZm9yICR7ZmlsZS5pZH06YCwgJ3dhcm5pbmcnKVxuICAgICAgICAgIHRoaXMudXBweS5sb2coZXJyLCAnd2FybmluZycpXG4gICAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3RodW1ibmFpbDplcnJvcicsIHRoaXMudXBweS5nZXRGaWxlKGZpbGUuaWQpLCBlcnIpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG5cbiAgb25GaWxlQWRkZWQgPSAoZmlsZSkgPT4ge1xuICAgIGlmIChcbiAgICAgICFmaWxlLnByZXZpZXdcbiAgICAgICYmIGZpbGUuZGF0YVxuICAgICAgJiYgaXNQcmV2aWV3U3VwcG9ydGVkKGZpbGUudHlwZSlcbiAgICAgICYmICFmaWxlLmlzUmVtb3RlXG4gICAgKSB7XG4gICAgICB0aGlzLmFkZFRvUXVldWUoZmlsZS5pZClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIGEgbGF6eSByZXF1ZXN0IGZvciBhIHRodW1ibmFpbCBpZiB0aGUgdGh1bWJuYWlsIGhhcyBub3QgeWV0IGJlZW4gZ2VuZXJhdGVkLlxuICAgKi9cbiAgb25DYW5jZWxSZXF1ZXN0ID0gKGZpbGUpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUuaW5kZXhPZihmaWxlLmlkKVxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMucXVldWUuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCB0aGUgdGh1bWJuYWlsIGZvciBhIGZpbGUuIENhbmNlbCBsYXp5IHJlcXVlc3RzIGFuZCBmcmVlIHRoZSB0aHVtYm5haWwgVVJMLlxuICAgKi9cbiAgb25GaWxlUmVtb3ZlZCA9IChmaWxlKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnF1ZXVlLmluZGV4T2YoZmlsZS5pZClcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnF1ZXVlLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCBvYmplY3QgVVJMcy5cbiAgICBpZiAoZmlsZS5wcmV2aWV3ICYmIGlzT2JqZWN0VVJMKGZpbGUucHJldmlldykpIHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoZmlsZS5wcmV2aWV3KVxuICAgIH1cbiAgfVxuXG4gIG9uUmVzdG9yZWQgPSAoKSA9PiB7XG4gICAgY29uc3QgcmVzdG9yZWRGaWxlcyA9IHRoaXMudXBweS5nZXRGaWxlcygpLmZpbHRlcihmaWxlID0+IGZpbGUuaXNSZXN0b3JlZClcbiAgICByZXN0b3JlZEZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIC8vIE9ubHkgYWRkIGJsb2IgVVJMczsgdGhleSBhcmUgbGlrZWx5IGludmFsaWQgYWZ0ZXIgYmVpbmcgcmVzdG9yZWQuXG4gICAgICBpZiAoIWZpbGUucHJldmlldyB8fCBpc09iamVjdFVSTChmaWxlLnByZXZpZXcpKSB7XG4gICAgICAgIHRoaXMuYWRkVG9RdWV1ZShmaWxlLmlkKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB3YWl0VW50aWxBbGxQcm9jZXNzZWQgPSAoZmlsZUlEcykgPT4ge1xuICAgIGZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICBjb25zdCBmaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKVxuICAgICAgdGhpcy51cHB5LmVtaXQoJ3ByZXByb2Nlc3MtcHJvZ3Jlc3MnLCBmaWxlLCB7XG4gICAgICAgIG1vZGU6ICdpbmRldGVybWluYXRlJyxcbiAgICAgICAgbWVzc2FnZTogdGhpcy5pMThuKCdnZW5lcmF0aW5nVGh1bWJuYWlscycpLFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY29uc3QgZW1pdFByZXByb2Nlc3NDb21wbGV0ZUZvckFsbCA9ICgpID0+IHtcbiAgICAgIGZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpXG4gICAgICAgIHRoaXMudXBweS5lbWl0KCdwcmVwcm9jZXNzLWNvbXBsZXRlJywgZmlsZSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLnF1ZXVlUHJvY2Vzc2luZykge1xuICAgICAgICB0aGlzLnVwcHkub25jZSgndGh1bWJuYWlsOmFsbC1nZW5lcmF0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgZW1pdFByZXByb2Nlc3NDb21wbGV0ZUZvckFsbCgpXG4gICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0UHJlcHJvY2Vzc0NvbXBsZXRlRm9yQWxsKClcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudXBweS5vbignZmlsZS1yZW1vdmVkJywgdGhpcy5vbkZpbGVSZW1vdmVkKVxuICAgIGlmICh0aGlzLm9wdHMubGF6eSkge1xuICAgICAgdGhpcy51cHB5Lm9uKCd0aHVtYm5haWw6cmVxdWVzdCcsIHRoaXMub25GaWxlQWRkZWQpXG4gICAgICB0aGlzLnVwcHkub24oJ3RodW1ibmFpbDpjYW5jZWwnLCB0aGlzLm9uQ2FuY2VsUmVxdWVzdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cHB5Lm9uKCdmaWxlLWFkZGVkJywgdGhpcy5vbkZpbGVBZGRlZClcbiAgICAgIHRoaXMudXBweS5vbigncmVzdG9yZWQnLCB0aGlzLm9uUmVzdG9yZWQpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy53YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZCkge1xuICAgICAgdGhpcy51cHB5LmFkZFByZVByb2Nlc3Nvcih0aGlzLndhaXRVbnRpbEFsbFByb2Nlc3NlZClcbiAgICB9XG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudXBweS5vZmYoJ2ZpbGUtcmVtb3ZlZCcsIHRoaXMub25GaWxlUmVtb3ZlZClcbiAgICBpZiAodGhpcy5vcHRzLmxhenkpIHtcbiAgICAgIHRoaXMudXBweS5vZmYoJ3RodW1ibmFpbDpyZXF1ZXN0JywgdGhpcy5vbkZpbGVBZGRlZClcbiAgICAgIHRoaXMudXBweS5vZmYoJ3RodW1ibmFpbDpjYW5jZWwnLCB0aGlzLm9uQ2FuY2VsUmVxdWVzdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cHB5Lm9mZignZmlsZS1hZGRlZCcsIHRoaXMub25GaWxlQWRkZWQpXG4gICAgICB0aGlzLnVwcHkub2ZmKCdyZXN0b3JlZCcsIHRoaXMub25SZXN0b3JlZClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLndhaXRGb3JUaHVtYm5haWxzQmVmb3JlVXBsb2FkKSB7XG4gICAgICB0aGlzLnVwcHkucmVtb3ZlUHJlUHJvY2Vzc29yKHRoaXMud2FpdFVudGlsQWxsUHJvY2Vzc2VkKVxuICAgIH1cbiAgfVxufVxuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0cy5pbnN0YW5jZXMgPSBbXTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgdmFyIHByZXZUaW1lO1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICBleHBvcnRzLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuICByZXR1cm4gZGVidWc7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICB2YXIgaW5kZXggPSBleHBvcnRzLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgZXhwb3J0cy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgaTtcbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cG9ydHMuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZXhwb3J0cy5pbnN0YW5jZXNbaV07XG4gICAgaW5zdGFuY2UuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9pbmRleCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh1cmkgJiYgJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IG51bGw7XG4gIH1cblxuICBpZiAodXJpKSB7XG4gICAgdXJpID0gcGFyc2V1cmkodXJpKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09PSAnd3NzJztcbiAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcbiAgICBpZiAodXJpLnF1ZXJ5KSBvcHRzLnF1ZXJ5ID0gdXJpLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaShvcHRzLmhvc3QpLmhvc3Q7XG4gIH1cblxuICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZVxuICAgIDogKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sKTtcblxuICBpZiAob3B0cy5ob3N0bmFtZSAmJiAhb3B0cy5wb3J0KSB7XG4gICAgLy8gaWYgbm8gcG9ydCBpcyBzcGVjaWZpZWQgbWFudWFsbHksIHVzZSB0aGUgcHJvdG9jb2wgZGVmYXVsdFxuICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuICB9XG5cbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8XG4gICAgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmIGxvY2F0aW9uLnBvcnRcbiAgICAgID8gbG9jYXRpb24ucG9ydFxuICAgICAgOiAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG4gIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcbiAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0JztcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG4gIHRoaXMudHJhbnNwb3J0T3B0aW9ucyA9IG9wdHMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cbiAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkID0gMTAyNDtcbiAgfVxuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9ICEhb3B0cy5mb3JjZU5vZGU7XG5cbiAgLy8gZGV0ZWN0IFJlYWN0TmF0aXZlIGVudmlyb25tZW50XG4gIHRoaXMuaXNSZWFjdE5hdGl2ZSA9ICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdzdHJpbmcnICYmIG5hdmlnYXRvci5wcm9kdWN0LnRvTG93ZXJDYXNlKCkgPT09ICdyZWFjdG5hdGl2ZScpO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgb3IgUmVhY3ROYXRpdmUgY2xpZW50XG4gIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5pc1JlYWN0TmF0aXZlKSB7XG4gICAgaWYgKG9wdHMuZXh0cmFIZWFkZXJzICYmIE9iamVjdC5rZXlzKG9wdHMuZXh0cmFIZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmxvY2FsQWRkcmVzcykge1xuICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBvcHRzLmxvY2FsQWRkcmVzcztcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgb24gaGFuZHNoYWtlXG4gIHRoaXMuaWQgPSBudWxsO1xuICB0aGlzLnVwZ3JhZGVzID0gbnVsbDtcbiAgdGhpcy5waW5nSW50ZXJ2YWwgPSBudWxsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gbnVsbDtcblxuICAvLyBzZXQgb24gaGVhcnRiZWF0XG4gIHRoaXMucGluZ0ludGVydmFsVGltZXIgPSBudWxsO1xuICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSBudWxsO1xuXG4gIHRoaXMub3BlbigpO1xufVxuXG5Tb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cbi8qKlxuICogRXhwb3NlIGRlcHMgZm9yIGxlZ2FjeSBjb21wYXRpYmlsaXR5XG4gKiBhbmQgc3RhbmRhbG9uZSBicm93c2VyIGFjY2Vzcy5cbiAqL1xuXG5Tb2NrZXQuU29ja2V0ID0gU29ja2V0O1xuU29ja2V0LlRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0Jyk7XG5Tb2NrZXQudHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9pbmRleCcpO1xuU29ja2V0LnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cbiAgLy8gYXBwZW5kIGVuZ2luZS5pbyBwcm90b2NvbCBpZGVudGlmaWVyXG4gIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblxuICAvLyB0cmFuc3BvcnQgbmFtZVxuICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXG4gIC8vIHBlci10cmFuc3BvcnQgb3B0aW9uc1xuICB2YXIgb3B0aW9ucyA9IHRoaXMudHJhbnNwb3J0T3B0aW9uc1tuYW1lXSB8fCB7fTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBxdWVyeTogcXVlcnksXG4gICAgc29ja2V0OiB0aGlzLFxuICAgIGFnZW50OiBvcHRpb25zLmFnZW50IHx8IHRoaXMuYWdlbnQsXG4gICAgaG9zdG5hbWU6IG9wdGlvbnMuaG9zdG5hbWUgfHwgdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiBvcHRpb25zLnBvcnQgfHwgdGhpcy5wb3J0LFxuICAgIHNlY3VyZTogb3B0aW9ucy5zZWN1cmUgfHwgdGhpcy5zZWN1cmUsXG4gICAgcGF0aDogb3B0aW9ucy5wYXRoIHx8IHRoaXMucGF0aCxcbiAgICBmb3JjZUpTT05QOiBvcHRpb25zLmZvcmNlSlNPTlAgfHwgdGhpcy5mb3JjZUpTT05QLFxuICAgIGpzb25wOiBvcHRpb25zLmpzb25wIHx8IHRoaXMuanNvbnAsXG4gICAgZm9yY2VCYXNlNjQ6IG9wdGlvbnMuZm9yY2VCYXNlNjQgfHwgdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiBvcHRpb25zLmVuYWJsZXNYRFIgfHwgdGhpcy5lbmFibGVzWERSLFxuICAgIHRpbWVzdGFtcFJlcXVlc3RzOiBvcHRpb25zLnRpbWVzdGFtcFJlcXVlc3RzIHx8IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IG9wdGlvbnMudGltZXN0YW1wUGFyYW0gfHwgdGhpcy50aW1lc3RhbXBQYXJhbSxcbiAgICBwb2xpY3lQb3J0OiBvcHRpb25zLnBvbGljeVBvcnQgfHwgdGhpcy5wb2xpY3lQb3J0LFxuICAgIHBmeDogb3B0aW9ucy5wZnggfHwgdGhpcy5wZngsXG4gICAga2V5OiBvcHRpb25zLmtleSB8fCB0aGlzLmtleSxcbiAgICBwYXNzcGhyYXNlOiBvcHRpb25zLnBhc3NwaHJhc2UgfHwgdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IG9wdGlvbnMuY2VydCB8fCB0aGlzLmNlcnQsXG4gICAgY2E6IG9wdGlvbnMuY2EgfHwgdGhpcy5jYSxcbiAgICBjaXBoZXJzOiBvcHRpb25zLmNpcGhlcnMgfHwgdGhpcy5jaXBoZXJzLFxuICAgIHJlamVjdFVuYXV0aG9yaXplZDogb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgfHwgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgfHwgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICBleHRyYUhlYWRlcnM6IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IHRoaXMuZXh0cmFIZWFkZXJzLFxuICAgIGZvcmNlTm9kZTogb3B0aW9ucy5mb3JjZU5vZGUgfHwgdGhpcy5mb3JjZU5vZGUsXG4gICAgbG9jYWxBZGRyZXNzOiBvcHRpb25zLmxvY2FsQWRkcmVzcyB8fCB0aGlzLmxvY2FsQWRkcmVzcyxcbiAgICByZXF1ZXN0VGltZW91dDogb3B0aW9ucy5yZXF1ZXN0VGltZW91dCB8fCB0aGlzLnJlcXVlc3RUaW1lb3V0LFxuICAgIHByb3RvY29sczogb3B0aW9ucy5wcm90b2NvbHMgfHwgdm9pZCAoMCksXG4gICAgaXNSZWFjdE5hdGl2ZTogdGhpcy5pc1JlYWN0TmF0aXZlXG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb1tpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFuc3BvcnQ7XG4gIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPT0gLTEpIHtcbiAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0JztcbiAgfSBlbHNlIGlmICgwID09PSB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG4gICAgLy8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG4gIH1cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcbiAgdHJ5IHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gIGRlYnVnKCdzZXR0aW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydC5uYW1lKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgIGRlYnVnKCdjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXMnLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgdHJhbnNwb3J0XG4gIC5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkRyYWluKCk7XG4gIH0pXG4gIC5vbigncGFja2V0JywgZnVuY3Rpb24gKHBhY2tldCkge1xuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfSlcbiAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKGUpO1xuICB9KVxuICAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KTtcbiAgdmFyIGZhaWxlZCA9IGZhbHNlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3BlbiAoKSB7XG4gICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG4gICAgICB2YXIgdXBncmFkZUxvc2VzQmluYXJ5ID0gIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgc2VsZi50cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnk7XG4gICAgICBmYWlsZWQgPSBmYWlsZWQgfHwgdXBncmFkZUxvc2VzQmluYXJ5O1xuICAgIH1cbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcbiAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAncGluZycsIGRhdGE6ICdwcm9iZScgfV0pO1xuICAgIHRyYW5zcG9ydC5vbmNlKCdwYWNrZXQnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICBpZiAoJ3BvbmcnID09PSBtc2cudHlwZSAmJiAncHJvYmUnID09PSBtc2cuZGF0YSkge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgIHNlbGYudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgICAgIGRlYnVnKCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsIHNlbGYudHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICBzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcbiAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQgKCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICBjbGVhbnVwKCk7XG5cbiAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgLy8gSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmVycm9yIChlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSAoKSB7XG4gICAgb25lcnJvcigndHJhbnNwb3J0IGNsb3NlZCcpO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uY2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3NvY2tldCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9udXBncmFkZSAodG8pIHtcbiAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT09IHRyYW5zcG9ydC5uYW1lKSB7XG4gICAgICBkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJywgdG8ubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICBmdW5jdGlvbiBjbGVhbnVwICgpIHtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9uY2UoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbmVycm9yKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG5cbiAgdGhpcy5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcbiAgICBkZWJ1Zygnc3RhcnRpbmcgdXBncmFkZSBwcm9iZXMnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLnByb2JlKHRoaXMudXBncmFkZXNbaV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSB8fFxuICAgICAgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IHJlY2VpdmU6IHR5cGUgXCIlc1wiLCBkYXRhIFwiJXNcIicsIHBhY2tldC50eXBlLCBwYWNrZXQuZGF0YSk7XG5cbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKEpTT04ucGFyc2UocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSAoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUgKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgdGhpcy5mb3JjZU5vZGUgPSBvcHRzLmZvcmNlTm9kZTtcblxuICAvLyByZXN1bHRzIG9mIFJlYWN0TmF0aXZlIGVudmlyb25tZW50IGRldGVjdGlvblxuICB0aGlzLmlzUmVhY3ROYXRpdmUgPSBvcHRzLmlzUmVhY3ROYXRpdmU7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgdGhpcy5sb2NhbEFkZHJlc3MgPSBvcHRzLmxvY2FsQWRkcmVzcztcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoVHJhbnNwb3J0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogRW1pdHMgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci50eXBlID0gJ1RyYW5zcG9ydEVycm9yJztcbiAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICAgIHRoaXMuZG9PcGVuKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgdGhpcy5vbkNsb3NlKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IG5vdCBvcGVuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gb3BlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgcGFja2V0ID0gcGFyc2VyLmRlY29kZVBhY2tldChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xudmFyIFhIUiA9IHJlcXVpcmUoJy4vcG9sbGluZy14aHInKTtcbnZhciBKU09OUCA9IHJlcXVpcmUoJy4vcG9sbGluZy1qc29ucCcpO1xudmFyIHdlYnNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0IHRyYW5zcG9ydHMuXG4gKi9cblxuZXhwb3J0cy5wb2xsaW5nID0gcG9sbGluZztcbmV4cG9ydHMud2Vic29ja2V0ID0gd2Vic29ja2V0O1xuXG4vKipcbiAqIFBvbGxpbmcgdHJhbnNwb3J0IHBvbHltb3JwaGljIGNvbnN0cnVjdG9yLlxuICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcG9sbGluZyAob3B0cykge1xuICB2YXIgeGhyO1xuICB2YXIgeGQgPSBmYWxzZTtcbiAgdmFyIHhzID0gZmFsc2U7XG4gIHZhciBqc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXG4gIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG4iLCIvKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogVW50aWwgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsIGlzIHNoaXBwZWQuXG4gKi9cbmZ1bmN0aW9uIGdsb2IgKCkge1xuICByZXR1cm4gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZlxuICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvd1xuICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHt9O1xufVxuXG4vKipcbiAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEpTT05QUG9sbGluZyAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cbiAgLy8gZGVmaW5lIGdsb2JhbCBjYWxsYmFja3MgYXJyYXkgaWYgbm90IHByZXNlbnRcbiAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgIHZhciBnbG9iYWwgPSBnbG9iKCk7XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbyA9IChnbG9iYWwuX19fZWlvIHx8IFtdKTtcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG4vKlxuICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmZvcm0pIHtcbiAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICB9XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsIGUpO1xuICB9O1xuXG4gIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgaWYgKGluc2VydEF0KSB7XG4gICAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIH0gZWxzZSB7XG4gICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcblxuICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSwgMTAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5mb3JtKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcbiAgICB2YXIgaWZyYW1lO1xuXG4gICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gIH1cblxuICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG4gICAgaW5pdElmcmFtZSgpO1xuICAgIGZuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcbiAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicgKyBzZWxmLmlmcmFtZUlkICsgJ1wiPic7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgIH1cblxuICAgIGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cbiAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBzZWxmLmlmcmFtZSA9IGlmcmFtZTtcbiAgfVxuXG4gIGluaXRJZnJhbWUoKTtcblxuICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcbiAgLy8gZG91YmxlIGVzY2FwaW5nIGlzIHJlcXVpcmVkIGZvciBlc2NhcGVkIG5ldyBsaW5lcyBiZWNhdXNlIHVuZXNjYXBpbmcgb2YgbmV3IGxpbmVzIGNhbiBiZSBkb25lIHNhZmVseSBvbiBzZXJ2ZXItc2lkZVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcbiAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuICB0cnkge1xuICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgfSBjYXRjaCAoZSkge31cblxuICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcbiAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gIH1cbn07XG4iLCIvKiBnbG9iYWwgYXR0YWNoRXZlbnQgKi9cblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZy14aHInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEVtcHR5IGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkge31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB0aGlzLnhkID0gKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUpIHx8XG4gICAgICBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cbi8qKlxuICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICovXG5cblhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG4gIG9wdHMueGQgPSB0aGlzLnhkO1xuICBvcHRzLnhzID0gdGhpcy54cztcbiAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG4gIG9wdHMuc3VwcG9ydHNCaW5hcnkgPSB0aGlzLnN1cHBvcnRzQmluYXJ5O1xuICBvcHRzLmVuYWJsZXNYRFIgPSB0aGlzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuICBvcHRzLnJlcXVlc3RUaW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXG4gIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcbn07XG5cbi8qKlxuICogU2VuZHMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmIGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdzdWNjZXNzJywgZm4pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5vbkRhdGEoZGF0YSk7XG4gIH0pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdCAob3B0cykge1xuICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICB0aGlzLnhzID0gISFvcHRzLnhzO1xuICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuICB0aGlzLmNyZWF0ZSgpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrICYmIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgaWYgKCdQT1NUJyA9PT0gdGhpcy5tZXRob2QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzQmluYXJ5KSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJyovKicpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBpZTYgY2hlY2tcbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXF1ZXN0VGltZW91dCkge1xuICAgICAgeGhyLnRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICAgIGlmIChzZWxmLnN1cHBvcnRzQmluYXJ5ICYmIGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIGlmICg0ICE9PSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoMjAwID09PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmluZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG4gICAgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XSA9IHRoaXM7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgdGhpcy5vblN1Y2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMuY2xlYW51cCh0cnVlKTtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGhvdXNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoZnJvbUVycm9yKSB7XG4gIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHhtbGh0dHByZXF1ZXN0XG4gIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgdGhpcy54aHIub25sb2FkID0gdGhpcy54aHIub25lcnJvciA9IGVtcHR5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuICB9XG5cbiAgaWYgKGZyb21FcnJvcikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50VHlwZSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZSB8fCB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5vbkVycm9yKGUpO1xuICB9XG4gIGlmIChudWxsICE9IGRhdGEpIHtcbiAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5SZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAodHlwZW9mIGF0dGFjaEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgdGVybWluYXRpb25FdmVudCA9ICdvbnBhZ2VoaWRlJyBpbiBzZWxmID8gJ3BhZ2VoaWRlJyA6ICd1bmxvYWQnO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIodGVybWluYXRpb25FdmVudCwgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIgKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wb2xsKCk7XG59O1xuXG4vKipcbiAqIFBhdXNlcyBwb2xsaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAob25QYXVzZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ3BhdXNpbmcnO1xuXG4gIGZ1bmN0aW9uIHBhdXNlICgpIHtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGF1c2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09PSBzZWxmLnJlYWR5U3RhdGUpIHtcbiAgICAgIHNlbGYub25PcGVuKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuICAgIGlmICgnY2xvc2UnID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgIHRoaXMucG9sbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCdodHRwcycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcblxudmFyIEJyb3dzZXJXZWJTb2NrZXQsIE5vZGVXZWJTb2NrZXQ7XG5cbmlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICBCcm93c2VyV2ViU29ja2V0ID0gV2ViU29ja2V0O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgQnJvd3NlcldlYlNvY2tldCA9IHNlbGYuV2ViU29ja2V0IHx8IHNlbGYuTW96V2ViU29ja2V0O1xufSBlbHNlIHtcbiAgdHJ5IHtcbiAgICBOb2RlV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcbiAgfSBjYXRjaCAoZSkgeyB9XG59XG5cbi8qKlxuICogR2V0IGVpdGhlciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuICogaW4gdGhlIGJyb3dzZXIgb3IgdHJ5IHRvIHJlc29sdmUgV2ViU29ja2V0LWNvbXBhdGlibGVcbiAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cbiAqL1xuXG52YXIgV2ViU29ja2V0SW1wbCA9IEJyb3dzZXJXZWJTb2NrZXQgfHwgTm9kZVdlYlNvY2tldDtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdTO1xuXG4vKipcbiAqIFdlYlNvY2tldCB0cmFuc3BvcnQgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSB7T2JqZWN0fSBjb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gV1MgKG9wdHMpIHtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmIChmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZTtcbiAgdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQgPSBCcm93c2VyV2ViU29ja2V0ICYmICFvcHRzLmZvcmNlTm9kZTtcbiAgdGhpcy5wcm90b2NvbHMgPSBvcHRzLnByb3RvY29scztcbiAgaWYgKCF0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgIFdlYlNvY2tldEltcGwgPSBOb2RlV2ViU29ja2V0O1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoV1MsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUubmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vKlxuICogV2ViU29ja2V0cyBzdXBwb3J0IGJpbmFyeVxuICovXG5cbldTLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogT3BlbnMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdXJpID0gdGhpcy51cmkoKTtcbiAgdmFyIHByb3RvY29scyA9IHRoaXMucHJvdG9jb2xzO1xuICB2YXIgb3B0cyA9IHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuICB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgb3B0cy5oZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG4gIH1cbiAgaWYgKHRoaXMubG9jYWxBZGRyZXNzKSB7XG4gICAgb3B0cy5sb2NhbEFkZHJlc3MgPSB0aGlzLmxvY2FsQWRkcmVzcztcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy53cyA9XG4gICAgICB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCAmJiAhdGhpcy5pc1JlYWN0TmF0aXZlXG4gICAgICAgID8gcHJvdG9jb2xzXG4gICAgICAgICAgPyBuZXcgV2ViU29ja2V0SW1wbCh1cmksIHByb3RvY29scylcbiAgICAgICAgICA6IG5ldyBXZWJTb2NrZXRJbXBsKHVyaSlcbiAgICAgICAgOiBuZXcgV2ViU29ja2V0SW1wbCh1cmksIHByb3RvY29scywgb3B0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIGlmICh0aGlzLndzLmJpbmFyeVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLndzLnN1cHBvcnRzICYmIHRoaXMud3Muc3VwcG9ydHMuYmluYXJ5KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ25vZGVidWZmZXInO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIH1cblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzb2NrZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uT3BlbigpO1xuICB9O1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCk7XG4gIH07XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgc2VsZi5vbkRhdGEoZXYuZGF0YSk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKCd3ZWJzb2NrZXQgZXJyb3InLCBlKTtcbiAgfTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGRhdGEgdG8gc29ja2V0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHBhY2tldHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gIHZhciB0b3RhbCA9IHBhY2tldHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHRvdGFsOyBpIDwgbDsgaSsrKSB7XG4gICAgKGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICAgIHBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0LCBzZWxmLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIXNlbGYudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgLy8gYWx3YXlzIGNyZWF0ZSBhIG5ldyBvYmplY3QgKEdILTQzNylcbiAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICAgIGlmIChwYWNrZXQub3B0aW9ucykge1xuICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IHBhY2tldC5vcHRpb25zLmNvbXByZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gJ3N0cmluZycgPT09IHR5cGVvZiBkYXRhID8gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPCBzZWxmLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuICAgICAgICAvLyBoYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcbiAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc2VsZi51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgIC8vIFR5cGVFcnJvciBpcyB0aHJvd24gd2hlbiBwYXNzaW5nIHRoZSBzZWNvbmQgYXJndW1lbnQgb24gU2FmYXJpXG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhLCBvcHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1Zygnd2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLS10b3RhbCB8fCBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KShwYWNrZXRzW2ldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUgKCkge1xuICAgIHNlbGYuZW1pdCgnZmx1c2gnKTtcblxuICAgIC8vIGZha2UgZHJhaW5cbiAgICAvLyBkZWZlciB0byBuZXh0IHRpY2sgdG8gYWxsb3cgU29ja2V0IHRvIGNsZWFyIHdyaXRlQnVmZmVyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ3dzcycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gNDQzKSB8fFxuICAgICgnd3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cbi8qKlxuICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISFXZWJTb2NrZXRJbXBsICYmICEoJ19faW5pdGlhbGl6ZScgaW4gV2ViU29ja2V0SW1wbCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG4iLCIvLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxuXG52YXIgaGFzQ09SUyA9IHJlcXVpcmUoJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHhkb21haW4gPSBvcHRzLnhkb21haW47XG5cbiAgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG4gIC8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcbiAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cbiAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG4gIHZhciBlbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG4gIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcbiAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IHNlbGZbWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKV0oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkgeyB9XG4gIH1cbn07XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iLCIvKipcclxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xyXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICB2YXIgc3RyID0gJyc7XHJcblxyXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xyXG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XHJcbiAgdmFyIHFyeSA9IHt9O1xyXG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcclxuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG4gIH1cclxuICByZXR1cm4gcXJ5O1xyXG59O1xyXG4iLCIvKipcclxuICogUGFyc2VzIGFuIFVSSVxyXG4gKlxyXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xyXG5cclxudmFyIHBhcnRzID0gW1xyXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXHJcbl07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xyXG4gICAgdmFyIHNyYyA9IHN0cixcclxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcclxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcclxuXHJcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcclxuICAgICAgICB1cmkgPSB7fSxcclxuICAgICAgICBpID0gMTQ7XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcclxuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xyXG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xyXG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXJpO1xyXG59O1xyXG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCAodXJpLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXG4gIHZhciBpbztcblxuICBpZiAobmV3Q29ubmVjdGlvbikge1xuICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcbiAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgICAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBpbyA9IGNhY2hlW2lkXTtcbiAgfVxuICBpZiAocGFyc2VkLnF1ZXJ5ICYmICFvcHRzLnF1ZXJ5KSB7XG4gICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeTtcbiAgfVxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuLyoqXG4gKiBgY29ubmVjdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbi8qKlxuICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xuZXhwb3J0cy5Tb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGVpbyA9IHJlcXVpcmUoJ2VuZ2luZS5pby1jbGllbnQnKTtcbnZhciBTb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6bWFuYWdlcicpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgQmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvMicpO1xuXG4vKipcbiAqIElFNisgaGFzT3duUHJvcGVydHlcbiAqL1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjtcblxuLyoqXG4gKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1hbmFnZXIgKHVyaSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFuYWdlcikpIHJldHVybiBuZXcgTWFuYWdlcih1cmksIG9wdHMpO1xuICBpZiAodXJpICYmICgnb2JqZWN0JyA9PT0gdHlwZW9mIHVyaSkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuICB0aGlzLm5zcHMgPSB7fTtcbiAgdGhpcy5zdWJzID0gW107XG4gIHRoaXMub3B0cyA9IG9wdHM7XG4gIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yIHx8IDAuNSk7XG4gIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG4gIH0pO1xuICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLnVyaSA9IHVyaTtcbiAgdGhpcy5jb25uZWN0aW5nID0gW107XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHZhciBfcGFyc2VyID0gb3B0cy5wYXJzZXIgfHwgcGFyc2VyO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgX3BhcnNlci5FbmNvZGVyKCk7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBfcGFyc2VyLkRlY29kZXIoKTtcbiAgdGhpcy5hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuICBpZiAodGhpcy5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogUHJvcGFnYXRlIGdpdmVuIGV2ZW50IHRvIHNvY2tldHMgYW5kIGVtaXQgb24gYHRoaXNgXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZW1pdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgYHNvY2tldC5pZGAgb2YgYWxsIHNvY2tldHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTb2NrZXRJZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5pZCA9IHRoaXMuZ2VuZXJhdGVJZChuc3ApO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBnZW5lcmF0ZSBgc29ja2V0LmlkYCBmb3IgdGhlIGdpdmVuIGBuc3BgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5zcFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uIChuc3ApIHtcbiAgcmV0dXJuIChuc3AgPT09ICcvJyA/ICcnIDogKG5zcCArICcjJykpICsgdGhpcy5lbmdpbmUuaWQ7XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO1xuICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIGJlZm9yZSBnaXZpbmcgdXBcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheSA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yO1xuICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXhpbXVtIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXggPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbm5lY3Rpb24gdGltZW91dC4gYGZhbHNlYCB0byBkaXNhYmxlXG4gKlxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgdGhpcy5fdGltZW91dCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgaWYgaXQncyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0aW5nXG4gIGlmICghdGhpcy5yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uICYmIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCkge1xuICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3BcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbmFsLCBjYWxsYmFja1xuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vcGVuID1cbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoZm4sIG9wdHMpIHtcbiAgZGVidWcoJ3JlYWR5U3RhdGUgJXMnLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKCdvcGVuJykpIHJldHVybiB0aGlzO1xuXG4gIGRlYnVnKCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuICB0aGlzLmVuZ2luZSA9IGVpbyh0aGlzLnVyaSwgdGhpcy5vcHRzKTtcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG5cbiAgLy8gZW1pdCBgb3BlbmBcbiAgdmFyIG9wZW5TdWIgPSBvbihzb2NrZXQsICdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25vcGVuKCk7XG4gICAgZm4gJiYgZm4oKTtcbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcbiAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRlYnVnKCdjb25uZWN0X2Vycm9yJyk7XG4gICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG4gICAgICBlcnIuZGF0YSA9IGRhdGE7XG4gICAgICBmbihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgc2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuICAgIC8vIHNldCB0aW1lclxuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ29wZW4nKTtcblxuICAvLyBjbGVhciBvbGQgc3Vic1xuICB0aGlzLmNsZWFudXAoKTtcblxuICAvLyBtYXJrIGFzIG9wZW5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcblxuICAvLyBhZGQgbmV3IHN1YnNcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdkYXRhJywgYmluZCh0aGlzLCAnb25kYXRhJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncGluZycsIGJpbmQodGhpcywgJ29ucGluZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BvbmcnLCBiaW5kKHRoaXMsICdvbnBvbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdlcnJvcicsIGJpbmQodGhpcywgJ29uZXJyb3InKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbih0aGlzLmRlY29kZXIsICdkZWNvZGVkJywgYmluZCh0aGlzLCAnb25kZWNvZGVkJykpKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwaW5nLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sYXN0UGluZyA9IG5ldyBEYXRlKCk7XG4gIHRoaXMuZW1pdEFsbCgncGluZycpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBvbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdEFsbCgncG9uZycsIG5ldyBEYXRlKCkgLSB0aGlzLmxhc3RQaW5nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdlcnJvcicsIGVycik7XG4gIHRoaXMuZW1pdEFsbCgnZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNvY2tldCBmb3IgdGhlIGdpdmVuIGBuc3BgLlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuc29ja2V0ID0gZnVuY3Rpb24gKG5zcCwgb3B0cykge1xuICB2YXIgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gIGlmICghc29ja2V0KSB7XG4gICAgc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3AsIG9wdHMpO1xuICAgIHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3RpbmcnLCBvbkNvbm5lY3RpbmcpO1xuICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNvY2tldC5pZCA9IHNlbGYuZ2VuZXJhdGVJZChuc3ApO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgIC8vIG1hbnVhbGx5IGNhbGwgaGVyZSBzaW5jZSBjb25uZWN0aW5nIGV2ZW50IGlzIGZpcmVkIGJlZm9yZSBsaXN0ZW5pbmdcbiAgICAgIG9uQ29ubmVjdGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29ubmVjdGluZyAoKSB7XG4gICAgaWYgKCF+aW5kZXhPZihzZWxmLmNvbm5lY3RpbmcsIHNvY2tldCkpIHtcbiAgICAgIHNlbGYuY29ubmVjdGluZy5wdXNoKHNvY2tldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvY2tldDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gKlxuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoc29ja2V0KSB7XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5jb25uZWN0aW5nLCBzb2NrZXQpO1xuICBpZiAofmluZGV4KSB0aGlzLmNvbm5lY3Rpbmcuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuICB0aGlzLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHBhY2tldC5xdWVyeSAmJiBwYWNrZXQudHlwZSA9PT0gMCkgcGFja2V0Lm5zcCArPSAnPycgKyBwYWNrZXQucXVlcnk7XG5cbiAgaWYgKCFzZWxmLmVuY29kaW5nKSB7XG4gICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuICAgIHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbiAoZW5jb2RlZFBhY2tldHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcbiAgICB2YXIgcGFjayA9IHRoaXMucGFja2V0QnVmZmVyLnNoaWZ0KCk7XG4gICAgdGhpcy5wYWNrZXQocGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcblxuICB2YXIgc3Vic0xlbmd0aCA9IHRoaXMuc3Vicy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpO1xuICAgIHN1Yi5kZXN0cm95KCk7XG4gIH1cblxuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXG4gIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSBjdXJyZW50IHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9XG5NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnZGlzY29ubmVjdCcpO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSB0cnVlO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBgb25jbG9zZWAgd2lsbCBub3QgZmlyZSBiZWNhdXNlXG4gICAgLy8gYW4gb3BlbiBldmVudCBuZXZlciBoYXBwZW5lZFxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgaWYgKHRoaXMuZW5naW5lKSB0aGlzLmVuZ2luZS5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgZGVidWcoJ29uY2xvc2UnKTtcblxuICB0aGlzLmNsZWFudXAoKTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblxuICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG4gICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICBkZWJ1Zygnd2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0JywgZGVsYXkpO1xuXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG4gICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvcicpO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9lcnJvcicsIGVyci5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IHN1Y2Nlc3MnKTtcbiAgICAgICAgICBzZWxmLm9ucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGRlbGF5KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG9uIChvYmosIGV2LCBmbikge1xuICBvYmoub24oZXYsIGZuKTtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHRvQXJyYXkgPSByZXF1aXJlKCd0by1hcnJheScpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGhhc0JpbiA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIEludGVybmFsIGV2ZW50cyAoYmxhY2tsaXN0ZWQpLlxuICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGV2ZW50cyA9IHtcbiAgY29ubmVjdDogMSxcbiAgY29ubmVjdF9lcnJvcjogMSxcbiAgY29ubmVjdF90aW1lb3V0OiAxLFxuICBjb25uZWN0aW5nOiAxLFxuICBkaXNjb25uZWN0OiAxLFxuICBlcnJvcjogMSxcbiAgcmVjb25uZWN0OiAxLFxuICByZWNvbm5lY3RfYXR0ZW1wdDogMSxcbiAgcmVjb25uZWN0X2ZhaWxlZDogMSxcbiAgcmVjb25uZWN0X2Vycm9yOiAxLFxuICByZWNvbm5lY3Rpbmc6IDEsXG4gIHBpbmc6IDEsXG4gIHBvbmc6IDFcbn07XG5cbi8qKlxuICogU2hvcnRjdXQgdG8gYEVtaXR0ZXIjZW1pdGAuXG4gKi9cblxudmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4vKipcbiAqIGBTb2NrZXRgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0IChpbywgbnNwLCBvcHRzKSB7XG4gIHRoaXMuaW8gPSBpbztcbiAgdGhpcy5uc3AgPSBuc3A7XG4gIHRoaXMuanNvbiA9IHRoaXM7IC8vIGNvbXBhdFxuICB0aGlzLmlkcyA9IDA7XG4gIHRoaXMuYWNrcyA9IHt9O1xuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5mbGFncyA9IHt9O1xuICBpZiAob3B0cyAmJiBvcHRzLnF1ZXJ5KSB7XG4gICAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIH1cbiAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gb3BlbiwgY2xvc2UgYW5kIHBhY2tldCBldmVudHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG4gIHZhciBpbyA9IHRoaXMuaW87XG4gIHRoaXMuc3VicyA9IFtcbiAgICBvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG4gICAgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcbiAgICBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuICBdO1xufTtcblxuLyoqXG4gKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5zdWJFdmVudHMoKTtcbiAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gIGlmICgnb3BlbicgPT09IHRoaXMuaW8ucmVhZHlTdGF0ZSkgdGhpcy5vbm9wZW4oKTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2KSB7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYWNrZXQgPSB7XG4gICAgdHlwZTogKHRoaXMuZmxhZ3MuYmluYXJ5ICE9PSB1bmRlZmluZWQgPyB0aGlzLmZsYWdzLmJpbmFyeSA6IGhhc0JpbihhcmdzKSkgPyBwYXJzZXIuQklOQVJZX0VWRU5UIDogcGFyc2VyLkVWRU5ULFxuICAgIGRhdGE6IGFyZ3NcbiAgfTtcblxuICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9ICF0aGlzLmZsYWdzIHx8IGZhbHNlICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzO1xuXG4gIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgIGRlYnVnKCdlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWQnLCB0aGlzLmlkcyk7XG4gICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG4gICAgcGFja2V0LmlkID0gdGhpcy5pZHMrKztcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxuXG4gIHRoaXMuZmxhZ3MgPSB7fTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHBhY2tldC5uc3AgPSB0aGlzLm5zcDtcbiAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9PSB0aGlzLm5zcCkge1xuICAgIGlmICh0aGlzLnF1ZXJ5KSB7XG4gICAgICB2YXIgcXVlcnkgPSB0eXBlb2YgdGhpcy5xdWVyeSA9PT0gJ29iamVjdCcgPyBwYXJzZXFzLmVuY29kZSh0aGlzLnF1ZXJ5KSA6IHRoaXMucXVlcnk7XG4gICAgICBkZWJ1Zygnc2VuZGluZyBjb25uZWN0IHBhY2tldCB3aXRoIHF1ZXJ5ICVzJywgcXVlcnkpO1xuICAgICAgdGhpcy5wYWNrZXQoe3R5cGU6IHBhcnNlci5DT05ORUNULCBxdWVyeTogcXVlcnl9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYWNrZXQoe3R5cGU6IHBhcnNlci5DT05ORUNUfSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlICglcyknLCByZWFzb24pO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGRlbGV0ZSB0aGlzLmlkO1xuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCByZWFzb24pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBzYW1lTmFtZXNwYWNlID0gcGFja2V0Lm5zcCA9PT0gdGhpcy5uc3A7XG4gIHZhciByb290TmFtZXNwYWNlRXJyb3IgPSBwYWNrZXQudHlwZSA9PT0gcGFyc2VyLkVSUk9SICYmIHBhY2tldC5uc3AgPT09ICcvJztcblxuICBpZiAoIXNhbWVOYW1lc3BhY2UgJiYgIXJvb3ROYW1lc3BhY2VFcnJvcikgcmV0dXJuO1xuXG4gIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICBjYXNlIHBhcnNlci5DT05ORUNUOlxuICAgICAgdGhpcy5vbmNvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0VWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkFDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0FDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRElTQ09OTkVDVDpcbiAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVSUk9SOlxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHBhY2tldC5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgc2VudCA9IHRydWU7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cbiAgICBzZWxmLnBhY2tldCh7XG4gICAgICB0eXBlOiBoYXNCaW4oYXJncykgPyBwYXJzZXIuQklOQVJZX0FDSyA6IHBhcnNlci5BQ0ssXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBhY2sgPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhY2spIHtcbiAgICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbn07XG5cbi8qKlxuICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXRCdWZmZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSB7XG4gICAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuc3VicyA9IG51bGw7XG4gIH1cblxuICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPVxuU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGNvbXByZXNzKSB7XG4gIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGJpbmFyeSBmbGFnXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIHRoZSBlbWl0dGVkIGRhdGEgY29udGFpbnMgYmluYXJ5XG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5iaW5hcnkgPSBmdW5jdGlvbiAoYmluYXJ5KSB7XG4gIHRoaXMuZmxhZ3MuYmluYXJ5ID0gYmluYXJ5O1xuICByZXR1cm4gdGhpcztcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsICh1cmksIGxvYykge1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIGxvYyA9IGxvYyB8fCAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhdGlvbik7XG4gIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG4gIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9IGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHZhciBob3N0ID0gaXB2NiA/ICdbJyArIG9iai5ob3N0ICsgJ10nIDogb2JqLmhvc3Q7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cbiIsIi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHRvU3RyaW5nLmNhbGwoQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nKTtcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXScpO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSwgYnVmZmVycyk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbmZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGlzQnVmKGRhdGEpKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhLCBidWZmZXJzKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG5mdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgod2l0aE5hdGl2ZUJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG52YXIgRVJST1JfUEFDS0VUID0gZXhwb3J0cy5FUlJPUiArICdcImVuY29kZSBlcnJvclwiJztcblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG5cbiAgLy8gZmlyc3QgaXMgdHlwZVxuICB2YXIgc3RyID0gJycgKyBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cyArICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPT0gb2JqLm5zcCkge1xuICAgIHN0ciArPSBvYmoubnNwICsgJywnO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHRyeVN0cmluZ2lmeShvYmouZGF0YSk7XG4gICAgaWYgKHBheWxvYWQgIT09IGZhbHNlKSB7XG4gICAgICBzdHIgKz0gcGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVSUk9SX1BBQ0tFVDtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gdHJ5U3RyaW5naWZ5KHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVuY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIGkgPSAwO1xuICAvLyBsb29rIHVwIHR5cGVcbiAgdmFyIHAgPSB7XG4gICAgdHlwZTogTnVtYmVyKHN0ci5jaGFyQXQoMCkpXG4gIH07XG5cbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSB7XG4gICAgcmV0dXJuIGVycm9yKCd1bmtub3duIHBhY2tldCB0eXBlICcgKyBwLnR5cGUpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHAudHlwZSkge1xuICAgIHZhciBzdGFydCA9IGkgKyAxO1xuICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT09ICctJyAmJiBpICE9IHN0ci5sZW5ndGgpIHt9XG4gICAgdmFyIGJ1ZiA9IHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkpO1xuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gJy0nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0YWNobWVudHMnKTtcbiAgICB9XG4gICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcbiAgaWYgKCcvJyA9PT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICB2YXIgc3RhcnQgPSBpICsgMTtcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09PSBjKSBicmVhaztcbiAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgcC5uc3AgPSBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcbiAgfSBlbHNlIHtcbiAgICBwLm5zcCA9ICcvJztcbiAgfVxuXG4gIC8vIGxvb2sgdXAgaWRcbiAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgdmFyIHN0YXJ0ID0gaSArIDE7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkgKyAxKSk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgdmFyIHBheWxvYWQgPSB0cnlQYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICB2YXIgaXNQYXlsb2FkVmFsaWQgPSBwYXlsb2FkICE9PSBmYWxzZSAmJiAocC50eXBlID09PSBleHBvcnRzLkVSUk9SIHx8IGlzQXJyYXkocGF5bG9hZCkpO1xuICAgIGlmIChpc1BheWxvYWRWYWxpZCkge1xuICAgICAgcC5kYXRhID0gcGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVycm9yKCdpbnZhbGlkIHBheWxvYWQnKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiB0cnlQYXJzZShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuRVJST1IsXG4gICAgZGF0YTogJ3BhcnNlciBlcnJvcjogJyArIG1zZ1xuICB9O1xufVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG52YXIgd2l0aE5hdGl2ZUJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcbnZhciB3aXRoTmF0aXZlQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbic7XG5cbnZhciBpc1ZpZXcgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nID8gQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgOiAob2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuICh3aXRoTmF0aXZlQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgICh3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiYgKG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IGlzVmlldyhvYmopKSk7XG59XG4iLCJcclxuLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSBldmVudCBzcGVjaWZpYyBhcnJheXMgZm9yIGV2ZW50IHR5cGVzIHRoYXQgbm9cclxuICAvLyBvbmUgaXMgc3Vic2NyaWJlZCBmb3IgdG8gYXZvaWQgbWVtb3J5IGxlYWsuXHJcbiAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcclxuICB9XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvdHJhbnNsb2FkaXRcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBUcmFuc2xvYWRpdCBwbHVnaW4gY2FuIGJlIHVzZWQgdG8gdXBsb2FkIGZpbGVzIHRvIFRyYW5zbG9hZGl0IGZvciBhbGwga2luZHMgb2YgcHJvY2Vzc2luZywgc3VjaCBhcyB0cmFuc2NvZGluZyB2aWRlbywgcmVzaXppbmcgaW1hZ2VzLCB6aXBwaW5nL3VuemlwcGluZywgYW5kIG1vcmVcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS42LjI2XCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ0cmFuc2xvYWRpdFwiLFxuICAgIFwiZmlsZSBlbmNvZGluZ1wiLFxuICAgIFwiZW5jb2RpbmdcIixcbiAgICBcImZpbGUgcHJvY2Vzc2luZ1wiLFxuICAgIFwidmlkZW8gZW5jb2RpbmdcIixcbiAgICBcImNyb3BcIixcbiAgICBcInJlc2l6ZVwiLFxuICAgIFwid2F0ZXJtYXJrXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29tcGFuaW9uLWNsaWVudFwiOiBcImZpbGU6Li4vY29tcGFuaW9uLWNsaWVudFwiLFxuICAgIFwiQHVwcHkvcHJvdmlkZXItdmlld3NcIjogXCJmaWxlOi4uL3Byb3ZpZGVyLXZpZXdzXCIsXG4gICAgXCJAdXBweS90dXNcIjogXCJmaWxlOi4uL3R1c1wiLFxuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJjb21wb25lbnQtZW1pdHRlclwiOiBcIl4xLjIuMVwiLFxuICAgIFwic29ja2V0LmlvLWNsaWVudFwiOiBcIn4yLjIuMFwiLFxuICAgIFwidXJsLXBhcnNlXCI6IFwiXjEuNC43XCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvcmVcIjogXCJeMS4wLjBcIlxuICB9XG59XG4iLCJjb25zdCBpbyA9IHJlcXVpcmVTb2NrZXRJb1xuY29uc3QgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJylcbmNvbnN0IGhhcyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9oYXNQcm9wZXJ0eScpXG5jb25zdCBwYXJzZVVybCA9IHJlcXVpcmUoJy4vcGFyc2VVcmwnKVxuY29uc3QgTmV0d29ya0Vycm9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL05ldHdvcmtFcnJvcicpXG5jb25zdCBmZXRjaFdpdGhOZXR3b3JrRXJyb3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZmV0Y2hXaXRoTmV0d29ya0Vycm9yJylcblxuLy8gTGF6eSBsb2FkIHNvY2tldC5pbyB0byBhdm9pZCBhIGNvbnNvbGUgZXJyb3Jcbi8vIGluIElFIDEwIHdoZW4gdGhlIFRyYW5zbG9hZGl0IHBsdWdpbiBpcyBub3QgdXNlZC5cbi8vIChUaGUgY29uc29sZS5lcnJvciBjYWxsIGNvbWVzIGZyb20gYGJ1ZmZlcmAuIElcbi8vIHRoaW5rIHdlIGFjdHVhbGx5IGRvbid0IHVzZSB0aGF0IHBhcnQgb2Ygc29ja2V0LmlvXG4vLyBhdCBhbGzigKYpXG5sZXQgc29ja2V0SW9cbmZ1bmN0aW9uIHJlcXVpcmVTb2NrZXRJbyAoKSB7XG4gIGlmICghc29ja2V0SW8pIHtcbiAgICBzb2NrZXRJbyA9IHJlcXVpcmUoJ3NvY2tldC5pby1jbGllbnQnKVxuICB9XG4gIHJldHVybiBzb2NrZXRJb1xufVxuXG5jb25zdCBBU1NFTUJMWV9VUExPQURJTkcgPSAnQVNTRU1CTFlfVVBMT0FESU5HJ1xuY29uc3QgQVNTRU1CTFlfRVhFQ1VUSU5HID0gJ0FTU0VNQkxZX0VYRUNVVElORydcbmNvbnN0IEFTU0VNQkxZX0NPTVBMRVRFRCA9ICdBU1NFTUJMWV9DT01QTEVURUQnXG5cbmNvbnN0IHN0YXR1c09yZGVyID0gW1xuICBBU1NFTUJMWV9VUExPQURJTkcsXG4gIEFTU0VNQkxZX0VYRUNVVElORyxcbiAgQVNTRU1CTFlfQ09NUExFVEVELFxuXVxuXG4vKipcbiAqIENoZWNrIHRoYXQgYW4gYXNzZW1ibHkgc3RhdHVzIGlzIGVxdWFsIHRvIG9yIGxhcmdlciB0aGFuIHNvbWUgZGVzaXJlZCBzdGF0dXMuXG4gKiBJdCBjaGVja3MgZm9yIHRoaW5ncyB0aGF0IGFyZSBsYXJnZXIgc28gdGhhdCBhIGNvbXBhcmlzb24gbGlrZSB0aGlzIHdvcmtzLFxuICogd2hlbiB0aGUgb2xkIGFzc2VtYmx5IHN0YXR1cyBpcyBVUExPQURJTkcgYnV0IHRoZSBuZXcgaXMgRklOSVNIRUQ6XG4gKlxuICogIWlzU3RhdHVzKG9sZFN0YXR1cywgQVNTRU1CTFlfRVhFQ1VUSU5HKSAmJiBpc1N0YXR1cyhuZXdTdGF0ZSwgQVNTRU1CTFlfRVhFQ1VUSU5HKVxuICpcbiAqIOKApnNvIHRoYXQgd2UgY2FuIGVtaXQgdGhlICdleGVjdXRpbmcnIGV2ZW50IGV2ZW4gaWYgdGhlIGV4ZWN1dGlvbiBzdGVwIHdhcyBzb1xuICogZmFzdCB0aGF0IHdlIG1pc3NlZCBpdC5cbiAqL1xuZnVuY3Rpb24gaXNTdGF0dXMgKHN0YXR1cywgdGVzdCkge1xuICByZXR1cm4gc3RhdHVzT3JkZXIuaW5kZXhPZihzdGF0dXMpID49IHN0YXR1c09yZGVyLmluZGV4T2YodGVzdClcbn1cblxuY2xhc3MgVHJhbnNsb2FkaXRBc3NlbWJseSBleHRlbmRzIEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoYXNzZW1ibHkpIHtcbiAgICBzdXBlcigpXG5cbiAgICAvLyBUaGUgY3VycmVudCBhc3NlbWJseSBzdGF0dXMuXG4gICAgdGhpcy5zdGF0dXMgPSBhc3NlbWJseVxuICAgIC8vIFRoZSBzb2NrZXQuaW8gY29ubmVjdGlvbi5cbiAgICB0aGlzLnNvY2tldCA9IG51bGxcbiAgICAvLyBUaGUgaW50ZXJ2YWwgdGltZXIgZm9yIGZ1bGwgc3RhdHVzIHVwZGF0ZXMuXG4gICAgdGhpcy5wb2xsSW50ZXJ2YWwgPSBudWxsXG4gICAgLy8gV2hldGhlciB0aGlzIGFzc2VtYmx5IGhhcyBiZWVuIGNsb3NlZCAoZmluaXNoZWQgb3IgZXJyb3JlZClcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlXG4gIH1cblxuICBjb25uZWN0ICgpIHtcbiAgICB0aGlzLl9jb25uZWN0U29ja2V0KClcbiAgICB0aGlzLl9iZWdpblBvbGxpbmcoKVxuICB9XG5cbiAgX29uRmluaXNoZWQgKCkge1xuICAgIHRoaXMuZW1pdCgnZmluaXNoZWQnKVxuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgX2Nvbm5lY3RTb2NrZXQgKCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlVXJsKHRoaXMuc3RhdHVzLndlYnNvY2tldF91cmwpXG4gICAgY29uc3Qgc29ja2V0ID0gaW8oKS5jb25uZWN0KHBhcnNlZC5vcmlnaW4sIHtcbiAgICAgIHRyYW5zcG9ydHM6IFsnd2Vic29ja2V0J10sXG4gICAgICBwYXRoOiBwYXJzZWQucGF0aG5hbWUsXG4gICAgfSlcblxuICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIHNvY2tldC5lbWl0KCdhc3NlbWJseV9jb25uZWN0Jywge1xuICAgICAgICBpZDogdGhpcy5zdGF0dXMuYXNzZW1ibHlfaWQsXG4gICAgICB9KVxuXG4gICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKVxuICAgIH0pXG5cbiAgICBzb2NrZXQub24oJ2Nvbm5lY3RfZmFpbGVkJywgKCkgPT4ge1xuICAgICAgdGhpcy5fb25FcnJvcihuZXcgTmV0d29ya0Vycm9yKCdUcmFuc2xvYWRpdCBTb2NrZXQuaW8gY29ubmVjdGlvbiBlcnJvcicpKVxuICAgICAgdGhpcy5zb2NrZXQgPSBudWxsXG4gICAgfSlcblxuICAgIHNvY2tldC5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICBzb2NrZXQuZGlzY29ubmVjdCgpXG4gICAgICB0aGlzLnNvY2tldCA9IG51bGxcbiAgICB9KVxuXG4gICAgc29ja2V0Lm9uKCdhc3NlbWJseV9maW5pc2hlZCcsICgpID0+IHtcbiAgICAgIHRoaXMuX29uRmluaXNoZWQoKVxuICAgIH0pXG5cbiAgICBzb2NrZXQub24oJ2Fzc2VtYmx5X3VwbG9hZF9maW5pc2hlZCcsIChmaWxlKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ3VwbG9hZCcsIGZpbGUpXG4gICAgICB0aGlzLnN0YXR1cy51cGxvYWRzLnB1c2goZmlsZSlcbiAgICB9KVxuXG4gICAgc29ja2V0Lm9uKCdhc3NlbWJseV91cGxvYWRpbmdfZmluaXNoZWQnLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2V4ZWN1dGluZycpXG4gICAgfSlcblxuICAgIHNvY2tldC5vbignYXNzZW1ibHlfdXBsb2FkX21ldGFfZGF0YV9leHRyYWN0ZWQnLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ21ldGFkYXRhJylcbiAgICAgIHRoaXMuX2ZldGNoU3RhdHVzKHsgZGlmZjogZmFsc2UgfSlcbiAgICB9KVxuXG4gICAgc29ja2V0Lm9uKCdhc3NlbWJseV9yZXN1bHRfZmluaXNoZWQnLCAoc3RlcE5hbWUsIHJlc3VsdCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdyZXN1bHQnLCBzdGVwTmFtZSwgcmVzdWx0KVxuICAgICAgaWYgKCF0aGlzLnN0YXR1cy5yZXN1bHRzW3N0ZXBOYW1lXSkge1xuICAgICAgICB0aGlzLnN0YXR1cy5yZXN1bHRzW3N0ZXBOYW1lXSA9IFtdXG4gICAgICB9XG4gICAgICB0aGlzLnN0YXR1cy5yZXN1bHRzW3N0ZXBOYW1lXS5wdXNoKHJlc3VsdClcbiAgICB9KVxuXG4gICAgc29ja2V0Lm9uKCdhc3NlbWJseV9lcnJvcicsIChlcnIpID0+IHtcbiAgICAgIHRoaXMuX29uRXJyb3IoZXJyKVxuICAgICAgLy8gUmVmZXRjaCBmb3IgdXBkYXRlZCBzdGF0dXMgY29kZVxuICAgICAgdGhpcy5fZmV0Y2hTdGF0dXMoeyBkaWZmOiBmYWxzZSB9KVxuICAgIH0pXG5cbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICB9XG5cbiAgX29uRXJyb3IgKGVycikge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihlcnIubWVzc2FnZSksIGVycikpXG4gIH1cblxuICAvKipcbiAgICogQmVnaW4gcG9sbGluZyBmb3IgYXNzZW1ibHkgc3RhdHVzIGNoYW5nZXMuIFRoaXMgc2VuZHMgYSByZXF1ZXN0IHRvIHRoZVxuICAgKiBhc3NlbWJseSBzdGF0dXMgZW5kcG9pbnQgZXZlcnkgc28gb2Z0ZW4sIGlmIHRoZSBzb2NrZXQgaXMgbm90IGNvbm5lY3RlZC5cbiAgICogSWYgdGhlIHNvY2tldCBjb25uZWN0aW9uIGZhaWxzIG9yIHRha2VzIGEgbG9uZyB0aW1lLCB3ZSB3b24ndCBtaXNzIGFueVxuICAgKiBldmVudHMuXG4gICAqL1xuICBfYmVnaW5Qb2xsaW5nICgpIHtcbiAgICB0aGlzLnBvbGxJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5zb2NrZXQgfHwgIXRoaXMuc29ja2V0LmNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLl9mZXRjaFN0YXR1cygpXG4gICAgICB9XG4gICAgfSwgMjAwMClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxvYWQgYXNzZW1ibHkgc3RhdHVzLiBVc2VmdWwgaWYgdGhlIHNvY2tldCBkb2Vzbid0IHdvcmsuXG4gICAqXG4gICAqIFBhc3MgYGRpZmY6IGZhbHNlYCB0byBhdm9pZCBlbWl0dGluZyBkaWZmIGV2ZW50cywgaW5zdGVhZCBvbmx5IGVtaXR0aW5nXG4gICAqICdzdGF0dXMnLlxuICAgKi9cbiAgX2ZldGNoU3RhdHVzICh7IGRpZmYgPSB0cnVlIH0gPSB7fSkge1xuICAgIHJldHVybiBmZXRjaFdpdGhOZXR3b3JrRXJyb3IodGhpcy5zdGF0dXMuYXNzZW1ibHlfc3NsX3VybClcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgLnRoZW4oKHN0YXR1cykgPT4ge1xuICAgICAgICAvLyBBdm9pZCB1cGRhdGluZyBpZiB3ZSBjbG9zZWQgZHVyaW5nIHRoaXMgcmVxdWVzdCdzIGxpZmV0aW1lLlxuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHJldHVyblxuICAgICAgICB0aGlzLmVtaXQoJ3N0YXR1cycsIHN0YXR1cylcblxuICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgIHRoaXMudXBkYXRlU3RhdHVzKHN0YXR1cylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHRoaXMuX29uRXJyb3IoZXJyKSlcbiAgfVxuXG4gIHVwZGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoU3RhdHVzKHsgZGlmZjogdHJ1ZSB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGlzIGFzc2VtYmx5J3Mgc3RhdHVzIHdpdGggYSBmdWxsIG5ldyBvYmplY3QuIEV2ZW50cyB3aWxsIGJlXG4gICAqIGVtaXR0ZWQgZm9yIHN0YXR1cyBjaGFuZ2VzLCBuZXcgZmlsZXMsIGFuZCBuZXcgcmVzdWx0cy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHQgVGhlIG5ldyBhc3NlbWJseSBzdGF0dXMgb2JqZWN0LlxuICAgKi9cbiAgdXBkYXRlU3RhdHVzIChuZXh0KSB7XG4gICAgdGhpcy5fZGlmZlN0YXR1cyh0aGlzLnN0YXR1cywgbmV4dClcbiAgICB0aGlzLnN0YXR1cyA9IG5leHRcbiAgfVxuXG4gIC8qKlxuICAgKiBEaWZmIHR3byBhc3NlbWJseSBzdGF0dXNlcywgYW5kIGVtaXQgdGhlIGV2ZW50cyBuZWNlc3NhcnkgdG8gZ28gZnJvbSBgcHJldmBcbiAgICogdG8gYG5leHRgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldiBUaGUgcHJldmlvdXMgYXNzZW1ibHkgc3RhdHVzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dCBUaGUgbmV3IGFzc2VtYmx5IHN0YXR1cy5cbiAgICovXG4gIF9kaWZmU3RhdHVzIChwcmV2LCBuZXh0KSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHByZXYub2tcbiAgICBjb25zdCBuZXh0U3RhdHVzID0gbmV4dC5va1xuXG4gICAgaWYgKG5leHQuZXJyb3IgJiYgIXByZXYuZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vbkVycm9yKG5leHQpXG4gICAgfVxuXG4gICAgLy8gRGVzaXJlZCBlbWl0IG9yZGVyOlxuICAgIC8vICAtIGV4ZWN1dGluZ1xuICAgIC8vICAtIChuIMOXIHVwbG9hZClcbiAgICAvLyAgLSBtZXRhZGF0YVxuICAgIC8vICAtIChtIMOXIHJlc3VsdClcbiAgICAvLyAgLSBmaW5pc2hlZFxuICAgIC8vIFRoZSBiZWxvdyBjaGVja3MgcnVuIGluIHRoaXMgb3JkZXIsIHRoYXQgd2F5IGV2ZW4gaWYgd2UganVtcCBmcm9tXG4gICAgLy8gVVBMT0FESU5HIHN0cmFpZ2h0IHRvIEZJTklTSEVEIGFsbCB0aGUgZXZlbnRzIGFyZSBlbWl0dGVkIGFzIGV4cGVjdGVkLlxuXG4gICAgY29uc3Qgbm93RXhlY3V0aW5nXG4gICAgICA9IGlzU3RhdHVzKG5leHRTdGF0dXMsIEFTU0VNQkxZX0VYRUNVVElORylcbiAgICAgICYmICFpc1N0YXR1cyhwcmV2U3RhdHVzLCBBU1NFTUJMWV9FWEVDVVRJTkcpXG4gICAgaWYgKG5vd0V4ZWN1dGluZykge1xuICAgICAgLy8gV2l0aG91dCBXZWJTb2NrZXRzLCB0aGlzIGlzIG91ciBvbmx5IHdheSB0byB0ZWxsIGlmIHVwbG9hZGluZyBmaW5pc2hlZC5cbiAgICAgIC8vIEhlbmNlLCB3ZSBlbWl0IHRoaXMganVzdCBiZWZvcmUgdGhlICd1cGxvYWQncyBhbmQgYmVmb3JlIHRoZSAnbWV0YWRhdGEnXG4gICAgICAvLyBldmVudCBmb3IgdGhlIG1vc3QgaW50dWl0aXZlIG9yZGVyaW5nLCBjb3JyZXNwb25kaW5nIHRvIHRoZSBfdXN1YWxfXG4gICAgICAvLyBvcmRlcmluZyAoaWYgbm90IGd1YXJhbnRlZWQpIHRoYXQgeW91J2QgZ2V0IG9uIHRoZSBXZWJTb2NrZXQuXG4gICAgICB0aGlzLmVtaXQoJ2V4ZWN1dGluZycpXG4gICAgfVxuXG4gICAgLy8gRmluZCBuZXcgdXBsb2FkZWQgZmlsZXMuXG4gICAgT2JqZWN0LmtleXMobmV4dC51cGxvYWRzKVxuICAgICAgLmZpbHRlcigodXBsb2FkKSA9PiAhaGFzKHByZXYudXBsb2FkcywgdXBsb2FkKSlcbiAgICAgIC5tYXAoKHVwbG9hZCkgPT4gbmV4dC51cGxvYWRzW3VwbG9hZF0pXG4gICAgICAuZm9yRWFjaCgodXBsb2FkKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdCgndXBsb2FkJywgdXBsb2FkKVxuICAgICAgfSlcblxuICAgIGlmIChub3dFeGVjdXRpbmcpIHtcbiAgICAgIHRoaXMuZW1pdCgnbWV0YWRhdGEnKVxuICAgIH1cblxuICAgIC8vIEZpbmQgbmV3IHJlc3VsdHMuXG4gICAgT2JqZWN0LmtleXMobmV4dC5yZXN1bHRzKS5mb3JFYWNoKChzdGVwTmFtZSkgPT4ge1xuICAgICAgY29uc3QgbmV4dFJlc3VsdHMgPSBuZXh0LnJlc3VsdHNbc3RlcE5hbWVdXG4gICAgICBjb25zdCBwcmV2UmVzdWx0cyA9IHByZXYucmVzdWx0c1tzdGVwTmFtZV1cblxuICAgICAgbmV4dFJlc3VsdHNcbiAgICAgICAgLmZpbHRlcigobikgPT4gIXByZXZSZXN1bHRzIHx8ICFwcmV2UmVzdWx0cy5zb21lKChwKSA9PiBwLmlkID09PSBuLmlkKSlcbiAgICAgICAgLmZvckVhY2goKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgncmVzdWx0Jywgc3RlcE5hbWUsIHJlc3VsdClcbiAgICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYgKGlzU3RhdHVzKG5leHRTdGF0dXMsIEFTU0VNQkxZX0NPTVBMRVRFRClcbiAgICAgICAgJiYgIWlzU3RhdHVzKHByZXZTdGF0dXMsIEFTU0VNQkxZX0NPTVBMRVRFRCkpIHtcbiAgICAgIHRoaXMuZW1pdCgnZmluaXNoZWQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHVwZGF0aW5nIHRoaXMgYXNzZW1ibHkuXG4gICAqL1xuICBjbG9zZSAoKSB7XG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlXG4gICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICB0aGlzLnNvY2tldC5kaXNjb25uZWN0KClcbiAgICAgIHRoaXMuc29ja2V0ID0gbnVsbFxuICAgIH1cbiAgICBjbGVhckludGVydmFsKHRoaXMucG9sbEludGVydmFsKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNsb2FkaXRBc3NlbWJseVxuIiwiLyoqXG4gKiBDaGVjayB0aGF0IEFzc2VtYmx5IHBhcmFtZXRlcnMgYXJlIHByZXNlbnQgYW5kIGluY2x1ZGUgYWxsIHJlcXVpcmVkIGZpZWxkcy5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQYXJhbXMgKHBhcmFtcykge1xuICBpZiAoIXBhcmFtcykge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNsb2FkaXQ6IFRoZSBgcGFyYW1zYCBvcHRpb24gaXMgcmVxdWlyZWQuJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBwYXJhbXMgPSBKU09OLnBhcnNlKHBhcmFtcylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFRlbGwgdGhlIHVzZXIgdGhhdCB0aGlzIGlzIG5vdCBhbiBVcHB5IGJ1ZyFcbiAgICAgIGVyci5tZXNzYWdlID0gYFRyYW5zbG9hZGl0OiBUaGUgXFxgcGFyYW1zXFxgIG9wdGlvbiBpcyBhIG1hbGZvcm1lZCBKU09OIHN0cmluZzogJHtcbiAgICAgICAgZXJyLm1lc3NhZ2V9YFxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgaWYgKCFwYXJhbXMuYXV0aCB8fCAhcGFyYW1zLmF1dGgua2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2xvYWRpdDogVGhlIGBwYXJhbXMuYXV0aC5rZXlgIG9wdGlvbiBpcyByZXF1aXJlZC4gJ1xuICAgICAgKyAnWW91IGNhbiBmaW5kIHlvdXIgVHJhbnNsb2FkaXQgQVBJIGtleSBhdCBodHRwczovL3RyYW5zbG9hZGl0LmNvbS9hY2NvdW50L2FwaS1zZXR0aW5ncy4nKVxuICB9XG59XG5cbi8qKlxuICogVHVybiBUcmFuc2xvYWRpdCBwbHVnaW4gb3B0aW9ucyBhbmQgYSBsaXN0IG9mIGZpbGVzIGludG8gYSBsaXN0IG9mIEFzc2VtYmx5XG4gKiBvcHRpb25zLlxuICovXG5jbGFzcyBBc3NlbWJseU9wdGlvbnMge1xuICBjb25zdHJ1Y3RvciAoZmlsZXMsIG9wdHMpIHtcbiAgICB0aGlzLmZpbGVzID0gZmlsZXNcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIFVwcHktc3BlY2lmaWMgQXNzZW1ibHkgb3B0aW9uIGZlYXR1cmVzIHRvIGEgVHJhbnNsb2FkaXQtXG4gICAqIGNvbXBhdGlibGUgb2JqZWN0LlxuICAgKi9cbiAgX25vcm1hbGl6ZUFzc2VtYmx5T3B0aW9ucyAoZmlsZSwgYXNzZW1ibHlPcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXNzZW1ibHlPcHRpb25zLmZpZWxkcykpIHtcbiAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBhc3NlbWJseU9wdGlvbnMuZmllbGRzXG4gICAgICBhc3NlbWJseU9wdGlvbnMuZmllbGRzID0ge31cbiAgICAgIGZpZWxkTmFtZXMuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgIGFzc2VtYmx5T3B0aW9ucy5maWVsZHNbZmllbGROYW1lXSA9IGZpbGUubWV0YVtmaWVsZE5hbWVdXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICghYXNzZW1ibHlPcHRpb25zLmZpZWxkcykge1xuICAgICAgYXNzZW1ibHlPcHRpb25zLmZpZWxkcyA9IHt9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzc2VtYmx5T3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBBc3NlbWJseSBvcHRpb25zIGZvciBhIGZpbGUuXG4gICAqL1xuICBfZ2V0QXNzZW1ibHlPcHRpb25zIChmaWxlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0c1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmdldEFzc2VtYmx5T3B0aW9ucyhmaWxlLCBvcHRpb25zKVxuICAgICAgfSlcbiAgICAgIC50aGVuKChhc3NlbWJseU9wdGlvbnMpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZUFzc2VtYmx5T3B0aW9ucyhmaWxlLCBhc3NlbWJseU9wdGlvbnMpXG4gICAgICB9KVxuICAgICAgLnRoZW4oKGFzc2VtYmx5T3B0aW9ucykgPT4ge1xuICAgICAgICB2YWxpZGF0ZVBhcmFtcyhhc3NlbWJseU9wdGlvbnMucGFyYW1zKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZmlsZUlEczogW2ZpbGUuaWRdLFxuICAgICAgICAgIG9wdGlvbnM6IGFzc2VtYmx5T3B0aW9ucyxcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lIEFzc2VtYmxpZXMgd2l0aCB0aGUgc2FtZSBvcHRpb25zIGludG8gYSBzaW5nbGUgQXNzZW1ibHkgZm9yIGFsbCB0aGVcbiAgICogcmVsZXZhbnQgZmlsZXMuXG4gICAqL1xuICBfZGVkdXBlIChsaXN0KSB7XG4gICAgY29uc3QgZGVkdXBlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIGxpc3QuZm9yRWFjaCgoeyBmaWxlSURzLCBvcHRpb25zIH0pID0+IHtcbiAgICAgIGNvbnN0IGlkID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucylcbiAgICAgIGlmIChkZWR1cGVNYXBbaWRdKSB7XG4gICAgICAgIGRlZHVwZU1hcFtpZF0uZmlsZUlEcy5wdXNoKC4uLmZpbGVJRHMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWR1cGVNYXBbaWRdID0ge1xuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgZmlsZUlEczogWy4uLmZpbGVJRHNdLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhkZWR1cGVNYXApLm1hcCgoaWQpID0+IGRlZHVwZU1hcFtpZF0pXG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBzZXQgb2YgQXNzZW1ibGllcyB0aGF0IHdpbGwgaGFuZGxlIHRoZSB1cGxvYWQuXG4gICAqIFJldHVybnMgYSBQcm9taXNlIGZvciBhbiBvYmplY3Qgd2l0aCBrZXlzOlxuICAgKiAgLSBmaWxlSURzIC0gYW4gYXJyYXkgb2YgZmlsZSBJRHMgdG8gYWRkIHRvIHRoaXMgQXNzZW1ibHlcbiAgICogIC0gb3B0aW9ucyAtIEFzc2VtYmx5IG9wdGlvbnNcbiAgICovXG4gIGJ1aWxkICgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRzXG5cbiAgICBpZiAodGhpcy5maWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgIHRoaXMuZmlsZXMubWFwKChmaWxlKSA9PiB0aGlzLl9nZXRBc3NlbWJseU9wdGlvbnMoZmlsZSkpXG4gICAgICApLnRoZW4oKGxpc3QpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZHVwZShsaXN0KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hbHdheXNSdW5Bc3NlbWJseSkge1xuICAgICAgLy8gTm8gZmlsZXMsIGp1c3QgZ2VuZXJhdGUgb25lIEFzc2VtYmx5XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICBvcHRpb25zLmdldEFzc2VtYmx5T3B0aW9ucyhudWxsLCBvcHRpb25zKVxuICAgICAgKS50aGVuKChhc3NlbWJseU9wdGlvbnMpID0+IHtcbiAgICAgICAgdmFsaWRhdGVQYXJhbXMoYXNzZW1ibHlPcHRpb25zLnBhcmFtcylcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgZmlsZUlEczogdGhpcy5maWxlcy5tYXAoKGZpbGUpID0+IGZpbGUuaWQpLFxuICAgICAgICAgIG9wdGlvbnM6IGFzc2VtYmx5T3B0aW9ucyxcbiAgICAgICAgfV1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGZpbGVzIGFuZCB3ZSBkbyBub3QgYGFsd2F5c1J1bkFzc2VtYmx5YCxcbiAgICAvLyBkb24ndCBkbyBhbnl0aGluZy5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXNzZW1ibHlPcHRpb25zXG5tb2R1bGUuZXhwb3J0cy52YWxpZGF0ZVBhcmFtcyA9IHZhbGlkYXRlUGFyYW1zXG4iLCJjb25zdCBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKVxuXG4vKipcbiAqIFRyYWNrIGNvbXBsZXRpb24gb2YgbXVsdGlwbGUgYXNzZW1ibGllcy5cbiAqXG4gKiBFbWl0cyAnYXNzZW1ibHktY29tcGxldGUnIHdoZW4gYW4gYXNzZW1ibHkgY29tcGxldGVzLlxuICogRW1pdHMgJ2Fzc2VtYmx5LWVycm9yJyB3aGVuIGFuIGFzc2VtYmx5IGZhaWxzLlxuICogRXhwb3NlcyBhIGAucHJvbWlzZWAgcHJvcGVydHkgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBhc3NlbWJsaWVzIGhhdmVcbiAqIGNvbXBsZXRlZCAob3IgZmFpbGVkKS5cbiAqL1xuY2xhc3MgVHJhbnNsb2FkaXRBc3NlbWJseVdhdGNoZXIgZXh0ZW5kcyBFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKHVwcHksIGFzc2VtYmx5SURzKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5fdXBweSA9IHVwcHlcbiAgICB0aGlzLl9hc3NlbWJseUlEcyA9IGFzc2VtYmx5SURzXG4gICAgdGhpcy5fcmVtYWluaW5nID0gYXNzZW1ibHlJRHMubGVuZ3RoXG5cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0XG4gICAgfSlcblxuICAgIHRoaXMuX29uQXNzZW1ibHlDb21wbGV0ZSA9IHRoaXMuX29uQXNzZW1ibHlDb21wbGV0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fb25Bc3NlbWJseUNhbmNlbCA9IHRoaXMuX29uQXNzZW1ibHlDYW5jZWwuYmluZCh0aGlzKVxuICAgIHRoaXMuX29uQXNzZW1ibHlFcnJvciA9IHRoaXMuX29uQXNzZW1ibHlFcnJvci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fb25JbXBvcnRFcnJvciA9IHRoaXMuX29uSW1wb3J0RXJyb3IuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5fYWRkTGlzdGVuZXJzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBBcmUgd2Ugd2F0Y2hpbmcgdGhpcyBhc3NlbWJseSBJRD9cbiAgICovXG4gIF93YXRjaGluZyAoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzZW1ibHlJRHMuaW5kZXhPZihpZCkgIT09IC0xXG4gIH1cblxuICBfb25Bc3NlbWJseUNvbXBsZXRlIChhc3NlbWJseSkge1xuICAgIGlmICghdGhpcy5fd2F0Y2hpbmcoYXNzZW1ibHkuYXNzZW1ibHlfaWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl91cHB5LmxvZyhgW1RyYW5zbG9hZGl0XSBBc3NlbWJseVdhdGNoZXI6IEdvdCBBc3NlbWJseSBmaW5pc2ggJHthc3NlbWJseS5hc3NlbWJseV9pZH1gKVxuXG4gICAgdGhpcy5lbWl0KCdhc3NlbWJseS1jb21wbGV0ZScsIGFzc2VtYmx5LmFzc2VtYmx5X2lkKVxuXG4gICAgdGhpcy5fY2hlY2tBbGxDb21wbGV0ZSgpXG4gIH1cblxuICBfb25Bc3NlbWJseUNhbmNlbCAoYXNzZW1ibHkpIHtcbiAgICBpZiAoIXRoaXMuX3dhdGNoaW5nKGFzc2VtYmx5LmFzc2VtYmx5X2lkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fY2hlY2tBbGxDb21wbGV0ZSgpXG4gIH1cblxuICBfb25Bc3NlbWJseUVycm9yIChhc3NlbWJseSwgZXJyb3IpIHtcbiAgICBpZiAoIXRoaXMuX3dhdGNoaW5nKGFzc2VtYmx5LmFzc2VtYmx5X2lkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fdXBweS5sb2coYFtUcmFuc2xvYWRpdF0gQXNzZW1ibHlXYXRjaGVyOiBHb3QgQXNzZW1ibHkgZXJyb3IgJHthc3NlbWJseS5hc3NlbWJseV9pZH1gKVxuICAgIHRoaXMuX3VwcHkubG9nKGVycm9yKVxuXG4gICAgdGhpcy5lbWl0KCdhc3NlbWJseS1lcnJvcicsIGFzc2VtYmx5LmFzc2VtYmx5X2lkLCBlcnJvcilcblxuICAgIHRoaXMuX2NoZWNrQWxsQ29tcGxldGUoKVxuICB9XG5cbiAgX29uSW1wb3J0RXJyb3IgKGFzc2VtYmx5LCBmaWxlSUQsIGVycm9yKSB7XG4gICAgaWYgKCF0aGlzLl93YXRjaGluZyhhc3NlbWJseS5hc3NlbWJseV9pZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIE5vdCBzdXJlIGlmIHdlIHNob3VsZCBiZSBkb2luZyBzb21ldGhpbmcgd2hlbiBpdCdzIGp1c3Qgb25lIGZpbGUgZmFpbGluZy5cbiAgICAvLyBBVE0sIHRoZSBvbmx5IG9wdGlvbnMgYXJlIDEpIGlnbm9yaW5nIG9yIDIpIGZhaWxpbmcgdGhlIGVudGlyZSB1cGxvYWQuXG4gICAgLy8gSSB0aGluayBmYWlsaW5nIHRoZSB1cGxvYWQgaXMgYmV0dGVyIHRoYW4gc2lsZW50bHkgaWdub3JpbmcuXG4gICAgLy8gSW4gdGhlIGZ1dHVyZSB3ZSBzaG91bGQgbWF5YmUgaGF2ZSBhIHdheSB0byByZXNvbHZlIHVwbG9hZHMgd2l0aCBzb21lIGZhaWx1cmVzLFxuICAgIC8vIGxpa2UgcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGB7IHN1Y2Nlc3NmdWwsIGZhaWxlZCB9YCB1cGxvYWRzLlxuICAgIHRoaXMuX29uQXNzZW1ibHlFcnJvcihhc3NlbWJseSwgZXJyb3IpXG4gIH1cblxuICBfY2hlY2tBbGxDb21wbGV0ZSAoKSB7XG4gICAgdGhpcy5fcmVtYWluaW5nIC09IDFcbiAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAvLyBXZSdyZSBkb25lLCB0aGVzZSBsaXN0ZW5lcnMgY2FuIGJlIHJlbW92ZWRcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpXG4gICAgICB0aGlzLl9yZXNvbHZlKClcbiAgICB9XG4gIH1cblxuICBfcmVtb3ZlTGlzdGVuZXJzICgpIHtcbiAgICB0aGlzLl91cHB5Lm9mZigndHJhbnNsb2FkaXQ6Y29tcGxldGUnLCB0aGlzLl9vbkFzc2VtYmx5Q29tcGxldGUpXG4gICAgdGhpcy5fdXBweS5vZmYoJ3RyYW5zbG9hZGl0OmFzc2VtYmx5LWNhbmNlbCcsIHRoaXMuX29uQXNzZW1ibHlDYW5jZWwpXG4gICAgdGhpcy5fdXBweS5vZmYoJ3RyYW5zbG9hZGl0OmFzc2VtYmx5LWVycm9yJywgdGhpcy5fb25Bc3NlbWJseUVycm9yKVxuICAgIHRoaXMuX3VwcHkub2ZmKCd0cmFuc2xvYWRpdDppbXBvcnQtZXJyb3InLCB0aGlzLl9vbkltcG9ydEVycm9yKVxuICB9XG5cbiAgX2FkZExpc3RlbmVycyAoKSB7XG4gICAgdGhpcy5fdXBweS5vbigndHJhbnNsb2FkaXQ6Y29tcGxldGUnLCB0aGlzLl9vbkFzc2VtYmx5Q29tcGxldGUpXG4gICAgdGhpcy5fdXBweS5vbigndHJhbnNsb2FkaXQ6YXNzZW1ibHktY2FuY2VsJywgdGhpcy5fb25Bc3NlbWJseUNhbmNlbClcbiAgICB0aGlzLl91cHB5Lm9uKCd0cmFuc2xvYWRpdDphc3NlbWJseS1lcnJvcicsIHRoaXMuX29uQXNzZW1ibHlFcnJvcilcbiAgICB0aGlzLl91cHB5Lm9uKCd0cmFuc2xvYWRpdDppbXBvcnQtZXJyb3InLCB0aGlzLl9vbkltcG9ydEVycm9yKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNsb2FkaXRBc3NlbWJseVdhdGNoZXJcbiIsImNvbnN0IGZldGNoV2l0aE5ldHdvcmtFcnJvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9mZXRjaFdpdGhOZXR3b3JrRXJyb3InKVxuY29uc3QgVVJMID0gcmVxdWlyZSgndXJsLXBhcnNlJylcblxuLyoqXG4gKiBBIEJhcmVib25lcyBIVFRQIEFQSSBjbGllbnQgZm9yIFRyYW5zbG9hZGl0LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIENsaWVudCB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG5cbiAgICB0aGlzLl9yZXBvcnRFcnJvciA9IHRoaXMuX3JlcG9ydEVycm9yLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2hlYWRlcnMgPSB7XG4gICAgICAnVHJhbnNsb2FkaXQtQ2xpZW50JzogdGhpcy5vcHRzLmNsaWVudCxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGFzc2VtYmx5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IG9wdGlvbnMucGFyYW1zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmZpZWxkc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zaWduYXR1cmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuZXhwZWN0ZWRGaWxlc1xuICAgKi9cbiAgY3JlYXRlQXNzZW1ibHkgKHtcbiAgICBwYXJhbXMsXG4gICAgZmllbGRzLFxuICAgIHNpZ25hdHVyZSxcbiAgICBleHBlY3RlZEZpbGVzLFxuICB9KSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgZGF0YS5hcHBlbmQoJ3BhcmFtcycsIHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnXG4gICAgICA/IHBhcmFtc1xuICAgICAgOiBKU09OLnN0cmluZ2lmeShwYXJhbXMpKVxuICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgIGRhdGEuYXBwZW5kKCdzaWduYXR1cmUnLCBzaWduYXR1cmUpXG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoZmllbGRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGRhdGEuYXBwZW5kKGtleSwgZmllbGRzW2tleV0pXG4gICAgfSlcbiAgICBkYXRhLmFwcGVuZCgnbnVtX2V4cGVjdGVkX3VwbG9hZF9maWxlcycsIGV4cGVjdGVkRmlsZXMpXG5cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKCcvYXNzZW1ibGllcycsIGAke3RoaXMub3B0cy5zZXJ2aWNlfWApLmhyZWZcbiAgICByZXR1cm4gZmV0Y2hXaXRoTmV0d29ya0Vycm9yKHVybCwge1xuICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICBoZWFkZXJzOiB0aGlzLl9oZWFkZXJzLFxuICAgICAgYm9keTogZGF0YSxcbiAgICB9KVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpLnRoZW4oKGFzc2VtYmx5KSA9PiB7XG4gICAgICAgIGlmIChhc3NlbWJseS5lcnJvcikge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGFzc2VtYmx5LmVycm9yKVxuICAgICAgICAgIGVycm9yLmRldGFpbHMgPSBhc3NlbWJseS5tZXNzYWdlXG4gICAgICAgICAgZXJyb3IuYXNzZW1ibHkgPSBhc3NlbWJseVxuICAgICAgICAgIGlmIChhc3NlbWJseS5hc3NlbWJseV9pZCkge1xuICAgICAgICAgICAgZXJyb3IuZGV0YWlscyArPSAnICcgKyBgQXNzZW1ibHkgSUQ6ICR7YXNzZW1ibHkuYXNzZW1ibHlfaWR9YFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFzc2VtYmx5XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHRoaXMuX3JlcG9ydEVycm9yKGVyciwgeyB1cmwsIHR5cGU6ICdBUElfRVJST1InIH0pKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2VydmUgcmVzb3VyY2VzIGZvciBhIGZpbGUgaW4gYW4gQXNzZW1ibHkuIFRoZW4gYWRkRmlsZSBjYW4gYmUgdXNlZCBsYXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGFzc2VtYmx5XG4gICAqIEBwYXJhbSB7VXBweUZpbGV9IGZpbGVcbiAgICovXG4gIHJlc2VydmVGaWxlIChhc3NlbWJseSwgZmlsZSkge1xuICAgIGNvbnN0IHNpemUgPSBlbmNvZGVVUklDb21wb25lbnQoZmlsZS5zaXplKVxuICAgIGNvbnN0IHVybCA9IGAke2Fzc2VtYmx5LmFzc2VtYmx5X3NzbF91cmx9L3Jlc2VydmVfZmlsZT9zaXplPSR7c2l6ZX1gXG4gICAgcmV0dXJuIGZldGNoV2l0aE5ldHdvcmtFcnJvcih1cmwsIHsgbWV0aG9kOiAncG9zdCcsIGhlYWRlcnM6IHRoaXMuX2hlYWRlcnMgfSlcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgLmNhdGNoKChlcnIpID0+IHRoaXMuX3JlcG9ydEVycm9yKGVyciwgeyBhc3NlbWJseSwgZmlsZSwgdXJsLCB0eXBlOiAnQVBJX0VSUk9SJyB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBvcnQgYSByZW1vdGUgZmlsZSB0byBhbiBBc3NlbWJseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGFzc2VtYmx5XG4gICAqIEBwYXJhbSB7VXBweUZpbGV9IGZpbGVcbiAgICovXG4gIGFkZEZpbGUgKGFzc2VtYmx5LCBmaWxlKSB7XG4gICAgaWYgKCFmaWxlLnVwbG9hZFVSTCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignRmlsZSBkb2VzIG5vdCBoYXZlIGFuIGB1cGxvYWRVUkxgLicpKVxuICAgIH1cbiAgICBjb25zdCBzaXplID0gZW5jb2RlVVJJQ29tcG9uZW50KGZpbGUuc2l6ZSlcbiAgICBjb25zdCB1cGxvYWRVcmwgPSBlbmNvZGVVUklDb21wb25lbnQoZmlsZS51cGxvYWRVUkwpXG4gICAgY29uc3QgZmlsZW5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoZmlsZS5uYW1lKVxuICAgIGNvbnN0IGZpZWxkbmFtZSA9ICdmaWxlJ1xuXG4gICAgY29uc3QgcXMgPSBgc2l6ZT0ke3NpemV9JmZpbGVuYW1lPSR7ZmlsZW5hbWV9JmZpZWxkbmFtZT0ke2ZpZWxkbmFtZX0mczNVcmw9JHt1cGxvYWRVcmx9YFxuICAgIGNvbnN0IHVybCA9IGAke2Fzc2VtYmx5LmFzc2VtYmx5X3NzbF91cmx9L2FkZF9maWxlPyR7cXN9YFxuICAgIHJldHVybiBmZXRjaFdpdGhOZXR3b3JrRXJyb3IodXJsLCB7IG1ldGhvZDogJ3Bvc3QnLCBoZWFkZXJzOiB0aGlzLl9oZWFkZXJzIH0pXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB0aGlzLl9yZXBvcnRFcnJvcihlcnIsIHsgYXNzZW1ibHksIGZpbGUsIHVybCwgdHlwZTogJ0FQSV9FUlJPUicgfSkpXG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIGEgcnVubmluZyBBc3NlbWJseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGFzc2VtYmx5XG4gICAqL1xuICBjYW5jZWxBc3NlbWJseSAoYXNzZW1ibHkpIHtcbiAgICBjb25zdCB1cmwgPSBhc3NlbWJseS5hc3NlbWJseV9zc2xfdXJsXG4gICAgcmV0dXJuIGZldGNoV2l0aE5ldHdvcmtFcnJvcih1cmwsIHsgbWV0aG9kOiAnZGVsZXRlJywgaGVhZGVyczogdGhpcy5faGVhZGVycyB9KVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAuY2F0Y2goKGVycikgPT4gdGhpcy5fcmVwb3J0RXJyb3IoZXJyLCB7IHVybCwgdHlwZTogJ0FQSV9FUlJPUicgfSkpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHN0YXR1cyBmb3IgYW4gYXNzZW1ibHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHN0YXR1cyBlbmRwb2ludCBvZiB0aGUgYXNzZW1ibHkuXG4gICAqL1xuICBnZXRBc3NlbWJseVN0YXR1cyAodXJsKSB7XG4gICAgcmV0dXJuIGZldGNoV2l0aE5ldHdvcmtFcnJvcih1cmwsIHsgaGVhZGVyczogdGhpcy5faGVhZGVycyB9KVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAuY2F0Y2goKGVycikgPT4gdGhpcy5fcmVwb3J0RXJyb3IoZXJyLCB7IHVybCwgdHlwZTogJ1NUQVRVU19FUlJPUicgfSkpXG4gIH1cblxuICBzdWJtaXRFcnJvciAoZXJyLCB7IGVuZHBvaW50LCBpbnN0YW5jZSwgYXNzZW1ibHkgfSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnIuZGV0YWlsc1xuICAgICAgPyBgJHtlcnIubWVzc2FnZX0gKCR7ZXJyLmRldGFpbHN9KWBcbiAgICAgIDogZXJyLm1lc3NhZ2VcblxuICAgIHJldHVybiBmZXRjaFdpdGhOZXR3b3JrRXJyb3IoJ2h0dHBzOi8vdHJhbnNsb2FkaXRzdGF0dXMuY29tL2NsaWVudF9lcnJvcicsIHtcbiAgICAgIG1ldGhvZDogJ3Bvc3QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIGFzc2VtYmx5X2lkOiBhc3NlbWJseSxcbiAgICAgICAgYWdlbnQ6IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yLnVzZXJBZ2VudCA6ICcnLFxuICAgICAgICBjbGllbnQ6IHRoaXMub3B0cy5jbGllbnQsXG4gICAgICAgIGVycm9yOiBtZXNzYWdlLFxuICAgICAgfSksXG4gICAgfSlcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxuICB9XG5cbiAgX3JlcG9ydEVycm9yIChlcnIsIHBhcmFtcykge1xuICAgIGlmICh0aGlzLm9wdHMuZXJyb3JSZXBvcnRpbmcgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgdHlwZTogcGFyYW1zLnR5cGUsXG4gICAgfVxuICAgIGlmIChwYXJhbXMuYXNzZW1ibHkpIHtcbiAgICAgIG9wdHMuYXNzZW1ibHkgPSBwYXJhbXMuYXNzZW1ibHkuYXNzZW1ibHlfaWRcbiAgICAgIG9wdHMuaW5zdGFuY2UgPSBwYXJhbXMuYXNzZW1ibHkuaW5zdGFuY2VcbiAgICB9XG4gICAgaWYgKHBhcmFtcy51cmwpIHtcbiAgICAgIG9wdHMuZW5kcG9pbnQgPSBwYXJhbXMudXJsXG4gICAgfVxuXG4gICAgdGhpcy5zdWJtaXRFcnJvcihlcnIsIG9wdHMpLmNhdGNoKChfKSA9PiB7XG4gICAgICAvLyBub3QgbXVjaCB3ZSBjYW4gZG8gdGhlbiBpcyB0aGVyZVxuICAgIH0pXG5cbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuIiwiY29uc3QgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9UcmFuc2xhdG9yJylcbmNvbnN0IGhhc1Byb3BlcnR5ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2hhc1Byb3BlcnR5JylcbmNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IFR1cyA9IHJlcXVpcmUoJ0B1cHB5L3R1cycpXG5jb25zdCBBc3NlbWJseSA9IHJlcXVpcmUoJy4vQXNzZW1ibHknKVxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi9DbGllbnQnKVxuY29uc3QgQXNzZW1ibHlPcHRpb25zID0gcmVxdWlyZSgnLi9Bc3NlbWJseU9wdGlvbnMnKVxuY29uc3QgQXNzZW1ibHlXYXRjaGVyID0gcmVxdWlyZSgnLi9Bc3NlbWJseVdhdGNoZXInKVxuXG5mdW5jdGlvbiBkZWZhdWx0R2V0QXNzZW1ibHlPcHRpb25zIChmaWxlLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgcGFyYW1zOiBvcHRpb25zLnBhcmFtcyxcbiAgICBzaWduYXR1cmU6IG9wdGlvbnMuc2lnbmF0dXJlLFxuICAgIGZpZWxkczogb3B0aW9ucy5maWVsZHMsXG4gIH1cbn1cblxuY29uc3QgQ09NUEFOSU9OID0gJ2h0dHBzOi8vYXBpMi50cmFuc2xvYWRpdC5jb20vY29tcGFuaW9uJ1xuLy8gUmVnZXggbWF0Y2hpbmcgYWNjZXB0YWJsZSBwb3N0TWVzc2FnZSgpIG9yaWdpbnMgZm9yIGF1dGhlbnRpY2F0aW9uIGZlZWRiYWNrIGZyb20gY29tcGFuaW9uLlxuY29uc3QgQUxMT1dFRF9DT01QQU5JT05fUEFUVEVSTiA9IC9cXC50cmFuc2xvYWRpdFxcLmNvbSQvXG4vLyBSZWdleCB1c2VkIHRvIGNoZWNrIGlmIGEgQ29tcGFuaW9uIGFkZHJlc3MgaXMgcnVuIGJ5IFRyYW5zbG9hZGl0LlxuY29uc3QgVExfQ09NUEFOSU9OID0gL2h0dHBzPzpcXC9cXC9hcGkyKD86LVxcdyspP1xcLnRyYW5zbG9hZGl0XFwuY29tXFwvY29tcGFuaW9uL1xuY29uc3QgVExfVVBQWV9TRVJWRVIgPSAvaHR0cHM/OlxcL1xcL2FwaTIoPzotXFx3Kyk/XFwudHJhbnNsb2FkaXRcXC5jb21cXC91cHB5LXNlcnZlci9cblxuLyoqXG4gKiBVcGxvYWQgZmlsZXMgdG8gVHJhbnNsb2FkaXQgdXNpbmcgVHVzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFRyYW5zbG9hZGl0IGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMudHlwZSA9ICd1cGxvYWRlcidcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdUcmFuc2xvYWRpdCdcbiAgICB0aGlzLnRpdGxlID0gJ1RyYW5zbG9hZGl0J1xuXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0ge1xuICAgICAgc3RyaW5nczoge1xuICAgICAgICBjcmVhdGluZ0Fzc2VtYmx5OiAnUHJlcGFyaW5nIHVwbG9hZC4uLicsXG4gICAgICAgIGNyZWF0aW5nQXNzZW1ibHlGYWlsZWQ6ICdUcmFuc2xvYWRpdDogQ291bGQgbm90IGNyZWF0ZSBBc3NlbWJseScsXG4gICAgICAgIGVuY29kaW5nOiAnRW5jb2RpbmcuLi4nLFxuICAgICAgfSxcbiAgICB9XG5cbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHNlcnZpY2U6ICdodHRwczovL2FwaTIudHJhbnNsb2FkaXQuY29tJyxcbiAgICAgIGVycm9yUmVwb3J0aW5nOiB0cnVlLFxuICAgICAgd2FpdEZvckVuY29kaW5nOiBmYWxzZSxcbiAgICAgIHdhaXRGb3JNZXRhZGF0YTogZmFsc2UsXG4gICAgICBhbHdheXNSdW5Bc3NlbWJseTogZmFsc2UsXG4gICAgICBpbXBvcnRGcm9tVXBsb2FkVVJMczogZmFsc2UsXG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwYXJhbXM6IG51bGwsXG4gICAgICBmaWVsZHM6IHt9LFxuICAgICAgZ2V0QXNzZW1ibHlPcHRpb25zOiBkZWZhdWx0R2V0QXNzZW1ibHlPcHRpb25zLFxuICAgICAgbGltaXQ6IDAsXG4gICAgfVxuXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcblxuICAgIHRoaXMuX3ByZXBhcmVVcGxvYWQgPSB0aGlzLl9wcmVwYXJlVXBsb2FkLmJpbmQodGhpcylcbiAgICB0aGlzLl9hZnRlclVwbG9hZCA9IHRoaXMuX2FmdGVyVXBsb2FkLmJpbmQodGhpcylcbiAgICB0aGlzLl9vbkVycm9yID0gdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fb25UdXNFcnJvciA9IHRoaXMuX29uVHVzRXJyb3IuYmluZCh0aGlzKVxuICAgIHRoaXMuX29uQ2FuY2VsQWxsID0gdGhpcy5fb25DYW5jZWxBbGwuYmluZCh0aGlzKVxuICAgIHRoaXMuX29uRmlsZVVwbG9hZFVSTEF2YWlsYWJsZSA9IHRoaXMuX29uRmlsZVVwbG9hZFVSTEF2YWlsYWJsZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fb25SZXN0b3JlZCA9IHRoaXMuX29uUmVzdG9yZWQuYmluZCh0aGlzKVxuICAgIHRoaXMuX2dldFBlcnNpc3RlbnREYXRhID0gdGhpcy5fZ2V0UGVyc2lzdGVudERhdGEuYmluZCh0aGlzKVxuXG4gICAgY29uc3QgaGFzQ3VzdG9tQXNzZW1ibHlPcHRpb25zID0gdGhpcy5vcHRzLmdldEFzc2VtYmx5T3B0aW9ucyAhPT0gZGVmYXVsdE9wdGlvbnMuZ2V0QXNzZW1ibHlPcHRpb25zXG4gICAgaWYgKHRoaXMub3B0cy5wYXJhbXMpIHtcbiAgICAgIEFzc2VtYmx5T3B0aW9ucy52YWxpZGF0ZVBhcmFtcyh0aGlzLm9wdHMucGFyYW1zKVxuICAgIH0gZWxzZSBpZiAoIWhhc0N1c3RvbUFzc2VtYmx5T3B0aW9ucykge1xuICAgICAgLy8gVGhyb3cgdGhlIHNhbWUgZXJyb3IgdGhhdCB3ZSdkIHRocm93IGlmIHRoZSBgcGFyYW1zYCByZXR1cm5lZCBmcm9tIGFcbiAgICAgIC8vIGBnZXRBc3NlbWJseU9wdGlvbnMoKWAgZnVuY3Rpb24gaXMgbnVsbC5cbiAgICAgIEFzc2VtYmx5T3B0aW9ucy52YWxpZGF0ZVBhcmFtcyhudWxsKVxuICAgIH1cblxuICAgIHRoaXMuY2xpZW50ID0gbmV3IENsaWVudCh7XG4gICAgICBzZXJ2aWNlOiB0aGlzLm9wdHMuc2VydmljZSxcbiAgICAgIGNsaWVudDogdGhpcy5fZ2V0Q2xpZW50VmVyc2lvbigpLFxuICAgICAgZXJyb3JSZXBvcnRpbmc6IHRoaXMub3B0cy5lcnJvclJlcG9ydGluZyxcbiAgICB9KVxuICAgIC8vIENvbnRhaW5zIEFzc2VtYmx5IGluc3RhbmNlcyBmb3IgaW4tcHJvZ3Jlc3MgQXNzZW1ibGllcy5cbiAgICB0aGlzLmFjdGl2ZUFzc2VtYmxpZXMgPSB7fVxuICAgIC8vIENvbnRhaW5zIGEgbWFwcGluZyBvZiB1cGxvYWRJRCB0byBBc3NlbWJseVdhdGNoZXJcbiAgICB0aGlzLmFzc2VtYmx5V2F0Y2hlcnMgPSB7fVxuICAgIC8vIENvbnRhaW5zIGEgZmlsZSBJRHMgdGhhdCBoYXZlIGNvbXBsZXRlZCBwb3N0cHJvY2Vzc2luZyBiZWZvcmUgdGhlIHVwbG9hZCB0aGV5IGJlbG9uZyB0byBoYXMgZW50ZXJlZCB0aGUgcG9zdHByb2Nlc3Mgc3RhZ2UuXG4gICAgdGhpcy5jb21wbGV0ZWRGaWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgfVxuXG4gIHNldE9wdGlvbnMgKG5ld09wdHMpIHtcbiAgICBzdXBlci5zZXRPcHRpb25zKG5ld09wdHMpXG4gICAgdGhpcy5pMThuSW5pdCgpXG4gIH1cblxuICBpMThuSW5pdCAoKSB7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoW3RoaXMuZGVmYXVsdExvY2FsZSwgdGhpcy51cHB5LmxvY2FsZSwgdGhpcy5vcHRzLmxvY2FsZV0pXG4gICAgdGhpcy5pMThuID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLmkxOG5BcnJheSA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGVBcnJheS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKCkgLy8gc28gdGhhdCBVSSByZS1yZW5kZXJzIGFuZCB3ZSBzZWUgdGhlIHVwZGF0ZWQgbG9jYWxlXG4gIH1cblxuICBfZ2V0Q2xpZW50VmVyc2lvbiAoKSB7XG4gICAgY29uc3QgbGlzdCA9IFtcbiAgICAgIGB1cHB5LWNvcmU6JHt0aGlzLnVwcHkuY29uc3RydWN0b3IuVkVSU0lPTn1gLFxuICAgICAgYHVwcHktdHJhbnNsb2FkaXQ6JHt0aGlzLmNvbnN0cnVjdG9yLlZFUlNJT059YCxcbiAgICAgIGB1cHB5LXR1czoke1R1cy5WRVJTSU9OfWAsXG4gICAgXVxuXG4gICAgY29uc3QgYWRkUGx1Z2luVmVyc2lvbiA9IChwbHVnaW5OYW1lLCB2ZXJzaW9uTmFtZSkgPT4ge1xuICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy51cHB5LmdldFBsdWdpbihwbHVnaW5OYW1lKVxuICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICBsaXN0LnB1c2goYCR7dmVyc2lvbk5hbWV9OiR7cGx1Z2luLmNvbnN0cnVjdG9yLlZFUlNJT059YClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmltcG9ydEZyb21VcGxvYWRVUkxzKSB7XG4gICAgICBhZGRQbHVnaW5WZXJzaW9uKCdYSFJVcGxvYWQnLCAndXBweS14aHItdXBsb2FkJylcbiAgICAgIGFkZFBsdWdpblZlcnNpb24oJ0F3c1MzJywgJ3VwcHktYXdzLXMzJylcbiAgICAgIGFkZFBsdWdpblZlcnNpb24oJ0F3c1MzTXVsdGlwYXJ0JywgJ3VwcHktYXdzLXMzLW11bHRpcGFydCcpXG4gICAgfVxuXG4gICAgYWRkUGx1Z2luVmVyc2lvbignRHJvcGJveCcsICd1cHB5LWRyb3Bib3gnKVxuICAgIGFkZFBsdWdpblZlcnNpb24oJ0JveCcsICd1cHB5LWJveCcpXG4gICAgYWRkUGx1Z2luVmVyc2lvbignRmFjZWJvb2snLCAndXBweS1mYWNlYm9vaycpXG4gICAgYWRkUGx1Z2luVmVyc2lvbignR29vZ2xlRHJpdmUnLCAndXBweS1nb29nbGUtZHJpdmUnKVxuICAgIGFkZFBsdWdpblZlcnNpb24oJ0luc3RhZ3JhbScsICd1cHB5LWluc3RhZ3JhbScpXG4gICAgYWRkUGx1Z2luVmVyc2lvbignT25lRHJpdmUnLCAndXBweS1vbmVkcml2ZScpXG4gICAgYWRkUGx1Z2luVmVyc2lvbignWm9vbScsICd1cHB5LXpvb20nKVxuICAgIGFkZFBsdWdpblZlcnNpb24oJ1VybCcsICd1cHB5LXVybCcpXG5cbiAgICByZXR1cm4gbGlzdC5qb2luKCcsJylcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggbWV0YWRhdGEgdG8gZmlsZXMgdG8gY29uZmlndXJlIHRoZSBUdXMgcGx1Z2luIHRvIHVwbG9hZCB0byBUcmFuc2xvYWRpdC5cbiAgICogQWxzbyB1c2UgVHJhbnNsb2FkaXQncyBDb21wYW5pb25cbiAgICpcbiAgICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdHVzL3R1c2Qvd2lraS9VcGxvYWRpbmctdG8tVHJhbnNsb2FkaXQtdXNpbmctdHVzI3VwbG9hZGluZy11c2luZy10dXNcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGZpbGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXR1c1xuICAgKi9cbiAgX2F0dGFjaEFzc2VtYmx5TWV0YWRhdGEgKGZpbGUsIHN0YXR1cykge1xuICAgIC8vIEFkZCB0aGUgbWV0YWRhdGEgcGFyYW1ldGVycyBUcmFuc2xvYWRpdCBuZWVkcy5cbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgLi4uZmlsZS5tZXRhLFxuICAgICAgYXNzZW1ibHlfdXJsOiBzdGF0dXMuYXNzZW1ibHlfdXJsLFxuICAgICAgZmlsZW5hbWU6IGZpbGUubmFtZSxcbiAgICAgIGZpZWxkbmFtZTogJ2ZpbGUnLFxuICAgIH1cbiAgICAvLyBBZGQgQXNzZW1ibHktc3BlY2lmaWMgVHVzIGVuZHBvaW50LlxuICAgIGNvbnN0IHR1cyA9IHtcbiAgICAgIC4uLmZpbGUudHVzLFxuICAgICAgZW5kcG9pbnQ6IHN0YXR1cy50dXNfdXJsLFxuICAgICAgLy8gSW5jbHVkZSBYLVJlcXVlc3QtSUQgaGVhZGVycyBmb3IgYmV0dGVyIGRlYnVnZ2luZy5cbiAgICAgIGFkZFJlcXVlc3RJZDogdHJ1ZSxcbiAgICB9XG5cbiAgICAvLyBTZXQgQ29tcGFuaW9uIGxvY2F0aW9uLiBXZSBvbmx5IGFkZCB0aGlzLCBpZiAnZmlsZScgaGFzIHRoZSBhdHRyaWJ1dGVcbiAgICAvLyByZW1vdGUsIGJlY2F1c2UgdGhpcyBpcyB0aGUgY3JpdGVyaWEgdG8gaWRlbnRpZnkgcmVtb3RlIGZpbGVzLlxuICAgIC8vIFdlIG9ubHkgcmVwbGFjZSB0aGUgaG9zdG5hbWUgZm9yIFRyYW5zbG9hZGl0J3MgY29tcGFuaW9ucywgc28gdGhhdFxuICAgIC8vIHBlb3BsZSBjYW4gYWxzbyBzZWxmLWhvc3QgdGhlbSB3aGlsZSBzdGlsbCB1c2luZyBUcmFuc2xvYWRpdCBmb3IgZW5jb2RpbmcuXG4gICAgbGV0IHJlbW90ZSA9IGZpbGUucmVtb3RlXG4gICAgaWYgKGZpbGUucmVtb3RlICYmIFRMX1VQUFlfU0VSVkVSLnRlc3QoZmlsZS5yZW1vdGUuY29tcGFuaW9uVXJsKSkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAnVGhlIGh0dHBzOi8vYXBpMi50cmFuc2xvYWRpdC5jb20vdXBweS1zZXJ2ZXIgZW5kcG9pbnQgd2FzIHJlbmFtZWQgdG8gJ1xuICAgICAgICArICdodHRwczovL2FwaTIudHJhbnNsb2FkaXQuY29tL2NvbXBhbmlvbiwgcGxlYXNlIHVwZGF0ZSB5b3VyIGBjb21wYW5pb25VcmxgICdcbiAgICAgICAgKyAnb3B0aW9ucyBhY2NvcmRpbmdseS4nXG4gICAgICApXG4gICAgICAvLyBFeHBsaWNpdGx5IGxvZyB0aGlzIGVycm9yIGhlcmUgYmVjYXVzZSBpdCBpcyBjYXVnaHQgYnkgdGhlIGBjcmVhdGVBc3NlbWJseWBcbiAgICAgIC8vIFByb21pc2UgZnVydGhlciBhbG9uZy5cbiAgICAgIC8vIFRoYXQncyBmaW5lLCBidXQgY3JlYXRlQXNzZW1ibHkgb25seSBzaG93cyB0aGUgaW5mb3JtZXIsIHdlIG5lZWQgc29tZXRoaW5nIGFcbiAgICAgIC8vIGxpdHRsZSBtb3JlIG5vaXN5LlxuICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBpZiAoZmlsZS5yZW1vdGUgJiYgVExfQ09NUEFOSU9OLnRlc3QoZmlsZS5yZW1vdGUuY29tcGFuaW9uVXJsKSkge1xuICAgICAgY29uc3QgbmV3SG9zdCA9IHN0YXR1cy5jb21wYW5pb25fdXJsXG4gICAgICAgIC5yZXBsYWNlKC9cXC8kLywgJycpXG4gICAgICBjb25zdCBwYXRoID0gZmlsZS5yZW1vdGUudXJsXG4gICAgICAgIC5yZXBsYWNlKGZpbGUucmVtb3RlLmNvbXBhbmlvblVybCwgJycpXG4gICAgICAgIC5yZXBsYWNlKC9eXFwvLywgJycpXG5cbiAgICAgIHJlbW90ZSA9IHtcbiAgICAgICAgLi4uZmlsZS5yZW1vdGUsXG4gICAgICAgIGNvbXBhbmlvblVybDogbmV3SG9zdCxcbiAgICAgICAgdXJsOiBgJHtuZXdIb3N0fS8ke3BhdGh9YCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgQXNzZW1ibHkgSUQgdGhpcyBmaWxlIGlzIGluIG9uIHRoZSBmaWxlIHVuZGVyIHRoZSBgdHJhbnNsb2FkaXRgIGtleS5cbiAgICBjb25zdCBuZXdGaWxlID0ge1xuICAgICAgLi4uZmlsZSxcbiAgICAgIHRyYW5zbG9hZGl0OiB7XG4gICAgICAgIGFzc2VtYmx5OiBzdGF0dXMuYXNzZW1ibHlfaWQsXG4gICAgICB9LFxuICAgIH1cbiAgICAvLyBPbmx5IGNvbmZpZ3VyZSB0aGUgVHVzIHBsdWdpbiBpZiB3ZSBhcmUgdXBsb2FkaW5nIHN0cmFpZ2h0IHRvIFRyYW5zbG9hZGl0ICh0aGUgZGVmYXVsdCkuXG4gICAgaWYgKCF0aGlzLm9wdHMuaW1wb3J0RnJvbVVwbG9hZFVSTHMpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24obmV3RmlsZSwgeyBtZXRhLCB0dXMsIHJlbW90ZSB9KVxuICAgIH1cbiAgICByZXR1cm4gbmV3RmlsZVxuICB9XG5cbiAgX2NyZWF0ZUFzc2VtYmx5IChmaWxlSURzLCB1cGxvYWRJRCwgb3B0aW9ucykge1xuICAgIHRoaXMudXBweS5sb2coJ1tUcmFuc2xvYWRpdF0gQ3JlYXRlIEFzc2VtYmx5JylcblxuICAgIHJldHVybiB0aGlzLmNsaWVudC5jcmVhdGVBc3NlbWJseSh7XG4gICAgICBwYXJhbXM6IG9wdGlvbnMucGFyYW1zLFxuICAgICAgZmllbGRzOiBvcHRpb25zLmZpZWxkcyxcbiAgICAgIGV4cGVjdGVkRmlsZXM6IGZpbGVJRHMubGVuZ3RoLFxuICAgICAgc2lnbmF0dXJlOiBvcHRpb25zLnNpZ25hdHVyZSxcbiAgICB9KS50aGVuKChuZXdBc3NlbWJseSkgPT4ge1xuICAgICAgY29uc3QgYXNzZW1ibHkgPSBuZXcgQXNzZW1ibHkobmV3QXNzZW1ibHkpXG4gICAgICBjb25zdCBzdGF0dXMgPSBhc3NlbWJseS5zdGF0dXNcbiAgICAgIGNvbnN0IGFzc2VtYmx5SUQgPSBzdGF0dXMuYXNzZW1ibHlfaWRcblxuICAgICAgY29uc3QgeyBhc3NlbWJsaWVzLCB1cGxvYWRzQXNzZW1ibGllcyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgLy8gU3RvcmUgdGhlIEFzc2VtYmx5IHN0YXR1cy5cbiAgICAgICAgYXNzZW1ibGllczoge1xuICAgICAgICAgIC4uLmFzc2VtYmxpZXMsXG4gICAgICAgICAgW2Fzc2VtYmx5SURdOiBzdGF0dXMsXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFN0b3JlIHRoZSBsaXN0IG9mIEFzc2VtYmxpZXMgcmVsYXRlZCB0byB0aGlzIHVwbG9hZC5cbiAgICAgICAgdXBsb2Fkc0Fzc2VtYmxpZXM6IHtcbiAgICAgICAgICAuLi51cGxvYWRzQXNzZW1ibGllcyxcbiAgICAgICAgICBbdXBsb2FkSURdOiBbXG4gICAgICAgICAgICAuLi51cGxvYWRzQXNzZW1ibGllc1t1cGxvYWRJRF0sXG4gICAgICAgICAgICBhc3NlbWJseUlELFxuICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB7IGZpbGVzIH0gPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuICAgICAgY29uc3QgdXBkYXRlZEZpbGVzID0ge31cbiAgICAgIGZpbGVJRHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgdXBkYXRlZEZpbGVzW2lkXSA9IHRoaXMuX2F0dGFjaEFzc2VtYmx5TWV0YWRhdGEodGhpcy51cHB5LmdldEZpbGUoaWQpLCBzdGF0dXMpXG4gICAgICB9KVxuICAgICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgICAgZmlsZXM6IHtcbiAgICAgICAgICAuLi5maWxlcyxcbiAgICAgICAgICAuLi51cGRhdGVkRmlsZXMsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICB0aGlzLnVwcHkuZW1pdCgndHJhbnNsb2FkaXQ6YXNzZW1ibHktY3JlYXRlZCcsIHN0YXR1cywgZmlsZUlEcylcblxuICAgICAgdGhpcy51cHB5LmxvZyhgW1RyYW5zbG9hZGl0XSBDcmVhdGVkIEFzc2VtYmx5ICR7YXNzZW1ibHlJRH1gKVxuICAgICAgcmV0dXJuIGFzc2VtYmx5XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBgJHt0aGlzLmkxOG4oJ2NyZWF0aW5nQXNzZW1ibHlGYWlsZWQnKX06ICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgLy8gUmVqZWN0IHRoZSBwcm9taXNlLlxuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcbiAgfVxuXG4gIF9jcmVhdGVBc3NlbWJseVdhdGNoZXIgKGFzc2VtYmx5SUQsIGZpbGVJRHMsIHVwbG9hZElEKSB7XG4gIC8vIEFzc2VtYmx5V2F0Y2hlciB0cmFja3MgY29tcGxldGlvbiBzdGF0ZXMgb2YgYWxsIEFzc2VtYmxpZXMgaW4gdGhpcyB1cGxvYWQuXG4gICAgY29uc3Qgd2F0Y2hlciA9IG5ldyBBc3NlbWJseVdhdGNoZXIodGhpcy51cHB5LCBhc3NlbWJseUlEKVxuXG4gICAgd2F0Y2hlci5vbignYXNzZW1ibHktY29tcGxldGUnLCAoaWQpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRBc3NlbWJseUZpbGVzKGlkKVxuICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgICB0aGlzLmNvbXBsZXRlZEZpbGVzW2ZpbGUuaWRdID0gdHJ1ZVxuICAgICAgICB0aGlzLnVwcHkuZW1pdCgncG9zdHByb2Nlc3MtY29tcGxldGUnLCBmaWxlKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgd2F0Y2hlci5vbignYXNzZW1ibHktZXJyb3InLCAoaWQsIGVycm9yKSA9PiB7XG4gICAgLy8gQ2xlYXIgcG9zdHByb2Nlc3Npbmcgc3RhdGUgZm9yIGFsbCBvdXIgZmlsZXMuXG4gICAgICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0QXNzZW1ibHlGaWxlcyhpZClcbiAgICAgIGZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIC8vIFRPRE8gTWF5YmUgbWFrZSBhIHBvc3Rwcm9jZXNzLWVycm9yIGV2ZW50IGhlcmU/XG4gICAgICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtZXJyb3InLCBmaWxlLCBlcnJvcilcblxuICAgICAgICB0aGlzLnVwcHkuZW1pdCgncG9zdHByb2Nlc3MtY29tcGxldGUnLCBmaWxlKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5hc3NlbWJseVdhdGNoZXJzW3VwbG9hZElEXSA9IHdhdGNoZXJcbiAgfVxuXG4gIF9zaG91bGRXYWl0QWZ0ZXJVcGxvYWQgKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHMud2FpdEZvckVuY29kaW5nIHx8IHRoaXMub3B0cy53YWl0Rm9yTWV0YWRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHdoZW4gYGltcG9ydEZyb21VcGxvYWRVUkxzYCBpcyBlbmFibGVkOiByZXNlcnZlcyBhbGwgZmlsZXMgaW5cbiAgICogdGhlIEFzc2VtYmx5LlxuICAgKi9cbiAgX3Jlc2VydmVGaWxlcyAoYXNzZW1ibHksIGZpbGVJRHMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZmlsZUlEcy5tYXAoKGZpbGVJRCkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRClcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXNlcnZlRmlsZShhc3NlbWJseS5zdGF0dXMsIGZpbGUpXG4gICAgfSkpXG4gIH1cblxuICAvKipcbiAgICogVXNlZCB3aGVuIGBpbXBvcnRGcm9tVXBsb2FkVVJMc2AgaXMgZW5hYmxlZDogYWRkcyBmaWxlcyB0byB0aGUgQXNzZW1ibHlcbiAgICogb25jZSB0aGV5IGhhdmUgYmVlbiBmdWxseSB1cGxvYWRlZC5cbiAgICovXG4gIF9vbkZpbGVVcGxvYWRVUkxBdmFpbGFibGUgKHJhd0ZpbGUpIHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy51cHB5LmdldEZpbGUocmF3RmlsZS5pZClcbiAgICBpZiAoIWZpbGUgfHwgIWZpbGUudHJhbnNsb2FkaXQgfHwgIWZpbGUudHJhbnNsb2FkaXQuYXNzZW1ibHkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgYXNzZW1ibGllcyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgYXNzZW1ibHkgPSBhc3NlbWJsaWVzW2ZpbGUudHJhbnNsb2FkaXQuYXNzZW1ibHldXG5cbiAgICB0aGlzLmNsaWVudC5hZGRGaWxlKGFzc2VtYmx5LCBmaWxlKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKGVycilcbiAgICAgIHRoaXMudXBweS5lbWl0KCd0cmFuc2xvYWRpdDppbXBvcnQtZXJyb3InLCBhc3NlbWJseSwgZmlsZS5pZCwgZXJyKVxuICAgIH0pXG4gIH1cblxuICBfZmluZEZpbGUgKHVwbG9hZGVkRmlsZSkge1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy51cHB5LmdldEZpbGVzKClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmaWxlID0gZmlsZXNbaV1cbiAgICAgIC8vIENvbXBsZXRlZCBmaWxlIHVwbG9hZC5cbiAgICAgIGlmIChmaWxlLnVwbG9hZFVSTCA9PT0gdXBsb2FkZWRGaWxlLnR1c191cGxvYWRfdXJsKSB7XG4gICAgICAgIHJldHVybiBmaWxlXG4gICAgICB9XG4gICAgICAvLyBJbi1wcm9ncmVzcyBmaWxlIHVwbG9hZC5cbiAgICAgIGlmIChmaWxlLnR1cyAmJiBmaWxlLnR1cy51cGxvYWRVcmwgPT09IHVwbG9hZGVkRmlsZS50dXNfdXBsb2FkX3VybCkge1xuICAgICAgICByZXR1cm4gZmlsZVxuICAgICAgfVxuICAgICAgaWYgKCF1cGxvYWRlZEZpbGUuaXNfdHVzX2ZpbGUpIHtcbiAgICAgICAgLy8gRmluZ2Vycy1jcm9zc2VkIGNoZWNrIGZvciBub24tdHVzIHVwbG9hZHMsIGVnIGltcG9ydGVkIGZyb20gUzMuXG4gICAgICAgIGlmIChmaWxlLm5hbWUgPT09IHVwbG9hZGVkRmlsZS5uYW1lICYmIGZpbGUuc2l6ZSA9PT0gdXBsb2FkZWRGaWxlLnNpemUpIHtcbiAgICAgICAgICByZXR1cm4gZmlsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX29uRmlsZVVwbG9hZENvbXBsZXRlIChhc3NlbWJseUlkLCB1cGxvYWRlZEZpbGUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IGZpbGUgPSB0aGlzLl9maW5kRmlsZSh1cGxvYWRlZEZpbGUpXG4gICAgaWYgKCFmaWxlKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKCdbVHJhbnNsb2FkaXRdIENvdWxkbuKAmXQgZmlsZSB0aGUgZmlsZSwgaXQgd2FzIGxpa2VseSByZW1vdmVkIGluIHRoZSBwcm9jZXNzJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGZpbGVzOiB7XG4gICAgICAgIC4uLnN0YXRlLmZpbGVzLFxuICAgICAgICBbdXBsb2FkZWRGaWxlLmlkXToge1xuICAgICAgICAgIGFzc2VtYmx5OiBhc3NlbWJseUlkLFxuICAgICAgICAgIGlkOiBmaWxlLmlkLFxuICAgICAgICAgIHVwbG9hZGVkRmlsZSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSlcbiAgICB0aGlzLnVwcHkuZW1pdCgndHJhbnNsb2FkaXQ6dXBsb2FkJywgdXBsb2FkZWRGaWxlLCB0aGlzLmdldEFzc2VtYmx5KGFzc2VtYmx5SWQpKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHdoZW4gYSBuZXcgQXNzZW1ibHkgcmVzdWx0IGNvbWVzIGluLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZW1ibHlJZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RlcE5hbWVcbiAgICogQHBhcmFtIHtvYmplY3R9IHJlc3VsdFxuICAgKi9cbiAgX29uUmVzdWx0IChhc3NlbWJseUlkLCBzdGVwTmFtZSwgcmVzdWx0KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBmaWxlID0gc3RhdGUuZmlsZXNbcmVzdWx0Lm9yaWdpbmFsX2lkXVxuICAgIC8vIFRoZSBgZmlsZWAgbWF5IG5vdCBleGlzdCBpZiBhbiBpbXBvcnQgcm9ib3Qgd2FzIHVzZWQgaW5zdGVhZCBvZiBhIGZpbGUgdXBsb2FkLlxuICAgIHJlc3VsdC5sb2NhbElkID0gZmlsZSA/IGZpbGUuaWQgOiBudWxsXG5cbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN0ZXBOYW1lLFxuICAgICAgaWQ6IHJlc3VsdC5pZCxcbiAgICAgIGFzc2VtYmx5OiBhc3NlbWJseUlkLFxuICAgIH1cblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgcmVzdWx0czogWy4uLnN0YXRlLnJlc3VsdHMsIGVudHJ5XSxcbiAgICB9KVxuICAgIHRoaXMudXBweS5lbWl0KCd0cmFuc2xvYWRpdDpyZXN1bHQnLCBzdGVwTmFtZSwgcmVzdWx0LCB0aGlzLmdldEFzc2VtYmx5KGFzc2VtYmx5SWQpKVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gYW4gQXNzZW1ibHkgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcsIGdldCB0aGUgZmluYWwgc3RhdGVcbiAgICogYW5kIGVtaXQgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0dXNcbiAgICovXG4gIF9vbkFzc2VtYmx5RmluaXNoZWQgKHN0YXR1cykge1xuICAgIGNvbnN0IHVybCA9IHN0YXR1cy5hc3NlbWJseV9zc2xfdXJsXG4gICAgdGhpcy5jbGllbnQuZ2V0QXNzZW1ibHlTdGF0dXModXJsKS50aGVuKChmaW5hbFN0YXR1cykgPT4ge1xuICAgICAgY29uc3QgYXNzZW1ibHlJZCA9IGZpbmFsU3RhdHVzLmFzc2VtYmx5X2lkXG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGFzc2VtYmxpZXM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5hc3NlbWJsaWVzLFxuICAgICAgICAgIFthc3NlbWJseUlkXTogZmluYWxTdGF0dXMsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICAgdGhpcy51cHB5LmVtaXQoJ3RyYW5zbG9hZGl0OmNvbXBsZXRlJywgZmluYWxTdGF0dXMpXG4gICAgfSlcbiAgfVxuXG4gIF9jYW5jZWxBc3NlbWJseSAoYXNzZW1ibHkpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FuY2VsQXNzZW1ibHkoYXNzZW1ibHkpLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gVE9ETyBidWJibGUgdGhpcyB0aHJvdWdoIEFzc2VtYmx5V2F0Y2hlciBzbyBpdHMgZXZlbnQgaGFuZGxlcnMgY2FuIGNsZWFuIHVwIGNvcnJlY3RseVxuICAgICAgdGhpcy51cHB5LmVtaXQoJ3RyYW5zbG9hZGl0OmFzc2VtYmx5LWNhbmNlbGxlZCcsIGFzc2VtYmx5KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogV2hlbiBhbGwgZmlsZXMgYXJlIHJlbW92ZWQsIGNhbmNlbCBpbi1wcm9ncmVzcyBBc3NlbWJsaWVzLlxuICAgKi9cbiAgX29uQ2FuY2VsQWxsICgpIHtcbiAgICBjb25zdCB7IHVwbG9hZHNBc3NlbWJsaWVzIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcblxuICAgIGNvbnN0IGFzc2VtYmx5SURzID0gT2JqZWN0LmtleXModXBsb2Fkc0Fzc2VtYmxpZXMpLnJlZHVjZSgoYWNjLCB1cGxvYWRJRCkgPT4ge1xuICAgICAgYWNjLnB1c2goLi4udXBsb2Fkc0Fzc2VtYmxpZXNbdXBsb2FkSURdKVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgY2FuY2VsUHJvbWlzZXMgPSBhc3NlbWJseUlEcy5tYXAoKGFzc2VtYmx5SUQpID0+IHtcbiAgICAgIGNvbnN0IGFzc2VtYmx5ID0gdGhpcy5nZXRBc3NlbWJseShhc3NlbWJseUlEKVxuICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbEFzc2VtYmx5KGFzc2VtYmx5KVxuICAgIH0pXG5cbiAgICBQcm9taXNlLmFsbChjYW5jZWxQcm9taXNlcykuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXN0b20gc3RhdGUgc2VyaWFsaXphdGlvbiBmb3IgdGhlIEdvbGRlbiBSZXRyaWV2ZXIgcGx1Z2luLlxuICAgKiBJdCB3aWxsIHBhc3MgdGhpcyBiYWNrIHRvIHRoZSBgX29uUmVzdG9yZWRgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXREYXRhXG4gICAqL1xuICBfZ2V0UGVyc2lzdGVudERhdGEgKHNldERhdGEpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IGFzc2VtYmxpZXMgPSBzdGF0ZS5hc3NlbWJsaWVzXG4gICAgY29uc3QgdXBsb2Fkc0Fzc2VtYmxpZXMgPSBzdGF0ZS51cGxvYWRzQXNzZW1ibGllc1xuXG4gICAgc2V0RGF0YSh7XG4gICAgICBbdGhpcy5pZF06IHtcbiAgICAgICAgYXNzZW1ibGllcyxcbiAgICAgICAgdXBsb2Fkc0Fzc2VtYmxpZXMsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBfb25SZXN0b3JlZCAocGx1Z2luRGF0YSkge1xuICAgIGNvbnN0IHNhdmVkU3RhdGUgPSBwbHVnaW5EYXRhICYmIHBsdWdpbkRhdGFbdGhpcy5pZF0gPyBwbHVnaW5EYXRhW3RoaXMuaWRdIDoge31cbiAgICBjb25zdCBwcmV2aW91c0Fzc2VtYmxpZXMgPSBzYXZlZFN0YXRlLmFzc2VtYmxpZXMgfHwge31cbiAgICBjb25zdCB1cGxvYWRzQXNzZW1ibGllcyA9IHNhdmVkU3RhdGUudXBsb2Fkc0Fzc2VtYmxpZXMgfHwge31cblxuICAgIGlmIChPYmplY3Qua2V5cyh1cGxvYWRzQXNzZW1ibGllcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIHJlc3RvcmUuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGxvYWRlZCBBc3NlbWJseSBzdGF0dXNlcyB0byBhIFRyYW5zbG9hZGl0IHBsdWdpbiBzdGF0ZSBvYmplY3QuXG4gICAgY29uc3QgcmVzdG9yZVN0YXRlID0gKGFzc2VtYmxpZXMpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVzID0ge31cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXVxuICAgICAgT2JqZWN0LmtleXMoYXNzZW1ibGllcykuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gYXNzZW1ibGllc1tpZF1cblxuICAgICAgICBzdGF0dXMudXBsb2Fkcy5mb3JFYWNoKCh1cGxvYWRlZEZpbGUpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5fZmluZEZpbGUodXBsb2FkZWRGaWxlKVxuICAgICAgICAgIGZpbGVzW3VwbG9hZGVkRmlsZS5pZF0gPSB7XG4gICAgICAgICAgICBpZDogZmlsZS5pZCxcbiAgICAgICAgICAgIGFzc2VtYmx5OiBpZCxcbiAgICAgICAgICAgIHVwbG9hZGVkRmlsZSxcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICAgICAgT2JqZWN0LmtleXMoc3RhdHVzLnJlc3VsdHMpLmZvckVhY2goKHN0ZXBOYW1lKSA9PiB7XG4gICAgICAgICAgc3RhdHVzLnJlc3VsdHNbc3RlcE5hbWVdLmZvckVhY2goKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHN0YXRlLmZpbGVzW3Jlc3VsdC5vcmlnaW5hbF9pZF1cbiAgICAgICAgICAgIHJlc3VsdC5sb2NhbElkID0gZmlsZSA/IGZpbGUuaWQgOiBudWxsXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICBpZDogcmVzdWx0LmlkLFxuICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgIHN0ZXBOYW1lLFxuICAgICAgICAgICAgICBhc3NlbWJseTogaWQsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgYXNzZW1ibGllcyxcbiAgICAgICAgZmlsZXMsXG4gICAgICAgIHJlc3VsdHMsXG4gICAgICAgIHVwbG9hZHNBc3NlbWJsaWVzLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgdGhlIEFzc2VtYmx5IGluc3RhbmNlcyBhbmQgQXNzZW1ibHlXYXRjaGVycyBmb3IgZXhpc3RpbmcgQXNzZW1ibGllcy5cbiAgICBjb25zdCByZXN0b3JlQXNzZW1ibGllcyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgYXNzZW1ibGllcywgdXBsb2Fkc0Fzc2VtYmxpZXMgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgICAvLyBTZXQgdXAgdGhlIGFzc2VtYmx5IHdhdGNoZXJzIGFnYWluIGZvciBhbGwgdGhlIG9uZ29pbmcgdXBsb2Fkcy5cbiAgICAgIE9iamVjdC5rZXlzKHVwbG9hZHNBc3NlbWJsaWVzKS5mb3JFYWNoKCh1cGxvYWRJRCkgPT4ge1xuICAgICAgICBjb25zdCBhc3NlbWJseUlEcyA9IHVwbG9hZHNBc3NlbWJsaWVzW3VwbG9hZElEXVxuICAgICAgICBjb25zdCBmaWxlSURzSW5VcGxvYWQgPSBhc3NlbWJseUlEcy5yZWR1Y2UoKGFjYywgYXNzZW1ibHlJRCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbGVJRHNJbkFzc2VtYmx5ID0gdGhpcy5nZXRBc3NlbWJseUZpbGVzKGFzc2VtYmx5SUQpLm1hcCgoZmlsZSkgPT4gZmlsZS5pZClcbiAgICAgICAgICBhY2MucHVzaCguLi5maWxlSURzSW5Bc3NlbWJseSlcbiAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgIH0sIFtdKVxuICAgICAgICB0aGlzLl9jcmVhdGVBc3NlbWJseVdhdGNoZXIoYXNzZW1ibHlJRHMsIGZpbGVJRHNJblVwbG9hZCwgdXBsb2FkSUQpXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBhbGxBc3NlbWJseUlEcyA9IE9iamVjdC5rZXlzKGFzc2VtYmxpZXMpXG4gICAgICBhbGxBc3NlbWJseUlEcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICBjb25zdCBhc3NlbWJseSA9IG5ldyBBc3NlbWJseShhc3NlbWJsaWVzW2lkXSlcbiAgICAgICAgdGhpcy5fY29ubmVjdEFzc2VtYmx5KGFzc2VtYmx5KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBGb3JjZS11cGRhdGUgYWxsIEFzc2VtYmxpZXMgdG8gY2hlY2sgZm9yIG1pc3NlZCBldmVudHMuXG4gICAgY29uc3QgdXBkYXRlQXNzZW1ibGllcyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgYXNzZW1ibGllcyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgIE9iamVjdC5rZXlzKGFzc2VtYmxpZXMpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVBc3NlbWJsaWVzW2lkXS51cGRhdGUoKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFJlc3RvcmUgYWxsIEFzc2VtYmx5IHN0YXRlLlxuICAgIHRoaXMucmVzdG9yZWQgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIHJlc3RvcmVTdGF0ZShwcmV2aW91c0Fzc2VtYmxpZXMpXG4gICAgICByZXN0b3JlQXNzZW1ibGllcygpXG4gICAgICByZXR1cm4gdXBkYXRlQXNzZW1ibGllcygpXG4gICAgfSlcblxuICAgIHRoaXMucmVzdG9yZWQudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnJlc3RvcmVkID0gbnVsbFxuICAgIH0pXG4gIH1cblxuICBfY29ubmVjdEFzc2VtYmx5IChhc3NlbWJseSkge1xuICAgIGNvbnN0IHsgc3RhdHVzIH0gPSBhc3NlbWJseVxuICAgIGNvbnN0IGlkID0gc3RhdHVzLmFzc2VtYmx5X2lkXG4gICAgdGhpcy5hY3RpdmVBc3NlbWJsaWVzW2lkXSA9IGFzc2VtYmx5XG5cbiAgICAvLyBTeW5jIGxvY2FsIGBhc3NlbWJsaWVzYCBzdGF0ZVxuICAgIGFzc2VtYmx5Lm9uKCdzdGF0dXMnLCAobmV3U3RhdHVzKSA9PiB7XG4gICAgICBjb25zdCB7IGFzc2VtYmxpZXMgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGFzc2VtYmxpZXM6IHtcbiAgICAgICAgICAuLi5hc3NlbWJsaWVzLFxuICAgICAgICAgIFtpZF06IG5ld1N0YXR1cyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGFzc2VtYmx5Lm9uKCd1cGxvYWQnLCAoZmlsZSkgPT4ge1xuICAgICAgdGhpcy5fb25GaWxlVXBsb2FkQ29tcGxldGUoaWQsIGZpbGUpXG4gICAgfSlcbiAgICBhc3NlbWJseS5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgIGVycm9yLmFzc2VtYmx5ID0gYXNzZW1ibHkuc3RhdHVzXG4gICAgICB0aGlzLnVwcHkuZW1pdCgndHJhbnNsb2FkaXQ6YXNzZW1ibHktZXJyb3InLCBhc3NlbWJseS5zdGF0dXMsIGVycm9yKVxuICAgIH0pXG5cbiAgICBhc3NlbWJseS5vbignZXhlY3V0aW5nJywgKCkgPT4ge1xuICAgICAgdGhpcy51cHB5LmVtaXQoJ3RyYW5zbG9hZGl0OmFzc2VtYmx5LWV4ZWN1dGluZycsIGFzc2VtYmx5LnN0YXR1cylcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMub3B0cy53YWl0Rm9yRW5jb2RpbmcpIHtcbiAgICAgIGFzc2VtYmx5Lm9uKCdyZXN1bHQnLCAoc3RlcE5hbWUsIHJlc3VsdCkgPT4ge1xuICAgICAgICB0aGlzLl9vblJlc3VsdChpZCwgc3RlcE5hbWUsIHJlc3VsdClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy53YWl0Rm9yRW5jb2RpbmcpIHtcbiAgICAgIGFzc2VtYmx5Lm9uKCdmaW5pc2hlZCcsICgpID0+IHtcbiAgICAgICAgdGhpcy5fb25Bc3NlbWJseUZpbmlzaGVkKGFzc2VtYmx5LnN0YXR1cylcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdHMud2FpdEZvck1ldGFkYXRhKSB7XG4gICAgICBhc3NlbWJseS5vbignbWV0YWRhdGEnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX29uQXNzZW1ibHlGaW5pc2hlZChhc3NlbWJseS5zdGF0dXMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIE5vIG5lZWQgdG8gY29ubmVjdCB0byB0aGUgc29ja2V0IGlmIHRoZSBBc3NlbWJseSBoYXMgY29tcGxldGVkIGJ5IG5vdy5cbiAgICBpZiAoYXNzZW1ibHkub2sgPT09ICdBU1NFTUJMWV9DT01QTEVURScpIHtcbiAgICAgIHJldHVybiBhc3NlbWJseVxuICAgIH1cblxuICAgIC8vIFRPRE8gRG8gd2Ugc3RpbGwgbmVlZCB0aGlzIGZvciBhbnl0aGluZ+KApj9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBjb25zdCBjb25uZWN0ZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBhc3NlbWJseS5vbmNlKCdjb25uZWN0JywgcmVzb2x2ZSlcbiAgICAgIGFzc2VtYmx5Lm9uY2UoJ3N0YXR1cycsIHJlc29sdmUpXG4gICAgICBhc3NlbWJseS5vbmNlKCdlcnJvcicsIHJlamVjdClcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tUcmFuc2xvYWRpdF0gU29ja2V0IGlzIHJlYWR5JylcbiAgICB9KVxuXG4gICAgYXNzZW1ibHkuY29ubmVjdCgpXG4gICAgcmV0dXJuIGFzc2VtYmx5XG4gIH1cblxuICBfcHJlcGFyZVVwbG9hZCAoZmlsZUlEcywgdXBsb2FkSUQpIHtcbiAgICAvLyBPbmx5IHVzZSBmaWxlcyB3aXRob3V0IGVycm9yc1xuICAgIGZpbGVJRHMgPSBmaWxlSURzLmZpbHRlcigoZmlsZSkgPT4gIWZpbGUuZXJyb3IpXG5cbiAgICBmaWxlSURzLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRClcbiAgICAgIHRoaXMudXBweS5lbWl0KCdwcmVwcm9jZXNzLXByb2dyZXNzJywgZmlsZSwge1xuICAgICAgICBtb2RlOiAnaW5kZXRlcm1pbmF0ZScsXG4gICAgICAgIG1lc3NhZ2U6IHRoaXMuaTE4bignY3JlYXRpbmdBc3NlbWJseScpLFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY29uc3QgY3JlYXRlQXNzZW1ibHkgPSAoeyBmaWxlSURzLCBvcHRpb25zIH0pID0+IHtcbiAgICAgIGxldCBjcmVhdGVkQXNzZW1ibHlcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVBc3NlbWJseShmaWxlSURzLCB1cGxvYWRJRCwgb3B0aW9ucykudGhlbigoYXNzZW1ibHkpID0+IHtcbiAgICAgICAgY3JlYXRlZEFzc2VtYmx5ID0gYXNzZW1ibHlcbiAgICAgICAgaWYgKHRoaXMub3B0cy5pbXBvcnRGcm9tVXBsb2FkVVJMcykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNlcnZlRmlsZXMoYXNzZW1ibHksIGZpbGVJRHMpXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBmaWxlSURzLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpXG4gICAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3ByZXByb2Nlc3MtY29tcGxldGUnLCBmaWxlKVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gY3JlYXRlZEFzc2VtYmx5XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRClcbiAgICAgICAgICAvLyBDbGVhciBwcmVwcm9jZXNzaW5nIHN0YXRlIHdoZW4gdGhlIEFzc2VtYmx5IGNvdWxkIG5vdCBiZSBjcmVhdGVkLFxuICAgICAgICAgIC8vIG90aGVyd2lzZSB0aGUgVUkgZ2V0cyBjb25mdXNlZCBhYm91dCB0aGUgbGluZ2VyaW5nIHByb2dyZXNzIGtleXNcbiAgICAgICAgICB0aGlzLnVwcHkuZW1pdCgncHJlcHJvY2Vzcy1jb21wbGV0ZScsIGZpbGUpXG4gICAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1lcnJvcicsIGZpbGUsIGVycilcbiAgICAgICAgfSlcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHsgdXBsb2Fkc0Fzc2VtYmxpZXMgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgdXBsb2Fkc0Fzc2VtYmxpZXM6IHtcbiAgICAgICAgLi4udXBsb2Fkc0Fzc2VtYmxpZXMsXG4gICAgICAgIFt1cGxvYWRJRF06IFtdLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgY29uc3QgZmlsZXMgPSBmaWxlSURzLm1hcCgoaWQpID0+IHRoaXMudXBweS5nZXRGaWxlKGlkKSlcbiAgICBjb25zdCBhc3NlbWJseU9wdGlvbnMgPSBuZXcgQXNzZW1ibHlPcHRpb25zKGZpbGVzLCB0aGlzLm9wdHMpXG5cbiAgICByZXR1cm4gYXNzZW1ibHlPcHRpb25zLmJ1aWxkKCkudGhlbihcbiAgICAgIChhc3NlbWJsaWVzKSA9PiBQcm9taXNlLmFsbChcbiAgICAgICAgYXNzZW1ibGllcy5tYXAoY3JlYXRlQXNzZW1ibHkpXG4gICAgICApLnRoZW4oKGNyZWF0ZWRBc3NlbWJsaWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGFzc2VtYmx5SURzID0gY3JlYXRlZEFzc2VtYmxpZXMubWFwKGFzc2VtYmx5ID0+IGFzc2VtYmx5LnN0YXR1cy5hc3NlbWJseV9pZClcbiAgICAgICAgdGhpcy5fY3JlYXRlQXNzZW1ibHlXYXRjaGVyKGFzc2VtYmx5SURzLCBmaWxlSURzLCB1cGxvYWRJRClcbiAgICAgICAgY3JlYXRlZEFzc2VtYmxpZXMubWFwKGFzc2VtYmx5ID0+IHRoaXMuX2Nvbm5lY3RBc3NlbWJseShhc3NlbWJseSkpXG4gICAgICB9KSxcbiAgICAgIC8vIElmIHNvbWV0aGluZyB3ZW50IHdyb25nIGJlZm9yZSBhbnkgQXNzZW1ibGllcyBjb3VsZCBiZSBjcmVhdGVkLFxuICAgICAgLy8gY2xlYXIgYWxsIHByb2Nlc3Npbmcgc3RhdGUuXG4gICAgICAoZXJyKSA9PiB7XG4gICAgICAgIGZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRClcbiAgICAgICAgICB0aGlzLnVwcHkuZW1pdCgncHJlcHJvY2Vzcy1jb21wbGV0ZScsIGZpbGUpXG4gICAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1lcnJvcicsIGZpbGUsIGVycilcbiAgICAgICAgfSlcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgX2FmdGVyVXBsb2FkIChmaWxlSURzLCB1cGxvYWRJRCkge1xuICAgIGNvbnN0IGZpbGVzID0gZmlsZUlEcy5tYXAoZmlsZUlEID0+IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRCkpXG4gICAgLy8gT25seSB1c2UgZmlsZXMgd2l0aG91dCBlcnJvcnNcbiAgICBmaWxlSURzID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiAhZmlsZS5lcnJvcikubWFwKGZpbGUgPT4gZmlsZS5pZClcblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG5cbiAgICAvLyBJZiB3ZSdyZSBzdGlsbCByZXN0b3Jpbmcgc3RhdGUsIHdhaXQgZm9yIHRoYXQgdG8gYmUgZG9uZS5cbiAgICBpZiAodGhpcy5yZXN0b3JlZCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVzdG9yZWQudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZnRlclVwbG9hZChmaWxlSURzLCB1cGxvYWRJRClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgYXNzZW1ibHlJRHMgPSBzdGF0ZS51cGxvYWRzQXNzZW1ibGllc1t1cGxvYWRJRF1cblxuICAgIGNvbnN0IGNsb3NlU29ja2V0Q29ubmVjdGlvbnMgPSAoKSA9PiB7XG4gICAgICBhc3NlbWJseUlEcy5mb3JFYWNoKChhc3NlbWJseUlEKSA9PiB7XG4gICAgICAgIGNvbnN0IGFzc2VtYmx5ID0gdGhpcy5hY3RpdmVBc3NlbWJsaWVzW2Fzc2VtYmx5SURdXG4gICAgICAgIGFzc2VtYmx5LmNsb3NlKClcbiAgICAgICAgZGVsZXRlIHRoaXMuYWN0aXZlQXNzZW1ibGllc1thc3NlbWJseUlEXVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIHRvIHdhaXQgZm9yIGVuY29kaW5nIG1ldGFkYXRhIG9yIHJlc3VsdHMsIHdlIGNhbiBjbG9zZVxuICAgIC8vIHRoZSBzb2NrZXQgaW1tZWRpYXRlbHkgYW5kIGZpbmlzaCB0aGUgdXBsb2FkLlxuICAgIGlmICghdGhpcy5fc2hvdWxkV2FpdEFmdGVyVXBsb2FkKCkpIHtcbiAgICAgIGNsb3NlU29ja2V0Q29ubmVjdGlvbnMoKVxuICAgICAgY29uc3QgYXNzZW1ibGllcyA9IGFzc2VtYmx5SURzLm1hcCgoaWQpID0+IHRoaXMuZ2V0QXNzZW1ibHkoaWQpKVxuICAgICAgdGhpcy51cHB5LmFkZFJlc3VsdERhdGEodXBsb2FkSUQsIHsgdHJhbnNsb2FkaXQ6IGFzc2VtYmxpZXMgfSlcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIC8vIElmIG5vIEFzc2VtYmxpZXMgd2VyZSBjcmVhdGVkIGZvciB0aGlzIHVwbG9hZCwgd2UgYWxzbyBkbyBub3QgaGF2ZSB0byB3YWl0LlxuICAgIC8vIFRoZXJlJ3MgYWxzbyBubyBzb2NrZXRzIG9yIGFueXRoaW5nIHRvIGNsb3NlLCBzbyBqdXN0IHJldHVybiBpbW1lZGlhdGVseS5cbiAgICBpZiAoYXNzZW1ibHlJRHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnVwcHkuYWRkUmVzdWx0RGF0YSh1cGxvYWRJRCwgeyB0cmFuc2xvYWRpdDogW10gfSlcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIGNvbnN0IGluY29tcGxldGVGaWxlcyA9IGZpbGVzLmZpbHRlcihmaWxlID0+ICFoYXNQcm9wZXJ0eSh0aGlzLmNvbXBsZXRlZEZpbGVzLCBmaWxlLmlkKSlcbiAgICBpbmNvbXBsZXRlRmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgdGhpcy51cHB5LmVtaXQoJ3Bvc3Rwcm9jZXNzLXByb2dyZXNzJywgZmlsZSwge1xuICAgICAgICBtb2RlOiAnaW5kZXRlcm1pbmF0ZScsXG4gICAgICAgIG1lc3NhZ2U6IHRoaXMuaTE4bignZW5jb2RpbmcnKSxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGNvbnN0IHdhdGNoZXIgPSB0aGlzLmFzc2VtYmx5V2F0Y2hlcnNbdXBsb2FkSURdXG4gICAgcmV0dXJuIHdhdGNoZXIucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGNsb3NlU29ja2V0Q29ubmVjdGlvbnMoKVxuXG4gICAgICBjb25zdCBhc3NlbWJsaWVzID0gYXNzZW1ibHlJRHMubWFwKChpZCkgPT4gdGhpcy5nZXRBc3NlbWJseShpZCkpXG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgQXNzZW1ibHkgSUQgbGlzdCBmb3IgdGhpcyB1cGxvYWQsXG4gICAgICAvLyBpdCdzIG5vIGxvbmdlciBnb2luZyB0byBiZSB1c2VkIGFueXdoZXJlLlxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICAgIGNvbnN0IHVwbG9hZHNBc3NlbWJsaWVzID0geyAuLi5zdGF0ZS51cGxvYWRzQXNzZW1ibGllcyB9XG4gICAgICBkZWxldGUgdXBsb2Fkc0Fzc2VtYmxpZXNbdXBsb2FkSURdXG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgdXBsb2Fkc0Fzc2VtYmxpZXMgfSlcblxuICAgICAgdGhpcy51cHB5LmFkZFJlc3VsdERhdGEodXBsb2FkSUQsIHtcbiAgICAgICAgdHJhbnNsb2FkaXQ6IGFzc2VtYmxpZXMsXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBfb25FcnJvciAoZXJyID0gbnVsbCwgdXBsb2FkSUQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IGFzc2VtYmx5SURzID0gc3RhdGUudXBsb2Fkc0Fzc2VtYmxpZXNbdXBsb2FkSURdXG5cbiAgICBhc3NlbWJseUlEcy5mb3JFYWNoKChhc3NlbWJseUlEKSA9PiB7XG4gICAgICBpZiAodGhpcy5hY3RpdmVBc3NlbWJsaWVzW2Fzc2VtYmx5SURdKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQXNzZW1ibGllc1thc3NlbWJseUlEXS5jbG9zZSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIF9vblR1c0Vycm9yIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIC9edHVzOiAvLnRlc3QoZXJyLm1lc3NhZ2UpKSB7XG4gICAgICBjb25zdCB4aHIgPSBlcnIub3JpZ2luYWxSZXF1ZXN0ID8gZXJyLm9yaWdpbmFsUmVxdWVzdC5nZXRVbmRlcmx5aW5nT2JqZWN0KCkgOiBudWxsXG4gICAgICBjb25zdCB1cmwgPSB4aHIgJiYgeGhyLnJlc3BvbnNlVVJMID8geGhyLnJlc3BvbnNlVVJMIDogbnVsbFxuICAgICAgdGhpcy5jbGllbnQuc3VibWl0RXJyb3IoZXJyLCB7IHVybCwgdHlwZTogJ1RVU19FUlJPUicgfSkudGhlbigoXykgPT4ge1xuICAgICAgICAvLyBpZiB3ZSBjYW4ndCByZXBvcnQgdGhlIGVycm9yIHRoYXQgc3Vja3NcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51cHB5LmFkZFByZVByb2Nlc3Nvcih0aGlzLl9wcmVwYXJlVXBsb2FkKVxuICAgIHRoaXMudXBweS5hZGRQb3N0UHJvY2Vzc29yKHRoaXMuX2FmdGVyVXBsb2FkKVxuXG4gICAgLy8gV2UgbWF5IG5lZWQgdG8gY2xvc2Ugc29ja2V0LmlvIGNvbm5lY3Rpb25zIG9uIGVycm9yLlxuICAgIHRoaXMudXBweS5vbignZXJyb3InLCB0aGlzLl9vbkVycm9yKVxuXG4gICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvbi5cbiAgICB0aGlzLnVwcHkub24oJ2NhbmNlbC1hbGwnLCB0aGlzLl9vbkNhbmNlbEFsbClcblxuICAgIC8vIEZvciBlcnJvciByZXBvcnRpbmcuXG4gICAgdGhpcy51cHB5Lm9uKCd1cGxvYWQtZXJyb3InLCB0aGlzLl9vblR1c0Vycm9yKVxuXG4gICAgaWYgKHRoaXMub3B0cy5pbXBvcnRGcm9tVXBsb2FkVVJMcykge1xuICAgICAgLy8gTm8gdXBsb2FkZXIgbmVlZGVkIHdoZW4gaW1wb3J0aW5nOyBpbnN0ZWFkIHdlIHRha2UgdGhlIHVwbG9hZCBVUkwgZnJvbSBhbiBleGlzdGluZyB1cGxvYWRlci5cbiAgICAgIHRoaXMudXBweS5vbigndXBsb2FkLXN1Y2Nlc3MnLCB0aGlzLl9vbkZpbGVVcGxvYWRVUkxBdmFpbGFibGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBweS51c2UoVHVzLCB7XG4gICAgICAgIC8vIERpc2FibGUgdHVzLWpzLWNsaWVudCBmaW5nZXJwcmludGluZywgb3RoZXJ3aXNlIHVwbG9hZGluZyB0aGUgc2FtZSBmaWxlIGF0IGRpZmZlcmVudCB0aW1lc1xuICAgICAgICAvLyB3aWxsIHVwbG9hZCB0byBhbiBvdXRkYXRlZCBBc3NlbWJseSwgYW5kIHdlIHdvbid0IGdldCBzb2NrZXQgZXZlbnRzIGZvciBpdC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVG8gcmVzdW1lIGEgVHJhbnNsb2FkaXQgdXBsb2FkLCB3ZSBuZWVkIHRvIHJlY29ubmVjdCB0byB0aGUgd2Vic29ja2V0LCBhbmQgdGhlIHN0YXRlIHRoYXQnc1xuICAgICAgICAvLyByZXF1aXJlZCB0byBkbyB0aGF0IGlzIG5vdCBzYXZlZCBieSB0dXMtanMtY2xpZW50J3MgZmluZ2VycHJpbnRpbmcuIFdlIG5lZWQgdGhlIHR1cyBVUkwsXG4gICAgICAgIC8vIHRoZSBBc3NlbWJseSBVUkwsIGFuZCB0aGUgV2ViU29ja2V0IFVSTCwgYXQgbGVhc3QuIFdlIGFsc28gbmVlZCB0byBrbm93IF9hbGxfIHRoZSBmaWxlcyB0aGF0XG4gICAgICAgIC8vIHdlcmUgYWRkZWQgdG8gdGhlIEFzc2VtYmx5LCBzbyB3ZSBjYW4gcHJvcGVybHkgY29tcGxldGUgaXQuIEFsbCB0aGF0IHN0YXRlIGlzIGhhbmRsZWQgYnlcbiAgICAgICAgLy8gR29sZGVuIFJldHJpZXZlci4gU28sIEdvbGRlbiBSZXRyaWV2ZXIgaXMgcmVxdWlyZWQgdG8gZG8gcmVzdW1hYmlsaXR5IHdpdGggdGhlIFRyYW5zbG9hZGl0IHBsdWdpbixcbiAgICAgICAgLy8gYW5kIHdlIGRpc2FibGUgVHVzJ3MgZGVmYXVsdCByZXN1bWUgaW1wbGVtZW50YXRpb24gdG8gcHJldmVudCBiYWQgYmVoYXZpb3Vycy5cbiAgICAgICAgc3RvcmVGaW5nZXJwcmludEZvclJlc3VtaW5nOiBmYWxzZSxcbiAgICAgICAgcmVzdW1lOiBmYWxzZSxcbiAgICAgICAgLy8gRGlzYWJsZSBDb21wYW5pb24ncyByZXRyeSBvcHRpbWlzYXRpb247IHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBlbmRwb2ludCBvbiByZXRyeVxuICAgICAgICAvLyBzbyBpdCBjYW4ndCBqdXN0IHJldXNlIHRoZSBzYW1lIHR1cy5VcGxvYWQgaW5zdGFuY2Ugc2VydmVyLXNpZGUuXG4gICAgICAgIHVzZUZhc3RSZW1vdGVSZXRyeTogZmFsc2UsXG4gICAgICAgIC8vIE9ubHkgc2VuZCBBc3NlbWJseSBtZXRhZGF0YSB0byB0aGUgdHVzIGVuZHBvaW50LlxuICAgICAgICBtZXRhRmllbGRzOiBbJ2Fzc2VtYmx5X3VybCcsICdmaWxlbmFtZScsICdmaWVsZG5hbWUnXSxcbiAgICAgICAgLy8gUGFzcyB0aGUgbGltaXQgb3B0aW9uIHRvIEB1cHB5L3R1c1xuICAgICAgICBsaW1pdDogdGhpcy5vcHRzLmxpbWl0LFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLnVwcHkub24oJ3Jlc3RvcmU6Z2V0LWRhdGEnLCB0aGlzLl9nZXRQZXJzaXN0ZW50RGF0YSlcbiAgICB0aGlzLnVwcHkub24oJ3Jlc3RvcmVkJywgdGhpcy5fb25SZXN0b3JlZClcblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgLy8gQ29udGFpbnMgQXNzZW1ibHkgc3RhdHVzIG9iamVjdHMsIGluZGV4ZWQgYnkgdGhlaXIgSUQuXG4gICAgICBhc3NlbWJsaWVzOiB7fSxcbiAgICAgIC8vIENvbnRhaW5zIGFycmF5cyBvZiBBc3NlbWJseSBJRHMsIGluZGV4ZWQgYnkgdGhlIHVwbG9hZCBJRCB0aGF0IHRoZXkgYmVsb25nIHRvLlxuICAgICAgdXBsb2Fkc0Fzc2VtYmxpZXM6IHt9LFxuICAgICAgLy8gQ29udGFpbnMgZmlsZSBkYXRhIGZyb20gVHJhbnNsb2FkaXQsIGluZGV4ZWQgYnkgdGhlaXIgVHJhbnNsb2FkaXQtYXNzaWduZWQgSUQuXG4gICAgICBmaWxlczoge30sXG4gICAgICAvLyBDb250YWlucyByZXN1bHQgZGF0YSBmcm9tIFRyYW5zbG9hZGl0LlxuICAgICAgcmVzdWx0czogW10sXG4gICAgfSlcblxuICAgIC8vIFdlIGNhbm5vdCBjYW5jZWwgaW5kaXZpZHVhbCBmaWxlcyBiZWNhdXNlIEFzc2VtYmxpZXMgdGVuZCB0byBjb250YWluIG1hbnkgZmlsZXMuXG4gICAgY29uc3QgeyBjYXBhYmlsaXRpZXMgfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG4gICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgIGNhcGFiaWxpdGllczoge1xuICAgICAgICAuLi5jYXBhYmlsaXRpZXMsXG4gICAgICAgIGluZGl2aWR1YWxDYW5jZWxsYXRpb246IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnVwcHkucmVtb3ZlUHJlUHJvY2Vzc29yKHRoaXMuX3ByZXBhcmVVcGxvYWQpXG4gICAgdGhpcy51cHB5LnJlbW92ZVBvc3RQcm9jZXNzb3IodGhpcy5fYWZ0ZXJVcGxvYWQpXG4gICAgdGhpcy51cHB5Lm9mZignZXJyb3InLCB0aGlzLl9vbkVycm9yKVxuXG4gICAgaWYgKHRoaXMub3B0cy5pbXBvcnRGcm9tVXBsb2FkVVJMcykge1xuICAgICAgdGhpcy51cHB5Lm9mZigndXBsb2FkLXN1Y2Nlc3MnLCB0aGlzLl9vbkZpbGVVcGxvYWRVUkxBdmFpbGFibGUpXG4gICAgfVxuXG4gICAgY29uc3QgeyBjYXBhYmlsaXRpZXMgfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG4gICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgIGNhcGFiaWxpdGllczoge1xuICAgICAgICAuLi5jYXBhYmlsaXRpZXMsXG4gICAgICAgIGluZGl2aWR1YWxDYW5jZWxsYXRpb246IHRydWUsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBnZXRBc3NlbWJseSAoaWQpIHtcbiAgICBjb25zdCB7IGFzc2VtYmxpZXMgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIHJldHVybiBhc3NlbWJsaWVzW2lkXVxuICB9XG5cbiAgZ2V0QXNzZW1ibHlGaWxlcyAoYXNzZW1ibHlJRCkge1xuICAgIHJldHVybiB0aGlzLnVwcHkuZ2V0RmlsZXMoKS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiBmaWxlICYmIGZpbGUudHJhbnNsb2FkaXQgJiYgZmlsZS50cmFuc2xvYWRpdC5hc3NlbWJseSA9PT0gYXNzZW1ibHlJRFxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuQ09NUEFOSU9OID0gQ09NUEFOSU9OXG5tb2R1bGUuZXhwb3J0cy5VUFBZX1NFUlZFUiA9IENPTVBBTklPTlxubW9kdWxlLmV4cG9ydHMuQ09NUEFOSU9OX1BBVFRFUk4gPSBBTExPV0VEX0NPTVBBTklPTl9QQVRURVJOXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlVXJsICh1cmwpIHtcbiAgY29uc3Qgc2NoZW1lID0gL15cXHcrOlxcL1xcLy8uZXhlYyh1cmwpXG4gIGxldCBpID0gMFxuICBpZiAoc2NoZW1lKSB7XG4gICAgaSA9IHNjaGVtZVswXS5sZW5ndGggKyAxXG4gIH1cbiAgY29uc3Qgc2xhc2hJbmRleCA9IHVybC5pbmRleE9mKCcvJywgaSlcbiAgaWYgKHNsYXNoSW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9yaWdpbjogdXJsLFxuICAgICAgcGF0aG5hbWU6ICcvJyxcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9yaWdpbjogdXJsLnNsaWNlKDAsIHNsYXNoSW5kZXgpLFxuICAgIHBhdGhuYW1lOiB1cmwuc2xpY2Uoc2xhc2hJbmRleCksXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvdHVzXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJSZXN1bWFibGUgdXBsb2FkcyBmb3IgVXBweSB1c2luZyBUdXMuaW9cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS45LjJcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJ1cGxvYWRcIixcbiAgICBcInJlc3VtYWJsZVwiLFxuICAgIFwidHVzXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIixcbiAgICBcInR1cy1qcy1jbGllbnRcIjogXCJeMi4xLjFcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHR1cyA9IHJlcXVpcmUoJ3R1cy1qcy1jbGllbnQnKVxuXG5mdW5jdGlvbiBpc0NvcmRvdmEgKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIHR5cGVvZiB3aW5kb3cuUGhvbmVHYXAgIT09ICd1bmRlZmluZWQnXG4gICAgfHwgdHlwZW9mIHdpbmRvdy5Db3Jkb3ZhICE9PSAndW5kZWZpbmVkJ1xuICAgIHx8IHR5cGVvZiB3aW5kb3cuY29yZG92YSAhPT0gJ3VuZGVmaW5lZCdcbiAgKVxufVxuXG5mdW5jdGlvbiBpc1JlYWN0TmF0aXZlICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgdHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnc3RyaW5nJ1xuICAgICYmIG5hdmlnYXRvci5wcm9kdWN0LnRvTG93ZXJDYXNlKCkgPT09ICdyZWFjdG5hdGl2ZSdcbn1cblxuLy8gV2Ugb3ZlcnJpZGUgdHVzIGZpbmdlcnByaW50IHRvIHVwcHnigJlzIGBmaWxlLmlkYCwgc2luY2UgdGhlIGBmaWxlLmlkYFxuLy8gbm93IGFsc28gaW5jbHVkZXMgYHJlbGF0aXZlUGF0aGAgZm9yIGZpbGVzIGFkZGVkIGZyb20gZm9sZGVycy5cbi8vIFRoaXMgbWVhbnMgeW91IGNhbiBhZGQgMiBpZGVudGljYWwgZmlsZXMsIGlmIG9uZSBpcyBpbiBmb2xkZXIgYSxcbi8vIHRoZSBvdGhlciBpbiBmb2xkZXIgYiDigJQgYGEvZmlsZS5qcGdgIGFuZCBgYi9maWxlLmpwZ2AsIHdoZW4gYWRkZWRcbi8vIHRvZ2V0aGVyIHdpdGggYSBmb2xkZXIsIHdpbGwgYmUgdHJlYXRlZCBhcyAyIHNlcGFyYXRlIGZpbGVzLlxuLy9cbi8vIEZvciBSZWFjdCBOYXRpdmUgYW5kIENvcmRvdmEsIHdlIGxldCB0dXMtanMtY2xpZW504oCZcyBkZWZhdWx0XG4vLyBmaW5nZXJwcmludCBoYW5kbGluZyB0YWtlIGNoYXJnZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RmluZ2VycHJpbnQgKHVwcHlGaWxlT2JqKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZmlsZSwgb3B0aW9ucykge1xuICAgIGlmIChpc0NvcmRvdmEoKSB8fCBpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIHJldHVybiB0dXMuZGVmYXVsdE9wdGlvbnMuZmluZ2VycHJpbnQoZmlsZSwgb3B0aW9ucylcbiAgICB9XG5cbiAgICBjb25zdCB1cHB5RmluZ2VycHJpbnQgPSBbXG4gICAgICAndHVzJyxcbiAgICAgIHVwcHlGaWxlT2JqLmlkLFxuICAgICAgb3B0aW9ucy5lbmRwb2ludCxcbiAgICBdLmpvaW4oJy0nKVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1cHB5RmluZ2VycHJpbnQpXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHR1cyA9IHJlcXVpcmUoJ3R1cy1qcy1jbGllbnQnKVxuY29uc3QgeyBQcm92aWRlciwgUmVxdWVzdENsaWVudCwgU29ja2V0IH0gPSByZXF1aXJlKCdAdXBweS9jb21wYW5pb24tY2xpZW50JylcbmNvbnN0IGVtaXRTb2NrZXRQcm9ncmVzcyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9lbWl0U29ja2V0UHJvZ3Jlc3MnKVxuY29uc3QgZ2V0U29ja2V0SG9zdCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRTb2NrZXRIb3N0JylcbmNvbnN0IHNldHRsZSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9zZXR0bGUnKVxuY29uc3QgRXZlbnRUcmFja2VyID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL0V2ZW50VHJhY2tlcicpXG5jb25zdCBOZXR3b3JrRXJyb3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvTmV0d29ya0Vycm9yJylcbmNvbnN0IGlzTmV0d29ya0Vycm9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2lzTmV0d29ya0Vycm9yJylcbmNvbnN0IFJhdGVMaW1pdGVkUXVldWUgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvUmF0ZUxpbWl0ZWRRdWV1ZScpXG5jb25zdCBoYXNQcm9wZXJ0eSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9oYXNQcm9wZXJ0eScpXG5jb25zdCBnZXRGaW5nZXJwcmludCA9IHJlcXVpcmUoJy4vZ2V0RmluZ2VycHJpbnQnKVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5UdXNPcHRpb25zfSBUdXNPcHRpb25zICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgndHVzLWpzLWNsaWVudCcpLlVwbG9hZE9wdGlvbnN9IFJhd1R1c09wdGlvbnMgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCdAdXBweS9jb3JlJykuVXBweX0gVXBweSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ0B1cHB5L2NvcmUnKS5VcHB5RmlsZX0gVXBweUZpbGUgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCdAdXBweS9jb3JlJykuRmFpbGVkVXBweUZpbGU8e30+fSBGYWlsZWRVcHB5RmlsZSAqL1xuXG4vKipcbiAqIEV4dHJhY3RlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90dXMvdHVzLWpzLWNsaWVudC9ibG9iL21hc3Rlci9saWIvdXBsb2FkLmpzI0wxM1xuICogZXhjZXB0ZWQgd2UgcmVtb3ZlZCAnZmluZ2VycHJpbnQnIGtleSB0byBhdm9pZCBhZGRpbmcgbW9yZSBkZXBlbmRlbmNpZXNcbiAqXG4gKiBAdHlwZSB7UmF3VHVzT3B0aW9uc31cbiAqL1xuY29uc3QgdHVzRGVmYXVsdE9wdGlvbnMgPSB7XG4gIGVuZHBvaW50OiAnJyxcblxuICB1cGxvYWRVcmw6IG51bGwsXG4gIG1ldGFkYXRhOiB7fSxcbiAgdXBsb2FkU2l6ZTogbnVsbCxcblxuICBvblByb2dyZXNzOiBudWxsLFxuICBvbkNodW5rQ29tcGxldGU6IG51bGwsXG4gIG9uU3VjY2VzczogbnVsbCxcbiAgb25FcnJvcjogbnVsbCxcblxuICBvdmVycmlkZVBhdGNoTWV0aG9kOiBmYWxzZSxcbiAgaGVhZGVyczoge30sXG4gIGFkZFJlcXVlc3RJZDogZmFsc2UsXG5cbiAgY2h1bmtTaXplOiBJbmZpbml0eSxcbiAgcmV0cnlEZWxheXM6IFswLCAxMDAwLCAzMDAwLCA1MDAwXSxcbiAgcGFyYWxsZWxVcGxvYWRzOiAxLFxuICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IHRydWUsXG4gIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzOiBmYWxzZSxcbiAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IGZhbHNlLFxuICB1cGxvYWREYXRhRHVyaW5nQ3JlYXRpb246IGZhbHNlLFxufVxuXG4vKipcbiAqIFR1cyByZXN1bWFibGUgZmlsZSB1cGxvYWRlclxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFR1cyBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwcHl9IHVwcHlcbiAgICogQHBhcmFtIHtUdXNPcHRpb25zfSBvcHRzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy50eXBlID0gJ3VwbG9hZGVyJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1R1cydcbiAgICB0aGlzLnRpdGxlID0gJ1R1cydcblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGF1dG9SZXRyeTogdHJ1ZSxcbiAgICAgIHJlc3VtZTogdHJ1ZSxcbiAgICAgIHVzZUZhc3RSZW1vdGVSZXRyeTogdHJ1ZSxcbiAgICAgIGxpbWl0OiAwLFxuICAgICAgcmV0cnlEZWxheXM6IFswLCAxMDAwLCAzMDAwLCA1MDAwXSxcbiAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgfVxuXG4gICAgLy8gbWVyZ2UgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIG9uZXMgc2V0IGJ5IHVzZXJcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uXCIpLlR1c09wdGlvbnN9ICovXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICAvKipcbiAgICAgKiBTaW11bHRhbmVvdXMgdXBsb2FkIGxpbWl0aW5nIGlzIHNoYXJlZCBhY3Jvc3MgYWxsIHVwbG9hZHMgd2l0aCB0aGlzIHBsdWdpbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtSYXRlTGltaXRlZFF1ZXVlfVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdHMgPSBuZXcgUmF0ZUxpbWl0ZWRRdWV1ZSh0aGlzLm9wdHMubGltaXQpXG5cbiAgICB0aGlzLnVwbG9hZGVycyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB0aGlzLnVwbG9hZGVyRXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIHRoaXMudXBsb2FkZXJTb2NrZXRzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgdGhpcy5oYW5kbGVSZXNldFByb2dyZXNzID0gdGhpcy5oYW5kbGVSZXNldFByb2dyZXNzLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZVVwbG9hZCA9IHRoaXMuaGFuZGxlVXBsb2FkLmJpbmQodGhpcylcbiAgfVxuXG4gIGhhbmRsZVJlc2V0UHJvZ3Jlc3MgKCkge1xuICAgIGNvbnN0IGZpbGVzID0geyAuLi50aGlzLnVwcHkuZ2V0U3RhdGUoKS5maWxlcyB9XG4gICAgT2JqZWN0LmtleXMoZmlsZXMpLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgLy8gT25seSBjbG9uZSB0aGUgZmlsZSBvYmplY3QgaWYgaXQgaGFzIGEgVHVzIGB1cGxvYWRVcmxgIGF0dGFjaGVkLlxuICAgICAgaWYgKGZpbGVzW2ZpbGVJRF0udHVzICYmIGZpbGVzW2ZpbGVJRF0udHVzLnVwbG9hZFVybCkge1xuICAgICAgICBjb25zdCB0dXNTdGF0ZSA9IHsgLi4uZmlsZXNbZmlsZUlEXS50dXMgfVxuICAgICAgICBkZWxldGUgdHVzU3RhdGUudXBsb2FkVXJsXG4gICAgICAgIGZpbGVzW2ZpbGVJRF0gPSB7IC4uLmZpbGVzW2ZpbGVJRF0sIHR1czogdHVzU3RhdGUgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLnVwcHkuc2V0U3RhdGUoeyBmaWxlcyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFsbCByZWZlcmVuY2VzIGZvciBhIGZpbGUncyB1cGxvYWQ6IHRoZSB0dXMuVXBsb2FkIGluc3RhbmNlLFxuICAgKiBhbnkgZXZlbnRzIHJlbGF0ZWQgdG8gdGhlIGZpbGUsIGFuZCB0aGUgQ29tcGFuaW9uIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEXG4gICAqL1xuICByZXNldFVwbG9hZGVyUmVmZXJlbmNlcyAoZmlsZUlELCBvcHRzID0ge30pIHtcbiAgICBpZiAodGhpcy51cGxvYWRlcnNbZmlsZUlEXSkge1xuICAgICAgY29uc3QgdXBsb2FkZXIgPSB0aGlzLnVwbG9hZGVyc1tmaWxlSURdXG4gICAgICB1cGxvYWRlci5hYm9ydCgpXG4gICAgICBpZiAob3B0cy5hYm9ydCkge1xuICAgICAgICAvLyB0byBhdm9pZCA0MjMgZXJyb3IgZnJvbSB0dXMgc2VydmVyLCB3ZSB3YWl0XG4gICAgICAgIC8vIHRvIGJlIHN1cmUgdGhlIHByZXZpb3VzIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCBiZWZvcmUgdGVybWluYXRpbmcgdGhlIHVwbG9hZFxuICAgICAgICAvLyBAdG9kbyByZW1vdmUgdGhlIHRpbWVvdXQgd2hlbiB0aGlzIFwid2FpdFwiIGlzIGhhbmRsZWQgaW4gdHVzLWpzLWNsaWVudCBpbnRlcm5hbGx5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdXBsb2FkZXIuYWJvcnQodHJ1ZSksIDEwMDApXG4gICAgICB9XG4gICAgICB0aGlzLnVwbG9hZGVyc1tmaWxlSURdID0gbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdKSB7XG4gICAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0ucmVtb3ZlKClcbiAgICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXSA9IG51bGxcbiAgICB9XG4gICAgaWYgKHRoaXMudXBsb2FkZXJTb2NrZXRzW2ZpbGVJRF0pIHtcbiAgICAgIHRoaXMudXBsb2FkZXJTb2NrZXRzW2ZpbGVJRF0uY2xvc2UoKVxuICAgICAgdGhpcy51cGxvYWRlclNvY2tldHNbZmlsZUlEXSA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFR1cyB1cGxvYWQuXG4gICAqXG4gICAqIEEgbG90IGNhbiBoYXBwZW4gZHVyaW5nIGFuIHVwbG9hZCwgc28gdGhpcyBpcyBxdWl0ZSBoYXJkIHRvIGZvbGxvdyFcbiAgICogLSBGaXJzdCwgdGhlIHVwbG9hZCBpcyBzdGFydGVkLiBJZiB0aGUgZmlsZSB3YXMgYWxyZWFkeSBwYXVzZWQgYnkgdGhlIHRpbWUgdGhlIHVwbG9hZCBzdGFydHMsIG5vdGhpbmcgc2hvdWxkIGhhcHBlbi5cbiAgICogICBJZiB0aGUgYGxpbWl0YCBvcHRpb24gaXMgdXNlZCwgdGhlIHVwbG9hZCBtdXN0IGJlIHF1ZXVlZCBvbnRvIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUuXG4gICAqICAgV2hlbiBhbiB1cGxvYWQgc3RhcnRzLCB3ZSBzdG9yZSB0aGUgdHVzLlVwbG9hZCBpbnN0YW5jZSwgYW5kIGFuIEV2ZW50VHJhY2tlciBpbnN0YW5jZSB0aGF0IG1hbmFnZXMgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgKiAgIGZvciBwYXVzaW5nLCBjYW5jZWxsYXRpb24sIHJlbW92YWwsIGV0Yy5cbiAgICogLSBXaGlsZSB0aGUgdXBsb2FkIGlzIGluIHByb2dyZXNzLCBpdCBtYXkgYmUgcGF1c2VkIG9yIGNhbmNlbGxlZC5cbiAgICogICBQYXVzaW5nIGFib3J0cyB0aGUgdW5kZXJseWluZyB0dXMuVXBsb2FkLCBhbmQgcmVtb3ZlcyB0aGUgdXBsb2FkIGZyb20gdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZS4gQWxsIG90aGVyIHN0YXRlIGlzXG4gICAqICAgbWFpbnRhaW5lZC5cbiAgICogICBDYW5jZWxsaW5nIHJlbW92ZXMgdGhlIHVwbG9hZCBmcm9tIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUsIGFuZCBjb21wbGV0ZWx5IGFib3J0cyB0aGUgdXBsb2FkLS10aGUgdHVzLlVwbG9hZCBpbnN0YW5jZVxuICAgKiAgIGlzIGFib3J0ZWQgYW5kIGRpc2NhcmRlZCwgdGhlIEV2ZW50VHJhY2tlciBpbnN0YW5jZSBpcyBkZXN0cm95ZWQgKHJlbW92aW5nIGFsbCBsaXN0ZW5lcnMpLlxuICAgKiAgIFJlc3VtaW5nIHRoZSB1cGxvYWQgdXNlcyB0aGUgYHRoaXMucmVxdWVzdHNgIHF1ZXVlIGFzIHdlbGwsIHRvIHByZXZlbnQgc2VsZWN0aXZlbHkgcGF1c2luZyBhbmQgcmVzdW1pbmcgdXBsb2FkcyBmcm9tXG4gICAqICAgYnlwYXNzaW5nIHRoZSBsaW1pdC5cbiAgICogLSBBZnRlciBjb21wbGV0aW5nIGFuIHVwbG9hZCwgdGhlIHR1cy5VcGxvYWQgYW5kIEV2ZW50VHJhY2tlciBpbnN0YW5jZXMgYXJlIGNsZWFuZWQgdXAsIGFuZCB0aGUgdXBsb2FkIGlzIG1hcmtlZCBhcyBkb25lXG4gICAqICAgaW4gdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZS5cbiAgICogLSBXaGVuIGFuIHVwbG9hZCBjb21wbGV0ZWQgd2l0aCBhbiBlcnJvciwgdGhlIHNhbWUgaGFwcGVucyBhcyBvbiBzdWNjZXNzZnVsIGNvbXBsZXRpb24sIGJ1dCB0aGUgYHVwbG9hZCgpYCBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKlxuICAgKiBXaGVuIHdvcmtpbmcgb24gdGhpcyBmdW5jdGlvbiwga2VlcCBpbiBtaW5kOlxuICAgKiAgLSBXaGVuIGFuIHVwbG9hZCBpcyBjb21wbGV0ZWQgb3IgY2FuY2VsbGVkIGZvciBhbnkgcmVhc29uLCB0aGUgdHVzLlVwbG9hZCBhbmQgRXZlbnRUcmFja2VyIGluc3RhbmNlcyBuZWVkIHRvIGJlIGNsZWFuZWQgdXAgdXNpbmcgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcygpLlxuICAgKiAgLSBXaGVuIGFuIHVwbG9hZCBpcyBjYW5jZWxsZWQgb3IgcGF1c2VkLCBmb3IgYW55IHJlYXNvbiwgaXQgbmVlZHMgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUgdXNpbmcgYHF1ZXVlZFJlcXVlc3QuYWJvcnQoKWAuXG4gICAqICAtIFdoZW4gYW4gdXBsb2FkIGlzIGNvbXBsZXRlZCBmb3IgYW55IHJlYXNvbiwgaW5jbHVkaW5nIGVycm9ycywgaXQgbmVlZHMgdG8gYmUgbWFya2VkIGFzIHN1Y2ggdXNpbmcgYHF1ZXVlZFJlcXVlc3QuZG9uZSgpYC5cbiAgICogIC0gV2hlbiBhbiB1cGxvYWQgaXMgc3RhcnRlZCBvciByZXN1bWVkLCBpdCBuZWVkcyB0byBnbyB0aHJvdWdoIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUuIFRoZSBgcXVldWVkUmVxdWVzdGAgdmFyaWFibGUgbXVzdCBiZSB1cGRhdGVkIHNvIHRoZSBvdGhlciB1c2VzIG9mIGl0IGFyZSB2YWxpZC5cbiAgICogIC0gQmVmb3JlIHJlcGxhY2luZyB0aGUgYHF1ZXVlZFJlcXVlc3RgIHZhcmlhYmxlLCB0aGUgcHJldmlvdXMgYHF1ZXVlZFJlcXVlc3RgIG11c3QgYmUgYWJvcnRlZCwgZWxzZSBpdCB3aWxsIGtlZXAgdGFraW5nIHVwIGEgc3BvdCBpbiB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBweUZpbGV9IGZpbGUgZm9yIHVzZSB3aXRoIHVwbG9hZFxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudCBmaWxlIGluIGEgcXVldWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsIG51bWJlciBvZiBmaWxlcyBpbiBhIHF1ZXVlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgdXBsb2FkIChmaWxlLCBjdXJyZW50LCB0b3RhbCkge1xuICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcblxuICAgIC8vIENyZWF0ZSBhIG5ldyB0dXMgdXBsb2FkXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtc3RhcnRlZCcsIGZpbGUpXG5cbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgLi4uKGZpbGUudHVzIHx8IHt9KSxcbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHtSYXdUdXNPcHRpb25zfSAqL1xuICAgICAgY29uc3QgdXBsb2FkT3B0aW9ucyA9IHtcbiAgICAgICAgLi4udHVzRGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIC8vIFRPRE8gb25seSBwdXQgdHVzLXNwZWNpZmljIG9wdGlvbnMgaW4/XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB1cGxvYWRPcHRpb25zLnJlc3VtZVxuXG4gICAgICAvLyBNYWtlIGByZXN1bWU6IHRydWVgIHdvcmsgbGlrZSBpdCBkaWQgaW4gdHVzLWpzLWNsaWVudCB2MS5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSBpbiBAdXBweS90dXMgdjJcbiAgICAgIGlmIChvcHRzLnJlc3VtZSkge1xuICAgICAgICB1cGxvYWRPcHRpb25zLnN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgLy8gV2Ugb3ZlcnJpZGUgdHVzIGZpbmdlcnByaW50IHRvIHVwcHnigJlzIGBmaWxlLmlkYCwgc2luY2UgdGhlIGBmaWxlLmlkYFxuICAgICAgLy8gbm93IGFsc28gaW5jbHVkZXMgYHJlbGF0aXZlUGF0aGAgZm9yIGZpbGVzIGFkZGVkIGZyb20gZm9sZGVycy5cbiAgICAgIC8vIFRoaXMgbWVhbnMgeW91IGNhbiBhZGQgMiBpZGVudGljYWwgZmlsZXMsIGlmIG9uZSBpcyBpbiBmb2xkZXIgYSxcbiAgICAgIC8vIHRoZSBvdGhlciBpbiBmb2xkZXIgYi5cbiAgICAgIHVwbG9hZE9wdGlvbnMuZmluZ2VycHJpbnQgPSBnZXRGaW5nZXJwcmludChmaWxlKVxuXG4gICAgICB1cGxvYWRPcHRpb25zLm9uQmVmb3JlUmVxdWVzdCA9IChyZXEpID0+IHtcbiAgICAgICAgY29uc3QgeGhyID0gcmVxLmdldFVuZGVybHlpbmdPYmplY3QoKVxuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRzLndpdGhDcmVkZW50aWFsc1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5vbkJlZm9yZVJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvcHRzLm9uQmVmb3JlUmVxdWVzdChyZXEpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXBsb2FkT3B0aW9ucy5vbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKGVycilcblxuICAgICAgICBjb25zdCB4aHIgPSBlcnIub3JpZ2luYWxSZXF1ZXN0ID8gZXJyLm9yaWdpbmFsUmVxdWVzdC5nZXRVbmRlcmx5aW5nT2JqZWN0KCkgOiBudWxsXG4gICAgICAgIGlmIChpc05ldHdvcmtFcnJvcih4aHIpKSB7XG4gICAgICAgICAgZXJyID0gbmV3IE5ldHdvcmtFcnJvcihlcnIsIHhocilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgcXVldWVkUmVxdWVzdC5kb25lKClcblxuICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLWVycm9yJywgZmlsZSwgZXJyKVxuXG4gICAgICAgIHJlamVjdChlcnIpXG4gICAgICB9XG5cbiAgICAgIHVwbG9hZE9wdGlvbnMub25Qcm9ncmVzcyA9IChieXRlc1VwbG9hZGVkLCBieXRlc1RvdGFsKSA9PiB7XG4gICAgICAgIHRoaXMub25SZWNlaXZlVXBsb2FkVXJsKGZpbGUsIHVwbG9hZC51cmwpXG4gICAgICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtcHJvZ3Jlc3MnLCBmaWxlLCB7XG4gICAgICAgICAgdXBsb2FkZXI6IHRoaXMsXG4gICAgICAgICAgYnl0ZXNVcGxvYWRlZCxcbiAgICAgICAgICBieXRlc1RvdGFsLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB1cGxvYWRPcHRpb25zLm9uU3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdXBsb2FkUmVzcCA9IHtcbiAgICAgICAgICB1cGxvYWRVUkw6IHVwbG9hZC51cmwsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKGZpbGUuaWQpXG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuZG9uZSgpXG5cbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1zdWNjZXNzJywgZmlsZSwgdXBsb2FkUmVzcClcblxuICAgICAgICBpZiAodXBsb2FkLnVybCkge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coYERvd25sb2FkICR7dXBsb2FkLmZpbGUubmFtZX0gZnJvbSAke3VwbG9hZC51cmx9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUodXBsb2FkKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjb3B5UHJvcCA9IChvYmosIHNyY1Byb3AsIGRlc3RQcm9wKSA9PiB7XG4gICAgICAgIGlmIChoYXNQcm9wZXJ0eShvYmosIHNyY1Byb3ApICYmICFoYXNQcm9wZXJ0eShvYmosIGRlc3RQcm9wKSkge1xuICAgICAgICAgIG9ialtkZXN0UHJvcF0gPSBvYmpbc3JjUHJvcF1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgICBjb25zdCBtZXRhID0ge31cbiAgICAgIGNvbnN0IG1ldGFGaWVsZHMgPSBBcnJheS5pc0FycmF5KG9wdHMubWV0YUZpZWxkcylcbiAgICAgICAgPyBvcHRzLm1ldGFGaWVsZHNcbiAgICAgICAgLy8gU2VuZCBhbG9uZyBhbGwgZmllbGRzIGJ5IGRlZmF1bHQuXG4gICAgICAgIDogT2JqZWN0LmtleXMoZmlsZS5tZXRhKVxuICAgICAgbWV0YUZpZWxkcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIG1ldGFbaXRlbV0gPSBmaWxlLm1ldGFbaXRlbV1cbiAgICAgIH0pXG5cbiAgICAgIC8vIHR1c2QgdXNlcyBtZXRhZGF0YSBmaWVsZHMgJ2ZpbGV0eXBlJyBhbmQgJ2ZpbGVuYW1lJ1xuICAgICAgY29weVByb3AobWV0YSwgJ3R5cGUnLCAnZmlsZXR5cGUnKVxuICAgICAgY29weVByb3AobWV0YSwgJ25hbWUnLCAnZmlsZW5hbWUnKVxuXG4gICAgICB1cGxvYWRPcHRpb25zLm1ldGFkYXRhID0gbWV0YVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLmRhdGEsIHVwbG9hZE9wdGlvbnMpXG4gICAgICB0aGlzLnVwbG9hZGVyc1tmaWxlLmlkXSA9IHVwbG9hZFxuICAgICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlLmlkXSA9IG5ldyBFdmVudFRyYWNrZXIodGhpcy51cHB5KVxuXG4gICAgICAvLyBNYWtlIGByZXN1bWU6IHRydWVgIHdvcmsgbGlrZSBpdCBkaWQgaW4gdHVzLWpzLWNsaWVudCB2MS5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSBpbiBAdXBweS90dXMgdjIuXG4gICAgICBpZiAob3B0cy5yZXN1bWUpIHtcbiAgICAgICAgdXBsb2FkLmZpbmRQcmV2aW91c1VwbG9hZHMoKS50aGVuKChwcmV2aW91c1VwbG9hZHMpID0+IHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91c1VwbG9hZCA9IHByZXZpb3VzVXBsb2Fkc1swXVxuICAgICAgICAgIGlmIChwcmV2aW91c1VwbG9hZCkge1xuICAgICAgICAgICAgdGhpcy51cHB5LmxvZyhgW1R1c10gUmVzdW1pbmcgdXBsb2FkIG9mICR7ZmlsZS5pZH0gc3RhcnRlZCBhdCAke3ByZXZpb3VzVXBsb2FkLmNyZWF0aW9uVGltZX1gKVxuICAgICAgICAgICAgdXBsb2FkLnJlc3VtZUZyb21QcmV2aW91c1VwbG9hZChwcmV2aW91c1VwbG9hZClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGxldCBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICBpZiAoIWZpbGUuaXNQYXVzZWQpIHtcbiAgICAgICAgICAvLyBFbnN1cmUgdGhpcyBnZXRzIHNjaGVkdWxlZCB0byBydW4gX2FmdGVyXyBgZmluZFByZXZpb3VzVXBsb2FkcygpYCByZXR1cm5zLlxuICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBpbiBAdXBweS90dXMgdjIuXG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB1cGxvYWQuc3RhcnQoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaGVyZSwgdGhlIGNhbGxlciB3aWxsIHRha2UgY2FyZSBvZiBjYW5jZWxsaW5nIHRoZSB1cGxvYWQgaXRzZWxmXG4gICAgICAgIC8vIHVzaW5nIHJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKCkuIFRoaXMgaXMgYmVjYXVzZSByZXNldFVwbG9hZGVyUmVmZXJlbmNlcygpIGhhcyB0byBiZVxuICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGlzIHJlcXVlc3QgaXMgc3RpbGwgaW4gdGhlIHF1ZXVlLCBhbmQgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgeWV0LCB0b28uIEF0XG4gICAgICAgIC8vIHRoYXQgcG9pbnQgdGhpcyBjYW5jZWxsYXRpb24gZnVuY3Rpb24gaXMgbm90IGdvaW5nIHRvIGJlIGNhbGxlZC5cbiAgICAgICAgLy8gQWxzbywgd2UgbmVlZCB0byByZW1vdmUgdGhlIHJlcXVlc3QgZnJvbSB0aGUgcXVldWUgX3dpdGhvdXRfIGRlc3Ryb3lpbmcgZXZlcnl0aGluZ1xuICAgICAgICAvLyByZWxhdGVkIHRvIHRoaXMgdXBsb2FkIHRvIGhhbmRsZSBwYXVzZXMuXG4gICAgICAgIHJldHVybiAoKSA9PiB7fVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vbkZpbGVSZW1vdmUoZmlsZS5pZCwgKHRhcmdldEZpbGVJRCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkLCB7IGFib3J0OiAhIXVwbG9hZC51cmwgfSlcbiAgICAgICAgcmVzb2x2ZShgdXBsb2FkICR7dGFyZ2V0RmlsZUlEfSB3YXMgcmVtb3ZlZGApXG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uUGF1c2UoZmlsZS5pZCwgKGlzUGF1c2VkKSA9PiB7XG4gICAgICAgIGlmIChpc1BhdXNlZCkge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGZpbGUgZnJvbSB0aGUgcXVldWUgc28gYW5vdGhlciBmaWxlIGNhbiBzdGFydCBpbiBpdHMgcGxhY2UuXG4gICAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgICAgdXBsb2FkLmFib3J0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZXN1bWluZyBhbiB1cGxvYWQgc2hvdWxkIGJlIHF1ZXVlZCwgZWxzZSB5b3UgY291bGQgcGF1c2UgYW5kIHRoZW4gcmVzdW1lIGEgcXVldWVkIHVwbG9hZCB0byBtYWtlIGl0IHNraXAgdGhlIHF1ZXVlLlxuICAgICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICAgIHF1ZXVlZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB1cGxvYWQuc3RhcnQoKVxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vblBhdXNlQWxsKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIHVwbG9hZC5hYm9ydCgpXG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uQ2FuY2VsQWxsKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZCwgeyBhYm9ydDogISF1cGxvYWQudXJsIH0pXG4gICAgICAgIHJlc29sdmUoYHVwbG9hZCAke2ZpbGUuaWR9IHdhcyBjYW5jZWxlZGApXG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uUmVzdW1lQWxsKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIGlmIChmaWxlLmVycm9yKSB7XG4gICAgICAgICAgdXBsb2FkLmFib3J0KClcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICAgIHVwbG9hZC5zdGFydCgpXG4gICAgICAgICAgcmV0dXJuICgpID0+IHt9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtZXJyb3InLCBmaWxlLCBlcnIpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBweUZpbGV9IGZpbGUgZm9yIHVzZSB3aXRoIHVwbG9hZFxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudCBmaWxlIGluIGEgcXVldWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsIG51bWJlciBvZiBmaWxlcyBpbiBhIHF1ZXVlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgdXBsb2FkUmVtb3RlIChmaWxlLCBjdXJyZW50LCB0b3RhbCkge1xuICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcblxuICAgIGNvbnN0IG9wdHMgPSB7IC4uLnRoaXMub3B0cyB9XG4gICAgaWYgKGZpbGUudHVzKSB7XG4gICAgICAvLyBJbnN0YWxsIGZpbGUtc3BlY2lmaWMgdXBsb2FkIG92ZXJyaWRlcy5cbiAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgZmlsZS50dXMpXG4gICAgfVxuXG4gICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1zdGFydGVkJywgZmlsZSlcbiAgICB0aGlzLnVwcHkubG9nKGZpbGUucmVtb3RlLnVybClcblxuICAgIGlmIChmaWxlLnNlcnZlclRva2VuKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0VG9TZXJ2ZXJTb2NrZXQoZmlsZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgQ2xpZW50ID0gZmlsZS5yZW1vdGUucHJvdmlkZXJPcHRpb25zLnByb3ZpZGVyID8gUHJvdmlkZXIgOiBSZXF1ZXN0Q2xpZW50XG4gICAgICBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KHRoaXMudXBweSwgZmlsZS5yZW1vdGUucHJvdmlkZXJPcHRpb25zKVxuXG4gICAgICAvLyAhISBjYW5jZWxsYXRpb24gaXMgTk9UIHN1cHBvcnRlZCBhdCB0aGlzIHN0YWdlIHlldFxuICAgICAgY2xpZW50LnBvc3QoZmlsZS5yZW1vdGUudXJsLCB7XG4gICAgICAgIC4uLmZpbGUucmVtb3RlLmJvZHksXG4gICAgICAgIGVuZHBvaW50OiBvcHRzLmVuZHBvaW50LFxuICAgICAgICB1cGxvYWRVcmw6IG9wdHMudXBsb2FkVXJsLFxuICAgICAgICBwcm90b2NvbDogJ3R1cycsXG4gICAgICAgIHNpemU6IGZpbGUuZGF0YS5zaXplLFxuICAgICAgICBoZWFkZXJzOiBvcHRzLmhlYWRlcnMsXG4gICAgICAgIG1ldGFkYXRhOiBmaWxlLm1ldGEsXG4gICAgICB9KS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LnNldEZpbGVTdGF0ZShmaWxlLmlkLCB7IHNlcnZlclRva2VuOiByZXMudG9rZW4gfSlcbiAgICAgICAgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGUuaWQpXG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RUb1NlcnZlclNvY2tldChmaWxlKVxuICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLWVycm9yJywgZmlsZSwgZXJyKVxuICAgICAgICByZWplY3QoZXJyKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNlZSB0aGUgY29tbWVudCBvbiB0aGUgdXBsb2FkKCkgbWV0aG9kLlxuICAgKlxuICAgKiBBZGRpdGlvbmFsbHksIHdoZW4gYW4gdXBsb2FkIGlzIHJlbW92ZWQsIGNvbXBsZXRlZCwgb3IgY2FuY2VsbGVkLCB3ZSBuZWVkIHRvIGNsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi4gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSByZXNldFVwbG9hZGVyUmVmZXJlbmNlcygpIGZ1bmN0aW9uLCBzbyB0aGUgc2FtZSBndWlkZWxpbmVzIGFwcGx5IGFzIGluIHVwbG9hZCgpLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwcHlGaWxlfSBmaWxlXG4gICAqL1xuICBjb25uZWN0VG9TZXJ2ZXJTb2NrZXQgKGZpbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW4gPSBmaWxlLnNlcnZlclRva2VuXG4gICAgICBjb25zdCBob3N0ID0gZ2V0U29ja2V0SG9zdChmaWxlLnJlbW90ZS5jb21wYW5pb25VcmwpXG4gICAgICBjb25zdCBzb2NrZXQgPSBuZXcgU29ja2V0KHsgdGFyZ2V0OiBgJHtob3N0fS9hcGkvJHt0b2tlbn1gLCBhdXRvT3BlbjogZmFsc2UgfSlcbiAgICAgIHRoaXMudXBsb2FkZXJTb2NrZXRzW2ZpbGUuaWRdID0gc29ja2V0XG4gICAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGUuaWRdID0gbmV3IEV2ZW50VHJhY2tlcih0aGlzLnVwcHkpXG5cbiAgICAgIHRoaXMub25GaWxlUmVtb3ZlKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIC8vIHN0aWxsIHNlbmQgcGF1c2UgZXZlbnQgaW4gY2FzZSB3ZSBhcmUgZGVhbGluZyB3aXRoIG9sZGVyIHZlcnNpb24gb2YgY29tcGFuaW9uXG4gICAgICAgIC8vIEB0b2RvIGRvbid0IHNlbmQgcGF1c2UgZXZlbnQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgc29ja2V0LnNlbmQoJ3BhdXNlJywge30pXG4gICAgICAgIHNvY2tldC5zZW5kKCdjYW5jZWwnLCB7fSlcbiAgICAgICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkKVxuICAgICAgICByZXNvbHZlKGB1cGxvYWQgJHtmaWxlLmlkfSB3YXMgcmVtb3ZlZGApXG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uUGF1c2UoZmlsZS5pZCwgKGlzUGF1c2VkKSA9PiB7XG4gICAgICAgIGlmIChpc1BhdXNlZCkge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGZpbGUgZnJvbSB0aGUgcXVldWUgc28gYW5vdGhlciBmaWxlIGNhbiBzdGFydCBpbiBpdHMgcGxhY2UuXG4gICAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgICAgc29ja2V0LnNlbmQoJ3BhdXNlJywge30pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVzdW1pbmcgYW4gdXBsb2FkIHNob3VsZCBiZSBxdWV1ZWQsIGVsc2UgeW91IGNvdWxkIHBhdXNlIGFuZCB0aGVuIHJlc3VtZSBhIHF1ZXVlZCB1cGxvYWQgdG8gbWFrZSBpdCBza2lwIHRoZSBxdWV1ZS5cbiAgICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgICBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LnNlbmQoJ3Jlc3VtZScsIHt9KVxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vblBhdXNlQWxsKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vbkNhbmNlbEFsbChmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICAvLyBzdGlsbCBzZW5kIHBhdXNlIGV2ZW50IGluIGNhc2Ugd2UgYXJlIGRlYWxpbmcgd2l0aCBvbGRlciB2ZXJzaW9uIG9mIGNvbXBhbmlvblxuICAgICAgICAvLyBAdG9kbyBkb24ndCBzZW5kIHBhdXNlIGV2ZW50IGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgICBzb2NrZXQuc2VuZCgnY2FuY2VsJywge30pXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgcmVzb2x2ZShgdXBsb2FkICR7ZmlsZS5pZH0gd2FzIGNhbmNlbGVkYClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXN1bWVBbGwoZmlsZS5pZCwgKCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgaWYgKGZpbGUuZXJyb3IpIHtcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICAgIHNvY2tldC5zZW5kKCdyZXN1bWUnLCB7fSlcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge31cbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXRyeShmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIC8vIE9ubHkgZG8gdGhlIHJldHJ5IGlmIHRoZSB1cGxvYWQgaXMgYWN0dWFsbHkgaW4gcHJvZ3Jlc3M7XG4gICAgICAgIC8vIGVsc2Ugd2UgY291bGQgdHJ5IHRvIHNlbmQgdGhlc2UgbWVzc2FnZXMgd2hlbiB0aGUgdXBsb2FkIGlzIHN0aWxsIHF1ZXVlZC5cbiAgICAgICAgLy8gV2UgbWF5IG5lZWQgYSBiZXR0ZXIgY2hlY2sgZm9yIHRoaXMgc2luY2UgdGhlIHNvY2tldCBtYXkgYWxzbyBiZSBjbG9zZWRcbiAgICAgICAgLy8gZm9yIG90aGVyIHJlYXNvbnMsIGxpa2UgbmV0d29yayBmYWlsdXJlcy5cbiAgICAgICAgaWYgKHNvY2tldC5pc09wZW4pIHtcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncmVzdW1lJywge30pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXRyeUFsbChmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgb25SZXRyeSgpIGNhbGxcbiAgICAgICAgaWYgKHNvY2tldC5pc09wZW4pIHtcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncmVzdW1lJywge30pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbigncHJvZ3Jlc3MnLCAocHJvZ3Jlc3NEYXRhKSA9PiBlbWl0U29ja2V0UHJvZ3Jlc3ModGhpcywgcHJvZ3Jlc3NEYXRhLCBmaWxlKSlcblxuICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIChlcnJEYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gZXJyRGF0YS5lcnJvclxuICAgICAgICBjb25zdCBlcnJvciA9IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKG1lc3NhZ2UpLCB7IGNhdXNlOiBlcnJEYXRhLmVycm9yIH0pXG5cbiAgICAgICAgLy8gSWYgdGhlIHJlbW90ZSByZXRyeSBvcHRpbWlzYXRpb24gc2hvdWxkIG5vdCBiZSB1c2VkLFxuICAgICAgICAvLyBjbG9zZSB0aGUgc29ja2V04oCUdGhpcyB3aWxsIHRlbGwgY29tcGFuaW9uIHRvIGNsZWFyIHN0YXRlIGFuZCBkZWxldGUgdGhlIGZpbGUuXG4gICAgICAgIGlmICghdGhpcy5vcHRzLnVzZUZhc3RSZW1vdGVSZXRyeSkge1xuICAgICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlcnZlclRva2VuIHNvIHRoYXQgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZCBmb3IgdGhlIHJldHJ5LlxuICAgICAgICAgIHRoaXMudXBweS5zZXRGaWxlU3RhdGUoZmlsZS5pZCwge1xuICAgICAgICAgICAgc2VydmVyVG9rZW46IG51bGwsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb2NrZXQuY2xvc2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1lcnJvcicsIGZpbGUsIGVycm9yKVxuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmRvbmUoKVxuICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ3N1Y2Nlc3MnLCAoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCB1cGxvYWRSZXNwID0ge1xuICAgICAgICAgIHVwbG9hZFVSTDogZGF0YS51cmwsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLXN1Y2Nlc3MnLCBmaWxlLCB1cGxvYWRSZXNwKVxuICAgICAgICB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKGZpbGUuaWQpXG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuZG9uZSgpXG5cbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuXG4gICAgICBsZXQgcXVldWVkUmVxdWVzdCA9IHRoaXMucmVxdWVzdHMucnVuKCgpID0+IHtcbiAgICAgICAgc29ja2V0Lm9wZW4oKVxuICAgICAgICBpZiAoZmlsZS5pc1BhdXNlZCkge1xuICAgICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaGVyZSwgdGhlIGNhbGxlciB3aWxsIHRha2UgY2FyZSBvZiBjYW5jZWxsaW5nIHRoZSB1cGxvYWQgaXRzZWxmXG4gICAgICAgIC8vIHVzaW5nIHJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKCkuIFRoaXMgaXMgYmVjYXVzZSByZXNldFVwbG9hZGVyUmVmZXJlbmNlcygpIGhhcyB0byBiZVxuICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGlzIHJlcXVlc3QgaXMgc3RpbGwgaW4gdGhlIHF1ZXVlLCBhbmQgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgeWV0LCB0b28uIEF0XG4gICAgICAgIC8vIHRoYXQgcG9pbnQgdGhpcyBjYW5jZWxsYXRpb24gZnVuY3Rpb24gaXMgbm90IGdvaW5nIHRvIGJlIGNhbGxlZC5cbiAgICAgICAgLy8gQWxzbywgd2UgbmVlZCB0byByZW1vdmUgdGhlIHJlcXVlc3QgZnJvbSB0aGUgcXVldWUgX3dpdGhvdXRfIGRlc3Ryb3lpbmcgZXZlcnl0aGluZ1xuICAgICAgICAvLyByZWxhdGVkIHRvIHRoaXMgdXBsb2FkIHRvIGhhbmRsZSBwYXVzZXMuXG4gICAgICAgIHJldHVybiAoKSA9PiB7fVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlIHRoZSB1cGxvYWRVcmwgb24gdGhlIGZpbGUgb3B0aW9ucywgc28gdGhhdCB3aGVuIEdvbGRlbiBSZXRyaWV2ZXJcbiAgICogcmVzdG9yZXMgc3RhdGUsIHdlIHdpbGwgY29udGludWUgdXBsb2FkaW5nIHRvIHRoZSBjb3JyZWN0IFVSTC5cbiAgICpcbiAgICogQHBhcmFtIHtVcHB5RmlsZX0gZmlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXBsb2FkVVJMXG4gICAqL1xuICBvblJlY2VpdmVVcGxvYWRVcmwgKGZpbGUsIHVwbG9hZFVSTCkge1xuICAgIGNvbnN0IGN1cnJlbnRGaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZS5pZClcbiAgICBpZiAoIWN1cnJlbnRGaWxlKSByZXR1cm5cbiAgICAvLyBPbmx5IGRvIHRoZSB1cGRhdGUgaWYgd2UgZGlkbid0IGhhdmUgYW4gdXBsb2FkIFVSTCB5ZXQuXG4gICAgaWYgKCFjdXJyZW50RmlsZS50dXMgfHwgY3VycmVudEZpbGUudHVzLnVwbG9hZFVybCAhPT0gdXBsb2FkVVJMKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKCdbVHVzXSBTdG9yaW5nIHVwbG9hZCB1cmwnKVxuICAgICAgdGhpcy51cHB5LnNldEZpbGVTdGF0ZShjdXJyZW50RmlsZS5pZCwge1xuICAgICAgICB0dXM6IHsgLi4uY3VycmVudEZpbGUudHVzLCB1cGxvYWRVcmw6IHVwbG9hZFVSTCB9LFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk6IHZvaWR9IGNiXG4gICAqL1xuICBvbkZpbGVSZW1vdmUgKGZpbGVJRCwgY2IpIHtcbiAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0ub24oJ2ZpbGUtcmVtb3ZlZCcsIChmaWxlKSA9PiB7XG4gICAgICBpZiAoZmlsZUlEID09PSBmaWxlLmlkKSBjYihmaWxlLmlkKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGJvb2xlYW4pOiB2b2lkfSBjYlxuICAgKi9cbiAgb25QYXVzZSAoZmlsZUlELCBjYikge1xuICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXS5vbigndXBsb2FkLXBhdXNlJywgKHRhcmdldEZpbGVJRCwgaXNQYXVzZWQpID0+IHtcbiAgICAgIGlmIChmaWxlSUQgPT09IHRhcmdldEZpbGVJRCkge1xuICAgICAgICAvLyBjb25zdCBpc1BhdXNlZCA9IHRoaXMudXBweS5wYXVzZVJlc3VtZShmaWxlSUQpXG4gICAgICAgIGNiKGlzUGF1c2VkKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNiXG4gICAqL1xuICBvblJldHJ5IChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCd1cGxvYWQtcmV0cnknLCAodGFyZ2V0RmlsZUlEKSA9PiB7XG4gICAgICBpZiAoZmlsZUlEID09PSB0YXJnZXRGaWxlSUQpIHtcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNiXG4gICAqL1xuICBvblJldHJ5QWxsIChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCdyZXRyeS1hbGwnLCAoZmlsZXNUb1JldHJ5KSA9PiB7XG4gICAgICBpZiAoIXRoaXMudXBweS5nZXRGaWxlKGZpbGVJRCkpIHJldHVyblxuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNiXG4gICAqL1xuICBvblBhdXNlQWxsIChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCdwYXVzZS1hbGwnLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudXBweS5nZXRGaWxlKGZpbGVJRCkpIHJldHVyblxuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNiXG4gICAqL1xuICBvbkNhbmNlbEFsbCAoZmlsZUlELCBjYikge1xuICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXS5vbignY2FuY2VsLWFsbCcsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKSkgcmV0dXJuXG4gICAgICBjYigpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gY2JcbiAgICovXG4gIG9uUmVzdW1lQWxsIChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCdyZXN1bWUtYWxsJywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpKSByZXR1cm5cbiAgICAgIGNiKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KFVwcHlGaWxlIHwgRmFpbGVkVXBweUZpbGUpW119IGZpbGVzXG4gICAqL1xuICB1cGxvYWRGaWxlcyAoZmlsZXMpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IGZpbGVzLm1hcCgoZmlsZSwgaSkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGkgKyAxXG4gICAgICBjb25zdCB0b3RhbCA9IGZpbGVzLmxlbmd0aFxuXG4gICAgICBpZiAoJ2Vycm9yJyBpbiBmaWxlICYmIGZpbGUuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihmaWxlLmVycm9yKSlcbiAgICAgIH0gaWYgKGZpbGUuaXNSZW1vdGUpIHtcbiAgICAgICAgLy8gV2UgZW1pdCB1cGxvYWQtc3RhcnRlZCBoZXJlLCBzbyB0aGF0IGl0J3MgYWxzbyBlbWl0dGVkIGZvciBmaWxlc1xuICAgICAgICAvLyB0aGF0IGhhdmUgdG8gd2FpdCBkdWUgdG8gdGhlIGBsaW1pdGAgb3B0aW9uLlxuICAgICAgICAvLyBEb24ndCBkb3VibGUtZW1pdCB1cGxvYWQtc3RhcnRlZCBmb3IgR29sZGVuIFJldHJpZXZlci1yZXN0b3JlZCBmaWxlcyB0aGF0IHdlcmUgYWxyZWFkeSBzdGFydGVkXG4gICAgICAgIGlmICghZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkIHx8ICFmaWxlLmlzUmVzdG9yZWQpIHtcbiAgICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLXN0YXJ0ZWQnLCBmaWxlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVwbG9hZFJlbW90ZShmaWxlLCBjdXJyZW50LCB0b3RhbClcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IGRvdWJsZS1lbWl0IHVwbG9hZC1zdGFydGVkIGZvciBHb2xkZW4gUmV0cmlldmVyLXJlc3RvcmVkIGZpbGVzIHRoYXQgd2VyZSBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIGlmICghZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkIHx8ICFmaWxlLmlzUmVzdG9yZWQpIHtcbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1zdGFydGVkJywgZmlsZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnVwbG9hZChmaWxlLCBjdXJyZW50LCB0b3RhbClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHNldHRsZShwcm9taXNlcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWxlSURzXG4gICAqL1xuICBoYW5kbGVVcGxvYWQgKGZpbGVJRHMpIHtcbiAgICBpZiAoZmlsZUlEcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tUdXNdIE5vIGZpbGVzIHRvIHVwbG9hZCcpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmxpbWl0ID09PSAwKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKFxuICAgICAgICAnW1R1c10gV2hlbiB1cGxvYWRpbmcgbXVsdGlwbGUgZmlsZXMgYXQgb25jZSwgY29uc2lkZXIgc2V0dGluZyB0aGUgYGxpbWl0YCBvcHRpb24gKHRvIGAxMGAgZm9yIGV4YW1wbGUpLCB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgdXBsb2Fkcywgd2hpY2ggaGVscHMgcHJldmVudCBtZW1vcnkgYW5kIG5ldHdvcmsgaXNzdWVzOiBodHRwczovL3VwcHkuaW8vZG9jcy90dXMvI2xpbWl0LTAnLFxuICAgICAgICAnd2FybmluZydcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLnVwcHkubG9nKCdbVHVzXSBVcGxvYWRpbmcuLi4nKVxuICAgIGNvbnN0IGZpbGVzVG9VcGxvYWQgPSBmaWxlSURzLm1hcCgoZmlsZUlEKSA9PiB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpKVxuXG4gICAgcmV0dXJuIHRoaXMudXBsb2FkRmlsZXMoZmlsZXNUb1VwbG9hZClcbiAgICAgIC50aGVuKCgpID0+IG51bGwpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnVwcHkuc2V0U3RhdGUoe1xuICAgICAgY2FwYWJpbGl0aWVzOiB7IC4uLnRoaXMudXBweS5nZXRTdGF0ZSgpLmNhcGFiaWxpdGllcywgcmVzdW1hYmxlVXBsb2FkczogdHJ1ZSB9LFxuICAgIH0pXG4gICAgdGhpcy51cHB5LmFkZFVwbG9hZGVyKHRoaXMuaGFuZGxlVXBsb2FkKVxuXG4gICAgdGhpcy51cHB5Lm9uKCdyZXNldC1wcm9ncmVzcycsIHRoaXMuaGFuZGxlUmVzZXRQcm9ncmVzcylcblxuICAgIGlmICh0aGlzLm9wdHMuYXV0b1JldHJ5KSB7XG4gICAgICB0aGlzLnVwcHkub24oJ2JhY2stb25saW5lJywgdGhpcy51cHB5LnJldHJ5QWxsKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgIGNhcGFiaWxpdGllczogeyAuLi50aGlzLnVwcHkuZ2V0U3RhdGUoKS5jYXBhYmlsaXRpZXMsIHJlc3VtYWJsZVVwbG9hZHM6IGZhbHNlIH0sXG4gICAgfSlcbiAgICB0aGlzLnVwcHkucmVtb3ZlVXBsb2FkZXIodGhpcy5oYW5kbGVVcGxvYWQpXG5cbiAgICBpZiAodGhpcy5vcHRzLmF1dG9SZXRyeSkge1xuICAgICAgdGhpcy51cHB5Lm9mZignYmFjay1vbmxpbmUnLCB0aGlzLnVwcHkucmV0cnlBbGwpXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L3VybFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIFVybCBwbHVnaW4gbGV0cyB1c2VycyBpbXBvcnQgZmlsZXMgZnJvbSB0aGUgSW50ZXJuZXQuIFBhc3RlIGFueSBVUkwgYW5kIGl04oCZbGwgYmUgYWRkZWQhXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuNS4yM1wiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwic3R5bGVcIjogXCJkaXN0L3N0eWxlLm1pbi5jc3NcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cmxcIixcbiAgICBcImltcG9ydCBmcm9tIHVybFwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvbXBhbmlvbi1jbGllbnRcIjogXCJmaWxlOi4uL2NvbXBhbmlvbi1jbGllbnRcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5jbGFzcyBVcmxVSSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuaGFuZGxlS2V5UHJlc3MgPSB0aGlzLmhhbmRsZUtleVByZXNzLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZUNsaWNrID0gdGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMpXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgdGhpcy5pbnB1dC52YWx1ZSA9ICcnXG4gIH1cblxuICBoYW5kbGVLZXlQcmVzcyAoZXYpIHtcbiAgICBpZiAoZXYua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIHRoaXMucHJvcHMuYWRkRmlsZSh0aGlzLmlucHV0LnZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNsaWNrICgpIHtcbiAgICB0aGlzLnByb3BzLmFkZEZpbGUodGhpcy5pbnB1dC52YWx1ZSlcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1VcmxcIj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy10ZXh0SW5wdXQgdXBweS1VcmwtaW5wdXRcIlxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBhcmlhLWxhYmVsPXt0aGlzLnByb3BzLmkxOG4oJ2VudGVyVXJsVG9JbXBvcnQnKX1cbiAgICAgICAgICBwbGFjZWhvbGRlcj17dGhpcy5wcm9wcy5pMThuKCdlbnRlclVybFRvSW1wb3J0Jyl9XG4gICAgICAgICAgb25LZXlVcD17dGhpcy5oYW5kbGVLZXlQcmVzc31cbiAgICAgICAgICByZWY9eyhpbnB1dCkgPT4geyB0aGlzLmlucHV0ID0gaW5wdXQgfX1cbiAgICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICAgIC8+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LWMtYnRuLXByaW1hcnkgdXBweS1VcmwtaW1wb3J0QnV0dG9uXCJcbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfVxuICAgICAgICA+XG4gICAgICAgICAge3RoaXMucHJvcHMuaTE4bignaW1wb3J0Jyl9XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsVUlcbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IFRyYW5zbGF0b3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvVHJhbnNsYXRvcicpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCB7IFJlcXVlc3RDbGllbnQgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgVXJsVUkgPSByZXF1aXJlKCcuL1VybFVJLmpzJylcbmNvbnN0IGZvckVhY2hEcm9wcGVkT3JQYXN0ZWRVcmwgPSByZXF1aXJlKCcuL3V0aWxzL2ZvckVhY2hEcm9wcGVkT3JQYXN0ZWRVcmwnKVxuXG5mdW5jdGlvbiBVcmxJY29uICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiPlxuICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIGZpbGw9XCIjRkY3NTNFXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjIuNzg4IDE1LjM4OWwtMi4xOTkgMi4xOWEzLjE4NCAzLjE4NCAwIDAgMS0uNTEzLjQzN2MtLjgwNi41ODQtMS42ODYuODc2LTIuNjM4Ljg3NmE0LjM3OCA0LjM3OCAwIDAgMS0zLjUxOS0xLjc1MmMtLjIyLS4yOTItLjE0Ni0uODAyLjE0Ny0xLjAyMS4yOTMtLjIyLjgwNi0uMTQ2IDEuMDI2LjE0Ni45NTMgMS4zMTMgMi43ODUgMS41MzIgNC4xMDUuNTgzYS41NzEuNTcxIDAgMCAwIC4yOTMtLjI5MmwyLjE5OS0yLjE4OWMxLjEtMS4xNjcgMS4xLTIuOTkyLS4wNzMtNC4wODZhMi45NzYgMi45NzYgMCAwIDAtNC4xMDUgMGwtMS4yNDYgMS4yNGEuNzEuNzEgMCAwIDEtMS4wMjYgMCAuNzAzLjcwMyAwIDAgMSAwLTEuMDIybDEuMjQ2LTEuMjRhNC4zMDUgNC4zMDUgMCAwIDEgNi4wODMgMGMxLjgzMyAxLjYwNSAxLjkwNiA0LjQ1MS4yMiA2LjEzem0tNy4xODMgNS4wMzVsLTEuMjQ2IDEuMjRhMi45NzYgMi45NzYgMCAwIDEtNC4xMDUgMGMtMS4xNzItMS4wOTQtMS4xNzItMi45OTEtLjA3My00LjA4NmwyLjItMi4xOS4yOTItLjI5MWMuNjYtLjQzOCAxLjM5My0uNjU3IDIuMi0uNTg0LjgwNS4xNDYgMS40NjUuNTEgMS45MDUgMS4xNjguMjIuMjkyLjczMy4zNjUgMS4wMjYuMTQ2LjI5My0uMjIuMzY3LS43My4xNDctMS4wMjItLjczMy0uOTQ5LTEuNzYtMS41MzItMi44NTktMS42NzgtMS4xLS4yMi0yLjI3Mi4wNzMtMy4yMjUuODAybC0uNDQuNDM4LTIuMTk5IDIuMTljLTEuNjg2IDEuNzUtMS42MTIgNC41MjQuMDc0IDYuMjAyLjg4LjgwMyAxLjk3OSAxLjI0MSAzLjA3OCAxLjI0MSAxLjEgMCAyLjE5OS0uNDM4IDMuMDc5LTEuMjRsMS4yNDYtMS4yNDFhLjcwMy43MDMgMCAwIDAgMC0xLjAyMmMtLjI5NC0uMjkyLS44MDctLjM2NS0xLjEtLjA3M3pcIiBmaWxsPVwiI0ZGRlwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuLyoqXG4gKiBVcmxcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVXJsIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1VybCdcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdMaW5rJ1xuICAgIHRoaXMudHlwZSA9ICdhY3F1aXJlcidcbiAgICB0aGlzLmljb24gPSAoKSA9PiA8VXJsSWNvbiAvPlxuXG4gICAgLy8gU2V0IGRlZmF1bHQgb3B0aW9ucyBhbmQgbG9jYWxlXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0ge1xuICAgICAgc3RyaW5nczoge1xuICAgICAgICBpbXBvcnQ6ICdJbXBvcnQnLFxuICAgICAgICBlbnRlclVybFRvSW1wb3J0OiAnRW50ZXIgVVJMIHRvIGltcG9ydCBhIGZpbGUnLFxuICAgICAgICBmYWlsZWRUb0ZldGNoOiAnQ29tcGFuaW9uIGZhaWxlZCB0byBmZXRjaCB0aGlzIFVSTCwgcGxlYXNlIG1ha2Ugc3VyZSBpdOKAmXMgY29ycmVjdCcsXG4gICAgICAgIGVudGVyQ29ycmVjdFVybDogJ0luY29ycmVjdCBVUkw6IFBsZWFzZSBtYWtlIHN1cmUgeW91IGFyZSBlbnRlcmluZyBhIGRpcmVjdCBsaW5rIHRvIGEgZmlsZScsXG4gICAgICB9LFxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge31cblxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgdGhpcy5pMThuSW5pdCgpXG5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5vcHRzLmNvbXBhbmlvblVybFxuXG4gICAgaWYgKCF0aGlzLmhvc3RuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBhbmlvbiBob3N0bmFtZSBpcyByZXF1aXJlZCwgcGxlYXNlIGNvbnN1bHQgaHR0cHM6Ly91cHB5LmlvL2RvY3MvY29tcGFuaW9uJylcbiAgICB9XG5cbiAgICAvLyBCaW5kIGFsbCBldmVudCBoYW5kbGVycyBmb3IgcmVmZXJlbmNhYmlsaXR5XG4gICAgdGhpcy5nZXRNZXRhID0gdGhpcy5nZXRNZXRhLmJpbmQodGhpcylcbiAgICB0aGlzLmFkZEZpbGUgPSB0aGlzLmFkZEZpbGUuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlUm9vdERyb3AgPSB0aGlzLmhhbmRsZVJvb3REcm9wLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZVJvb3RQYXN0ZSA9IHRoaXMuaGFuZGxlUm9vdFBhc3RlLmJpbmQodGhpcylcblxuICAgIHRoaXMuY2xpZW50ID0gbmV3IFJlcXVlc3RDbGllbnQodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMgfHwgdGhpcy5vcHRzLnNlcnZlckhlYWRlcnMsXG4gICAgICBjb21wYW5pb25Db29raWVzUnVsZTogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlLFxuICAgIH0pXG4gIH1cblxuICBzZXRPcHRpb25zIChuZXdPcHRzKSB7XG4gICAgc3VwZXIuc2V0T3B0aW9ucyhuZXdPcHRzKVxuICAgIHRoaXMuaTE4bkluaXQoKVxuICB9XG5cbiAgaTE4bkluaXQgKCkge1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKFt0aGlzLmRlZmF1bHRMb2NhbGUsIHRoaXMudXBweS5sb2NhbGUsIHRoaXMub3B0cy5sb2NhbGVdKVxuICAgIHRoaXMuaTE4biA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5pMThuQXJyYXkgPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlQXJyYXkuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyBhbmQgd2Ugc2VlIHRoZSB1cGRhdGVkIGxvY2FsZVxuICB9XG5cbiAgZ2V0RmlsZU5hbWVGcm9tVXJsICh1cmwpIHtcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZyh1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpXG4gIH1cblxuICBjaGVja0lmQ29ycmVjdFVSTCAodXJsKSB7XG4gICAgaWYgKCF1cmwpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3QgcHJvdG9jb2wgPSB1cmwubWF0Y2goL14oW2EtejAtOV0rKTpcXC9cXC8vKVsxXVxuICAgIGlmIChwcm90b2NvbCAhPT0gJ2h0dHAnICYmIHByb3RvY29sICE9PSAnaHR0cHMnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgYWRkUHJvdG9jb2xUb1VSTCAodXJsKSB7XG4gICAgY29uc3QgcHJvdG9jb2xSZWdleCA9IC9eW2EtejAtOV0rOlxcL1xcLy9cbiAgICBjb25zdCBkZWZhdWx0UHJvdG9jb2wgPSAnaHR0cDovLydcbiAgICBpZiAocHJvdG9jb2xSZWdleC50ZXN0KHVybCkpIHtcbiAgICAgIHJldHVybiB1cmxcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdFByb3RvY29sICsgdXJsXG4gIH1cblxuICBnZXRNZXRhICh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucG9zdCgndXJsL21ldGEnLCB7IHVybCB9KVxuICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICAgICAgdGhpcy51cHB5LmxvZygnW1VSTF0gRXJyb3I6JylcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKHJlcy5lcnJvcilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCB0aGUgZmlsZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc1xuICAgICAgfSlcbiAgfVxuXG4gIGFkZEZpbGUgKHVybCkge1xuICAgIHVybCA9IHRoaXMuYWRkUHJvdG9jb2xUb1VSTCh1cmwpXG4gICAgaWYgKCF0aGlzLmNoZWNrSWZDb3JyZWN0VVJMKHVybCkpIHtcbiAgICAgIHRoaXMudXBweS5sb2coYFtVUkxdIEluY29ycmVjdCBVUkwgZW50ZXJlZDogJHt1cmx9YClcbiAgICAgIHRoaXMudXBweS5pbmZvKHRoaXMuaTE4bignZW50ZXJDb3JyZWN0VXJsJyksICdlcnJvcicsIDQwMDApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRNZXRhKHVybClcbiAgICAgIC50aGVuKChtZXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhZ0ZpbGUgPSB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0RmlsZU5hbWVGcm9tVXJsKHVybCksXG4gICAgICAgICAgdHlwZTogbWV0YS50eXBlLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHNpemU6IG1ldGEuc2l6ZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlzUmVtb3RlOiB0cnVlLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgICAgICAgdXJsOiBgJHt0aGlzLmhvc3RuYW1lfS91cmwvZ2V0YCxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgZmlsZUlkOiB1cmwsXG4gICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHRoaXMuY2xpZW50Lm9wdHMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnRmlsZVxuICAgICAgfSlcbiAgICAgIC50aGVuKCh0YWdGaWxlKSA9PiB7XG4gICAgICAgIHRoaXMudXBweS5sb2coJ1tVcmxdIEFkZGluZyByZW1vdGUgZmlsZScpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudXBweS5hZGRGaWxlKHRhZ0ZpbGUpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmICghZXJyLmlzUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZXJyXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKGVycilcbiAgICAgICAgdGhpcy51cHB5LmluZm8oe1xuICAgICAgICAgIG1lc3NhZ2U6IHRoaXMuaTE4bignZmFpbGVkVG9GZXRjaCcpLFxuICAgICAgICAgIGRldGFpbHM6IGVycixcbiAgICAgICAgfSwgJ2Vycm9yJywgNDAwMClcbiAgICAgICAgcmV0dXJuIGVyclxuICAgICAgfSlcbiAgfVxuXG4gIGhhbmRsZVJvb3REcm9wIChlKSB7XG4gICAgZm9yRWFjaERyb3BwZWRPclBhc3RlZFVybChlLmRhdGFUcmFuc2ZlciwgJ2Ryb3AnLCAodXJsKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKGBbVVJMXSBBZGRpbmcgZmlsZSBmcm9tIGRyb3BwZWQgdXJsOiAke3VybH1gKVxuICAgICAgdGhpcy5hZGRGaWxlKHVybClcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlUm9vdFBhc3RlIChlKSB7XG4gICAgZm9yRWFjaERyb3BwZWRPclBhc3RlZFVybChlLmNsaXBib2FyZERhdGEsICdwYXN0ZScsICh1cmwpID0+IHtcbiAgICAgIHRoaXMudXBweS5sb2coYFtVUkxdIEFkZGluZyBmaWxlIGZyb20gcGFzdGVkIHVybDogJHt1cmx9YClcbiAgICAgIHRoaXMuYWRkRmlsZSh1cmwpXG4gICAgfSlcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUpIHtcbiAgICByZXR1cm4gPFVybFVJIGkxOG49e3RoaXMuaTE4bn0gYWRkRmlsZT17dGhpcy5hZGRGaWxlfSAvPlxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxufVxuIiwiY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi90b0FycmF5JylcblxuLypcbiAgU0lUVUFUSU9OXG5cbiAgICAxLiBDcm9zcy1icm93c2VyIGRhdGFUcmFuc2Zlci5pdGVtc1xuXG4gICAgICBwYXN0ZSBpbiBjaHJvbWUgW0NvcHkgSW1hZ2VdOlxuICAgICAgMDoge2tpbmQ6IFwiZmlsZVwiLCB0eXBlOiBcImltYWdlL3BuZ1wifVxuICAgICAgMToge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC9odG1sXCJ9XG4gICAgICBwYXN0ZSBpbiBzYWZhcmkgW0NvcHkgSW1hZ2VdOlxuICAgICAgMDoge2tpbmQ6IFwiZmlsZVwiLCB0eXBlOiBcImltYWdlL3BuZ1wifVxuICAgICAgMToge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC9odG1sXCJ9XG4gICAgICAyOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG4gICAgICAzOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3VyaS1saXN0XCJ9XG4gICAgICBwYXN0ZSBpbiBmaXJlZm94IFtDb3B5IEltYWdlXTpcbiAgICAgIDA6IHtraW5kOiBcImZpbGVcIiwgdHlwZTogXCJpbWFnZS9wbmdcIn1cbiAgICAgIDE6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvaHRtbFwifVxuXG4gICAgICBwYXN0ZSBpbiBjaHJvbWUgW0NvcHkgSW1hZ2UgQWRkcmVzc106XG4gICAgICAwOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG4gICAgICBwYXN0ZSBpbiBzYWZhcmkgW0NvcHkgSW1hZ2UgQWRkcmVzc106XG4gICAgICAwOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG4gICAgICAxOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3VyaS1saXN0XCJ9XG4gICAgICBwYXN0ZSBpbiBmaXJlZm94IFtDb3B5IEltYWdlIEFkZHJlc3NdOlxuICAgICAgMDoge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC9wbGFpblwifVxuXG4gICAgICBkcm9wIGluIGNocm9tZSBbZnJvbSBicm93c2VyXTpcbiAgICAgIDA6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvdXJpLWxpc3RcIn1cbiAgICAgIDE6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvaHRtbFwifVxuICAgICAgZHJvcCBpbiBzYWZhcmkgW2Zyb20gYnJvd3Nlcl06XG4gICAgICAwOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3VyaS1saXN0XCJ9XG4gICAgICAxOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L2h0bWxcIn1cbiAgICAgIDI6IHtraW5kOiBcImZpbGVcIiwgdHlwZTogXCJpbWFnZS9wbmdcIn1cbiAgICAgIGRyb3AgaW4gZmlyZWZveCBbZnJvbSBicm93c2VyXTpcbiAgICAgIDA6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvdXJpLWxpc3RcIn1cbiAgICAgIDE6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQveC1tb3otdXJsXCJ9XG4gICAgICAyOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG5cbiAgICAyLiBXZSBjYW4gZGV0ZXJtaW5lIGlmIGl0J3MgYSAnY29weXBhc3RlJyBvciBhICdkcm9wJywgYnV0IHdlIGNhbid0IGRpc2Nlcm4gYmV0d2VlbiBbQ29weSBJbWFnZV0gYW5kIFtDb3B5IEltYWdlIEFkZHJlc3NdLlxuXG4gIENPTkNMVVNJT05cblxuICAgIDEuICdwYXN0ZScgKFtDb3B5IEltYWdlXSBvciBbQ29weSBJbWFnZSBBZGRyZXNzXSwgd2UgY2FuJ3QgZGlzY2VybiBiZXR3ZWVuIHRoZXNlIHR3bylcbiAgICAgIERvbid0IGRvIGFueXRoaW5nIGlmIHRoZXJlIGlzICdmaWxlJyBpdGVtLiAuaGFuZGxlUGFzdGUgaW4gdGhlIERhc2hib2FyZFBsdWdpbiB3aWxsIGRlYWwgd2l0aCBhbGwgJ2ZpbGUnIGl0ZW1zLlxuICAgICAgSWYgdGhlcmUgYXJlIG5vICdmaWxlJyBpdGVtcyAtIGhhbmRsZSAndGV4dC9wbGFpbicgaXRlbXMuXG5cbiAgICAyLiAnZHJvcCdcbiAgICAgIFRha2UgJ3RleHQvdXJpLWxpc3QnIGl0ZW1zLiBTYWZhcmkgaGFzIGFuIGFkZGl0aW9uYWwgaXRlbSBvZiAua2luZCA9PT0gJ2ZpbGUnLCBhbmQgeW91IG1heSB3b3JyeSBhYm91dCB0aGUgaXRlbSBiZWluZyBkdXBsaWNhdGVkIChmaXJzdCBieSBEYXNoYm9hcmRQbHVnaW4sIGFuZCB0aGVuIGJ5IFVybFBsdWdpbiwgbm93KSwgYnV0IGRvbid0LiBEaXJlY3RvcnkgaGFuZGxpbmcgY29kZSB3b24ndCBwYXkgYXR0ZW50aW9uIHRvIHRoaXMgcGFydGljdWxhciBpdGVtIG9mIGtpbmQgJ2ZpbGUnLlxuKi9cblxuLyoqXG4gKiBGaW5kcyBhbGwgbGlua3MgZHJvcHBlZC9wYXN0ZWQgZnJvbSBvbmUgYnJvd3NlciB3aW5kb3cgdG8gYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YVRyYW5zZmVyIC0gRGF0YVRyYW5zZmVyIGluc3RhbmNlLCBlLmcuIGUuY2xpcGJvYXJkRGF0YSwgb3IgZS5kYXRhVHJhbnNmZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpc0Ryb3BPclBhc3RlIC0gZWl0aGVyICdkcm9wJyBvciAncGFzdGUnXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtICh1cmxTdHJpbmcpID0+IHt9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9yRWFjaERyb3BwZWRPclBhc3RlZFVybCAoZGF0YVRyYW5zZmVyLCBpc0Ryb3BPclBhc3RlLCBjYWxsYmFjaykge1xuICBjb25zdCBpdGVtcyA9IHRvQXJyYXkoZGF0YVRyYW5zZmVyLml0ZW1zKVxuXG4gIGxldCB1cmxJdGVtc1xuXG4gIHN3aXRjaCAoaXNEcm9wT3JQYXN0ZSkge1xuICAgIGNhc2UgJ3Bhc3RlJzoge1xuICAgICAgY29uc3QgYXRMZWFzdE9uZUZpbGVJc0RyYWdnZWQgPSBpdGVtcy5zb21lKChpdGVtKSA9PiBpdGVtLmtpbmQgPT09ICdmaWxlJylcbiAgICAgIGlmIChhdExlYXN0T25lRmlsZUlzRHJhZ2dlZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVybEl0ZW1zID0gaXRlbXMuZmlsdGVyKChpdGVtKSA9PlxuICAgICAgICBpdGVtLmtpbmQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgJiYgaXRlbS50eXBlID09PSAndGV4dC9wbGFpbicpXG5cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJ2Ryb3AnOiB7XG4gICAgICB1cmxJdGVtcyA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT5cbiAgICAgICAgaXRlbS5raW5kID09PSAnc3RyaW5nJ1xuICAgICAgICAmJiBpdGVtLnR5cGUgPT09ICd0ZXh0L3VyaS1saXN0JylcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaXNEcm9wT3JQYXN0ZSBtdXN0IGJlIGVpdGhlciAnZHJvcCcgb3IgJ3Bhc3RlJywgYnV0IGl0J3MgJHtpc0Ryb3BPclBhc3RlfWApXG4gICAgfVxuICB9XG5cbiAgdXJsSXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGl0ZW0uZ2V0QXNTdHJpbmcoKHVybFN0cmluZykgPT5cbiAgICAgIGNhbGxiYWNrKHVybFN0cmluZykpXG4gIH0pXG59XG4iLCIvKipcbiAqIENyZWF0ZSBhIHdyYXBwZXIgYXJvdW5kIGFuIGV2ZW50IGVtaXR0ZXIgd2l0aCBhIGByZW1vdmVgIG1ldGhvZCB0byByZW1vdmVcbiAqIGFsbCBldmVudHMgdGhhdCB3ZXJlIGFkZGVkIHVzaW5nIHRoZSB3cmFwcGVkIGVtaXR0ZXIuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRXZlbnRUcmFja2VyIHtcbiAgY29uc3RydWN0b3IgKGVtaXR0ZXIpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBbXVxuICAgIHRoaXMuX2VtaXR0ZXIgPSBlbWl0dGVyXG4gIH1cblxuICBvbiAoZXZlbnQsIGZuKSB7XG4gICAgdGhpcy5fZXZlbnRzLnB1c2goW2V2ZW50LCBmbl0pXG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIub24oZXZlbnQsIGZuKVxuICB9XG5cbiAgcmVtb3ZlICgpIHtcbiAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgoW2V2ZW50LCBmbl0pID0+IHtcbiAgICAgIHRoaXMuX2VtaXR0ZXIub2ZmKGV2ZW50LCBmbilcbiAgICB9KVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2FbaHJlZl06bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ2FyZWFbaHJlZl06bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ2lucHV0Om5vdChbZGlzYWJsZWRdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICd0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICdidXR0b246bm90KFtkaXNhYmxlZF0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnaWZyYW1lOm5vdChbdGFiaW5kZXhePVwiLVwiXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICdvYmplY3Q6bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ2VtYmVkOm5vdChbdGFiaW5kZXhePVwiLVwiXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICdbY29udGVudGVkaXRhYmxlXTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnW3RhYmluZGV4XTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuXVxuIiwiY2xhc3MgTmV0d29ya0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAoZXJyb3IsIHhociA9IG51bGwpIHtcbiAgICBzdXBlcihgVGhpcyBsb29rcyBsaWtlIGEgbmV0d29yayBlcnJvciwgdGhlIGVuZHBvaW50IG1pZ2h0IGJlIGJsb2NrZWQgYnkgYW4gaW50ZXJuZXQgcHJvdmlkZXIgb3IgYSBmaXJld2FsbC5cXG5cXG5Tb3VyY2UgZXJyb3I6IFske2Vycm9yfV1gKVxuXG4gICAgdGhpcy5pc05ldHdvcmtFcnJvciA9IHRydWVcbiAgICB0aGlzLnJlcXVlc3QgPSB4aHJcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtFcnJvclxuIiwiY29uc3QgZmluZEluZGV4ID0gcmVxdWlyZSgnLi9maW5kSW5kZXgnKVxuXG5mdW5jdGlvbiBjcmVhdGVDYW5jZWxFcnJvciAoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0NhbmNlbGxlZCcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmF0ZUxpbWl0ZWRRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yIChsaW1pdCkge1xuICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8IGxpbWl0ID09PSAwKSB7XG4gICAgICB0aGlzLmxpbWl0ID0gSW5maW5pdHlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saW1pdCA9IGxpbWl0XG4gICAgfVxuXG4gICAgdGhpcy5hY3RpdmVSZXF1ZXN0cyA9IDBcbiAgICB0aGlzLnF1ZXVlZEhhbmRsZXJzID0gW11cbiAgfVxuXG4gIF9jYWxsIChmbikge1xuICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMgKz0gMVxuXG4gICAgbGV0IGRvbmUgPSBmYWxzZVxuXG4gICAgbGV0IGNhbmNlbEFjdGl2ZVxuICAgIHRyeSB7XG4gICAgICBjYW5jZWxBY3RpdmUgPSBmbigpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmFjdGl2ZVJlcXVlc3RzIC09IDFcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhYm9ydDogKCkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICAgIGRvbmUgPSB0cnVlXG4gICAgICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMgLT0gMVxuICAgICAgICBjYW5jZWxBY3RpdmUoKVxuICAgICAgICB0aGlzLl9xdWV1ZU5leHQoKVxuICAgICAgfSxcblxuICAgICAgZG9uZTogKCkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICAgIGRvbmUgPSB0cnVlXG4gICAgICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMgLT0gMVxuICAgICAgICB0aGlzLl9xdWV1ZU5leHQoKVxuICAgICAgfSxcbiAgICB9XG4gIH1cblxuICBfcXVldWVOZXh0ICgpIHtcbiAgICAvLyBEbyBpdCBzb29uIGJ1dCBub3QgaW1tZWRpYXRlbHksIHRoaXMgYWxsb3dzIGNsZWFyaW5nIG91dCB0aGUgZW50aXJlIHF1ZXVlIHN5bmNocm9ub3VzbHlcbiAgICAvLyBvbmUgYnkgb25lIHdpdGhvdXQgY29udGludW91c2x5IF9hZHZhbmNpbmdfIGl0IChhbmQgc3RhcnRpbmcgbmV3IHRhc2tzIGJlZm9yZSBpbW1lZGlhdGVseVxuICAgIC8vIGFib3J0aW5nIHRoZW0pXG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLl9uZXh0KClcbiAgICB9KVxuICB9XG5cbiAgX25leHQgKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZVJlcXVlc3RzID49IHRoaXMubGltaXQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodGhpcy5xdWV1ZWRIYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIERpc3BhdGNoIHRoZSBuZXh0IHJlcXVlc3QsIGFuZCB1cGRhdGUgdGhlIGFib3J0L2RvbmUgaGFuZGxlcnNcbiAgICAvLyBzbyB0aGF0IGNhbmNlbGxpbmcgaXQgZG9lcyB0aGUgUmlnaHQgVGhpbmcgKGFuZCBkb2Vzbid0IGp1c3QgdHJ5XG4gICAgLy8gdG8gZGVxdWV1ZSBhbiBhbHJlYWR5LXJ1bm5pbmcgcmVxdWVzdCkuXG4gICAgY29uc3QgbmV4dCA9IHRoaXMucXVldWVkSGFuZGxlcnMuc2hpZnQoKVxuICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9jYWxsKG5leHQuZm4pXG4gICAgbmV4dC5hYm9ydCA9IGhhbmRsZXIuYWJvcnRcbiAgICBuZXh0LmRvbmUgPSBoYW5kbGVyLmRvbmVcbiAgfVxuXG4gIF9xdWV1ZSAoZm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICBmbixcbiAgICAgIHByaW9yaXR5OiBvcHRpb25zLnByaW9yaXR5IHx8IDAsXG4gICAgICBhYm9ydDogKCkgPT4ge1xuICAgICAgICB0aGlzLl9kZXF1ZXVlKGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZG9uZTogKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtYXJrIGEgcXVldWVkIHJlcXVlc3QgYXMgZG9uZTogdGhpcyBpbmRpY2F0ZXMgYSBidWcnKVxuICAgICAgfSxcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IGZpbmRJbmRleCh0aGlzLnF1ZXVlZEhhbmRsZXJzLCAob3RoZXIpID0+IHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnByaW9yaXR5ID4gb3RoZXIucHJpb3JpdHlcbiAgICB9KVxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMucXVldWVkSGFuZGxlcnMucHVzaChoYW5kbGVyKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnF1ZXVlZEhhbmRsZXJzLnNwbGljZShpbmRleCwgMCwgaGFuZGxlcilcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXJcbiAgfVxuXG4gIF9kZXF1ZXVlIChoYW5kbGVyKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnF1ZXVlZEhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcilcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnF1ZXVlZEhhbmRsZXJzLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cblxuICBydW4gKGZuLCBxdWV1ZU9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVSZXF1ZXN0cyA8IHRoaXMubGltaXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxsKGZuKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcXVldWUoZm4sIHF1ZXVlT3B0aW9ucylcbiAgfVxuXG4gIHdyYXBQcm9taXNlRnVuY3Rpb24gKGZuLCBxdWV1ZU9wdGlvbnMpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGxldCBxdWV1ZWRSZXF1ZXN0XG4gICAgICBjb25zdCBvdXRlclByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QgPSB0aGlzLnJ1bigoKSA9PiB7XG4gICAgICAgICAgbGV0IGNhbmNlbEVycm9yXG4gICAgICAgICAgbGV0IGlubmVyUHJvbWlzZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbm5lclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZm4oLi4uYXJncykpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpbm5lclByb21pc2UgPSBQcm9taXNlLnJlamVjdChlcnIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5uZXJQcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbEVycm9yKSB7XG4gICAgICAgICAgICAgIHJlamVjdChjYW5jZWxFcnJvcilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHF1ZXVlZFJlcXVlc3QuZG9uZSgpXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxFcnJvcikge1xuICAgICAgICAgICAgICByZWplY3QoY2FuY2VsRXJyb3IpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBxdWV1ZWRSZXF1ZXN0LmRvbmUoKVxuICAgICAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2FuY2VsRXJyb3IgPSBjcmVhdGVDYW5jZWxFcnJvcigpXG4gICAgICAgICAgfVxuICAgICAgICB9LCBxdWV1ZU9wdGlvbnMpXG4gICAgICB9KVxuXG4gICAgICBvdXRlclByb21pc2UuYWJvcnQgPSAoKSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0ZXJQcm9taXNlXG4gICAgfVxuICB9XG59XG4iLCJjb25zdCBoYXMgPSByZXF1aXJlKCcuL2hhc1Byb3BlcnR5JylcblxuLyoqXG4gKiBUcmFuc2xhdGVzIHN0cmluZ3Mgd2l0aCBpbnRlcnBvbGF0aW9uICYgcGx1cmFsaXphdGlvbiBzdXBwb3J0LlxuICogRXh0ZW5zaWJsZSB3aXRoIGN1c3RvbSBkaWN0aW9uYXJpZXMgYW5kIHBsdXJhbGl6YXRpb24gZnVuY3Rpb25zLlxuICpcbiAqIEJvcnJvd3MgaGVhdmlseSBmcm9tIGFuZCBpbnNwaXJlZCBieSBQb2x5Z2xvdCBodHRwczovL2dpdGh1Yi5jb20vYWlyYm5iL3BvbHlnbG90LmpzLFxuICogYmFzaWNhbGx5IGEgc3RyaXBwZWQtZG93biB2ZXJzaW9uIG9mIGl0LiBEaWZmZXJlbmNlczogcGx1cmFsaXphdGlvbiBmdW5jdGlvbnMgYXJlIG5vdCBoYXJkY29kZWRcbiAqIGFuZCBjYW4gYmUgZWFzaWx5IGFkZGVkIGFtb25nIHdpdGggZGljdGlvbmFyaWVzLCBuZXN0ZWQgb2JqZWN0cyBhcmUgdXNlZCBmb3IgcGx1cmFsaXphdGlvblxuICogYXMgb3Bwb3NlZCB0byBgfHx8fGAgZGVsaW1ldGVyXG4gKlxuICogVXNhZ2UgZXhhbXBsZTogYHRyYW5zbGF0b3IudHJhbnNsYXRlKCdmaWxlc19jaG9zZW4nLCB7c21hcnRfY291bnQ6IDN9KWBcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUcmFuc2xhdG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fEFycmF5PG9iamVjdD59IGxvY2FsZXMgLSBsb2NhbGUgb3IgbGlzdCBvZiBsb2NhbGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKGxvY2FsZXMpIHtcbiAgICB0aGlzLmxvY2FsZSA9IHtcbiAgICAgIHN0cmluZ3M6IHt9LFxuICAgICAgcGx1cmFsaXplIChuKSB7XG4gICAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMVxuICAgICAgfSxcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShsb2NhbGVzKSkge1xuICAgICAgbG9jYWxlcy5mb3JFYWNoKChsb2NhbGUpID0+IHRoaXMuX2FwcGx5KGxvY2FsZSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FwcGx5KGxvY2FsZXMpXG4gICAgfVxuICB9XG5cbiAgX2FwcGx5IChsb2NhbGUpIHtcbiAgICBpZiAoIWxvY2FsZSB8fCAhbG9jYWxlLnN0cmluZ3MpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHByZXZMb2NhbGUgPSB0aGlzLmxvY2FsZVxuICAgIHRoaXMubG9jYWxlID0geyAuLi5wcmV2TG9jYWxlLCBzdHJpbmdzOiB7IC4uLnByZXZMb2NhbGUuc3RyaW5ncywgLi4ubG9jYWxlLnN0cmluZ3MgfSB9XG4gICAgdGhpcy5sb2NhbGUucGx1cmFsaXplID0gbG9jYWxlLnBsdXJhbGl6ZSB8fCBwcmV2TG9jYWxlLnBsdXJhbGl6ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgc3RyaW5nIHdpdGggcGxhY2Vob2xkZXIgdmFyaWFibGVzIGxpa2UgYCV7c21hcnRfY291bnR9IGZpbGUgc2VsZWN0ZWRgXG4gICAqIGFuZCByZXBsYWNlcyBpdCB3aXRoIHZhbHVlcyBmcm9tIG9wdGlvbnMgYHtzbWFydF9jb3VudDogNX1gXG4gICAqXG4gICAqIEBsaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS9haXJibmIvcG9seWdsb3QuanMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICAgKiB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9haXJibmIvcG9seWdsb3QuanMvYmxvYi9tYXN0ZXIvbGliL3BvbHlnbG90LmpzI0wyOTlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBocmFzZSB0aGF0IG5lZWRzIGludGVycG9sYXRpb24sIHdpdGggcGxhY2Vob2xkZXJzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHdpdGggdmFsdWVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlcGxhY2UgcGxhY2Vob2xkZXJzXG4gICAqIEByZXR1cm5zIHthbnlbXX0gaW50ZXJwb2xhdGVkXG4gICAqL1xuICBpbnRlcnBvbGF0ZSAocGhyYXNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBzcGxpdCwgcmVwbGFjZSB9ID0gU3RyaW5nLnByb3RvdHlwZVxuICAgIGNvbnN0IGRvbGxhclJlZ2V4ID0gL1xcJC9nXG4gICAgY29uc3QgZG9sbGFyQmlsbHNZYWxsID0gJyQkJCQnXG4gICAgbGV0IGludGVycG9sYXRlZCA9IFtwaHJhc2VdXG5cbiAgICBmb3IgKGNvbnN0IGFyZyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoYXJnICE9PSAnXycgJiYgaGFzKG9wdGlvbnMsIGFyZykpIHtcbiAgICAgICAgLy8gRW5zdXJlIHJlcGxhY2VtZW50IHZhbHVlIGlzIGVzY2FwZWQgdG8gcHJldmVudCBzcGVjaWFsICQtcHJlZml4ZWRcbiAgICAgICAgLy8gcmVnZXggcmVwbGFjZSB0b2tlbnMuIHRoZSBcIiQkJCRcIiBpcyBuZWVkZWQgYmVjYXVzZSBlYWNoIFwiJFwiIG5lZWRzIHRvXG4gICAgICAgIC8vIGJlIGVzY2FwZWQgd2l0aCBcIiRcIiBpdHNlbGYsIGFuZCB3ZSBuZWVkIHR3byBpbiB0aGUgcmVzdWx0aW5nIG91dHB1dC5cbiAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gb3B0aW9uc1thcmddXG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlLmNhbGwob3B0aW9uc1thcmddLCBkb2xsYXJSZWdleCwgZG9sbGFyQmlsbHNZYWxsKVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGNyZWF0ZSBhIG5ldyBgUmVnRXhwYCBlYWNoIHRpbWUgaW5zdGVhZCBvZiB1c2luZyBhIG1vcmUtZWZmaWNpZW50XG4gICAgICAgIC8vIHN0cmluZyByZXBsYWNlIHNvIHRoYXQgdGhlIHNhbWUgYXJndW1lbnQgY2FuIGJlIHJlcGxhY2VkIG11bHRpcGxlIHRpbWVzXG4gICAgICAgIC8vIGluIHRoZSBzYW1lIHBocmFzZS5cbiAgICAgICAgaW50ZXJwb2xhdGVkID0gaW5zZXJ0UmVwbGFjZW1lbnQoaW50ZXJwb2xhdGVkLCBuZXcgUmVnRXhwKGAlXFxcXHske2FyZ31cXFxcfWAsICdnJyksIHJlcGxhY2VtZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnBvbGF0ZWRcblxuICAgIGZ1bmN0aW9uIGluc2VydFJlcGxhY2VtZW50IChzb3VyY2UsIHJ4LCByZXBsYWNlbWVudCkge1xuICAgICAgY29uc3QgbmV3UGFydHMgPSBbXVxuICAgICAgc291cmNlLmZvckVhY2goKGNodW5rKSA9PiB7XG4gICAgICAgIC8vIFdoZW4gdGhlIHNvdXJjZSBjb250YWlucyBtdWx0aXBsZSBwbGFjZWhvbGRlcnMgZm9yIGludGVycG9sYXRpb24sXG4gICAgICAgIC8vIHdlIHNob3VsZCBpZ25vcmUgY2h1bmtzIHRoYXQgYXJlIG5vdCBzdHJpbmdzLCBiZWNhdXNlIHRob3NlXG4gICAgICAgIC8vIGNhbiBiZSBKU1ggb2JqZWN0cyBhbmQgd2lsbCBiZSBvdGhlcndpc2UgaW5jb3JyZWN0bHkgdHVybmVkIGludG8gc3RyaW5ncy5cbiAgICAgICAgLy8gV2l0aG91dCB0aGlzIGNvbmRpdGlvbiB3ZeKAmWQgZ2V0IHRoaXM6IFtvYmplY3QgT2JqZWN0XSBoZWxsbyBbb2JqZWN0IE9iamVjdF0gbXkgPGJ1dHRvbj5cbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gbmV3UGFydHMucHVzaChjaHVuaylcbiAgICAgICAgfVxuXG4gICAgICAgIHNwbGl0LmNhbGwoY2h1bmssIHJ4KS5mb3JFYWNoKChyYXcsIGksIGxpc3QpID0+IHtcbiAgICAgICAgICBpZiAocmF3ICE9PSAnJykge1xuICAgICAgICAgICAgbmV3UGFydHMucHVzaChyYXcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSW50ZXJsYWNlIHdpdGggdGhlIGByZXBsYWNlbWVudGAgdmFsdWVcbiAgICAgICAgICBpZiAoaSA8IGxpc3QubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgbmV3UGFydHMucHVzaChyZXBsYWNlbWVudClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgcmV0dXJuIG5ld1BhcnRzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyB0cmFuc2xhdGUgbWV0aG9kXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgd2l0aCB2YWx1ZXMgdGhhdCB3aWxsIGJlIHVzZWQgbGF0ZXIgdG8gcmVwbGFjZSBwbGFjZWhvbGRlcnMgaW4gc3RyaW5nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRyYW5zbGF0ZWQgKGFuZCBpbnRlcnBvbGF0ZWQpXG4gICAqL1xuICB0cmFuc2xhdGUgKGtleSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZUFycmF5KGtleSwgb3B0aW9ucykuam9pbignJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0cmFuc2xhdGlvbiBhbmQgcmV0dXJuIHRoZSB0cmFuc2xhdGVkIGFuZCBpbnRlcnBvbGF0ZWQgcGFydHMgYXMgYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgd2l0aCB2YWx1ZXMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVwbGFjZSBwbGFjZWhvbGRlcnNcbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgdHJhbnNsYXRlZCBhbmQgaW50ZXJwb2xhdGVkIHBhcnRzLCBpbiBvcmRlci5cbiAgICovXG4gIHRyYW5zbGF0ZUFycmF5IChrZXksIG9wdGlvbnMpIHtcbiAgICBpZiAoIWhhcyh0aGlzLmxvY2FsZS5zdHJpbmdzLCBrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgc3RyaW5nOiAke2tleX1gKVxuICAgIH1cblxuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMubG9jYWxlLnN0cmluZ3Nba2V5XVxuICAgIGNvbnN0IGhhc1BsdXJhbEZvcm1zID0gdHlwZW9mIHN0cmluZyA9PT0gJ29iamVjdCdcblxuICAgIGlmIChoYXNQbHVyYWxGb3Jtcykge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuc21hcnRfY291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IHBsdXJhbCA9IHRoaXMubG9jYWxlLnBsdXJhbGl6ZShvcHRpb25zLnNtYXJ0X2NvdW50KVxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZShzdHJpbmdbcGx1cmFsXSwgb3B0aW9ucylcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHVzZSBhIHN0cmluZyB3aXRoIHBsdXJhbCBmb3JtcywgYnV0IG5vIHZhbHVlIHdhcyBnaXZlbiBmb3IgJXtzbWFydF9jb3VudH0nKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmludGVycG9sYXRlKHN0cmluZywgb3B0aW9ucylcbiAgfVxufVxuIiwiY29uc3QgZGF0YVVSSXRvQmxvYiA9IHJlcXVpcmUoJy4vZGF0YVVSSXRvQmxvYicpXG5cbi8qKlxuICogU2F2ZSBhIDxjYW52YXM+IGVsZW1lbnQncyBjb250ZW50IHRvIGEgQmxvYiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYW52YXNUb0Jsb2IgKGNhbnZhcywgdHlwZSwgcXVhbGl0eSkge1xuICBpZiAoY2FudmFzLnRvQmxvYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY2FudmFzLnRvQmxvYihyZXNvbHZlLCB0eXBlLCBxdWFsaXR5KVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIHJldHVybiBkYXRhVVJJdG9CbG9iKGNhbnZhcy50b0RhdGFVUkwodHlwZSwgcXVhbGl0eSksIHt9KVxuICB9KVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkYXRhVVJJdG9CbG9iIChkYXRhVVJJLCBvcHRzLCB0b0ZpbGUpIHtcbiAgLy8gZ2V0IHRoZSBiYXNlNjQgZGF0YVxuICBjb25zdCBkYXRhID0gZGF0YVVSSS5zcGxpdCgnLCcpWzFdXG5cbiAgLy8gdXNlciBtYXkgcHJvdmlkZSBtaW1lIHR5cGUsIGlmIG5vdCBnZXQgaXQgZnJvbSBkYXRhIFVSSVxuICBsZXQgbWltZVR5cGUgPSBvcHRzLm1pbWVUeXBlIHx8IGRhdGFVUkkuc3BsaXQoJywnKVswXS5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF1cblxuICAvLyBkZWZhdWx0IHRvIHBsYWluL3RleHQgaWYgZGF0YSBVUkkgaGFzIG5vIG1pbWVUeXBlXG4gIGlmIChtaW1lVHlwZSA9PSBudWxsKSB7XG4gICAgbWltZVR5cGUgPSAncGxhaW4vdGV4dCdcbiAgfVxuXG4gIGNvbnN0IGJpbmFyeSA9IGF0b2IoZGF0YSlcbiAgY29uc3QgYXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeS5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5LnB1c2goYmluYXJ5LmNoYXJDb2RlQXQoaSkpXG4gIH1cblxuICBsZXQgYnl0ZXNcbiAgdHJ5IHtcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbXBhdC9jb21wYXRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIENvbnZlcnQgdG8gYSBGaWxlP1xuICBpZiAodG9GaWxlKSB7XG4gICAgcmV0dXJuIG5ldyBGaWxlKFtieXRlc10sIG9wdHMubmFtZSB8fCAnJywgeyB0eXBlOiBtaW1lVHlwZSB9KVxuICB9XG5cbiAgcmV0dXJuIG5ldyBCbG9iKFtieXRlc10sIHsgdHlwZTogbWltZVR5cGUgfSlcbn1cbiIsImNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgnbG9kYXNoLnRocm90dGxlJylcblxuZnVuY3Rpb24gX2VtaXRTb2NrZXRQcm9ncmVzcyAodXBsb2FkZXIsIHByb2dyZXNzRGF0YSwgZmlsZSkge1xuICBjb25zdCB7IHByb2dyZXNzLCBieXRlc1VwbG9hZGVkLCBieXRlc1RvdGFsIH0gPSBwcm9ncmVzc0RhdGFcbiAgaWYgKHByb2dyZXNzKSB7XG4gICAgdXBsb2FkZXIudXBweS5sb2coYFVwbG9hZCBwcm9ncmVzczogJHtwcm9ncmVzc31gKVxuICAgIHVwbG9hZGVyLnVwcHkuZW1pdCgndXBsb2FkLXByb2dyZXNzJywgZmlsZSwge1xuICAgICAgdXBsb2FkZXIsXG4gICAgICBieXRlc1VwbG9hZGVkLFxuICAgICAgYnl0ZXNUb3RhbCxcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGUoX2VtaXRTb2NrZXRQcm9ncmVzcywgMzAwLCB7XG4gIGxlYWRpbmc6IHRydWUsXG4gIHRyYWlsaW5nOiB0cnVlLFxufSlcbiIsImNvbnN0IE5ldHdvcmtFcnJvciA9IHJlcXVpcmUoJy4vTmV0d29ya0Vycm9yJylcblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCB3aW5kb3cuZmV0Y2ggdGhhdCB0aHJvd3MgYSBOZXR3b3JrRXJyb3Igd2hlbiBhcHByb3ByaWF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZldGNoV2l0aE5ldHdvcmtFcnJvciAoLi4ub3B0aW9ucykge1xuICByZXR1cm4gZmV0Y2goLi4ub3B0aW9ucylcbiAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKGVycilcbiAgICAgIH1cbiAgICB9KVxufVxuIiwiY29uc3QgaXNET01FbGVtZW50ID0gcmVxdWlyZSgnLi9pc0RPTUVsZW1lbnQnKVxuXG4vKipcbiAqIEZpbmQgb25lIG9yIG1vcmUgRE9NIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl8bnVsbH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaW5kQWxsRE9NRWxlbWVudHMgKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnQpKVxuICAgIHJldHVybiBlbGVtZW50cy5sZW5ndGggPiAwID8gZWxlbWVudHMgOiBudWxsXG4gIH1cblxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGlzRE9NRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiBbZWxlbWVudF1cbiAgfVxufVxuIiwiY29uc3QgaXNET01FbGVtZW50ID0gcmVxdWlyZSgnLi9pc0RPTUVsZW1lbnQnKVxuXG4vKipcbiAqIEZpbmQgYSBET00gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV8c3RyaW5nfSBlbGVtZW50XG4gKiBAcmV0dXJucyB7Tm9kZXxudWxsfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbmRET01FbGVtZW50IChlbGVtZW50LCBjb250ZXh0ID0gZG9jdW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudClcbiAgfVxuXG4gIGlmIChpc0RPTUVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZWxlbWVudFxuICB9XG59XG4iLCIvKipcbiAqIEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXggcG9ueWZpbGwgZm9yIG9sZCBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbmRJbmRleCAoYXJyYXksIHByZWRpY2F0ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpXSkpIHJldHVybiBpXG4gIH1cbiAgcmV0dXJuIC0xXG59XG4iLCIvKipcbiAqIFRha2VzIGEgZmlsZSBvYmplY3QgYW5kIHR1cm5zIGl0IGludG8gZmlsZUlELCBieSBjb252ZXJ0aW5nIGZpbGUubmFtZSB0byBsb3dlcmNhc2UsXG4gKiByZW1vdmluZyBleHRyYSBjaGFyYWN0ZXJzIGFuZCBhZGRpbmcgdHlwZSwgc2l6ZSBhbmQgbGFzdE1vZGlmaWVkXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGZpbGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBmaWxlSURcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZUZpbGVJRCAoZmlsZSkge1xuICAvLyBJdCdzIHRlbXB0aW5nIHRvIGRvIGBbaXRlbXNdLmZpbHRlcihCb29sZWFuKS5qb2luKCctJylgIGhlcmUsIGJ1dCB0aGF0XG4gIC8vIGlzIHNsb3dlciEgc2ltcGxlIHN0cmluZyBjb25jYXRlbmF0aW9uIGlzIGZhc3RcblxuICBsZXQgaWQgPSAndXBweSdcbiAgaWYgKHR5cGVvZiBmaWxlLm5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWQgKz0gYC0ke2VuY29kZUZpbGVuYW1lKGZpbGUubmFtZS50b0xvd2VyQ2FzZSgpKX1gXG4gIH1cblxuICBpZiAoZmlsZS50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZCArPSBgLSR7ZmlsZS50eXBlfWBcbiAgfVxuXG4gIGlmIChmaWxlLm1ldGEgJiYgdHlwZW9mIGZpbGUubWV0YS5yZWxhdGl2ZVBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgaWQgKz0gYC0ke2VuY29kZUZpbGVuYW1lKGZpbGUubWV0YS5yZWxhdGl2ZVBhdGgudG9Mb3dlckNhc2UoKSl9YFxuICB9XG5cbiAgaWYgKGZpbGUuZGF0YS5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZCArPSBgLSR7ZmlsZS5kYXRhLnNpemV9YFxuICB9XG4gIGlmIChmaWxlLmRhdGEubGFzdE1vZGlmaWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZCArPSBgLSR7ZmlsZS5kYXRhLmxhc3RNb2RpZmllZH1gXG4gIH1cblxuICByZXR1cm4gaWRcbn1cblxuZnVuY3Rpb24gZW5jb2RlRmlsZW5hbWUgKG5hbWUpIHtcbiAgbGV0IHN1ZmZpeCA9ICcnXG4gIHJldHVybiBuYW1lLnJlcGxhY2UoL1teQS1aMC05XS9pZywgKGNoYXJhY3RlcikgPT4ge1xuICAgIHN1ZmZpeCArPSBgLSR7ZW5jb2RlQ2hhcmFjdGVyKGNoYXJhY3Rlcil9YFxuICAgIHJldHVybiAnLydcbiAgfSkgKyBzdWZmaXhcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2hhcmFjdGVyIChjaGFyYWN0ZXIpIHtcbiAgcmV0dXJuIGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDMyKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRCeXRlc1JlbWFpbmluZyAoZmlsZVByb2dyZXNzKSB7XG4gIHJldHVybiBmaWxlUHJvZ3Jlc3MuYnl0ZXNUb3RhbCAtIGZpbGVQcm9ncmVzcy5ieXRlc1VwbG9hZGVkXG59XG4iLCJjb25zdCB3ZWJraXRHZXRBc0VudHJ5QXBpID0gcmVxdWlyZSgnLi91dGlscy93ZWJraXRHZXRBc0VudHJ5QXBpL2luZGV4JylcbmNvbnN0IGZhbGxiYWNrQXBpID0gcmVxdWlyZSgnLi91dGlscy9mYWxsYmFja0FwaScpXG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgYXJyYXkgb2YgZHJvcHBlZCBmaWxlcyAoaWYgYSBmb2xkZXIgaXMgZHJvcHBlZCwgYW5kIGJyb3dzZXIgc3VwcG9ydHMgZm9sZGVyIHBhcnNpbmcgLSBwcm9taXNlIHJlc29sdmVzIHRvIHRoZSBmbGF0IGFycmF5IG9mIGFsbCBmaWxlcyBpbiBhbGwgZGlyZWN0b3JpZXMpLlxuICogRWFjaCBmaWxlIGhhcyAucmVsYXRpdmVQYXRoIHByb3AgYXBwZW5kZWQgdG8gaXQgKGUuZy4gXCIvZG9jcy9QcmFndWUvdGlja2V0X2Zyb21fcHJhZ3VlX3RvX3VmYS5wZGZcIikgaWYgYnJvd3NlciBzdXBwb3J0cyBpdC4gT3RoZXJ3aXNlIGl0J3MgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7RGF0YVRyYW5zZmVyfSBkYXRhVHJhbnNmZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxvZ0Ryb3BFcnJvciAtIGEgZnVuY3Rpb24gdGhhdCdzIGNhbGxlZCBldmVyeSB0aW1lIHNvbWUgZm9sZGVyIG9yIHNvbWUgZmlsZSBlcnJvciBvdXQgKGUuZy4gYmVjYXVzZSBvZiB0aGUgZm9sZGVyIG5hbWUgYmVpbmcgdG9vIGxvbmcgb24gV2luZG93cykuIE5vdGljZSB0aGF0IHJlc3VsdGluZyBwcm9taXNlIHdpbGwgYWx3YXlzIGJlIHJlc29sdmVkIGFueXdheS5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBBcnJheTxGaWxlPlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldERyb3BwZWRGaWxlcyAoZGF0YVRyYW5zZmVyLCB7IGxvZ0Ryb3BFcnJvciA9ICgpID0+IHt9IH0gPSB7fSkge1xuICAvLyBHZXQgYWxsIGZpbGVzIGZyb20gYWxsIHN1YmRpcnMuIFdvcmtzIChhdCBsZWFzdCkgaW4gQ2hyb21lLCBNb3ppbGxhLCBhbmQgU2FmYXJpXG4gIGlmIChkYXRhVHJhbnNmZXIuaXRlbXMgJiYgZGF0YVRyYW5zZmVyLml0ZW1zWzBdICYmICd3ZWJraXRHZXRBc0VudHJ5JyBpbiBkYXRhVHJhbnNmZXIuaXRlbXNbMF0pIHtcbiAgICByZXR1cm4gd2Via2l0R2V0QXNFbnRyeUFwaShkYXRhVHJhbnNmZXIsIGxvZ0Ryb3BFcnJvcilcbiAgLy8gT3RoZXJ3aXNlIGp1c3QgcmV0dXJuIGFsbCBmaXJzdC1vcmRlciBmaWxlc1xuICB9XG4gIHJldHVybiBmYWxsYmFja0FwaShkYXRhVHJhbnNmZXIpXG59XG4iLCJjb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnLi4vLi4vdG9BcnJheScpXG5cbi8vIC5maWxlcyBmYWxsYmFjaywgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIGFueSBicm93c2VyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZhbGxiYWNrQXBpIChkYXRhVHJhbnNmZXIpIHtcbiAgY29uc3QgZmlsZXMgPSB0b0FycmF5KGRhdGFUcmFuc2Zlci5maWxlcylcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmaWxlcylcbn1cbiIsIi8qKlxuICogUmVjdXJzaXZlIGZ1bmN0aW9uLCBjYWxscyB0aGUgb3JpZ2luYWwgY2FsbGJhY2soKSB3aGVuIHRoZSBkaXJlY3RvcnkgaXMgZW50aXJlbHkgcGFyc2VkLlxuICpcbiAqIEBwYXJhbSB7RmlsZVN5c3RlbURpcmVjdG9yeVJlYWRlcn0gZGlyZWN0b3J5UmVhZGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvbGRFbnRyaWVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsb2dEcm9wRXJyb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gY2FsbGVkIHdpdGggKFsgYWxsIGZpbGVzIGFuZCBkaXJlY3RvcmllcyBpbiB0aGF0IGRpcmVjdG9yeVJlYWRlciBdKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEZpbGVzQW5kRGlyZWN0b3JpZXNGcm9tRGlyZWN0b3J5IChkaXJlY3RvcnlSZWFkZXIsIG9sZEVudHJpZXMsIGxvZ0Ryb3BFcnJvciwgeyBvblN1Y2Nlc3MgfSkge1xuICBkaXJlY3RvcnlSZWFkZXIucmVhZEVudHJpZXMoXG4gICAgKGVudHJpZXMpID0+IHtcbiAgICAgIGNvbnN0IG5ld0VudHJpZXMgPSBbLi4ub2xkRW50cmllcywgLi4uZW50cmllc11cbiAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgRmlsZVN5c3RlbSBBUEkgc3BlYywgZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnkoKSBtdXN0IGJlIGNhbGxlZCB1bnRpbCBpdCBjYWxscyB0aGUgb25TdWNjZXNzIHdpdGggYW4gZW1wdHkgYXJyYXkuXG4gICAgICBpZiAoZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnkoZGlyZWN0b3J5UmVhZGVyLCBuZXdFbnRyaWVzLCBsb2dEcm9wRXJyb3IsIHsgb25TdWNjZXNzIH0pXG4gICAgICAgIH0sIDApXG4gICAgICAvLyBEb25lIGl0ZXJhdGluZyB0aGlzIHBhcnRpY3VsYXIgZGlyZWN0b3J5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblN1Y2Nlc3MobmV3RW50cmllcylcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSByZXNvbHZlIG9uIGVycm9yIGFueXdheSwgaXQncyBmaW5lIGlmIG9ubHkgb25lIGRpcmVjdG9yeSBjb3VsZG4ndCBiZSBwYXJzZWQhXG4gICAgKGVycm9yKSA9PiB7XG4gICAgICBsb2dEcm9wRXJyb3IoZXJyb3IpXG4gICAgICBvblN1Y2Nlc3Mob2xkRW50cmllcylcbiAgICB9XG4gIClcbn1cbiIsIi8qKlxuICogR2V0IHRoZSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIEZpbGVFbnRyeSNmdWxsUGF0aCwgYmVjYXVzZSBGaWxlI3dlYmtpdFJlbGF0aXZlUGF0aCBpcyBhbHdheXMgJycsIGF0IGxlYXN0IG9uRHJvcC5cbiAqXG4gKiBAcGFyYW0ge0ZpbGVFbnRyeX0gZmlsZUVudHJ5XG4gKlxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSAtIGlmIGZpbGUgaXMgbm90IGluIGEgZm9sZGVyIC0gcmV0dXJuIG51bGwgKHRoaXMgaXMgdG8gYmUgY29uc2lzdGVudCB3aXRoIC5yZWxhdGl2ZVBhdGgtcyBvZiBmaWxlcyBzZWxlY3RlZCBmcm9tIE15IERldmljZSkuIElmIGZpbGUgaXMgaW4gYSBmb2xkZXIgLSByZXR1cm4gaXRzIGZ1bGxQYXRoLCBlLmcuICcvc2ltcHNvbnMvaGkuanBlZycuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UmVsYXRpdmVQYXRoIChmaWxlRW50cnkpIHtcbiAgLy8gZmlsZUVudHJ5LmZ1bGxQYXRoIC0gXCIvc2ltcHNvbnMvaGkuanBlZ1wiIG9yIHVuZGVmaW5lZCAoZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdClcbiAgLy8gZmlsZUVudHJ5Lm5hbWUgLSBcImhpLmpwZWdcIlxuICBpZiAoIWZpbGVFbnRyeS5mdWxsUGF0aCB8fCBmaWxlRW50cnkuZnVsbFBhdGggPT09IGAvJHtmaWxlRW50cnkubmFtZX1gKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICByZXR1cm4gZmlsZUVudHJ5LmZ1bGxQYXRoXG59XG4iLCJjb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnLi4vLi4vLi4vdG9BcnJheScpXG5jb25zdCBnZXRSZWxhdGl2ZVBhdGggPSByZXF1aXJlKCcuL2dldFJlbGF0aXZlUGF0aCcpXG5jb25zdCBnZXRGaWxlc0FuZERpcmVjdG9yaWVzRnJvbURpcmVjdG9yeSA9IHJlcXVpcmUoJy4vZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnknKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdlYmtpdEdldEFzRW50cnlBcGkgKGRhdGFUcmFuc2ZlciwgbG9nRHJvcEVycm9yKSB7XG4gIGNvbnN0IGZpbGVzID0gW11cblxuICBjb25zdCByb290UHJvbWlzZXMgPSBbXVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmVzb2x2ZWQgcHJvbWlzZSwgd2hlbiA6ZmlsZXMgYXJyYXkgaXMgZW5oYW5jZWRcbiAgICpcbiAgICogQHBhcmFtIHsoRmlsZVN5c3RlbUZpbGVFbnRyeXxGaWxlU3lzdGVtRGlyZWN0b3J5RW50cnkpfSBlbnRyeVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBlbXB0eSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiA6ZmlsZXMgaXMgZW5oYW5jZWQgd2l0aCBhIGZpbGVcbiAgICovXG4gIGNvbnN0IGNyZWF0ZVByb21pc2VUb0FkZEZpbGVPclBhcnNlRGlyZWN0b3J5ID0gKGVudHJ5KSA9PlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAvLyBUaGlzIGlzIGEgYmFzZSBjYWxsXG4gICAgICBpZiAoZW50cnkuaXNGaWxlKSB7XG4gICAgICAgIC8vIENyZWF0ZXMgYSBuZXcgRmlsZSBvYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVhZCB0aGUgZmlsZS5cbiAgICAgICAgZW50cnkuZmlsZShcbiAgICAgICAgICAoZmlsZSkgPT4ge1xuICAgICAgICAgICAgZmlsZS5yZWxhdGl2ZVBhdGggPSBnZXRSZWxhdGl2ZVBhdGgoZW50cnkpXG4gICAgICAgICAgICBmaWxlcy5wdXNoKGZpbGUpXG4gICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSByZXNvbHZlIG9uIGVycm9yIGFueXdheSwgaXQncyBmaW5lIGlmIG9ubHkgb25lIGZpbGUgY291bGRuJ3QgYmUgcmVhZCFcbiAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGxvZ0Ryb3BFcnJvcihlcnJvcilcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgLy8gVGhpcyBpcyBhIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICB9IGVsc2UgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdG9yeVJlYWRlciA9IGVudHJ5LmNyZWF0ZVJlYWRlcigpXG4gICAgICAgIGdldEZpbGVzQW5kRGlyZWN0b3JpZXNGcm9tRGlyZWN0b3J5KGRpcmVjdG9yeVJlYWRlciwgW10sIGxvZ0Ryb3BFcnJvciwge1xuICAgICAgICAgIG9uU3VjY2VzczogKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gZW50cmllcy5tYXAoKGVudHJ5KSA9PiBjcmVhdGVQcm9taXNlVG9BZGRGaWxlT3JQYXJzZURpcmVjdG9yeShlbnRyeSkpXG4gICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiByZXNvbHZlKCkpXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gIC8vIEZvciBlYWNoIGRyb3BwZWQgaXRlbSwgLSBtYWtlIHN1cmUgaXQncyBhIGZpbGUvZGlyZWN0b3J5LCBhbmQgc3RhcnQgZGVlcGVuaW5nIGluIVxuICB0b0FycmF5KGRhdGFUcmFuc2Zlci5pdGVtcylcbiAgICAuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBpdGVtLndlYmtpdEdldEFzRW50cnkoKVxuICAgICAgLy8gOmVudHJ5IGNhbiBiZSBudWxsIHdoZW4gd2UgZHJvcCB0aGUgdXJsIGUuZy5cbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICByb290UHJvbWlzZXMucHVzaChjcmVhdGVQcm9taXNlVG9BZGRGaWxlT3JQYXJzZURpcmVjdG9yeShlbnRyeSkpXG4gICAgICB9XG4gICAgfSlcblxuICByZXR1cm4gUHJvbWlzZS5hbGwocm9vdFByb21pc2VzKVxuICAgIC50aGVuKCgpID0+IGZpbGVzKVxufVxuIiwiLyoqXG4gKiBUYWtlcyBhIGZ1bGwgZmlsZW5hbWUgc3RyaW5nIGFuZCByZXR1cm5zIGFuIG9iamVjdCB7bmFtZSwgZXh0ZW5zaW9ufVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmdWxsRmlsZU5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9IHtuYW1lLCBleHRlbnNpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24gKGZ1bGxGaWxlTmFtZSkge1xuICBjb25zdCBsYXN0RG90ID0gZnVsbEZpbGVOYW1lLmxhc3RJbmRleE9mKCcuJylcbiAgLy8gdGhlc2UgY291bnQgYXMgbm8gZXh0ZW5zaW9uOiBcIm5vLWRvdFwiLCBcInRyYWlsaW5nLWRvdC5cIlxuICBpZiAobGFzdERvdCA9PT0gLTEgfHwgbGFzdERvdCA9PT0gZnVsbEZpbGVOYW1lLmxlbmd0aCAtIDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogZnVsbEZpbGVOYW1lLFxuICAgICAgZXh0ZW5zaW9uOiB1bmRlZmluZWQsXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogZnVsbEZpbGVOYW1lLnNsaWNlKDAsIGxhc3REb3QpLFxuICAgIGV4dGVuc2lvbjogZnVsbEZpbGVOYW1lLnNsaWNlKGxhc3REb3QgKyAxKSxcbiAgfVxufVxuIiwiY29uc3QgZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24gPSByZXF1aXJlKCcuL2dldEZpbGVOYW1lQW5kRXh0ZW5zaW9uJylcbmNvbnN0IG1pbWVUeXBlcyA9IHJlcXVpcmUoJy4vbWltZVR5cGVzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRGaWxlVHlwZSAoZmlsZSkge1xuICBsZXQgZmlsZUV4dGVuc2lvbiA9IGZpbGUubmFtZSA/IGdldEZpbGVOYW1lQW5kRXh0ZW5zaW9uKGZpbGUubmFtZSkuZXh0ZW5zaW9uIDogbnVsbFxuICBmaWxlRXh0ZW5zaW9uID0gZmlsZUV4dGVuc2lvbiA/IGZpbGVFeHRlbnNpb24udG9Mb3dlckNhc2UoKSA6IG51bGxcblxuICBpZiAoZmlsZS50eXBlKSB7XG4gICAgLy8gaWYgbWltZSB0eXBlIGlzIHNldCBpbiB0aGUgZmlsZSBvYmplY3QgYWxyZWFkeSwgdXNlIHRoYXRcbiAgICByZXR1cm4gZmlsZS50eXBlXG4gIH0gaWYgKGZpbGVFeHRlbnNpb24gJiYgbWltZVR5cGVzW2ZpbGVFeHRlbnNpb25dKSB7XG4gICAgLy8gZWxzZSwgc2VlIGlmIHdlIGNhbiBtYXAgZXh0ZW5zaW9uIHRvIGEgbWltZSB0eXBlXG4gICAgcmV0dXJuIG1pbWVUeXBlc1tmaWxlRXh0ZW5zaW9uXVxuICB9XG4gIC8vIGlmIGFsbCBmYWlscywgZmFsbCBiYWNrIHRvIGEgZ2VuZXJpYyBieXRlIHN0cmVhbSB0eXBlXG4gIHJldHVybiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xufVxuIiwiLy8gVE9ETyBDaGVjayB3aGljaCB0eXBlcyBhcmUgYWN0dWFsbHkgc3VwcG9ydGVkIGluIGJyb3dzZXJzLiBDaHJvbWUgbGlrZXMgd2VibVxuLy8gZnJvbSBteSB0ZXN0aW5nLCBidXQgd2UgbWF5IG5lZWQgbW9yZS5cbi8vIFdlIGNvdWxkIHVzZSBhIGxpYnJhcnkgYnV0IHRoZXkgdGVuZCB0byBjb250YWluIGRvemVucyBvZiBLQnMgb2YgbWFwcGluZ3MsXG4vLyBtb3N0IG9mIHdoaWNoIHdpbGwgZ28gdW51c2VkLCBzbyBub3Qgc3VyZSBpZiB0aGF0J3Mgd29ydGggaXQuXG5jb25zdCBtaW1lVG9FeHRlbnNpb25zID0ge1xuICAnYXVkaW8vbXAzJzogJ21wMycsXG4gICdhdWRpby9tcDQnOiAnbXA0JyxcbiAgJ2F1ZGlvL29nZyc6ICdvZ2cnLFxuICAnYXVkaW8vd2VibSc6ICd3ZWJtJyxcbiAgJ2ltYWdlL2dpZic6ICdnaWYnLFxuICAnaW1hZ2UvaGVpYyc6ICdoZWljJyxcbiAgJ2ltYWdlL2hlaWYnOiAnaGVpZicsXG4gICdpbWFnZS9qcGVnJzogJ2pwZycsXG4gICdpbWFnZS9wbmcnOiAncG5nJyxcbiAgJ2ltYWdlL3N2Zyt4bWwnOiAnc3ZnJyxcbiAgJ3ZpZGVvL21wNCc6ICdtcDQnLFxuICAndmlkZW8vb2dnJzogJ29ndicsXG4gICd2aWRlby9xdWlja3RpbWUnOiAnbW92JyxcbiAgJ3ZpZGVvL3dlYm0nOiAnd2VibScsXG4gICd2aWRlby94LW1hdHJvc2thJzogJ21rdicsXG4gICd2aWRlby94LW1zdmlkZW8nOiAnYXZpJyxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRGaWxlVHlwZUV4dGVuc2lvbiAobWltZVR5cGUpIHtcbiAgLy8gUmVtb3ZlIHRoZSA7IGJpdCBpbiAndmlkZW8veC1tYXRyb3NrYTtjb2RlY3M9YXZjMSdcbiAgbWltZVR5cGUgPSBtaW1lVHlwZS5yZXBsYWNlKC87LiokLywgJycpXG4gIHJldHVybiBtaW1lVG9FeHRlbnNpb25zW21pbWVUeXBlXSB8fCBudWxsXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNvY2tldEhvc3QgKHVybCkge1xuICAvLyBnZXQgdGhlIGhvc3QgZG9tYWluXG4gIHZhciByZWdleCA9IC9eKD86aHR0cHM/OlxcL1xcL3xcXC9cXC8pPyg/OlteQFxcbl0rQCk/KD86d3d3XFwuKT8oW15cXG5dKykvaVxuICB2YXIgaG9zdCA9IHJlZ2V4LmV4ZWModXJsKVsxXVxuICB2YXIgc29ja2V0UHJvdG9jb2wgPSAvXmh0dHA6XFwvXFwvL2kudGVzdCh1cmwpID8gJ3dzJyA6ICd3c3MnXG5cbiAgcmV0dXJuIGAke3NvY2tldFByb3RvY29sfTovLyR7aG9zdH1gXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNwZWVkIChmaWxlUHJvZ3Jlc3MpIHtcbiAgaWYgKCFmaWxlUHJvZ3Jlc3MuYnl0ZXNVcGxvYWRlZCkgcmV0dXJuIDBcblxuICBjb25zdCB0aW1lRWxhcHNlZCA9IChuZXcgRGF0ZSgpKSAtIGZpbGVQcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gIGNvbnN0IHVwbG9hZFNwZWVkID0gZmlsZVByb2dyZXNzLmJ5dGVzVXBsb2FkZWQgLyAodGltZUVsYXBzZWQgLyAxMDAwKVxuICByZXR1cm4gdXBsb2FkU3BlZWRcbn1cbiIsIi8qKlxuICogR2V0IHRoZSBkZWNsYXJlZCB0ZXh0IGRpcmVjdGlvbiBmb3IgYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGdldFRleHREaXJlY3Rpb24gKGVsZW1lbnQpIHtcbiAgLy8gVGhlcmUgaXMgYW5vdGhlciB3YXkgdG8gZGV0ZXJtaW5lIHRleHQgZGlyZWN0aW9uIHVzaW5nIGdldENvbXB1dGVkU3R5bGUoKSwgYXMgZG9uZSBoZXJlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGVuY2lsLWpzL3RleHQtZGlyZWN0aW9uL2Jsb2IvMmEyMzVjZTk1MDg5YjMxODVhY2VjM2I1MTMxM2NiYmE5MjFiMzgxMS90ZXh0LWRpcmVjdGlvbi5qc1xuICAvL1xuICAvLyBXZSBkbyBub3QgdXNlIHRoYXQgYXBwcm9hY2ggYmVjYXVzZSB3ZSBhcmUgaW50ZXJlc3RlZCBzcGVjaWZpY2FsbHkgaW4gdGhlIF9kZWNsYXJlZF8gdGV4dCBkaXJlY3Rpb24uXG4gIC8vIElmIG5vIHRleHQgZGlyZWN0aW9uIGlzIGRlY2xhcmVkLCB3ZSBoYXZlIHRvIHByb3ZpZGUgb3VyIG93biBleHBsaWNpdCB0ZXh0IGRpcmVjdGlvbiBzbyBvdXJcbiAgLy8gYmlkaXJlY3Rpb25hbCBDU1Mgc3R5bGUgc2hlZXRzIHdvcmsuXG4gIHdoaWxlIChlbGVtZW50ICYmICFlbGVtZW50LmRpcikge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGVcbiAgfVxuICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQuZGlyIDogdW5kZWZpbmVkXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGV4dERpcmVjdGlvblxuIiwiLyoqXG4gKiBSZXR1cm5zIGEgdGltZXN0YW1wIGluIHRoZSBmb3JtYXQgb2YgYGhvdXJzOm1pbnV0ZXM6c2Vjb25kc2BcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRUaW1lU3RhbXAgKCkge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKClcbiAgdmFyIGhvdXJzID0gcGFkKGRhdGUuZ2V0SG91cnMoKS50b1N0cmluZygpKVxuICB2YXIgbWludXRlcyA9IHBhZChkYXRlLmdldE1pbnV0ZXMoKS50b1N0cmluZygpKVxuICB2YXIgc2Vjb25kcyA9IHBhZChkYXRlLmdldFNlY29uZHMoKS50b1N0cmluZygpKVxuICByZXR1cm4gYCR7aG91cnN9OiR7bWludXRlc306JHtzZWNvbmRzfWBcbn1cblxuLyoqXG4gKiBBZGRzIHplcm8gdG8gc3RyaW5ncyBzaG9ydGVyIHRoYW4gdHdvIGNoYXJhY3RlcnNcbiAqL1xuZnVuY3Rpb24gcGFkIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5sZW5ndGggIT09IDIgPyAwICsgc3RyIDogc3RyXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhcyAob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSlcbn1cbiIsIi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgRE9NIGVsZW1lbnQuIER1Y2stdHlwaW5nIGJhc2VkIG9uIGBub2RlVHlwZWAuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RPTUVsZW1lbnQgKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREVcbn1cbiIsIi8qKlxuICogQ2hlY2tzIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIERyYWcgJiBEcm9wIChub3Qgc3VwcG9ydGVkIG9uIG1vYmlsZSBkZXZpY2VzLCBmb3IgZXhhbXBsZSkuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEcmFnRHJvcFN1cHBvcnRlZCAoKSB7XG4gIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgaWYgKCEoJ2RyYWdnYWJsZScgaW4gZGl2KSB8fCAhKCdvbmRyYWdzdGFydCcgaW4gZGl2ICYmICdvbmRyb3AnIGluIGRpdikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmICghKCdGb3JtRGF0YScgaW4gd2luZG93KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKCEoJ0ZpbGVSZWFkZXInIGluIHdpbmRvdykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCJmdW5jdGlvbiBpc05ldHdvcmtFcnJvciAoeGhyKSB7XG4gIGlmICgheGhyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuICh4aHIucmVhZHlTdGF0ZSAhPT0gMCAmJiB4aHIucmVhZHlTdGF0ZSAhPT0gNCkgfHwgeGhyLnN0YXR1cyA9PT0gMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTmV0d29ya0Vycm9yXG4iLCIvKipcbiAqIENoZWNrIGlmIGEgVVJMIHN0cmluZyBpcyBhbiBvYmplY3QgVVJMIGZyb20gYFVSTC5jcmVhdGVPYmplY3RVUkxgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT2JqZWN0VVJMICh1cmwpIHtcbiAgcmV0dXJuIHVybC5pbmRleE9mKCdibG9iOicpID09PSAwXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUHJldmlld1N1cHBvcnRlZCAoZmlsZVR5cGUpIHtcbiAgaWYgKCFmaWxlVHlwZSkgcmV0dXJuIGZhbHNlXG4gIGNvbnN0IGZpbGVUeXBlU3BlY2lmaWMgPSBmaWxlVHlwZS5zcGxpdCgnLycpWzFdXG4gIC8vIGxpc3Qgb2YgaW1hZ2VzIHRoYXQgYnJvd3NlcnMgY2FuIHByZXZpZXdcbiAgaWYgKC9eKGpwZT9nfGdpZnxwbmd8c3ZnfHN2Z1xcK3htbHxibXB8d2VicHxhdmlmKSQvLnRlc3QoZmlsZVR5cGVTcGVjaWZpYykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuIiwiLy8gX19fV2h5IG5vdCBhZGQgdGhlIG1pbWUtdHlwZXMgcGFja2FnZT9cbi8vICAgIEl0J3MgMTkuN2tCIGd6aXBwZWQsIGFuZCB3ZSBvbmx5IG5lZWQgbWltZSB0eXBlcyBmb3Igd2VsbC1rbm93biBleHRlbnNpb25zIChmb3IgZmlsZSBwcmV2aWV3cykuXG4vLyBfX19XaGVyZSB0byB0YWtlIG5ldyBleHRlbnNpb25zIGZyb20/XG4vLyAgICBodHRwczovL2dpdGh1Yi5jb20vanNodHRwL21pbWUtZGIvYmxvYi9tYXN0ZXIvZGIuanNvblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWQ6ICd0ZXh0L21hcmtkb3duJyxcbiAgbWFya2Rvd246ICd0ZXh0L21hcmtkb3duJyxcbiAgbXA0OiAndmlkZW8vbXA0JyxcbiAgbXAzOiAnYXVkaW8vbXAzJyxcbiAgc3ZnOiAnaW1hZ2Uvc3ZnK3htbCcsXG4gIGpwZzogJ2ltYWdlL2pwZWcnLFxuICBwbmc6ICdpbWFnZS9wbmcnLFxuICBnaWY6ICdpbWFnZS9naWYnLFxuICBoZWljOiAnaW1hZ2UvaGVpYycsXG4gIGhlaWY6ICdpbWFnZS9oZWlmJyxcbiAgeWFtbDogJ3RleHQveWFtbCcsXG4gIHltbDogJ3RleHQveWFtbCcsXG4gIGNzdjogJ3RleHQvY3N2JyxcbiAgdHN2OiAndGV4dC90YWItc2VwYXJhdGVkLXZhbHVlcycsXG4gIHRhYjogJ3RleHQvdGFiLXNlcGFyYXRlZC12YWx1ZXMnLFxuICBhdmk6ICd2aWRlby94LW1zdmlkZW8nLFxuICBta3M6ICd2aWRlby94LW1hdHJvc2thJyxcbiAgbWt2OiAndmlkZW8veC1tYXRyb3NrYScsXG4gIG1vdjogJ3ZpZGVvL3F1aWNrdGltZScsXG4gIGRvYzogJ2FwcGxpY2F0aW9uL21zd29yZCcsXG4gIGRvY206ICdhcHBsaWNhdGlvbi92bmQubXMtd29yZC5kb2N1bWVudC5tYWNyb2VuYWJsZWQuMTInLFxuICBkb2N4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICBkb3Q6ICdhcHBsaWNhdGlvbi9tc3dvcmQnLFxuICBkb3RtOiAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmQudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyJyxcbiAgZG90eDogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnRlbXBsYXRlJyxcbiAgeGxhOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgeGxhbTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5hZGRpbi5tYWNyb2VuYWJsZWQuMTInLFxuICB4bGM6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB4bGY6ICdhcHBsaWNhdGlvbi94LXhsaWZmK3htbCcsXG4gIHhsbTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsXG4gIHhsczogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsXG4gIHhsc2I6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQuYmluYXJ5Lm1hY3JvZW5hYmxlZC4xMicsXG4gIHhsc206ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQubWFjcm9lbmFibGVkLjEyJyxcbiAgeGxzeDogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0JyxcbiAgeGx0OiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgeGx0bTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTInLFxuICB4bHR4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwudGVtcGxhdGUnLFxuICB4bHc6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB0eHQ6ICd0ZXh0L3BsYWluJyxcbiAgdGV4dDogJ3RleHQvcGxhaW4nLFxuICBjb25mOiAndGV4dC9wbGFpbicsXG4gIGxvZzogJ3RleHQvcGxhaW4nLFxuICBwZGY6ICdhcHBsaWNhdGlvbi9wZGYnLFxuICB6aXA6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAnN3onOiAnYXBwbGljYXRpb24veC03ei1jb21wcmVzc2VkJyxcbiAgcmFyOiAnYXBwbGljYXRpb24veC1yYXItY29tcHJlc3NlZCcsXG4gIHRhcjogJ2FwcGxpY2F0aW9uL3gtdGFyJyxcbiAgZ3o6ICdhcHBsaWNhdGlvbi9nemlwJyxcbiAgZG1nOiAnYXBwbGljYXRpb24veC1hcHBsZS1kaXNraW1hZ2UnLFxufVxuIiwiY29uc3Qgc2Vjb25kc1RvVGltZSA9IHJlcXVpcmUoJy4vc2Vjb25kc1RvVGltZScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJldHR5RVRBIChzZWNvbmRzKSB7XG4gIGNvbnN0IHRpbWUgPSBzZWNvbmRzVG9UaW1lKHNlY29uZHMpXG5cbiAgLy8gT25seSBkaXNwbGF5IGhvdXJzIGFuZCBtaW51dGVzIGlmIHRoZXkgYXJlIGdyZWF0ZXIgdGhhbiAwIGJ1dCBhbHdheXNcbiAgLy8gZGlzcGxheSBtaW51dGVzIGlmIGhvdXJzIGlzIGJlaW5nIGRpc3BsYXllZFxuICAvLyBEaXNwbGF5IGEgbGVhZGluZyB6ZXJvIGlmIHRoZSB0aGVyZSBpcyBhIHByZWNlZGluZyB1bml0OiAxbSAwNXMsIGJ1dCA1c1xuICBjb25zdCBob3Vyc1N0ciA9IHRpbWUuaG91cnMgPyBgJHt0aW1lLmhvdXJzfWggYCA6ICcnXG4gIGNvbnN0IG1pbnV0ZXNWYWwgPSB0aW1lLmhvdXJzID8gKGAwJHt0aW1lLm1pbnV0ZXN9YCkuc3Vic3RyKC0yKSA6IHRpbWUubWludXRlc1xuICBjb25zdCBtaW51dGVzU3RyID0gbWludXRlc1ZhbCA/IGAke21pbnV0ZXNWYWx9bWAgOiAnJ1xuICBjb25zdCBzZWNvbmRzVmFsID0gbWludXRlc1ZhbCA/IChgMCR7dGltZS5zZWNvbmRzfWApLnN1YnN0cigtMikgOiB0aW1lLnNlY29uZHNcbiAgY29uc3Qgc2Vjb25kc1N0ciA9IHRpbWUuaG91cnMgPyAnJyA6IChtaW51dGVzVmFsID8gYCAke3NlY29uZHNWYWx9c2AgOiBgJHtzZWNvbmRzVmFsfXNgKVxuXG4gIHJldHVybiBgJHtob3Vyc1N0cn0ke21pbnV0ZXNTdHJ9JHtzZWNvbmRzU3RyfWBcbn1cbiIsImNvbnN0IGdldEZpbGVOYW1lQW5kRXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9nZXRGaWxlTmFtZUFuZEV4dGVuc2lvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVtb3RlRmlsZU9ialRvTG9jYWwgKGZpbGUpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5maWxlLFxuICAgIHR5cGU6IGZpbGUubWltZVR5cGUsXG4gICAgZXh0ZW5zaW9uOiBmaWxlLm5hbWUgPyBnZXRGaWxlTmFtZUFuZEV4dGVuc2lvbihmaWxlLm5hbWUpLmV4dGVuc2lvbiA6IG51bGwsXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2Vjb25kc1RvVGltZSAocmF3U2Vjb25kcykge1xuICBjb25zdCBob3VycyA9IE1hdGguZmxvb3IocmF3U2Vjb25kcyAvIDM2MDApICUgMjRcbiAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IocmF3U2Vjb25kcyAvIDYwKSAlIDYwXG4gIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKHJhd1NlY29uZHMgJSA2MClcblxuICByZXR1cm4geyBob3VycywgbWludXRlcywgc2Vjb25kcyB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZSAocHJvbWlzZXMpIHtcbiAgY29uc3QgcmVzb2x1dGlvbnMgPSBbXVxuICBjb25zdCByZWplY3Rpb25zID0gW11cbiAgZnVuY3Rpb24gcmVzb2x2ZWQgKHZhbHVlKSB7XG4gICAgcmVzb2x1dGlvbnMucHVzaCh2YWx1ZSlcbiAgfVxuICBmdW5jdGlvbiByZWplY3RlZCAoZXJyb3IpIHtcbiAgICByZWplY3Rpb25zLnB1c2goZXJyb3IpXG4gIH1cblxuICBjb25zdCB3YWl0ID0gUHJvbWlzZS5hbGwoXG4gICAgcHJvbWlzZXMubWFwKChwcm9taXNlKSA9PiBwcm9taXNlLnRoZW4ocmVzb2x2ZWQsIHJlamVjdGVkKSlcbiAgKVxuXG4gIHJldHVybiB3YWl0LnRoZW4oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzZnVsOiByZXNvbHV0aW9ucyxcbiAgICAgIGZhaWxlZDogcmVqZWN0aW9ucyxcbiAgICB9XG4gIH0pXG59XG4iLCIvKipcbiAqIENvbnZlcnRzIGxpc3QgaW50byBhcnJheVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QgfHwgW10sIDApXG59XG4iLCIvKipcbiAqIFRydW5jYXRlcyBhIHN0cmluZyB0byB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGNoYXJzIChtYXhMZW5ndGgpIGJ5IGluc2VydGluZyAnLi4uJyBpbiB0aGUgbWlkZGxlIG9mIHRoYXQgc3RyaW5nLlxuICogUGFydGlhbGx5IHRha2VuIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU3MjMyNzQvMzE5MjQ3MC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gc3RyaW5nIHRvIGJlIHRydW5jYXRlZFxuICogQHBhcmFtIHtudW1iZXJ9IG1heExlbmd0aCAtIG1heGltdW0gc2l6ZSBvZiB0aGUgcmVzdWx0aW5nIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cnVuY2F0ZVN0cmluZyAoc3RyaW5nLCBtYXhMZW5ndGgpIHtcbiAgY29uc3Qgc2VwYXJhdG9yID0gJy4uLidcblxuICAvLyBSZXR1cm4gb3JpZ2luYWwgc3RyaW5nIGlmIGl0J3MgYWxyZWFkeSBzaG9ydGVyIHRoYW4gbWF4TGVuZ3RoXG4gIGlmIChzdHJpbmcubGVuZ3RoIDw9IG1heExlbmd0aCkge1xuICAgIHJldHVybiBzdHJpbmdcbiAgLy8gUmV0dXJuIHRydW5jYXRlZCBzdWJzdHJpbmcgd2l0aG91dCAnLi4uJyBpZiBzdHJpbmcgY2FuJ3QgYmUgbWVhbmluZ2Z1bGx5IHRydW5jYXRlZFxuICB9IGlmIChtYXhMZW5ndGggPD0gc2VwYXJhdG9yLmxlbmd0aCkge1xuICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIG1heExlbmd0aClcbiAgLy8gUmV0dXJuIHRydW5jYXRlZCBzdHJpbmcgZGl2aWRlZCBpbiBoYWxmIGJ5ICcuLi4nXG4gIH1cbiAgY29uc3QgY2hhcnNUb1Nob3cgPSBtYXhMZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoXG4gIGNvbnN0IGZyb250Q2hhcnMgPSBNYXRoLmNlaWwoY2hhcnNUb1Nob3cgLyAyKVxuICBjb25zdCBiYWNrQ2hhcnMgPSBNYXRoLmZsb29yKGNoYXJzVG9TaG93IC8gMilcblxuICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCBmcm9udENoYXJzKSArIHNlcGFyYXRvciArIHN0cmluZy5zdWJzdHIoc3RyaW5nLmxlbmd0aCAtIGJhY2tDaGFycylcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvd2ViY2FtXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJVcHB5IHBsdWdpbiB0aGF0IHRha2VzIHBob3RvcyBvciByZWNvcmRzIHZpZGVvcyB1c2luZyB0aGUgZGV2aWNlJ3MgY2FtZXJhLlwiLFxuICBcInZlcnNpb25cIjogXCIxLjguMTJcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInN0eWxlXCI6IFwiZGlzdC9zdHlsZS5taW4uY3NzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcIndlYmNhbVwiLFxuICAgIFwicGljdHVyZVwiLFxuICAgIFwicGhvdG9cIixcbiAgICBcInZpZGVvXCIsXG4gICAgXCJyZWNvcmRcIixcbiAgICBcIm1lZGlhcmVjb3JkZXJcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgZmlsbD1cIiMwMDk3RENcIiB3aWR0aD1cIjY2XCIgaGVpZ2h0PVwiNTVcIiB2aWV3Qm94PVwiMCAwIDY2IDU1XCI+XG4gICAgICA8cGF0aCBkPVwiTTU3LjMgOC40MzNjNC41OSAwIDguMSAzLjUxIDguMSA4LjF2MjkuN2MwIDQuNTktMy41MSA4LjEtOC4xIDguMUg4LjdjLTQuNTkgMC04LjEtMy41MS04LjEtOC4xdi0yOS43YzAtNC41OSAzLjUxLTguMSA4LjEtOC4xaDkuNDVsNC41OS03LjAyYy41NC0uNTQgMS4zNS0xLjA4IDIuMTYtMS4wOGgxNi4yYy44MSAwIDEuNjIuNTQgMi4xNiAxLjA4bDQuNTkgNy4wMmg5LjQ1ek0zMyAxNC42NGMtOC42MiAwLTE1LjM5MyA2Ljc3My0xNS4zOTMgMTUuMzkzIDAgOC42MiA2Ljc3MyAxNS4zOTMgMTUuMzkzIDE1LjM5MyA4LjYyIDAgMTUuMzkzLTYuNzczIDE1LjM5My0xNS4zOTMgMC04LjYyLTYuNzczLTE1LjM5My0xNS4zOTMtMTUuMzkzek0zMyA0MGMtNS42NDggMC05Ljk2Ni00LjMxOS05Ljk2Ni05Ljk2NyAwLTUuNjQ3IDQuMzE4LTkuOTY2IDkuOTY2LTkuOTY2czkuOTY2IDQuMzE5IDkuOTY2IDkuOTY2QzQyLjk2NiAzNS42ODEgMzguNjQ4IDQwIDMzIDQwelwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIGpzeC1hMTF5L21lZGlhLWhhcy1jYXB0aW9uICovXG5jb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IFNuYXBzaG90QnV0dG9uID0gcmVxdWlyZSgnLi9TbmFwc2hvdEJ1dHRvbicpXG5jb25zdCBSZWNvcmRCdXR0b24gPSByZXF1aXJlKCcuL1JlY29yZEJ1dHRvbicpXG5jb25zdCBSZWNvcmRpbmdMZW5ndGggPSByZXF1aXJlKCcuL1JlY29yZGluZ0xlbmd0aCcpXG5jb25zdCBWaWRlb1NvdXJjZVNlbGVjdCA9IHJlcXVpcmUoJy4vVmlkZW9Tb3VyY2VTZWxlY3QnKVxuY29uc3QgU3VibWl0QnV0dG9uID0gcmVxdWlyZSgnLi9TdWJtaXRCdXR0b24nKVxuY29uc3QgRGlzY2FyZEJ1dHRvbiA9IHJlcXVpcmUoJy4vRGlzY2FyZEJ1dHRvbicpXG5cbmZ1bmN0aW9uIGlzTW9kZUF2YWlsYWJsZSAobW9kZXMsIG1vZGUpIHtcbiAgcmV0dXJuIG1vZGVzLmluZGV4T2YobW9kZSkgIT09IC0xXG59XG5cbmNsYXNzIENhbWVyYVNjcmVlbiBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBjb25zdCB7IG9uRm9jdXMgfSA9IHRoaXMucHJvcHNcbiAgICBvbkZvY3VzKClcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICBjb25zdCB7IG9uU3RvcCB9ID0gdGhpcy5wcm9wc1xuICAgIG9uU3RvcCgpXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNyYyxcbiAgICAgIHJlY29yZGVkVmlkZW8sXG4gICAgICByZWNvcmRpbmcsXG4gICAgICBtb2RlcyxcbiAgICAgIHN1cHBvcnRzUmVjb3JkaW5nLFxuICAgICAgdmlkZW9Tb3VyY2VzLFxuICAgICAgc2hvd1ZpZGVvU291cmNlRHJvcGRvd24sXG4gICAgICBzaG93UmVjb3JkaW5nTGVuZ3RoLFxuICAgICAgb25TdWJtaXQsXG4gICAgICBpMThuLFxuICAgICAgbWlycm9yLFxuICAgICAgb25TbmFwc2hvdCxcbiAgICAgIG9uU3RhcnRSZWNvcmRpbmcsXG4gICAgICBvblN0b3BSZWNvcmRpbmcsXG4gICAgICBvbkRpc2NhcmRSZWNvcmRlZFZpZGVvLFxuICAgICAgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kcyxcbiAgICB9ID0gdGhpcy5wcm9wc1xuXG4gICAgY29uc3QgaGFzUmVjb3JkZWRWaWRlbyA9ICEhcmVjb3JkZWRWaWRlb1xuICAgIGNvbnN0IHNob3VsZFNob3dSZWNvcmRCdXR0b24gPSAhaGFzUmVjb3JkZWRWaWRlbyAmJiBzdXBwb3J0c1JlY29yZGluZyAmJiAoXG4gICAgICBpc01vZGVBdmFpbGFibGUobW9kZXMsICd2aWRlby1vbmx5JylcbiAgICAgIHx8IGlzTW9kZUF2YWlsYWJsZShtb2RlcywgJ2F1ZGlvLW9ubHknKVxuICAgICAgfHwgaXNNb2RlQXZhaWxhYmxlKG1vZGVzLCAndmlkZW8tYXVkaW8nKVxuICAgIClcbiAgICBjb25zdCBzaG91bGRTaG93U25hcHNob3RCdXR0b24gPSAhaGFzUmVjb3JkZWRWaWRlbyAmJiBpc01vZGVBdmFpbGFibGUobW9kZXMsICdwaWN0dXJlJylcbiAgICBjb25zdCBzaG91bGRTaG93UmVjb3JkaW5nTGVuZ3RoID0gc3VwcG9ydHNSZWNvcmRpbmcgJiYgc2hvd1JlY29yZGluZ0xlbmd0aFxuICAgIGNvbnN0IHNob3VsZFNob3dWaWRlb1NvdXJjZURyb3Bkb3duID0gc2hvd1ZpZGVvU291cmNlRHJvcGRvd24gJiYgdmlkZW9Tb3VyY2VzICYmIHZpZGVvU291cmNlcy5sZW5ndGggPiAxXG5cbiAgICBjb25zdCB2aWRlb1Byb3BzID0ge1xuICAgICAgcGxheXNpbmxpbmU6IHRydWUsXG4gICAgfVxuXG4gICAgaWYgKHJlY29yZGVkVmlkZW8pIHtcbiAgICAgIHZpZGVvUHJvcHMubXV0ZWQgPSBmYWxzZVxuICAgICAgdmlkZW9Qcm9wcy5jb250cm9scyA9IHRydWVcbiAgICAgIHZpZGVvUHJvcHMuc3JjID0gcmVjb3JkZWRWaWRlb1xuXG4gICAgICAvLyByZXNldCBzcmNPYmplY3QgaW4gZG9tLiBJZiBub3QgcmVzZXR0ZWQsIHN0cmVhbSBzdGlja3MgaW4gZWxlbWVudFxuICAgICAgaWYgKHRoaXMudmlkZW9FbGVtZW50KSB7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnNyY09iamVjdCA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb1Byb3BzLm11dGVkID0gdHJ1ZVxuICAgICAgdmlkZW9Qcm9wcy5hdXRvcGxheSA9IHRydWVcbiAgICAgIHZpZGVvUHJvcHMuc3JjT2JqZWN0ID0gc3JjXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweSB1cHB5LVdlYmNhbS1jb250YWluZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVdlYmNhbS12aWRlb0NvbnRhaW5lclwiPlxuICAgICAgICAgIDx2aWRlb1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJldHVybi1hc3NpZ24gKi9cbiAgICAgICAgICAgIHJlZj17KHZpZGVvRWxlbWVudCkgPT4gKHRoaXMudmlkZW9FbGVtZW50ID0gdmlkZW9FbGVtZW50KX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17YHVwcHktV2ViY2FtLXZpZGVvICAke21pcnJvciA/ICd1cHB5LVdlYmNhbS12aWRlby0tbWlycm9yZWQnIDogJyd9YH1cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtcHJvcHMtbm8tc3ByZWFkaW5nICovXG4gICAgICAgICAgICB7Li4udmlkZW9Qcm9wc31cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVdlYmNhbS1mb290ZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLXZpZGVvU291cmNlQ29udGFpbmVyXCI+XG4gICAgICAgICAgICB7c2hvdWxkU2hvd1ZpZGVvU291cmNlRHJvcGRvd25cbiAgICAgICAgICAgICAgPyBWaWRlb1NvdXJjZVNlbGVjdCh0aGlzLnByb3BzKVxuICAgICAgICAgICAgICA6IG51bGx9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVdlYmNhbS1idXR0b25Db250YWluZXJcIj5cbiAgICAgICAgICAgIHtzaG91bGRTaG93U25hcHNob3RCdXR0b24gJiYgPFNuYXBzaG90QnV0dG9uIG9uU25hcHNob3Q9e29uU25hcHNob3R9IGkxOG49e2kxOG59IC8+fVxuXG4gICAgICAgICAgICB7c2hvdWxkU2hvd1JlY29yZEJ1dHRvbiAmJiAoXG4gICAgICAgICAgICAgIDxSZWNvcmRCdXR0b25cbiAgICAgICAgICAgICAgICByZWNvcmRpbmc9e3JlY29yZGluZ31cbiAgICAgICAgICAgICAgICBvblN0YXJ0UmVjb3JkaW5nPXtvblN0YXJ0UmVjb3JkaW5nfVxuICAgICAgICAgICAgICAgIG9uU3RvcFJlY29yZGluZz17b25TdG9wUmVjb3JkaW5nfVxuICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApfVxuXG4gICAgICAgICAgICB7aGFzUmVjb3JkZWRWaWRlbyAmJiA8U3VibWl0QnV0dG9uIG9uU3VibWl0PXtvblN1Ym1pdH0gaTE4bj17aTE4bn0gLz59XG5cbiAgICAgICAgICAgIHtoYXNSZWNvcmRlZFZpZGVvICYmIDxEaXNjYXJkQnV0dG9uIG9uRGlzY2FyZD17b25EaXNjYXJkUmVjb3JkZWRWaWRlb30gaTE4bj17aTE4bn0gLz59XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICB7c2hvdWxkU2hvd1JlY29yZGluZ0xlbmd0aCAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLXJlY29yZGluZ0xlbmd0aFwiPlxuICAgICAgICAgICAgICA8UmVjb3JkaW5nTGVuZ3RoIHJlY29yZGluZ0xlbmd0aFNlY29uZHM9e3JlY29yZGluZ0xlbmd0aFNlY29uZHN9IGkxOG49e2kxOG59IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhbWVyYVNjcmVlblxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5mdW5jdGlvbiBEaXNjYXJkQnV0dG9uICh7IG9uRGlzY2FyZCwgaTE4biB9KSB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1XZWJjYW0tYnV0dG9uXCJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgdGl0bGU9e2kxOG4oJ2Rpc2NhcmRSZWNvcmRlZEZpbGUnKX1cbiAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ2Rpc2NhcmRSZWNvcmRlZEZpbGUnKX1cbiAgICAgIG9uQ2xpY2s9e29uRGlzY2FyZH1cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICA8c3ZnXG4gICAgICAgIHdpZHRoPVwiMTNcIlxuICAgICAgICBoZWlnaHQ9XCIxM1wiXG4gICAgICAgIHZpZXdCb3g9XCIwIDAgMTMgMTNcIlxuICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiXG4gICAgICA+XG4gICAgICAgIDxnIGZpbGw9XCIjRkZGXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHBhdGggZD1cIk0uNDk2IDExLjM2N0wxMS4xMDMuNzZsMS40MTQgMS40MTRMMS45MTEgMTIuNzgxelwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMS4xMDQgMTIuNzgyTC40OTcgMi4xNzUgMS45MTEuNzZsMTAuNjA3IDEwLjYwNnpcIiAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L3N2Zz5cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc2NhcmRCdXR0b25cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLXBlcm1pc3NvbnNcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1XZWJjYW0tcGVybWlzc29uc0ljb25cIj57cHJvcHMuaWNvbigpfTwvZGl2PlxuICAgICAgPGgxIGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLXRpdGxlXCI+e3Byb3BzLmhhc0NhbWVyYSA/IHByb3BzLmkxOG4oJ2FsbG93QWNjZXNzVGl0bGUnKSA6IHByb3BzLmkxOG4oJ25vQ2FtZXJhVGl0bGUnKX08L2gxPlxuICAgICAgPHA+e3Byb3BzLmhhc0NhbWVyYSA/IHByb3BzLmkxOG4oJ2FsbG93QWNjZXNzRGVzY3JpcHRpb24nKSA6IHByb3BzLmkxOG4oJ25vQ2FtZXJhRGVzY3JpcHRpb24nKX08L3A+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSZWNvcmRCdXR0b24gKHsgcmVjb3JkaW5nLCBvblN0YXJ0UmVjb3JkaW5nLCBvblN0b3BSZWNvcmRpbmcsIGkxOG4gfSkge1xuICBpZiAocmVjb3JkaW5nKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1XZWJjYW0tYnV0dG9uXCJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIHRpdGxlPXtpMThuKCdzdG9wUmVjb3JkaW5nJyl9XG4gICAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3N0b3BSZWNvcmRpbmcnKX1cbiAgICAgICAgb25DbGljaz17b25TdG9wUmVjb3JkaW5nfVxuICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICA+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgdmlld0JveD1cIjAgMCAxMDAgMTAwXCI+XG4gICAgICAgICAgPHJlY3QgeD1cIjE1XCIgeT1cIjE1XCIgd2lkdGg9XCI3MFwiIGhlaWdodD1cIjcwXCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktV2ViY2FtLWJ1dHRvblwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIHRpdGxlPXtpMThuKCdzdGFydFJlY29yZGluZycpfVxuICAgICAgYXJpYS1sYWJlbD17aTE4bignc3RhcnRSZWNvcmRpbmcnKX1cbiAgICAgIG9uQ2xpY2s9e29uU3RhcnRSZWNvcmRpbmd9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIj5cbiAgICAgICAgPGNpcmNsZSBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCI0MFwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgZm9ybWF0U2Vjb25kcyA9IHJlcXVpcmUoJy4vZm9ybWF0U2Vjb25kcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUmVjb3JkaW5nTGVuZ3RoICh7IHJlY29yZGluZ0xlbmd0aFNlY29uZHMsIGkxOG4gfSkge1xuICBjb25zdCBmb3JtYXR0ZWRSZWNvcmRpbmdMZW5ndGhTZWNvbmRzID0gZm9ybWF0U2Vjb25kcyhyZWNvcmRpbmdMZW5ndGhTZWNvbmRzKVxuXG4gIHJldHVybiAoXG4gICAgPHNwYW4gYXJpYS1sYWJlbD17aTE4bigncmVjb3JkaW5nTGVuZ3RoJywgeyByZWNvcmRpbmdfbGVuZ3RoOiBmb3JtYXR0ZWRSZWNvcmRpbmdMZW5ndGhTZWNvbmRzIH0pfT5cbiAgICAgIHtmb3JtYXR0ZWRSZWNvcmRpbmdMZW5ndGhTZWNvbmRzfVxuICAgIDwvc3Bhbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgQ2FtZXJhSWNvbiA9IHJlcXVpcmUoJy4vQ2FtZXJhSWNvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gKHsgb25TbmFwc2hvdCwgaTE4biB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1XZWJjYW0tYnV0dG9uIHVwcHktV2ViY2FtLWJ1dHRvbi0tcGljdHVyZVwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIHRpdGxlPXtpMThuKCd0YWtlUGljdHVyZScpfVxuICAgICAgYXJpYS1sYWJlbD17aTE4bigndGFrZVBpY3R1cmUnKX1cbiAgICAgIG9uQ2xpY2s9e29uU25hcHNob3R9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAge0NhbWVyYUljb24oKX1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5mdW5jdGlvbiBTdWJtaXRCdXR0b24gKHsgb25TdWJtaXQsIGkxOG4gfSkge1xuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktV2ViY2FtLWJ1dHRvbiB1cHB5LVdlYmNhbS1idXR0b24tLXN1Ym1pdFwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIHRpdGxlPXtpMThuKCdzdWJtaXRSZWNvcmRlZEZpbGUnKX1cbiAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3N1Ym1pdFJlY29yZGVkRmlsZScpfVxuICAgICAgb25DbGljaz17b25TdWJtaXR9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAgPHN2Z1xuICAgICAgICB3aWR0aD1cIjEyXCJcbiAgICAgICAgaGVpZ2h0PVwiOVwiXG4gICAgICAgIHZpZXdCb3g9XCIwIDAgMTIgOVwiXG4gICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCJcbiAgICAgID5cbiAgICAgICAgPHBhdGggZmlsbD1cIiNmZmZcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiBkPVwiTTEwLjY2IDBMMTIgMS4zMSA0LjEzNiA5IDAgNC45NTZsMS4zNC0xLjMxTDQuMTM2IDYuMzh6XCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3VibWl0QnV0dG9uXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gKHsgY3VycmVudERldmljZUlkLCB2aWRlb1NvdXJjZXMsIG9uQ2hhbmdlVmlkZW9Tb3VyY2UgfSkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1XZWJjYW0tdmlkZW9Tb3VyY2VcIj5cbiAgICAgIDxzZWxlY3RcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktV2ViY2FtLXZpZGVvU291cmNlLXNlbGVjdFwiXG4gICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+IHsgb25DaGFuZ2VWaWRlb1NvdXJjZShldmVudC50YXJnZXQudmFsdWUpIH19XG4gICAgICA+XG4gICAgICAgIHt2aWRlb1NvdXJjZXMubWFwKCh2aWRlb1NvdXJjZSkgPT4gKFxuICAgICAgICAgIDxvcHRpb25cbiAgICAgICAgICAgIGtleT17dmlkZW9Tb3VyY2UuZGV2aWNlSWR9XG4gICAgICAgICAgICB2YWx1ZT17dmlkZW9Tb3VyY2UuZGV2aWNlSWR9XG4gICAgICAgICAgICBzZWxlY3RlZD17dmlkZW9Tb3VyY2UuZGV2aWNlSWQgPT09IGN1cnJlbnREZXZpY2VJZH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7dmlkZW9Tb3VyY2UubGFiZWx9XG4gICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgICkpfVxuICAgICAgPC9zZWxlY3Q+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsIi8qKlxuICogVGFrZXMgYW4gSW50ZWdlciB2YWx1ZSBvZiBzZWNvbmRzIChlLmcuIDgzKSBhbmQgY29udmVydHMgaXQgaW50byBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdHRlZCBzdHJpbmcgKGUuZy4gJzE6MjMnKS5cbiAqXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHNlY29uZHNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBmb3JtYXR0ZWQgc2Vjb25kcyAoZS5nLiAnMToyMycgZm9yIDEgbWludXRlIGFuZCAyMyBzZWNvbmRzKVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JtYXRTZWNvbmRzIChzZWNvbmRzKSB7XG4gIHJldHVybiBgJHtNYXRoLmZsb29yKFxuICAgIHNlY29uZHMgLyA2MFxuICApfToke1N0cmluZyhzZWNvbmRzICUgNjApLnBhZFN0YXJ0KDIsIDApfWBcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IFRyYW5zbGF0b3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvVHJhbnNsYXRvcicpXG5jb25zdCBnZXRGaWxlVHlwZUV4dGVuc2lvbiA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRGaWxlVHlwZUV4dGVuc2lvbicpXG5jb25zdCBtaW1lVHlwZXMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvbWltZVR5cGVzJylcbmNvbnN0IGNhbnZhc1RvQmxvYiA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9jYW52YXNUb0Jsb2InKVxuY29uc3Qgc3VwcG9ydHNNZWRpYVJlY29yZGVyID0gcmVxdWlyZSgnLi9zdXBwb3J0c01lZGlhUmVjb3JkZXInKVxuY29uc3QgQ2FtZXJhSWNvbiA9IHJlcXVpcmUoJy4vQ2FtZXJhSWNvbicpXG5jb25zdCBDYW1lcmFTY3JlZW4gPSByZXF1aXJlKCcuL0NhbWVyYVNjcmVlbicpXG5jb25zdCBQZXJtaXNzaW9uc1NjcmVlbiA9IHJlcXVpcmUoJy4vUGVybWlzc2lvbnNTY3JlZW4nKVxuY29uc3QgcGFja2FnZUpzb25WZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIE1JTUUgdHlwZSBvciBmaWxlIGV4dGVuc2lvbiBpbnRvIGEgTUlNRSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlVHlwZSAtIE1JTUUgdHlwZSBvciBhIGZpbGUgZXh0ZW5zaW9uIHByZWZpeGVkIHdpdGggYC5gLlxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFRoZSBNSU1FIHR5cGUgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIGZpbGVUeXBlIGlzIGFuIGV4dGVuc2lvbiBhbmQgaXMgbm90IGtub3duLlxuICovXG5mdW5jdGlvbiB0b01pbWVUeXBlIChmaWxlVHlwZSkge1xuICBpZiAoZmlsZVR5cGVbMF0gPT09ICcuJykge1xuICAgIHJldHVybiBtaW1lVHlwZXNbZmlsZVR5cGUuc2xpY2UoMSldXG4gIH1cbiAgcmV0dXJuIGZpbGVUeXBlXG59XG5cbi8qKlxuICogSXMgdGhpcyBNSU1FIHR5cGUgYSB2aWRlbz9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWltZVR5cGUgLSBNSU1FIHR5cGUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWaWRlb01pbWVUeXBlIChtaW1lVHlwZSkge1xuICByZXR1cm4gL152aWRlb1xcL1teKl0rJC8udGVzdChtaW1lVHlwZSlcbn1cblxuLyoqXG4gKiBJcyB0aGlzIE1JTUUgdHlwZSBhbiBpbWFnZT9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWltZVR5cGUgLSBNSU1FIHR5cGUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNJbWFnZU1pbWVUeXBlIChtaW1lVHlwZSkge1xuICByZXR1cm4gL15pbWFnZVxcL1teKl0rJC8udGVzdChtaW1lVHlwZSlcbn1cblxuLyoqXG4gKiBTZXR1cCBnZXRVc2VyTWVkaWEsIHdpdGggcG9seWZpbGwgZm9yIG9sZGVyIGJyb3dzZXJzXG4gKiBBZGFwdGVkIGZyb206IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYURldmljZXMvZ2V0VXNlck1lZGlhXG4gKi9cbmZ1bmN0aW9uIGdldE1lZGlhRGV2aWNlcyAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlc1xuICB9XG5cbiAgY29uc3QgZ2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhXG4gIGlmICghZ2V0VXNlck1lZGlhKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0VXNlck1lZGlhIChvcHRzKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBnZXRVc2VyTWVkaWEuY2FsbChuYXZpZ2F0b3IsIG9wdHMsIHJlc29sdmUsIHJlamVjdClcbiAgICAgIH0pXG4gICAgfSxcbiAgfVxufVxuLyoqXG4gKiBXZWJjYW1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBXZWJjYW0gZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHBhY2thZ2VKc29uVmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLm1lZGlhRGV2aWNlcyA9IGdldE1lZGlhRGV2aWNlcygpXG4gICAgdGhpcy5zdXBwb3J0c1VzZXJNZWRpYSA9ICEhdGhpcy5tZWRpYURldmljZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgdGhpcy5wcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sLm1hdGNoKC9odHRwcy9pKSA/ICdodHRwcycgOiAnaHR0cCdcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdXZWJjYW0nXG4gICAgdGhpcy50aXRsZSA9IHRoaXMub3B0cy50aXRsZSB8fCAnQ2FtZXJhJ1xuICAgIHRoaXMudHlwZSA9ICdhY3F1aXJlcidcbiAgICB0aGlzLmNhcHR1cmVkTWVkaWFGaWxlID0gbnVsbFxuICAgIHRoaXMuaWNvbiA9ICgpID0+IChcbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIGZpbGw9XCIjMDNCRkVGXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0yMiAxMWMxLjEzMyAwIDIgLjg2NyAyIDJ2Ny4zMzNjMCAxLjEzNC0uODY3IDItMiAySDEwYy0xLjEzMyAwLTItLjg2Ni0yLTJWMTNjMC0xLjEzMy44NjctMiAyLTJoMi4zMzNsMS4xMzQtMS43MzNDMTMuNiA5LjEzMyAxMy44IDkgMTQgOWg0Yy4yIDAgLjQuMTMzLjUzMy4yNjdMMTkuNjY3IDExSDIyem0tNiAxLjUzM2EzLjc2NCAzLjc2NCAwIDAgMC0zLjggMy44YzAgMi4xMjkgMS42NzIgMy44MDEgMy44IDMuODAxczMuOC0xLjY3MiAzLjgtMy44YzAtMi4xMy0xLjY3Mi0zLjgwMS0zLjgtMy44MDF6bTAgNi4yNjFjLTEuMzk1IDAtMi40Ni0xLjA2Ni0yLjQ2LTIuNDYgMC0xLjM5NSAxLjA2NS0yLjQ2MSAyLjQ2LTIuNDYxczIuNDYgMS4wNjYgMi40NiAyLjQ2YzAgMS4zOTUtMS4wNjUgMi40NjEtMi40NiAyLjQ2MXpcIiBmaWxsPVwiI0ZGRlwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IHtcbiAgICAgIHN0cmluZ3M6IHtcbiAgICAgICAgc21pbGU6ICdTbWlsZSEnLFxuICAgICAgICB0YWtlUGljdHVyZTogJ1Rha2UgYSBwaWN0dXJlJyxcbiAgICAgICAgc3RhcnRSZWNvcmRpbmc6ICdCZWdpbiB2aWRlbyByZWNvcmRpbmcnLFxuICAgICAgICBzdG9wUmVjb3JkaW5nOiAnU3RvcCB2aWRlbyByZWNvcmRpbmcnLFxuICAgICAgICBhbGxvd0FjY2Vzc1RpdGxlOiAnUGxlYXNlIGFsbG93IGFjY2VzcyB0byB5b3VyIGNhbWVyYScsXG4gICAgICAgIGFsbG93QWNjZXNzRGVzY3JpcHRpb246ICdJbiBvcmRlciB0byB0YWtlIHBpY3R1cmVzIG9yIHJlY29yZCB2aWRlbyB3aXRoIHlvdXIgY2FtZXJhLCBwbGVhc2UgYWxsb3cgY2FtZXJhIGFjY2VzcyBmb3IgdGhpcyBzaXRlLicsXG4gICAgICAgIG5vQ2FtZXJhVGl0bGU6ICdDYW1lcmEgTm90IEF2YWlsYWJsZScsXG4gICAgICAgIG5vQ2FtZXJhRGVzY3JpcHRpb246ICdJbiBvcmRlciB0byB0YWtlIHBpY3R1cmVzIG9yIHJlY29yZCB2aWRlbywgcGxlYXNlIGNvbm5lY3QgYSBjYW1lcmEgZGV2aWNlJyxcbiAgICAgICAgcmVjb3JkaW5nU3RvcHBlZE1heFNpemU6ICdSZWNvcmRpbmcgc3RvcHBlZCBiZWNhdXNlIHRoZSBmaWxlIHNpemUgaXMgYWJvdXQgdG8gZXhjZWVkIHRoZSBsaW1pdCcsXG4gICAgICAgIHJlY29yZGluZ0xlbmd0aDogJ1JlY29yZGluZyBsZW5ndGggJXtyZWNvcmRpbmdfbGVuZ3RofScsXG4gICAgICAgIHN1Ym1pdFJlY29yZGVkRmlsZTogJ1N1Ym1pdCByZWNvcmRlZCBmaWxlJyxcbiAgICAgICAgZGlzY2FyZFJlY29yZGVkRmlsZTogJ0Rpc2NhcmQgcmVjb3JkZWQgZmlsZScsXG4gICAgICB9LFxuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIG9uQmVmb3JlU25hcHNob3Q6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgY291bnRkb3duOiBmYWxzZSxcbiAgICAgIG1vZGVzOiBbXG4gICAgICAgICd2aWRlby1hdWRpbycsXG4gICAgICAgICd2aWRlby1vbmx5JyxcbiAgICAgICAgJ2F1ZGlvLW9ubHknLFxuICAgICAgICAncGljdHVyZScsXG4gICAgICBdLFxuICAgICAgbWlycm9yOiB0cnVlLFxuICAgICAgc2hvd1ZpZGVvU291cmNlRHJvcGRvd246IGZhbHNlLFxuICAgICAgZmFjaW5nTW9kZTogJ3VzZXInLFxuICAgICAgcHJlZmVycmVkSW1hZ2VNaW1lVHlwZTogbnVsbCxcbiAgICAgIHByZWZlcnJlZFZpZGVvTWltZVR5cGU6IG51bGwsXG4gICAgICBzaG93UmVjb3JkaW5nTGVuZ3RoOiBmYWxzZSxcbiAgICB9XG5cbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuXG4gICAgdGhpcy5pbnN0YWxsID0gdGhpcy5pbnN0YWxsLmJpbmQodGhpcylcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlID0gdGhpcy5zZXRQbHVnaW5TdGF0ZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcblxuICAgIC8vIENhbWVyYSBjb250cm9sc1xuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcylcbiAgICB0aGlzLnN0b3AgPSB0aGlzLnN0b3AuYmluZCh0aGlzKVxuICAgIHRoaXMudGFrZVNuYXBzaG90ID0gdGhpcy50YWtlU25hcHNob3QuYmluZCh0aGlzKVxuICAgIHRoaXMuc3RhcnRSZWNvcmRpbmcgPSB0aGlzLnN0YXJ0UmVjb3JkaW5nLmJpbmQodGhpcylcbiAgICB0aGlzLnN0b3BSZWNvcmRpbmcgPSB0aGlzLnN0b3BSZWNvcmRpbmcuYmluZCh0aGlzKVxuICAgIHRoaXMuZGlzY2FyZFJlY29yZGVkVmlkZW8gPSB0aGlzLmRpc2NhcmRSZWNvcmRlZFZpZGVvLmJpbmQodGhpcylcbiAgICB0aGlzLnN1Ym1pdCA9IHRoaXMuc3VibWl0LmJpbmQodGhpcylcbiAgICB0aGlzLm9uZVR3b1RocmVlU21pbGUgPSB0aGlzLm9uZVR3b1RocmVlU21pbGUuYmluZCh0aGlzKVxuICAgIHRoaXMuZm9jdXMgPSB0aGlzLmZvY3VzLmJpbmQodGhpcylcbiAgICB0aGlzLmNoYW5nZVZpZGVvU291cmNlID0gdGhpcy5jaGFuZ2VWaWRlb1NvdXJjZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLndlYmNhbUFjdGl2ZSA9IGZhbHNlXG5cbiAgICBpZiAodGhpcy5vcHRzLmNvdW50ZG93bikge1xuICAgICAgdGhpcy5vcHRzLm9uQmVmb3JlU25hcHNob3QgPSB0aGlzLm9uZVR3b1RocmVlU21pbGVcbiAgICB9XG5cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGhhc0NhbWVyYTogZmFsc2UsXG4gICAgICBjYW1lcmFSZWFkeTogZmFsc2UsXG4gICAgICBjYW1lcmFFcnJvcjogbnVsbCxcbiAgICAgIHJlY29yZGluZ0xlbmd0aFNlY29uZHM6IDAsXG4gICAgICB2aWRlb1NvdXJjZXM6IFtdLFxuICAgICAgY3VycmVudERldmljZUlkOiBudWxsLFxuICAgIH0pXG4gIH1cblxuICBzZXRPcHRpb25zIChuZXdPcHRzKSB7XG4gICAgc3VwZXIuc2V0T3B0aW9ucyh7XG4gICAgICAuLi5uZXdPcHRzLFxuICAgICAgdmlkZW9Db25zdHJhaW50czoge1xuICAgICAgICAvLyBNYXkgYmUgdW5kZWZpbmVkIGJ1dCAuLi4gaGFuZGxlcyB0aGF0XG4gICAgICAgIC4uLnRoaXMub3B0cy52aWRlb0NvbnN0cmFpbnRzLFxuICAgICAgICAuLi5uZXdPcHRzPy52aWRlb0NvbnN0cmFpbnRzLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgdGhpcy5pMThuSW5pdCgpXG4gIH1cblxuICBpMThuSW5pdCAoKSB7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoW3RoaXMuZGVmYXVsdExvY2FsZSwgdGhpcy51cHB5LmxvY2FsZSwgdGhpcy5vcHRzLmxvY2FsZV0pXG4gICAgdGhpcy5pMThuID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLmkxOG5BcnJheSA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGVBcnJheS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKCkgLy8gc28gdGhhdCBVSSByZS1yZW5kZXJzIGFuZCB3ZSBzZWUgdGhlIHVwZGF0ZWQgbG9jYWxlXG4gIH1cblxuICBoYXNDYW1lcmFDaGVjayAoKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhRGV2aWNlcykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpLnRoZW4oZGV2aWNlcyA9PiB7XG4gICAgICByZXR1cm4gZGV2aWNlcy5zb21lKGRldmljZSA9PiBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKVxuICAgIH0pXG4gIH1cblxuICBpc0F1ZGlvT25seSAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cy5tb2Rlcy5sZW5ndGggPT09IDEgJiYgdGhpcy5vcHRzLm1vZGVzWzBdID09PSAnYXVkaW8tb25seSdcbiAgfVxuXG4gIGdldENvbnN0cmFpbnRzIChkZXZpY2VJZCA9IG51bGwpIHtcbiAgICBjb25zdCBhY2NlcHRzQXVkaW8gPSB0aGlzLm9wdHMubW9kZXMuaW5kZXhPZigndmlkZW8tYXVkaW8nKSAhPT0gLTFcbiAgICAgIHx8IHRoaXMub3B0cy5tb2Rlcy5pbmRleE9mKCdhdWRpby1vbmx5JykgIT09IC0xXG4gICAgY29uc3QgYWNjZXB0c1ZpZGVvID0gIXRoaXMuaXNBdWRpb09ubHkoKVxuICAgICAgICAmJiAodGhpcy5vcHRzLm1vZGVzLmluZGV4T2YoJ3ZpZGVvLWF1ZGlvJykgIT09IC0xXG4gICAgICAgICAgfHwgdGhpcy5vcHRzLm1vZGVzLmluZGV4T2YoJ3ZpZGVvLW9ubHknKSAhPT0gLTFcbiAgICAgICAgICB8fCB0aGlzLm9wdHMubW9kZXMuaW5kZXhPZigncGljdHVyZScpICE9PSAtMSlcblxuICAgIGNvbnN0IHZpZGVvQ29uc3RyYWludHMgPSB7XG4gICAgICAuLi4odGhpcy5vcHRzLnZpZGVvQ29uc3RyYWludHMgPz8geyBmYWNpbmdNb2RlOiB0aGlzLm9wdHMuZmFjaW5nTW9kZSB9KSxcbiAgICAgIC8vIGZhY2luZ01vZGUgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGRldmljZUlkLCBhbmQgbm90IG5lZWRlZFxuICAgICAgLy8gd2hlbiBzcGVjaWZpYyBkZXZpY2UgaXMgc2VsZWN0ZWRcbiAgICAgIC4uLihkZXZpY2VJZCA/IHsgZGV2aWNlSWQsIGZhY2luZ01vZGU6IG51bGwgfSA6IHt9KSxcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW86IGFjY2VwdHNBdWRpbyxcbiAgICAgIHZpZGVvOiBhY2NlcHRzVmlkZW8gPyB2aWRlb0NvbnN0cmFpbnRzIDogZmFsc2UsXG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIHN0YXJ0IChvcHRpb25zID0gbnVsbCkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0c1VzZXJNZWRpYSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignV2ViY2FtIGFjY2VzcyBub3Qgc3VwcG9ydGVkJykpXG4gICAgfVxuXG4gICAgdGhpcy53ZWJjYW1BY3RpdmUgPSB0cnVlXG4gICAgdGhpcy5vcHRzLm1pcnJvciA9IHRydWVcblxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5nZXRDb25zdHJhaW50cyhvcHRpb25zICYmIG9wdGlvbnMuZGV2aWNlSWQgPyBvcHRpb25zLmRldmljZUlkIDogbnVsbClcblxuICAgIHRoaXMuaGFzQ2FtZXJhQ2hlY2soKS50aGVuKGhhc0NhbWVyYSA9PiB7XG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgaGFzQ2FtZXJhLFxuICAgICAgfSlcblxuICAgICAgLy8gYXNrIHVzZXIgZm9yIGFjY2VzcyB0byB0aGVpciBjYW1lcmFcbiAgICAgIHJldHVybiB0aGlzLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG4gICAgICAgIC50aGVuKChzdHJlYW0pID0+IHtcbiAgICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbVxuXG4gICAgICAgICAgbGV0IGN1cnJlbnREZXZpY2VJZCA9IG51bGxcbiAgICAgICAgICBjb25zdCB0cmFja3MgPSB0aGlzLmlzQXVkaW9Pbmx5KCkgPyBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKSA6IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpXG5cbiAgICAgICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuZGV2aWNlSWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnREZXZpY2VJZCA9IHRyYWNrc1swXS5nZXRTZXR0aW5ncygpLmRldmljZUlkXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgICBpZiAodHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZCA9PT0gb3B0aW9ucy5kZXZpY2VJZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2VJZCA9IHRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNvdXJjZXMgbm93LCBzbyB3ZSBjYW4gYWNjZXNzIHRoZSBuYW1lcy5cbiAgICAgICAgICB0aGlzLnVwZGF0ZVZpZGVvU291cmNlcygpXG5cbiAgICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICAgIGN1cnJlbnREZXZpY2VJZCxcbiAgICAgICAgICAgIGNhbWVyYVJlYWR5OiB0cnVlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgICBjYW1lcmFSZWFkeTogZmFsc2UsXG4gICAgICAgICAgICBjYW1lcmFFcnJvcjogZXJyLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy51cHB5LmluZm8oZXJyLm1lc3NhZ2UsICdlcnJvcicpXG4gICAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgZ2V0TWVkaWFSZWNvcmRlck9wdGlvbnMgKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7fVxuXG4gICAgLy8gVHJ5IHRvIHVzZSB0aGUgYG9wdHMucHJlZmVycmVkVmlkZW9NaW1lVHlwZWAgb3Igb25lIG9mIHRoZSBgYWxsb3dlZEZpbGVUeXBlc2AgZm9yIHRoZSByZWNvcmRpbmcuXG4gICAgLy8gSWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGl0LCB3ZSdsbCBmYWxsIGJhY2sgdG8gdGhlIGJyb3dzZXIgZGVmYXVsdCBpbnN0ZWFkLlxuICAgIC8vIFNhZmFyaSBkb2Vzbid0IGhhdmUgdGhlIGBpc1R5cGVTdXBwb3J0ZWRgIEFQSS5cbiAgICBpZiAoTWVkaWFSZWNvcmRlci5pc1R5cGVTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IHsgcmVzdHJpY3Rpb25zIH0gPSB0aGlzLnVwcHkub3B0c1xuICAgICAgbGV0IHByZWZlcnJlZFZpZGVvTWltZVR5cGVzID0gW11cbiAgICAgIGlmICh0aGlzLm9wdHMucHJlZmVycmVkVmlkZW9NaW1lVHlwZSkge1xuICAgICAgICBwcmVmZXJyZWRWaWRlb01pbWVUeXBlcyA9IFt0aGlzLm9wdHMucHJlZmVycmVkVmlkZW9NaW1lVHlwZV1cbiAgICAgIH0gZWxzZSBpZiAocmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXMpIHtcbiAgICAgICAgcHJlZmVycmVkVmlkZW9NaW1lVHlwZXMgPSByZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcy5tYXAodG9NaW1lVHlwZSkuZmlsdGVyKGlzVmlkZW9NaW1lVHlwZSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlsdGVyU3VwcG9ydGVkVHlwZXMgPSAoY2FuZGlkYXRlVHlwZSkgPT4gTWVkaWFSZWNvcmRlci5pc1R5cGVTdXBwb3J0ZWQoY2FuZGlkYXRlVHlwZSlcbiAgICAgICAgJiYgZ2V0RmlsZVR5cGVFeHRlbnNpb24oY2FuZGlkYXRlVHlwZSlcbiAgICAgIGNvbnN0IGFjY2VwdGFibGVNaW1lVHlwZXMgPSBwcmVmZXJyZWRWaWRlb01pbWVUeXBlcy5maWx0ZXIoZmlsdGVyU3VwcG9ydGVkVHlwZXMpXG5cbiAgICAgIGlmIChhY2NlcHRhYmxlTWltZVR5cGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIG9wdGlvbnMubWltZVR5cGUgPSBhY2NlcHRhYmxlTWltZVR5cGVzWzBdXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIHN0YXJ0UmVjb3JkaW5nICgpIHtcbiAgICAvLyBvbmx5IHVzZWQgaWYgc3VwcG9ydHNNZWRpYVJlY29yZGVyKCkgcmV0dXJuZWQgdHJ1ZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgdGhpcy5yZWNvcmRlciA9IG5ldyBNZWRpYVJlY29yZGVyKHRoaXMuc3RyZWFtLCB0aGlzLmdldE1lZGlhUmVjb3JkZXJPcHRpb25zKCkpXG4gICAgdGhpcy5yZWNvcmRpbmdDaHVua3MgPSBbXVxuICAgIGxldCBzdG9wcGluZ0JlY2F1c2VPZk1heFNpemUgPSBmYWxzZVxuICAgIHRoaXMucmVjb3JkZXIuYWRkRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5yZWNvcmRpbmdDaHVua3MucHVzaChldmVudC5kYXRhKVxuXG4gICAgICBjb25zdCB7IHJlc3RyaWN0aW9ucyB9ID0gdGhpcy51cHB5Lm9wdHNcbiAgICAgIGlmICh0aGlzLnJlY29yZGluZ0NodW5rcy5sZW5ndGggPiAxXG4gICAgICAgICAgJiYgcmVzdHJpY3Rpb25zLm1heEZpbGVTaXplICE9IG51bGxcbiAgICAgICAgICAmJiAhc3RvcHBpbmdCZWNhdXNlT2ZNYXhTaXplKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IHRoaXMucmVjb3JkaW5nQ2h1bmtzLnJlZHVjZSgoYWNjLCBjaHVuaykgPT4gYWNjICsgY2h1bmsuc2l6ZSwgMClcbiAgICAgICAgLy8gRXhjbHVkZSB0aGUgaW5pdGlhbCBjaHVuayBmcm9tIHRoZSBhdmVyYWdlIHNpemUgY2FsY3VsYXRpb24gYmVjYXVzZSBpdCBpcyBsaWtlbHkgdG8gYmUgYSB2ZXJ5IHNtYWxsIG91dGxpZXJcbiAgICAgICAgY29uc3QgYXZlcmFnZUNodW5rU2l6ZSA9ICh0b3RhbFNpemUgLSB0aGlzLnJlY29yZGluZ0NodW5rc1swXS5zaXplKSAvICh0aGlzLnJlY29yZGluZ0NodW5rcy5sZW5ndGggLSAxKVxuICAgICAgICBjb25zdCBleHBlY3RlZEVuZENodW5rU2l6ZSA9IGF2ZXJhZ2VDaHVua1NpemUgKiAzXG4gICAgICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heCgwLCByZXN0cmljdGlvbnMubWF4RmlsZVNpemUgLSBleHBlY3RlZEVuZENodW5rU2l6ZSlcblxuICAgICAgICBpZiAodG90YWxTaXplID4gbWF4U2l6ZSkge1xuICAgICAgICAgIHN0b3BwaW5nQmVjYXVzZU9mTWF4U2l6ZSA9IHRydWVcbiAgICAgICAgICB0aGlzLnVwcHkuaW5mbyh0aGlzLmkxOG4oJ3JlY29yZGluZ1N0b3BwZWRNYXhTaXplJyksICd3YXJuaW5nJywgNDAwMClcbiAgICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIHVzZSBhIFwidGltZSBzbGljZVwiIG9mIDUwMG1zOiBvbmRhdGFhdmFpbGFibGUgd2lsbCBiZSBjYWxsZWQgZWFjaCA1MDBtc1xuICAgIC8vIHNtYWxsZXIgdGltZSBzbGljZXMgbWVhbiB3ZSBjYW4gbW9yZSBhY2N1cmF0ZWx5IGNoZWNrIHRoZSBtYXggZmlsZSBzaXplIHJlc3RyaWN0aW9uXG4gICAgdGhpcy5yZWNvcmRlci5zdGFydCg1MDApXG5cbiAgICBpZiAodGhpcy5vcHRzLnNob3dSZWNvcmRpbmdMZW5ndGgpIHtcbiAgICAgIC8vIFN0YXJ0IHRoZSByZWNvcmRpbmdMZW5ndGhUaW1lciBpZiB3ZSBhcmUgc2hvd2luZyB0aGUgcmVjb3JkaW5nIGxlbmd0aC5cbiAgICAgIHRoaXMucmVjb3JkaW5nTGVuZ3RoVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSZWNvcmRpbmdMZW5ndGggPSB0aGlzLmdldFBsdWdpblN0YXRlKCkucmVjb3JkaW5nTGVuZ3RoU2Vjb25kc1xuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kczogY3VycmVudFJlY29yZGluZ0xlbmd0aCArIDEgfSlcbiAgICAgIH0sIDEwMDApXG4gICAgfVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBpc1JlY29yZGluZzogdHJ1ZSxcbiAgICB9KVxuICB9XG5cbiAgc3RvcFJlY29yZGluZyAoKSB7XG4gICAgY29uc3Qgc3RvcHBlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLnJlY29yZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3AnLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbiAgICAgIHRoaXMucmVjb3JkZXIuc3RvcCgpXG5cbiAgICAgIGlmICh0aGlzLm9wdHMuc2hvd1JlY29yZGluZ0xlbmd0aCkge1xuICAgICAgICAvLyBTdG9wIHRoZSByZWNvcmRpbmdMZW5ndGhUaW1lciBpZiB3ZSBhcmUgc2hvd2luZyB0aGUgcmVjb3JkaW5nIGxlbmd0aC5cbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlY29yZGluZ0xlbmd0aFRpbWVyKVxuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kczogMCB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gc3RvcHBlZC50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBpc1JlY29yZGluZzogZmFsc2UsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmlkZW8oKVxuICAgIH0pLnRoZW4oKGZpbGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUgPSBmaWxlXG4gICAgICAgIC8vIGNyZWF0ZSBvYmplY3QgdXJsIGZvciBjYXB0dXJlIHJlc3VsdCBwcmV2aWV3XG4gICAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgICAgICAgcmVjb3JkZWRWaWRlbzogVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlLmRhdGEpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLm9wdHMubWlycm9yID0gZmFsc2VcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBMb2dnaW5nIHRoZSBlcnJvciwgZXhlcHQgcmVzdHJpY3Rpb25zLCB3aGljaCBpcyBoYW5kbGVkIGluIENvcmVcbiAgICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnJlY29yZGluZ0NodW5rcyA9IG51bGxcbiAgICAgIHRoaXMucmVjb3JkZXIgPSBudWxsXG4gICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLnJlY29yZGluZ0NodW5rcyA9IG51bGxcbiAgICAgIHRoaXMucmVjb3JkZXIgPSBudWxsXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH0pXG4gIH1cblxuICBkaXNjYXJkUmVjb3JkZWRWaWRlbyAoKSB7XG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7IHJlY29yZGVkVmlkZW86IG51bGwgfSlcbiAgICB0aGlzLm9wdHMubWlycm9yID0gdHJ1ZVxuICAgIHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUgPSBudWxsXG4gIH1cblxuICBzdWJtaXQgKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5jYXB0dXJlZE1lZGlhRmlsZSkge1xuICAgICAgICB0aGlzLnVwcHkuYWRkRmlsZSh0aGlzLmNhcHR1cmVkTWVkaWFGaWxlKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gTG9nZ2luZyB0aGUgZXJyb3IsIGV4ZXB0IHJlc3RyaWN0aW9ucywgd2hpY2ggaXMgaGFuZGxlZCBpbiBDb3JlXG4gICAgICBpZiAoIWVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICAgIHRoaXMudXBweS5sb2coZXJyLCAnZXJyb3InKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0b3AgKCkge1xuICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgdGhpcy5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5zdG9wKClcbiAgICAgIH0pXG4gICAgICB0aGlzLnN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgIHRyYWNrLnN0b3AoKVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy53ZWJjYW1BY3RpdmUgPSBmYWxzZVxuICAgIHRoaXMuc3RyZWFtID0gbnVsbFxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgcmVjb3JkZWRWaWRlbzogbnVsbCxcbiAgICB9KVxuICB9XG5cbiAgZ2V0VmlkZW9FbGVtZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcudXBweS1XZWJjYW0tdmlkZW8nKVxuICB9XG5cbiAgb25lVHdvVGhyZWVTbWlsZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBjb3VudCA9IHRoaXMub3B0cy5jb3VudGRvd25cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICBjb25zdCBjb3VudERvd24gPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy53ZWJjYW1BY3RpdmUpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGNvdW50RG93bilcbiAgICAgICAgICB0aGlzLmNhcHR1cmVJblByb2dyZXNzID0gZmFsc2VcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignV2ViY2FtIGlzIG5vdCBhY3RpdmUnKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICB0aGlzLnVwcHkuaW5mbyhgJHtjb3VudH0uLi5gLCAnd2FybmluZycsIDgwMClcbiAgICAgICAgICBjb3VudC0tXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChjb3VudERvd24pXG4gICAgICAgICAgdGhpcy51cHB5LmluZm8odGhpcy5pMThuKCdzbWlsZScpLCAnc3VjY2VzcycsIDE1MDApXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIDE1MDApXG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApXG4gICAgfSlcbiAgfVxuXG4gIHRha2VTbmFwc2hvdCAoKSB7XG4gICAgaWYgKHRoaXMuY2FwdHVyZUluUHJvZ3Jlc3MpIHJldHVyblxuXG4gICAgdGhpcy5jYXB0dXJlSW5Qcm9ncmVzcyA9IHRydWVcblxuICAgIHRoaXMub3B0cy5vbkJlZm9yZVNuYXBzaG90KCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHR5cGVvZiBlcnIgPT09ICdvYmplY3QnID8gZXJyLm1lc3NhZ2UgOiBlcnJcbiAgICAgIHRoaXMudXBweS5pbmZvKG1lc3NhZ2UsICdlcnJvcicsIDUwMDApXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBvbkJlZm9yZVNuYXBzaG90OiAke21lc3NhZ2V9YCkpXG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbWFnZSgpXG4gICAgfSkudGhlbigodGFnRmlsZSkgPT4ge1xuICAgICAgdGhpcy5jYXB0dXJlSW5Qcm9ncmVzcyA9IGZhbHNlXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnVwcHkuYWRkRmlsZSh0YWdGaWxlKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIExvZ2dpbmcgdGhlIGVycm9yLCBleGNlcHQgcmVzdHJpY3Rpb25zLCB3aGljaCBpcyBoYW5kbGVkIGluIENvcmVcbiAgICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLmNhcHR1cmVJblByb2dyZXNzID0gZmFsc2VcbiAgICAgIHRocm93IGVycm9yXG4gICAgfSlcbiAgfVxuXG4gIGdldEltYWdlICgpIHtcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMuZ2V0VmlkZW9FbGVtZW50KClcbiAgICBpZiAoIXZpZGVvKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdObyB2aWRlbyBlbGVtZW50IGZvdW5kLCBsaWtlbHkgZHVlIHRvIHRoZSBXZWJjYW0gdGFiIGJlaW5nIGNsb3NlZC4nKSlcbiAgICB9XG5cbiAgICBjb25zdCB3aWR0aCA9IHZpZGVvLnZpZGVvV2lkdGhcbiAgICBjb25zdCBoZWlnaHQgPSB2aWRlby52aWRlb0hlaWdodFxuXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHRcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGN0eC5kcmF3SW1hZ2UodmlkZW8sIDAsIDApXG5cbiAgICBjb25zdCB7IHJlc3RyaWN0aW9ucyB9ID0gdGhpcy51cHB5Lm9wdHNcbiAgICBsZXQgcHJlZmVycmVkSW1hZ2VNaW1lVHlwZXMgPSBbXVxuICAgIGlmICh0aGlzLm9wdHMucHJlZmVycmVkSW1hZ2VNaW1lVHlwZSkge1xuICAgICAgcHJlZmVycmVkSW1hZ2VNaW1lVHlwZXMgPSBbdGhpcy5vcHRzLnByZWZlcnJlZEltYWdlTWltZVR5cGVdXG4gICAgfSBlbHNlIGlmIChyZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcykge1xuICAgICAgcHJlZmVycmVkSW1hZ2VNaW1lVHlwZXMgPSByZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcy5tYXAodG9NaW1lVHlwZSkuZmlsdGVyKGlzSW1hZ2VNaW1lVHlwZSlcbiAgICB9XG5cbiAgICBjb25zdCBtaW1lVHlwZSA9IHByZWZlcnJlZEltYWdlTWltZVR5cGVzWzBdIHx8ICdpbWFnZS9qcGVnJ1xuICAgIGNvbnN0IGV4dCA9IGdldEZpbGVUeXBlRXh0ZW5zaW9uKG1pbWVUeXBlKSB8fCAnanBnJ1xuICAgIGNvbnN0IG5hbWUgPSBgY2FtLSR7RGF0ZS5ub3coKX0uJHtleHR9YFxuXG4gICAgcmV0dXJuIGNhbnZhc1RvQmxvYihjYW52YXMsIG1pbWVUeXBlKS50aGVuKChibG9iKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRhdGE6IG5ldyBCbG9iKFtibG9iXSwgeyB0eXBlOiBtaW1lVHlwZSB9KSxcbiAgICAgICAgdHlwZTogbWltZVR5cGUsXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGdldFZpZGVvICgpIHtcbiAgICAvLyBTb21ldGltZXMgaW4gaU9TIFNhZmFyaSwgQmxvYnMgKGVzcGVjaWFsbHkgdGhlIGZpcnN0IEJsb2IgaW4gdGhlIHJlY29yZGluZ0NodW5rcyBBcnJheSlcbiAgICAvLyBoYXZlIGVtcHR5ICd0eXBlJyBhdHRyaWJ1dGVzIChlLmcuICcnKSBzbyB3ZSBuZWVkIHRvIGZpbmQgYSBCbG9iIHRoYXQgaGFzIGEgZGVmaW5lZCAndHlwZSdcbiAgICAvLyBhdHRyaWJ1dGUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IE1JTUUgdHlwZS5cbiAgICBjb25zdCBtaW1lVHlwZSA9IHRoaXMucmVjb3JkaW5nQ2h1bmtzLmZpbmQoYmxvYiA9PiBibG9iLnR5cGU/Lmxlbmd0aCA+IDApLnR5cGVcblxuICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBnZXRGaWxlVHlwZUV4dGVuc2lvbihtaW1lVHlwZSlcblxuICAgIGlmICghZmlsZUV4dGVuc2lvbikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgQ291bGQgbm90IHJldHJpZXZlIHJlY29yZGluZzogVW5zdXBwb3J0ZWQgbWVkaWEgdHlwZSBcIiR7bWltZVR5cGV9XCJgKSlcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gYHdlYmNhbS0ke0RhdGUubm93KCl9LiR7ZmlsZUV4dGVuc2lvbn1gXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKHRoaXMucmVjb3JkaW5nQ2h1bmtzLCB7IHR5cGU6IG1pbWVUeXBlIH0pXG4gICAgY29uc3QgZmlsZSA9IHtcbiAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgIG5hbWUsXG4gICAgICBkYXRhOiBuZXcgQmxvYihbYmxvYl0sIHsgdHlwZTogbWltZVR5cGUgfSksXG4gICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbGUpXG4gIH1cblxuICBmb2N1cyAoKSB7XG4gICAgaWYgKCF0aGlzLm9wdHMuY291bnRkb3duKSByZXR1cm5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBweS5pbmZvKHRoaXMuaTE4bignc21pbGUnKSwgJ3N1Y2Nlc3MnLCAxNTAwKVxuICAgIH0sIDEwMDApXG4gIH1cblxuICBjaGFuZ2VWaWRlb1NvdXJjZSAoZGV2aWNlSWQpIHtcbiAgICB0aGlzLnN0b3AoKVxuICAgIHRoaXMuc3RhcnQoeyBkZXZpY2VJZCB9KVxuICB9XG5cbiAgdXBkYXRlVmlkZW9Tb3VyY2VzICgpIHtcbiAgICB0aGlzLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbihkZXZpY2VzID0+IHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICB2aWRlb1NvdXJjZXM6IGRldmljZXMuZmlsdGVyKChkZXZpY2UpID0+IGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCcpLFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBpZiAoIXRoaXMud2ViY2FtQWN0aXZlKSB7XG4gICAgICB0aGlzLnN0YXJ0KClcbiAgICB9XG5cbiAgICBjb25zdCB3ZWJjYW1TdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgaWYgKCF3ZWJjYW1TdGF0ZS5jYW1lcmFSZWFkeSB8fCAhd2ViY2FtU3RhdGUuaGFzQ2FtZXJhKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8UGVybWlzc2lvbnNTY3JlZW5cbiAgICAgICAgICBpY29uPXtDYW1lcmFJY29ufVxuICAgICAgICAgIGkxOG49e3RoaXMuaTE4bn1cbiAgICAgICAgICBoYXNDYW1lcmE9e3dlYmNhbVN0YXRlLmhhc0NhbWVyYX1cbiAgICAgICAgLz5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPENhbWVyYVNjcmVlblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvanN4LXByb3BzLW5vLXNwcmVhZGluZ1xuICAgICAgICB7Li4ud2ViY2FtU3RhdGV9XG4gICAgICAgIG9uQ2hhbmdlVmlkZW9Tb3VyY2U9e3RoaXMuY2hhbmdlVmlkZW9Tb3VyY2V9XG4gICAgICAgIG9uU25hcHNob3Q9e3RoaXMudGFrZVNuYXBzaG90fVxuICAgICAgICBvblN0YXJ0UmVjb3JkaW5nPXt0aGlzLnN0YXJ0UmVjb3JkaW5nfVxuICAgICAgICBvblN0b3BSZWNvcmRpbmc9e3RoaXMuc3RvcFJlY29yZGluZ31cbiAgICAgICAgb25EaXNjYXJkUmVjb3JkZWRWaWRlbz17dGhpcy5kaXNjYXJkUmVjb3JkZWRWaWRlb31cbiAgICAgICAgb25TdWJtaXQ9e3RoaXMuc3VibWl0fVxuICAgICAgICBvbkZvY3VzPXt0aGlzLmZvY3VzfVxuICAgICAgICBvblN0b3A9e3RoaXMuc3RvcH1cbiAgICAgICAgaTE4bj17dGhpcy5pMThufVxuICAgICAgICBtb2Rlcz17dGhpcy5vcHRzLm1vZGVzfVxuICAgICAgICBzaG93UmVjb3JkaW5nTGVuZ3RoPXt0aGlzLm9wdHMuc2hvd1JlY29yZGluZ0xlbmd0aH1cbiAgICAgICAgc2hvd1ZpZGVvU291cmNlRHJvcGRvd249e3RoaXMub3B0cy5zaG93VmlkZW9Tb3VyY2VEcm9wZG93bn1cbiAgICAgICAgc3VwcG9ydHNSZWNvcmRpbmc9e3N1cHBvcnRzTWVkaWFSZWNvcmRlcigpfVxuICAgICAgICByZWNvcmRpbmc9e3dlYmNhbVN0YXRlLmlzUmVjb3JkaW5nfVxuICAgICAgICBtaXJyb3I9e3RoaXMub3B0cy5taXJyb3J9XG4gICAgICAgIHNyYz17dGhpcy5zdHJlYW19XG4gICAgICAvPlxuICAgIClcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgY2FtZXJhUmVhZHk6IGZhbHNlLFxuICAgICAgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kczogMCxcbiAgICB9KVxuXG4gICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMub3B0c1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm1lZGlhRGV2aWNlcykge1xuICAgICAgdGhpcy51cGRhdGVWaWRlb1NvdXJjZXMoKVxuXG4gICAgICB0aGlzLm1lZGlhRGV2aWNlcy5vbmRldmljZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVWaWRlb1NvdXJjZXMoKVxuXG4gICAgICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgICAgIGxldCByZXN0YXJ0U3RyZWFtID0gdHJ1ZVxuXG4gICAgICAgICAgY29uc3QgeyB2aWRlb1NvdXJjZXMsIGN1cnJlbnREZXZpY2VJZCB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG5cbiAgICAgICAgICB2aWRlb1NvdXJjZXMuZm9yRWFjaCgodmlkZW9Tb3VyY2UpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RGV2aWNlSWQgPT09IHZpZGVvU291cmNlLmRldmljZUlkKSB7XG4gICAgICAgICAgICAgIHJlc3RhcnRTdHJlYW0gPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBpZiAocmVzdGFydFN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKClcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICB0aGlzLnN0b3AoKVxuICAgIH1cblxuICAgIHRoaXMudW5tb3VudCgpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3VwcG9ydHNNZWRpYVJlY29yZGVyICgpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgY29tcGF0L2NvbXBhdCAqL1xuICByZXR1cm4gdHlwZW9mIE1lZGlhUmVjb3JkZXIgPT09ICdmdW5jdGlvbicgJiYgISFNZWRpYVJlY29yZGVyLnByb3RvdHlwZVxuICAgICYmIHR5cGVvZiBNZWRpYVJlY29yZGVyLnByb3RvdHlwZS5zdGFydCA9PT0gJ2Z1bmN0aW9uJ1xuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBhdC9jb21wYXQgKi9cbn1cbiIsIi8qKlxuICogbWFya2VkIC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE4LCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZFxuICovXG5cbjsoZnVuY3Rpb24ocm9vdCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuXG52YXIgYmxvY2sgPSB7XG4gIG5ld2xpbmU6IC9eXFxuKy8sXG4gIGNvZGU6IC9eKCB7NH1bXlxcbl0rXFxuKikrLyxcbiAgZmVuY2VzOiAvXiB7MCwzfShgezMsfXx+ezMsfSkoW15gflxcbl0qKVxcbig/OnwoW1xcc1xcU10qPylcXG4pKD86IHswLDN9XFwxW35gXSogKig/Olxcbit8JCl8JCkvLFxuICBocjogL14gezAsM30oKD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFwqICopezMsfSkoPzpcXG4rfCQpLyxcbiAgaGVhZGluZzogL14gezAsM30oI3sxLDZ9KSArKFteXFxuXSo/KSg/OiArIyspPyAqKD86XFxuK3wkKS8sXG4gIGJsb2NrcXVvdGU6IC9eKCB7MCwzfT4gPyhwYXJhZ3JhcGh8W15cXG5dKikoPzpcXG58JCkpKy8sXG4gIGxpc3Q6IC9eKCB7MCwzfSkoYnVsbCkgW1xcc1xcU10rPyg/OmhyfGRlZnxcXG57Mix9KD8hICkoPyFcXDFidWxsIClcXG4qfFxccyokKS8sXG4gIGh0bWw6ICdeIHswLDN9KD86JyAvLyBvcHRpb25hbCBpbmRlbnRhdGlvblxuICAgICsgJzwoc2NyaXB0fHByZXxzdHlsZSlbXFxcXHM+XVtcXFxcc1xcXFxTXSo/KD86PC9cXFxcMT5bXlxcXFxuXSpcXFxcbit8JCknIC8vICgxKVxuICAgICsgJ3xjb21tZW50W15cXFxcbl0qKFxcXFxuK3wkKScgLy8gKDIpXG4gICAgKyAnfDxcXFxcP1tcXFxcc1xcXFxTXSo/XFxcXD8+XFxcXG4qJyAvLyAoMylcbiAgICArICd8PCFbQS1aXVtcXFxcc1xcXFxTXSo/PlxcXFxuKicgLy8gKDQpXG4gICAgKyAnfDwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPlxcXFxuKicgLy8gKDUpXG4gICAgKyAnfDwvPyh0YWcpKD86ICt8XFxcXG58Lz8+KVtcXFxcc1xcXFxTXSo/KD86XFxcXG57Mix9fCQpJyAvLyAoNilcbiAgICArICd8PCg/IXNjcmlwdHxwcmV8c3R5bGUpKFthLXpdW1xcXFx3LV0qKSg/OmF0dHJpYnV0ZSkqPyAqLz8+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzpcXFxcbnsyLH18JCknIC8vICg3KSBvcGVuIHRhZ1xuICAgICsgJ3w8Lyg/IXNjcmlwdHxwcmV8c3R5bGUpW2Etel1bXFxcXHctXSpcXFxccyo+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzpcXFxcbnsyLH18JCknIC8vICg3KSBjbG9zaW5nIHRhZ1xuICAgICsgJyknLFxuICBkZWY6IC9eIHswLDN9XFxbKGxhYmVsKVxcXTogKlxcbj8gKjw/KFteXFxzPl0rKT4/KD86KD86ICtcXG4/ICp8ICpcXG4gKikodGl0bGUpKT8gKig/Olxcbit8JCkvLFxuICBucHRhYmxlOiBub29wLFxuICB0YWJsZTogbm9vcCxcbiAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gIC8vIHJlZ2V4IHRlbXBsYXRlLCBwbGFjZWhvbGRlcnMgd2lsbCBiZSByZXBsYWNlZCBhY2NvcmRpbmcgdG8gZGlmZmVyZW50IHBhcmFncmFwaFxuICAvLyBpbnRlcnJ1cHRpb24gcnVsZXMgb2YgY29tbW9ubWFyayBhbmQgdGhlIG9yaWdpbmFsIG1hcmtkb3duIHNwZWM6XG4gIF9wYXJhZ3JhcGg6IC9eKFteXFxuXSsoPzpcXG4oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8ZmVuY2VzfGxpc3R8aHRtbClbXlxcbl0rKSopLyxcbiAgdGV4dDogL15bXlxcbl0rL1xufTtcblxuYmxvY2suX2xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXFtcXFtcXF1dfFteXFxbXFxdXSkrLztcbmJsb2NrLl90aXRsZSA9IC8oPzpcIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnW14nXFxuXSooPzpcXG5bXidcXG5dKykqXFxuPyd8XFwoW14oKV0qXFwpKS87XG5ibG9jay5kZWYgPSBlZGl0KGJsb2NrLmRlZilcbiAgLnJlcGxhY2UoJ2xhYmVsJywgYmxvY2suX2xhYmVsKVxuICAucmVwbGFjZSgndGl0bGUnLCBibG9jay5fdGl0bGUpXG4gIC5nZXRSZWdleCgpO1xuXG5ibG9jay5idWxsZXQgPSAvKD86WyorLV18XFxkezEsOX1cXC4pLztcbmJsb2NrLml0ZW0gPSAvXiggKikoYnVsbCkgP1teXFxuXSooPzpcXG4oPyFcXDFidWxsID8pW15cXG5dKikqLztcbmJsb2NrLml0ZW0gPSBlZGl0KGJsb2NrLml0ZW0sICdnbScpXG4gIC5yZXBsYWNlKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgLmdldFJlZ2V4KCk7XG5cbmJsb2NrLmxpc3QgPSBlZGl0KGJsb2NrLmxpc3QpXG4gIC5yZXBsYWNlKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgLnJlcGxhY2UoJ2hyJywgJ1xcXFxuKyg/PVxcXFwxPyg/Oig/Oi0gKil7Myx9fCg/Ol8gKil7Myx9fCg/OlxcXFwqICopezMsfSkoPzpcXFxcbit8JCkpJylcbiAgLnJlcGxhY2UoJ2RlZicsICdcXFxcbisoPz0nICsgYmxvY2suZGVmLnNvdXJjZSArICcpJylcbiAgLmdldFJlZ2V4KCk7XG5cbmJsb2NrLl90YWcgPSAnYWRkcmVzc3xhcnRpY2xlfGFzaWRlfGJhc2V8YmFzZWZvbnR8YmxvY2txdW90ZXxib2R5fGNhcHRpb24nXG4gICsgJ3xjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbidcbiAgKyAnfGZpZ3VyZXxmb290ZXJ8Zm9ybXxmcmFtZXxmcmFtZXNldHxoWzEtNl18aGVhZHxoZWFkZXJ8aHJ8aHRtbHxpZnJhbWUnXG4gICsgJ3xsZWdlbmR8bGl8bGlua3xtYWlufG1lbnV8bWVudWl0ZW18bWV0YXxuYXZ8bm9mcmFtZXN8b2x8b3B0Z3JvdXB8b3B0aW9uJ1xuICArICd8cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyJ1xuICArICd8dHJhY2t8dWwnO1xuYmxvY2suX2NvbW1lbnQgPSAvPCEtLSg/IS0/PilbXFxzXFxTXSo/LS0+LztcbmJsb2NrLmh0bWwgPSBlZGl0KGJsb2NrLmh0bWwsICdpJylcbiAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBibG9jay5fY29tbWVudClcbiAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpXG4gIC5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvICtbYS16QS1aOl9dW1xcdy46LV0qKD86ICo9ICpcIlteXCJcXG5dKlwifCAqPSAqJ1teJ1xcbl0qJ3wgKj0gKlteXFxzXCInPTw+YF0rKT8vKVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2sucGFyYWdyYXBoID0gZWRpdChibG9jay5fcGFyYWdyYXBoKVxuICAucmVwbGFjZSgnaHInLCBibG9jay5ocilcbiAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICsnKVxuICAucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4IGhlYWRpbmdzIGRvbid0IGludGVycnVwdCBjb21tb25tYXJrIHBhcmFncmFwaHNcbiAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH18fnszLH0pW15gXFxcXG5dKlxcXFxuJylcbiAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8IS0tKScpXG4gIC5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2suYmxvY2txdW90ZSA9IGVkaXQoYmxvY2suYmxvY2txdW90ZSlcbiAgLnJlcGxhY2UoJ3BhcmFncmFwaCcsIGJsb2NrLnBhcmFncmFwaClcbiAgLmdldFJlZ2V4KCk7XG5cbi8qKlxuICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5ub3JtYWwgPSBtZXJnZSh7fSwgYmxvY2spO1xuXG4vKipcbiAqIEdGTSBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2suZ2ZtID0gbWVyZ2Uoe30sIGJsb2NrLm5vcm1hbCwge1xuICBucHRhYmxlOiAvXiAqKFtefFxcbiBdLipcXHwuKilcXG4gKihbLTpdKyAqXFx8Wy18IDpdKikoPzpcXG4oKD86LipbXj5cXG4gXS4qKD86XFxufCQpKSopXFxuKnwkKS8sXG4gIHRhYmxlOiAvXiAqXFx8KC4rKVxcbiAqXFx8PyggKlstOl0rWy18IDpdKikoPzpcXG4oKD86ICpbXj5cXG4gXS4qKD86XFxufCQpKSopXFxuKnwkKS9cbn0pO1xuXG4vKipcbiAqIFBlZGFudGljIGdyYW1tYXIgKG9yaWdpbmFsIEpvaG4gR3J1YmVyJ3MgbG9vc2UgbWFya2Rvd24gc3BlY2lmaWNhdGlvbilcbiAqL1xuXG5ibG9jay5wZWRhbnRpYyA9IG1lcmdlKHt9LCBibG9jay5ub3JtYWwsIHtcbiAgaHRtbDogZWRpdChcbiAgICAnXiAqKD86Y29tbWVudCAqKD86XFxcXG58XFxcXHMqJCknXG4gICAgKyAnfDwodGFnKVtcXFxcc1xcXFxTXSs/PC9cXFxcMT4gKig/OlxcXFxuezIsfXxcXFxccyokKScgLy8gY2xvc2VkIHRhZ1xuICAgICsgJ3w8dGFnKD86XCJbXlwiXSpcInxcXCdbXlxcJ10qXFwnfFxcXFxzW15cXCdcIi8+XFxcXHNdKikqPy8/PiAqKD86XFxcXG57Mix9fFxcXFxzKiQpKScpXG4gICAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBibG9jay5fY29tbWVudClcbiAgICAucmVwbGFjZSgvdGFnL2csICcoPyEoPzonXG4gICAgICArICdhfGVtfHN0cm9uZ3xzbWFsbHxzfGNpdGV8cXxkZm58YWJicnxkYXRhfHRpbWV8Y29kZXx2YXJ8c2FtcHxrYmR8c3ViJ1xuICAgICAgKyAnfHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkb3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZyknXG4gICAgICArICdcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInKVxuICAgIC5nZXRSZWdleCgpLFxuICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArKFtcIihdW15cXG5dK1tcIildKSk/ICooPzpcXG4rfCQpLyxcbiAgaGVhZGluZzogL14gKigjezEsNn0pICooW15cXG5dKz8pICooPzojKyAqKT8oPzpcXG4rfCQpLyxcbiAgZmVuY2VzOiBub29wLCAvLyBmZW5jZXMgbm90IHN1cHBvcnRlZFxuICBwYXJhZ3JhcGg6IGVkaXQoYmxvY2subm9ybWFsLl9wYXJhZ3JhcGgpXG4gICAgLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpXG4gICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnICojezEsNn0gKlteXFxuXScpXG4gICAgLnJlcGxhY2UoJ2xoZWFkaW5nJywgYmxvY2subGhlYWRpbmcpXG4gICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgLnJlcGxhY2UoJ3xmZW5jZXMnLCAnJylcbiAgICAucmVwbGFjZSgnfGxpc3QnLCAnJylcbiAgICAucmVwbGFjZSgnfGh0bWwnLCAnJylcbiAgICAuZ2V0UmVnZXgoKVxufSk7XG5cbi8qKlxuICogQmxvY2sgTGV4ZXJcbiAqL1xuXG5mdW5jdGlvbiBMZXhlcihvcHRpb25zKSB7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMudG9rZW5zLmxpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMucnVsZXMgPSBibG9jay5ub3JtYWw7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgIHRoaXMucnVsZXMgPSBibG9jay5wZWRhbnRpYztcbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgdGhpcy5ydWxlcyA9IGJsb2NrLmdmbTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBCbG9jayBSdWxlc1xuICovXG5cbkxleGVyLnJ1bGVzID0gYmxvY2s7XG5cbi8qKlxuICogU3RhdGljIExleCBNZXRob2RcbiAqL1xuXG5MZXhlci5sZXggPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMpIHtcbiAgdmFyIGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG59O1xuXG4vKipcbiAqIFByZXByb2Nlc3NpbmdcbiAqL1xuXG5MZXhlci5wcm90b3R5cGUubGV4ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHNyYyA9IHNyY1xuICAgIC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKVxuICAgIC5yZXBsYWNlKC9cXHQvZywgJyAgICAnKVxuICAgIC5yZXBsYWNlKC9cXHUwMGEwL2csICcgJylcbiAgICAucmVwbGFjZSgvXFx1MjQyNC9nLCAnXFxuJyk7XG5cbiAgcmV0dXJuIHRoaXMudG9rZW4oc3JjLCB0cnVlKTtcbn07XG5cbi8qKlxuICogTGV4aW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLnRva2VuID0gZnVuY3Rpb24oc3JjLCB0b3ApIHtcbiAgc3JjID0gc3JjLnJlcGxhY2UoL14gKyQvZ20sICcnKTtcbiAgdmFyIG5leHQsXG4gICAgICBsb29zZSxcbiAgICAgIGNhcCxcbiAgICAgIGJ1bGwsXG4gICAgICBiLFxuICAgICAgaXRlbSxcbiAgICAgIGxpc3RTdGFydCxcbiAgICAgIGxpc3RJdGVtcyxcbiAgICAgIHQsXG4gICAgICBzcGFjZSxcbiAgICAgIGksXG4gICAgICB0YWcsXG4gICAgICBsLFxuICAgICAgaXNvcmRlcmVkLFxuICAgICAgaXN0YXNrLFxuICAgICAgaXNjaGVja2VkO1xuXG4gIHdoaWxlIChzcmMpIHtcbiAgICAvLyBuZXdsaW5lXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubmV3bGluZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ3NwYWNlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHZhciBsYXN0VG9rZW4gPSB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICAvLyBBbiBpbmRlbnRlZCBjb2RlIGJsb2NrIGNhbm5vdCBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGguXG4gICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIGNhcFswXS50cmltUmlnaHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eIHs0fS9nbSwgJycpO1xuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgY29kZUJsb2NrU3R5bGU6ICdpbmRlbnRlZCcsXG4gICAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgPyBydHJpbShjYXAsICdcXG4nKVxuICAgICAgICAgICAgOiBjYXBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmZW5jZXNcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5mZW5jZXMuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgbGFuZzogY2FwWzJdID8gY2FwWzJdLnRyaW0oKSA6IGNhcFsyXSxcbiAgICAgICAgdGV4dDogY2FwWzNdIHx8ICcnXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5oZWFkaW5nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIGRlcHRoOiBjYXBbMV0ubGVuZ3RoLFxuICAgICAgICB0ZXh0OiBjYXBbMl1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFibGUgbm8gbGVhZGluZyBwaXBlIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubnB0YWJsZS5leGVjKHNyYykpIHtcbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogc3BsaXRDZWxscyhjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKSksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgY2VsbHM6IGNhcFszXSA/IGNhcFszXS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKSA6IFtdXG4gICAgICB9O1xuXG4gICAgICBpZiAoaXRlbS5oZWFkZXIubGVuZ3RoID09PSBpdGVtLmFsaWduLmxlbmd0aCkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmFsaWduLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbS5jZWxsc1tpXSA9IHNwbGl0Q2VsbHMoaXRlbS5jZWxsc1tpXSwgaXRlbS5oZWFkZXIubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goaXRlbSk7XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaHJcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5oci5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hyJ1xuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBibG9ja3F1b3RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYmxvY2txdW90ZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9zdGFydCdcbiAgICAgIH0pO1xuXG4gICAgICBjYXAgPSBjYXBbMF0ucmVwbGFjZSgvXiAqPiA/L2dtLCAnJyk7XG5cbiAgICAgIC8vIFBhc3MgYHRvcGAgdG8ga2VlcCB0aGUgY3VycmVudFxuICAgICAgLy8gXCJ0b3BsZXZlbFwiIHN0YXRlLiBUaGlzIGlzIGV4YWN0bHlcbiAgICAgIC8vIGhvdyBtYXJrZG93bi5wbCB3b3Jrcy5cbiAgICAgIHRoaXMudG9rZW4oY2FwLCB0b3ApO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGVfZW5kJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxpc3RcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saXN0LmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGJ1bGwgPSBjYXBbMl07XG4gICAgICBpc29yZGVyZWQgPSBidWxsLmxlbmd0aCA+IDE7XG5cbiAgICAgIGxpc3RTdGFydCA9IHtcbiAgICAgICAgdHlwZTogJ2xpc3Rfc3RhcnQnLFxuICAgICAgICBvcmRlcmVkOiBpc29yZGVyZWQsXG4gICAgICAgIHN0YXJ0OiBpc29yZGVyZWQgPyArYnVsbCA6ICcnLFxuICAgICAgICBsb29zZTogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2gobGlzdFN0YXJ0KTtcblxuICAgICAgLy8gR2V0IGVhY2ggdG9wLWxldmVsIGl0ZW0uXG4gICAgICBjYXAgPSBjYXBbMF0ubWF0Y2godGhpcy5ydWxlcy5pdGVtKTtcblxuICAgICAgbGlzdEl0ZW1zID0gW107XG4gICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICBsID0gY2FwLmxlbmd0aDtcbiAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpdGVtID0gY2FwW2ldO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBpdGVtJ3MgYnVsbGV0XG4gICAgICAgIC8vIHNvIGl0IGlzIHNlZW4gYXMgdGhlIG5leHQgdG9rZW4uXG4gICAgICAgIHNwYWNlID0gaXRlbS5sZW5ndGg7XG4gICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL14gKihbKistXXxcXGQrXFwuKSAqLywgJycpO1xuXG4gICAgICAgIC8vIE91dGRlbnQgd2hhdGV2ZXIgdGhlXG4gICAgICAgIC8vIGxpc3QgaXRlbSBjb250YWlucy4gSGFja3kuXG4gICAgICAgIGlmICh+aXRlbS5pbmRleE9mKCdcXG4gJykpIHtcbiAgICAgICAgICBzcGFjZSAtPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICBpdGVtID0gIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgPyBpdGVtLnJlcGxhY2UobmV3IFJlZ0V4cCgnXiB7MSwnICsgc3BhY2UgKyAnfScsICdnbScpLCAnJylcbiAgICAgICAgICAgIDogaXRlbS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbmV4dCBsaXN0IGl0ZW0gYmVsb25ncyBoZXJlLlxuICAgICAgICAvLyBCYWNrcGVkYWwgaWYgaXQgZG9lcyBub3QgYmVsb25nIGluIHRoaXMgbGlzdC5cbiAgICAgICAgaWYgKGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgYiA9IGJsb2NrLmJ1bGxldC5leGVjKGNhcFtpICsgMV0pWzBdO1xuICAgICAgICAgIGlmIChidWxsLmxlbmd0aCA+IDEgPyBiLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgOiAoYi5sZW5ndGggPiAxIHx8ICh0aGlzLm9wdGlvbnMuc21hcnRMaXN0cyAmJiBiICE9PSBidWxsKSkpIHtcbiAgICAgICAgICAgIHNyYyA9IGNhcC5zbGljZShpICsgMSkuam9pbignXFxuJykgKyBzcmM7XG4gICAgICAgICAgICBpID0gbCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgaXRlbSBpcyBsb29zZSBvciBub3QuXG4gICAgICAgIC8vIFVzZTogLyhefFxcbikoPyEgKVteXFxuXStcXG5cXG4oPyFcXHMqJCkvXG4gICAgICAgIC8vIGZvciBkaXNjb3VudCBiZWhhdmlvci5cbiAgICAgICAgbG9vc2UgPSBuZXh0IHx8IC9cXG5cXG4oPyFcXHMqJCkvLnRlc3QoaXRlbSk7XG4gICAgICAgIGlmIChpICE9PSBsIC0gMSkge1xuICAgICAgICAgIG5leHQgPSBpdGVtLmNoYXJBdChpdGVtLmxlbmd0aCAtIDEpID09PSAnXFxuJztcbiAgICAgICAgICBpZiAoIWxvb3NlKSBsb29zZSA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9vc2UpIHtcbiAgICAgICAgICBsaXN0U3RhcnQubG9vc2UgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICBpc3Rhc2sgPSAvXlxcW1sgeFhdXFxdIC8udGVzdChpdGVtKTtcbiAgICAgICAgaXNjaGVja2VkID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaXN0YXNrKSB7XG4gICAgICAgICAgaXNjaGVja2VkID0gaXRlbVsxXSAhPT0gJyAnO1xuICAgICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL15cXFtbIHhYXVxcXSArLywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdCA9IHtcbiAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtX3N0YXJ0JyxcbiAgICAgICAgICB0YXNrOiBpc3Rhc2ssXG4gICAgICAgICAgY2hlY2tlZDogaXNjaGVja2VkLFxuICAgICAgICAgIGxvb3NlOiBsb29zZVxuICAgICAgICB9O1xuXG4gICAgICAgIGxpc3RJdGVtcy5wdXNoKHQpO1xuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHQpO1xuXG4gICAgICAgIC8vIFJlY3Vyc2UuXG4gICAgICAgIHRoaXMudG9rZW4oaXRlbSwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW1fZW5kJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpc3RTdGFydC5sb29zZSkge1xuICAgICAgICBsID0gbGlzdEl0ZW1zLmxlbmd0aDtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbGlzdEl0ZW1zW2ldLmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpc3RfZW5kJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGh0bWxcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5odG1sLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemVcbiAgICAgICAgICA/ICdwYXJhZ3JhcGgnXG4gICAgICAgICAgOiAnaHRtbCcsXG4gICAgICAgIHByZTogIXRoaXMub3B0aW9ucy5zYW5pdGl6ZXJcbiAgICAgICAgICAmJiAoY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyksXG4gICAgICAgIHRleHQ6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/ICh0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogZXNjYXBlKGNhcFswXSkpIDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRlZlxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMuZGVmLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzNdKSBjYXBbM10gPSBjYXBbM10uc3Vic3RyaW5nKDEsIGNhcFszXS5sZW5ndGggLSAxKTtcbiAgICAgIHRhZyA9IGNhcFsxXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgIGlmICghdGhpcy50b2tlbnMubGlua3NbdGFnXSkge1xuICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0YWddID0ge1xuICAgICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWJsZSAoZ2ZtKVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRhYmxlLmV4ZWMoc3JjKSkge1xuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgaGVhZGVyOiBzcGxpdENlbGxzKGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpKSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBjZWxsczogY2FwWzNdID8gY2FwWzNdLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpIDogW11cbiAgICAgIH07XG5cbiAgICAgIGlmIChpdGVtLmhlYWRlci5sZW5ndGggPT09IGl0ZW0uYWxpZ24ubGVuZ3RoKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtLmNlbGxzW2ldID0gc3BsaXRDZWxscyhcbiAgICAgICAgICAgIGl0ZW0uY2VsbHNbaV0ucmVwbGFjZSgvXiAqXFx8ICp8ICpcXHwgKiQvZywgJycpLFxuICAgICAgICAgICAgaXRlbS5oZWFkZXIubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goaXRlbSk7XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saGVhZGluZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzJdLmNoYXJBdCgwKSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgIHRleHQ6IGNhcFsxXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5wYXJhZ3JhcGguZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgdGV4dDogY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nXG4gICAgICAgICAgPyBjYXBbMV0uc2xpY2UoMCwgLTEpXG4gICAgICAgICAgOiBjYXBbMV1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICAvLyBUb3AtbGV2ZWwgc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUuXG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLnRva2Vucztcbn07XG5cbi8qKlxuICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAqL1xuXG52YXIgaW5saW5lID0ge1xuICBlc2NhcGU6IC9eXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvLFxuICBhdXRvbGluazogL148KHNjaGVtZTpbXlxcc1xceDAwLVxceDFmPD5dKnxlbWFpbCk+LyxcbiAgdXJsOiBub29wLFxuICB0YWc6ICdeY29tbWVudCdcbiAgICArICd8XjwvW2EtekEtWl1bXFxcXHc6LV0qXFxcXHMqPicgLy8gc2VsZi1jbG9zaW5nIHRhZ1xuICAgICsgJ3xePFthLXpBLVpdW1xcXFx3LV0qKD86YXR0cmlidXRlKSo/XFxcXHMqLz8+JyAvLyBvcGVuIHRhZ1xuICAgICsgJ3xePFxcXFw/W1xcXFxzXFxcXFNdKj9cXFxcPz4nIC8vIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24sIGUuZy4gPD9waHAgPz5cbiAgICArICd8XjwhW2EtekEtWl0rXFxcXHNbXFxcXHNcXFxcU10qPz4nIC8vIGRlY2xhcmF0aW9uLCBlLmcuIDwhRE9DVFlQRSBodG1sPlxuICAgICsgJ3xePCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JywgLy8gQ0RBVEEgc2VjdGlvblxuICBsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcKFxccyooaHJlZikoPzpcXHMrKHRpdGxlKSk/XFxzKlxcKS8sXG4gIHJlZmxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFxbKD8hXFxzKlxcXSkoKD86XFxcXFtcXFtcXF1dP3xbXlxcW1xcXVxcXFxdKSspXFxdLyxcbiAgbm9saW5rOiAvXiE/XFxbKD8hXFxzKlxcXSkoKD86XFxbW15cXFtcXF1dKlxcXXxcXFxcW1xcW1xcXV18W15cXFtcXF1dKSopXFxdKD86XFxbXFxdKT8vLFxuICBzdHJvbmc6IC9eX18oW15cXHNfXSlfXyg/IV8pfF5cXCpcXCooW15cXHMqXSlcXCpcXCooPyFcXCopfF5fXyhbXlxcc11bXFxzXFxTXSo/W15cXHNdKV9fKD8hXyl8XlxcKlxcKihbXlxcc11bXFxzXFxTXSo/W15cXHNdKVxcKlxcKig/IVxcKikvLFxuICBlbTogL15fKFteXFxzX10pXyg/IV8pfF5cXCooW15cXHMqPFxcW10pXFwqKD8hXFwqKXxeXyhbXlxcczxdW1xcc1xcU10qP1teXFxzX10pXyg/IV98W15cXHNwdW5jdHVhdGlvbl0pfF5fKFteXFxzXzxdW1xcc1xcU10qP1teXFxzXSlfKD8hX3xbXlxcc3B1bmN0dWF0aW9uXSl8XlxcKihbXlxcczxcIl1bXFxzXFxTXSo/W15cXHNcXCpdKVxcKig/IVxcKnxbXlxcc3B1bmN0dWF0aW9uXSl8XlxcKihbXlxccypcIjxcXFtdW1xcc1xcU10qP1teXFxzXSlcXCooPyFcXCopLyxcbiAgY29kZTogL14oYCspKFteYF18W15gXVtcXHNcXFNdKj9bXmBdKVxcMSg/IWApLyxcbiAgYnI6IC9eKCB7Mix9fFxcXFwpXFxuKD8hXFxzKiQpLyxcbiAgZGVsOiBub29wLFxuICB0ZXh0OiAvXihgK3xbXmBdKSg/OltcXHNcXFNdKj8oPzooPz1bXFxcXDwhXFxbYCpdfFxcYl98JCl8W14gXSg/PSB7Mix9XFxuKSl8KD89IHsyLH1cXG4pKS9cbn07XG5cbi8vIGxpc3Qgb2YgcHVuY3R1YXRpb24gbWFya3MgZnJvbSBjb21tb24gbWFyayBzcGVjXG4vLyB3aXRob3V0IGAgYW5kIF0gdG8gd29ya2Fyb3VuZCBSdWxlIDE3IChpbmxpbmUgY29kZSBibG9ja3MvbGlua3MpXG5pbmxpbmUuX3B1bmN0dWF0aW9uID0gJyFcIiMkJSZcXCcoKSorLFxcXFwtLi86Ozw9Pj9AXFxcXFteX3t8fX4nO1xuaW5saW5lLmVtID0gZWRpdChpbmxpbmUuZW0pLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG5cbmlubGluZS5fZXNjYXBlcyA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS9nO1xuXG5pbmxpbmUuX3NjaGVtZSA9IC9bYS16QS1aXVthLXpBLVowLTkrLi1dezEsMzF9LztcbmlubGluZS5fZW1haWwgPSAvW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXSsoQClbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyg/IVstX10pLztcbmlubGluZS5hdXRvbGluayA9IGVkaXQoaW5saW5lLmF1dG9saW5rKVxuICAucmVwbGFjZSgnc2NoZW1lJywgaW5saW5lLl9zY2hlbWUpXG4gIC5yZXBsYWNlKCdlbWFpbCcsIGlubGluZS5fZW1haWwpXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUuX2F0dHJpYnV0ZSA9IC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LztcblxuaW5saW5lLnRhZyA9IGVkaXQoaW5saW5lLnRhZylcbiAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBibG9jay5fY29tbWVudClcbiAgLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIGlubGluZS5fYXR0cmlidXRlKVxuICAuZ2V0UmVnZXgoKTtcblxuaW5saW5lLl9sYWJlbCA9IC8oPzpcXFtbXlxcW1xcXV0qXFxdfFxcXFwufGBbXmBdKmB8W15cXFtcXF1cXFxcYF0pKj8vO1xuaW5saW5lLl9ocmVmID0gLzwoPzpcXFxcWzw+XT98W15cXHM8PlxcXFxdKSo+fFteXFxzXFx4MDAtXFx4MWZdKi87XG5pbmxpbmUuX3RpdGxlID0gL1wiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCcoPzpcXFxcJz98W14nXFxcXF0pKid8XFwoKD86XFxcXFxcKT98W14pXFxcXF0pKlxcKS87XG5cbmlubGluZS5saW5rID0gZWRpdChpbmxpbmUubGluaylcbiAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgLnJlcGxhY2UoJ2hyZWYnLCBpbmxpbmUuX2hyZWYpXG4gIC5yZXBsYWNlKCd0aXRsZScsIGlubGluZS5fdGl0bGUpXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUucmVmbGluayA9IGVkaXQoaW5saW5lLnJlZmxpbmspXG4gIC5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpXG4gIC5nZXRSZWdleCgpO1xuXG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5ub3JtYWwgPSBtZXJnZSh7fSwgaW5saW5lKTtcblxuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5wZWRhbnRpYyA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIHN0cm9uZzogL15fXyg/PVxcUykoW1xcc1xcU10qP1xcUylfXyg/IV8pfF5cXCpcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pfF5cXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKS8sXG4gIGxpbms6IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXCgoLio/KVxcKS8pXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgICAuZ2V0UmVnZXgoKSxcbiAgcmVmbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxccypcXFsoW15cXF1dKilcXF0vKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpXG4gICAgLmdldFJlZ2V4KClcbn0pO1xuXG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5nZm0gPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBlc2NhcGU6IGVkaXQoaW5saW5lLmVzY2FwZSkucmVwbGFjZSgnXSknLCAnfnxdKScpLmdldFJlZ2V4KCksXG4gIF9leHRlbmRlZF9lbWFpbDogL1tBLVphLXowLTkuXystXSsoQClbYS16QS1aMC05LV9dKyg/OlxcLlthLXpBLVowLTktX10qW2EtekEtWjAtOV0pKyg/IVstX10pLyxcbiAgdXJsOiAvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sXG4gIF9iYWNrcGVkYWw6IC8oPzpbXj8hLiw6OypffigpJl0rfFxcKFteKV0qXFwpfCYoPyFbYS16QS1aMC05XSs7JCl8Wz8hLiw6OypffildKyg/ISQpKSsvLFxuICBkZWw6IC9efisoPz1cXFMpKFtcXHNcXFNdKj9cXFMpfisvLFxuICB0ZXh0OiAvXihgK3xbXmBdKSg/OltcXHNcXFNdKj8oPzooPz1bXFxcXDwhXFxbYCp+XXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpfCg/PSB7Mix9XFxufFthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpL1xufSk7XG5cbmlubGluZS5nZm0udXJsID0gZWRpdChpbmxpbmUuZ2ZtLnVybCwgJ2knKVxuICAucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUuZ2ZtLl9leHRlbmRlZF9lbWFpbClcbiAgLmdldFJlZ2V4KCk7XG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmJyZWFrcyA9IG1lcmdlKHt9LCBpbmxpbmUuZ2ZtLCB7XG4gIGJyOiBlZGl0KGlubGluZS5icikucmVwbGFjZSgnezIsfScsICcqJykuZ2V0UmVnZXgoKSxcbiAgdGV4dDogZWRpdChpbmxpbmUuZ2ZtLnRleHQpXG4gICAgLnJlcGxhY2UoJ1xcXFxiXycsICdcXFxcYl98IHsyLH1cXFxcbicpXG4gICAgLnJlcGxhY2UoL1xcezIsXFx9L2csICcqJylcbiAgICAuZ2V0UmVnZXgoKVxufSk7XG5cbi8qKlxuICogSW5saW5lIExleGVyICYgQ29tcGlsZXJcbiAqL1xuXG5mdW5jdGlvbiBJbmxpbmVMZXhlcihsaW5rcywgb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5saW5rcyA9IGxpbmtzO1xuICB0aGlzLnJ1bGVzID0gaW5saW5lLm5vcm1hbDtcbiAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIoKTtcbiAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmICghdGhpcy5saW5rcykge1xuICAgIHRocm93IG5ldyBFcnJvcignVG9rZW5zIGFycmF5IHJlcXVpcmVzIGEgYGxpbmtzYCBwcm9wZXJ0eS4nKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICB0aGlzLnJ1bGVzID0gaW5saW5lLnBlZGFudGljO1xuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGlubGluZS5icmVha3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnVsZXMgPSBpbmxpbmUuZ2ZtO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBJbmxpbmUgUnVsZXNcbiAqL1xuXG5JbmxpbmVMZXhlci5ydWxlcyA9IGlubGluZTtcblxuLyoqXG4gKiBTdGF0aWMgTGV4aW5nL0NvbXBpbGluZyBNZXRob2RcbiAqL1xuXG5JbmxpbmVMZXhlci5vdXRwdXQgPSBmdW5jdGlvbihzcmMsIGxpbmtzLCBvcHRpb25zKSB7XG4gIHZhciBpbmxpbmUgPSBuZXcgSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpO1xuICByZXR1cm4gaW5saW5lLm91dHB1dChzcmMpO1xufTtcblxuLyoqXG4gKiBMZXhpbmcvQ29tcGlsaW5nXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uKHNyYykge1xuICB2YXIgb3V0ID0gJycsXG4gICAgICBsaW5rLFxuICAgICAgdGV4dCxcbiAgICAgIGhyZWYsXG4gICAgICB0aXRsZSxcbiAgICAgIGNhcCxcbiAgICAgIHByZXZDYXBaZXJvO1xuXG4gIHdoaWxlIChzcmMpIHtcbiAgICAvLyBlc2NhcGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lc2NhcGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFnXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGFnLmV4ZWMoc3JjKSkge1xuICAgICAgaWYgKCF0aGlzLmluTGluayAmJiAvXjxhIC9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmluTGluayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaW5SYXdCbG9jayAmJiAvXjwocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5SYXdCbG9jayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5SYXdCbG9jayA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXJcbiAgICAgICAgICA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKVxuICAgICAgICAgIDogZXNjYXBlKGNhcFswXSlcbiAgICAgICAgOiBjYXBbMF07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaW5rXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGluay5leGVjKHNyYykpIHtcbiAgICAgIHZhciBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldChjYXBbMl0sICcoKScpO1xuICAgICAgaWYgKGxhc3RQYXJlbkluZGV4ID4gLTEpIHtcbiAgICAgICAgdmFyIGxpbmtMZW4gPSA0ICsgY2FwWzFdLmxlbmd0aCArIGxhc3RQYXJlbkluZGV4O1xuICAgICAgICBjYXBbMl0gPSBjYXBbMl0uc3Vic3RyaW5nKDAsIGxhc3RQYXJlbkluZGV4KTtcbiAgICAgICAgY2FwWzBdID0gY2FwWzBdLnN1YnN0cmluZygwLCBsaW5rTGVuKS50cmltKCk7XG4gICAgICAgIGNhcFszXSA9ICcnO1xuICAgICAgfVxuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIGhyZWYgPSBjYXBbMl07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgIGxpbmsgPSAvXihbXidcIl0qW15cXHNdKVxccysoWydcIl0pKC4qKVxcMi8uZXhlYyhocmVmKTtcblxuICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgIGhyZWYgPSBsaW5rWzFdO1xuICAgICAgICAgIHRpdGxlID0gbGlua1szXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aXRsZSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zbGljZSgxLCAtMSkgOiAnJztcbiAgICAgIH1cbiAgICAgIGhyZWYgPSBocmVmLnRyaW0oKS5yZXBsYWNlKC9ePChbXFxzXFxTXSopPiQvLCAnJDEnKTtcbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgIGhyZWY6IElubGluZUxleGVyLmVzY2FwZXMoaHJlZiksXG4gICAgICAgIHRpdGxlOiBJbmxpbmVMZXhlci5lc2NhcGVzKHRpdGxlKVxuICAgICAgfSk7XG4gICAgICB0aGlzLmluTGluayA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVmbGluaywgbm9saW5rXG4gICAgaWYgKChjYXAgPSB0aGlzLnJ1bGVzLnJlZmxpbmsuZXhlYyhzcmMpKVxuICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGxpbmsgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgbGluayA9IHRoaXMubGlua3NbbGluay50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmICghbGluayB8fCAhbGluay5ocmVmKSB7XG4gICAgICAgIG91dCArPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICBzcmMgPSBjYXBbMF0uc3Vic3RyaW5nKDEpICsgc3JjO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCBsaW5rKTtcbiAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBzdHJvbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5zdHJvbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuc3Ryb25nKHRoaXMub3V0cHV0KGNhcFs0XSB8fCBjYXBbM10gfHwgY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZW1cbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lbS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5lbSh0aGlzLm91dHB1dChjYXBbNl0gfHwgY2FwWzVdIHx8IGNhcFs0XSB8fCBjYXBbM10gfHwgY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gY29kZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZXNwYW4oZXNjYXBlKGNhcFsyXS50cmltKCksIHRydWUpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGJyXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYnIuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYnIoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRlbCAoZ2ZtKVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmRlbC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5kZWwodGhpcy5vdXRwdXQoY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBhdXRvbGlua1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmF1dG9saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKHRoaXMubWFuZ2xlKGNhcFsxXSkpO1xuICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICB9XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIG51bGwsIHRleHQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdXJsIChnZm0pXG4gICAgaWYgKCF0aGlzLmluTGluayAmJiAoY2FwID0gdGhpcy5ydWxlcy51cmwuZXhlYyhzcmMpKSkge1xuICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzBdKTtcbiAgICAgICAgaHJlZiA9ICdtYWlsdG86JyArIHRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkbyBleHRlbmRlZCBhdXRvbGluayBwYXRoIHZhbGlkYXRpb25cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgIGNhcFswXSA9IHRoaXMucnVsZXMuX2JhY2twZWRhbC5leGVjKGNhcFswXSlbMF07XG4gICAgICAgIH0gd2hpbGUgKHByZXZDYXBaZXJvICE9PSBjYXBbMF0pO1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFswXSk7XG4gICAgICAgIGlmIChjYXBbMV0gPT09ICd3d3cuJykge1xuICAgICAgICAgIGhyZWYgPSAnaHR0cDovLycgKyB0ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGluayhocmVmLCBudWxsLCB0ZXh0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmICh0aGlzLmluUmF3QmxvY2spIHtcbiAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIudGV4dCh0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyAodGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IGVzY2FwZShjYXBbMF0pKSA6IGNhcFswXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci50ZXh0KGVzY2FwZSh0aGlzLnNtYXJ0eXBhbnRzKGNhcFswXSkpKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5JbmxpbmVMZXhlci5lc2NhcGVzID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gdGV4dCA/IHRleHQucmVwbGFjZShJbmxpbmVMZXhlci5ydWxlcy5fZXNjYXBlcywgJyQxJykgOiB0ZXh0O1xufTtcblxuLyoqXG4gKiBDb21waWxlIExpbmtcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUub3V0cHV0TGluayA9IGZ1bmN0aW9uKGNhcCwgbGluaykge1xuICB2YXIgaHJlZiA9IGxpbmsuaHJlZixcbiAgICAgIHRpdGxlID0gbGluay50aXRsZSA/IGVzY2FwZShsaW5rLnRpdGxlKSA6IG51bGw7XG5cbiAgcmV0dXJuIGNhcFswXS5jaGFyQXQoMCkgIT09ICchJ1xuICAgID8gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIHRpdGxlLCB0aGlzLm91dHB1dChjYXBbMV0pKVxuICAgIDogdGhpcy5yZW5kZXJlci5pbWFnZShocmVmLCB0aXRsZSwgZXNjYXBlKGNhcFsxXSkpO1xufTtcblxuLyoqXG4gKiBTbWFydHlwYW50cyBUcmFuc2Zvcm1hdGlvbnNcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUuc21hcnR5cGFudHMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzKSByZXR1cm4gdGV4dDtcbiAgcmV0dXJuIHRleHRcbiAgICAvLyBlbS1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0tL2csICdcXHUyMDE0JylcbiAgICAvLyBlbi1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0vZywgJ1xcdTIwMTMnKVxuICAgIC8vIG9wZW5pbmcgc2luZ2xlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcIlxcc10pJy9nLCAnJDFcXHUyMDE4JylcbiAgICAvLyBjbG9zaW5nIHNpbmdsZXMgJiBhcG9zdHJvcGhlc1xuICAgIC5yZXBsYWNlKC8nL2csICdcXHUyMDE5JylcbiAgICAvLyBvcGVuaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XFx1MjAxOFxcc10pXCIvZywgJyQxXFx1MjAxYycpXG4gICAgLy8gY2xvc2luZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoL1wiL2csICdcXHUyMDFkJylcbiAgICAvLyBlbGxpcHNlc1xuICAgIC5yZXBsYWNlKC9cXC57M30vZywgJ1xcdTIwMjYnKTtcbn07XG5cbi8qKlxuICogTWFuZ2xlIExpbmtzXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm1hbmdsZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMubWFuZ2xlKSByZXR1cm4gdGV4dDtcbiAgdmFyIG91dCA9ICcnLFxuICAgICAgbCA9IHRleHQubGVuZ3RoLFxuICAgICAgaSA9IDAsXG4gICAgICBjaDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICBjaCA9ICd4JyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJlbmRlcmVyXG4gKi9cblxuZnVuY3Rpb24gUmVuZGVyZXIob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbn1cblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGUgPSBmdW5jdGlvbihjb2RlLCBpbmZvc3RyaW5nLCBlc2NhcGVkKSB7XG4gIHZhciBsYW5nID0gKGluZm9zdHJpbmcgfHwgJycpLm1hdGNoKC9cXFMqLylbMF07XG4gIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgdmFyIG91dCA9IHRoaXMub3B0aW9ucy5oaWdobGlnaHQoY29kZSwgbGFuZyk7XG4gICAgaWYgKG91dCAhPSBudWxsICYmIG91dCAhPT0gY29kZSkge1xuICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICBjb2RlID0gb3V0O1xuICAgIH1cbiAgfVxuXG4gIGlmICghbGFuZykge1xuICAgIHJldHVybiAnPHByZT48Y29kZT4nXG4gICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICsgJzwvY29kZT48L3ByZT4nO1xuICB9XG5cbiAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwiJ1xuICAgICsgdGhpcy5vcHRpb25zLmxhbmdQcmVmaXhcbiAgICArIGVzY2FwZShsYW5nLCB0cnVlKVxuICAgICsgJ1wiPidcbiAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5ibG9ja3F1b3RlID0gZnVuY3Rpb24ocXVvdGUpIHtcbiAgcmV0dXJuICc8YmxvY2txdW90ZT5cXG4nICsgcXVvdGUgKyAnPC9ibG9ja3F1b3RlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWw7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaGVhZGluZyA9IGZ1bmN0aW9uKHRleHQsIGxldmVsLCByYXcsIHNsdWdnZXIpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJJZHMpIHtcbiAgICByZXR1cm4gJzxoJ1xuICAgICAgKyBsZXZlbFxuICAgICAgKyAnIGlkPVwiJ1xuICAgICAgKyB0aGlzLm9wdGlvbnMuaGVhZGVyUHJlZml4XG4gICAgICArIHNsdWdnZXIuc2x1ZyhyYXcpXG4gICAgICArICdcIj4nXG4gICAgICArIHRleHRcbiAgICAgICsgJzwvaCdcbiAgICAgICsgbGV2ZWxcbiAgICAgICsgJz5cXG4nO1xuICB9XG4gIC8vIGlnbm9yZSBJRHNcbiAgcmV0dXJuICc8aCcgKyBsZXZlbCArICc+JyArIHRleHQgKyAnPC9oJyArIGxldmVsICsgJz5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmhyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGhyLz5cXG4nIDogJzxocj5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihib2R5LCBvcmRlcmVkLCBzdGFydCkge1xuICB2YXIgdHlwZSA9IG9yZGVyZWQgPyAnb2wnIDogJ3VsJyxcbiAgICAgIHN0YXJ0YXR0ID0gKG9yZGVyZWQgJiYgc3RhcnQgIT09IDEpID8gKCcgc3RhcnQ9XCInICsgc3RhcnQgKyAnXCInKSA6ICcnO1xuICByZXR1cm4gJzwnICsgdHlwZSArIHN0YXJ0YXR0ICsgJz5cXG4nICsgYm9keSArICc8LycgKyB0eXBlICsgJz5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpc3RpdGVtID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxsaT4nICsgdGV4dCArICc8L2xpPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuY2hlY2tib3ggPSBmdW5jdGlvbihjaGVja2VkKSB7XG4gIHJldHVybiAnPGlucHV0ICdcbiAgICArIChjaGVja2VkID8gJ2NoZWNrZWQ9XCJcIiAnIDogJycpXG4gICAgKyAnZGlzYWJsZWQ9XCJcIiB0eXBlPVwiY2hlY2tib3hcIidcbiAgICArICh0aGlzLm9wdGlvbnMueGh0bWwgPyAnIC8nIDogJycpXG4gICAgKyAnPiAnO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnBhcmFncmFwaCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8cD4nICsgdGV4dCArICc8L3A+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uKGhlYWRlciwgYm9keSkge1xuICBpZiAoYm9keSkgYm9keSA9ICc8dGJvZHk+JyArIGJvZHkgKyAnPC90Ym9keT4nO1xuXG4gIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICArICc8dGhlYWQ+XFxuJ1xuICAgICsgaGVhZGVyXG4gICAgKyAnPC90aGVhZD5cXG4nXG4gICAgKyBib2R5XG4gICAgKyAnPC90YWJsZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlcm93ID0gZnVuY3Rpb24oY29udGVudCkge1xuICByZXR1cm4gJzx0cj5cXG4nICsgY29udGVudCArICc8L3RyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVjZWxsID0gZnVuY3Rpb24oY29udGVudCwgZmxhZ3MpIHtcbiAgdmFyIHR5cGUgPSBmbGFncy5oZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgdmFyIHRhZyA9IGZsYWdzLmFsaWduXG4gICAgPyAnPCcgKyB0eXBlICsgJyBhbGlnbj1cIicgKyBmbGFncy5hbGlnbiArICdcIj4nXG4gICAgOiAnPCcgKyB0eXBlICsgJz4nO1xuICByZXR1cm4gdGFnICsgY29udGVudCArICc8LycgKyB0eXBlICsgJz5cXG4nO1xufTtcblxuLy8gc3BhbiBsZXZlbCByZW5kZXJlclxuUmVuZGVyZXIucHJvdG90eXBlLnN0cm9uZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8c3Ryb25nPicgKyB0ZXh0ICsgJzwvc3Ryb25nPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZW0gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGVtPicgKyB0ZXh0ICsgJzwvZW0+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5jb2Rlc3BhbiA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8Y29kZT4nICsgdGV4dCArICc8L2NvZGU+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5iciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxici8+JyA6ICc8YnI+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGRlbD4nICsgdGV4dCArICc8L2RlbD4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpbmsgPSBmdW5jdGlvbihocmVmLCB0aXRsZSwgdGV4dCkge1xuICBocmVmID0gY2xlYW5VcmwodGhpcy5vcHRpb25zLnNhbml0aXplLCB0aGlzLm9wdGlvbnMuYmFzZVVybCwgaHJlZik7XG4gIGlmIChocmVmID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgdmFyIG91dCA9ICc8YSBocmVmPVwiJyArIGVzY2FwZShocmVmKSArICdcIic7XG4gIGlmICh0aXRsZSkge1xuICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgfVxuICBvdXQgKz0gJz4nICsgdGV4dCArICc8L2E+JztcbiAgcmV0dXJuIG91dDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIGhyZWYgPSBjbGVhblVybCh0aGlzLm9wdGlvbnMuc2FuaXRpemUsIHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcbiAgaWYgKGhyZWYgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIHZhciBvdXQgPSAnPGltZyBzcmM9XCInICsgaHJlZiArICdcIiBhbHQ9XCInICsgdGV4dCArICdcIic7XG4gIGlmICh0aXRsZSkge1xuICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgfVxuICBvdXQgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gJy8+JyA6ICc+JztcbiAgcmV0dXJuIG91dDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gdGV4dDtcbn07XG5cbi8qKlxuICogVGV4dFJlbmRlcmVyXG4gKiByZXR1cm5zIG9ubHkgdGhlIHRleHR1YWwgcGFydCBvZiB0aGUgdG9rZW5cbiAqL1xuXG5mdW5jdGlvbiBUZXh0UmVuZGVyZXIoKSB7fVxuXG4vLyBubyBuZWVkIGZvciBibG9jayBsZXZlbCByZW5kZXJlcnNcblxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5zdHJvbmcgPVxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5lbSA9XG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmNvZGVzcGFuID1cblRleHRSZW5kZXJlci5wcm90b3R5cGUuZGVsID1cblRleHRSZW5kZXJlci5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuIHRleHQ7XG59O1xuXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmxpbmsgPVxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIHJldHVybiAnJyArIHRleHQ7XG59O1xuXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmJyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogUGFyc2luZyAmIENvbXBpbGluZ1xuICovXG5cbmZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMudG9rZW4gPSBudWxsO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcigpO1xuICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHRoaXMuc2x1Z2dlciA9IG5ldyBTbHVnZ2VyKCk7XG59XG5cbi8qKlxuICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICovXG5cblBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucykge1xuICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZShzcmMpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBMb29wXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHNyYykge1xuICB0aGlzLmlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihzcmMubGlua3MsIHRoaXMub3B0aW9ucyk7XG4gIC8vIHVzZSBhbiBJbmxpbmVMZXhlciB3aXRoIGEgVGV4dFJlbmRlcmVyIHRvIGV4dHJhY3QgcHVyZSB0ZXh0XG4gIHRoaXMuaW5saW5lVGV4dCA9IG5ldyBJbmxpbmVMZXhlcihcbiAgICBzcmMubGlua3MsXG4gICAgbWVyZ2Uoe30sIHRoaXMub3B0aW9ucywgeyByZW5kZXJlcjogbmV3IFRleHRSZW5kZXJlcigpIH0pXG4gICk7XG4gIHRoaXMudG9rZW5zID0gc3JjLnJldmVyc2UoKTtcblxuICB2YXIgb3V0ID0gJyc7XG4gIHdoaWxlICh0aGlzLm5leHQoKSkge1xuICAgIG91dCArPSB0aGlzLnRvaygpO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnRva2VuID0gdGhpcy50b2tlbnMucG9wKCk7XG4gIHJldHVybiB0aGlzLnRva2VuO1xufTtcblxuLyoqXG4gKiBQcmV2aWV3IE5leHQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdIHx8IDA7XG59O1xuXG4vKipcbiAqIFBhcnNlIFRleHQgVG9rZW5zXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRleHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJvZHkgPSB0aGlzLnRva2VuLnRleHQ7XG5cbiAgd2hpbGUgKHRoaXMucGVlaygpLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGJvZHkgKz0gJ1xcbicgKyB0aGlzLm5leHQoKS50ZXh0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuaW5saW5lLm91dHB1dChib2R5KTtcbn07XG5cbi8qKlxuICogUGFyc2UgQ3VycmVudCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUudG9rID0gZnVuY3Rpb24oKSB7XG4gIHN3aXRjaCAodGhpcy50b2tlbi50eXBlKSB7XG4gICAgY2FzZSAnc3BhY2UnOiB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNhc2UgJ2hyJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICB9XG4gICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmhlYWRpbmcoXG4gICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpLFxuICAgICAgICB0aGlzLnRva2VuLmRlcHRoLFxuICAgICAgICB1bmVzY2FwZSh0aGlzLmlubGluZVRleHQub3V0cHV0KHRoaXMudG9rZW4udGV4dCkpLFxuICAgICAgICB0aGlzLnNsdWdnZXIpO1xuICAgIH1cbiAgICBjYXNlICdjb2RlJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuY29kZSh0aGlzLnRva2VuLnRleHQsXG4gICAgICAgIHRoaXMudG9rZW4ubGFuZyxcbiAgICAgICAgdGhpcy50b2tlbi5lc2NhcGVkKTtcbiAgICB9XG4gICAgY2FzZSAndGFibGUnOiB7XG4gICAgICB2YXIgaGVhZGVyID0gJycsXG4gICAgICAgICAgYm9keSA9ICcnLFxuICAgICAgICAgIGksXG4gICAgICAgICAgcm93LFxuICAgICAgICAgIGNlbGwsXG4gICAgICAgICAgajtcblxuICAgICAgLy8gaGVhZGVyXG4gICAgICBjZWxsID0gJyc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5oZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbChcbiAgICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi5oZWFkZXJbaV0pLFxuICAgICAgICAgIHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltpXSB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBoZWFkZXIgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudG9rZW4uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm93ID0gdGhpcy50b2tlbi5jZWxsc1tpXTtcblxuICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHJvd1tqXSksXG4gICAgICAgICAgICB7IGhlYWRlcjogZmFsc2UsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2pdIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIudGFibGUoaGVhZGVyLCBib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnYmxvY2txdW90ZV9zdGFydCc6IHtcbiAgICAgIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdibG9ja3F1b3RlX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ibG9ja3F1b3RlKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdsaXN0X3N0YXJ0Jzoge1xuICAgICAgYm9keSA9ICcnO1xuICAgICAgdmFyIG9yZGVyZWQgPSB0aGlzLnRva2VuLm9yZGVyZWQsXG4gICAgICAgICAgc3RhcnQgPSB0aGlzLnRva2VuLnN0YXJ0O1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpO1xuICAgIH1cbiAgICBjYXNlICdsaXN0X2l0ZW1fc3RhcnQnOiB7XG4gICAgICBib2R5ID0gJyc7XG4gICAgICB2YXIgbG9vc2UgPSB0aGlzLnRva2VuLmxvb3NlO1xuICAgICAgdmFyIGNoZWNrZWQgPSB0aGlzLnRva2VuLmNoZWNrZWQ7XG4gICAgICB2YXIgdGFzayA9IHRoaXMudG9rZW4udGFzaztcblxuICAgICAgaWYgKHRoaXMudG9rZW4udGFzaykge1xuICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIuY2hlY2tib3goY2hlY2tlZCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSAhbG9vc2UgJiYgdGhpcy50b2tlbi50eXBlID09PSAndGV4dCdcbiAgICAgICAgICA/IHRoaXMucGFyc2VUZXh0KClcbiAgICAgICAgICA6IHRoaXMudG9rKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0aXRlbShib2R5LCB0YXNrLCBjaGVja2VkKTtcbiAgICB9XG4gICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgIC8vIFRPRE8gcGFyc2UgaW5saW5lIGNvbnRlbnQgaWYgcGFyYW1ldGVyIG1hcmtkb3duPTFcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmh0bWwodGhpcy50b2tlbi50ZXh0KTtcbiAgICB9XG4gICAgY2FzZSAncGFyYWdyYXBoJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpKTtcbiAgICB9XG4gICAgY2FzZSAndGV4dCc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLnBhcnNlVGV4dCgpKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdmFyIGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRoaXMudG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVyck1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2x1Z2dlciBnZW5lcmF0ZXMgaGVhZGVyIGlkXG4gKi9cblxuZnVuY3Rpb24gU2x1Z2dlcigpIHtcbiAgdGhpcy5zZWVuID0ge307XG59XG5cbi8qKlxuICogQ29udmVydCBzdHJpbmcgdG8gdW5pcXVlIGlkXG4gKi9cblxuU2x1Z2dlci5wcm90b3R5cGUuc2x1ZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBzbHVnID0gdmFsdWVcbiAgICAudG9Mb3dlckNhc2UoKVxuICAgIC50cmltKClcbiAgICAucmVwbGFjZSgvW1xcdTIwMDAtXFx1MjA2RlxcdTJFMDAtXFx1MkU3RlxcXFwnIVwiIyQlJigpKissLi86Ozw9Pj9AW1xcXV5ge3x9fl0vZywgJycpXG4gICAgLnJlcGxhY2UoL1xccy9nLCAnLScpO1xuXG4gIGlmICh0aGlzLnNlZW4uaGFzT3duUHJvcGVydHkoc2x1ZykpIHtcbiAgICB2YXIgb3JpZ2luYWxTbHVnID0gc2x1ZztcbiAgICBkbyB7XG4gICAgICB0aGlzLnNlZW5bb3JpZ2luYWxTbHVnXSsrO1xuICAgICAgc2x1ZyA9IG9yaWdpbmFsU2x1ZyArICctJyArIHRoaXMuc2VlbltvcmlnaW5hbFNsdWddO1xuICAgIH0gd2hpbGUgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSk7XG4gIH1cbiAgdGhpcy5zZWVuW3NsdWddID0gMDtcblxuICByZXR1cm4gc2x1Zztcbn07XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShodG1sLCBlbmNvZGUpIHtcbiAgaWYgKGVuY29kZSkge1xuICAgIGlmIChlc2NhcGUuZXNjYXBlVGVzdC50ZXN0KGh0bWwpKSB7XG4gICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZS5lc2NhcGVSZXBsYWNlLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gZXNjYXBlLnJlcGxhY2VtZW50c1tjaF07IH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZXNjYXBlLmVzY2FwZVRlc3ROb0VuY29kZS50ZXN0KGh0bWwpKSB7XG4gICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZS5lc2NhcGVSZXBsYWNlTm9FbmNvZGUsIGZ1bmN0aW9uKGNoKSB7IHJldHVybiBlc2NhcGUucmVwbGFjZW1lbnRzW2NoXTsgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGh0bWw7XG59XG5cbmVzY2FwZS5lc2NhcGVUZXN0ID0gL1smPD5cIiddLztcbmVzY2FwZS5lc2NhcGVSZXBsYWNlID0gL1smPD5cIiddL2c7XG5lc2NhcGUucmVwbGFjZW1lbnRzID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnXG59O1xuXG5lc2NhcGUuZXNjYXBlVGVzdE5vRW5jb2RlID0gL1s8PlwiJ118Jig/ISM/XFx3KzspLztcbmVzY2FwZS5lc2NhcGVSZXBsYWNlTm9FbmNvZGUgPSAvWzw+XCInXXwmKD8hIz9cXHcrOykvZztcblxuZnVuY3Rpb24gdW5lc2NhcGUoaHRtbCkge1xuICAvLyBleHBsaWNpdGx5IG1hdGNoIGRlY2ltYWwsIGhleCwgYW5kIG5hbWVkIEhUTUwgZW50aXRpZXNcbiAgcmV0dXJuIGh0bWwucmVwbGFjZSgvJigjKD86XFxkKyl8KD86I3hbMC05QS1GYS1mXSspfCg/OlxcdyspKTs/L2lnLCBmdW5jdGlvbihfLCBuKSB7XG4gICAgbiA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobiA9PT0gJ2NvbG9uJykgcmV0dXJuICc6JztcbiAgICBpZiAobi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCdcbiAgICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG4uc3Vic3RyaW5nKDIpLCAxNikpXG4gICAgICAgIDogU3RyaW5nLmZyb21DaGFyQ29kZSgrbi5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZGl0KHJlZ2V4LCBvcHQpIHtcbiAgcmVnZXggPSByZWdleC5zb3VyY2UgfHwgcmVnZXg7XG4gIG9wdCA9IG9wdCB8fCAnJztcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoLyhefFteXFxbXSlcXF4vZywgJyQxJyk7XG4gICAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0UmVnZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIG9wdCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjbGVhblVybChzYW5pdGl6ZSwgYmFzZSwgaHJlZikge1xuICBpZiAoc2FuaXRpemUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHByb3QgPSBkZWNvZGVVUklDb21wb25lbnQodW5lc2NhcGUoaHJlZikpXG4gICAgICAgIC5yZXBsYWNlKC9bXlxcdzpdL2csICcnKVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHByb3QuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ3Zic2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChiYXNlICYmICFvcmlnaW5JbmRlcGVuZGVudFVybC50ZXN0KGhyZWYpKSB7XG4gICAgaHJlZiA9IHJlc29sdmVVcmwoYmFzZSwgaHJlZik7XG4gIH1cbiAgdHJ5IHtcbiAgICBocmVmID0gZW5jb2RlVVJJKGhyZWYpLnJlcGxhY2UoLyUyNS9nLCAnJScpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhyZWY7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgaHJlZikge1xuICBpZiAoIWJhc2VVcmxzWycgJyArIGJhc2VdKSB7XG4gICAgLy8gd2UgY2FuIGlnbm9yZSBldmVyeXRoaW5nIGluIGJhc2UgYWZ0ZXIgdGhlIGxhc3Qgc2xhc2ggb2YgaXRzIHBhdGggY29tcG9uZW50LFxuICAgIC8vIGJ1dCB3ZSBtaWdodCBuZWVkIHRvIGFkZCBfdGhhdF9cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTNcbiAgICBpZiAoL15bXjpdKzpcXC8qW14vXSokLy50ZXN0KGJhc2UpKSB7XG4gICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IGJhc2UgKyAnLyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gcnRyaW0oYmFzZSwgJy8nLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgYmFzZSA9IGJhc2VVcmxzWycgJyArIGJhc2VdO1xuXG4gIGlmIChocmVmLnNsaWNlKDAsIDIpID09PSAnLy8nKSB7XG4gICAgcmV0dXJuIGJhc2UucmVwbGFjZSgvOltcXHNcXFNdKi8sICc6JykgKyBocmVmO1xuICB9IGVsc2UgaWYgKGhyZWYuY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC8oOlxcLypbXi9dKilbXFxzXFxTXSovLCAnJDEnKSArIGhyZWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2UgKyBocmVmO1xuICB9XG59XG52YXIgYmFzZVVybHMgPSB7fTtcbnZhciBvcmlnaW5JbmRlcGVuZGVudFVybCA9IC9eJHxeW2Etel1bYS16MC05Ky4tXSo6fF5bPyNdL2k7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxubm9vcC5leGVjID0gbm9vcDtcblxuZnVuY3Rpb24gbWVyZ2Uob2JqKSB7XG4gIHZhciBpID0gMSxcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleTtcblxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIG9ialtrZXldID0gdGFyZ2V0W2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gc3BsaXRDZWxscyh0YWJsZVJvdywgY291bnQpIHtcbiAgLy8gZW5zdXJlIHRoYXQgZXZlcnkgY2VsbC1kZWxpbWl0aW5nIHBpcGUgaGFzIGEgc3BhY2VcbiAgLy8gYmVmb3JlIGl0IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gYW4gZXNjYXBlZCBwaXBlXG4gIHZhciByb3cgPSB0YWJsZVJvdy5yZXBsYWNlKC9cXHwvZywgZnVuY3Rpb24obWF0Y2gsIG9mZnNldCwgc3RyKSB7XG4gICAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsXG4gICAgICAgICAgICBjdXJyID0gb2Zmc2V0O1xuICAgICAgICB3aGlsZSAoLS1jdXJyID49IDAgJiYgc3RyW2N1cnJdID09PSAnXFxcXCcpIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgICAvLyBvZGQgbnVtYmVyIG9mIHNsYXNoZXMgbWVhbnMgfCBpcyBlc2NhcGVkXG4gICAgICAgICAgLy8gc28gd2UgbGVhdmUgaXQgYWxvbmVcbiAgICAgICAgICByZXR1cm4gJ3wnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFkZCBzcGFjZSBiZWZvcmUgdW5lc2NhcGVkIHxcbiAgICAgICAgICByZXR1cm4gJyB8JztcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBjZWxscyA9IHJvdy5zcGxpdCgvIFxcfC8pLFxuICAgICAgaSA9IDA7XG5cbiAgaWYgKGNlbGxzLmxlbmd0aCA+IGNvdW50KSB7XG4gICAgY2VsbHMuc3BsaWNlKGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoY2VsbHMubGVuZ3RoIDwgY291bnQpIGNlbGxzLnB1c2goJycpO1xuICB9XG5cbiAgZm9yICg7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBpcyBpZ25vcmVkIHBlciB0aGUgZ2ZtIHNwZWNcbiAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gIH1cbiAgcmV0dXJuIGNlbGxzO1xufVxuXG4vLyBSZW1vdmUgdHJhaWxpbmcgJ2Mncy4gRXF1aXZhbGVudCB0byBzdHIucmVwbGFjZSgvYyokLywgJycpLlxuLy8gL2MqJC8gaXMgdnVsbmVyYWJsZSB0byBSRURPUy5cbi8vIGludmVydDogUmVtb3ZlIHN1ZmZpeCBvZiBub24tYyBjaGFycyBpbnN0ZWFkLiBEZWZhdWx0IGZhbHNleS5cbmZ1bmN0aW9uIHJ0cmltKHN0ciwgYywgaW52ZXJ0KSB7XG4gIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gTGVuZ3RoIG9mIHN1ZmZpeCBtYXRjaGluZyB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cbiAgdmFyIHN1ZmZMZW4gPSAwO1xuXG4gIC8vIFN0ZXAgbGVmdCB1bnRpbCB3ZSBmYWlsIHRvIG1hdGNoIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICB3aGlsZSAoc3VmZkxlbiA8IHN0ci5sZW5ndGgpIHtcbiAgICB2YXIgY3VyckNoYXIgPSBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSBzdWZmTGVuIC0gMSk7XG4gICAgaWYgKGN1cnJDaGFyID09PSBjICYmICFpbnZlcnQpIHtcbiAgICAgIHN1ZmZMZW4rKztcbiAgICB9IGVsc2UgaWYgKGN1cnJDaGFyICE9PSBjICYmIGludmVydCkge1xuICAgICAgc3VmZkxlbisrO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cigwLCBzdHIubGVuZ3RoIC0gc3VmZkxlbik7XG59XG5cbmZ1bmN0aW9uIGZpbmRDbG9zaW5nQnJhY2tldChzdHIsIGIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKGJbMV0pID09PSAtMSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgbGV2ZWwgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHJbaV0gPT09ICdcXFxcJykge1xuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSBiWzBdKSB7XG4gICAgICBsZXZlbCsrO1xuICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSBiWzFdKSB7XG4gICAgICBsZXZlbC0tO1xuICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24ob3B0KSB7XG4gIGlmIChvcHQgJiYgb3B0LnNhbml0aXplICYmICFvcHQuc2lsZW50KSB7XG4gICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogc2FuaXRpemUgYW5kIHNhbml0aXplciBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMC43LjAsIHNob3VsZCBub3QgYmUgdXNlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL21hcmtlZC5qcy5vcmcvIy9VU0lOR19BRFZBTkNFRC5tZCNvcHRpb25zJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBNYXJrZWRcbiAqL1xuXG5mdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQsIGNhbGxiYWNrKSB7XG4gIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCBvciBudWxsJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJ1xuICAgICAgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArICcsIHN0cmluZyBleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGNhbGxiYWNrIHx8IHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdDtcbiAgICAgIG9wdCA9IG51bGw7XG4gICAgfVxuXG4gICAgb3B0ID0gbWVyZ2Uoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcbiAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24ob3B0KTtcblxuICAgIHZhciBoaWdobGlnaHQgPSBvcHQuaGlnaGxpZ2h0LFxuICAgICAgICB0b2tlbnMsXG4gICAgICAgIHBlbmRpbmcsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRva2VucyA9IExleGVyLmxleChzcmMsIG9wdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgIH1cblxuICAgIHBlbmRpbmcgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG91dCA9IFBhcnNlci5wYXJzZSh0b2tlbnMsIG9wdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVyciA9IGU7XG4gICAgICB9XG5cbiAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG5cbiAgICAgIHJldHVybiBlcnJcbiAgICAgICAgPyBjYWxsYmFjayhlcnIpXG4gICAgICAgIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICB9O1xuXG4gICAgaWYgKCFoaWdobGlnaHQgfHwgaGlnaGxpZ2h0Lmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG9wdC5oaWdobGlnaHQ7XG5cbiAgICBpZiAoIXBlbmRpbmcpIHJldHVybiBkb25lKCk7XG5cbiAgICBmb3IgKDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnY29kZScpIHtcbiAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIGZ1bmN0aW9uKGVyciwgY29kZSkge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgaWYgKGNvZGUgPT0gbnVsbCB8fCBjb2RlID09PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW4udGV4dCA9IGNvZGU7XG4gICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSh0b2tlbnNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHQpIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gICAgY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uKG9wdCk7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZShMZXhlci5sZXgoc3JjLCBvcHQpLCBvcHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuICAgIGlmICgob3B0IHx8IG1hcmtlZC5kZWZhdWx0cykuc2lsZW50KSB7XG4gICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPidcbiAgICAgICAgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICsgJzwvcHJlPic7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zXG4gKi9cblxubWFya2VkLm9wdGlvbnMgPVxubWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHQpIHtcbiAgbWVyZ2UobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICByZXR1cm4gbWFya2VkO1xufTtcblxubWFya2VkLmdldERlZmF1bHRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgYmFzZVVybDogbnVsbCxcbiAgICBicmVha3M6IGZhbHNlLFxuICAgIGdmbTogdHJ1ZSxcbiAgICBoZWFkZXJJZHM6IHRydWUsXG4gICAgaGVhZGVyUHJlZml4OiAnJyxcbiAgICBoaWdobGlnaHQ6IG51bGwsXG4gICAgbGFuZ1ByZWZpeDogJ2xhbmd1YWdlLScsXG4gICAgbWFuZ2xlOiB0cnVlLFxuICAgIHBlZGFudGljOiBmYWxzZSxcbiAgICByZW5kZXJlcjogbmV3IFJlbmRlcmVyKCksXG4gICAgc2FuaXRpemU6IGZhbHNlLFxuICAgIHNhbml0aXplcjogbnVsbCxcbiAgICBzaWxlbnQ6IGZhbHNlLFxuICAgIHNtYXJ0TGlzdHM6IGZhbHNlLFxuICAgIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgICB4aHRtbDogZmFsc2VcbiAgfTtcbn07XG5cbm1hcmtlZC5kZWZhdWx0cyA9IG1hcmtlZC5nZXREZWZhdWx0cygpO1xuXG4vKipcbiAqIEV4cG9zZVxuICovXG5cbm1hcmtlZC5QYXJzZXIgPSBQYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xuXG5tYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbm1hcmtlZC5UZXh0UmVuZGVyZXIgPSBUZXh0UmVuZGVyZXI7XG5cbm1hcmtlZC5MZXhlciA9IExleGVyO1xubWFya2VkLmxleGVyID0gTGV4ZXIubGV4O1xuXG5tYXJrZWQuSW5saW5lTGV4ZXIgPSBJbmxpbmVMZXhlcjtcbm1hcmtlZC5pbmxpbmVMZXhlciA9IElubGluZUxleGVyLm91dHB1dDtcblxubWFya2VkLlNsdWdnZXIgPSBTbHVnZ2VyO1xuXG5tYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBtYXJrZWQ7XG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBtYXJrZWQ7IH0pO1xufSBlbHNlIHtcbiAgcm9vdC5tYXJrZWQgPSBtYXJrZWQ7XG59XG59KSh0aGlzIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCkpO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5jb25zdCBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKVxuY29uc3QgZHJhZ2Ryb3AgPSByZXF1aXJlKCdkcmFnLWRyb3AnKVxuLy8gQWRkIFJvYm9kb2cgSlMuIEl0IGlzIGFkdmlzYWJsZSB0byBpbnN0YWxsIFJvYm9kb2cgZnJvbSBucG0veWFybi5cbi8vIEJ1dCBmb3IgZXhwZXJpbWVudGluZywgeW91IGNhbiB1c2UgYWxzbyBUcmFuc2xvYWRpdOKAmXMgQ0ROLCBFZGdseTpcbi8vIDxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9yZWxlYXNlcy50cmFuc2xvYWRpdC5jb20vdXBweS9yb2JvZG9nL3YxLjEwLjEyL3JvYm9kb2cubWluLmpzXCI+PC9zY3JpcHQ+XG5jb25zdCByb2JvZG9nID0gcmVxdWlyZSgnQHVwcHkvcm9ib2RvZycpXG5cbmNvbnN0IFRSQU5TTE9BRElUX0VYQU1QTEVfS0VZID0gJzM1YzFhZWQwM2Y1MDExZTk4MmI2YWZlODI1OTliNmEwJ1xuY29uc3QgVFJBTlNMT0FESVRfRVhBTVBMRV9URU1QTEFURSA9ICcwYjJlZTJiYzI1ZGM0MzYxOTcwMGMyY2UwYTc1MTY0YSdcblxuLyoqXG4gKiBBIHRleHRhcmVhIGZvciBtYXJrZG93biB0ZXh0LCB3aXRoIHN1cHBvcnQgZm9yIGZpbGUgYXR0YWNobWVudHMuXG4gKlxuICogIyMgVXNhZ2VcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJylcbiAqIGNvbnN0IG1kdHh0ID0gbmV3IE1hcmtkb3duVGV4dGFyZWEoZWxlbWVudClcbiAqIG1kdHh0Lmluc3RhbGwoKVxuICogYGBgXG4gKi9cbmNsYXNzIE1hcmtkb3duVGV4dGFyZWEge1xuICBjb25zdHJ1Y3RvciAoZWxlbWVudCkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnRcbiAgICB0aGlzLmNvbnRyb2xzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLmNvbnRyb2xzLmNsYXNzTGlzdC5hZGQoJ21kdHh0LWNvbnRyb2xzJylcbiAgICB0aGlzLnVwbG9hZExpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKVxuICAgIHRoaXMudXBsb2FkTGluZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJylcbiAgICB0aGlzLnVwbG9hZExpbmUuY2xhc3NMaXN0LmFkZCgnZm9ybS11cGxvYWQnKVxuXG4gICAgdGhpcy51cGxvYWRMaW5lLmFwcGVuZENoaWxkKFxuICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1RhcCBoZXJlIHRvIHVwbG9hZCBhbiBhdHRhY2htZW50JykpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRoaXNcbiAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ21kdHh0JylcbiAgICBlbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHdyYXBwZXIsIGVsZW1lbnQpXG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRyb2xzKVxuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudClcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMudXBsb2FkTGluZSlcblxuICAgIHRoaXMuc2V0dXBVcGxvYWRMaW5lKClcbiAgICB0aGlzLnNldHVwVGV4dGFyZWFEcm9wKClcbiAgfVxuXG4gIHNldHVwVGV4dGFyZWFEcm9wICgpIHtcbiAgICBkcmFnZHJvcCh0aGlzLmVsZW1lbnQsIChmaWxlcykgPT4ge1xuICAgICAgdGhpcy51cGxvYWRGaWxlcyhmaWxlcylcbiAgICB9KVxuICB9XG5cbiAgc2V0dXBVcGxvYWRMaW5lICgpIHtcbiAgICB0aGlzLnVwbG9hZExpbmUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICB0aGlzLnBpY2tGaWxlcygpXG4gICAgfSlcbiAgfVxuXG4gIHJlcG9ydFVwbG9hZEVycm9yIChlcnIpIHtcbiAgICB0aGlzLnVwbG9hZExpbmUuY2xhc3NMaXN0LmFkZCgnZXJyb3InKVxuICAgIGNvbnN0IG1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICBtZXNzYWdlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGVyci5tZXNzYWdlKSlcbiAgICB0aGlzLnVwbG9hZExpbmUuaW5zZXJ0Q2hpbGQobWVzc2FnZSwgdGhpcy51cGxvYWRMaW5lLmZpcnN0Q2hpbGQpXG4gIH1cblxuICB1bnJlcG9ydFVwbG9hZEVycm9yICgpIHtcbiAgICB0aGlzLnVwbG9hZExpbmUuY2xhc3NMaXN0LnJlbW92ZSgnZXJyb3InKVxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLnVwbG9hZExpbmUucXVlcnlTZWxlY3RvcignbWVzc2FnZScpXG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMudXBsb2FkTGluZS5yZW1vdmVDaGlsZChtZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIGluc2VydEF0dGFjaG1lbnRzIChhdHRhY2htZW50cykge1xuICAgIGF0dGFjaG1lbnRzLmZvckVhY2goKGF0dGFjaG1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgZmlsZSwgdGh1bWIgfSA9IGF0dGFjaG1lbnRcbiAgICAgIGNvbnN0IGxpbmsgPSBgXFxuW0xBQkVMXSgke2ZpbGUuc3NsX3VybH0pXFxuYFxuICAgICAgY29uc3QgbGFiZWxUZXh0ID0gYFZpZXcgRmlsZSAke2ZpbGUuYmFzZW5hbWV9YFxuICAgICAgaWYgKHRodW1iKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC52YWx1ZSArPSBsaW5rLnJlcGxhY2UoJ0xBQkVMJywgYCFbJHtsYWJlbFRleHR9XSgke3RodW1iLnNzbF91cmx9KWApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsZW1lbnQudmFsdWUgKz0gbGluay5yZXBsYWNlKCdMQUJFTCcsIGxhYmVsVGV4dClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgbWF0Y2hGaWxlc0FuZFRodW1icyAocmVzdWx0cykge1xuICAgIGNvbnN0IGZpbGVzQnlJZCA9IHt9XG4gICAgY29uc3QgdGh1bWJzQnlJZCA9IHt9XG5cbiAgICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKHJlc3VsdC5zdGVwTmFtZSA9PT0gJ3RodW1ibmFpbHMnKSB7XG4gICAgICAgIHRodW1ic0J5SWRbcmVzdWx0Lm9yaWdpbmFsX2lkXSA9IHJlc3VsdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsZXNCeUlkW3Jlc3VsdC5vcmlnaW5hbF9pZF0gPSByZXN1bHRcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZpbGVzQnlJZCkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IGZpbGVzQnlJZFtrZXldXG4gICAgICBjb25zdCB0aHVtYiA9IHRodW1ic0J5SWRba2V5XVxuICAgICAgYWNjLnB1c2goeyBmaWxlLCB0aHVtYiB9KVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIFtdKVxuICB9XG5cbiAgdXBsb2FkRmlsZXMgKGZpbGVzKSB7XG4gICAgcm9ib2RvZy51cGxvYWQoZmlsZXMsIHtcbiAgICAgIHdhaXRGb3JFbmNvZGluZzogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBhdXRoOiB7IGtleTogVFJBTlNMT0FESVRfRVhBTVBMRV9LRVkgfSxcbiAgICAgICAgdGVtcGxhdGVfaWQ6IFRSQU5TTE9BRElUX0VYQU1QTEVfVEVNUExBVEVcbiAgICAgIH1cbiAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHJldHVyblxuICAgICAgdGhpcy5pbnNlcnRBdHRhY2htZW50cyhcbiAgICAgICAgdGhpcy5tYXRjaEZpbGVzQW5kVGh1bWJzKHJlc3VsdC5yZXN1bHRzKVxuICAgICAgKVxuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgdGhpcy5yZXBvcnRVcGxvYWRFcnJvcihlcnIpXG4gICAgfSlcbiAgfVxuXG4gIHBpY2tGaWxlcyAoKSB7XG4gICAgcm9ib2RvZy5waWNrKHtcbiAgICAgIHdhaXRGb3JFbmNvZGluZzogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBhdXRoOiB7IGtleTogVFJBTlNMT0FESVRfRVhBTVBMRV9LRVkgfSxcbiAgICAgICAgdGVtcGxhdGVfaWQ6IFRSQU5TTE9BRElUX0VYQU1QTEVfVEVNUExBVEVcbiAgICAgIH0sXG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgJ3dlYmNhbScsXG4gICAgICAgICd1cmwnLFxuICAgICAgICAnaW5zdGFncmFtJyxcbiAgICAgICAgJ2dvb2dsZS1kcml2ZScsXG4gICAgICAgICdkcm9wYm94J1xuICAgICAgXVxuICAgIH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgcmV0dXJuXG4gICAgICB0aGlzLmluc2VydEF0dGFjaG1lbnRzKFxuICAgICAgICB0aGlzLm1hdGNoRmlsZXNBbmRUaHVtYnMocmVzdWx0LnJlc3VsdHMpXG4gICAgICApXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICB0aGlzLnJlcG9ydFVwbG9hZEVycm9yKGVycilcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IHRleHRhcmVhID0gbmV3IE1hcmtkb3duVGV4dGFyZWEoXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNuZXcgdGV4dGFyZWEnKSlcbnRleHRhcmVhLmluc3RhbGwoKVxuXG5mdW5jdGlvbiByZW5kZXJTbmlwcGV0ICh0aXRsZSwgdGV4dCkge1xuICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzbmlwcGV0JylcbiAgY29uc3QgbmV3U25pcHBldCA9IGRvY3VtZW50LmltcG9ydE5vZGUodGVtcGxhdGUuY29udGVudCwgdHJ1ZSlcbiAgY29uc3QgdGl0bGVFbCA9IG5ld1NuaXBwZXQucXVlcnlTZWxlY3RvcignLnNuaXBwZXQtdGl0bGUnKVxuICBjb25zdCBjb250ZW50RWwgPSBuZXdTbmlwcGV0LnF1ZXJ5U2VsZWN0b3IoJy5zbmlwcGV0LWNvbnRlbnQnKVxuXG4gIHRpdGxlRWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGl0bGUpKVxuICBjb250ZW50RWwuaW5uZXJIVE1MID0gbWFya2VkKHRleHQpXG5cbiAgY29uc3QgbGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzbmlwcGV0cycpXG4gIGxpc3QuaW5zZXJ0QmVmb3JlKG5ld1NuaXBwZXQsIGxpc3QuZmlyc3RDaGlsZClcbn1cblxuZnVuY3Rpb24gc2F2ZVNuaXBwZXQgKHRpdGxlLCB0ZXh0KSB7XG4gIGNvbnN0IGlkID0gcGFyc2VJbnQobG9jYWxTdG9yYWdlLm51bVNuaXBwZXRzIHx8IDAsIDEwKVxuICBsb2NhbFN0b3JhZ2VbYHNuaXBwZXRfJHtpZH1gXSA9IEpTT04uc3RyaW5naWZ5KHsgdGl0bGUsIHRleHQgfSlcbiAgbG9jYWxTdG9yYWdlLm51bVNuaXBwZXRzID0gaWQgKyAxXG59XG5cbmZ1bmN0aW9uIGxvYWRTbmlwcGV0cyAoKSB7XG4gIGZvciAobGV0IGlkID0gMDsgbG9jYWxTdG9yYWdlW2BzbmlwcGV0XyR7aWR9YF0gIT0gbnVsbDsgaWQgKz0gMSkge1xuICAgIGNvbnN0IHsgdGl0bGUsIHRleHQgfSA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlW2BzbmlwcGV0XyR7aWR9YF0pXG4gICAgcmVuZGVyU25pcHBldCh0aXRsZSwgdGV4dClcbiAgfVxufVxuXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbmV3JykuYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgKGV2ZW50KSA9PiB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICBjb25zdCB0aXRsZSA9IGV2ZW50LnRhcmdldC5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPVwidGl0bGVcIl0nKS52YWx1ZSB8fFxuICAgICdVbm5hbWVkIFNuaXBwZXQnXG4gIGNvbnN0IHRleHQgPSB0ZXh0YXJlYS5lbGVtZW50LnZhbHVlXG5cbiAgc2F2ZVNuaXBwZXQodGl0bGUsIHRleHQpXG4gIHJlbmRlclNuaXBwZXQodGl0bGUsIHRleHQpXG5cbiAgZXZlbnQudGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykudmFsdWUgPSAnJ1xuICBldmVudC50YXJnZXQucXVlcnlTZWxlY3RvcigndGV4dGFyZWEnKS52YWx1ZSA9ICcnXG59KVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgbG9hZFNuaXBwZXRzKClcbn0pXG4iXX0=
