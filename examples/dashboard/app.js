(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Adapted from https://github.com/Flet/prettier-bytes/
// Changing 1000 bytes to 1024, so we can keep uppercase KB vs kB
// ISC License (c) Dan Flettre https://github.com/Flet/prettier-bytes/blob/master/LICENSE
module.exports = function prettierBytes (num) {
  if (typeof num !== 'number' || isNaN(num)) {
    throw new TypeError('Expected a number, got ' + typeof num)
  }

  var neg = num < 0
  var units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']

  if (neg) {
    num = -num
  }

  if (num < 1) {
    return (neg ? '-' : '') + num + ' B'
  }

  var exponent = Math.min(Math.floor(Math.log(num) / Math.log(1024)), units.length - 1)
  num = Number(num / Math.pow(1024, exponent))
  var unit = units[exponent]

  if (num >= 10 || num % 1 === 0) {
    // Do not show decimals when the number is two-digit, or if the number has no
    // decimal component.
    return (neg ? '-' : '') + num.toFixed(0) + ' ' + unit
  } else {
    return (neg ? '-' : '') + num.toFixed(1) + ' ' + unit
  }
}

},{}],2:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],3:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":2,"buffer":3,"ieee754":13}],4:[function(require,module,exports){
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString === Object.prototype.toString) {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				} else {
					classes.push(arg.toString());
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],5:[function(require,module,exports){
/*!
 * Cropper.js v1.5.7
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2020-05-23T05:23:00.081Z
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.Cropper = factory());
}(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';
  var WINDOW = IS_BROWSER ? window : {};
  var IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? 'ontouchstart' in WINDOW.document.documentElement : false;
  var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;
  var NAMESPACE = 'cropper'; // Actions

  var ACTION_ALL = 'all';
  var ACTION_CROP = 'crop';
  var ACTION_MOVE = 'move';
  var ACTION_ZOOM = 'zoom';
  var ACTION_EAST = 'e';
  var ACTION_WEST = 'w';
  var ACTION_SOUTH = 's';
  var ACTION_NORTH = 'n';
  var ACTION_NORTH_EAST = 'ne';
  var ACTION_NORTH_WEST = 'nw';
  var ACTION_SOUTH_EAST = 'se';
  var ACTION_SOUTH_WEST = 'sw'; // Classes

  var CLASS_CROP = "".concat(NAMESPACE, "-crop");
  var CLASS_DISABLED = "".concat(NAMESPACE, "-disabled");
  var CLASS_HIDDEN = "".concat(NAMESPACE, "-hidden");
  var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
  var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
  var CLASS_MODAL = "".concat(NAMESPACE, "-modal");
  var CLASS_MOVE = "".concat(NAMESPACE, "-move"); // Data keys

  var DATA_ACTION = "".concat(NAMESPACE, "Action");
  var DATA_PREVIEW = "".concat(NAMESPACE, "Preview"); // Drag modes

  var DRAG_MODE_CROP = 'crop';
  var DRAG_MODE_MOVE = 'move';
  var DRAG_MODE_NONE = 'none'; // Events

  var EVENT_CROP = 'crop';
  var EVENT_CROP_END = 'cropend';
  var EVENT_CROP_MOVE = 'cropmove';
  var EVENT_CROP_START = 'cropstart';
  var EVENT_DBLCLICK = 'dblclick';
  var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';
  var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';
  var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';
  var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;
  var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;
  var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;
  var EVENT_READY = 'ready';
  var EVENT_RESIZE = 'resize';
  var EVENT_WHEEL = 'wheel';
  var EVENT_ZOOM = 'zoom'; // Mime types

  var MIME_TYPE_JPEG = 'image/jpeg'; // RegExps

  var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;
  var REGEXP_DATA_URL = /^data:/;
  var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
  var REGEXP_TAG_NAME = /^img|canvas$/i; // Misc

  var DEFAULTS = {
    // Define the view mode of the cropper
    viewMode: 0,
    // 0, 1, 2, 3
    // Define the dragging mode of the cropper
    dragMode: DRAG_MODE_CROP,
    // 'crop', 'move' or 'none'
    // Define the initial aspect ratio of the crop box
    initialAspectRatio: NaN,
    // Define the aspect ratio of the crop box
    aspectRatio: NaN,
    // An object with the previous cropping result data
    data: null,
    // A selector for adding extra containers to preview
    preview: '',
    // Re-render the cropper when resize the window
    responsive: true,
    // Restore the cropped area after resize the window
    restore: true,
    // Check if the current image is a cross-origin image
    checkCrossOrigin: true,
    // Check the current image's Exif Orientation information
    checkOrientation: true,
    // Show the black modal
    modal: true,
    // Show the dashed lines for guiding
    guides: true,
    // Show the center indicator for guiding
    center: true,
    // Show the white modal to highlight the crop box
    highlight: true,
    // Show the grid background
    background: true,
    // Enable to crop the image automatically when initialize
    autoCrop: true,
    // Define the percentage of automatic cropping area when initializes
    autoCropArea: 0.8,
    // Enable to move the image
    movable: true,
    // Enable to rotate the image
    rotatable: true,
    // Enable to scale the image
    scalable: true,
    // Enable to zoom the image
    zoomable: true,
    // Enable to zoom the image by dragging touch
    zoomOnTouch: true,
    // Enable to zoom the image by wheeling mouse
    zoomOnWheel: true,
    // Define zoom ratio when zoom the image by wheeling mouse
    wheelZoomRatio: 0.1,
    // Enable to move the crop box
    cropBoxMovable: true,
    // Enable to resize the crop box
    cropBoxResizable: true,
    // Toggle drag mode between "crop" and "move" when click twice on the cropper
    toggleDragModeOnDblclick: true,
    // Size limitation
    minCanvasWidth: 0,
    minCanvasHeight: 0,
    minCropBoxWidth: 0,
    minCropBoxHeight: 0,
    minContainerWidth: 200,
    minContainerHeight: 100,
    // Shortcuts of events
    ready: null,
    cropstart: null,
    cropmove: null,
    cropend: null,
    crop: null,
    zoom: null
  };

  var TEMPLATE = '<div class="cropper-container" touch-action="none">' + '<div class="cropper-wrap-box">' + '<div class="cropper-canvas"></div>' + '</div>' + '<div class="cropper-drag-box"></div>' + '<div class="cropper-crop-box">' + '<span class="cropper-view-box"></span>' + '<span class="cropper-dashed dashed-h"></span>' + '<span class="cropper-dashed dashed-v"></span>' + '<span class="cropper-center"></span>' + '<span class="cropper-face"></span>' + '<span class="cropper-line line-e" data-cropper-action="e"></span>' + '<span class="cropper-line line-n" data-cropper-action="n"></span>' + '<span class="cropper-line line-w" data-cropper-action="w"></span>' + '<span class="cropper-line line-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-e" data-cropper-action="e"></span>' + '<span class="cropper-point point-n" data-cropper-action="n"></span>' + '<span class="cropper-point point-w" data-cropper-action="w"></span>' + '<span class="cropper-point point-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-ne" data-cropper-action="ne"></span>' + '<span class="cropper-point point-nw" data-cropper-action="nw"></span>' + '<span class="cropper-point point-sw" data-cropper-action="sw"></span>' + '<span class="cropper-point point-se" data-cropper-action="se"></span>' + '</div>' + '</div>';

  /**
   * Check if the given value is not a number.
   */

  var isNaN = Number.isNaN || WINDOW.isNaN;
  /**
   * Check if the given value is a number.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a number, else `false`.
   */

  function isNumber(value) {
    return typeof value === 'number' && !isNaN(value);
  }
  /**
   * Check if the given value is a positive number.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.
   */

  var isPositiveNumber = function isPositiveNumber(value) {
    return value > 0 && value < Infinity;
  };
  /**
   * Check if the given value is undefined.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is undefined, else `false`.
   */

  function isUndefined(value) {
    return typeof value === 'undefined';
  }
  /**
   * Check if the given value is an object.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is an object, else `false`.
   */

  function isObject(value) {
    return _typeof(value) === 'object' && value !== null;
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  /**
   * Check if the given value is a plain object.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.
   */

  function isPlainObject(value) {
    if (!isObject(value)) {
      return false;
    }

    try {
      var _constructor = value.constructor;
      var prototype = _constructor.prototype;
      return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');
    } catch (error) {
      return false;
    }
  }
  /**
   * Check if the given value is a function.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a function, else `false`.
   */

  function isFunction(value) {
    return typeof value === 'function';
  }
  var slice = Array.prototype.slice;
  /**
   * Convert array-like or iterable object to an array.
   * @param {*} value - The value to convert.
   * @returns {Array} Returns a new array.
   */

  function toArray(value) {
    return Array.from ? Array.from(value) : slice.call(value);
  }
  /**
   * Iterate the given data.
   * @param {*} data - The data to iterate.
   * @param {Function} callback - The process function for each element.
   * @returns {*} The original data.
   */

  function forEach(data, callback) {
    if (data && isFunction(callback)) {
      if (Array.isArray(data) || isNumber(data.length)
      /* array-like */
      ) {
          toArray(data).forEach(function (value, key) {
            callback.call(data, value, key, data);
          });
        } else if (isObject(data)) {
        Object.keys(data).forEach(function (key) {
          callback.call(data, data[key], key, data);
        });
      }
    }

    return data;
  }
  /**
   * Extend the given object.
   * @param {*} target - The target object to extend.
   * @param {*} args - The rest objects for merging to the target object.
   * @returns {Object} The extended object.
   */

  var assign = Object.assign || function assign(target) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (isObject(target) && args.length > 0) {
      args.forEach(function (arg) {
        if (isObject(arg)) {
          Object.keys(arg).forEach(function (key) {
            target[key] = arg[key];
          });
        }
      });
    }

    return target;
  };
  var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
  /**
   * Normalize decimal number.
   * Check out {@link https://0.30000000000000004.com/}
   * @param {number} value - The value to normalize.
   * @param {number} [times=100000000000] - The times for normalizing.
   * @returns {number} Returns the normalized number.
   */

  function normalizeDecimalNumber(value) {
    var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;
    return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
  }
  var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;
  /**
   * Apply styles to the given element.
   * @param {Element} element - The target element.
   * @param {Object} styles - The styles for applying.
   */

  function setStyle(element, styles) {
    var style = element.style;
    forEach(styles, function (value, property) {
      if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
        value = "".concat(value, "px");
      }

      style[property] = value;
    });
  }
  /**
   * Check if the given element has a special class.
   * @param {Element} element - The element to check.
   * @param {string} value - The class to search.
   * @returns {boolean} Returns `true` if the special class was found.
   */

  function hasClass(element, value) {
    return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
  }
  /**
   * Add classes to the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be added.
   */

  function addClass(element, value) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        addClass(elem, value);
      });
      return;
    }

    if (element.classList) {
      element.classList.add(value);
      return;
    }

    var className = element.className.trim();

    if (!className) {
      element.className = value;
    } else if (className.indexOf(value) < 0) {
      element.className = "".concat(className, " ").concat(value);
    }
  }
  /**
   * Remove classes from the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be removed.
   */

  function removeClass(element, value) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        removeClass(elem, value);
      });
      return;
    }

    if (element.classList) {
      element.classList.remove(value);
      return;
    }

    if (element.className.indexOf(value) >= 0) {
      element.className = element.className.replace(value, '');
    }
  }
  /**
   * Add or remove classes from the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be toggled.
   * @param {boolean} added - Add only.
   */

  function toggleClass(element, value, added) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        toggleClass(elem, value, added);
      });
      return;
    } // IE10-11 doesn't support the second parameter of `classList.toggle`


    if (added) {
      addClass(element, value);
    } else {
      removeClass(element, value);
    }
  }
  var REGEXP_CAMEL_CASE = /([a-z\d])([A-Z])/g;
  /**
   * Transform the given string from camelCase to kebab-case
   * @param {string} value - The value to transform.
   * @returns {string} The transformed value.
   */

  function toParamCase(value) {
    return value.replace(REGEXP_CAMEL_CASE, '$1-$2').toLowerCase();
  }
  /**
   * Get data from the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to get.
   * @returns {string} The data value.
   */

  function getData(element, name) {
    if (isObject(element[name])) {
      return element[name];
    }

    if (element.dataset) {
      return element.dataset[name];
    }

    return element.getAttribute("data-".concat(toParamCase(name)));
  }
  /**
   * Set data to the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to set.
   * @param {string} data - The data value.
   */

  function setData(element, name, data) {
    if (isObject(data)) {
      element[name] = data;
    } else if (element.dataset) {
      element.dataset[name] = data;
    } else {
      element.setAttribute("data-".concat(toParamCase(name)), data);
    }
  }
  /**
   * Remove data from the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to remove.
   */

  function removeData(element, name) {
    if (isObject(element[name])) {
      try {
        delete element[name];
      } catch (error) {
        element[name] = undefined;
      }
    } else if (element.dataset) {
      // #128 Safari not allows to delete dataset property
      try {
        delete element.dataset[name];
      } catch (error) {
        element.dataset[name] = undefined;
      }
    } else {
      element.removeAttribute("data-".concat(toParamCase(name)));
    }
  }
  var REGEXP_SPACES = /\s\s*/;

  var onceSupported = function () {
    var supported = false;

    if (IS_BROWSER) {
      var once = false;

      var listener = function listener() {};

      var options = Object.defineProperty({}, 'once', {
        get: function get() {
          supported = true;
          return once;
        },

        /**
         * This setter can fix a `TypeError` in strict mode
         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
         * @param {boolean} value - The value to set
         */
        set: function set(value) {
          once = value;
        }
      });
      WINDOW.addEventListener('test', listener, options);
      WINDOW.removeEventListener('test', listener, options);
    }

    return supported;
  }();
  /**
   * Remove event listener from the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Function} listener - The event listener.
   * @param {Object} options - The event options.
   */


  function removeListener(element, type, listener) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var handler = listener;
    type.trim().split(REGEXP_SPACES).forEach(function (event) {
      if (!onceSupported) {
        var listeners = element.listeners;

        if (listeners && listeners[event] && listeners[event][listener]) {
          handler = listeners[event][listener];
          delete listeners[event][listener];

          if (Object.keys(listeners[event]).length === 0) {
            delete listeners[event];
          }

          if (Object.keys(listeners).length === 0) {
            delete element.listeners;
          }
        }
      }

      element.removeEventListener(event, handler, options);
    });
  }
  /**
   * Add event listener to the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Function} listener - The event listener.
   * @param {Object} options - The event options.
   */

  function addListener(element, type, listener) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var _handler = listener;
    type.trim().split(REGEXP_SPACES).forEach(function (event) {
      if (options.once && !onceSupported) {
        var _element$listeners = element.listeners,
            listeners = _element$listeners === void 0 ? {} : _element$listeners;

        _handler = function handler() {
          delete listeners[event][listener];
          element.removeEventListener(event, _handler, options);

          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          listener.apply(element, args);
        };

        if (!listeners[event]) {
          listeners[event] = {};
        }

        if (listeners[event][listener]) {
          element.removeEventListener(event, listeners[event][listener], options);
        }

        listeners[event][listener] = _handler;
        element.listeners = listeners;
      }

      element.addEventListener(event, _handler, options);
    });
  }
  /**
   * Dispatch event on the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Object} data - The additional event data.
   * @returns {boolean} Indicate if the event is default prevented or not.
   */

  function dispatchEvent(element, type, data) {
    var event; // Event and CustomEvent on IE9-11 are global objects, not constructors

    if (isFunction(Event) && isFunction(CustomEvent)) {
      event = new CustomEvent(type, {
        detail: data,
        bubbles: true,
        cancelable: true
      });
    } else {
      event = document.createEvent('CustomEvent');
      event.initCustomEvent(type, true, true, data);
    }

    return element.dispatchEvent(event);
  }
  /**
   * Get the offset base on the document.
   * @param {Element} element - The target element.
   * @returns {Object} The offset data.
   */

  function getOffset(element) {
    var box = element.getBoundingClientRect();
    return {
      left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
      top: box.top + (window.pageYOffset - document.documentElement.clientTop)
    };
  }
  var location = WINDOW.location;
  var REGEXP_ORIGINS = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
  /**
   * Check if the given URL is a cross origin URL.
   * @param {string} url - The target URL.
   * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.
   */

  function isCrossOriginURL(url) {
    var parts = url.match(REGEXP_ORIGINS);
    return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);
  }
  /**
   * Add timestamp to the given URL.
   * @param {string} url - The target URL.
   * @returns {string} The result URL.
   */

  function addTimestamp(url) {
    var timestamp = "timestamp=".concat(new Date().getTime());
    return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;
  }
  /**
   * Get transforms base on the given object.
   * @param {Object} obj - The target object.
   * @returns {string} A string contains transform values.
   */

  function getTransforms(_ref) {
    var rotate = _ref.rotate,
        scaleX = _ref.scaleX,
        scaleY = _ref.scaleY,
        translateX = _ref.translateX,
        translateY = _ref.translateY;
    var values = [];

    if (isNumber(translateX) && translateX !== 0) {
      values.push("translateX(".concat(translateX, "px)"));
    }

    if (isNumber(translateY) && translateY !== 0) {
      values.push("translateY(".concat(translateY, "px)"));
    } // Rotate should come first before scale to match orientation transform


    if (isNumber(rotate) && rotate !== 0) {
      values.push("rotate(".concat(rotate, "deg)"));
    }

    if (isNumber(scaleX) && scaleX !== 1) {
      values.push("scaleX(".concat(scaleX, ")"));
    }

    if (isNumber(scaleY) && scaleY !== 1) {
      values.push("scaleY(".concat(scaleY, ")"));
    }

    var transform = values.length ? values.join(' ') : 'none';
    return {
      WebkitTransform: transform,
      msTransform: transform,
      transform: transform
    };
  }
  /**
   * Get the max ratio of a group of pointers.
   * @param {string} pointers - The target pointers.
   * @returns {number} The result ratio.
   */

  function getMaxZoomRatio(pointers) {
    var pointers2 = _objectSpread2({}, pointers);

    var ratios = [];
    forEach(pointers, function (pointer, pointerId) {
      delete pointers2[pointerId];
      forEach(pointers2, function (pointer2) {
        var x1 = Math.abs(pointer.startX - pointer2.startX);
        var y1 = Math.abs(pointer.startY - pointer2.startY);
        var x2 = Math.abs(pointer.endX - pointer2.endX);
        var y2 = Math.abs(pointer.endY - pointer2.endY);
        var z1 = Math.sqrt(x1 * x1 + y1 * y1);
        var z2 = Math.sqrt(x2 * x2 + y2 * y2);
        var ratio = (z2 - z1) / z1;
        ratios.push(ratio);
      });
    });
    ratios.sort(function (a, b) {
      return Math.abs(a) < Math.abs(b);
    });
    return ratios[0];
  }
  /**
   * Get a pointer from an event object.
   * @param {Object} event - The target event object.
   * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.
   * @returns {Object} The result pointer contains start and/or end point coordinates.
   */

  function getPointer(_ref2, endOnly) {
    var pageX = _ref2.pageX,
        pageY = _ref2.pageY;
    var end = {
      endX: pageX,
      endY: pageY
    };
    return endOnly ? end : _objectSpread2({
      startX: pageX,
      startY: pageY
    }, end);
  }
  /**
   * Get the center point coordinate of a group of pointers.
   * @param {Object} pointers - The target pointers.
   * @returns {Object} The center point coordinate.
   */

  function getPointersCenter(pointers) {
    var pageX = 0;
    var pageY = 0;
    var count = 0;
    forEach(pointers, function (_ref3) {
      var startX = _ref3.startX,
          startY = _ref3.startY;
      pageX += startX;
      pageY += startY;
      count += 1;
    });
    pageX /= count;
    pageY /= count;
    return {
      pageX: pageX,
      pageY: pageY
    };
  }
  /**
   * Get the max sizes in a rectangle under the given aspect ratio.
   * @param {Object} data - The original sizes.
   * @param {string} [type='contain'] - The adjust type.
   * @returns {Object} The result sizes.
   */

  function getAdjustedSizes(_ref4) // or 'cover'
  {
    var aspectRatio = _ref4.aspectRatio,
        height = _ref4.height,
        width = _ref4.width;
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'contain';
    var isValidWidth = isPositiveNumber(width);
    var isValidHeight = isPositiveNumber(height);

    if (isValidWidth && isValidHeight) {
      var adjustedWidth = height * aspectRatio;

      if (type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {
        height = width / aspectRatio;
      } else {
        width = height * aspectRatio;
      }
    } else if (isValidWidth) {
      height = width / aspectRatio;
    } else if (isValidHeight) {
      width = height * aspectRatio;
    }

    return {
      width: width,
      height: height
    };
  }
  /**
   * Get the new sizes of a rectangle after rotated.
   * @param {Object} data - The original sizes.
   * @returns {Object} The result sizes.
   */

  function getRotatedSizes(_ref5) {
    var width = _ref5.width,
        height = _ref5.height,
        degree = _ref5.degree;
    degree = Math.abs(degree) % 180;

    if (degree === 90) {
      return {
        width: height,
        height: width
      };
    }

    var arc = degree % 90 * Math.PI / 180;
    var sinArc = Math.sin(arc);
    var cosArc = Math.cos(arc);
    var newWidth = width * cosArc + height * sinArc;
    var newHeight = width * sinArc + height * cosArc;
    return degree > 90 ? {
      width: newHeight,
      height: newWidth
    } : {
      width: newWidth,
      height: newHeight
    };
  }
  /**
   * Get a canvas which drew the given image.
   * @param {HTMLImageElement} image - The image for drawing.
   * @param {Object} imageData - The image data.
   * @param {Object} canvasData - The canvas data.
   * @param {Object} options - The options.
   * @returns {HTMLCanvasElement} The result canvas.
   */

  function getSourceCanvas(image, _ref6, _ref7, _ref8) {
    var imageAspectRatio = _ref6.aspectRatio,
        imageNaturalWidth = _ref6.naturalWidth,
        imageNaturalHeight = _ref6.naturalHeight,
        _ref6$rotate = _ref6.rotate,
        rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate,
        _ref6$scaleX = _ref6.scaleX,
        scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX,
        _ref6$scaleY = _ref6.scaleY,
        scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;
    var aspectRatio = _ref7.aspectRatio,
        naturalWidth = _ref7.naturalWidth,
        naturalHeight = _ref7.naturalHeight;
    var _ref8$fillColor = _ref8.fillColor,
        fillColor = _ref8$fillColor === void 0 ? 'transparent' : _ref8$fillColor,
        _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,
        imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE,
        _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,
        imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? 'low' : _ref8$imageSmoothingQ,
        _ref8$maxWidth = _ref8.maxWidth,
        maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth,
        _ref8$maxHeight = _ref8.maxHeight,
        maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight,
        _ref8$minWidth = _ref8.minWidth,
        minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth,
        _ref8$minHeight = _ref8.minHeight,
        minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    var maxSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: maxWidth,
      height: maxHeight
    });
    var minSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: minWidth,
      height: minHeight
    }, 'cover');
    var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));
    var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight)); // Note: should always use image's natural sizes for drawing as
    // imageData.naturalWidth === canvasData.naturalHeight when rotate % 180 === 90

    var destMaxSizes = getAdjustedSizes({
      aspectRatio: imageAspectRatio,
      width: maxWidth,
      height: maxHeight
    });
    var destMinSizes = getAdjustedSizes({
      aspectRatio: imageAspectRatio,
      width: minWidth,
      height: minHeight
    }, 'cover');
    var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));
    var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));
    var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];
    canvas.width = normalizeDecimalNumber(width);
    canvas.height = normalizeDecimalNumber(height);
    context.fillStyle = fillColor;
    context.fillRect(0, 0, width, height);
    context.save();
    context.translate(width / 2, height / 2);
    context.rotate(rotate * Math.PI / 180);
    context.scale(scaleX, scaleY);
    context.imageSmoothingEnabled = imageSmoothingEnabled;
    context.imageSmoothingQuality = imageSmoothingQuality;
    context.drawImage.apply(context, [image].concat(_toConsumableArray(params.map(function (param) {
      return Math.floor(normalizeDecimalNumber(param));
    }))));
    context.restore();
    return canvas;
  }
  var fromCharCode = String.fromCharCode;
  /**
   * Get string from char code in data view.
   * @param {DataView} dataView - The data view for read.
   * @param {number} start - The start index.
   * @param {number} length - The read length.
   * @returns {string} The read result.
   */

  function getStringFromCharCode(dataView, start, length) {
    var str = '';
    length += start;

    for (var i = start; i < length; i += 1) {
      str += fromCharCode(dataView.getUint8(i));
    }

    return str;
  }
  var REGEXP_DATA_URL_HEAD = /^data:.*,/;
  /**
   * Transform Data URL to array buffer.
   * @param {string} dataURL - The Data URL to transform.
   * @returns {ArrayBuffer} The result array buffer.
   */

  function dataURLToArrayBuffer(dataURL) {
    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');
    var binary = atob(base64);
    var arrayBuffer = new ArrayBuffer(binary.length);
    var uint8 = new Uint8Array(arrayBuffer);
    forEach(uint8, function (value, i) {
      uint8[i] = binary.charCodeAt(i);
    });
    return arrayBuffer;
  }
  /**
   * Transform array buffer to Data URL.
   * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.
   * @param {string} mimeType - The mime type of the Data URL.
   * @returns {string} The result Data URL.
   */

  function arrayBufferToDataURL(arrayBuffer, mimeType) {
    var chunks = []; // Chunk Typed Array for better performance (#435)

    var chunkSize = 8192;
    var uint8 = new Uint8Array(arrayBuffer);

    while (uint8.length > 0) {
      // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9
      // eslint-disable-next-line prefer-spread
      chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));
      uint8 = uint8.subarray(chunkSize);
    }

    return "data:".concat(mimeType, ";base64,").concat(btoa(chunks.join('')));
  }
  /**
   * Get orientation value from given array buffer.
   * @param {ArrayBuffer} arrayBuffer - The array buffer to read.
   * @returns {number} The read orientation value.
   */

  function resetAndGetOrientation(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var orientation; // Ignores range error when the image does not have correct Exif information

    try {
      var littleEndian;
      var app1Start;
      var ifdStart; // Only handle JPEG image (start by 0xFFD8)

      if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {
        var length = dataView.byteLength;
        var offset = 2;

        while (offset + 1 < length) {
          if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {
            app1Start = offset;
            break;
          }

          offset += 1;
        }
      }

      if (app1Start) {
        var exifIDCode = app1Start + 4;
        var tiffOffset = app1Start + 10;

        if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {
          var endianness = dataView.getUint16(tiffOffset);
          littleEndian = endianness === 0x4949;

          if (littleEndian || endianness === 0x4D4D
          /* bigEndian */
          ) {
              if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {
                var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);

                if (firstIFDOffset >= 0x00000008) {
                  ifdStart = tiffOffset + firstIFDOffset;
                }
              }
            }
        }
      }

      if (ifdStart) {
        var _length = dataView.getUint16(ifdStart, littleEndian);

        var _offset;

        var i;

        for (i = 0; i < _length; i += 1) {
          _offset = ifdStart + i * 12 + 2;

          if (dataView.getUint16(_offset, littleEndian) === 0x0112
          /* Orientation */
          ) {
              // 8 is the offset of the current tag's value
              _offset += 8; // Get the original orientation value

              orientation = dataView.getUint16(_offset, littleEndian); // Override the orientation with its default value

              dataView.setUint16(_offset, 1, littleEndian);
              break;
            }
        }
      }
    } catch (error) {
      orientation = 1;
    }

    return orientation;
  }
  /**
   * Parse Exif Orientation value.
   * @param {number} orientation - The orientation to parse.
   * @returns {Object} The parsed result.
   */

  function parseOrientation(orientation) {
    var rotate = 0;
    var scaleX = 1;
    var scaleY = 1;

    switch (orientation) {
      // Flip horizontal
      case 2:
        scaleX = -1;
        break;
      // Rotate left 180°

      case 3:
        rotate = -180;
        break;
      // Flip vertical

      case 4:
        scaleY = -1;
        break;
      // Flip vertical and rotate right 90°

      case 5:
        rotate = 90;
        scaleY = -1;
        break;
      // Rotate right 90°

      case 6:
        rotate = 90;
        break;
      // Flip horizontal and rotate right 90°

      case 7:
        rotate = 90;
        scaleX = -1;
        break;
      // Rotate left 90°

      case 8:
        rotate = -90;
        break;
    }

    return {
      rotate: rotate,
      scaleX: scaleX,
      scaleY: scaleY
    };
  }

  var render = {
    render: function render() {
      this.initContainer();
      this.initCanvas();
      this.initCropBox();
      this.renderCanvas();

      if (this.cropped) {
        this.renderCropBox();
      }
    },
    initContainer: function initContainer() {
      var element = this.element,
          options = this.options,
          container = this.container,
          cropper = this.cropper;
      addClass(cropper, CLASS_HIDDEN);
      removeClass(element, CLASS_HIDDEN);
      var containerData = {
        width: Math.max(container.offsetWidth, Number(options.minContainerWidth) || 200),
        height: Math.max(container.offsetHeight, Number(options.minContainerHeight) || 100)
      };
      this.containerData = containerData;
      setStyle(cropper, {
        width: containerData.width,
        height: containerData.height
      });
      addClass(element, CLASS_HIDDEN);
      removeClass(cropper, CLASS_HIDDEN);
    },
    // Canvas (image wrapper)
    initCanvas: function initCanvas() {
      var containerData = this.containerData,
          imageData = this.imageData;
      var viewMode = this.options.viewMode;
      var rotated = Math.abs(imageData.rotate) % 180 === 90;
      var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
      var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
      var aspectRatio = naturalWidth / naturalHeight;
      var canvasWidth = containerData.width;
      var canvasHeight = containerData.height;

      if (containerData.height * aspectRatio > containerData.width) {
        if (viewMode === 3) {
          canvasWidth = containerData.height * aspectRatio;
        } else {
          canvasHeight = containerData.width / aspectRatio;
        }
      } else if (viewMode === 3) {
        canvasHeight = containerData.width / aspectRatio;
      } else {
        canvasWidth = containerData.height * aspectRatio;
      }

      var canvasData = {
        aspectRatio: aspectRatio,
        naturalWidth: naturalWidth,
        naturalHeight: naturalHeight,
        width: canvasWidth,
        height: canvasHeight
      };
      canvasData.left = (containerData.width - canvasWidth) / 2;
      canvasData.top = (containerData.height - canvasHeight) / 2;
      canvasData.oldLeft = canvasData.left;
      canvasData.oldTop = canvasData.top;
      this.canvasData = canvasData;
      this.limited = viewMode === 1 || viewMode === 2;
      this.limitCanvas(true, true);
      this.initialImageData = assign({}, imageData);
      this.initialCanvasData = assign({}, canvasData);
    },
    limitCanvas: function limitCanvas(sizeLimited, positionLimited) {
      var options = this.options,
          containerData = this.containerData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var viewMode = options.viewMode;
      var aspectRatio = canvasData.aspectRatio;
      var cropped = this.cropped && cropBoxData;

      if (sizeLimited) {
        var minCanvasWidth = Number(options.minCanvasWidth) || 0;
        var minCanvasHeight = Number(options.minCanvasHeight) || 0;

        if (viewMode > 1) {
          minCanvasWidth = Math.max(minCanvasWidth, containerData.width);
          minCanvasHeight = Math.max(minCanvasHeight, containerData.height);

          if (viewMode === 3) {
            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            } else {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            }
          }
        } else if (viewMode > 0) {
          if (minCanvasWidth) {
            minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);
          } else if (minCanvasHeight) {
            minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);
          } else if (cropped) {
            minCanvasWidth = cropBoxData.width;
            minCanvasHeight = cropBoxData.height;

            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            } else {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            }
          }
        }

        var _getAdjustedSizes = getAdjustedSizes({
          aspectRatio: aspectRatio,
          width: minCanvasWidth,
          height: minCanvasHeight
        });

        minCanvasWidth = _getAdjustedSizes.width;
        minCanvasHeight = _getAdjustedSizes.height;
        canvasData.minWidth = minCanvasWidth;
        canvasData.minHeight = minCanvasHeight;
        canvasData.maxWidth = Infinity;
        canvasData.maxHeight = Infinity;
      }

      if (positionLimited) {
        if (viewMode > (cropped ? 0 : 1)) {
          var newCanvasLeft = containerData.width - canvasData.width;
          var newCanvasTop = containerData.height - canvasData.height;
          canvasData.minLeft = Math.min(0, newCanvasLeft);
          canvasData.minTop = Math.min(0, newCanvasTop);
          canvasData.maxLeft = Math.max(0, newCanvasLeft);
          canvasData.maxTop = Math.max(0, newCanvasTop);

          if (cropped && this.limited) {
            canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));
            canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));
            canvasData.maxLeft = cropBoxData.left;
            canvasData.maxTop = cropBoxData.top;

            if (viewMode === 2) {
              if (canvasData.width >= containerData.width) {
                canvasData.minLeft = Math.min(0, newCanvasLeft);
                canvasData.maxLeft = Math.max(0, newCanvasLeft);
              }

              if (canvasData.height >= containerData.height) {
                canvasData.minTop = Math.min(0, newCanvasTop);
                canvasData.maxTop = Math.max(0, newCanvasTop);
              }
            }
          }
        } else {
          canvasData.minLeft = -canvasData.width;
          canvasData.minTop = -canvasData.height;
          canvasData.maxLeft = containerData.width;
          canvasData.maxTop = containerData.height;
        }
      }
    },
    renderCanvas: function renderCanvas(changed, transformed) {
      var canvasData = this.canvasData,
          imageData = this.imageData;

      if (transformed) {
        var _getRotatedSizes = getRotatedSizes({
          width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),
          height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),
          degree: imageData.rotate || 0
        }),
            naturalWidth = _getRotatedSizes.width,
            naturalHeight = _getRotatedSizes.height;

        var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);
        var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);
        canvasData.left -= (width - canvasData.width) / 2;
        canvasData.top -= (height - canvasData.height) / 2;
        canvasData.width = width;
        canvasData.height = height;
        canvasData.aspectRatio = naturalWidth / naturalHeight;
        canvasData.naturalWidth = naturalWidth;
        canvasData.naturalHeight = naturalHeight;
        this.limitCanvas(true, false);
      }

      if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {
        canvasData.left = canvasData.oldLeft;
      }

      if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {
        canvasData.top = canvasData.oldTop;
      }

      canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
      canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
      this.limitCanvas(false, true);
      canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);
      canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);
      canvasData.oldLeft = canvasData.left;
      canvasData.oldTop = canvasData.top;
      setStyle(this.canvas, assign({
        width: canvasData.width,
        height: canvasData.height
      }, getTransforms({
        translateX: canvasData.left,
        translateY: canvasData.top
      })));
      this.renderImage(changed);

      if (this.cropped && this.limited) {
        this.limitCropBox(true, true);
      }
    },
    renderImage: function renderImage(changed) {
      var canvasData = this.canvasData,
          imageData = this.imageData;
      var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);
      var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);
      assign(imageData, {
        width: width,
        height: height,
        left: (canvasData.width - width) / 2,
        top: (canvasData.height - height) / 2
      });
      setStyle(this.image, assign({
        width: imageData.width,
        height: imageData.height
      }, getTransforms(assign({
        translateX: imageData.left,
        translateY: imageData.top
      }, imageData))));

      if (changed) {
        this.output();
      }
    },
    initCropBox: function initCropBox() {
      var options = this.options,
          canvasData = this.canvasData;
      var aspectRatio = options.aspectRatio || options.initialAspectRatio;
      var autoCropArea = Number(options.autoCropArea) || 0.8;
      var cropBoxData = {
        width: canvasData.width,
        height: canvasData.height
      };

      if (aspectRatio) {
        if (canvasData.height * aspectRatio > canvasData.width) {
          cropBoxData.height = cropBoxData.width / aspectRatio;
        } else {
          cropBoxData.width = cropBoxData.height * aspectRatio;
        }
      }

      this.cropBoxData = cropBoxData;
      this.limitCropBox(true, true); // Initialize auto crop area

      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight); // The width/height of auto crop area must large than "minWidth/Height"

      cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);
      cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);
      cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;
      cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;
      cropBoxData.oldLeft = cropBoxData.left;
      cropBoxData.oldTop = cropBoxData.top;
      this.initialCropBoxData = assign({}, cropBoxData);
    },
    limitCropBox: function limitCropBox(sizeLimited, positionLimited) {
      var options = this.options,
          containerData = this.containerData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData,
          limited = this.limited;
      var aspectRatio = options.aspectRatio;

      if (sizeLimited) {
        var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
        var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
        var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;
        var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height; // The min/maxCropBoxWidth/Height must be less than container's width/height

        minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);
        minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);

        if (aspectRatio) {
          if (minCropBoxWidth && minCropBoxHeight) {
            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
              minCropBoxHeight = minCropBoxWidth / aspectRatio;
            } else {
              minCropBoxWidth = minCropBoxHeight * aspectRatio;
            }
          } else if (minCropBoxWidth) {
            minCropBoxHeight = minCropBoxWidth / aspectRatio;
          } else if (minCropBoxHeight) {
            minCropBoxWidth = minCropBoxHeight * aspectRatio;
          }

          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
          } else {
            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
          }
        } // The minWidth/Height must be less than maxWidth/Height


        cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
        cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
        cropBoxData.maxWidth = maxCropBoxWidth;
        cropBoxData.maxHeight = maxCropBoxHeight;
      }

      if (positionLimited) {
        if (limited) {
          cropBoxData.minLeft = Math.max(0, canvasData.left);
          cropBoxData.minTop = Math.max(0, canvasData.top);
          cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;
          cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;
        } else {
          cropBoxData.minLeft = 0;
          cropBoxData.minTop = 0;
          cropBoxData.maxLeft = containerData.width - cropBoxData.width;
          cropBoxData.maxTop = containerData.height - cropBoxData.height;
        }
      }
    },
    renderCropBox: function renderCropBox() {
      var options = this.options,
          containerData = this.containerData,
          cropBoxData = this.cropBoxData;

      if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {
        cropBoxData.left = cropBoxData.oldLeft;
      }

      if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {
        cropBoxData.top = cropBoxData.oldTop;
      }

      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
      this.limitCropBox(false, true);
      cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);
      cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);
      cropBoxData.oldLeft = cropBoxData.left;
      cropBoxData.oldTop = cropBoxData.top;

      if (options.movable && options.cropBoxMovable) {
        // Turn to move the canvas when the crop box is equal to the container
        setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);
      }

      setStyle(this.cropBox, assign({
        width: cropBoxData.width,
        height: cropBoxData.height
      }, getTransforms({
        translateX: cropBoxData.left,
        translateY: cropBoxData.top
      })));

      if (this.cropped && this.limited) {
        this.limitCanvas(true, true);
      }

      if (!this.disabled) {
        this.output();
      }
    },
    output: function output() {
      this.preview();
      dispatchEvent(this.element, EVENT_CROP, this.getData());
    }
  };

  var preview = {
    initPreview: function initPreview() {
      var element = this.element,
          crossOrigin = this.crossOrigin;
      var preview = this.options.preview;
      var url = crossOrigin ? this.crossOriginUrl : this.url;
      var alt = element.alt || 'The image to preview';
      var image = document.createElement('img');

      if (crossOrigin) {
        image.crossOrigin = crossOrigin;
      }

      image.src = url;
      image.alt = alt;
      this.viewBox.appendChild(image);
      this.viewBoxImage = image;

      if (!preview) {
        return;
      }

      var previews = preview;

      if (typeof preview === 'string') {
        previews = element.ownerDocument.querySelectorAll(preview);
      } else if (preview.querySelector) {
        previews = [preview];
      }

      this.previews = previews;
      forEach(previews, function (el) {
        var img = document.createElement('img'); // Save the original size for recover

        setData(el, DATA_PREVIEW, {
          width: el.offsetWidth,
          height: el.offsetHeight,
          html: el.innerHTML
        });

        if (crossOrigin) {
          img.crossOrigin = crossOrigin;
        }

        img.src = url;
        img.alt = alt;
        /**
         * Override img element styles
         * Add `display:block` to avoid margin top issue
         * Add `height:auto` to override `height` attribute on IE8
         * (Occur only when margin-top <= -height)
         */

        img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;"';
        el.innerHTML = '';
        el.appendChild(img);
      });
    },
    resetPreview: function resetPreview() {
      forEach(this.previews, function (element) {
        var data = getData(element, DATA_PREVIEW);
        setStyle(element, {
          width: data.width,
          height: data.height
        });
        element.innerHTML = data.html;
        removeData(element, DATA_PREVIEW);
      });
    },
    preview: function preview() {
      var imageData = this.imageData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var cropBoxWidth = cropBoxData.width,
          cropBoxHeight = cropBoxData.height;
      var width = imageData.width,
          height = imageData.height;
      var left = cropBoxData.left - canvasData.left - imageData.left;
      var top = cropBoxData.top - canvasData.top - imageData.top;

      if (!this.cropped || this.disabled) {
        return;
      }

      setStyle(this.viewBoxImage, assign({
        width: width,
        height: height
      }, getTransforms(assign({
        translateX: -left,
        translateY: -top
      }, imageData))));
      forEach(this.previews, function (element) {
        var data = getData(element, DATA_PREVIEW);
        var originalWidth = data.width;
        var originalHeight = data.height;
        var newWidth = originalWidth;
        var newHeight = originalHeight;
        var ratio = 1;

        if (cropBoxWidth) {
          ratio = originalWidth / cropBoxWidth;
          newHeight = cropBoxHeight * ratio;
        }

        if (cropBoxHeight && newHeight > originalHeight) {
          ratio = originalHeight / cropBoxHeight;
          newWidth = cropBoxWidth * ratio;
          newHeight = originalHeight;
        }

        setStyle(element, {
          width: newWidth,
          height: newHeight
        });
        setStyle(element.getElementsByTagName('img')[0], assign({
          width: width * ratio,
          height: height * ratio
        }, getTransforms(assign({
          translateX: -left * ratio,
          translateY: -top * ratio
        }, imageData))));
      });
    }
  };

  var events = {
    bind: function bind() {
      var element = this.element,
          options = this.options,
          cropper = this.cropper;

      if (isFunction(options.cropstart)) {
        addListener(element, EVENT_CROP_START, options.cropstart);
      }

      if (isFunction(options.cropmove)) {
        addListener(element, EVENT_CROP_MOVE, options.cropmove);
      }

      if (isFunction(options.cropend)) {
        addListener(element, EVENT_CROP_END, options.cropend);
      }

      if (isFunction(options.crop)) {
        addListener(element, EVENT_CROP, options.crop);
      }

      if (isFunction(options.zoom)) {
        addListener(element, EVENT_ZOOM, options.zoom);
      }

      addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));

      if (options.zoomable && options.zoomOnWheel) {
        addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
          passive: false,
          capture: true
        });
      }

      if (options.toggleDragModeOnDblclick) {
        addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
      }

      addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));
      addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));

      if (options.responsive) {
        addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
      }
    },
    unbind: function unbind() {
      var element = this.element,
          options = this.options,
          cropper = this.cropper;

      if (isFunction(options.cropstart)) {
        removeListener(element, EVENT_CROP_START, options.cropstart);
      }

      if (isFunction(options.cropmove)) {
        removeListener(element, EVENT_CROP_MOVE, options.cropmove);
      }

      if (isFunction(options.cropend)) {
        removeListener(element, EVENT_CROP_END, options.cropend);
      }

      if (isFunction(options.crop)) {
        removeListener(element, EVENT_CROP, options.crop);
      }

      if (isFunction(options.zoom)) {
        removeListener(element, EVENT_ZOOM, options.zoom);
      }

      removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);

      if (options.zoomable && options.zoomOnWheel) {
        removeListener(cropper, EVENT_WHEEL, this.onWheel, {
          passive: false,
          capture: true
        });
      }

      if (options.toggleDragModeOnDblclick) {
        removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);
      }

      removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);
      removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);

      if (options.responsive) {
        removeListener(window, EVENT_RESIZE, this.onResize);
      }
    }
  };

  var handlers = {
    resize: function resize() {
      if (this.disabled) {
        return;
      }

      var options = this.options,
          container = this.container,
          containerData = this.containerData;
      var ratio = container.offsetWidth / containerData.width; // Resize when width changed or height changed

      if (ratio !== 1 || container.offsetHeight !== containerData.height) {
        var canvasData;
        var cropBoxData;

        if (options.restore) {
          canvasData = this.getCanvasData();
          cropBoxData = this.getCropBoxData();
        }

        this.render();

        if (options.restore) {
          this.setCanvasData(forEach(canvasData, function (n, i) {
            canvasData[i] = n * ratio;
          }));
          this.setCropBoxData(forEach(cropBoxData, function (n, i) {
            cropBoxData[i] = n * ratio;
          }));
        }
      }
    },
    dblclick: function dblclick() {
      if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {
        return;
      }

      this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
    },
    wheel: function wheel(event) {
      var _this = this;

      var ratio = Number(this.options.wheelZoomRatio) || 0.1;
      var delta = 1;

      if (this.disabled) {
        return;
      }

      event.preventDefault(); // Limit wheel speed to prevent zoom too fast (#21)

      if (this.wheeling) {
        return;
      }

      this.wheeling = true;
      setTimeout(function () {
        _this.wheeling = false;
      }, 50);

      if (event.deltaY) {
        delta = event.deltaY > 0 ? 1 : -1;
      } else if (event.wheelDelta) {
        delta = -event.wheelDelta / 120;
      } else if (event.detail) {
        delta = event.detail > 0 ? 1 : -1;
      }

      this.zoom(-delta * ratio, event);
    },
    cropStart: function cropStart(event) {
      var buttons = event.buttons,
          button = event.button;

      if (this.disabled // Handle mouse event and pointer event and ignore touch event
      || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && ( // No primary button (Usually the left button)
      isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 // Open context menu
      || event.ctrlKey)) {
        return;
      }

      var options = this.options,
          pointers = this.pointers;
      var action;

      if (event.changedTouches) {
        // Handle touch event
        forEach(event.changedTouches, function (touch) {
          pointers[touch.identifier] = getPointer(touch);
        });
      } else {
        // Handle mouse event and pointer event
        pointers[event.pointerId || 0] = getPointer(event);
      }

      if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
        action = ACTION_ZOOM;
      } else {
        action = getData(event.target, DATA_ACTION);
      }

      if (!REGEXP_ACTIONS.test(action)) {
        return;
      }

      if (dispatchEvent(this.element, EVENT_CROP_START, {
        originalEvent: event,
        action: action
      }) === false) {
        return;
      } // This line is required for preventing page zooming in iOS browsers


      event.preventDefault();
      this.action = action;
      this.cropping = false;

      if (action === ACTION_CROP) {
        this.cropping = true;
        addClass(this.dragBox, CLASS_MODAL);
      }
    },
    cropMove: function cropMove(event) {
      var action = this.action;

      if (this.disabled || !action) {
        return;
      }

      var pointers = this.pointers;
      event.preventDefault();

      if (dispatchEvent(this.element, EVENT_CROP_MOVE, {
        originalEvent: event,
        action: action
      }) === false) {
        return;
      }

      if (event.changedTouches) {
        forEach(event.changedTouches, function (touch) {
          // The first parameter should not be undefined (#432)
          assign(pointers[touch.identifier] || {}, getPointer(touch, true));
        });
      } else {
        assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));
      }

      this.change(event);
    },
    cropEnd: function cropEnd(event) {
      if (this.disabled) {
        return;
      }

      var action = this.action,
          pointers = this.pointers;

      if (event.changedTouches) {
        forEach(event.changedTouches, function (touch) {
          delete pointers[touch.identifier];
        });
      } else {
        delete pointers[event.pointerId || 0];
      }

      if (!action) {
        return;
      }

      event.preventDefault();

      if (!Object.keys(pointers).length) {
        this.action = '';
      }

      if (this.cropping) {
        this.cropping = false;
        toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);
      }

      dispatchEvent(this.element, EVENT_CROP_END, {
        originalEvent: event,
        action: action
      });
    }
  };

  var change = {
    change: function change(event) {
      var options = this.options,
          canvasData = this.canvasData,
          containerData = this.containerData,
          cropBoxData = this.cropBoxData,
          pointers = this.pointers;
      var action = this.action;
      var aspectRatio = options.aspectRatio;
      var left = cropBoxData.left,
          top = cropBoxData.top,
          width = cropBoxData.width,
          height = cropBoxData.height;
      var right = left + width;
      var bottom = top + height;
      var minLeft = 0;
      var minTop = 0;
      var maxWidth = containerData.width;
      var maxHeight = containerData.height;
      var renderable = true;
      var offset; // Locking aspect ratio in "free mode" by holding shift key

      if (!aspectRatio && event.shiftKey) {
        aspectRatio = width && height ? width / height : 1;
      }

      if (this.limited) {
        minLeft = cropBoxData.minLeft;
        minTop = cropBoxData.minTop;
        maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);
        maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);
      }

      var pointer = pointers[Object.keys(pointers)[0]];
      var range = {
        x: pointer.endX - pointer.startX,
        y: pointer.endY - pointer.startY
      };

      var check = function check(side) {
        switch (side) {
          case ACTION_EAST:
            if (right + range.x > maxWidth) {
              range.x = maxWidth - right;
            }

            break;

          case ACTION_WEST:
            if (left + range.x < minLeft) {
              range.x = minLeft - left;
            }

            break;

          case ACTION_NORTH:
            if (top + range.y < minTop) {
              range.y = minTop - top;
            }

            break;

          case ACTION_SOUTH:
            if (bottom + range.y > maxHeight) {
              range.y = maxHeight - bottom;
            }

            break;
        }
      };

      switch (action) {
        // Move crop box
        case ACTION_ALL:
          left += range.x;
          top += range.y;
          break;
        // Resize crop box

        case ACTION_EAST:
          if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
            renderable = false;
            break;
          }

          check(ACTION_EAST);
          width += range.x;

          if (width < 0) {
            action = ACTION_WEST;
            width = -width;
            left -= width;
          }

          if (aspectRatio) {
            height = width / aspectRatio;
            top += (cropBoxData.height - height) / 2;
          }

          break;

        case ACTION_NORTH:
          if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
            renderable = false;
            break;
          }

          check(ACTION_NORTH);
          height -= range.y;
          top += range.y;

          if (height < 0) {
            action = ACTION_SOUTH;
            height = -height;
            top -= height;
          }

          if (aspectRatio) {
            width = height * aspectRatio;
            left += (cropBoxData.width - width) / 2;
          }

          break;

        case ACTION_WEST:
          if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
            renderable = false;
            break;
          }

          check(ACTION_WEST);
          width -= range.x;
          left += range.x;

          if (width < 0) {
            action = ACTION_EAST;
            width = -width;
            left -= width;
          }

          if (aspectRatio) {
            height = width / aspectRatio;
            top += (cropBoxData.height - height) / 2;
          }

          break;

        case ACTION_SOUTH:
          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
            renderable = false;
            break;
          }

          check(ACTION_SOUTH);
          height += range.y;

          if (height < 0) {
            action = ACTION_NORTH;
            height = -height;
            top -= height;
          }

          if (aspectRatio) {
            width = height * aspectRatio;
            left += (cropBoxData.width - width) / 2;
          }

          break;

        case ACTION_NORTH_EAST:
          if (aspectRatio) {
            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
              renderable = false;
              break;
            }

            check(ACTION_NORTH);
            height -= range.y;
            top += range.y;
            width = height * aspectRatio;
          } else {
            check(ACTION_NORTH);
            check(ACTION_EAST);

            if (range.x >= 0) {
              if (right < maxWidth) {
                width += range.x;
              } else if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            } else {
              width += range.x;
            }

            if (range.y <= 0) {
              if (top > minTop) {
                height -= range.y;
                top += range.y;
              }
            } else {
              height -= range.y;
              top += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_SOUTH_WEST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_NORTH_WEST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_SOUTH_EAST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_NORTH_WEST:
          if (aspectRatio) {
            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
              renderable = false;
              break;
            }

            check(ACTION_NORTH);
            height -= range.y;
            top += range.y;
            width = height * aspectRatio;
            left += cropBoxData.width - width;
          } else {
            check(ACTION_NORTH);
            check(ACTION_WEST);

            if (range.x <= 0) {
              if (left > minLeft) {
                width -= range.x;
                left += range.x;
              } else if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            } else {
              width -= range.x;
              left += range.x;
            }

            if (range.y <= 0) {
              if (top > minTop) {
                height -= range.y;
                top += range.y;
              }
            } else {
              height -= range.y;
              top += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_SOUTH_EAST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_NORTH_EAST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_SOUTH_WEST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_SOUTH_WEST:
          if (aspectRatio) {
            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
              renderable = false;
              break;
            }

            check(ACTION_WEST);
            width -= range.x;
            left += range.x;
            height = width / aspectRatio;
          } else {
            check(ACTION_SOUTH);
            check(ACTION_WEST);

            if (range.x <= 0) {
              if (left > minLeft) {
                width -= range.x;
                left += range.x;
              } else if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            } else {
              width -= range.x;
              left += range.x;
            }

            if (range.y >= 0) {
              if (bottom < maxHeight) {
                height += range.y;
              }
            } else {
              height += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_NORTH_EAST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_SOUTH_EAST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_NORTH_WEST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_SOUTH_EAST:
          if (aspectRatio) {
            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
              renderable = false;
              break;
            }

            check(ACTION_EAST);
            width += range.x;
            height = width / aspectRatio;
          } else {
            check(ACTION_SOUTH);
            check(ACTION_EAST);

            if (range.x >= 0) {
              if (right < maxWidth) {
                width += range.x;
              } else if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            } else {
              width += range.x;
            }

            if (range.y >= 0) {
              if (bottom < maxHeight) {
                height += range.y;
              }
            } else {
              height += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_NORTH_WEST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_SOUTH_WEST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_NORTH_EAST;
            height = -height;
            top -= height;
          }

          break;
        // Move canvas

        case ACTION_MOVE:
          this.move(range.x, range.y);
          renderable = false;
          break;
        // Zoom canvas

        case ACTION_ZOOM:
          this.zoom(getMaxZoomRatio(pointers), event);
          renderable = false;
          break;
        // Create crop box

        case ACTION_CROP:
          if (!range.x || !range.y) {
            renderable = false;
            break;
          }

          offset = getOffset(this.cropper);
          left = pointer.startX - offset.left;
          top = pointer.startY - offset.top;
          width = cropBoxData.minWidth;
          height = cropBoxData.minHeight;

          if (range.x > 0) {
            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
          } else if (range.x < 0) {
            left -= width;
            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
          }

          if (range.y < 0) {
            top -= height;
          } // Show the crop box if is hidden


          if (!this.cropped) {
            removeClass(this.cropBox, CLASS_HIDDEN);
            this.cropped = true;

            if (this.limited) {
              this.limitCropBox(true, true);
            }
          }

          break;
      }

      if (renderable) {
        cropBoxData.width = width;
        cropBoxData.height = height;
        cropBoxData.left = left;
        cropBoxData.top = top;
        this.action = action;
        this.renderCropBox();
      } // Override


      forEach(pointers, function (p) {
        p.startX = p.endX;
        p.startY = p.endY;
      });
    }
  };

  var methods = {
    // Show the crop box manually
    crop: function crop() {
      if (this.ready && !this.cropped && !this.disabled) {
        this.cropped = true;
        this.limitCropBox(true, true);

        if (this.options.modal) {
          addClass(this.dragBox, CLASS_MODAL);
        }

        removeClass(this.cropBox, CLASS_HIDDEN);
        this.setCropBoxData(this.initialCropBoxData);
      }

      return this;
    },
    // Reset the image and crop box to their initial states
    reset: function reset() {
      if (this.ready && !this.disabled) {
        this.imageData = assign({}, this.initialImageData);
        this.canvasData = assign({}, this.initialCanvasData);
        this.cropBoxData = assign({}, this.initialCropBoxData);
        this.renderCanvas();

        if (this.cropped) {
          this.renderCropBox();
        }
      }

      return this;
    },
    // Clear the crop box
    clear: function clear() {
      if (this.cropped && !this.disabled) {
        assign(this.cropBoxData, {
          left: 0,
          top: 0,
          width: 0,
          height: 0
        });
        this.cropped = false;
        this.renderCropBox();
        this.limitCanvas(true, true); // Render canvas after crop box rendered

        this.renderCanvas();
        removeClass(this.dragBox, CLASS_MODAL);
        addClass(this.cropBox, CLASS_HIDDEN);
      }

      return this;
    },

    /**
     * Replace the image's src and rebuild the cropper
     * @param {string} url - The new URL.
     * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.
     * @returns {Cropper} this
     */
    replace: function replace(url) {
      var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.disabled && url) {
        if (this.isImg) {
          this.element.src = url;
        }

        if (hasSameSize) {
          this.url = url;
          this.image.src = url;

          if (this.ready) {
            this.viewBoxImage.src = url;
            forEach(this.previews, function (element) {
              element.getElementsByTagName('img')[0].src = url;
            });
          }
        } else {
          if (this.isImg) {
            this.replaced = true;
          }

          this.options.data = null;
          this.uncreate();
          this.load(url);
        }
      }

      return this;
    },
    // Enable (unfreeze) the cropper
    enable: function enable() {
      if (this.ready && this.disabled) {
        this.disabled = false;
        removeClass(this.cropper, CLASS_DISABLED);
      }

      return this;
    },
    // Disable (freeze) the cropper
    disable: function disable() {
      if (this.ready && !this.disabled) {
        this.disabled = true;
        addClass(this.cropper, CLASS_DISABLED);
      }

      return this;
    },

    /**
     * Destroy the cropper and remove the instance from the image
     * @returns {Cropper} this
     */
    destroy: function destroy() {
      var element = this.element;

      if (!element[NAMESPACE]) {
        return this;
      }

      element[NAMESPACE] = undefined;

      if (this.isImg && this.replaced) {
        element.src = this.originalUrl;
      }

      this.uncreate();
      return this;
    },

    /**
     * Move the canvas with relative offsets
     * @param {number} offsetX - The relative offset distance on the x-axis.
     * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.
     * @returns {Cropper} this
     */
    move: function move(offsetX) {
      var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : offsetX;
      var _this$canvasData = this.canvasData,
          left = _this$canvasData.left,
          top = _this$canvasData.top;
      return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));
    },

    /**
     * Move the canvas to an absolute point
     * @param {number} x - The x-axis coordinate.
     * @param {number} [y=x] - The y-axis coordinate.
     * @returns {Cropper} this
     */
    moveTo: function moveTo(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
      var canvasData = this.canvasData;
      var changed = false;
      x = Number(x);
      y = Number(y);

      if (this.ready && !this.disabled && this.options.movable) {
        if (isNumber(x)) {
          canvasData.left = x;
          changed = true;
        }

        if (isNumber(y)) {
          canvasData.top = y;
          changed = true;
        }

        if (changed) {
          this.renderCanvas(true);
        }
      }

      return this;
    },

    /**
     * Zoom the canvas with a relative ratio
     * @param {number} ratio - The target ratio.
     * @param {Event} _originalEvent - The original event if any.
     * @returns {Cropper} this
     */
    zoom: function zoom(ratio, _originalEvent) {
      var canvasData = this.canvasData;
      ratio = Number(ratio);

      if (ratio < 0) {
        ratio = 1 / (1 - ratio);
      } else {
        ratio = 1 + ratio;
      }

      return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);
    },

    /**
     * Zoom the canvas to an absolute ratio
     * @param {number} ratio - The target ratio.
     * @param {Object} pivot - The zoom pivot point coordinate.
     * @param {Event} _originalEvent - The original event if any.
     * @returns {Cropper} this
     */
    zoomTo: function zoomTo(ratio, pivot, _originalEvent) {
      var options = this.options,
          canvasData = this.canvasData;
      var width = canvasData.width,
          height = canvasData.height,
          naturalWidth = canvasData.naturalWidth,
          naturalHeight = canvasData.naturalHeight;
      ratio = Number(ratio);

      if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {
        var newWidth = naturalWidth * ratio;
        var newHeight = naturalHeight * ratio;

        if (dispatchEvent(this.element, EVENT_ZOOM, {
          ratio: ratio,
          oldRatio: width / naturalWidth,
          originalEvent: _originalEvent
        }) === false) {
          return this;
        }

        if (_originalEvent) {
          var pointers = this.pointers;
          var offset = getOffset(this.cropper);
          var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
            pageX: _originalEvent.pageX,
            pageY: _originalEvent.pageY
          }; // Zoom from the triggering point of the event

          canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);
          canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);
        } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {
          canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);
          canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);
        } else {
          // Zoom from the center of the canvas
          canvasData.left -= (newWidth - width) / 2;
          canvasData.top -= (newHeight - height) / 2;
        }

        canvasData.width = newWidth;
        canvasData.height = newHeight;
        this.renderCanvas(true);
      }

      return this;
    },

    /**
     * Rotate the canvas with a relative degree
     * @param {number} degree - The rotate degree.
     * @returns {Cropper} this
     */
    rotate: function rotate(degree) {
      return this.rotateTo((this.imageData.rotate || 0) + Number(degree));
    },

    /**
     * Rotate the canvas to an absolute degree
     * @param {number} degree - The rotate degree.
     * @returns {Cropper} this
     */
    rotateTo: function rotateTo(degree) {
      degree = Number(degree);

      if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {
        this.imageData.rotate = degree % 360;
        this.renderCanvas(true, true);
      }

      return this;
    },

    /**
     * Scale the image on the x-axis.
     * @param {number} scaleX - The scale ratio on the x-axis.
     * @returns {Cropper} this
     */
    scaleX: function scaleX(_scaleX) {
      var scaleY = this.imageData.scaleY;
      return this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);
    },

    /**
     * Scale the image on the y-axis.
     * @param {number} scaleY - The scale ratio on the y-axis.
     * @returns {Cropper} this
     */
    scaleY: function scaleY(_scaleY) {
      var scaleX = this.imageData.scaleX;
      return this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);
    },

    /**
     * Scale the image
     * @param {number} scaleX - The scale ratio on the x-axis.
     * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
     * @returns {Cropper} this
     */
    scale: function scale(scaleX) {
      var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;
      var imageData = this.imageData;
      var transformed = false;
      scaleX = Number(scaleX);
      scaleY = Number(scaleY);

      if (this.ready && !this.disabled && this.options.scalable) {
        if (isNumber(scaleX)) {
          imageData.scaleX = scaleX;
          transformed = true;
        }

        if (isNumber(scaleY)) {
          imageData.scaleY = scaleY;
          transformed = true;
        }

        if (transformed) {
          this.renderCanvas(true, true);
        }
      }

      return this;
    },

    /**
     * Get the cropped area position and size data (base on the original image)
     * @param {boolean} [rounded=false] - Indicate if round the data values or not.
     * @returns {Object} The result cropped data.
     */
    getData: function getData() {
      var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var options = this.options,
          imageData = this.imageData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var data;

      if (this.ready && this.cropped) {
        data = {
          x: cropBoxData.left - canvasData.left,
          y: cropBoxData.top - canvasData.top,
          width: cropBoxData.width,
          height: cropBoxData.height
        };
        var ratio = imageData.width / imageData.naturalWidth;
        forEach(data, function (n, i) {
          data[i] = n / ratio;
        });

        if (rounded) {
          // In case rounding off leads to extra 1px in right or bottom border
          // we should round the top-left corner and the dimension (#343).
          var bottom = Math.round(data.y + data.height);
          var right = Math.round(data.x + data.width);
          data.x = Math.round(data.x);
          data.y = Math.round(data.y);
          data.width = right - data.x;
          data.height = bottom - data.y;
        }
      } else {
        data = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }

      if (options.rotatable) {
        data.rotate = imageData.rotate || 0;
      }

      if (options.scalable) {
        data.scaleX = imageData.scaleX || 1;
        data.scaleY = imageData.scaleY || 1;
      }

      return data;
    },

    /**
     * Set the cropped area position and size with new data
     * @param {Object} data - The new data.
     * @returns {Cropper} this
     */
    setData: function setData(data) {
      var options = this.options,
          imageData = this.imageData,
          canvasData = this.canvasData;
      var cropBoxData = {};

      if (this.ready && !this.disabled && isPlainObject(data)) {
        var transformed = false;

        if (options.rotatable) {
          if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {
            imageData.rotate = data.rotate;
            transformed = true;
          }
        }

        if (options.scalable) {
          if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {
            imageData.scaleX = data.scaleX;
            transformed = true;
          }

          if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {
            imageData.scaleY = data.scaleY;
            transformed = true;
          }
        }

        if (transformed) {
          this.renderCanvas(true, true);
        }

        var ratio = imageData.width / imageData.naturalWidth;

        if (isNumber(data.x)) {
          cropBoxData.left = data.x * ratio + canvasData.left;
        }

        if (isNumber(data.y)) {
          cropBoxData.top = data.y * ratio + canvasData.top;
        }

        if (isNumber(data.width)) {
          cropBoxData.width = data.width * ratio;
        }

        if (isNumber(data.height)) {
          cropBoxData.height = data.height * ratio;
        }

        this.setCropBoxData(cropBoxData);
      }

      return this;
    },

    /**
     * Get the container size data.
     * @returns {Object} The result container data.
     */
    getContainerData: function getContainerData() {
      return this.ready ? assign({}, this.containerData) : {};
    },

    /**
     * Get the image position and size data.
     * @returns {Object} The result image data.
     */
    getImageData: function getImageData() {
      return this.sized ? assign({}, this.imageData) : {};
    },

    /**
     * Get the canvas position and size data.
     * @returns {Object} The result canvas data.
     */
    getCanvasData: function getCanvasData() {
      var canvasData = this.canvasData;
      var data = {};

      if (this.ready) {
        forEach(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {
          data[n] = canvasData[n];
        });
      }

      return data;
    },

    /**
     * Set the canvas position and size with new data.
     * @param {Object} data - The new canvas data.
     * @returns {Cropper} this
     */
    setCanvasData: function setCanvasData(data) {
      var canvasData = this.canvasData;
      var aspectRatio = canvasData.aspectRatio;

      if (this.ready && !this.disabled && isPlainObject(data)) {
        if (isNumber(data.left)) {
          canvasData.left = data.left;
        }

        if (isNumber(data.top)) {
          canvasData.top = data.top;
        }

        if (isNumber(data.width)) {
          canvasData.width = data.width;
          canvasData.height = data.width / aspectRatio;
        } else if (isNumber(data.height)) {
          canvasData.height = data.height;
          canvasData.width = data.height * aspectRatio;
        }

        this.renderCanvas(true);
      }

      return this;
    },

    /**
     * Get the crop box position and size data.
     * @returns {Object} The result crop box data.
     */
    getCropBoxData: function getCropBoxData() {
      var cropBoxData = this.cropBoxData;
      var data;

      if (this.ready && this.cropped) {
        data = {
          left: cropBoxData.left,
          top: cropBoxData.top,
          width: cropBoxData.width,
          height: cropBoxData.height
        };
      }

      return data || {};
    },

    /**
     * Set the crop box position and size with new data.
     * @param {Object} data - The new crop box data.
     * @returns {Cropper} this
     */
    setCropBoxData: function setCropBoxData(data) {
      var cropBoxData = this.cropBoxData;
      var aspectRatio = this.options.aspectRatio;
      var widthChanged;
      var heightChanged;

      if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {
        if (isNumber(data.left)) {
          cropBoxData.left = data.left;
        }

        if (isNumber(data.top)) {
          cropBoxData.top = data.top;
        }

        if (isNumber(data.width) && data.width !== cropBoxData.width) {
          widthChanged = true;
          cropBoxData.width = data.width;
        }

        if (isNumber(data.height) && data.height !== cropBoxData.height) {
          heightChanged = true;
          cropBoxData.height = data.height;
        }

        if (aspectRatio) {
          if (widthChanged) {
            cropBoxData.height = cropBoxData.width / aspectRatio;
          } else if (heightChanged) {
            cropBoxData.width = cropBoxData.height * aspectRatio;
          }
        }

        this.renderCropBox();
      }

      return this;
    },

    /**
     * Get a canvas drawn the cropped image.
     * @param {Object} [options={}] - The config options.
     * @returns {HTMLCanvasElement} - The result canvas.
     */
    getCroppedCanvas: function getCroppedCanvas() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.ready || !window.HTMLCanvasElement) {
        return null;
      }

      var canvasData = this.canvasData;
      var source = getSourceCanvas(this.image, this.imageData, canvasData, options); // Returns the source canvas if it is not cropped.

      if (!this.cropped) {
        return source;
      }

      var _this$getData = this.getData(),
          initialX = _this$getData.x,
          initialY = _this$getData.y,
          initialWidth = _this$getData.width,
          initialHeight = _this$getData.height;

      var ratio = source.width / Math.floor(canvasData.naturalWidth);

      if (ratio !== 1) {
        initialX *= ratio;
        initialY *= ratio;
        initialWidth *= ratio;
        initialHeight *= ratio;
      }

      var aspectRatio = initialWidth / initialHeight;
      var maxSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.maxWidth || Infinity,
        height: options.maxHeight || Infinity
      });
      var minSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.minWidth || 0,
        height: options.minHeight || 0
      }, 'cover');

      var _getAdjustedSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.width || (ratio !== 1 ? source.width : initialWidth),
        height: options.height || (ratio !== 1 ? source.height : initialHeight)
      }),
          width = _getAdjustedSizes.width,
          height = _getAdjustedSizes.height;

      width = Math.min(maxSizes.width, Math.max(minSizes.width, width));
      height = Math.min(maxSizes.height, Math.max(minSizes.height, height));
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      canvas.width = normalizeDecimalNumber(width);
      canvas.height = normalizeDecimalNumber(height);
      context.fillStyle = options.fillColor || 'transparent';
      context.fillRect(0, 0, width, height);
      var _options$imageSmoothi = options.imageSmoothingEnabled,
          imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi,
          imageSmoothingQuality = options.imageSmoothingQuality;
      context.imageSmoothingEnabled = imageSmoothingEnabled;

      if (imageSmoothingQuality) {
        context.imageSmoothingQuality = imageSmoothingQuality;
      } // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage


      var sourceWidth = source.width;
      var sourceHeight = source.height; // Source canvas parameters

      var srcX = initialX;
      var srcY = initialY;
      var srcWidth;
      var srcHeight; // Destination canvas parameters

      var dstX;
      var dstY;
      var dstWidth;
      var dstHeight;

      if (srcX <= -initialWidth || srcX > sourceWidth) {
        srcX = 0;
        srcWidth = 0;
        dstX = 0;
        dstWidth = 0;
      } else if (srcX <= 0) {
        dstX = -srcX;
        srcX = 0;
        srcWidth = Math.min(sourceWidth, initialWidth + srcX);
        dstWidth = srcWidth;
      } else if (srcX <= sourceWidth) {
        dstX = 0;
        srcWidth = Math.min(initialWidth, sourceWidth - srcX);
        dstWidth = srcWidth;
      }

      if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {
        srcY = 0;
        srcHeight = 0;
        dstY = 0;
        dstHeight = 0;
      } else if (srcY <= 0) {
        dstY = -srcY;
        srcY = 0;
        srcHeight = Math.min(sourceHeight, initialHeight + srcY);
        dstHeight = srcHeight;
      } else if (srcY <= sourceHeight) {
        dstY = 0;
        srcHeight = Math.min(initialHeight, sourceHeight - srcY);
        dstHeight = srcHeight;
      }

      var params = [srcX, srcY, srcWidth, srcHeight]; // Avoid "IndexSizeError"

      if (dstWidth > 0 && dstHeight > 0) {
        var scale = width / initialWidth;
        params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);
      } // All the numerical parameters should be integer for `drawImage`
      // https://github.com/fengyuanchen/cropper/issues/476


      context.drawImage.apply(context, [source].concat(_toConsumableArray(params.map(function (param) {
        return Math.floor(normalizeDecimalNumber(param));
      }))));
      return canvas;
    },

    /**
     * Change the aspect ratio of the crop box.
     * @param {number} aspectRatio - The new aspect ratio.
     * @returns {Cropper} this
     */
    setAspectRatio: function setAspectRatio(aspectRatio) {
      var options = this.options;

      if (!this.disabled && !isUndefined(aspectRatio)) {
        // 0 -> NaN
        options.aspectRatio = Math.max(0, aspectRatio) || NaN;

        if (this.ready) {
          this.initCropBox();

          if (this.cropped) {
            this.renderCropBox();
          }
        }
      }

      return this;
    },

    /**
     * Change the drag mode.
     * @param {string} mode - The new drag mode.
     * @returns {Cropper} this
     */
    setDragMode: function setDragMode(mode) {
      var options = this.options,
          dragBox = this.dragBox,
          face = this.face;

      if (this.ready && !this.disabled) {
        var croppable = mode === DRAG_MODE_CROP;
        var movable = options.movable && mode === DRAG_MODE_MOVE;
        mode = croppable || movable ? mode : DRAG_MODE_NONE;
        options.dragMode = mode;
        setData(dragBox, DATA_ACTION, mode);
        toggleClass(dragBox, CLASS_CROP, croppable);
        toggleClass(dragBox, CLASS_MOVE, movable);

        if (!options.cropBoxMovable) {
          // Sync drag mode to crop box when it is not movable
          setData(face, DATA_ACTION, mode);
          toggleClass(face, CLASS_CROP, croppable);
          toggleClass(face, CLASS_MOVE, movable);
        }
      }

      return this;
    }
  };

  var AnotherCropper = WINDOW.Cropper;

  var Cropper = /*#__PURE__*/function () {
    /**
     * Create a new Cropper.
     * @param {Element} element - The target element for cropping.
     * @param {Object} [options={}] - The configuration options.
     */
    function Cropper(element) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Cropper);

      if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {
        throw new Error('The first argument is required and must be an <img> or <canvas> element.');
      }

      this.element = element;
      this.options = assign({}, DEFAULTS, isPlainObject(options) && options);
      this.cropped = false;
      this.disabled = false;
      this.pointers = {};
      this.ready = false;
      this.reloading = false;
      this.replaced = false;
      this.sized = false;
      this.sizing = false;
      this.init();
    }

    _createClass(Cropper, [{
      key: "init",
      value: function init() {
        var element = this.element;
        var tagName = element.tagName.toLowerCase();
        var url;

        if (element[NAMESPACE]) {
          return;
        }

        element[NAMESPACE] = this;

        if (tagName === 'img') {
          this.isImg = true; // e.g.: "img/picture.jpg"

          url = element.getAttribute('src') || '';
          this.originalUrl = url; // Stop when it's a blank image

          if (!url) {
            return;
          } // e.g.: "https://example.com/img/picture.jpg"


          url = element.src;
        } else if (tagName === 'canvas' && window.HTMLCanvasElement) {
          url = element.toDataURL();
        }

        this.load(url);
      }
    }, {
      key: "load",
      value: function load(url) {
        var _this = this;

        if (!url) {
          return;
        }

        this.url = url;
        this.imageData = {};
        var element = this.element,
            options = this.options;

        if (!options.rotatable && !options.scalable) {
          options.checkOrientation = false;
        } // Only IE10+ supports Typed Arrays


        if (!options.checkOrientation || !window.ArrayBuffer) {
          this.clone();
          return;
        } // Detect the mime type of the image directly if it is a Data URL


        if (REGEXP_DATA_URL.test(url)) {
          // Read ArrayBuffer from Data URL of JPEG images directly for better performance
          if (REGEXP_DATA_URL_JPEG.test(url)) {
            this.read(dataURLToArrayBuffer(url));
          } else {
            // Only a JPEG image may contains Exif Orientation information,
            // the rest types of Data URLs are not necessary to check orientation at all.
            this.clone();
          }

          return;
        } // 1. Detect the mime type of the image by a XMLHttpRequest.
        // 2. Load the image as ArrayBuffer for reading orientation if its a JPEG image.


        var xhr = new XMLHttpRequest();
        var clone = this.clone.bind(this);
        this.reloading = true;
        this.xhr = xhr; // 1. Cross origin requests are only supported for protocol schemes:
        // http, https, data, chrome, chrome-extension.
        // 2. Access to XMLHttpRequest from a Data URL will be blocked by CORS policy
        // in some browsers as IE11 and Safari.

        xhr.onabort = clone;
        xhr.onerror = clone;
        xhr.ontimeout = clone;

        xhr.onprogress = function () {
          // Abort the request directly if it not a JPEG image for better performance
          if (xhr.getResponseHeader('content-type') !== MIME_TYPE_JPEG) {
            xhr.abort();
          }
        };

        xhr.onload = function () {
          _this.read(xhr.response);
        };

        xhr.onloadend = function () {
          _this.reloading = false;
          _this.xhr = null;
        }; // Bust cache when there is a "crossOrigin" property to avoid browser cache error


        if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {
          url = addTimestamp(url);
        }

        xhr.open('GET', url);
        xhr.responseType = 'arraybuffer';
        xhr.withCredentials = element.crossOrigin === 'use-credentials';
        xhr.send();
      }
    }, {
      key: "read",
      value: function read(arrayBuffer) {
        var options = this.options,
            imageData = this.imageData; // Reset the orientation value to its default value 1
        // as some iOS browsers will render image with its orientation

        var orientation = resetAndGetOrientation(arrayBuffer);
        var rotate = 0;
        var scaleX = 1;
        var scaleY = 1;

        if (orientation > 1) {
          // Generate a new URL which has the default orientation value
          this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);

          var _parseOrientation = parseOrientation(orientation);

          rotate = _parseOrientation.rotate;
          scaleX = _parseOrientation.scaleX;
          scaleY = _parseOrientation.scaleY;
        }

        if (options.rotatable) {
          imageData.rotate = rotate;
        }

        if (options.scalable) {
          imageData.scaleX = scaleX;
          imageData.scaleY = scaleY;
        }

        this.clone();
      }
    }, {
      key: "clone",
      value: function clone() {
        var element = this.element,
            url = this.url;
        var crossOrigin = element.crossOrigin;
        var crossOriginUrl = url;

        if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {
          if (!crossOrigin) {
            crossOrigin = 'anonymous';
          } // Bust cache when there is not a "crossOrigin" property (#519)


          crossOriginUrl = addTimestamp(url);
        }

        this.crossOrigin = crossOrigin;
        this.crossOriginUrl = crossOriginUrl;
        var image = document.createElement('img');

        if (crossOrigin) {
          image.crossOrigin = crossOrigin;
        }

        image.src = crossOriginUrl || url;
        image.alt = element.alt || 'The image to crop';
        this.image = image;
        image.onload = this.start.bind(this);
        image.onerror = this.stop.bind(this);
        addClass(image, CLASS_HIDE);
        element.parentNode.insertBefore(image, element.nextSibling);
      }
    }, {
      key: "start",
      value: function start() {
        var _this2 = this;

        var image = this.image;
        image.onload = null;
        image.onerror = null;
        this.sizing = true; // Match all browsers that use WebKit as the layout engine in iOS devices,
        // such as Safari for iOS, Chrome for iOS, and in-app browsers.

        var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);

        var done = function done(naturalWidth, naturalHeight) {
          assign(_this2.imageData, {
            naturalWidth: naturalWidth,
            naturalHeight: naturalHeight,
            aspectRatio: naturalWidth / naturalHeight
          });
          _this2.sizing = false;
          _this2.sized = true;

          _this2.build();
        }; // Most modern browsers (excepts iOS WebKit)


        if (image.naturalWidth && !isIOSWebKit) {
          done(image.naturalWidth, image.naturalHeight);
          return;
        }

        var sizingImage = document.createElement('img');
        var body = document.body || document.documentElement;
        this.sizingImage = sizingImage;

        sizingImage.onload = function () {
          done(sizingImage.width, sizingImage.height);

          if (!isIOSWebKit) {
            body.removeChild(sizingImage);
          }
        };

        sizingImage.src = image.src; // iOS WebKit will convert the image automatically
        // with its orientation once append it into DOM (#279)

        if (!isIOSWebKit) {
          sizingImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';
          body.appendChild(sizingImage);
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        var image = this.image;
        image.onload = null;
        image.onerror = null;
        image.parentNode.removeChild(image);
        this.image = null;
      }
    }, {
      key: "build",
      value: function build() {
        if (!this.sized || this.ready) {
          return;
        }

        var element = this.element,
            options = this.options,
            image = this.image; // Create cropper elements

        var container = element.parentNode;
        var template = document.createElement('div');
        template.innerHTML = TEMPLATE;
        var cropper = template.querySelector(".".concat(NAMESPACE, "-container"));
        var canvas = cropper.querySelector(".".concat(NAMESPACE, "-canvas"));
        var dragBox = cropper.querySelector(".".concat(NAMESPACE, "-drag-box"));
        var cropBox = cropper.querySelector(".".concat(NAMESPACE, "-crop-box"));
        var face = cropBox.querySelector(".".concat(NAMESPACE, "-face"));
        this.container = container;
        this.cropper = cropper;
        this.canvas = canvas;
        this.dragBox = dragBox;
        this.cropBox = cropBox;
        this.viewBox = cropper.querySelector(".".concat(NAMESPACE, "-view-box"));
        this.face = face;
        canvas.appendChild(image); // Hide the original image

        addClass(element, CLASS_HIDDEN); // Inserts the cropper after to the current image

        container.insertBefore(cropper, element.nextSibling); // Show the image if is hidden

        if (!this.isImg) {
          removeClass(image, CLASS_HIDE);
        }

        this.initPreview();
        this.bind();
        options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;
        options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
        options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;
        addClass(cropBox, CLASS_HIDDEN);

        if (!options.guides) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-dashed")), CLASS_HIDDEN);
        }

        if (!options.center) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-center")), CLASS_HIDDEN);
        }

        if (options.background) {
          addClass(cropper, "".concat(NAMESPACE, "-bg"));
        }

        if (!options.highlight) {
          addClass(face, CLASS_INVISIBLE);
        }

        if (options.cropBoxMovable) {
          addClass(face, CLASS_MOVE);
          setData(face, DATA_ACTION, ACTION_ALL);
        }

        if (!options.cropBoxResizable) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-line")), CLASS_HIDDEN);
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-point")), CLASS_HIDDEN);
        }

        this.render();
        this.ready = true;
        this.setDragMode(options.dragMode);

        if (options.autoCrop) {
          this.crop();
        }

        this.setData(options.data);

        if (isFunction(options.ready)) {
          addListener(element, EVENT_READY, options.ready, {
            once: true
          });
        }

        dispatchEvent(element, EVENT_READY);
      }
    }, {
      key: "unbuild",
      value: function unbuild() {
        if (!this.ready) {
          return;
        }

        this.ready = false;
        this.unbind();
        this.resetPreview();
        this.cropper.parentNode.removeChild(this.cropper);
        removeClass(this.element, CLASS_HIDDEN);
      }
    }, {
      key: "uncreate",
      value: function uncreate() {
        if (this.ready) {
          this.unbuild();
          this.ready = false;
          this.cropped = false;
        } else if (this.sizing) {
          this.sizingImage.onload = null;
          this.sizing = false;
          this.sized = false;
        } else if (this.reloading) {
          this.xhr.onabort = null;
          this.xhr.abort();
        } else if (this.image) {
          this.stop();
        }
      }
      /**
       * Get the no conflict cropper class.
       * @returns {Cropper} The cropper class.
       */

    }], [{
      key: "noConflict",
      value: function noConflict() {
        window.Cropper = AnotherCropper;
        return Cropper;
      }
      /**
       * Change the default options.
       * @param {Object} options - The new default options.
       */

    }, {
      key: "setDefaults",
      value: function setDefaults(options) {
        assign(DEFAULTS, isPlainObject(options) && options);
      }
    }]);

    return Cropper;
  }();

  assign(Cropper.prototype, render, preview, events, handlers, change, methods);

  return Cropper;

})));

},{}],6:[function(require,module,exports){
/**
 * cuid.js
 * Collision-resistant UID generator for browsers and node.
 * Sequential for fast db lookups and recency sorting.
 * Safe for element IDs and server-side lookups.
 *
 * Extracted from CLCTR
 *
 * Copyright (c) Eric Elliott 2012
 * MIT License
 */

var fingerprint = require('./lib/fingerprint.js');
var pad = require('./lib/pad.js');
var getRandomValue = require('./lib/getRandomValue.js');

var c = 0,
  blockSize = 4,
  base = 36,
  discreteValues = Math.pow(base, blockSize);

function randomBlock () {
  return pad((getRandomValue() *
    discreteValues << 0)
    .toString(base), blockSize);
}

function safeCounter () {
  c = c < discreteValues ? c : 0;
  c++; // this is not subliminal
  return c - 1;
}

function cuid () {
  // Starting with a lowercase letter makes
  // it HTML element ID friendly.
  var letter = 'c', // hard-coded allows for sequential access

    // timestamp
    // warning: this exposes the exact date and time
    // that the uid was created.
    timestamp = (new Date().getTime()).toString(base),

    // Prevent same-machine collisions.
    counter = pad(safeCounter().toString(base), blockSize),

    // A few chars to generate distinct ids for different
    // clients (so different computers are far less
    // likely to generate the same id)
    print = fingerprint(),

    // Grab some more chars from Math.random()
    random = randomBlock() + randomBlock();

  return letter + timestamp + counter + print + random;
}

cuid.slug = function slug () {
  var date = new Date().getTime().toString(36),
    counter = safeCounter().toString(36).slice(-4),
    print = fingerprint().slice(0, 1) +
      fingerprint().slice(-1),
    random = randomBlock().slice(-2);

  return date.slice(-2) +
    counter + print + random;
};

cuid.isCuid = function isCuid (stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  if (stringToCheck.startsWith('c')) return true;
  return false;
};

cuid.isSlug = function isSlug (stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  var stringLength = stringToCheck.length;
  if (stringLength >= 7 && stringLength <= 10) return true;
  return false;
};

cuid.fingerprint = fingerprint;

module.exports = cuid;

},{"./lib/fingerprint.js":7,"./lib/getRandomValue.js":8,"./lib/pad.js":9}],7:[function(require,module,exports){
var pad = require('./pad.js');

var env = typeof window === 'object' ? window : self;
var globalCount = Object.keys(env).length;
var mimeTypesLength = navigator.mimeTypes ? navigator.mimeTypes.length : 0;
var clientId = pad((mimeTypesLength +
  navigator.userAgent.length).toString(36) +
  globalCount.toString(36), 4);

module.exports = function fingerprint () {
  return clientId;
};

},{"./pad.js":9}],8:[function(require,module,exports){

var getRandomValue;

var crypto = typeof window !== 'undefined' &&
  (window.crypto || window.msCrypto) ||
  typeof self !== 'undefined' &&
  self.crypto;

if (crypto) {
    var lim = Math.pow(2, 32) - 1;
    getRandomValue = function () {
        return Math.abs(crypto.getRandomValues(new Uint32Array(1))[0] / lim);
    };
} else {
    getRandomValue = Math.random;
}

module.exports = getRandomValue;

},{}],9:[function(require,module,exports){
module.exports = function pad (num, size) {
  var s = '000000000' + num;
  return s.substr(s.length - size);
};

},{}],10:[function(require,module,exports){
// This file can be required in Browserify and Node.js for automatic polyfill
// To use it:  require('es6-promise/auto');
'use strict';
module.exports = require('./').polyfill();

},{"./":11}],11:[function(require,module,exports){
(function (process,global){(function (){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    var then$$1 = void 0;
    try {
      then$$1 = value.then;
    } catch (error) {
      reject(promise, error);
      return;
    }
    handleMaybeThenable(promise, value, then$$1);
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = true;

  if (hasCallback) {
    try {
      value = callback(detail);
    } catch (e) {
      succeeded = false;
      error = e;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (succeeded === false) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = void 0;
      var error = void 0;
      var didError = false;
      try {
        _then = entry.then;
      } catch (e) {
        didError = true;
        error = e;
      }

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        if (didError) {
          reject(promise, error);
        } else {
          handleMaybeThenable(promise, entry, _then);
        }
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));





}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":22}],12:[function(require,module,exports){
(function (process,global,Buffer){(function (){
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define("exifr",["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).exifr={})}(this,(function(e){"use strict";function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function r(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}});var n=["prototype","__proto__","caller","arguments","length","name"];Object.getOwnPropertyNames(t).forEach((function(r){-1===n.indexOf(r)&&e[r]!==t[r]&&(e[r]=t[r])})),t&&u(e,t)}function s(e){return(s=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function u(e,t){return(u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function o(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function f(e,t,n){return(f=o()?Reflect.construct:function(e,t,n){var r=[null];r.push.apply(r,t);var i=new(Function.bind.apply(e,r));return n&&u(i,n.prototype),i}).apply(null,arguments)}function c(e){var t="function"==typeof Map?new Map:void 0;return(c=function(e){if(null===e||(n=e,-1===Function.toString.call(n).indexOf("[native code]")))return e;var n;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,r)}function r(){return f(e,arguments,s(this).constructor)}return r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),u(r,e)})(e)}function h(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function l(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?h(e):t}function d(e){var t=o();return function(){var n,r=s(e);if(t){var i=s(this).constructor;n=Reflect.construct(r,arguments,i)}else n=r.apply(this,arguments);return l(this,n)}}function v(e,t,n){return(v="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var r=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=s(e)););return e}(e,t);if(r){var i=Object.getOwnPropertyDescriptor(r,t);return i.get?i.get.call(n):i.value}})(e,t,n||e)}var p=Object.values||function(e){var t=[];for(var n in e)t.push(e[n]);return t},y=Object.entries||function(e){var t=[];for(var n in e)t.push([n,e[n]]);return t},g=Object.assign||function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return n.forEach((function(t){for(var n in t)e[n]=t[n]})),e},k=Object.fromEntries||function(e){var t={};return m(e).forEach((function(e){var n=e[0],r=e[1];t[n]=r})),t},m=Array.from||function(e){if(e instanceof P){var t=[];return e.forEach((function(e,n){return t.push([n,e])})),t}return Array.prototype.slice.call(e)};function b(e){return-1!==this.indexOf(e)}Array.prototype.includes||(Array.prototype.includes=b),String.prototype.includes||(String.prototype.includes=b),String.prototype.startsWith||(String.prototype.startsWith=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.substring(t,t+e.length)===e}),String.prototype.endsWith||(String.prototype.endsWith=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.length;return this.substring(t-e.length,t)===e});var A="undefined"!=typeof self?self:global,w=A.fetch||function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new Promise((function(n,r){var i=new XMLHttpRequest;if(i.open("get",e,!0),i.responseType="arraybuffer",i.onerror=r,t.headers)for(var a in t.headers)i.setRequestHeader(a,t.headers[a]);i.onload=function(){n({ok:i.status>=200&&i.status<300,status:i.status,arrayBuffer:function(){return Promise.resolve(i.response)}})},i.send(null)}))},O=function(e){var t=[];if(Object.defineProperties(t,{size:{get:function(){return this.length}},has:{value:function(e){return-1!==this.indexOf(e)}},add:{value:function(e){this.has(e)||this.push(e)}},delete:{value:function(e){if(this.has(e)){var t=this.indexOf(e);this.splice(t,1)}}}}),Array.isArray(e))for(var n=0;n<e.length;n++)t.add(e[n]);return t},S=function(e){return new P(e)},P=void 0!==A.Map&&void 0!==A.Map.prototype.keys?A.Map:function(){function e(n){if(t(this,e),this.clear(),n)for(var r=0;r<n.length;r++)this.set(n[r][0],n[r][1])}return r(e,[{key:"clear",value:function(){this._map={},this._keys=[]}},{key:"size",get:function(){return this._keys.length}},{key:"get",value:function(e){return this._map["map_"+e]}},{key:"set",value:function(e,t){return this._map["map_"+e]=t,this._keys.indexOf(e)<0&&this._keys.push(e),this}},{key:"has",value:function(e){return this._keys.indexOf(e)>=0}},{key:"delete",value:function(e){var t=this._keys.indexOf(e);return!(t<0)&&(delete this._map["map_"+e],this._keys.splice(t,1),!0)}},{key:"keys",value:function(){return this._keys.slice(0)}},{key:"values",value:function(){var e=this;return this._keys.map((function(t){return e.get(t)}))}},{key:"entries",value:function(){var e=this;return this._keys.map((function(t){return[t,e.get(t)]}))}},{key:"forEach",value:function(e,t){for(var n=0;n<this._keys.length;n++)e.call(t,this._map["map_"+this._keys[n]],this._keys[n],this)}}]),e}(),U="undefined"!=typeof self?self:global,x="undefined"!=typeof navigator,C=x&&"undefined"==typeof HTMLImageElement,B=!("undefined"==typeof global||"undefined"==typeof process||!process.versions||!process.versions.node),j=U.Buffer,_=!!j;var V=function(e){return void 0!==e};function I(e){return void 0===e||(e instanceof P?0===e.size:0===p(e).filter(V).length)}function L(e){var t=new Error(e);throw delete t.stack,t}function T(e){var t=function(e){var t=0;return e.ifd0.enabled&&(t+=1024),e.exif.enabled&&(t+=2048),e.makerNote&&(t+=2048),e.userComment&&(t+=1024),e.gps.enabled&&(t+=512),e.interop.enabled&&(t+=100),e.ifd1.enabled&&(t+=1024),t+2048}(e);return e.jfif.enabled&&(t+=50),e.xmp.enabled&&(t+=2e4),e.iptc.enabled&&(t+=14e3),e.icc.enabled&&(t+=6e3),t}var z=function(e){return String.fromCharCode.apply(null,e)},F="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):void 0;function E(e){return F?F.decode(e):_?Buffer.from(e).toString("utf8"):decodeURIComponent(escape(z(e)))}var D=function(){function e(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(t(this,e),"boolean"==typeof a&&(this.le=a),Array.isArray(n)&&(n=new Uint8Array(n)),0===n)this.byteOffset=0,this.byteLength=0;else if(n instanceof ArrayBuffer){void 0===i&&(i=n.byteLength-r);var s=new DataView(n,r,i);this._swapDataView(s)}else if(n instanceof Uint8Array||n instanceof DataView||n instanceof e){void 0===i&&(i=n.byteLength-r),(r+=n.byteOffset)+i>n.byteOffset+n.byteLength&&L("Creating view outside of available memory in ArrayBuffer");var u=new DataView(n.buffer,r,i);this._swapDataView(u)}else if("number"==typeof n){var o=new DataView(new ArrayBuffer(n));this._swapDataView(o)}else L("Invalid input argument for BufferView: "+n)}return r(e,[{key:"_swapArrayBuffer",value:function(e){this._swapDataView(new DataView(e))}},{key:"_swapBuffer",value:function(e){this._swapDataView(new DataView(e.buffer,e.byteOffset,e.byteLength))}},{key:"_swapDataView",value:function(e){this.dataView=e,this.buffer=e.buffer,this.byteOffset=e.byteOffset,this.byteLength=e.byteLength}},{key:"_lengthToEnd",value:function(e){return this.byteLength-e}},{key:"set",value:function(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;t instanceof DataView||t instanceof e?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t instanceof ArrayBuffer&&(t=new Uint8Array(t)),t instanceof Uint8Array||L("BufferView.set(): Invalid data argument.");var i=this.toUint8();return i.set(t,n),new r(this,n,t.byteLength)}},{key:"subarray",value:function(t,n){return new e(this,t,n=n||this._lengthToEnd(t))}},{key:"toUint8",value:function(){return new Uint8Array(this.buffer,this.byteOffset,this.byteLength)}},{key:"getUint8Array",value:function(e,t){return new Uint8Array(this.buffer,this.byteOffset+e,t)}},{key:"getString",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength,n=this.getUint8Array(e,t);return E(n)}},{key:"getLatin1String",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength,n=this.getUint8Array(e,t);return z(n)}},{key:"getUnicodeString",value:function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength,n=[],r=0;r<t&&e+r<this.byteLength;r+=2)n.push(this.getUint16(e+r));return z(n)}},{key:"getInt8",value:function(e){return this.dataView.getInt8(e)}},{key:"getUint8",value:function(e){return this.dataView.getUint8(e)}},{key:"getInt16",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getInt16(e,t)}},{key:"getInt32",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getInt32(e,t)}},{key:"getUint16",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getUint16(e,t)}},{key:"getUint32",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getUint32(e,t)}},{key:"getFloat32",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat32(e,t)}},{key:"getFloat64",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat64(e,t)}},{key:"getFloat",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat32(e,t)}},{key:"getDouble",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.le;return this.dataView.getFloat64(e,t)}},{key:"getUintBytes",value:function(e,t,n){switch(t){case 1:return this.getUint8(e,n);case 2:return this.getUint16(e,n);case 4:return this.getUint32(e,n);case 8:return this.getUint64&&this.getUint64(e,n)}}},{key:"getUint",value:function(e,t,n){switch(t){case 8:return this.getUint8(e,n);case 16:return this.getUint16(e,n);case 32:return this.getUint32(e,n);case 64:return this.getUint64&&this.getUint64(e,n)}}},{key:"toString",value:function(e){return this.dataView.toString(e,this.constructor.name)}},{key:"ensureChunk",value:function(){}}],[{key:"from",value:function(t,n){return t instanceof this&&t.le===n?t:new e(t,void 0,void 0,n)}}]),e}();function R(e,t){L("".concat(e," '").concat(t,"' was not loaded, try using full build of exifr."))}var N=function(e){a(i,e);var n=d(i);function i(e){var r;return t(this,i),(r=n.call(this)).kind=e,r}return r(i,[{key:"get",value:function(e,t){return this.has(e)||R(this.kind,e),t&&(e in t||function(e,t){L("Unknown ".concat(e," '").concat(t,"'."))}(this.kind,e),t[e].enabled||R(this.kind,e)),v(s(i.prototype),"get",this).call(this,e)}},{key:"keyList",value:function(){return m(this.keys())}}]),i}(c(P)),M=new N("file parser"),W=new N("segment parser"),K=new N("file reader");function H(e){return function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];try{return Promise.resolve(e.apply(this,t))}catch(e){return Promise.reject(e)}}}function X(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}var Y=H((function(e){return new Promise((function(t,n){var r=new FileReader;r.onloadend=function(){return t(r.result||new ArrayBuffer)},r.onerror=n,r.readAsArrayBuffer(e)}))})),G=H((function(e){return w(e).then((function(e){return e.arrayBuffer()}))})),J=H((function(e,t){return X(t(e),(function(e){return new D(e)}))})),q=H((function(e,t,n){var r=new(K.get(n))(e,t);return X(r.read(),(function(){return r}))})),Q=H((function(e,t,n,r){return K.has(n)?q(e,t,n):r?J(e,r):(L("Parser ".concat(n," is not loaded")),X())})),Z="Invalid input argument";function $(e,t){return(n=e).startsWith("data:")||n.length>1e4?q(e,t,"base64"):x?Q(e,t,"url",G):B?q(e,t,"fs"):void L(Z);var n}var ee=function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"tagKeys",get:function(){return this.allKeys||(this.allKeys=m(this.keys())),this.allKeys}},{key:"tagValues",get:function(){return this.allValues||(this.allValues=m(this.values())),this.allValues}}]),i}(c(P));function te(e,t,n){var r=new ee,i=n;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++){var s=i[a],u=s[0],o=s[1];r.set(u,o)}if(Array.isArray(t)){var f=t;Array.isArray(f)||("function"==typeof f.entries&&(f=f.entries()),f=m(f));for(var c=0;c<f.length;c++){var h=f[c];e.set(h,r)}}else e.set(t,r);return r}function ne(e,t,n){var r,i=e.get(t),a=n;Array.isArray(a)||("function"==typeof a.entries&&(a=a.entries()),a=m(a));for(var s=0;s<a.length;s++)r=a[s],i.set(r[0],r[1])}var re=S(),ie=S(),ae=S(),se=37500,ue=37510,oe=33723,fe=34675,ce=34665,he=34853,le=40965,de=["chunked","firstChunkSize","firstChunkSizeNode","firstChunkSizeBrowser","chunkSize","chunkLimit"],ve=["jfif","xmp","icc","iptc","ihdr"],pe=["tiff"].concat(ve),ye=["ifd0","ifd1","exif","gps","interop"],ge=[].concat(pe,ye),ke=["makerNote","userComment"],me=["translateKeys","translateValues","reviveValues","multiSegment"],be=[].concat(me,["sanitize","mergeOutput","silentErrors"]),Ae=function(){function e(){t(this,e)}return r(e,[{key:"translate",get:function(){return this.translateKeys||this.translateValues||this.reviveValues}}]),e}(),we=function(e){a(s,e);var n=d(s);function s(e,r,a,u){var o;if(t(this,s),i(h(o=n.call(this)),"enabled",!1),i(h(o),"skip",O()),i(h(o),"pick",O()),i(h(o),"deps",O()),i(h(o),"translateKeys",!1),i(h(o),"translateValues",!1),i(h(o),"reviveValues",!1),o.key=e,o.enabled=r,o.parse=o.enabled,o.applyInheritables(u),o.canBeFiltered=ye.includes(e),o.canBeFiltered&&(o.dict=re.get(e)),void 0!==a)if(Array.isArray(a))o.parse=o.enabled=!0,o.canBeFiltered&&a.length>0&&o.translateTagSet(a,o.pick);else if("object"==typeof a){if(o.enabled=!0,o.parse=!1!==a.parse,o.canBeFiltered){var f=a.pick,c=a.skip;f&&f.length>0&&o.translateTagSet(f,o.pick),c&&c.length>0&&o.translateTagSet(c,o.skip)}o.applyInheritables(a)}else!0===a||!1===a?o.parse=o.enabled=a:L("Invalid options argument: ".concat(a));return o}return r(s,[{key:"needed",get:function(){return this.enabled||this.deps.size>0}},{key:"applyInheritables",value:function(e){var t,n,r=me;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++)void 0!==(n=e[t=r[i]])&&(this[t]=n)}},{key:"translateTagSet",value:function(e,t){if(this.dict){var n,r,i=this.dict,a=i.tagKeys,s=i.tagValues,u=e;Array.isArray(u)||("function"==typeof u.entries&&(u=u.entries()),u=m(u));for(var o=0;o<u.length;o++)"string"==typeof(n=u[o])?(-1===(r=s.indexOf(n))&&(r=a.indexOf(Number(n))),-1!==r&&t.add(Number(a[r]))):t.add(n)}else{var f=e;Array.isArray(f)||("function"==typeof f.entries&&(f=f.entries()),f=m(f));for(var c=0;c<f.length;c++){var h=f[c];t.add(h)}}}},{key:"finalizeFilters",value:function(){!this.enabled&&this.deps.size>0?(this.enabled=!0,Ce(this.pick,this.deps)):this.enabled&&this.pick.size>0&&Ce(this.pick,this.deps)}}]),s}(Ae),Oe={jfif:!1,tiff:!0,xmp:!1,icc:!1,iptc:!1,ifd0:!0,ifd1:!1,exif:!0,gps:!0,interop:!1,ihdr:void 0,makerNote:!1,userComment:!1,multiSegment:!1,skip:[],pick:[],translateKeys:!0,translateValues:!0,reviveValues:!0,sanitize:!0,mergeOutput:!0,silentErrors:!0,chunked:!0,firstChunkSize:void 0,firstChunkSizeNode:512,firstChunkSizeBrowser:65536,chunkSize:65536,chunkLimit:5},Se=S(),Pe=function(e){a(i,e);var n=d(i);function i(e){var r;return t(this,i),r=n.call(this),!0===e?r.setupFromTrue():void 0===e?r.setupFromUndefined():Array.isArray(e)?r.setupFromArray(e):"object"==typeof e?r.setupFromObject(e):L("Invalid options argument ".concat(e)),void 0===r.firstChunkSize&&(r.firstChunkSize=x?r.firstChunkSizeBrowser:r.firstChunkSizeNode),r.mergeOutput&&(r.ifd1.enabled=!1),r.filterNestedSegmentTags(),r.traverseTiffDependencyTree(),r.checkLoadedPlugins(),r}return r(i,[{key:"setupFromUndefined",value:function(){var e,t=de;Array.isArray(t)||("function"==typeof t.entries&&(t=t.entries()),t=m(t));for(var n=0;n<t.length;n++)this[e=t[n]]=Oe[e];var r=be;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++)this[e=r[i]]=Oe[e];var a=ke;Array.isArray(a)||("function"==typeof a.entries&&(a=a.entries()),a=m(a));for(var s=0;s<a.length;s++)this[e=a[s]]=Oe[e];var u=ge;Array.isArray(u)||("function"==typeof u.entries&&(u=u.entries()),u=m(u));for(var o=0;o<u.length;o++)this[e=u[o]]=new we(e,Oe[e],void 0,this)}},{key:"setupFromTrue",value:function(){var e,t=de;Array.isArray(t)||("function"==typeof t.entries&&(t=t.entries()),t=m(t));for(var n=0;n<t.length;n++)this[e=t[n]]=Oe[e];var r=be;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++)this[e=r[i]]=Oe[e];var a=ke;Array.isArray(a)||("function"==typeof a.entries&&(a=a.entries()),a=m(a));for(var s=0;s<a.length;s++)this[e=a[s]]=!0;var u=ge;Array.isArray(u)||("function"==typeof u.entries&&(u=u.entries()),u=m(u));for(var o=0;o<u.length;o++)this[e=u[o]]=new we(e,!0,void 0,this)}},{key:"setupFromArray",value:function(e){var t,n=de;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++)this[t=n[r]]=Oe[t];var i=be;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++)this[t=i[a]]=Oe[t];var s=ke;Array.isArray(s)||("function"==typeof s.entries&&(s=s.entries()),s=m(s));for(var u=0;u<s.length;u++)this[t=s[u]]=Oe[t];var o=ge;Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++)this[t=o[f]]=new we(t,!1,void 0,this);this.setupGlobalFilters(e,void 0,ye)}},{key:"setupFromObject",value:function(e){var t;ye.ifd0=ye.ifd0||ye.image,ye.ifd1=ye.ifd1||ye.thumbnail,g(this,e);var n=de;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++)this[t=n[r]]=xe(e[t],Oe[t]);var i=be;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++)this[t=i[a]]=xe(e[t],Oe[t]);var s=ke;Array.isArray(s)||("function"==typeof s.entries&&(s=s.entries()),s=m(s));for(var u=0;u<s.length;u++)this[t=s[u]]=xe(e[t],Oe[t]);var o=pe;Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++)this[t=o[f]]=new we(t,Oe[t],e[t],this);var c=ye;Array.isArray(c)||("function"==typeof c.entries&&(c=c.entries()),c=m(c));for(var h=0;h<c.length;h++)this[t=c[h]]=new we(t,Oe[t],e[t],this.tiff);this.setupGlobalFilters(e.pick,e.skip,ye,ge),!0===e.tiff?this.batchEnableWithBool(ye,!0):!1===e.tiff?this.batchEnableWithUserValue(ye,e):Array.isArray(e.tiff)?this.setupGlobalFilters(e.tiff,void 0,ye):"object"==typeof e.tiff&&this.setupGlobalFilters(e.tiff.pick,e.tiff.skip,ye)}},{key:"batchEnableWithBool",value:function(e,t){var n=e;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){this[n[r]].enabled=t}}},{key:"batchEnableWithUserValue",value:function(e,t){var n=e;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r],a=t[i];this[i].enabled=!1!==a&&void 0!==a}}},{key:"setupGlobalFilters",value:function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n;if(e&&e.length){var i=r;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++){var s=i[a];this[s].enabled=!1}var u=Ue(e,n),o=u;Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++){var c=o[f],h=c[0],l=c[1];Ce(this[h].pick,l),this[h].enabled=!0}}else if(t&&t.length){var d=Ue(t,n),v=d;Array.isArray(v)||("function"==typeof v.entries&&(v=v.entries()),v=m(v));for(var p=0;p<v.length;p++){var y=v[p],g=y[0],k=y[1];Ce(this[g].skip,k)}}}},{key:"filterNestedSegmentTags",value:function(){var e=this.ifd0,t=this.exif,n=this.xmp,r=this.iptc,i=this.icc;this.makerNote?t.deps.add(se):t.skip.add(se),this.userComment?t.deps.add(ue):t.skip.add(ue),n.enabled||e.skip.add(700),r.enabled||e.skip.add(oe),i.enabled||e.skip.add(fe)}},{key:"traverseTiffDependencyTree",value:function(){var e=this,t=this.ifd0,n=this.exif,r=this.gps;this.interop.needed&&(n.deps.add(le),t.deps.add(le)),n.needed&&t.deps.add(ce),r.needed&&t.deps.add(he),this.tiff.enabled=ye.some((function(t){return!0===e[t].enabled}))||this.makerNote||this.userComment;var i=ye;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++){this[i[a]].finalizeFilters()}}},{key:"onlyTiff",get:function(){var e=this;return!ve.map((function(t){return e[t].enabled})).some((function(e){return!0===e}))&&this.tiff.enabled}},{key:"checkLoadedPlugins",value:function(){var e=pe;Array.isArray(e)||("function"==typeof e.entries&&(e=e.entries()),e=m(e));for(var t=0;t<e.length;t++){var n=e[t];this[n].enabled&&!W.has(n)&&R("segment parser",n)}}}],[{key:"useCached",value:function(e){var t=Se.get(e);return void 0!==t||(t=new this(e),Se.set(e,t)),t}}]),i}(Ae);function Ue(e,t){var n,r,i,a=[],s=t;Array.isArray(s)||("function"==typeof s.entries&&(s=s.entries()),s=m(s));for(var u=0;u<s.length;u++){r=s[u],n=[];var o=re.get(r);Array.isArray(o)||("function"==typeof o.entries&&(o=o.entries()),o=m(o));for(var f=0;f<o.length;f++)i=o[f],(e.includes(i[0])||e.includes(i[1]))&&n.push(i[0]);n.length&&a.push([r,n])}return a}function xe(e,t){return void 0!==e?e:void 0!==t?t:void 0}function Ce(e,t){var n=t;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r];e.add(i)}}function Be(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}function je(){}function _e(e,t){if(!t)return e&&e.then?e.then(je):Promise.resolve()}function Ve(e,t){var n=e();return n&&n.then?n.then(t):t(n)}i(Pe,"default",Oe);var Ie=function(){function e(n){t(this,e),i(this,"parsers",{}),this.options=Pe.useCached(n)}return r(e,[{key:"setup",value:function(){if(!this.fileParser){var e=this.file,t=e.getUint16(0),n=M;Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r],a=i[0],s=i[1];if(s.canHandle(e,t))return this.fileParser=new s(this.options,this.file,this.parsers),e[a]=!0}L("Unknown file format")}}},{key:"read",value:function(e){try{var t=this;return Be(function(e,t){return"string"==typeof e?$(e,t):x&&!C&&e instanceof HTMLImageElement?$(e.src,t):e instanceof Uint8Array||e instanceof ArrayBuffer||e instanceof DataView?new D(e):x&&e instanceof Blob?Q(e,t,"blob",Y):void L(Z)}(e,t.options),(function(e){t.file=e}))}catch(e){return Promise.reject(e)}}},{key:"parse",value:function(){try{var e=this;e.setup();var t={},n=[];return Ve((function(){return e.options.silentErrors?Be(e.doParse(t,n).catch((function(e){return n.push(e)})),(function(){n.push.apply(n,e.fileParser.errors)})):_e(e.doParse(t,n))}),(function(){return e.file.close&&e.file.close(),e.options.silentErrors&&n.length>0&&(t.errors=n),I(r=t)?void 0:r;var r}))}catch(e){return Promise.reject(e)}}},{key:"doParse",value:function(e,t){try{var n=this;return Be(n.fileParser.parse(),(function(){var r,i=p(n.parsers).map((r=function(t){return Be(t.parse(),(function(n){t.assignToOutput(e,n)}))},function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];try{return Promise.resolve(r.apply(this,e))}catch(e){return Promise.reject(e)}}));if(n.options.silentErrors){var a=function(e){return t.push(e)};i=i.map((function(e){return e.catch(a)}))}return _e(Promise.all(i))}))}catch(e){return Promise.reject(e)}}},{key:"extractThumbnail",value:function(){try{var e=this;e.setup();var t,n=e.options,r=e.file,i=W.get("tiff",n);return Ve((function(){if(!r.tiff)return function(e){var t=e();if(t&&t.then)return t.then(je)}((function(){if(r.jpeg)return Be(e.fileParser.getOrFindSegment("tiff"),(function(e){t=e}))}));t={start:0,type:"tiff"}}),(function(){if(void 0!==t)return Be(e.fileParser.ensureSegmentChunk(t),(function(t){return Be((e.parsers.tiff=new i(t,n,r)).extractThumbnail(),(function(e){return r.close&&r.close(),e}))}))}))}catch(e){return Promise.reject(e)}}}]),e}();var Le,Te=(Le=function(e,t){var n,r,i,a=new Ie(t);return n=a.read(e),r=function(){return a.parse()},i?r?r(n):n:(n&&n.then||(n=Promise.resolve(n)),r?n.then(r):n)},function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];try{return Promise.resolve(Le.apply(this,e))}catch(e){return Promise.reject(e)}}),ze=Object.freeze({__proto__:null,parse:Te,Exifr:Ie,fileParsers:M,segmentParsers:W,fileReaders:K,tagKeys:re,tagValues:ie,tagRevivers:ae,createDictionary:te,extendDictionary:ne,fetchUrlAsArrayBuffer:G,readBlobAsArrayBuffer:Y,chunkedProps:de,otherSegments:ve,segments:pe,tiffBlocks:ye,segmentsAndBlocks:ge,tiffExtractables:ke,inheritables:me,allFormatters:be,Options:Pe});function Fe(){}var Ee=function(){function e(n,r,a){var s=this;t(this,e),i(this,"errors",[]),i(this,"ensureSegmentChunk",function(e){return function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];try{return Promise.resolve(e.apply(this,t))}catch(e){return Promise.reject(e)}}}((function(e){var t,n,r,i=e.start,a=e.size||65536;return t=function(){if(s.file.chunked)return function(e){var t=e();if(t&&t.then)return t.then(Fe)}((function(){if(!s.file.available(i,a))return function(e){if(e&&e.then)return e.then(Fe)}(function(e,t){try{var n=e()}catch(e){return t(e)}return n&&n.then?n.then(void 0,t):n}((function(){return t=s.file.readChunk(i,a),n=function(t){e.chunk=t},r?n?n(t):t:(t&&t.then||(t=Promise.resolve(t)),n?t.then(n):t);var t,n,r}),(function(t){L("Couldn't read segment: ".concat(JSON.stringify(e),". ").concat(t.message))})));e.chunk=s.file.subarray(i,a)}));s.file.byteLength>i+a?e.chunk=s.file.subarray(i,a):void 0===e.size?e.chunk=s.file.subarray(i):L("Segment unreachable: "+JSON.stringify(e))},n=function(){return e.chunk},(r=t())&&r.then?r.then(n):n(r)}))),this.extendOptions&&this.extendOptions(n),this.options=n,this.file=r,this.parsers=a}return r(e,[{key:"injectSegment",value:function(e,t){this.options[e].enabled&&this.createParser(e,t)}},{key:"createParser",value:function(e,t){var n=new(W.get(e))(t,this.options,this.file);return this.parsers[e]=n}},{key:"createParsers",value:function(e){var t=e;Array.isArray(t)||("function"==typeof t.entries&&(t=t.entries()),t=m(t));for(var n=0;n<t.length;n++){var r=t[n],i=r.type,a=r.chunk,s=this.options[i];if(s&&s.enabled){var u=this.parsers[i];u&&u.append||u||this.createParser(i,a)}}}},{key:"readSegments",value:function(e){try{var t=e.map(this.ensureSegmentChunk);return function(e,t){if(!t)return e&&e.then?e.then(Fe):Promise.resolve()}(Promise.all(t))}catch(e){return Promise.reject(e)}}}]),e}(),De=function(){function e(n){var r=this,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},s=arguments.length>2?arguments[2]:void 0;t(this,e),i(this,"errors",[]),i(this,"raw",S()),i(this,"handleError",(function(e){if(!r.options.silentErrors)throw e;r.errors.push(e.message)})),this.chunk=this.normalizeInput(n),this.file=s,this.type=this.constructor.type,this.globalOptions=this.options=a,this.localOptions=a[this.type],this.canTranslate=this.localOptions&&this.localOptions.translate}return r(e,[{key:"normalizeInput",value:function(e){return e instanceof D?e:new D(e)}},{key:"translate",value:function(){this.canTranslate&&(this.translated=this.translateBlock(this.raw,this.type))}},{key:"output",get:function(){return this.translated?this.translated:this.raw?k(this.raw):void 0}},{key:"translateBlock",value:function(e,t){var n=ae.get(t),r=ie.get(t),i=re.get(t),a=this.options[t],s=a.reviveValues&&!!n,u=a.translateValues&&!!r,o=a.translateKeys&&!!i,f={},c=e;Array.isArray(c)||("function"==typeof c.entries&&(c=c.entries()),c=m(c));for(var h=0;h<c.length;h++){var l=c[h],d=l[0],v=l[1];s&&n.has(d)?v=n.get(d)(v):u&&r.has(d)&&(v=this.translateValue(v,r.get(d))),o&&i.has(d)&&(d=i.get(d)||d),f[d]=v}return f}},{key:"translateValue",value:function(e,t){return t[e]||t.DEFAULT||e}},{key:"assignToOutput",value:function(e,t){this.assignObjectToOutput(e,this.constructor.type,t)}},{key:"assignObjectToOutput",value:function(e,t,n){if(this.globalOptions.mergeOutput)return g(e,n);e[t]?g(e[t],n):e[t]=n}}],[{key:"findPosition",value:function(e,t){var n=e.getUint16(t+2)+2,r="function"==typeof this.headerLength?this.headerLength(e,t,n):this.headerLength,i=t+r,a=n-r;return{offset:t,length:n,headerLength:r,start:i,size:a,end:i+a}}},{key:"parse",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=new Pe(i({},this.type,t)),r=new this(e,n);return r.parse()}}]),e}();function Re(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}i(De,"headerLength",4),i(De,"type",void 0),i(De,"multiSegment",!1),i(De,"canHandle",(function(){return!1}));function Ne(){}function Me(e,t){if(!t)return e&&e.then?e.then(Ne):Promise.resolve()}function We(e){var t=e();if(t&&t.then)return t.then(Ne)}function Ke(e,t){var n=e();return n&&n.then?n.then(t):t(n)}function He(e,t,n){if(!e.s){if(n instanceof Xe){if(!n.s)return void(n.o=He.bind(null,e,t));1&t&&(t=n.s),n=n.v}if(n&&n.then)return void n.then(He.bind(null,e,t),He.bind(null,e,2));e.s=t,e.v=n;var r=e.o;r&&r(e)}}var Xe=function(){function e(){}return e.prototype.then=function(t,n){var r=new e,i=this.s;if(i){var a=1&i?t:n;if(a){try{He(r,1,a(this.v))}catch(e){He(r,2,e)}return r}return this}return this.o=function(e){try{var i=e.v;1&e.s?He(r,1,t?t(i):i):n?He(r,1,n(i)):He(r,2,i)}catch(e){He(r,2,e)}},r},e}();function Ye(e){return e instanceof Xe&&1&e.s}function Ge(e,t,n){for(var r;;){var i=e();if(Ye(i)&&(i=i.v),!i)return a;if(i.then){r=0;break}var a=n();if(a&&a.then){if(!Ye(a)){r=1;break}a=a.s}if(t){var s=t();if(s&&s.then&&!Ye(s)){r=2;break}}}var u=new Xe,o=He.bind(null,u,2);return(0===r?i.then(c):1===r?a.then(f):s.then(h)).then(void 0,o),u;function f(r){a=r;do{if(t&&(s=t())&&s.then&&!Ye(s))return void s.then(h).then(void 0,o);if(!(i=e())||Ye(i)&&!i.v)return void He(u,1,a);if(i.then)return void i.then(c).then(void 0,o);Ye(a=n())&&(a=a.v)}while(!a||!a.then);a.then(f).then(void 0,o)}function c(e){e?(a=n())&&a.then?a.then(f).then(void 0,o):f(a):He(u,1,a)}function h(){(i=e())?i.then?i.then(c).then(void 0,o):c(i):He(u,1,a)}}function Je(e){return 192===e||194===e||196===e||219===e||221===e||218===e||254===e}function qe(e){return e>=224&&e<=239}function Qe(e,t,n){var r=W;Array.isArray(r)||("function"==typeof r.entries&&(r=r.entries()),r=m(r));for(var i=0;i<r.length;i++){var a=r[i],s=a[0];if(a[1].canHandle(e,t,n))return s}}var Ze=function(e){a(s,e);var n=d(s);function s(){var e;t(this,s);for(var r=arguments.length,a=new Array(r),u=0;u<r;u++)a[u]=arguments[u];return i(h(e=n.call.apply(n,[this].concat(a))),"appSegments",[]),i(h(e),"jpegSegments",[]),i(h(e),"unknownSegments",[]),e}return r(s,[{key:"parse",value:function(){try{var e=this;return Re(e.findAppSegments(),(function(){return Re(e.readSegments(e.appSegments),(function(){e.mergeMultiSegments(),e.createParsers(e.mergedAppSegments||e.appSegments)}))}))}catch(e){return Promise.reject(e)}}},{key:"setupSegmentFinderArgs",value:function(e){var t=this;!0===e?(this.findAll=!0,this.wanted=O(W.keyList())):(e=void 0===e?W.keyList().filter((function(e){return t.options[e].enabled})):e.filter((function(e){return t.options[e].enabled&&W.has(e)})),this.findAll=!1,this.remaining=O(e),this.wanted=O(e)),this.unfinishedMultiSegment=!1}},{key:"findAppSegments",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1?arguments[1]:void 0;try{var n=this;n.setupSegmentFinderArgs(t);var r=n.file,i=n.findAll,a=n.wanted,s=n.remaining;return Ke((function(){if(!i&&n.file.chunked)return i=m(a).some((function(e){var t=W.get(e),r=n.options[e];return t.multiSegment&&r.multiSegment})),We((function(){if(i)return Me(n.file.readWhole())}))}),(function(){var t=!1;if(e=n.findAppSegmentsInRange(e,r.byteLength),!n.options.onlyTiff)return function(){if(r.chunked){var i=!1;return Ge((function(){return!t&&s.size>0&&!i&&(!!r.canReadNextChunk||!!n.unfinishedMultiSegment)}),void 0,(function(){var a=r.nextChunkOffset,s=n.appSegments.some((function(e){return!n.file.available(e.offset||e.start,e.length||e.size)}));return Ke((function(){return e>a&&!s?Re(r.readNextChunk(e),(function(e){i=!e})):Re(r.readNextChunk(a),(function(e){i=!e}))}),(function(){void 0===(e=n.findAppSegmentsInRange(e,r.byteLength))&&(t=!0)}))}))}}()}))}catch(e){return Promise.reject(e)}}},{key:"findAppSegmentsInRange",value:function(e,t){t-=2;for(var n,r,i,a,s,u,o=this.file,f=this.findAll,c=this.wanted,h=this.remaining,l=this.options;e<t;e++)if(255===o.getUint8(e))if(qe(n=o.getUint8(e+1))){if(r=o.getUint16(e+2),(i=Qe(o,e,r))&&c.has(i)&&(s=(a=W.get(i)).findPosition(o,e),u=l[i],s.type=i,this.appSegments.push(s),!f&&(a.multiSegment&&u.multiSegment?(this.unfinishedMultiSegment=s.chunkNumber<s.chunkCount,this.unfinishedMultiSegment||h.delete(i)):h.delete(i),0===h.size)))break;l.recordUnknownSegments&&((s=De.findPosition(o,e)).marker=n,this.unknownSegments.push(s)),e+=r+1}else if(Je(n)){if(r=o.getUint16(e+2),218===n&&!1!==l.stopAfterSos)return;l.recordJpegSegments&&this.jpegSegments.push({offset:e,length:r,marker:n}),e+=r+1}return e}},{key:"mergeMultiSegments",value:function(){var e=this;if(this.appSegments.some((function(e){return e.multiSegment}))){var t=function(e,t){for(var n,r,i,a=S(),s=0;s<e.length;s++)r=(n=e[s])[t],a.has(r)?i=a.get(r):a.set(r,i=[]),i.push(n);return m(a)}(this.appSegments,"type");this.mergedAppSegments=t.map((function(t){var n=t[0],r=t[1],i=W.get(n,e.options);return i.handleMultiSegments?{type:n,chunk:i.handleMultiSegments(r)}:r[0]}))}}},{key:"getSegment",value:function(e){return this.appSegments.find((function(t){return t.type===e}))}},{key:"getOrFindSegment",value:function(e){try{var t=this,n=t.getSegment(e);return Ke((function(){if(void 0===n)return Re(t.findAppSegments(0,[e]),(function(){n=t.getSegment(e)}))}),(function(){return n}))}catch(e){return Promise.reject(e)}}}],[{key:"canHandle",value:function(e,t){return 65496===t}}]),s}(Ee);function $e(){}i(Ze,"type","jpeg"),M.set("jpeg",Ze);function et(e,t){if(!t)return e&&e.then?e.then($e):Promise.resolve()}function tt(e,t){var n=e();return n&&n.then?n.then(t):t(n)}var nt=[void 0,1,1,2,4,8,1,1,2,4,8,4,8,4];var rt=function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"parse",value:function(){try{var e=this;e.parseHeader();var t=e.options;return tt((function(){if(t.ifd0.enabled)return et(e.parseIfd0Block())}),(function(){return tt((function(){if(t.exif.enabled)return et(e.safeParse("parseExifBlock"))}),(function(){return tt((function(){if(t.gps.enabled)return et(e.safeParse("parseGpsBlock"))}),(function(){return tt((function(){if(t.interop.enabled)return et(e.safeParse("parseInteropBlock"))}),(function(){return tt((function(){if(t.ifd1.enabled)return et(e.safeParse("parseThumbnailBlock"))}),(function(){return e.createOutput()}))}))}))}))}))}catch(e){return Promise.reject(e)}}},{key:"safeParse",value:function(e){var t=this[e]();return void 0!==t.catch&&(t=t.catch(this.handleError)),t}},{key:"findIfd0Offset",value:function(){void 0===this.ifd0Offset&&(this.ifd0Offset=this.chunk.getUint32(4))}},{key:"findIfd1Offset",value:function(){if(void 0===this.ifd1Offset){this.findIfd0Offset();var e=this.chunk.getUint16(this.ifd0Offset),t=this.ifd0Offset+2+12*e;this.ifd1Offset=this.chunk.getUint32(t)}}},{key:"parseBlock",value:function(e,t){var n=S();return this[t]=n,this.parseTags(e,t,n),n}},{key:"parseIfd0Block",value:function(){try{var e=this;if(e.ifd0)return;var t=e.file;return e.findIfd0Offset(),e.ifd0Offset<8&&L("Malformed EXIF data"),!t.chunked&&e.ifd0Offset>t.byteLength&&L("IFD0 offset points to outside of file.\nthis.ifd0Offset: ".concat(e.ifd0Offset,", file.byteLength: ").concat(t.byteLength)),tt((function(){if(t.tiff)return et(t.ensureChunk(e.ifd0Offset,T(e.options)))}),(function(){var t=e.parseBlock(e.ifd0Offset,"ifd0");if(0!==t.size)return e.exifOffset=t.get(ce),e.interopOffset=t.get(le),e.gpsOffset=t.get(he),e.xmp=t.get(700),e.iptc=t.get(oe),e.icc=t.get(fe),e.options.sanitize&&(t.delete(ce),t.delete(le),t.delete(he),t.delete(700),t.delete(oe),t.delete(fe)),t}))}catch(e){return Promise.reject(e)}}},{key:"parseExifBlock",value:function(){try{var e=this;if(e.exif)return;return tt((function(){if(!e.ifd0)return et(e.parseIfd0Block())}),(function(){if(void 0!==e.exifOffset)return tt((function(){if(e.file.tiff)return et(e.file.ensureChunk(e.exifOffset,T(e.options)))}),(function(){var t=e.parseBlock(e.exifOffset,"exif");return e.interopOffset||(e.interopOffset=t.get(le)),e.makerNote=t.get(se),e.userComment=t.get(ue),e.options.sanitize&&(t.delete(le),t.delete(se),t.delete(ue)),e.unpack(t,41728),e.unpack(t,41729),t}))}))}catch(e){return Promise.reject(e)}}},{key:"unpack",value:function(e,t){var n=e.get(t);n&&1===n.length&&e.set(t,n[0])}},{key:"parseGpsBlock",value:function(){try{var e=this;if(e.gps)return;return tt((function(){if(!e.ifd0)return et(e.parseIfd0Block())}),(function(){if(void 0!==e.gpsOffset){var t=e.parseBlock(e.gpsOffset,"gps");return t&&t.has(2)&&t.has(4)&&(t.set("latitude",it.apply(void 0,t.get(2).concat([t.get(1)]))),t.set("longitude",it.apply(void 0,t.get(4).concat([t.get(3)])))),t}}))}catch(e){return Promise.reject(e)}}},{key:"parseInteropBlock",value:function(){try{var e=this;if(e.interop)return;return tt((function(){if(!e.ifd0)return et(e.parseIfd0Block())}),(function(){return tt((function(){if(void 0===e.interopOffset&&!e.exif)return et(e.parseExifBlock())}),(function(){if(void 0!==e.interopOffset)return e.parseBlock(e.interopOffset,"interop")}))}))}catch(e){return Promise.reject(e)}}},{key:"parseThumbnailBlock",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];try{var t=this;if(t.ifd1||t.ifd1Parsed)return;if(t.options.mergeOutput&&!e)return;return t.findIfd1Offset(),t.ifd1Offset>0&&(t.parseBlock(t.ifd1Offset,"ifd1"),t.ifd1Parsed=!0),t.ifd1}catch(e){return Promise.reject(e)}}},{key:"extractThumbnail",value:function(){try{var e=this;return e.headerParsed||e.parseHeader(),tt((function(){if(!e.ifd1Parsed)return et(e.parseThumbnailBlock(!0))}),(function(){if(void 0!==e.ifd1){var t=e.ifd1.get(513),n=e.ifd1.get(514);return e.chunk.getUint8Array(t,n)}}))}catch(e){return Promise.reject(e)}}},{key:"image",get:function(){return this.ifd0}},{key:"thumbnail",get:function(){return this.ifd1}},{key:"createOutput",value:function(){var e,t,n,r={},i=ye;Array.isArray(i)||("function"==typeof i.entries&&(i=i.entries()),i=m(i));for(var a=0;a<i.length;a++)if(!I(e=this[t=i[a]]))if(n=this.canTranslate?this.translateBlock(e,t):k(e),this.options.mergeOutput){if("ifd1"===t)continue;g(r,n)}else r[t]=n;return this.makerNote&&(r.makerNote=this.makerNote),this.userComment&&(r.userComment=this.userComment),r}},{key:"assignToOutput",value:function(e,t){if(this.globalOptions.mergeOutput)g(e,t);else{var n=y(t);Array.isArray(n)||("function"==typeof n.entries&&(n=n.entries()),n=m(n));for(var r=0;r<n.length;r++){var i=n[r],a=i[0],s=i[1];this.assignObjectToOutput(e,a,s)}}}}],[{key:"canHandle",value:function(e,t){return 225===e.getUint8(t+1)&&1165519206===e.getUint32(t+4)&&0===e.getUint16(t+8)}}]),i}(function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"parseHeader",value:function(){var e=this.chunk.getUint16();18761===e?this.le=!0:19789===e&&(this.le=!1),this.chunk.le=this.le,this.headerParsed=!0}},{key:"parseTags",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:S(),r=this.options[t],i=r.pick,a=r.skip,s=(i=O(i)).size>0,u=0===a.size,o=this.chunk.getUint16(e);e+=2;for(var f=0;f<o;f++){var c=this.chunk.getUint16(e);if(s){if(i.has(c)&&(n.set(c,this.parseTag(e,c,t)),i.delete(c),0===i.size))break}else!u&&a.has(c)||n.set(c,this.parseTag(e,c,t));e+=12}return n}},{key:"parseTag",value:function(e,t,n){var r,i=this.chunk,a=i.getUint16(e+2),s=i.getUint32(e+4),u=nt[a];if(u*s<=4?e+=8:e=i.getUint32(e+8),(a<1||a>13)&&L("Invalid TIFF value type. block: ".concat(n.toUpperCase(),", tag: ").concat(t.toString(16),", type: ").concat(a,", offset ").concat(e)),e>i.byteLength&&L("Invalid TIFF value offset. block: ".concat(n.toUpperCase(),", tag: ").concat(t.toString(16),", type: ").concat(a,", offset ").concat(e," is outside of chunk size ").concat(i.byteLength)),1===a)return i.getUint8Array(e,s);if(2===a)return""===(r=function(e){for(;e.endsWith("\0");)e=e.slice(0,-1);return e}(r=i.getString(e,s)).trim())?void 0:r;if(7===a)return i.getUint8Array(e,s);if(1===s)return this.parseTagValue(a,e);for(var o=new(function(e){switch(e){case 1:return Uint8Array;case 3:return Uint16Array;case 4:return Uint32Array;case 5:return Array;case 6:return Int8Array;case 8:return Int16Array;case 9:return Int32Array;case 10:return Array;case 11:return Float32Array;case 12:return Float64Array;default:return Array}}(a))(s),f=u,c=0;c<s;c++)o[c]=this.parseTagValue(a,e),e+=f;return o}},{key:"parseTagValue",value:function(e,t){var n=this.chunk;switch(e){case 1:return n.getUint8(t);case 3:return n.getUint16(t);case 4:return n.getUint32(t);case 5:return n.getUint32(t)/n.getUint32(t+4);case 6:return n.getInt8(t);case 8:return n.getInt16(t);case 9:return n.getInt32(t);case 10:return n.getInt32(t)/n.getInt32(t+4);case 11:return n.getFloat(t);case 12:return n.getDouble(t);case 13:return n.getUint32(t);default:L("Invalid tiff type ".concat(e))}}}]),i}(De));function it(e,t,n,r){var i=e+t/60+n/3600;return"S"!==r&&"W"!==r||(i*=-1),i}i(rt,"type","tiff"),i(rt,"headerLength",10),W.set("tiff",rt);var at=Object.freeze({__proto__:null,default:ze,Exifr:Ie,fileParsers:M,segmentParsers:W,fileReaders:K,tagKeys:re,tagValues:ie,tagRevivers:ae,createDictionary:te,extendDictionary:ne,fetchUrlAsArrayBuffer:G,readBlobAsArrayBuffer:Y,chunkedProps:de,otherSegments:ve,segments:pe,tiffBlocks:ye,segmentsAndBlocks:ge,tiffExtractables:ke,inheritables:me,allFormatters:be,Options:Pe,parse:Te});function st(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}function ut(e){return function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];try{return Promise.resolve(e.apply(this,t))}catch(e){return Promise.reject(e)}}}var ot=ut((function(e){var t=new Ie(vt);return st(t.read(e),(function(){return st(t.parse(),(function(e){if(e&&e.ifd0)return e.ifd0[274]}))}))})),ft=ut((function(e){var t=new Ie(dt);return st(t.read(e),(function(){return st(t.parse(),(function(e){if(e&&e.gps){var t=e.gps;return{latitude:t.latitude,longitude:t.longitude}}}))}))})),ct=ut((function(e){return st(this.thumbnail(e),(function(e){if(void 0!==e){var t=new Blob([e]);return URL.createObjectURL(t)}}))})),ht=ut((function(e){var t=new Ie(pt);return st(t.read(e),(function(){return st(t.extractThumbnail(),(function(e){return e&&_?j.from(e):e}))}))})),lt={ifd0:!1,ifd1:!1,exif:!1,gps:!1,interop:!1,sanitize:!1,reviveValues:!0,translateKeys:!1,translateValues:!1,mergeOutput:!1},dt=g({},lt,{firstChunkSize:4e4,gps:[1,2,3,4]}),vt=g({},lt,{firstChunkSize:4e4,ifd0:[274]}),pt=g({},lt,{tiff:!1,ifd1:!0,mergeOutput:!1}),yt=Object.freeze({1:{dimensionSwapped:!1,scaleX:1,scaleY:1,deg:0,rad:0},2:{dimensionSwapped:!1,scaleX:-1,scaleY:1,deg:0,rad:0},3:{dimensionSwapped:!1,scaleX:1,scaleY:1,deg:180,rad:180*Math.PI/180},4:{dimensionSwapped:!1,scaleX:-1,scaleY:1,deg:180,rad:180*Math.PI/180},5:{dimensionSwapped:!0,scaleX:1,scaleY:-1,deg:90,rad:90*Math.PI/180},6:{dimensionSwapped:!0,scaleX:1,scaleY:1,deg:90,rad:90*Math.PI/180},7:{dimensionSwapped:!0,scaleX:1,scaleY:-1,deg:270,rad:270*Math.PI/180},8:{dimensionSwapped:!0,scaleX:1,scaleY:1,deg:270,rad:270*Math.PI/180}});if(e.rotateCanvas=!0,e.rotateCss=!0,"object"==typeof navigator){var gt=navigator.userAgent;if(gt.includes("iPad")||gt.includes("iPhone")){var kt=gt.match(/OS (\d+)_(\d+)/);if(kt){var mt=kt[1],bt=kt[2],At=Number(mt)+.1*Number(bt);e.rotateCanvas=At<13.4,e.rotateCss=!1}}else if(gt.includes("OS X 10")){var wt=gt.match(/OS X 10[_.](\d+)/)[1];e.rotateCanvas=e.rotateCss=Number(wt)<15}if(gt.includes("Chrome/")){var Ot=gt.match(/Chrome\/(\d+)/)[1];e.rotateCanvas=e.rotateCss=Number(Ot)<81}else if(gt.includes("Firefox/")){var St=gt.match(/Firefox\/(\d+)/)[1];e.rotateCanvas=e.rotateCss=Number(St)<77}}function Pt(){}var Ut=function(e){a(u,e);var n=d(u);function u(){var e;t(this,u);for(var r=arguments.length,a=new Array(r),s=0;s<r;s++)a[s]=arguments[s];return i(h(e=n.call.apply(n,[this].concat(a))),"ranges",new xt),0!==e.byteLength&&e.ranges.add(0,e.byteLength),e}return r(u,[{key:"_tryExtend",value:function(e,t,n){if(0===e&&0===this.byteLength&&n){var r=new DataView(n.buffer||n,n.byteOffset,n.byteLength);this._swapDataView(r)}else{var i=e+t;if(i>this.byteLength){var a=this._extend(i).dataView;this._swapDataView(a)}}}},{key:"_extend",value:function(e){var t;t=_?j.allocUnsafe(e):new Uint8Array(e);var n=new DataView(t.buffer,t.byteOffset,t.byteLength);return t.set(new Uint8Array(this.buffer,this.byteOffset,this.byteLength),0),{uintView:t,dataView:n}}},{key:"subarray",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return t=t||this._lengthToEnd(e),n&&this._tryExtend(e,t),this.ranges.add(e,t),v(s(u.prototype),"subarray",this).call(this,e,t)}},{key:"set",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];n&&this._tryExtend(t,e.byteLength,e);var r=v(s(u.prototype),"set",this).call(this,e,t);return this.ranges.add(t,r.byteLength),r}},{key:"ensureChunk",value:function(e,t){try{var n=this;if(!n.chunked)return;if(n.ranges.available(e,t))return;return function(e,t){if(!t)return e&&e.then?e.then(Pt):Promise.resolve()}(n.readChunk(e,t))}catch(e){return Promise.reject(e)}}},{key:"available",value:function(e,t){return this.ranges.available(e,t)}}]),u}(D),xt=function(){function e(){t(this,e),i(this,"list",[])}return r(e,[{key:"length",get:function(){return this.list.length}},{key:"add",value:function(e,t){var n=e+t,r=this.list.filter((function(t){return Ct(e,t.offset,n)||Ct(e,t.end,n)}));if(r.length>0){e=Math.min.apply(Math,[e].concat(r.map((function(e){return e.offset})))),t=(n=Math.max.apply(Math,[n].concat(r.map((function(e){return e.end})))))-e;var i=r.shift();i.offset=e,i.length=t,i.end=n,this.list=this.list.filter((function(e){return!r.includes(e)}))}else this.list.push({offset:e,length:t,end:n})}},{key:"available",value:function(e,t){var n=e+t;return this.list.some((function(t){return t.offset<=e&&n<=t.end}))}}]),e}();function Ct(e,t,n){return e<=t&&t<=n}function Bt(){}function jt(e,t){if(!t)return e&&e.then?e.then(Bt):Promise.resolve()}function _t(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}var Vt=function(e){a(i,e);var n=d(i);function i(){return t(this,i),n.apply(this,arguments)}return r(i,[{key:"readWhole",value:function(){try{var e=this;return e.chunked=!1,_t(Y(e.input),(function(t){e._swapArrayBuffer(t)}))}catch(e){return Promise.reject(e)}}},{key:"readChunked",value:function(){return this.chunked=!0,this.size=this.input.size,v(s(i.prototype),"readChunked",this).call(this)}},{key:"_readChunk",value:function(e,t){try{var n=this,r=t?e+t:void 0,i=n.input.slice(e,r);return _t(Y(i),(function(t){return n.set(t,e,!0)}))}catch(e){return Promise.reject(e)}}}]),i}(function(e){a(s,e);var n=d(s);function s(e,r){var a;return t(this,s),i(h(a=n.call(this,0)),"chunksRead",0),a.input=e,a.options=r,a}return r(s,[{key:"readWhole",value:function(){try{var e=this;return e.chunked=!1,jt(e.readChunk(e.nextChunkOffset))}catch(e){return Promise.reject(e)}}},{key:"readChunked",value:function(){try{var e=this;return e.chunked=!0,jt(e.readChunk(0,e.options.firstChunkSize))}catch(e){return Promise.reject(e)}}},{key:"readNextChunk",value:function(e){try{var t=this;if(void 0===e&&(e=t.nextChunkOffset),t.fullyRead)return t.chunksRead++,!1;var n=t.options.chunkSize;return r=t.readChunk(e,n),i=function(e){return!!e&&e.byteLength===n},a?i?i(r):r:(r&&r.then||(r=Promise.resolve(r)),i?r.then(i):r)}catch(e){return Promise.reject(e)}var r,i,a}},{key:"readChunk",value:function(e,t){try{var n=this;if(n.chunksRead++,0===(t=n.safeWrapAddress(e,t)))return;return n._readChunk(e,t)}catch(e){return Promise.reject(e)}}},{key:"safeWrapAddress",value:function(e,t){return void 0!==this.size&&e+t>this.size?Math.max(0,this.size-e):t}},{key:"nextChunkOffset",get:function(){if(0!==this.ranges.list.length)return this.ranges.list[0].length}},{key:"canReadNextChunk",get:function(){return this.chunksRead<this.options.chunkLimit}},{key:"fullyRead",get:function(){return void 0!==this.size&&this.nextChunkOffset===this.size}},{key:"read",value:function(){return this.options.chunked?this.readChunked():this.readWhole()}},{key:"close",value:function(){}}]),s}(Ut));K.set("blob",Vt),e.Exifr=Ie,e.Options=Pe,e.allFormatters=be,e.chunkedProps=de,e.createDictionary=te,e.default=at,e.disableAllOptions=lt,e.extendDictionary=ne,e.fetchUrlAsArrayBuffer=G,e.fileParsers=M,e.fileReaders=K,e.gps=ft,e.gpsOnlyOptions=dt,e.inheritables=me,e.orientation=ot,e.orientationOnlyOptions=vt,e.otherSegments=ve,e.parse=Te,e.readBlobAsArrayBuffer=Y,e.rotation=function(t){return st(ot(t),(function(t){return g({canvas:e.rotateCanvas,css:e.rotateCss},yt[t])}))},e.rotations=yt,e.segmentParsers=W,e.segments=pe,e.segmentsAndBlocks=ge,e.tagKeys=re,e.tagRevivers=ae,e.tagValues=ie,e.thumbnail=ht,e.thumbnailOnlyOptions=pt,e.thumbnailUrl=ct,e.tiffBlocks=ye,e.tiffExtractables=ke,Object.defineProperty(e,"__esModule",{value:!0})}));

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"_process":22,"buffer":3}],13:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],14:[function(require,module,exports){
module.exports = function isShallowEqual (a, b) {
  if (a === b) return true
  for (var i in a) if (!(i in b)) return false
  for (var i in b) if (a[i] !== b[i]) return false
  return true
}

},{}],15:[function(require,module,exports){
(function (global){(function (){
/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory(global)
        : typeof define === 'function' && define.amd
        ? define(factory) : factory(global)
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    global = global || {};
    var _Base64 = global.Base64;
    var version = "2.6.4";
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa && typeof global.btoa == 'function'
        ? function(b){ return global.btoa(b) } : function(b) {
        if (b.match(/[^\x00-\xFF]/)) throw new RangeError(
            'The string contains invalid characters.'
        );
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = function(u) {
        return btoa(utob(String(u)));
    };
    var mkUriSafe = function (b64) {
        return b64.replace(/[+\/]/g, function(m0) {
            return m0 == '+' ? '-' : '_';
        }).replace(/=/g, '');
    };
    var encode = function(u, urisafe) {
        return urisafe ? mkUriSafe(_encode(u)) : _encode(u);
    };
    var encodeURI = function(u) { return encode(u, true) };
    var fromUint8Array;
    if (global.Uint8Array) fromUint8Array = function(a, urisafe) {
        // return btoa(fromCharCode.apply(null, a));
        var b64 = '';
        for (var i = 0, l = a.length; i < l; i += 3) {
            var a0 = a[i], a1 = a[i+1], a2 = a[i+2];
            var ord = a0 << 16 | a1 << 8 | a2;
            b64 +=    b64chars.charAt( ord >>> 18)
                +     b64chars.charAt((ord >>> 12) & 63)
                + ( typeof a1 != 'undefined'
                    ? b64chars.charAt((ord >>>  6) & 63) : '=')
                + ( typeof a2 != 'undefined'
                    ? b64chars.charAt( ord         & 63) : '=');
        }
        return urisafe ? mkUriSafe(b64) : b64;
    };
    // decoder stuff
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = global.atob && typeof global.atob == 'function'
        ? function(a){ return global.atob(a) } : function(a){
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function(a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    var _decode = function(a) { return btou(_atob(a)) };
    var _fromURI = function(a) {
        return String(a).replace(/[-_]/g, function(m0) {
            return m0 == '-' ? '+' : '/'
        }).replace(/[^A-Za-z0-9\+\/]/g, '');
    };
    var decode = function(a){
        return _decode(_fromURI(a));
    };
    var toUint8Array;
    if (global.Uint8Array) toUint8Array = function(a) {
        return Uint8Array.from(atob(_fromURI(a)), function(c) {
            return c.charCodeAt(0);
        });
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        fromUint8Array: fromUint8Array,
        toUint8Array: toUint8Array
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function(){ return global.Base64 });
    }
    // that's it!
    return {Base64: global.Base64}
}));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],16:[function(require,module,exports){
(function (global){(function (){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],17:[function(require,module,exports){
(function (global){(function (){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = throttle;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],18:[function(require,module,exports){
'use strict';
module.exports = Math.log2 || function (x) {
	return Math.log(x) * Math.LOG2E;
};

},{}],19:[function(require,module,exports){
'use strict';

function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (newInputs[i] !== lastInputs[i]) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var lastThis;
    var lastArgs = [];
    var lastResult;
    var calledOnce = false;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
            return lastResult;
        }
        lastResult = resultFn.apply(this, newArgs);
        calledOnce = true;
        lastThis = this;
        lastArgs = newArgs;
        return lastResult;
    }
    return memoized;
}

module.exports = memoizeOne;

},{}],20:[function(require,module,exports){
var wildcard = require('wildcard');
var reMimePartSplit = /[\/\+\.]/;

/**
  # mime-match

  A simple function to checker whether a target mime type matches a mime-type
  pattern (e.g. image/jpeg matches image/jpeg OR image/*).

  ## Example Usage

  <<< example.js

**/
module.exports = function(target, pattern) {
  function test(pattern) {
    var result = wildcard(pattern, target, reMimePartSplit);

    // ensure that we have a valid mime type (should have two parts)
    return result && result.length >= 2;
  }

  return pattern ? test(pattern.split(';')[0]) : test;
};

},{"wildcard":43}],21:[function(require,module,exports){
/**
* Create an event emitter with namespaces
* @name createNamespaceEmitter
* @example
* var emitter = require('./index')()
*
* emitter.on('*', function () {
*   console.log('all events emitted', this.event)
* })
*
* emitter.on('example', function () {
*   console.log('example event emitted')
* })
*/
module.exports = function createNamespaceEmitter () {
  var emitter = {}
  var _fns = emitter._fns = {}

  /**
  * Emit an event. Optionally namespace the event. Handlers are fired in the order in which they were added with exact matches taking precedence. Separate the namespace and event with a `:`
  * @name emit
  * @param {String} event – the name of the event, with optional namespace
  * @param {...*} data – up to 6 arguments that are passed to the event listener
  * @example
  * emitter.emit('example')
  * emitter.emit('demo:test')
  * emitter.emit('data', { example: true}, 'a string', 1)
  */
  emitter.emit = function emit (event, arg1, arg2, arg3, arg4, arg5, arg6) {
    var toEmit = getListeners(event)

    if (toEmit.length) {
      emitAll(event, toEmit, [arg1, arg2, arg3, arg4, arg5, arg6])
    }
  }

  /**
  * Create en event listener.
  * @name on
  * @param {String} event
  * @param {Function} fn
  * @example
  * emitter.on('example', function () {})
  * emitter.on('demo', function () {})
  */
  emitter.on = function on (event, fn) {
    if (!_fns[event]) {
      _fns[event] = []
    }

    _fns[event].push(fn)
  }

  /**
  * Create en event listener that fires once.
  * @name once
  * @param {String} event
  * @param {Function} fn
  * @example
  * emitter.once('example', function () {})
  * emitter.once('demo', function () {})
  */
  emitter.once = function once (event, fn) {
    function one () {
      fn.apply(this, arguments)
      emitter.off(event, one)
    }
    this.on(event, one)
  }

  /**
  * Stop listening to an event. Stop all listeners on an event by only passing the event name. Stop a single listener by passing that event handler as a callback.
  * You must be explicit about what will be unsubscribed: `emitter.off('demo')` will unsubscribe an `emitter.on('demo')` listener,
  * `emitter.off('demo:example')` will unsubscribe an `emitter.on('demo:example')` listener
  * @name off
  * @param {String} event
  * @param {Function} [fn] – the specific handler
  * @example
  * emitter.off('example')
  * emitter.off('demo', function () {})
  */
  emitter.off = function off (event, fn) {
    var keep = []

    if (event && fn) {
      var fns = this._fns[event]
      var i = 0
      var l = fns ? fns.length : 0

      for (i; i < l; i++) {
        if (fns[i] !== fn) {
          keep.push(fns[i])
        }
      }
    }

    keep.length ? this._fns[event] = keep : delete this._fns[event]
  }

  function getListeners (e) {
    var out = _fns[e] ? _fns[e] : []
    var idx = e.indexOf(':')
    var args = (idx === -1) ? [e] : [e.substring(0, idx), e.substring(idx + 1)]

    var keys = Object.keys(_fns)
    var i = 0
    var l = keys.length

    for (i; i < l; i++) {
      var key = keys[i]
      if (key === '*') {
        out = out.concat(_fns[key])
      }

      if (args.length === 2 && args[0] === key) {
        out = out.concat(_fns[key])
        break
      }
    }

    return out
  }

  function emitAll (e, fns, args) {
    var i = 0
    var l = fns.length

    for (i; i < l; i++) {
      if (!fns[i]) break
      fns[i].event = e
      fns[i].apply(fns[i], args)
    }
  }

  return emitter
}

},{}],22:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],23:[function(require,module,exports){
var has = Object.prototype.hasOwnProperty

/**
 * Stringify an object for use in a query string.
 *
 * @param {Object} obj - The object.
 * @param {string} prefix - When nesting, the parent key.
 *     keys in `obj` will be stringified as `prefix[key]`.
 * @returns {string}
 */

module.exports = function queryStringify (obj, prefix) {
  var pairs = []
  for (var key in obj) {
    if (!has.call(obj, key)) {
      continue
    }

    var value = obj[key]
    var enkey = encodeURIComponent(key)
    var pair
    if (typeof value === 'object') {
      pair = queryStringify(value, prefix ? prefix + '[' + enkey + ']' : enkey)
    } else {
      pair = (prefix ? prefix + '[' + enkey + ']' : enkey) + '=' + encodeURIComponent(value)
    }
    pairs.push(pair)
  }
  return pairs.join('&')
}

},{}],24:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],25:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],26:[function(require,module,exports){
(function (global){(function (){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ResizeObserver = factory());
}(this, (function () { 'use strict';

    /**
     * A collection of shims that provide minimal functionality of the ES6 collections.
     *
     * These implementations are not meant to be used outside of the ResizeObserver
     * modules as they cover only a limited range of use cases.
     */
    /* eslint-disable require-jsdoc, valid-jsdoc */
    var MapShim = (function () {
        if (typeof Map !== 'undefined') {
            return Map;
        }
        /**
         * Returns index in provided array that matches the specified key.
         *
         * @param {Array<Array>} arr
         * @param {*} key
         * @returns {number}
         */
        function getIndex(arr, key) {
            var result = -1;
            arr.some(function (entry, index) {
                if (entry[0] === key) {
                    result = index;
                    return true;
                }
                return false;
            });
            return result;
        }
        return /** @class */ (function () {
            function class_1() {
                this.__entries__ = [];
            }
            Object.defineProperty(class_1.prototype, "size", {
                /**
                 * @returns {boolean}
                 */
                get: function () {
                    return this.__entries__.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * @param {*} key
             * @returns {*}
             */
            class_1.prototype.get = function (key) {
                var index = getIndex(this.__entries__, key);
                var entry = this.__entries__[index];
                return entry && entry[1];
            };
            /**
             * @param {*} key
             * @param {*} value
             * @returns {void}
             */
            class_1.prototype.set = function (key, value) {
                var index = getIndex(this.__entries__, key);
                if (~index) {
                    this.__entries__[index][1] = value;
                }
                else {
                    this.__entries__.push([key, value]);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.delete = function (key) {
                var entries = this.__entries__;
                var index = getIndex(entries, key);
                if (~index) {
                    entries.splice(index, 1);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.has = function (key) {
                return !!~getIndex(this.__entries__, key);
            };
            /**
             * @returns {void}
             */
            class_1.prototype.clear = function () {
                this.__entries__.splice(0);
            };
            /**
             * @param {Function} callback
             * @param {*} [ctx=null]
             * @returns {void}
             */
            class_1.prototype.forEach = function (callback, ctx) {
                if (ctx === void 0) { ctx = null; }
                for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                    var entry = _a[_i];
                    callback.call(ctx, entry[1], entry[0]);
                }
            };
            return class_1;
        }());
    })();

    /**
     * Detects whether window and document objects are available in current environment.
     */
    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

    // Returns global object of a current environment.
    var global$1 = (function () {
        if (typeof global !== 'undefined' && global.Math === Math) {
            return global;
        }
        if (typeof self !== 'undefined' && self.Math === Math) {
            return self;
        }
        if (typeof window !== 'undefined' && window.Math === Math) {
            return window;
        }
        // eslint-disable-next-line no-new-func
        return Function('return this')();
    })();

    /**
     * A shim for the requestAnimationFrame which falls back to the setTimeout if
     * first one is not supported.
     *
     * @returns {number} Requests' identifier.
     */
    var requestAnimationFrame$1 = (function () {
        if (typeof requestAnimationFrame === 'function') {
            // It's required to use a bounded function because IE sometimes throws
            // an "Invalid calling object" error if rAF is invoked without the global
            // object on the left hand side.
            return requestAnimationFrame.bind(global$1);
        }
        return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
    })();

    // Defines minimum timeout before adding a trailing call.
    var trailingTimeout = 2;
    /**
     * Creates a wrapper function which ensures that provided callback will be
     * invoked only once during the specified delay period.
     *
     * @param {Function} callback - Function to be invoked after the delay period.
     * @param {number} delay - Delay after which to invoke callback.
     * @returns {Function}
     */
    function throttle (callback, delay) {
        var leadingCall = false, trailingCall = false, lastCallTime = 0;
        /**
         * Invokes the original callback function and schedules new invocation if
         * the "proxy" was called during current request.
         *
         * @returns {void}
         */
        function resolvePending() {
            if (leadingCall) {
                leadingCall = false;
                callback();
            }
            if (trailingCall) {
                proxy();
            }
        }
        /**
         * Callback invoked after the specified delay. It will further postpone
         * invocation of the original function delegating it to the
         * requestAnimationFrame.
         *
         * @returns {void}
         */
        function timeoutCallback() {
            requestAnimationFrame$1(resolvePending);
        }
        /**
         * Schedules invocation of the original function.
         *
         * @returns {void}
         */
        function proxy() {
            var timeStamp = Date.now();
            if (leadingCall) {
                // Reject immediately following calls.
                if (timeStamp - lastCallTime < trailingTimeout) {
                    return;
                }
                // Schedule new call to be in invoked when the pending one is resolved.
                // This is important for "transitions" which never actually start
                // immediately so there is a chance that we might miss one if change
                // happens amids the pending invocation.
                trailingCall = true;
            }
            else {
                leadingCall = true;
                trailingCall = false;
                setTimeout(timeoutCallback, delay);
            }
            lastCallTime = timeStamp;
        }
        return proxy;
    }

    // Minimum delay before invoking the update of observers.
    var REFRESH_DELAY = 20;
    // A list of substrings of CSS properties used to find transition events that
    // might affect dimensions of observed elements.
    var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
    // Check if MutationObserver is available.
    var mutationObserverSupported = typeof MutationObserver !== 'undefined';
    /**
     * Singleton controller class which handles updates of ResizeObserver instances.
     */
    var ResizeObserverController = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserverController.
         *
         * @private
         */
        function ResizeObserverController() {
            /**
             * Indicates whether DOM listeners have been added.
             *
             * @private {boolean}
             */
            this.connected_ = false;
            /**
             * Tells that controller has subscribed for Mutation Events.
             *
             * @private {boolean}
             */
            this.mutationEventsAdded_ = false;
            /**
             * Keeps reference to the instance of MutationObserver.
             *
             * @private {MutationObserver}
             */
            this.mutationsObserver_ = null;
            /**
             * A list of connected observers.
             *
             * @private {Array<ResizeObserverSPI>}
             */
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
        }
        /**
         * Adds observer to observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be added.
         * @returns {void}
         */
        ResizeObserverController.prototype.addObserver = function (observer) {
            if (!~this.observers_.indexOf(observer)) {
                this.observers_.push(observer);
            }
            // Add listeners if they haven't been added yet.
            if (!this.connected_) {
                this.connect_();
            }
        };
        /**
         * Removes observer from observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be removed.
         * @returns {void}
         */
        ResizeObserverController.prototype.removeObserver = function (observer) {
            var observers = this.observers_;
            var index = observers.indexOf(observer);
            // Remove observer if it's present in registry.
            if (~index) {
                observers.splice(index, 1);
            }
            // Remove listeners if controller has no connected observers.
            if (!observers.length && this.connected_) {
                this.disconnect_();
            }
        };
        /**
         * Invokes the update of observers. It will continue running updates insofar
         * it detects changes.
         *
         * @returns {void}
         */
        ResizeObserverController.prototype.refresh = function () {
            var changesDetected = this.updateObservers_();
            // Continue running updates if changes have been detected as there might
            // be future ones caused by CSS transitions.
            if (changesDetected) {
                this.refresh();
            }
        };
        /**
         * Updates every observer from observers list and notifies them of queued
         * entries.
         *
         * @private
         * @returns {boolean} Returns "true" if any observer has detected changes in
         *      dimensions of it's elements.
         */
        ResizeObserverController.prototype.updateObservers_ = function () {
            // Collect observers that have active observations.
            var activeObservers = this.observers_.filter(function (observer) {
                return observer.gatherActive(), observer.hasActive();
            });
            // Deliver notifications in a separate cycle in order to avoid any
            // collisions between observers, e.g. when multiple instances of
            // ResizeObserver are tracking the same element and the callback of one
            // of them changes content dimensions of the observed target. Sometimes
            // this may result in notifications being blocked for the rest of observers.
            activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
            return activeObservers.length > 0;
        };
        /**
         * Initializes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.connect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already added.
            if (!isBrowser || this.connected_) {
                return;
            }
            // Subscription to the "Transitionend" event is used as a workaround for
            // delayed transitions. This way it's possible to capture at least the
            // final state of an element.
            document.addEventListener('transitionend', this.onTransitionEnd_);
            window.addEventListener('resize', this.refresh);
            if (mutationObserverSupported) {
                this.mutationsObserver_ = new MutationObserver(this.refresh);
                this.mutationsObserver_.observe(document, {
                    attributes: true,
                    childList: true,
                    characterData: true,
                    subtree: true
                });
            }
            else {
                document.addEventListener('DOMSubtreeModified', this.refresh);
                this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
        };
        /**
         * Removes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.disconnect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already removed.
            if (!isBrowser || !this.connected_) {
                return;
            }
            document.removeEventListener('transitionend', this.onTransitionEnd_);
            window.removeEventListener('resize', this.refresh);
            if (this.mutationsObserver_) {
                this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
                document.removeEventListener('DOMSubtreeModified', this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
        };
        /**
         * "Transitionend" event handler.
         *
         * @private
         * @param {TransitionEvent} event
         * @returns {void}
         */
        ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
            var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
            // Detect whether transition may affect dimensions of an element.
            var isReflowProperty = transitionKeys.some(function (key) {
                return !!~propertyName.indexOf(key);
            });
            if (isReflowProperty) {
                this.refresh();
            }
        };
        /**
         * Returns instance of the ResizeObserverController.
         *
         * @returns {ResizeObserverController}
         */
        ResizeObserverController.getInstance = function () {
            if (!this.instance_) {
                this.instance_ = new ResizeObserverController();
            }
            return this.instance_;
        };
        /**
         * Holds reference to the controller's instance.
         *
         * @private {ResizeObserverController}
         */
        ResizeObserverController.instance_ = null;
        return ResizeObserverController;
    }());

    /**
     * Defines non-writable/enumerable properties of the provided target object.
     *
     * @param {Object} target - Object for which to define properties.
     * @param {Object} props - Properties to be defined.
     * @returns {Object} Target object.
     */
    var defineConfigurable = (function (target, props) {
        for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
            var key = _a[_i];
            Object.defineProperty(target, key, {
                value: props[key],
                enumerable: false,
                writable: false,
                configurable: true
            });
        }
        return target;
    });

    /**
     * Returns the global object associated with provided element.
     *
     * @param {Object} target
     * @returns {Object}
     */
    var getWindowOf = (function (target) {
        // Assume that the element is an instance of Node, which means that it
        // has the "ownerDocument" property from which we can retrieve a
        // corresponding global object.
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
        // Return the local global object if it's not possible extract one from
        // provided element.
        return ownerGlobal || global$1;
    });

    // Placeholder of an empty content rectangle.
    var emptyRect = createRectInit(0, 0, 0, 0);
    /**
     * Converts provided string to a number.
     *
     * @param {number|string} value
     * @returns {number}
     */
    function toFloat(value) {
        return parseFloat(value) || 0;
    }
    /**
     * Extracts borders size from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @param {...string} positions - Borders positions (top, right, ...)
     * @returns {number}
     */
    function getBordersSize(styles) {
        var positions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            positions[_i - 1] = arguments[_i];
        }
        return positions.reduce(function (size, position) {
            var value = styles['border-' + position + '-width'];
            return size + toFloat(value);
        }, 0);
    }
    /**
     * Extracts paddings sizes from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @returns {Object} Paddings box.
     */
    function getPaddings(styles) {
        var positions = ['top', 'right', 'bottom', 'left'];
        var paddings = {};
        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
            var position = positions_1[_i];
            var value = styles['padding-' + position];
            paddings[position] = toFloat(value);
        }
        return paddings;
    }
    /**
     * Calculates content rectangle of provided SVG element.
     *
     * @param {SVGGraphicsElement} target - Element content rectangle of which needs
     *      to be calculated.
     * @returns {DOMRectInit}
     */
    function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
    }
    /**
     * Calculates content rectangle of provided HTMLElement.
     *
     * @param {HTMLElement} target - Element for which to calculate the content rectangle.
     * @returns {DOMRectInit}
     */
    function getHTMLElementContentRect(target) {
        // Client width & height properties can't be
        // used exclusively as they provide rounded values.
        var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
        // By this condition we can catch all non-replaced inline, hidden and
        // detached elements. Though elements with width & height properties less
        // than 0.5 will be discarded as well.
        //
        // Without it we would need to implement separate methods for each of
        // those cases and it's not possible to perform a precise and performance
        // effective test for hidden elements. E.g. even jQuery's ':visible' filter
        // gives wrong results for elements with width & height less than 0.5.
        if (!clientWidth && !clientHeight) {
            return emptyRect;
        }
        var styles = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom;
        // Computed styles of width & height are being used because they are the
        // only dimensions available to JS that contain non-rounded values. It could
        // be possible to utilize the getBoundingClientRect if only it's data wasn't
        // affected by CSS transformations let alone paddings, borders and scroll bars.
        var width = toFloat(styles.width), height = toFloat(styles.height);
        // Width & height include paddings and borders when the 'border-box' box
        // model is applied (except for IE).
        if (styles.boxSizing === 'border-box') {
            // Following conditions are required to handle Internet Explorer which
            // doesn't include paddings and borders to computed CSS dimensions.
            //
            // We can say that if CSS dimensions + paddings are equal to the "client"
            // properties then it's either IE, and thus we don't need to subtract
            // anything, or an element merely doesn't have paddings/borders styles.
            if (Math.round(width + horizPad) !== clientWidth) {
                width -= getBordersSize(styles, 'left', 'right') + horizPad;
            }
            if (Math.round(height + vertPad) !== clientHeight) {
                height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
            }
        }
        // Following steps can't be applied to the document's root element as its
        // client[Width/Height] properties represent viewport area of the window.
        // Besides, it's as well not necessary as the <html> itself neither has
        // rendered scroll bars nor it can be clipped.
        if (!isDocumentElement(target)) {
            // In some browsers (only in Firefox, actually) CSS width & height
            // include scroll bars size which can be removed at this step as scroll
            // bars are the only difference between rounded dimensions + paddings
            // and "client" properties, though that is not always true in Chrome.
            var vertScrollbar = Math.round(width + horizPad) - clientWidth;
            var horizScrollbar = Math.round(height + vertPad) - clientHeight;
            // Chrome has a rather weird rounding of "client" properties.
            // E.g. for an element with content width of 314.2px it sometimes gives
            // the client width of 315px and for the width of 314.7px it may give
            // 314px. And it doesn't happen all the time. So just ignore this delta
            // as a non-relevant.
            if (Math.abs(vertScrollbar) !== 1) {
                width -= vertScrollbar;
            }
            if (Math.abs(horizScrollbar) !== 1) {
                height -= horizScrollbar;
            }
        }
        return createRectInit(paddings.left, paddings.top, width, height);
    }
    /**
     * Checks whether provided element is an instance of the SVGGraphicsElement.
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    var isSVGGraphicsElement = (function () {
        // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
        // interface.
        if (typeof SVGGraphicsElement !== 'undefined') {
            return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
        }
        // If it's so, then check that element is at least an instance of the
        // SVGElement and that it has the "getBBox" method.
        // eslint-disable-next-line no-extra-parens
        return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
            typeof target.getBBox === 'function'); };
    })();
    /**
     * Checks whether provided element is a document element (<html>).
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
    }
    /**
     * Calculates an appropriate content rectangle for provided html or svg element.
     *
     * @param {Element} target - Element content rectangle of which needs to be calculated.
     * @returns {DOMRectInit}
     */
    function getContentRect(target) {
        if (!isBrowser) {
            return emptyRect;
        }
        if (isSVGGraphicsElement(target)) {
            return getSVGContentRect(target);
        }
        return getHTMLElementContentRect(target);
    }
    /**
     * Creates rectangle with an interface of the DOMRectReadOnly.
     * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
     *
     * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
     * @returns {DOMRectReadOnly}
     */
    function createReadOnlyRect(_a) {
        var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        // If DOMRectReadOnly is available use it as a prototype for the rectangle.
        var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype);
        // Rectangle's properties are not writable and non-enumerable.
        defineConfigurable(rect, {
            x: x, y: y, width: width, height: height,
            top: y,
            right: x + width,
            bottom: height + y,
            left: x
        });
        return rect;
    }
    /**
     * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
     * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
     *
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} width - Rectangle's width.
     * @param {number} height - Rectangle's height.
     * @returns {DOMRectInit}
     */
    function createRectInit(x, y, width, height) {
        return { x: x, y: y, width: width, height: height };
    }

    /**
     * Class that is responsible for computations of the content rectangle of
     * provided DOM element and for keeping track of it's changes.
     */
    var ResizeObservation = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObservation.
         *
         * @param {Element} target - Element to be observed.
         */
        function ResizeObservation(target) {
            /**
             * Broadcasted width of content rectangle.
             *
             * @type {number}
             */
            this.broadcastWidth = 0;
            /**
             * Broadcasted height of content rectangle.
             *
             * @type {number}
             */
            this.broadcastHeight = 0;
            /**
             * Reference to the last observed content rectangle.
             *
             * @private {DOMRectInit}
             */
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
        }
        /**
         * Updates content rectangle and tells whether it's width or height properties
         * have changed since the last broadcast.
         *
         * @returns {boolean}
         */
        ResizeObservation.prototype.isActive = function () {
            var rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return (rect.width !== this.broadcastWidth ||
                rect.height !== this.broadcastHeight);
        };
        /**
         * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
         * from the corresponding properties of the last observed content rectangle.
         *
         * @returns {DOMRectInit} Last observed content rectangle.
         */
        ResizeObservation.prototype.broadcastRect = function () {
            var rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
        };
        return ResizeObservation;
    }());

    var ResizeObserverEntry = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObserverEntry.
         *
         * @param {Element} target - Element that is being observed.
         * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
         */
        function ResizeObserverEntry(target, rectInit) {
            var contentRect = createReadOnlyRect(rectInit);
            // According to the specification following properties are not writable
            // and are also not enumerable in the native implementation.
            //
            // Property accessors are not being used as they'd require to define a
            // private WeakMap storage which may cause memory leaks in browsers that
            // don't support this type of collections.
            defineConfigurable(this, { target: target, contentRect: contentRect });
        }
        return ResizeObserverEntry;
    }());

    var ResizeObserverSPI = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback function that is invoked
         *      when one of the observed elements changes it's content dimensions.
         * @param {ResizeObserverController} controller - Controller instance which
         *      is responsible for the updates of observer.
         * @param {ResizeObserver} callbackCtx - Reference to the public
         *      ResizeObserver instance which will be passed to callback function.
         */
        function ResizeObserverSPI(callback, controller, callbackCtx) {
            /**
             * Collection of resize observations that have detected changes in dimensions
             * of elements.
             *
             * @private {Array<ResizeObservation>}
             */
            this.activeObservations_ = [];
            /**
             * Registry of the ResizeObservation instances.
             *
             * @private {Map<Element, ResizeObservation>}
             */
            this.observations_ = new MapShim();
            if (typeof callback !== 'function') {
                throw new TypeError('The callback provided as parameter 1 is not a function.');
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
        }
        /**
         * Starts observing provided element.
         *
         * @param {Element} target - Element to be observed.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.observe = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is already being observed.
            if (observations.has(target)) {
                return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            // Force the update of observations.
            this.controller_.refresh();
        };
        /**
         * Stops observing provided element.
         *
         * @param {Element} target - Element to stop observing.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.unobserve = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is not being observed.
            if (!observations.has(target)) {
                return;
            }
            observations.delete(target);
            if (!observations.size) {
                this.controller_.removeObserver(this);
            }
        };
        /**
         * Stops observing all elements.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.disconnect = function () {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
        };
        /**
         * Collects observation instances the associated element of which has changed
         * it's content rectangle.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.gatherActive = function () {
            var _this = this;
            this.clearActive();
            this.observations_.forEach(function (observation) {
                if (observation.isActive()) {
                    _this.activeObservations_.push(observation);
                }
            });
        };
        /**
         * Invokes initial callback function with a list of ResizeObserverEntry
         * instances collected from active resize observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.broadcastActive = function () {
            // Do nothing if observer doesn't have active observations.
            if (!this.hasActive()) {
                return;
            }
            var ctx = this.callbackCtx_;
            // Create ResizeObserverEntry instance for every active observation.
            var entries = this.activeObservations_.map(function (observation) {
                return new ResizeObserverEntry(observation.target, observation.broadcastRect());
            });
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
        };
        /**
         * Clears the collection of active observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.clearActive = function () {
            this.activeObservations_.splice(0);
        };
        /**
         * Tells whether observer has active observations.
         *
         * @returns {boolean}
         */
        ResizeObserverSPI.prototype.hasActive = function () {
            return this.activeObservations_.length > 0;
        };
        return ResizeObserverSPI;
    }());

    // Registry of internal observers. If WeakMap is not available use current shim
    // for the Map collection as it has all required methods and because WeakMap
    // can't be fully polyfilled anyway.
    var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
    /**
     * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
     * exposing only those methods and properties that are defined in the spec.
     */
    var ResizeObserver = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback that is invoked when
         *      dimensions of the observed elements change.
         */
        function ResizeObserver(callback) {
            if (!(this instanceof ResizeObserver)) {
                throw new TypeError('Cannot call a class as a function.');
            }
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            var controller = ResizeObserverController.getInstance();
            var observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
        }
        return ResizeObserver;
    }());
    // Expose public methods of ResizeObserver.
    [
        'observe',
        'unobserve',
        'disconnect'
    ].forEach(function (method) {
        ResizeObserver.prototype[method] = function () {
            var _a;
            return (_a = observers.get(this))[method].apply(_a, arguments);
        };
    });

    var index = (function () {
        // Export existing implementation if available.
        if (typeof global$1.ResizeObserver !== 'undefined') {
            return global$1.ResizeObserver;
        }
        return ResizeObserver;
    })();

    return index;

})));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

var _uriToBlob = _interopRequireDefault(require("./uriToBlob"));

var _isCordova = _interopRequireDefault(require("./isCordova"));

var _readAsByteArray = _interopRequireDefault(require("./readAsByteArray"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var FileSource = /*#__PURE__*/function () {
  // Make this.size a method
  function FileSource(file) {
    _classCallCheck(this, FileSource);

    this._file = file;
    this.size = file.size;
  }

  _createClass(FileSource, [{
    key: "slice",
    value: function slice(start, end) {
      // In Apache Cordova applications, a File must be resolved using
      // FileReader instances, see
      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file
      if ((0, _isCordova.default)()) {
        return (0, _readAsByteArray.default)(this._file.slice(start, end));
      }

      var value = this._file.slice(start, end);

      return Promise.resolve({
        value: value
      });
    }
  }, {
    key: "close",
    value: function close() {// Nothing to do here since we don't need to release any resources.
    }
  }]);

  return FileSource;
}();

var StreamSource = /*#__PURE__*/function () {
  function StreamSource(reader, chunkSize) {
    _classCallCheck(this, StreamSource);

    this._chunkSize = chunkSize;
    this._buffer = undefined;
    this._bufferOffset = 0;
    this._reader = reader;
    this._done = false;
  }

  _createClass(StreamSource, [{
    key: "slice",
    value: function slice(start, end) {
      if (start < this._bufferOffset) {
        return Promise.reject(new Error("Requested data is before the reader's current offset"));
      }

      return this._readUntilEnoughDataOrDone(start, end);
    }
  }, {
    key: "_readUntilEnoughDataOrDone",
    value: function _readUntilEnoughDataOrDone(start, end) {
      var _this = this;

      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);

      if (this._done || hasEnoughData) {
        var value = this._getDataFromBuffer(start, end);

        var done = value == null ? this._done : false;
        return Promise.resolve({
          value: value,
          done: done
        });
      }

      return this._reader.read().then(function (_ref) {
        var value = _ref.value,
            done = _ref.done;

        if (done) {
          _this._done = true;
        } else if (_this._buffer === undefined) {
          _this._buffer = value;
        } else {
          _this._buffer = concat(_this._buffer, value);
        }

        return _this._readUntilEnoughDataOrDone(start, end);
      });
    }
  }, {
    key: "_getDataFromBuffer",
    value: function _getDataFromBuffer(start, end) {
      // Remove data from buffer before `start`.
      // Data might be reread from the buffer if an upload fails, so we can only
      // safely delete data when it comes *before* what is currently being read.
      if (start > this._bufferOffset) {
        this._buffer = this._buffer.slice(start - this._bufferOffset);
        this._bufferOffset = start;
      } // If the buffer is empty after removing old data, all data has been read.


      var hasAllDataBeenRead = len(this._buffer) === 0;

      if (this._done && hasAllDataBeenRead) {
        return null;
      } // We already removed data before `start`, so we just return the first
      // chunk from the buffer.


      return this._buffer.slice(0, end - start);
    }
  }, {
    key: "close",
    value: function close() {
      if (this._reader.cancel) {
        this._reader.cancel();
      }
    }
  }]);

  return StreamSource;
}();

function len(blobOrArray) {
  if (blobOrArray === undefined) return 0;
  if (blobOrArray.size !== undefined) return blobOrArray.size;
  return blobOrArray.length;
}
/*
  Typed arrays and blobs don't have a concat method.
  This function helps StreamSource accumulate data to reach chunkSize.
*/


function concat(a, b) {
  if (a.concat) {
    // Is `a` an Array?
    return a.concat(b);
  }

  if (a instanceof Blob) {
    return new Blob([a, b], {
      type: a.type
    });
  }

  if (a.set) {
    // Is `a` a typed array?
    var c = new a.constructor(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
  }

  throw new Error("Unknown data type");
}

var FileReader = /*#__PURE__*/function () {
  function FileReader() {
    _classCallCheck(this, FileReader);
  }

  _createClass(FileReader, [{
    key: "openFile",
    value: function openFile(input, chunkSize) {
      // In React Native, when user selects a file, instead of a File or Blob,
      // you usually get a file object {} with a uri property that contains
      // a local path to the file. We use XMLHttpRequest to fetch
      // the file blob, before uploading with tus.
      if ((0, _isReactNative.default)() && input && typeof input.uri !== "undefined") {
        return (0, _uriToBlob.default)(input.uri).then(function (blob) {
          return new FileSource(blob);
        })["catch"](function (err) {
          throw new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. " + err);
        });
      } // Since we emulate the Blob type in our tests (not all target browsers
      // support it), we cannot use `instanceof` for testing whether the input value
      // can be handled. Instead, we simply check is the slice() function and the
      // size property are available.


      if (typeof input.slice === "function" && typeof input.size !== "undefined") {
        return Promise.resolve(new FileSource(input));
      }

      if (typeof input.read === "function") {
        chunkSize = +chunkSize;

        if (!isFinite(chunkSize)) {
          return Promise.reject(new Error("cannot create source for stream without a finite value for the `chunkSize` option"));
        }

        return Promise.resolve(new StreamSource(input, chunkSize));
      }

      return Promise.reject(new Error("source object may only be an instance of File, Blob, or Reader in this environment"));
    }
  }]);

  return FileReader;
}();

exports.default = FileReader;
},{"./isCordova":31,"./isReactNative":32,"./readAsByteArray":33,"./uriToBlob":34}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fingerprint;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: Differenciate between input types

/**
 * Generate a fingerprint for a file which will be used the store the endpoint
 *
 * @param {File} file
 * @param {Object} options
 * @param {Function} callback
 */
function fingerprint(file, options) {
  if ((0, _isReactNative.default)()) {
    return Promise.resolve(reactNativeFingerprint(file, options));
  }

  return Promise.resolve(["tus-br", file.name, file.type, file.size, file.lastModified, options.endpoint].join("-"));
}

function reactNativeFingerprint(file, options) {
  var exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : "noexif";
  return ["tus-rn", file.name || "noname", file.size || "nosize", exifHash, options.endpoint].join("/");
}

function hashCode(str) {
  // from https://stackoverflow.com/a/8831937/151666
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    var _char = str.charCodeAt(i);

    hash = (hash << 5) - hash + _char;
    hash = hash & hash; // Convert to 32bit integer
  }

  return hash;
}
},{"./isReactNative":32}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var XHRHttpStack = /*#__PURE__*/function () {
  function XHRHttpStack() {
    _classCallCheck(this, XHRHttpStack);
  }

  _createClass(XHRHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      return new Request(method, url);
    }
  }, {
    key: "getName",
    value: function getName() {
      return "XHRHttpStack";
    }
  }]);

  return XHRHttpStack;
}();

exports.default = XHRHttpStack;

var Request = /*#__PURE__*/function () {
  function Request(method, url) {
    _classCallCheck(this, Request);

    this._xhr = new XMLHttpRequest();

    this._xhr.open(method, url, true);

    this._method = method;
    this._url = url;
    this._headers = {};
  }

  _createClass(Request, [{
    key: "getMethod",
    value: function getMethod() {
      return this._method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this._url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this._xhr.setRequestHeader(header, value);

      this._headers[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._headers[header];
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      // Test support for progress events before attaching an event listener
      if (!("upload" in this._xhr)) {
        return;
      }

      this._xhr.upload.onprogress = function (e) {
        if (!e.lengthComputable) {
          return;
        }

        progressHandler(e.loaded);
      };
    }
  }, {
    key: "send",
    value: function send() {
      var _this = this;

      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return new Promise(function (resolve, reject) {
        _this._xhr.onload = function () {
          resolve(new Response(_this._xhr));
        };

        _this._xhr.onerror = function (err) {
          reject(err);
        };

        _this._xhr.send(body);
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      this._xhr.abort();

      return Promise.resolve();
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Request;
}();

var Response = /*#__PURE__*/function () {
  function Response(xhr) {
    _classCallCheck(this, Response);

    this._xhr = xhr;
  }

  _createClass(Response, [{
    key: "getStatus",
    value: function getStatus() {
      return this._xhr.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._xhr.getResponseHeader(header);
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._xhr.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Response;
}();
},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "enableDebugLog", {
  enumerable: true,
  get: function () {
    return _logger.enableDebugLog;
  }
});
Object.defineProperty(exports, "canStoreURLs", {
  enumerable: true,
  get: function () {
    return _urlStorage.canStoreURLs;
  }
});
exports.isSupported = exports.defaultOptions = exports.Upload = void 0;

var _upload = _interopRequireDefault(require("../upload"));

var _noopUrlStorage = _interopRequireDefault(require("../noopUrlStorage"));

var _logger = require("../logger");

var _urlStorage = require("./urlStorage");

var _httpStack = _interopRequireDefault(require("./httpStack"));

var _fileReader = _interopRequireDefault(require("./fileReader"));

var _fingerprint = _interopRequireDefault(require("./fingerprint"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/* global window */


var defaultOptions = _objectSpread({}, _upload.default.defaultOptions, {
  httpStack: new _httpStack.default(),
  fileReader: new _fileReader.default(),
  urlStorage: _urlStorage.canStoreURLs ? new _urlStorage.WebStorageUrlStorage() : new _noopUrlStorage.default(),
  fingerprint: _fingerprint.default
});

exports.defaultOptions = defaultOptions;

var Upload = /*#__PURE__*/function (_BaseUpload) {
  _inherits(Upload, _BaseUpload);

  var _super = _createSuper(Upload);

  function Upload() {
    var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Upload);

    options = _objectSpread({}, defaultOptions, {}, options);
    return _super.call(this, file, options);
  }

  _createClass(Upload, null, [{
    key: "terminate",
    value: function terminate(url, options, cb) {
      options = _objectSpread({}, defaultOptions, {}, options);
      return _upload.default.terminate(url, options, cb);
    }
  }]);

  return Upload;
}(_upload.default);

exports.Upload = Upload;
var _window = window,
    XMLHttpRequest = _window.XMLHttpRequest,
    Blob = _window.Blob;
var isSupported = XMLHttpRequest && Blob && typeof Blob.prototype.slice === "function";
exports.isSupported = isSupported;
},{"../logger":37,"../noopUrlStorage":38,"../upload":39,"./fileReader":27,"./fingerprint":28,"./httpStack":29,"./urlStorage":35}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var isCordova = function isCordova() {
  return typeof window != "undefined" && (typeof window.PhoneGap != "undefined" || typeof window.Cordova != "undefined" || typeof window.cordova != "undefined");
};

var _default = isCordova;
exports.default = _default;
},{}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var isReactNative = function isReactNative() {
  return typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
};

var _default = isReactNative;
exports.default = _default;
},{}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = readAsByteArray;

/**
 * readAsByteArray converts a File object to a Uint8Array.
 * This function is only used on the Apache Cordova platform.
 * See https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file/index.html#read-a-file
 */
function readAsByteArray(chunk) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();

    reader.onload = function () {
      var value = new Uint8Array(reader.result);
      resolve({
        value: value
      });
    };

    reader.onerror = function (err) {
      reject(err);
    };

    reader.readAsArrayBuffer(chunk);
  });
}
},{}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = uriToBlob;

/**
 * uriToBlob resolves a URI to a Blob object. This is used for
 * React Native to retrieve a file (identified by a file://
 * URI) as a blob.
 */
function uriToBlob(uri) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.responseType = "blob";

    xhr.onload = function () {
      var blob = xhr.response;
      resolve(blob);
    };

    xhr.onerror = function (err) {
      reject(err);
    };

    xhr.open("GET", uri);
    xhr.send();
  });
}
},{}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebStorageUrlStorage = exports.canStoreURLs = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window, localStorage */


var hasStorage = false;

try {
  hasStorage = "localStorage" in window; // Attempt to store and read entries from the local storage to detect Private
  // Mode on Safari on iOS (see #49)

  var key = "tusSupport";
  localStorage.setItem(key, localStorage.getItem(key));
} catch (e) {
  // If we try to access localStorage inside a sandboxed iframe, a SecurityError
  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is
  // thrown (see #49)
  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {
    hasStorage = false;
  } else {
    throw e;
  }
}

var canStoreURLs = hasStorage;
exports.canStoreURLs = canStoreURLs;

var WebStorageUrlStorage = /*#__PURE__*/function () {
  function WebStorageUrlStorage() {
    _classCallCheck(this, WebStorageUrlStorage);
  }

  _createClass(WebStorageUrlStorage, [{
    key: "findAllUploads",
    value: function findAllUploads() {
      var results = this._findEntries("tus::");

      return Promise.resolve(results);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      var results = this._findEntries("tus::".concat(fingerprint, "::"));

      return Promise.resolve(results);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      localStorage.removeItem(urlStorageKey);
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      var id = Math.round(Math.random() * 1e12);
      var key = "tus::".concat(fingerprint, "::").concat(id);
      localStorage.setItem(key, JSON.stringify(upload));
      return Promise.resolve(key);
    }
  }, {
    key: "_findEntries",
    value: function _findEntries(prefix) {
      var results = [];

      for (var i = 0; i < localStorage.length; i++) {
        var _key = localStorage.key(i);

        if (_key.indexOf(prefix) !== 0) continue;

        try {
          var upload = JSON.parse(localStorage.getItem(_key));
          upload.urlStorageKey = _key;
          results.push(upload);
        } catch (e) {// The JSON parse error is intentionally ignored here, so a malformed
          // entry in the storage cannot prevent an upload.
        }
      }

      return results;
    }
  }]);

  return WebStorageUrlStorage;
}();

exports.WebStorageUrlStorage = WebStorageUrlStorage;
},{}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

var DetailedError = /*#__PURE__*/function (_Error) {
  _inherits(DetailedError, _Error);

  var _super = _createSuper(DetailedError);

  function DetailedError(message) {
    var _this;

    var causingErr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var req = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var res = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, DetailedError);

    _this = _super.call(this, message);
    _this.originalRequest = req;
    _this.originalResponse = res;
    _this.causingError = causingErr;

    if (causingErr != null) {
      message += ", caused by ".concat(causingErr.toString());
    }

    if (req != null) {
      var requestId = req.getHeader("X-Request-ID") || "n/a";
      var method = req.getMethod();
      var url = req.getURL();
      var status = res ? res.getStatus() : "n/a";
      var body = res ? res.getBody() || "" : "n/a";
      message += ", originated from request (method: ".concat(method, ", url: ").concat(url, ", response code: ").concat(status, ", response text: ").concat(body, ", request id: ").concat(requestId, ")");
    }

    _this.message = message;
    return _this;
  }

  return DetailedError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var _default = DetailedError;
exports.default = _default;
},{}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enableDebugLog = enableDebugLog;
exports.log = log;

/* eslint no-console: "off" */
var isEnabled = false;

function enableDebugLog() {
  isEnabled = true;
}

function log(msg) {
  if (!isEnabled) return;
  console.log(msg);
}
},{}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* eslint no-unused-vars: "off" */


var NoopUrlStorage = /*#__PURE__*/function () {
  function NoopUrlStorage() {
    _classCallCheck(this, NoopUrlStorage);
  }

  _createClass(NoopUrlStorage, [{
    key: "listAllUploads",
    value: function listAllUploads() {
      return Promise.resolve([]);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      return Promise.resolve([]);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      return Promise.resolve(null);
    }
  }]);

  return NoopUrlStorage;
}();

exports.default = NoopUrlStorage;
},{}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _error = _interopRequireDefault(require("./error"));

var _uuid = _interopRequireDefault(require("./uuid"));

var _jsBase = require("js-base64");

var _urlParse = _interopRequireDefault(require("url-parse"));

var _logger = require("./logger");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var defaultOptions = {
  endpoint: null,
  uploadUrl: null,
  metadata: {},
  fingerprint: null,
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  _onUploadUrlAvailable: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  onBeforeRequest: null,
  onAfterResponse: null,
  chunkSize: Infinity,
  retryDelays: [0, 1000, 3000, 5000],
  parallelUploads: 1,
  storeFingerprintForResuming: true,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false,
  urlStorage: null,
  fileReader: null,
  httpStack: null
};

var BaseUpload = /*#__PURE__*/function () {
  function BaseUpload(file, options) {
    _classCallCheck(this, BaseUpload); // Warn about removed options from previous versions


    if ("resume" in options) {
      console.log("tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead."); // eslint-disable-line no-console
    } // The default options will already be added from the wrapper classes.


    this.options = options; // The storage module used to store URLs

    this._urlStorage = this.options.urlStorage; // The underlying File/Blob object

    this.file = file; // The URL against which the file will be uploaded

    this.url = null; // The underlying request object for the current PATCH request

    this._req = null; // The fingerpinrt for the current file (set after start())

    this._fingerprint = null; // The key that the URL storage returned when saving an URL with a fingerprint,

    this._urlStorageKey = null; // The offset used in the current PATCH request

    this._offset = null; // True if the current PATCH request has been aborted

    this._aborted = false; // The file's size in bytes

    this._size = null; // The Source object which will wrap around the given file and provides us
    // with a unified interface for getting its size and slice chunks from its
    // content allowing us to easily handle Files, Blobs, Buffers and Streams.

    this._source = null; // The current count of attempts which have been made. Zero indicates none.

    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry

    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.

    this._offsetBeforeRetry = 0; // An array of BaseUpload instances which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploads = null; // An array of upload URLs which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploadUrls = null;
  }
  /**
   * Use the Termination extension to delete an upload from the server by sending a DELETE
   * request to the specified upload URL. This is only possible if the server supports the
   * Termination extension. If the `options.retryDelays` property is set, the method will
   * also retry if an error ocurrs.
   *
   * @param {String} url The upload's URL which will be terminated.
   * @param {object} options Optional options for influencing HTTP requests.
   * @return {Promise} The Promise will be resolved/rejected when the requests finish.
   */


  _createClass(BaseUpload, [{
    key: "findPreviousUploads",
    value: function findPreviousUploads() {
      var _this = this;

      return this.options.fingerprint(this.file, this.options).then(function (fingerprint) {
        return _this._urlStorage.findUploadsByFingerprint(fingerprint);
      });
    }
  }, {
    key: "resumeFromPreviousUpload",
    value: function resumeFromPreviousUpload(previousUpload) {
      this.url = previousUpload.uploadUrl || null;
      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;
      this._urlStorageKey = previousUpload.urlStorageKey;
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var file = this.file;

      if (!file) {
        this._emitError(new Error("tus: no file or stream to upload provided"));

        return;
      }

      if (!this.options.endpoint && !this.options.uploadUrl) {
        this._emitError(new Error("tus: neither an endpoint or an upload URL is provided"));

        return;
      }

      var retryDelays = this.options.retryDelays;

      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== "[object Array]") {
        this._emitError(new Error("tus: the `retryDelays` option must either be an array or null"));

        return;
      }

      if (this.options.parallelUploads > 1) {
        // Test which options are incompatible with parallel uploads.
        ["uploadUrl", "uploadSize", "uploadLengthDeferred"].forEach(function (optionName) {
          if (_this2.options[optionName]) {
            _this2._emitError(new Error("tus: cannot use the ".concat(optionName, " option when parallelUploads is enabled")));
          }
        });
      }

      this.options.fingerprint(file, this.options).then(function (fingerprint) {
        if (fingerprint == null) {
          (0, _logger.log)("No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.");
        } else {
          (0, _logger.log)("Calculated fingerprint: ".concat(fingerprint));
        }

        _this2._fingerprint = fingerprint;

        if (_this2._source) {
          return _this2._source;
        } else {
          return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);
        }
      }).then(function (source) {
        _this2._source = source; // If the upload was configured to use multiple requests or if we resume from
        // an upload which used multiple requests, we start a parallel upload.

        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {
          _this2._startParallelUpload();
        } else {
          _this2._startSingleUpload();
        }
      })["catch"](function (err) {
        _this2._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a parallelized upload, where one file is split into
     * multiple request which are run in parallel.
     *
     * @api private
     */

  }, {
    key: "_startParallelUpload",
    value: function _startParallelUpload() {
      var _this3 = this;

      var totalSize = this._size = this._source.size;
      var totalProgress = 0;
      this._parallelUploads = [];
      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads; // The input file will be split into multiple slices which are uploaded in separate
      // requests. Here we generate the start and end position for the slices.

      var parts = splitSizeIntoParts(this._source.size, partCount, this._parallelUploadUrls); // Create an empty list for storing the upload URLs

      this._parallelUploadUrls = new Array(parts.length); // Generate a promise for each slice that will be resolve if the respective
      // upload is completed.

      var uploads = parts.map(function (part, index) {
        var lastPartProgress = 0;
        return _this3._source.slice(part.start, part.end).then(function (_ref) {
          var value = _ref.value;
          return new Promise(function (resolve, reject) {
            // Merge with the user supplied options but overwrite some values.
            var options = _objectSpread({}, _this3.options, {
              // If available, the partial upload should be resumed from a previous URL.
              uploadUrl: part.uploadUrl || null,
              // We take manually care of resuming for partial uploads, so they should
              // not be stored in the URL storage.
              storeFingerprintForResuming: false,
              removeFingerprintOnSuccess: false,
              // Reset the parallelUploads option to not cause recursion.
              parallelUploads: 1,
              metadata: {},
              // Add the header to indicate the this is a partial upload.
              headers: _objectSpread({}, _this3.options.headers, {
                "Upload-Concat": "partial"
              }),
              // Reject or resolve the promise if the upload errors or completes.
              onSuccess: resolve,
              onError: reject,
              // Based in the progress for this partial upload, calculate the progress
              // for the entire final upload.
              onProgress: function onProgress(newPartProgress) {
                totalProgress = totalProgress - lastPartProgress + newPartProgress;
                lastPartProgress = newPartProgress;

                _this3._emitProgress(totalProgress, totalSize);
              },
              // Wait until every partial upload has an upload URL, so we can add
              // them to the URL storage.
              _onUploadUrlAvailable: function _onUploadUrlAvailable() {
                _this3._parallelUploadUrls[index] = upload.url; // Test if all uploads have received an URL

                if (_this3._parallelUploadUrls.filter(function (u) {
                  return !!u;
                }).length === parts.length) {
                  _this3._saveUploadInUrlStorage();
                }
              }
            });

            var upload = new BaseUpload(value, options);
            upload.start(); // Store the upload in an array, so we can later abort them if necessary.

            _this3._parallelUploads.push(upload);
          });
        });
      });
      var req; // Wait until all partial uploads are finished and we can send the POST request for
      // creating the final upload.

      Promise.all(uploads).then(function () {
        req = _this3._openRequest("POST", _this3.options.endpoint);
        req.setHeader("Upload-Concat", "final;".concat(_this3._parallelUploadUrls.join(" "))); // Add metadata if values have been added

        var metadata = encodeMetadata(_this3.options.metadata);

        if (metadata !== "") {
          req.setHeader("Upload-Metadata", metadata);
        }

        return _this3._sendRequest(req, null);
      }).then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this3._emitHttpError(req, res, "tus: unexpected response while creating upload");

          return;
        }

        var location = res.getHeader("Location");

        if (location == null) {
          _this3._emitHttpError(req, res, "tus: invalid or missing Location header");

          return;
        }

        _this3.url = resolveUrl(_this3.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this3.url));

        _this3._emitSuccess();
      })["catch"](function (err) {
        _this3._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is
     * uploaded in a sequential matter.
     *
     * @api private
     */

  }, {
    key: "_startSingleUpload",
    value: function _startSingleUpload() {
      // First, we look at the uploadLengthDeferred option.
      // Next, we check if the caller has supplied a manual upload size.
      // Finally, we try to use the calculated size from the source object.
      if (this.options.uploadLengthDeferred) {
        this._size = null;
      } else if (this.options.uploadSize != null) {
        this._size = +this.options.uploadSize;

        if (isNaN(this._size)) {
          this._emitError(new Error("tus: cannot convert `uploadSize` option into a number"));

          return;
        }
      } else {
        this._size = this._source.size;

        if (this._size == null) {
          this._emitError(new Error("tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option"));

          return;
        }
      } // Reset the aborted flag when the upload is started or else the
      // _performUpload will stop before sending a request if the upload has been
      // aborted previously.


      this._aborted = false; // The upload had been started previously and we should reuse this URL.

      if (this.url != null) {
        (0, _logger.log)("Resuming upload from previous URL: ".concat(this.url));

        this._resumeUpload();

        return;
      } // A URL has manually been specified, so we try to resume


      if (this.options.uploadUrl != null) {
        (0, _logger.log)("Resuming upload from provided URL: ".concat(this.options.url));
        this.url = this.options.uploadUrl;

        this._resumeUpload();

        return;
      } // An upload has not started for the file yet, so we start a new one


      (0, _logger.log)("Creating a new upload");

      this._createUpload();
    }
    /**
     * Abort any running request and stop the current upload. After abort is called, no event
     * handler will be invoked anymore. You can use the `start` method to resume the upload
     * again.
     * If `shouldTerminate` is true, the `terminate` function will be called to remove the
     * current upload from the server.
     *
     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.
     * @return {Promise} The Promise will be resolved/rejected when the requests finish.
     */

  }, {
    key: "abort",
    value: function abort(shouldTerminate, cb) {
      var _this4 = this;

      if (typeof cb === "function") {
        throw new Error("tus: the abort function does not accept a callback since v2 anymore; please use the returned Promise instead");
      } // Stop any parallel partial uploads, that have been started in _startParallelUploads.


      if (this._parallelUploads != null) {
        this._parallelUploads.forEach(function (upload) {
          upload.abort(shouldTerminate);
        });
      } // Stop any current running request.


      if (this._req !== null) {
        this._req.abort();

        this._source.close();
      }

      this._aborted = true; // Stop any timeout used for initiating a retry.

      if (this._retryTimeout != null) {
        clearTimeout(this._retryTimeout);
        this._retryTimeout = null;
      }

      if (!shouldTerminate || this.url == null) {
        return Promise.resolve();
      }

      return BaseUpload.terminate(this.url, this.options) // Remove entry from the URL storage since the upload URL is no longer valid.
      .then(function () {
        return _this4._removeFromUrlStorage();
      });
    }
  }, {
    key: "_emitHttpError",
    value: function _emitHttpError(req, res, message, causingErr) {
      this._emitError(new _error.default(message, causingErr, req, res));
    }
  }, {
    key: "_emitError",
    value: function _emitError(err) {
      var _this5 = this; // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.


      if (this._aborted) return; // Check if we should retry, when enabled, before sending the error to the user.

      if (this.options.retryDelays != null) {
        // We will reset the attempt counter if
        // - we were already able to connect to the server (offset != null) and
        // - we were able to upload a small chunk of data to the server
        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;

        if (shouldResetDelays) {
          this._retryAttempt = 0;
        }

        if (shouldRetry(err, this._retryAttempt, this.options)) {
          var delay = this.options.retryDelays[this._retryAttempt++];
          this._offsetBeforeRetry = this._offset;
          this._retryTimeout = setTimeout(function () {
            _this5.start();
          }, delay);
          return;
        }
      }

      if (typeof this.options.onError === "function") {
        this.options.onError(err);
      } else {
        throw err;
      }
    }
    /**
     * Publishes notification if the upload has been successfully completed.
     *
     * @api private
     */

  }, {
    key: "_emitSuccess",
    value: function _emitSuccess() {
      if (this.options.removeFingerprintOnSuccess) {
        // Remove stored fingerprint and corresponding endpoint. This causes
        // new uploads of the same file to be treated as a different file.
        this._removeFromUrlStorage();
      }

      if (typeof this.options.onSuccess === "function") {
        this.options.onSuccess();
      }
    }
    /**
     * Publishes notification when data has been sent to the server. This
     * data may not have been accepted by the server yet.
     *
     * @param {number} bytesSent  Number of bytes sent to the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitProgress",
    value: function _emitProgress(bytesSent, bytesTotal) {
      if (typeof this.options.onProgress === "function") {
        this.options.onProgress(bytesSent, bytesTotal);
      }
    }
    /**
     * Publishes notification when a chunk of data has been sent to the server
     * and accepted by the server.
     * @param {number} chunkSize  Size of the chunk that was accepted by the server.
     * @param {number} bytesAccepted Total number of bytes that have been
     *                                accepted by the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitChunkComplete",
    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
      if (typeof this.options.onChunkComplete === "function") {
        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
      }
    }
    /**
     * Create a new upload using the creation extension by sending a POST
     * request to the endpoint. After successful creation the file will be
     * uploaded
     *
     * @api private
     */

  }, {
    key: "_createUpload",
    value: function _createUpload() {
      var _this6 = this;

      if (!this.options.endpoint) {
        this._emitError(new Error("tus: unable to create upload because no endpoint is provided"));

        return;
      }

      var req = this._openRequest("POST", this.options.endpoint);

      if (this.options.uploadLengthDeferred) {
        req.setHeader("Upload-Defer-Length", 1);
      } else {
        req.setHeader("Upload-Length", this._size);
      } // Add metadata if values have been added


      var metadata = encodeMetadata(this.options.metadata);

      if (metadata !== "") {
        req.setHeader("Upload-Metadata", metadata);
      }

      var promise;

      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {
        this._offset = 0;
        promise = this._addChunkToRequest(req);
      } else {
        promise = this._sendRequest(req, null);
      }

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this6._emitHttpError(req, res, "tus: unexpected response while creating upload");

          return;
        }

        var location = res.getHeader("Location");

        if (location == null) {
          _this6._emitHttpError(req, res, "tus: invalid or missing Location header");

          return;
        }

        _this6.url = resolveUrl(_this6.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this6.url));

        if (typeof _this6.options._onUploadUrlAvailable === "function") {
          _this6.options._onUploadUrlAvailable();
        }

        if (_this6._size === 0) {
          // Nothing to upload and file was successfully created
          _this6._emitSuccess();

          _this6._source.close();

          return;
        }

        _this6._saveUploadInUrlStorage();

        if (_this6.options.uploadDataDuringCreation) {
          _this6._handleUploadResponse(req, res);
        } else {
          _this6._offset = 0;

          _this6._performUpload();
        }
      })["catch"](function (err) {
        _this6._emitHttpError(req, null, "tus: failed to create upload", err);
      });
    }
    /*
     * Try to resume an existing upload. First a HEAD request will be sent
     * to retrieve the offset. If the request fails a new upload will be
     * created. In the case of a successful response the file will be uploaded.
     *
     * @api private
     */

  }, {
    key: "_resumeUpload",
    value: function _resumeUpload() {
      var _this7 = this;

      var req = this._openRequest("HEAD", this.url);

      var promise = this._sendRequest(req, null);

      promise.then(function (res) {
        var status = res.getStatus();

        if (!inStatusCategory(status, 200)) {
          if (inStatusCategory(status, 400)) {
            // Remove stored fingerprint and corresponding endpoint,
            // on client errors since the file can not be found
            _this7._removeFromUrlStorage();
          } // If the upload is locked (indicated by the 423 Locked status code), we
          // emit an error instead of directly starting a new upload. This way the
          // retry logic can catch the error and will retry the upload. An upload
          // is usually locked for a short period of time and will be available
          // afterwards.


          if (status === 423) {
            _this7._emitHttpError(req, res, "tus: upload is currently locked; retry later");

            return;
          }

          if (!_this7.options.endpoint) {
            // Don't attempt to create a new upload if no endpoint is provided.
            _this7._emitHttpError(req, res, "tus: unable to resume upload (new upload cannot be created without an endpoint)");

            return;
          } // Try to create a new upload


          _this7.url = null;

          _this7._createUpload();

          return;
        }

        var offset = parseInt(res.getHeader("Upload-Offset"), 10);

        if (isNaN(offset)) {
          _this7._emitHttpError(req, res, "tus: invalid or missing offset value");

          return;
        }

        var length = parseInt(res.getHeader("Upload-Length"), 10);

        if (isNaN(length) && !_this7.options.uploadLengthDeferred) {
          _this7._emitHttpError(req, res, "tus: invalid or missing length value");

          return;
        }

        if (typeof _this7.options._onUploadUrlAvailable === "function") {
          _this7.options._onUploadUrlAvailable();
        } // Upload has already been completed and we do not need to send additional
        // data to the server


        if (offset === length) {
          _this7._emitProgress(length, length);

          _this7._emitSuccess();

          return;
        }

        _this7._offset = offset;

        _this7._performUpload();
      })["catch"](function (err) {
        _this7._emitHttpError(req, null, "tus: failed to resume upload", err);
      });
    }
    /**
     * Start uploading the file using PATCH requests. The file will be divided
     * into chunks as specified in the chunkSize option. During the upload
     * the onProgress event handler may be invoked multiple times.
     *
     * @api private
     */

  }, {
    key: "_performUpload",
    value: function _performUpload() {
      var _this8 = this; // If the upload has been aborted, we will not send the next PATCH request.
      // This is important if the abort method was called during a callback, such
      // as onChunkComplete or onProgress.


      if (this._aborted) {
        return;
      }

      var req; // Some browser and servers may not support the PATCH method. For those
      // cases, you can tell tus-js-client to use a POST request with the
      // X-HTTP-Method-Override header for simulating a PATCH request.

      if (this.options.overridePatchMethod) {
        req = this._openRequest("POST", this.url);
        req.setHeader("X-HTTP-Method-Override", "PATCH");
      } else {
        req = this._openRequest("PATCH", this.url);
      }

      req.setHeader("Upload-Offset", this._offset);

      var promise = this._addChunkToRequest(req);

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this8._emitHttpError(req, res, "tus: unexpected response while uploading chunk");

          return;
        }

        _this8._handleUploadResponse(req, res);
      })["catch"](function (err) {
        // Don't emit an error if the upload was aborted manually
        if (_this8._aborted) {
          return;
        }

        _this8._emitHttpError(req, null, "tus: failed to upload chunk at offset " + _this8._offset, err);
      });
    }
    /**
     * _addChunktoRequest reads a chunk from the source and sends it using the
     * supplied request object. It will not handle the response.
     *
     * @api private
     */

  }, {
    key: "_addChunkToRequest",
    value: function _addChunkToRequest(req) {
      var _this9 = this;

      var start = this._offset;
      var end = this._offset + this.options.chunkSize;
      req.setProgressHandler(function (bytesSent) {
        _this9._emitProgress(start + bytesSent, _this9._size);
      });
      req.setHeader("Content-Type", "application/offset+octet-stream"); // The specified chunkSize may be Infinity or the calcluated end position
      // may exceed the file's size. In both cases, we limit the end position to
      // the input's total size for simpler calculations and correctness.

      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {
        end = this._size;
      }

      return this._source.slice(start, end).then(function (_ref2) {
        var value = _ref2.value,
            done = _ref2.done; // If the upload length is deferred, the upload size was not specified during
        // upload creation. So, if the file reader is done reading, we know the total
        // upload size and can tell the tus server.

        if (_this9.options.uploadLengthDeferred && done) {
          _this9._size = _this9._offset + (value && value.size ? value.size : 0);
          req.setHeader("Upload-Length", _this9._size);
        }

        if (value === null) {
          return _this9._sendRequest(req);
        } else {
          _this9._emitProgress(_this9._offset, _this9._size);

          return _this9._sendRequest(req, value);
        }
      });
    }
    /**
     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest
     * and already have received a response.
     *
     * @api private
     */

  }, {
    key: "_handleUploadResponse",
    value: function _handleUploadResponse(req, res) {
      var offset = parseInt(res.getHeader("Upload-Offset"), 10);

      if (isNaN(offset)) {
        this._emitHttpError(req, res, "tus: invalid or missing offset value");

        return;
      }

      this._emitProgress(offset, this._size);

      this._emitChunkComplete(offset - this._offset, offset, this._size);

      this._offset = offset;

      if (offset == this._size) {
        // Yay, finally done :)
        this._emitSuccess();

        this._source.close();

        return;
      }

      this._performUpload();
    }
    /**
     * Create a new HTTP request object with the given method and URL.
     *
     * @api private
     */

  }, {
    key: "_openRequest",
    value: function _openRequest(method, url) {
      var req = openRequest(method, url, this.options);
      this._req = req;
      return req;
    }
    /**
     * Remove the entry in the URL storage, if it has been saved before.
     *
     * @api private
     */

  }, {
    key: "_removeFromUrlStorage",
    value: function _removeFromUrlStorage() {
      var _this10 = this;

      if (!this._urlStorageKey) return;

      this._urlStorage.removeUpload(this._urlStorageKey)["catch"](function (err) {
        _this10._emitError(err);
      });

      this._urlStorageKey = null;
    }
    /**
     * Add the upload URL to the URL storage, if possible.
     *
     * @api private
     */

  }, {
    key: "_saveUploadInUrlStorage",
    value: function _saveUploadInUrlStorage() {
      var _this11 = this; // Only if a fingerprint was calculated for the input (i.e. not a stream), we can store the upload URL.


      if (!this.options.storeFingerprintForResuming || !this._fingerprint) {
        return;
      }

      var storedUpload = {
        size: this._size,
        metadata: this.options.metadata,
        creationTime: new Date().toString()
      };

      if (this._parallelUploads) {
        // Save multiple URLs if the parallelUploads option is used ...
        storedUpload.parallelUploadUrls = this._parallelUploadUrls;
      } else {
        // ... otherwise we just save the one available URL.
        storedUpload.uploadUrl = this.url;
      }

      this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function (urlStorageKey) {
        return _this11._urlStorageKey = urlStorageKey;
      })["catch"](function (err) {
        _this11._emitError(err);
      });
    }
    /**
     * Send a request with the provided body while invoking the onBeforeRequest
     * and onAfterResponse callbacks.
     *
     * @api private
     */

  }, {
    key: "_sendRequest",
    value: function _sendRequest(req) {
      var _this12 = this;

      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (typeof this.options.onBeforeRequest === "function") {
        this.options.onBeforeRequest(req);
      }

      return req.send(body).then(function (res) {
        if (typeof _this12.options.onAfterResponse === "function") {
          _this12.options.onAfterResponse(req, res);
        }

        return res;
      });
    }
  }], [{
    key: "terminate",
    value: function terminate(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cb = arguments.length > 2 ? arguments[2] : undefined;

      if (typeof options === "function" || typeof cb === "function") {
        throw new Error("tus: the terminate function does not accept a callback since v2 anymore; please use the returned Promise instead");
      }

      var req = openRequest("DELETE", url, options);
      var promise = req.send();
      return promise.then(function (res) {
        // A 204 response indicates a successfull request
        if (res.getStatus() === 204) {
          return;
        }

        throw new _error.default("tus: unexpected response while terminating upload", null, req, res);
      })["catch"](function (err) {
        if (!(err instanceof _error.default)) {
          err = new _error.default("tus: failed to terminate upload", err, req, null);
        }

        if (!shouldRetry(err, 0, options)) {
          throw err;
        } // Instead of keeping track of the retry attempts, we remove the first element from the delays
        // array. If the array is empty, all retry attempts are used up and we will bubble up the error.
        // We recursively call the terminate function will removing elements from the retryDelays array.


        var delay = options.retryDelays[0];
        var remainingDelays = options.retryDelays.slice(1);

        var newOptions = _objectSpread({}, options, {
          retryDelays: remainingDelays
        });

        return new Promise(function (resolve) {
          return setTimeout(resolve, delay);
        }).then(function () {
          return BaseUpload.terminate(url, newOptions);
        });
      });
    }
  }]);

  return BaseUpload;
}();

function encodeMetadata(metadata) {
  var encoded = [];

  for (var key in metadata) {
    encoded.push(key + " " + _jsBase.Base64.encode(metadata[key]));
  }

  return encoded.join(",");
}
/**
 * Checks whether a given status is in the range of the expected category.
 * For example, only a status between 200 and 299 will satisfy the category 200.
 *
 * @api private
 */


function inStatusCategory(status, category) {
  return status >= category && status < category + 100;
}
/**
 * Create a new HTTP request with the specified method and URL.
 * The necessary headers that are included in every request
 * will be added, including the request ID.
 *
 * @api private
 */


function openRequest(method, url, options) {
  var req = options.httpStack.createRequest(method, url);
  req.setHeader("Tus-Resumable", "1.0.0");
  var headers = options.headers || {};

  for (var name in headers) {
    req.setHeader(name, headers[name]);
  }

  if (options.addRequestId) {
    var requestId = (0, _uuid.default)();
    req.setHeader("X-Request-ID", requestId);
  }

  return req;
}
/**
 * Checks whether the browser running this code has internet access.
 * This function will always return true in the node.js environment
 *
 * @api private
 */


function isOnline() {
  var online = true;

  if (typeof window !== "undefined" && "navigator" in window && window.navigator.onLine === false) {
    online = false;
  }

  return online;
}
/**
 * Checks whether or not it is ok to retry a request.
 * @param {Error} err the error returned from the last request
 * @param {number} retryAttempt the number of times the request has already been retried
 * @param {object} options tus Upload options
 *
 * @api private
 */


function shouldRetry(err, retryAttempt, options) {
  // We only attempt a retry if
  // - retryDelays option is set
  // - we didn't exceed the maxium number of retries, yet, and
  // - this error was caused by a request or it's response and
  // - the error is server error (i.e. no a status 4xx or a 409 or 423) and
  // - the browser does not indicate that we are offline
  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;
  var isServerError = !inStatusCategory(status, 400) || status === 409 || status === 423;
  return options.retryDelays != null && retryAttempt < options.retryDelays.length && err.originalRequest != null && isServerError && isOnline();
}
/**
 * Resolve a relative link given the origin as source. For example,
 * if a HTTP request to http://example.com/files/ returns a Location
 * header with the value /upload/abc, the resolved URL will be:
 * http://example.com/upload/abc
 */


function resolveUrl(origin, link) {
  return new _urlParse.default(link, origin).toString();
}
/**
 * Calculate the start and end positions for the parts if an upload
 * is split into multiple parallel requests.
 *
 * @param {number} totalSize The byte size of the upload, which will be split.
 * @param {number} partCount The number in how many parts the upload will be split.
 * @param {string[]} previousUrls The upload URLs for previous parts.
 * @return {object[]}
 * @api private
 */


function splitSizeIntoParts(totalSize, partCount, previousUrls) {
  var partSize = Math.floor(totalSize / partCount);
  var parts = [];

  for (var i = 0; i < partCount; i++) {
    parts.push({
      start: partSize * i,
      end: partSize * (i + 1)
    });
  }

  parts[partCount - 1].end = totalSize; // Attach URLs from previous uploads, if available.

  if (previousUrls) {
    parts.forEach(function (part, index) {
      part.uploadUrl = previousUrls[index] || null;
    });
  }

  return parts;
}

BaseUpload.defaultOptions = defaultOptions;
var _default = BaseUpload;
exports.default = _default;
},{"./error":36,"./logger":37,"./uuid":40,"js-base64":15,"url-parse":41}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = uuid;

/**
 * Generate a UUID v4 based on random numbers. We intentioanlly use the less
 * secure Math.random function here since the more secure crypto.getRandomNumbers
 * is not available on all platforms.
 * This is not a problem for us since we use the UUID only for generating a
 * request ID, so we can correlate server logs to client errors.
 *
 * This function is taken from following site:
 * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 *
 * @return {string} The generate UUID
 */
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == "x" ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
},{}],41:[function(require,module,exports){
(function (global){(function (){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:[\\/]+/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?([\\/]{1,})?([\S\s]*)/i
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  address = trimLeft(address);

  var match = protocolre.exec(address)
    , protocol = match[1] ? match[1].toLowerCase() : ''
    , slashes = !!(match[2] && match[2].length >= 2)
    , rest =  match[2] && match[2].length === 1 ? '/' + match[3] : match[3];

  return {
    protocol: protocol,
    slashes: slashes,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && url.hostname) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":24,"requires-port":25}],42:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.WHATWGFetch = {})));
}(this, (function (exports) { 'use strict';

  var global =
    (typeof globalThis !== 'undefined' && globalThis) ||
    (typeof self !== 'undefined' && self) ||
    (typeof global !== 'undefined' && global);

  var support = {
    searchParams: 'URLSearchParams' in global,
    iterable: 'Symbol' in global && 'iterator' in Symbol,
    blob:
      'FileReader' in global &&
      'Blob' in global &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in global,
    arrayBuffer: 'ArrayBuffer' in global
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
      throw new TypeError('Invalid character in header field name: "' + name + '"')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      /*
        fetch-mock wraps the Response object in an ES6 Proxy to
        provide useful test harness features such as flush. However, on
        ES5 browsers without fetch or Proxy support pollyfills must be used;
        the proxy-pollyfill is unable to proxy an attribute unless it exists
        on the object before the Proxy is created. This change ensures
        Response.bodyUsed exists on the instance, while maintaining the
        semantic of setting Request.bodyUsed in the constructor before
        _initBody is called.
      */
      this.bodyUsed = this.bodyUsed;
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          var isConsumed = consumed(this);
          if (isConsumed) {
            return isConsumed
          }
          if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
            return Promise.resolve(
              this._bodyArrayBuffer.buffer.slice(
                this._bodyArrayBuffer.byteOffset,
                this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
              )
            )
          } else {
            return Promise.resolve(this._bodyArrayBuffer)
          }
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    if (!(this instanceof Request)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
    }

    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);

    if (this.method === 'GET' || this.method === 'HEAD') {
      if (options.cache === 'no-store' || options.cache === 'no-cache') {
        // Search for a '_' parameter in the query string
        var reParamSearch = /([?&])_=[^&]*/;
        if (reParamSearch.test(this.url)) {
          // If it already exists then set the value with the current time
          this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
        } else {
          // Otherwise add a new '_' parameter to the end with the current time
          var reQueryString = /\?/;
          this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
        }
      }
    }
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
    // https://github.com/github/fetch/issues/748
    // https://github.com/zloirock/core-js/issues/751
    preProcessedHeaders
      .split('\r')
      .map(function(header) {
        return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
      })
      .forEach(function(line) {
        var parts = line.split(':');
        var key = parts.shift().trim();
        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!(this instanceof Response)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
    }
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = global.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        setTimeout(function() {
          resolve(new Response(body, options));
        }, 0);
      };

      xhr.onerror = function() {
        setTimeout(function() {
          reject(new TypeError('Network request failed'));
        }, 0);
      };

      xhr.ontimeout = function() {
        setTimeout(function() {
          reject(new TypeError('Network request failed'));
        }, 0);
      };

      xhr.onabort = function() {
        setTimeout(function() {
          reject(new exports.DOMException('Aborted', 'AbortError'));
        }, 0);
      };

      function fixUrl(url) {
        try {
          return url === '' && global.location.href ? global.location.href : url
        } catch (e) {
          return url
        }
      }

      xhr.open(request.method, fixUrl(request.url), true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr) {
        if (support.blob) {
          xhr.responseType = 'blob';
        } else if (
          support.arrayBuffer &&
          request.headers.get('Content-Type') &&
          request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
        ) {
          xhr.responseType = 'arraybuffer';
        }
      }

      if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
        Object.getOwnPropertyNames(init.headers).forEach(function(name) {
          xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
        });
      } else {
        request.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });
      }

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!global.fetch) {
    global.fetch = fetch;
    global.Headers = Headers;
    global.Request = Request;
    global.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],43:[function(require,module,exports){
/* jshint node: true */
'use strict';

/**
  # wildcard

  Very simple wildcard matching, which is designed to provide the same
  functionality that is found in the
  [eve](https://github.com/adobe-webplatform/eve) eventing library.

  ## Usage

  It works with strings:

  <<< examples/strings.js

  Arrays:

  <<< examples/arrays.js

  Objects (matching against keys):

  <<< examples/objects.js

  While the library works in Node, if you are are looking for file-based
  wildcard matching then you should have a look at:

  <https://github.com/isaacs/node-glob>
**/

function WildcardMatcher(text, separator) {
  this.text = text = text || '';
  this.hasWild = ~text.indexOf('*');
  this.separator = separator;
  this.parts = text.split(separator);
}

WildcardMatcher.prototype.match = function(input) {
  var matches = true;
  var parts = this.parts;
  var ii;
  var partsCount = parts.length;
  var testParts;

  if (typeof input == 'string' || input instanceof String) {
    if (!this.hasWild && this.text != input) {
      matches = false;
    } else {
      testParts = (input || '').split(this.separator);
      for (ii = 0; matches && ii < partsCount; ii++) {
        if (parts[ii] === '*')  {
          continue;
        } else if (ii < testParts.length) {
          matches = parts[ii] === testParts[ii];
        } else {
          matches = false;
        }
      }

      // If matches, then return the component parts
      matches = matches && testParts;
    }
  }
  else if (typeof input.splice == 'function') {
    matches = [];

    for (ii = input.length; ii--; ) {
      if (this.match(input[ii])) {
        matches[matches.length] = input[ii];
      }
    }
  }
  else if (typeof input == 'object') {
    matches = {};

    for (var key in input) {
      if (this.match(key)) {
        matches[key] = input[key];
      }
    }
  }

  return matches;
};

module.exports = function(text, test, separator) {
  var matcher = new WildcardMatcher(text, separator || /[\/\.]/);
  if (typeof test != 'undefined') {
    return matcher.match(test);
  }

  return matcher;
};

},{}],44:[function(require,module,exports){
module.exports={
  "name": "@uppy/companion-client",
  "description": "Client library for communication with Companion. Intended for use in Uppy plugins.",
  "version": "1.10.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "companion",
    "provider"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "namespace-emitter": "^2.0.1",
    "qs-stringify": "^1.1.0",
    "url-parse": "^1.4.7"
  }
}

},{}],45:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var AuthError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(AuthError, _Error);

  function AuthError() {
    var _this;

    _this = _Error.call(this, 'Authorization required') || this;
    _this.name = 'AuthError';
    _this.isAuthError = true;
    return _this;
  }

  return AuthError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

module.exports = AuthError;

},{}],46:[function(require,module,exports){
'use strict';

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var qsStringify = require('qs-stringify');

var URL = require('url-parse');

var RequestClient = require('./RequestClient');

var tokenStorage = require('./tokenStorage');

var _getName = function _getName(id) {
  return id.split('-').map(function (s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }).join(' ');
};

module.exports = /*#__PURE__*/function (_RequestClient) {
  _inheritsLoose(Provider, _RequestClient);

  function Provider(uppy, opts) {
    var _this;

    _this = _RequestClient.call(this, uppy, opts) || this;
    _this.provider = opts.provider;
    _this.id = _this.provider;
    _this.name = _this.opts.name || _getName(_this.id);
    _this.pluginId = _this.opts.pluginId;
    _this.tokenKey = "companion-" + _this.pluginId + "-auth-token";
    _this.companionKeysParams = _this.opts.companionKeysParams;
    _this.preAuthToken = null;
    return _this;
  }

  var _proto = Provider.prototype;

  _proto.headers = function headers() {
    var _this2 = this;

    return Promise.all([_RequestClient.prototype.headers.call(this), this.getAuthToken()]).then(function (_ref) {
      var headers = _ref[0],
          token = _ref[1];
      var authHeaders = {};

      if (token) {
        authHeaders['uppy-auth-token'] = token;
      }

      if (_this2.companionKeysParams) {
        authHeaders['uppy-credentials-params'] = btoa(JSON.stringify({
          params: _this2.companionKeysParams
        }));
      }

      return _extends({}, headers, authHeaders);
    });
  };

  _proto.onReceiveResponse = function onReceiveResponse(response) {
    response = _RequestClient.prototype.onReceiveResponse.call(this, response);
    var plugin = this.uppy.getPlugin(this.pluginId);
    var oldAuthenticated = plugin.getPluginState().authenticated;
    var authenticated = oldAuthenticated ? response.status !== 401 : response.status < 400;
    plugin.setPluginState({
      authenticated: authenticated
    });
    return response;
  } // @todo(i.olarewaju) consider whether or not this method should be exposed
  ;

  _proto.setAuthToken = function setAuthToken(token) {
    return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, token);
  };

  _proto.getAuthToken = function getAuthToken() {
    return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey);
  };

  _proto.authUrl = function authUrl(queries) {
    if (queries === void 0) {
      queries = {};
    }

    if (this.preAuthToken) {
      queries.uppyPreAuthToken = this.preAuthToken;
    }

    var strigifiedQueries = qsStringify(queries);
    strigifiedQueries = strigifiedQueries ? "?" + strigifiedQueries : strigifiedQueries;
    return this.hostname + "/" + this.id + "/connect" + strigifiedQueries;
  };

  _proto.fileUrl = function fileUrl(id) {
    return this.hostname + "/" + this.id + "/get/" + id;
  };

  _proto.fetchPreAuthToken = function fetchPreAuthToken() {
    var _this3 = this;

    if (!this.companionKeysParams) {
      return Promise.resolve();
    }

    return this.post(this.id + "/preauth/", {
      params: this.companionKeysParams
    }).then(function (res) {
      _this3.preAuthToken = res.token;
    }).catch(function (err) {
      _this3.uppy.log("[CompanionClient] unable to fetch preAuthToken " + err, 'warning');
    });
  };

  _proto.list = function list(directory) {
    return this.get(this.id + "/list/" + (directory || ''));
  };

  _proto.logout = function logout() {
    var _this4 = this;

    return this.get(this.id + "/logout").then(function (response) {
      return Promise.all([response, _this4.uppy.getPlugin(_this4.pluginId).storage.removeItem(_this4.tokenKey)]);
    }).then(function (_ref2) {
      var response = _ref2[0];
      return response;
    });
  };

  Provider.initPlugin = function initPlugin(plugin, opts, defaultOpts) {
    plugin.type = 'acquirer';
    plugin.files = [];

    if (defaultOpts) {
      plugin.opts = _extends({}, defaultOpts, opts);
    }

    if (opts.serverUrl || opts.serverPattern) {
      throw new Error('`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`');
    }

    if (opts.companionAllowedHosts) {
      var pattern = opts.companionAllowedHosts; // validate companionAllowedHosts param

      if (typeof pattern !== 'string' && !Array.isArray(pattern) && !(pattern instanceof RegExp)) {
        throw new TypeError(plugin.id + ": the option \"companionAllowedHosts\" must be one of string, Array, RegExp");
      }

      plugin.opts.companionAllowedHosts = pattern;
    } else {
      // does not start with https://
      if (/^(?!https?:\/\/).*$/i.test(opts.companionUrl)) {
        plugin.opts.companionAllowedHosts = "https://" + opts.companionUrl.replace(/^\/\//, '');
      } else {
        plugin.opts.companionAllowedHosts = new URL(opts.companionUrl).origin;
      }
    }

    plugin.storage = plugin.opts.storage || tokenStorage;
  };

  return Provider;
}(RequestClient);

},{"./RequestClient":47,"./tokenStorage":51,"qs-stringify":23,"url-parse":41}],47:[function(require,module,exports){
'use strict';

var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AuthError = require('./AuthError');

var fetchWithNetworkError = require('./../../utils/lib/fetchWithNetworkError'); // Remove the trailing slash so we can always safely append /xyz.


function stripSlash(url) {
  return url.replace(/\/$/, '');
}

module.exports = (_temp = _class = /*#__PURE__*/function () {
  function RequestClient(uppy, opts) {
    this.uppy = uppy;
    this.opts = opts;
    this.onReceiveResponse = this.onReceiveResponse.bind(this);
    this.allowedHeaders = ['accept', 'content-type', 'uppy-auth-token'];
    this.preflightDone = false;
  }

  var _proto = RequestClient.prototype;

  _proto.headers = function headers() {
    var userHeaders = this.opts.companionHeaders || this.opts.serverHeaders || {};
    return Promise.resolve(_extends({}, this.defaultHeaders, userHeaders));
  };

  _proto._getPostResponseFunc = function _getPostResponseFunc(skip) {
    var _this = this;

    return function (response) {
      if (!skip) {
        return _this.onReceiveResponse(response);
      }

      return response;
    };
  };

  _proto.onReceiveResponse = function onReceiveResponse(response) {
    var state = this.uppy.getState();
    var companion = state.companion || {};
    var host = this.opts.companionUrl;
    var headers = response.headers; // Store the self-identified domain name for the Companion instance we just hit.

    if (headers.has('i-am') && headers.get('i-am') !== companion[host]) {
      var _extends2;

      this.uppy.setState({
        companion: _extends({}, companion, (_extends2 = {}, _extends2[host] = headers.get('i-am'), _extends2))
      });
    }

    return response;
  };

  _proto._getUrl = function _getUrl(url) {
    if (/^(https?:|)\/\//.test(url)) {
      return url;
    }

    return this.hostname + "/" + url;
  };

  _proto._json = function _json(res) {
    if (res.status === 401) {
      throw new AuthError();
    }

    if (res.status < 200 || res.status > 300) {
      var errMsg = "Failed request with status: " + res.status + ". " + res.statusText;
      return res.json().then(function (errData) {
        errMsg = errData.message ? errMsg + " message: " + errData.message : errMsg;
        errMsg = errData.requestId ? errMsg + " request-Id: " + errData.requestId : errMsg;
        throw new Error(errMsg);
      }).catch(function () {
        throw new Error(errMsg);
      });
    }

    return res.json();
  };

  _proto.preflight = function preflight(path) {
    var _this2 = this;

    if (this.preflightDone) {
      return Promise.resolve(this.allowedHeaders.slice());
    }

    return fetch(this._getUrl(path), {
      method: 'OPTIONS'
    }).then(function (response) {
      if (response.headers.has('access-control-allow-headers')) {
        _this2.allowedHeaders = response.headers.get('access-control-allow-headers').split(',').map(function (headerName) {
          return headerName.trim().toLowerCase();
        });
      }

      _this2.preflightDone = true;
      return _this2.allowedHeaders.slice();
    }).catch(function (err) {
      _this2.uppy.log("[CompanionClient] unable to make preflight request " + err, 'warning');

      _this2.preflightDone = true;
      return _this2.allowedHeaders.slice();
    });
  };

  _proto.preflightAndHeaders = function preflightAndHeaders(path) {
    var _this3 = this;

    return Promise.all([this.preflight(path), this.headers()]).then(function (_ref) {
      var allowedHeaders = _ref[0],
          headers = _ref[1];
      // filter to keep only allowed Headers
      Object.keys(headers).forEach(function (header) {
        if (allowedHeaders.indexOf(header.toLowerCase()) === -1) {
          _this3.uppy.log("[CompanionClient] excluding unallowed header " + header);

          delete headers[header];
        }
      });
      return headers;
    });
  };

  _proto.get = function get(path, skipPostResponse) {
    var _this4 = this;

    return this.preflightAndHeaders(path).then(function (headers) {
      return fetchWithNetworkError(_this4._getUrl(path), {
        method: 'get',
        headers: headers,
        credentials: _this4.opts.companionCookiesRule || 'same-origin'
      });
    }).then(this._getPostResponseFunc(skipPostResponse)).then(function (res) {
      return _this4._json(res);
    }).catch(function (err) {
      if (!err.isAuthError) {
        err.message = "Could not get " + _this4._getUrl(path) + ". " + err.message;
      }

      return Promise.reject(err);
    });
  };

  _proto.post = function post(path, data, skipPostResponse) {
    var _this5 = this;

    return this.preflightAndHeaders(path).then(function (headers) {
      return fetchWithNetworkError(_this5._getUrl(path), {
        method: 'post',
        headers: headers,
        credentials: _this5.opts.companionCookiesRule || 'same-origin',
        body: JSON.stringify(data)
      });
    }).then(this._getPostResponseFunc(skipPostResponse)).then(function (res) {
      return _this5._json(res);
    }).catch(function (err) {
      if (!err.isAuthError) {
        err.message = "Could not post " + _this5._getUrl(path) + ". " + err.message;
      }

      return Promise.reject(err);
    });
  };

  _proto.delete = function _delete(path, data, skipPostResponse) {
    var _this6 = this;

    return this.preflightAndHeaders(path).then(function (headers) {
      return fetchWithNetworkError(_this6.hostname + "/" + path, {
        method: 'delete',
        headers: headers,
        credentials: _this6.opts.companionCookiesRule || 'same-origin',
        body: data ? JSON.stringify(data) : null
      });
    }).then(this._getPostResponseFunc(skipPostResponse)).then(function (res) {
      return _this6._json(res);
    }).catch(function (err) {
      if (!err.isAuthError) {
        err.message = "Could not delete " + _this6._getUrl(path) + ". " + err.message;
      }

      return Promise.reject(err);
    });
  };

  _createClass(RequestClient, [{
    key: "hostname",
    get: function get() {
      var _this$uppy$getState = this.uppy.getState(),
          companion = _this$uppy$getState.companion;

      var host = this.opts.companionUrl;
      return stripSlash(companion && companion[host] ? companion[host] : host);
    }
  }, {
    key: "defaultHeaders",
    get: function get() {
      return {
        Accept: 'application/json',
        'Content-Type': 'application/json',
        'Uppy-Versions': "@uppy/companion-client=" + RequestClient.VERSION
      };
    }
  }]);

  return RequestClient;
}(), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":44,"./../../utils/lib/fetchWithNetworkError":171,"./AuthError":45}],48:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var RequestClient = require('./RequestClient');

var _getName = function _getName(id) {
  return id.split('-').map(function (s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }).join(' ');
};

module.exports = /*#__PURE__*/function (_RequestClient) {
  _inheritsLoose(SearchProvider, _RequestClient);

  function SearchProvider(uppy, opts) {
    var _this;

    _this = _RequestClient.call(this, uppy, opts) || this;
    _this.provider = opts.provider;
    _this.id = _this.provider;
    _this.name = _this.opts.name || _getName(_this.id);
    _this.pluginId = _this.opts.pluginId;
    return _this;
  }

  var _proto = SearchProvider.prototype;

  _proto.fileUrl = function fileUrl(id) {
    return this.hostname + "/search/" + this.id + "/get/" + id;
  };

  _proto.search = function search(text, queries) {
    queries = queries ? "&" + queries : '';
    return this.get("search/" + this.id + "/list?q=" + encodeURIComponent(text) + queries);
  };

  return SearchProvider;
}(RequestClient);

},{"./RequestClient":47}],49:[function(require,module,exports){
var ee = require('namespace-emitter');

module.exports = /*#__PURE__*/function () {
  function UppySocket(opts) {
    this.opts = opts;
    this._queued = [];
    this.isOpen = false;
    this.emitter = ee();
    this._handleMessage = this._handleMessage.bind(this);
    this.close = this.close.bind(this);
    this.emit = this.emit.bind(this);
    this.on = this.on.bind(this);
    this.once = this.once.bind(this);
    this.send = this.send.bind(this);

    if (!opts || opts.autoOpen !== false) {
      this.open();
    }
  }

  var _proto = UppySocket.prototype;

  _proto.open = function open() {
    var _this = this;

    this.socket = new WebSocket(this.opts.target);

    this.socket.onopen = function (e) {
      _this.isOpen = true;

      while (_this._queued.length > 0 && _this.isOpen) {
        var first = _this._queued[0];

        _this.send(first.action, first.payload);

        _this._queued = _this._queued.slice(1);
      }
    };

    this.socket.onclose = function (e) {
      _this.isOpen = false;
    };

    this.socket.onmessage = this._handleMessage;
  };

  _proto.close = function close() {
    if (this.socket) {
      this.socket.close();
    }
  };

  _proto.send = function send(action, payload) {
    // attach uuid
    if (!this.isOpen) {
      this._queued.push({
        action: action,
        payload: payload
      });

      return;
    }

    this.socket.send(JSON.stringify({
      action: action,
      payload: payload
    }));
  };

  _proto.on = function on(action, handler) {
    this.emitter.on(action, handler);
  };

  _proto.emit = function emit(action, payload) {
    this.emitter.emit(action, payload);
  };

  _proto.once = function once(action, handler) {
    this.emitter.once(action, handler);
  };

  _proto._handleMessage = function _handleMessage(e) {
    try {
      var message = JSON.parse(e.data);
      this.emit(message.action, message.payload);
    } catch (err) {
      console.log(err);
    }
  };

  return UppySocket;
}();

},{"namespace-emitter":21}],50:[function(require,module,exports){
'use strict';
/**
 * Manages communications with Companion
 */

var RequestClient = require('./RequestClient');

var Provider = require('./Provider');

var SearchProvider = require('./SearchProvider');

var Socket = require('./Socket');

module.exports = {
  RequestClient: RequestClient,
  Provider: Provider,
  SearchProvider: SearchProvider,
  Socket: Socket
};

},{"./Provider":46,"./RequestClient":47,"./SearchProvider":48,"./Socket":49}],51:[function(require,module,exports){
'use strict';
/**
 * This module serves as an Async wrapper for LocalStorage
 */

module.exports.setItem = function (key, value) {
  return new Promise(function (resolve) {
    localStorage.setItem(key, value);
    resolve();
  });
};

module.exports.getItem = function (key) {
  return Promise.resolve(localStorage.getItem(key));
};

module.exports.removeItem = function (key) {
  return new Promise(function (resolve) {
    localStorage.removeItem(key);
    resolve();
  });
};

},{}],52:[function(require,module,exports){
!function() {
    'use strict';
    function VNode() {}
    function h(nodeName, attributes) {
        var lastSimple, child, simple, i, children = EMPTY_CHILDREN;
        for (i = arguments.length; i-- > 2; ) stack.push(arguments[i]);
        if (attributes && null != attributes.children) {
            if (!stack.length) stack.push(attributes.children);
            delete attributes.children;
        }
        while (stack.length) if ((child = stack.pop()) && void 0 !== child.pop) for (i = child.length; i--; ) stack.push(child[i]); else {
            if ('boolean' == typeof child) child = null;
            if (simple = 'function' != typeof nodeName) if (null == child) child = ''; else if ('number' == typeof child) child = String(child); else if ('string' != typeof child) simple = !1;
            if (simple && lastSimple) children[children.length - 1] += child; else if (children === EMPTY_CHILDREN) children = [ child ]; else children.push(child);
            lastSimple = simple;
        }
        var p = new VNode();
        p.nodeName = nodeName;
        p.children = children;
        p.attributes = null == attributes ? void 0 : attributes;
        p.key = null == attributes ? void 0 : attributes.key;
        if (void 0 !== options.vnode) options.vnode(p);
        return p;
    }
    function extend(obj, props) {
        for (var i in props) obj[i] = props[i];
        return obj;
    }
    function cloneElement(vnode, props) {
        return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
    }
    function enqueueRender(component) {
        if (!component.__d && (component.__d = !0) && 1 == items.push(component)) (options.debounceRendering || defer)(rerender);
    }
    function rerender() {
        var p, list = items;
        items = [];
        while (p = list.pop()) if (p.__d) renderComponent(p);
    }
    function isSameNodeType(node, vnode, hydrating) {
        if ('string' == typeof vnode || 'number' == typeof vnode) return void 0 !== node.splitText;
        if ('string' == typeof vnode.nodeName) return !node._componentConstructor && isNamedNode(node, vnode.nodeName); else return hydrating || node._componentConstructor === vnode.nodeName;
    }
    function isNamedNode(node, nodeName) {
        return node.__n === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
    }
    function getNodeProps(vnode) {
        var props = extend({}, vnode.attributes);
        props.children = vnode.children;
        var defaultProps = vnode.nodeName.defaultProps;
        if (void 0 !== defaultProps) for (var i in defaultProps) if (void 0 === props[i]) props[i] = defaultProps[i];
        return props;
    }
    function createNode(nodeName, isSvg) {
        var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
        node.__n = nodeName;
        return node;
    }
    function removeNode(node) {
        var parentNode = node.parentNode;
        if (parentNode) parentNode.removeChild(node);
    }
    function setAccessor(node, name, old, value, isSvg) {
        if ('className' === name) name = 'class';
        if ('key' === name) ; else if ('ref' === name) {
            if (old) old(null);
            if (value) value(node);
        } else if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {
            if (!value || 'string' == typeof value || 'string' == typeof old) node.style.cssText = value || '';
            if (value && 'object' == typeof value) {
                if ('string' != typeof old) for (var i in old) if (!(i in value)) node.style[i] = '';
                for (var i in value) node.style[i] = 'number' == typeof value[i] && !1 === IS_NON_DIMENSIONAL.test(i) ? value[i] + 'px' : value[i];
            }
        } else if ('dangerouslySetInnerHTML' === name) {
            if (value) node.innerHTML = value.__html || '';
        } else if ('o' == name[0] && 'n' == name[1]) {
            var useCapture = name !== (name = name.replace(/Capture$/, ''));
            name = name.toLowerCase().substring(2);
            if (value) {
                if (!old) node.addEventListener(name, eventProxy, useCapture);
            } else node.removeEventListener(name, eventProxy, useCapture);
            (node.__l || (node.__l = {}))[name] = value;
        } else if ('list' !== name && 'type' !== name && !isSvg && name in node) {
            setProperty(node, name, null == value ? '' : value);
            if (null == value || !1 === value) node.removeAttribute(name);
        } else {
            var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));
            if (null == value || !1 === value) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase()); else node.removeAttribute(name); else if ('function' != typeof value) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value); else node.setAttribute(name, value);
        }
    }
    function setProperty(node, name, value) {
        try {
            node[name] = value;
        } catch (e) {}
    }
    function eventProxy(e) {
        return this.__l[e.type](options.event && options.event(e) || e);
    }
    function flushMounts() {
        var c;
        while (c = mounts.pop()) {
            if (options.afterMount) options.afterMount(c);
            if (c.componentDidMount) c.componentDidMount();
        }
    }
    function diff(dom, vnode, context, mountAll, parent, componentRoot) {
        if (!diffLevel++) {
            isSvgMode = null != parent && void 0 !== parent.ownerSVGElement;
            hydrating = null != dom && !('__preactattr_' in dom);
        }
        var ret = idiff(dom, vnode, context, mountAll, componentRoot);
        if (parent && ret.parentNode !== parent) parent.appendChild(ret);
        if (!--diffLevel) {
            hydrating = !1;
            if (!componentRoot) flushMounts();
        }
        return ret;
    }
    function idiff(dom, vnode, context, mountAll, componentRoot) {
        var out = dom, prevSvgMode = isSvgMode;
        if (null == vnode || 'boolean' == typeof vnode) vnode = '';
        if ('string' == typeof vnode || 'number' == typeof vnode) {
            if (dom && void 0 !== dom.splitText && dom.parentNode && (!dom._component || componentRoot)) {
                if (dom.nodeValue != vnode) dom.nodeValue = vnode;
            } else {
                out = document.createTextNode(vnode);
                if (dom) {
                    if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                    recollectNodeTree(dom, !0);
                }
            }
            out.__preactattr_ = !0;
            return out;
        }
        var vnodeName = vnode.nodeName;
        if ('function' == typeof vnodeName) return buildComponentFromVNode(dom, vnode, context, mountAll);
        isSvgMode = 'svg' === vnodeName ? !0 : 'foreignObject' === vnodeName ? !1 : isSvgMode;
        vnodeName = String(vnodeName);
        if (!dom || !isNamedNode(dom, vnodeName)) {
            out = createNode(vnodeName, isSvgMode);
            if (dom) {
                while (dom.firstChild) out.appendChild(dom.firstChild);
                if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                recollectNodeTree(dom, !0);
            }
        }
        var fc = out.firstChild, props = out.__preactattr_, vchildren = vnode.children;
        if (null == props) {
            props = out.__preactattr_ = {};
            for (var a = out.attributes, i = a.length; i--; ) props[a[i].name] = a[i].value;
        }
        if (!hydrating && vchildren && 1 === vchildren.length && 'string' == typeof vchildren[0] && null != fc && void 0 !== fc.splitText && null == fc.nextSibling) {
            if (fc.nodeValue != vchildren[0]) fc.nodeValue = vchildren[0];
        } else if (vchildren && vchildren.length || null != fc) innerDiffNode(out, vchildren, context, mountAll, hydrating || null != props.dangerouslySetInnerHTML);
        diffAttributes(out, vnode.attributes, props);
        isSvgMode = prevSvgMode;
        return out;
    }
    function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
        var j, c, f, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren ? vchildren.length : 0;
        if (0 !== len) for (var i = 0; i < len; i++) {
            var _child = originalChildren[i], props = _child.__preactattr_, key = vlen && props ? _child._component ? _child._component.__k : props.key : null;
            if (null != key) {
                keyedLen++;
                keyed[key] = _child;
            } else if (props || (void 0 !== _child.splitText ? isHydrating ? _child.nodeValue.trim() : !0 : isHydrating)) children[childrenLen++] = _child;
        }
        if (0 !== vlen) for (var i = 0; i < vlen; i++) {
            vchild = vchildren[i];
            child = null;
            var key = vchild.key;
            if (null != key) {
                if (keyedLen && void 0 !== keyed[key]) {
                    child = keyed[key];
                    keyed[key] = void 0;
                    keyedLen--;
                }
            } else if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) if (void 0 !== children[j] && isSameNodeType(c = children[j], vchild, isHydrating)) {
                child = c;
                children[j] = void 0;
                if (j === childrenLen - 1) childrenLen--;
                if (j === min) min++;
                break;
            }
            child = idiff(child, vchild, context, mountAll);
            f = originalChildren[i];
            if (child && child !== dom && child !== f) if (null == f) dom.appendChild(child); else if (child === f.nextSibling) removeNode(f); else dom.insertBefore(child, f);
        }
        if (keyedLen) for (var i in keyed) if (void 0 !== keyed[i]) recollectNodeTree(keyed[i], !1);
        while (min <= childrenLen) if (void 0 !== (child = children[childrenLen--])) recollectNodeTree(child, !1);
    }
    function recollectNodeTree(node, unmountOnly) {
        var component = node._component;
        if (component) unmountComponent(component); else {
            if (null != node.__preactattr_ && node.__preactattr_.ref) node.__preactattr_.ref(null);
            if (!1 === unmountOnly || null == node.__preactattr_) removeNode(node);
            removeChildren(node);
        }
    }
    function removeChildren(node) {
        node = node.lastChild;
        while (node) {
            var next = node.previousSibling;
            recollectNodeTree(node, !0);
            node = next;
        }
    }
    function diffAttributes(dom, attrs, old) {
        var name;
        for (name in old) if ((!attrs || null == attrs[name]) && null != old[name]) setAccessor(dom, name, old[name], old[name] = void 0, isSvgMode);
        for (name in attrs) if (!('children' === name || 'innerHTML' === name || name in old && attrs[name] === ('value' === name || 'checked' === name ? dom[name] : old[name]))) setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
    }
    function collectComponent(component) {
        var name = component.constructor.name;
        (components[name] || (components[name] = [])).push(component);
    }
    function createComponent(Ctor, props, context) {
        var inst, list = components[Ctor.name];
        if (Ctor.prototype && Ctor.prototype.render) {
            inst = new Ctor(props, context);
            Component.call(inst, props, context);
        } else {
            inst = new Component(props, context);
            inst.constructor = Ctor;
            inst.render = doRender;
        }
        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {
            inst.__b = list[i].__b;
            list.splice(i, 1);
            break;
        }
        return inst;
    }
    function doRender(props, state, context) {
        return this.constructor(props, context);
    }
    function setComponentProps(component, props, opts, context, mountAll) {
        if (!component.__x) {
            component.__x = !0;
            if (component.__r = props.ref) delete props.ref;
            if (component.__k = props.key) delete props.key;
            if (!component.base || mountAll) {
                if (component.componentWillMount) component.componentWillMount();
            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);
            if (context && context !== component.context) {
                if (!component.__c) component.__c = component.context;
                component.context = context;
            }
            if (!component.__p) component.__p = component.props;
            component.props = props;
            component.__x = !1;
            if (0 !== opts) if (1 === opts || !1 !== options.syncComponentUpdates || !component.base) renderComponent(component, 1, mountAll); else enqueueRender(component);
            if (component.__r) component.__r(component);
        }
    }
    function renderComponent(component, opts, mountAll, isChild) {
        if (!component.__x) {
            var rendered, inst, cbase, props = component.props, state = component.state, context = component.context, previousProps = component.__p || props, previousState = component.__s || state, previousContext = component.__c || context, isUpdate = component.base, nextBase = component.__b, initialBase = isUpdate || nextBase, initialChildComponent = component._component, skip = !1;
            if (isUpdate) {
                component.props = previousProps;
                component.state = previousState;
                component.context = previousContext;
                if (2 !== opts && component.shouldComponentUpdate && !1 === component.shouldComponentUpdate(props, state, context)) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);
                component.props = props;
                component.state = state;
                component.context = context;
            }
            component.__p = component.__s = component.__c = component.__b = null;
            component.__d = !1;
            if (!skip) {
                rendered = component.render(props, state, context);
                if (component.getChildContext) context = extend(extend({}, context), component.getChildContext());
                var toUnmount, base, childComponent = rendered && rendered.nodeName;
                if ('function' == typeof childComponent) {
                    var childProps = getNodeProps(rendered);
                    inst = initialChildComponent;
                    if (inst && inst.constructor === childComponent && childProps.key == inst.__k) setComponentProps(inst, childProps, 1, context, !1); else {
                        toUnmount = inst;
                        component._component = inst = createComponent(childComponent, childProps, context);
                        inst.__b = inst.__b || nextBase;
                        inst.__u = component;
                        setComponentProps(inst, childProps, 0, context, !1);
                        renderComponent(inst, 1, mountAll, !0);
                    }
                    base = inst.base;
                } else {
                    cbase = initialBase;
                    toUnmount = initialChildComponent;
                    if (toUnmount) cbase = component._component = null;
                    if (initialBase || 1 === opts) {
                        if (cbase) cbase._component = null;
                        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, !0);
                    }
                }
                if (initialBase && base !== initialBase && inst !== initialChildComponent) {
                    var baseParent = initialBase.parentNode;
                    if (baseParent && base !== baseParent) {
                        baseParent.replaceChild(base, initialBase);
                        if (!toUnmount) {
                            initialBase._component = null;
                            recollectNodeTree(initialBase, !1);
                        }
                    }
                }
                if (toUnmount) unmountComponent(toUnmount);
                component.base = base;
                if (base && !isChild) {
                    var componentRef = component, t = component;
                    while (t = t.__u) (componentRef = t).base = base;
                    base._component = componentRef;
                    base._componentConstructor = componentRef.constructor;
                }
            }
            if (!isUpdate || mountAll) mounts.unshift(component); else if (!skip) {
                if (component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);
                if (options.afterUpdate) options.afterUpdate(component);
            }
            if (null != component.__h) while (component.__h.length) component.__h.pop().call(component);
            if (!diffLevel && !isChild) flushMounts();
        }
    }
    function buildComponentFromVNode(dom, vnode, context, mountAll) {
        var c = dom && dom._component, originalComponent = c, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);
        while (c && !isOwner && (c = c.__u)) isOwner = c.constructor === vnode.nodeName;
        if (c && isOwner && (!mountAll || c._component)) {
            setComponentProps(c, props, 3, context, mountAll);
            dom = c.base;
        } else {
            if (originalComponent && !isDirectOwner) {
                unmountComponent(originalComponent);
                dom = oldDom = null;
            }
            c = createComponent(vnode.nodeName, props, context);
            if (dom && !c.__b) {
                c.__b = dom;
                oldDom = null;
            }
            setComponentProps(c, props, 1, context, mountAll);
            dom = c.base;
            if (oldDom && dom !== oldDom) {
                oldDom._component = null;
                recollectNodeTree(oldDom, !1);
            }
        }
        return dom;
    }
    function unmountComponent(component) {
        if (options.beforeUnmount) options.beforeUnmount(component);
        var base = component.base;
        component.__x = !0;
        if (component.componentWillUnmount) component.componentWillUnmount();
        component.base = null;
        var inner = component._component;
        if (inner) unmountComponent(inner); else if (base) {
            if (base.__preactattr_ && base.__preactattr_.ref) base.__preactattr_.ref(null);
            component.__b = base;
            removeNode(base);
            collectComponent(component);
            removeChildren(base);
        }
        if (component.__r) component.__r(null);
    }
    function Component(props, context) {
        this.__d = !0;
        this.context = context;
        this.props = props;
        this.state = this.state || {};
    }
    function render(vnode, parent, merge) {
        return diff(merge, vnode, {}, !1, parent, !1);
    }
    var options = {};
    var stack = [];
    var EMPTY_CHILDREN = [];
    var defer = 'function' == typeof Promise ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;
    var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    var items = [];
    var mounts = [];
    var diffLevel = 0;
    var isSvgMode = !1;
    var hydrating = !1;
    var components = {};
    extend(Component.prototype, {
        setState: function(state, callback) {
            var s = this.state;
            if (!this.__s) this.__s = extend({}, s);
            extend(s, 'function' == typeof state ? state(s, this.props) : state);
            if (callback) (this.__h = this.__h || []).push(callback);
            enqueueRender(this);
        },
        forceUpdate: function(callback) {
            if (callback) (this.__h = this.__h || []).push(callback);
            renderComponent(this, 2);
        },
        render: function() {}
    });
    var preact = {
        h: h,
        createElement: h,
        cloneElement: cloneElement,
        Component: Component,
        render: render,
        rerender: rerender,
        options: options
    };
    if ('undefined' != typeof module) module.exports = preact; else self.preact = preact;
}();

},{}],53:[function(require,module,exports){
module.exports={
  "name": "@uppy/core",
  "description": "Core module for the extensible JavaScript file upload widget with support for drag&drop, resumable uploads, previews, restrictions, file processing/encoding, remote providers like Instagram, Dropbox, Google Drive, S3 and more :dog:",
  "version": "1.19.2",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@transloadit/prettier-bytes": "0.0.7",
    "@uppy/store-default": "file:../store-default",
    "@uppy/utils": "file:../utils",
    "cuid": "^2.1.1",
    "lodash.throttle": "^4.1.1",
    "mime-match": "^1.0.2",
    "namespace-emitter": "^2.0.1",
    "preact": "8.2.9"
  }
}

},{}],54:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var preact = require('preact');

var findDOMElement = require('./../../utils/lib/findDOMElement');
/**
 * Defer a frequent call to the microtask queue.
 */


function debounce(fn) {
  var calling = null;
  var latestArgs = null;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    latestArgs = args;

    if (!calling) {
      calling = Promise.resolve().then(function () {
        calling = null; // At this point `args` may be different from the most
        // recent state, if multiple calls happened since this task
        // was queued. So we use the `latestArgs`, which definitely
        // is the most recent call.

        return fn.apply(void 0, latestArgs);
      });
    }

    return calling;
  };
}
/**
 * Boilerplate that all Plugins share - and should not be used
 * directly. It also shows which methods final plugins should implement/override,
 * this deciding on structure.
 *
 * @param {object} main Uppy core object
 * @param {object} object with plugin options
 * @returns {Array|string} files or success/fail message
 */


module.exports = /*#__PURE__*/function () {
  function Plugin(uppy, opts) {
    this.uppy = uppy;
    this.opts = opts || {};
    this.update = this.update.bind(this);
    this.mount = this.mount.bind(this);
    this.install = this.install.bind(this);
    this.uninstall = this.uninstall.bind(this);
  }

  var _proto = Plugin.prototype;

  _proto.getPluginState = function getPluginState() {
    var _this$uppy$getState = this.uppy.getState(),
        plugins = _this$uppy$getState.plugins;

    return plugins[this.id] || {};
  };

  _proto.setPluginState = function setPluginState(update) {
    var _extends2;

    var _this$uppy$getState2 = this.uppy.getState(),
        plugins = _this$uppy$getState2.plugins;

    this.uppy.setState({
      plugins: _extends({}, plugins, (_extends2 = {}, _extends2[this.id] = _extends({}, plugins[this.id], update), _extends2))
    });
  };

  _proto.setOptions = function setOptions(newOpts) {
    this.opts = _extends({}, this.opts, newOpts);
    this.setPluginState(); // so that UI re-renders with new options
  };

  _proto.update = function update(state) {
    if (typeof this.el === 'undefined') {
      return;
    }

    if (this._updateUI) {
      this._updateUI(state);
    }
  } // Called after every state update, after everything's mounted. Debounced.
  ;

  _proto.afterUpdate = function afterUpdate() {}
  /**
   * Called when plugin is mounted, whether in DOM or into another plugin.
   * Needed because sometimes plugins are mounted separately/after `install`,
   * so this.el and this.parent might not be available in `install`.
   * This is the case with @uppy/react plugins, for example.
   */
  ;

  _proto.onMount = function onMount() {}
  /**
   * Check if supplied `target` is a DOM element or an `object`.
   * If it’s an object — target is a plugin, and we search `plugins`
   * for a plugin with same name and return its target.
   *
   * @param {string|object} target
   *
   */
  ;

  _proto.mount = function mount(target, plugin) {
    var _this = this;

    var callerPluginName = plugin.id;
    var targetElement = findDOMElement(target);

    if (targetElement) {
      this.isTargetDOMEl = true; // API for plugins that require a synchronous rerender.

      this.rerender = function (state) {
        // plugin could be removed, but this.rerender is debounced below,
        // so it could still be called even after uppy.removePlugin or uppy.close
        // hence the check
        if (!_this.uppy.getPlugin(_this.id)) return;
        _this.el = preact.render(_this.render(state), targetElement, _this.el);

        _this.afterUpdate();
      };

      this._updateUI = debounce(this.rerender);
      this.uppy.log("Installing " + callerPluginName + " to a DOM element '" + target + "'"); // clear everything inside the target container

      if (this.opts.replaceTargetContent) {
        targetElement.innerHTML = '';
      }

      this.el = preact.render(this.render(this.uppy.getState()), targetElement);
      this.onMount();
      return this.el;
    }

    var targetPlugin;

    if (typeof target === 'object' && target instanceof Plugin) {
      // Targeting a plugin *instance*
      targetPlugin = target;
    } else if (typeof target === 'function') {
      // Targeting a plugin type
      var Target = target; // Find the target plugin instance.

      this.uppy.iteratePlugins(function (plugin) {
        if (plugin instanceof Target) {
          targetPlugin = plugin;
          return false;
        }
      });
    }

    if (targetPlugin) {
      this.uppy.log("Installing " + callerPluginName + " to " + targetPlugin.id);
      this.parent = targetPlugin;
      this.el = targetPlugin.addTarget(plugin);
      this.onMount();
      return this.el;
    }

    this.uppy.log("Not installing " + callerPluginName);
    var message = "Invalid target option given to " + callerPluginName + ".";

    if (typeof target === 'function') {
      message += ' The given target is not a Plugin class. ' + 'Please check that you\'re not specifying a React Component instead of a plugin. ' + 'If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: ' + 'run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly.';
    } else {
      message += 'If you meant to target an HTML element, please make sure that the element exists. ' + 'Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. ' + '(see https://github.com/transloadit/uppy/issues/1042)\n\n' + 'If you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.';
    }

    throw new Error(message);
  };

  _proto.render = function render(state) {
    throw new Error('Extend the render method to add your plugin to a DOM element');
  };

  _proto.addTarget = function addTarget(plugin) {
    throw new Error('Extend the addTarget method to add your plugin to another plugin\'s target');
  };

  _proto.unmount = function unmount() {
    if (this.isTargetDOMEl && this.el && this.el.parentNode) {
      this.el.parentNode.removeChild(this.el);
    }
  };

  _proto.install = function install() {};

  _proto.uninstall = function uninstall() {
    this.unmount();
  };

  return Plugin;
}();

},{"./../../utils/lib/findDOMElement":173,"preact":52}],55:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* global AggregateError */
var Translator = require('./../../utils/lib/Translator');

var ee = require('namespace-emitter');

var cuid = require('cuid');

var throttle = require('lodash.throttle');

var prettierBytes = require('@transloadit/prettier-bytes');

var match = require('mime-match');

var DefaultStore = require('./../../store-default');

var getFileType = require('./../../utils/lib/getFileType');

var getFileNameAndExtension = require('./../../utils/lib/getFileNameAndExtension');

var generateFileID = require('./../../utils/lib/generateFileID');

var findIndex = require('./../../utils/lib/findIndex');

var supportsUploadProgress = require('./supportsUploadProgress');

var _require = require('./loggers'),
    justErrorsLogger = _require.justErrorsLogger,
    debugLogger = _require.debugLogger;

var Plugin = require('./Plugin');

var _require2 = require('../package.json'),
    version = _require2.version; // Exported from here.


var RestrictionError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(RestrictionError, _Error);

  function RestrictionError() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Error.call.apply(_Error, [this].concat(args)) || this;
    _this.isRestriction = true;
    return _this;
  }

  return RestrictionError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Uppy Core module.
 * Manages plugins, state updates, acts as an event bus,
 * adds/removes files and metadata.
 */


var Uppy = /*#__PURE__*/function () {
  /**
   * Instantiate Uppy
   *
   * @param {object} opts — Uppy options
   */
  function Uppy(opts) {
    var _this2 = this;

    this.defaultLocale = {
      strings: {
        addBulkFilesFailed: {
          0: 'Failed to add %{smart_count} file due to an internal error',
          1: 'Failed to add %{smart_count} files due to internal errors'
        },
        youCanOnlyUploadX: {
          0: 'You can only upload %{smart_count} file',
          1: 'You can only upload %{smart_count} files'
        },
        youHaveToAtLeastSelectX: {
          0: 'You have to select at least %{smart_count} file',
          1: 'You have to select at least %{smart_count} files'
        },
        // The default `exceedsSize2` string only combines the `exceedsSize` string (%{backwardsCompat}) with the size.
        // Locales can override `exceedsSize2` to specify a different word order. This is for backwards compat with
        // Uppy 1.9.x and below which did a naive concatenation of `exceedsSize2 + size` instead of using a locale-specific
        // substitution.
        // TODO: In 2.0 `exceedsSize2` should be removed in and `exceedsSize` updated to use substitution.
        exceedsSize2: '%{backwardsCompat} %{size}',
        exceedsSize: '%{file} exceeds maximum allowed size of',
        inferiorSize: 'This file is smaller than the allowed size of %{size}',
        youCanOnlyUploadFileTypes: 'You can only upload: %{types}',
        noNewAlreadyUploading: 'Cannot add new files: already uploading',
        noDuplicates: 'Cannot add the duplicate file \'%{fileName}\', it already exists',
        companionError: 'Connection with Companion failed',
        companionUnauthorizeHint: 'To unauthorize to your %{provider} account, please go to %{url}',
        failedToUpload: 'Failed to upload %{file}',
        noInternetConnection: 'No Internet connection',
        connectedToInternet: 'Connected to the Internet',
        // Strings for remote providers
        noFilesFound: 'You have no files or folders here',
        selectX: {
          0: 'Select %{smart_count}',
          1: 'Select %{smart_count}'
        },
        selectAllFilesFromFolderNamed: 'Select all files from folder %{name}',
        unselectAllFilesFromFolderNamed: 'Unselect all files from folder %{name}',
        selectFileNamed: 'Select file %{name}',
        unselectFileNamed: 'Unselect file %{name}',
        openFolderNamed: 'Open folder %{name}',
        cancel: 'Cancel',
        logOut: 'Log out',
        filter: 'Filter',
        resetFilter: 'Reset filter',
        loading: 'Loading...',
        authenticateWithTitle: 'Please authenticate with %{pluginName} to select files',
        authenticateWith: 'Connect to %{pluginName}',
        searchImages: 'Search for images',
        enterTextToSearch: 'Enter text to search for images',
        backToSearch: 'Back to Search',
        emptyFolderAdded: 'No files were added from empty folder',
        folderAdded: {
          0: 'Added %{smart_count} file from %{folder}',
          1: 'Added %{smart_count} files from %{folder}'
        }
      }
    };
    var defaultOptions = {
      id: 'uppy',
      autoProceed: false,
      allowMultipleUploads: true,
      debug: false,
      restrictions: {
        maxFileSize: null,
        minFileSize: null,
        maxTotalFileSize: null,
        maxNumberOfFiles: null,
        minNumberOfFiles: null,
        allowedFileTypes: null
      },
      meta: {},
      onBeforeFileAdded: function onBeforeFileAdded(currentFile) {
        return currentFile;
      },
      onBeforeUpload: function onBeforeUpload(files) {
        return files;
      },
      store: DefaultStore(),
      logger: justErrorsLogger,
      infoTimeout: 5000
    }; // Merge default options with the ones set by user,
    // making sure to merge restrictions too

    this.opts = _extends({}, defaultOptions, opts, {
      restrictions: _extends({}, defaultOptions.restrictions, opts && opts.restrictions)
    }); // Support debug: true for backwards-compatability, unless logger is set in opts
    // opts instead of this.opts to avoid comparing objects — we set logger: justErrorsLogger in defaultOptions

    if (opts && opts.logger && opts.debug) {
      this.log('You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.', 'warning');
    } else if (opts && opts.debug) {
      this.opts.logger = debugLogger;
    }

    this.log("Using Core v" + this.constructor.VERSION);

    if (this.opts.restrictions.allowedFileTypes && this.opts.restrictions.allowedFileTypes !== null && !Array.isArray(this.opts.restrictions.allowedFileTypes)) {
      throw new TypeError('`restrictions.allowedFileTypes` must be an array');
    }

    this.i18nInit(); // Container for different types of plugins

    this.plugins = {};
    this.getState = this.getState.bind(this);
    this.getPlugin = this.getPlugin.bind(this);
    this.setFileMeta = this.setFileMeta.bind(this);
    this.setFileState = this.setFileState.bind(this);
    this.log = this.log.bind(this);
    this.info = this.info.bind(this);
    this.hideInfo = this.hideInfo.bind(this);
    this.addFile = this.addFile.bind(this);
    this.removeFile = this.removeFile.bind(this);
    this.pauseResume = this.pauseResume.bind(this);
    this.validateRestrictions = this.validateRestrictions.bind(this); // ___Why throttle at 500ms?
    //    - We must throttle at >250ms for superfocus in Dashboard to work well
    //    (because animation takes 0.25s, and we want to wait for all animations to be over before refocusing).
    //    [Practical Check]: if thottle is at 100ms, then if you are uploading a file,
    //    and click 'ADD MORE FILES', - focus won't activate in Firefox.
    //    - We must throttle at around >500ms to avoid performance lags.
    //    [Practical Check] Firefox, try to upload a big file for a prolonged period of time. Laptop will start to heat up.

    this.calculateProgress = throttle(this.calculateProgress.bind(this), 500, {
      leading: true,
      trailing: true
    });
    this.updateOnlineStatus = this.updateOnlineStatus.bind(this);
    this.resetProgress = this.resetProgress.bind(this);
    this.pauseAll = this.pauseAll.bind(this);
    this.resumeAll = this.resumeAll.bind(this);
    this.retryAll = this.retryAll.bind(this);
    this.cancelAll = this.cancelAll.bind(this);
    this.retryUpload = this.retryUpload.bind(this);
    this.upload = this.upload.bind(this);
    this.emitter = ee();
    this.on = this.on.bind(this);
    this.off = this.off.bind(this);
    this.once = this.emitter.once.bind(this.emitter);
    this.emit = this.emitter.emit.bind(this.emitter);
    this.preProcessors = [];
    this.uploaders = [];
    this.postProcessors = [];
    this.store = this.opts.store;
    this.setState({
      plugins: {},
      files: {},
      currentUploads: {},
      allowNewUpload: true,
      capabilities: {
        uploadProgress: supportsUploadProgress(),
        individualCancellation: true,
        resumableUploads: false
      },
      totalProgress: 0,
      meta: _extends({}, this.opts.meta),
      info: {
        isHidden: true,
        type: 'info',
        message: ''
      },
      recoveredState: null
    });
    this.storeUnsubscribe = this.store.subscribe(function (prevState, nextState, patch) {
      _this2.emit('state-update', prevState, nextState, patch);

      _this2.updateAll(nextState);
    }); // Exposing uppy object on window for debugging and testing

    if (this.opts.debug && typeof window !== 'undefined') {
      window[this.opts.id] = this;
    }

    this.addListeners(); // Re-enable if we’ll need some capabilities on boot, like isMobileDevice
    // this._setCapabilities()
  } // _setCapabilities = () => {
  //   const capabilities = {
  //     isMobileDevice: isMobileDevice()
  //   }
  //   this.setState({
  //     ...this.getState().capabilities,
  //     capabilities
  //   })
  // }


  var _proto = Uppy.prototype;

  _proto.on = function on(event, callback) {
    this.emitter.on(event, callback);
    return this;
  };

  _proto.off = function off(event, callback) {
    this.emitter.off(event, callback);
    return this;
  }
  /**
   * Iterate on all plugins and run `update` on them.
   * Called each time state changes.
   *
   */
  ;

  _proto.updateAll = function updateAll(state) {
    this.iteratePlugins(function (plugin) {
      plugin.update(state);
    });
  }
  /**
   * Updates state with a patch
   *
   * @param {object} patch {foo: 'bar'}
   */
  ;

  _proto.setState = function setState(patch) {
    this.store.setState(patch);
  }
  /**
   * Returns current state.
   *
   * @returns {object}
   */
  ;

  _proto.getState = function getState() {
    return this.store.getState();
  }
  /**
   * Back compat for when uppy.state is used instead of uppy.getState().
   */
  ;

  /**
   * Shorthand to set state for a specific file.
   */
  _proto.setFileState = function setFileState(fileID, state) {
    var _extends2;

    if (!this.getState().files[fileID]) {
      throw new Error("Can\u2019t set state for " + fileID + " (the file could have been removed)");
    }

    this.setState({
      files: _extends({}, this.getState().files, (_extends2 = {}, _extends2[fileID] = _extends({}, this.getState().files[fileID], state), _extends2))
    });
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.opts.locale]);
    this.locale = this.translator.locale;
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
  };

  _proto.setOptions = function setOptions(newOpts) {
    this.opts = _extends({}, this.opts, newOpts, {
      restrictions: _extends({}, this.opts.restrictions, newOpts && newOpts.restrictions)
    });

    if (newOpts.meta) {
      this.setMeta(newOpts.meta);
    }

    this.i18nInit();

    if (newOpts.locale) {
      this.iteratePlugins(function (plugin) {
        plugin.setOptions();
      });
    } // Note: this is not the preact `setState`, it's an internal function that has the same name.


    this.setState(); // so that UI re-renders with new options
  };

  _proto.resetProgress = function resetProgress() {
    var defaultProgress = {
      percentage: 0,
      bytesUploaded: 0,
      uploadComplete: false,
      uploadStarted: null
    };

    var files = _extends({}, this.getState().files);

    var updatedFiles = {};
    Object.keys(files).forEach(function (fileID) {
      var updatedFile = _extends({}, files[fileID]);

      updatedFile.progress = _extends({}, updatedFile.progress, defaultProgress);
      updatedFiles[fileID] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      totalProgress: 0
    });
    this.emit('reset-progress');
  };

  _proto.addPreProcessor = function addPreProcessor(fn) {
    this.preProcessors.push(fn);
  };

  _proto.removePreProcessor = function removePreProcessor(fn) {
    var i = this.preProcessors.indexOf(fn);

    if (i !== -1) {
      this.preProcessors.splice(i, 1);
    }
  };

  _proto.addPostProcessor = function addPostProcessor(fn) {
    this.postProcessors.push(fn);
  };

  _proto.removePostProcessor = function removePostProcessor(fn) {
    var i = this.postProcessors.indexOf(fn);

    if (i !== -1) {
      this.postProcessors.splice(i, 1);
    }
  };

  _proto.addUploader = function addUploader(fn) {
    this.uploaders.push(fn);
  };

  _proto.removeUploader = function removeUploader(fn) {
    var i = this.uploaders.indexOf(fn);

    if (i !== -1) {
      this.uploaders.splice(i, 1);
    }
  };

  _proto.setMeta = function setMeta(data) {
    var updatedMeta = _extends({}, this.getState().meta, data);

    var updatedFiles = _extends({}, this.getState().files);

    Object.keys(updatedFiles).forEach(function (fileID) {
      updatedFiles[fileID] = _extends({}, updatedFiles[fileID], {
        meta: _extends({}, updatedFiles[fileID].meta, data)
      });
    });
    this.log('Adding metadata:');
    this.log(data);
    this.setState({
      meta: updatedMeta,
      files: updatedFiles
    });
  };

  _proto.setFileMeta = function setFileMeta(fileID, data) {
    var updatedFiles = _extends({}, this.getState().files);

    if (!updatedFiles[fileID]) {
      this.log('Was trying to set metadata for a file that has been removed: ', fileID);
      return;
    }

    var newMeta = _extends({}, updatedFiles[fileID].meta, data);

    updatedFiles[fileID] = _extends({}, updatedFiles[fileID], {
      meta: newMeta
    });
    this.setState({
      files: updatedFiles
    });
  }
  /**
   * Get a file object.
   *
   * @param {string} fileID The ID of the file object to return.
   */
  ;

  _proto.getFile = function getFile(fileID) {
    return this.getState().files[fileID];
  }
  /**
   * Get all files in an array.
   */
  ;

  _proto.getFiles = function getFiles() {
    var _this$getState = this.getState(),
        files = _this$getState.files;

    return Object.keys(files).map(function (fileID) {
      return files[fileID];
    });
  }
  /**
   * A public wrapper for _checkRestrictions — checks if a file passes a set of restrictions.
   * For use in UI pluigins (like Providers), to disallow selecting files that won’t pass restrictions.
   *
   * @param {object} file object to check
   * @param {Array} [files] array to check maxNumberOfFiles and maxTotalFileSize
   * @returns {object} { result: true/false, reason: why file didn’t pass restrictions }
   */
  ;

  _proto.validateRestrictions = function validateRestrictions(file, files) {
    try {
      this.checkRestrictions(file, files);
      return {
        result: true
      };
    } catch (err) {
      return {
        result: false,
        reason: err.message
      };
    }
  }
  /**
   * Check if file passes a set of restrictions set in options: maxFileSize, minFileSize,
   * maxNumberOfFiles and allowedFileTypes.
   *
   * @param {object} file object to check
   * @param {Array} [files] array to check maxNumberOfFiles and maxTotalFileSize
   * @private
   */
  ;

  _proto.checkRestrictions = function checkRestrictions(file, files) {
    if (files === void 0) {
      files = this.getFiles();
    }

    var _this$opts$restrictio = this.opts.restrictions,
        maxFileSize = _this$opts$restrictio.maxFileSize,
        minFileSize = _this$opts$restrictio.minFileSize,
        maxTotalFileSize = _this$opts$restrictio.maxTotalFileSize,
        maxNumberOfFiles = _this$opts$restrictio.maxNumberOfFiles,
        allowedFileTypes = _this$opts$restrictio.allowedFileTypes;

    if (maxNumberOfFiles) {
      if (files.length + 1 > maxNumberOfFiles) {
        throw new RestrictionError("" + this.i18n('youCanOnlyUploadX', {
          smart_count: maxNumberOfFiles
        }));
      }
    }

    if (allowedFileTypes) {
      var isCorrectFileType = allowedFileTypes.some(function (type) {
        // check if this is a mime-type
        if (type.indexOf('/') > -1) {
          if (!file.type) return false;
          return match(file.type.replace(/;.*?$/, ''), type);
        } // otherwise this is likely an extension


        if (type[0] === '.' && file.extension) {
          return file.extension.toLowerCase() === type.substr(1).toLowerCase();
        }

        return false;
      });

      if (!isCorrectFileType) {
        var allowedFileTypesString = allowedFileTypes.join(', ');
        throw new RestrictionError(this.i18n('youCanOnlyUploadFileTypes', {
          types: allowedFileTypesString
        }));
      }
    } // We can't check maxTotalFileSize if the size is unknown.


    if (maxTotalFileSize && file.size != null) {
      var totalFilesSize = 0;
      totalFilesSize += file.size;
      files.forEach(function (f) {
        totalFilesSize += f.size;
      });

      if (totalFilesSize > maxTotalFileSize) {
        throw new RestrictionError(this.i18n('exceedsSize2', {
          backwardsCompat: this.i18n('exceedsSize'),
          size: prettierBytes(maxTotalFileSize),
          file: file.name
        }));
      }
    } // We can't check maxFileSize if the size is unknown.


    if (maxFileSize && file.size != null) {
      if (file.size > maxFileSize) {
        throw new RestrictionError(this.i18n('exceedsSize2', {
          backwardsCompat: this.i18n('exceedsSize'),
          size: prettierBytes(maxFileSize),
          file: file.name
        }));
      }
    } // We can't check minFileSize if the size is unknown.


    if (minFileSize && file.size != null) {
      if (file.size < minFileSize) {
        throw new RestrictionError(this.i18n('inferiorSize', {
          size: prettierBytes(minFileSize)
        }));
      }
    }
  }
  /**
   * Check if minNumberOfFiles restriction is reached before uploading.
   *
   * @private
   */
  ;

  _proto.checkMinNumberOfFiles = function checkMinNumberOfFiles(files) {
    var minNumberOfFiles = this.opts.restrictions.minNumberOfFiles;

    if (Object.keys(files).length < minNumberOfFiles) {
      throw new RestrictionError("" + this.i18n('youHaveToAtLeastSelectX', {
        smart_count: minNumberOfFiles
      }));
    }
  }
  /**
   * Logs an error, sets Informer message, then throws the error.
   * Emits a 'restriction-failed' event if it’s a restriction error
   *
   * @param {object | string} err — Error object or plain string message
   * @param {object} [options]
   * @param {boolean} [options.showInformer=true] — Sometimes developer might want to show Informer manually
   * @param {object} [options.file=null] — File object used to emit the restriction error
   * @param {boolean} [options.throwErr=true] — Errors shouldn’t be thrown, for example, in `upload-error` event
   * @private
   */
  ;

  _proto.showOrLogErrorAndThrow = function showOrLogErrorAndThrow(err, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$showInformer = _ref.showInformer,
        showInformer = _ref$showInformer === void 0 ? true : _ref$showInformer,
        _ref$file = _ref.file,
        file = _ref$file === void 0 ? null : _ref$file,
        _ref$throwErr = _ref.throwErr,
        throwErr = _ref$throwErr === void 0 ? true : _ref$throwErr;

    var message = typeof err === 'object' ? err.message : err;
    var details = typeof err === 'object' && err.details ? err.details : ''; // Restriction errors should be logged, but not as errors,
    // as they are expected and shown in the UI.

    var logMessageWithDetails = message;

    if (details) {
      logMessageWithDetails += " " + details;
    }

    if (err.isRestriction) {
      this.log(logMessageWithDetails);
      this.emit('restriction-failed', file, err);
    } else {
      this.log(logMessageWithDetails, 'error');
    } // Sometimes informer has to be shown manually by the developer,
    // for example, in `onBeforeFileAdded`.


    if (showInformer) {
      this.info({
        message: message,
        details: details
      }, 'error', this.opts.infoTimeout);
    }

    if (throwErr) {
      throw typeof err === 'object' ? err : new Error(err);
    }
  };

  _proto.assertNewUploadAllowed = function assertNewUploadAllowed(file) {
    var _this$getState2 = this.getState(),
        allowNewUpload = _this$getState2.allowNewUpload;

    if (allowNewUpload === false) {
      this.showOrLogErrorAndThrow(new RestrictionError(this.i18n('noNewAlreadyUploading')), {
        file: file
      });
    }
  }
  /**
   * Create a file state object based on user-provided `addFile()` options.
   *
   * Note this is extremely side-effectful and should only be done when a file state object will be added to state immediately afterward!
   *
   * The `files` value is passed in because it may be updated by the caller without updating the store.
   */
  ;

  _proto.checkAndCreateFileStateObject = function checkAndCreateFileStateObject(files, f) {
    var fileType = getFileType(f);
    var file = f;
    file.type = fileType;
    var onBeforeFileAddedResult = this.opts.onBeforeFileAdded(file, files);

    if (onBeforeFileAddedResult === false) {
      // Don’t show UI info for this error, as it should be done by the developer
      this.showOrLogErrorAndThrow(new RestrictionError('Cannot add the file because onBeforeFileAdded returned false.'), {
        showInformer: false,
        file: file
      });
    }

    if (typeof onBeforeFileAddedResult === 'object' && onBeforeFileAddedResult) {
      file = onBeforeFileAddedResult;
    }

    var fileName;

    if (file.name) {
      fileName = file.name;
    } else if (fileType.split('/')[0] === 'image') {
      fileName = fileType.split('/')[0] + "." + fileType.split('/')[1];
    } else {
      fileName = 'noname';
    }

    var fileExtension = getFileNameAndExtension(fileName).extension;
    var isRemote = file.isRemote || false;
    var fileID = generateFileID(file);

    if (files[fileID] && !files[fileID].isGhost) {
      this.showOrLogErrorAndThrow(new RestrictionError(this.i18n('noDuplicates', {
        fileName: fileName
      })), {
        file: file
      });
    }

    var meta = file.meta || {};
    meta.name = fileName;
    meta.type = fileType; // `null` means the size is unknown.

    var size = Number.isFinite(file.data.size) ? file.data.size : null;
    var newFile = {
      source: file.source || '',
      id: fileID,
      name: fileName,
      extension: fileExtension || '',
      meta: _extends({}, this.getState().meta, meta),
      type: fileType,
      data: file.data,
      progress: {
        percentage: 0,
        bytesUploaded: 0,
        bytesTotal: size,
        uploadComplete: false,
        uploadStarted: null
      },
      size: size,
      isRemote: isRemote,
      remote: file.remote || '',
      preview: file.preview
    };

    try {
      var filesArray = Object.keys(files).map(function (i) {
        return files[i];
      });
      this.checkRestrictions(newFile, filesArray);
    } catch (err) {
      this.showOrLogErrorAndThrow(err, {
        file: newFile
      });
    }

    return newFile;
  } // Schedule an upload if `autoProceed` is enabled.
  ;

  _proto.startIfAutoProceed = function startIfAutoProceed() {
    var _this3 = this;

    if (this.opts.autoProceed && !this.scheduledAutoProceed) {
      this.scheduledAutoProceed = setTimeout(function () {
        _this3.scheduledAutoProceed = null;

        _this3.upload().catch(function (err) {
          if (!err.isRestriction) {
            _this3.log(err.stack || err.message || err);
          }
        });
      }, 4);
    }
  }
  /**
   * Add a new file to `state.files`. This will run `onBeforeFileAdded`,
   * try to guess file type in a clever way, check file against restrictions,
   * and start an upload if `autoProceed === true`.
   *
   * @param {object} file object to add
   * @returns {string} id for the added file
   */
  ;

  _proto.addFile = function addFile(file) {
    var _extends3;

    this.assertNewUploadAllowed(file);

    var _this$getState3 = this.getState(),
        files = _this$getState3.files;

    var newFile = this.checkAndCreateFileStateObject(files, file); // Users are asked to re-select recovered files without data,
    // and to keep the progress, meta and everthing else, we only replace said data

    if (files[newFile.id] && files[newFile.id].isGhost) {
      newFile = _extends({}, files[newFile.id], {
        data: file.data,
        isGhost: false
      });
      this.log("Replaced the blob in the restored ghost file: " + newFile.name + ", " + newFile.id);
    }

    this.setState({
      files: _extends({}, files, (_extends3 = {}, _extends3[newFile.id] = newFile, _extends3))
    });
    this.emit('file-added', newFile);
    this.emit('files-added', [newFile]);
    this.log("Added file: " + newFile.name + ", " + newFile.id + ", mime type: " + newFile.type);
    this.startIfAutoProceed();
    return newFile.id;
  }
  /**
   * Add multiple files to `state.files`. See the `addFile()` documentation.
   *
   * If an error occurs while adding a file, it is logged and the user is notified.
   * This is good for UI plugins, but not for programmatic use.
   * Programmatic users should usually still use `addFile()` on individual files.
   */
  ;

  _proto.addFiles = function addFiles(fileDescriptors) {
    var _this4 = this;

    this.assertNewUploadAllowed(); // create a copy of the files object only once

    var files = _extends({}, this.getState().files);

    var newFiles = [];
    var errors = [];

    for (var i = 0; i < fileDescriptors.length; i++) {
      try {
        var newFile = this.checkAndCreateFileStateObject(files, fileDescriptors[i]); // Users are asked to re-select recovered files without data,
        // and to keep the progress, meta and everthing else, we only replace said data

        if (files[newFile.id] && files[newFile.id].isGhost) {
          newFile = _extends({}, files[newFile.id], {
            data: fileDescriptors[i].data,
            isGhost: false
          });
          this.log("Replaced blob in a ghost file: " + newFile.name + ", " + newFile.id);
        }

        files[newFile.id] = newFile;
        newFiles.push(newFile);
      } catch (err) {
        if (!err.isRestriction) {
          errors.push(err);
        }
      }
    }

    this.setState({
      files: files
    });
    newFiles.forEach(function (newFile) {
      _this4.emit('file-added', newFile);
    });
    this.emit('files-added', newFiles);

    if (newFiles.length > 5) {
      this.log("Added batch of " + newFiles.length + " files");
    } else {
      Object.keys(newFiles).forEach(function (fileID) {
        _this4.log("Added file: " + newFiles[fileID].name + "\n id: " + newFiles[fileID].id + "\n type: " + newFiles[fileID].type);
      });
    }

    if (newFiles.length > 0) {
      this.startIfAutoProceed();
    }

    if (errors.length > 0) {
      var message = 'Multiple errors occurred while adding files:\n';
      errors.forEach(function (subError) {
        message += "\n * " + subError.message;
      });
      this.info({
        message: this.i18n('addBulkFilesFailed', {
          smart_count: errors.length
        }),
        details: message
      }, 'error', this.opts.infoTimeout);

      if (typeof AggregateError === 'function') {
        throw new AggregateError(errors, message);
      } else {
        var err = new Error(message);
        err.errors = errors;
        throw err;
      }
    }
  };

  _proto.removeFiles = function removeFiles(fileIDs, reason) {
    var _this5 = this;

    var _this$getState4 = this.getState(),
        files = _this$getState4.files,
        currentUploads = _this$getState4.currentUploads;

    var updatedFiles = _extends({}, files);

    var updatedUploads = _extends({}, currentUploads);

    var removedFiles = Object.create(null);
    fileIDs.forEach(function (fileID) {
      if (files[fileID]) {
        removedFiles[fileID] = files[fileID];
        delete updatedFiles[fileID];
      }
    }); // Remove files from the `fileIDs` list in each upload.

    function fileIsNotRemoved(uploadFileID) {
      return removedFiles[uploadFileID] === undefined;
    }

    Object.keys(updatedUploads).forEach(function (uploadID) {
      var newFileIDs = currentUploads[uploadID].fileIDs.filter(fileIsNotRemoved); // Remove the upload if no files are associated with it anymore.

      if (newFileIDs.length === 0) {
        delete updatedUploads[uploadID];
        return;
      }

      updatedUploads[uploadID] = _extends({}, currentUploads[uploadID], {
        fileIDs: newFileIDs
      });
    });
    var stateUpdate = {
      currentUploads: updatedUploads,
      files: updatedFiles
    }; // If all files were removed - allow new uploads,
    // and clear recoveredState

    if (Object.keys(updatedFiles).length === 0) {
      stateUpdate.allowNewUpload = true;
      stateUpdate.error = null;
      stateUpdate.recoveredState = null;
    }

    this.setState(stateUpdate);
    this.calculateTotalProgress();
    var removedFileIDs = Object.keys(removedFiles);
    removedFileIDs.forEach(function (fileID) {
      _this5.emit('file-removed', removedFiles[fileID], reason);
    });

    if (removedFileIDs.length > 5) {
      this.log("Removed " + removedFileIDs.length + " files");
    } else {
      this.log("Removed files: " + removedFileIDs.join(', '));
    }
  };

  _proto.removeFile = function removeFile(fileID, reason) {
    if (reason === void 0) {
      reason = null;
    }

    this.removeFiles([fileID], reason);
  };

  _proto.pauseResume = function pauseResume(fileID) {
    if (!this.getState().capabilities.resumableUploads || this.getFile(fileID).uploadComplete) {
      return undefined;
    }

    var wasPaused = this.getFile(fileID).isPaused || false;
    var isPaused = !wasPaused;
    this.setFileState(fileID, {
      isPaused: isPaused
    });
    this.emit('upload-pause', fileID, isPaused);
    return isPaused;
  };

  _proto.pauseAll = function pauseAll() {
    var updatedFiles = _extends({}, this.getState().files);

    var inProgressUpdatedFiles = Object.keys(updatedFiles).filter(function (file) {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach(function (file) {
      var updatedFile = _extends({}, updatedFiles[file], {
        isPaused: true
      });

      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit('pause-all');
  };

  _proto.resumeAll = function resumeAll() {
    var updatedFiles = _extends({}, this.getState().files);

    var inProgressUpdatedFiles = Object.keys(updatedFiles).filter(function (file) {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach(function (file) {
      var updatedFile = _extends({}, updatedFiles[file], {
        isPaused: false,
        error: null
      });

      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit('resume-all');
  };

  _proto.retryAll = function retryAll() {
    var updatedFiles = _extends({}, this.getState().files);

    var filesToRetry = Object.keys(updatedFiles).filter(function (file) {
      return updatedFiles[file].error;
    });
    filesToRetry.forEach(function (file) {
      var updatedFile = _extends({}, updatedFiles[file], {
        isPaused: false,
        error: null
      });

      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      error: null
    });
    this.emit('retry-all', filesToRetry);

    if (filesToRetry.length === 0) {
      return Promise.resolve({
        successful: [],
        failed: []
      });
    }

    var uploadID = this.createUpload(filesToRetry, {
      forceAllowNewUpload: true // create new upload even if allowNewUpload: false

    });
    return this.runUpload(uploadID);
  };

  _proto.cancelAll = function cancelAll() {
    this.emit('cancel-all');

    var _this$getState5 = this.getState(),
        files = _this$getState5.files;

    var fileIDs = Object.keys(files);

    if (fileIDs.length) {
      this.removeFiles(fileIDs, 'cancel-all');
    }

    this.setState({
      totalProgress: 0,
      error: null,
      recoveredState: null
    });
  };

  _proto.retryUpload = function retryUpload(fileID) {
    this.setFileState(fileID, {
      error: null,
      isPaused: false
    });
    this.emit('upload-retry', fileID);
    var uploadID = this.createUpload([fileID], {
      forceAllowNewUpload: true // create new upload even if allowNewUpload: false

    });
    return this.runUpload(uploadID);
  };

  _proto.reset = function reset() {
    this.cancelAll();
  };

  _proto.logout = function logout() {
    this.iteratePlugins(function (plugin) {
      if (plugin.provider && plugin.provider.logout) {
        plugin.provider.logout();
      }
    });
  };

  _proto.calculateProgress = function calculateProgress(file, data) {
    if (!this.getFile(file.id)) {
      this.log("Not setting progress for a file that has been removed: " + file.id);
      return;
    } // bytesTotal may be null or zero; in that case we can't divide by it


    var canHavePercentage = Number.isFinite(data.bytesTotal) && data.bytesTotal > 0;
    this.setFileState(file.id, {
      progress: _extends({}, this.getFile(file.id).progress, {
        bytesUploaded: data.bytesUploaded,
        bytesTotal: data.bytesTotal,
        percentage: canHavePercentage // TODO(goto-bus-stop) flooring this should probably be the choice of the UI?
        // we get more accurate calculations if we don't round this at all.
        ? Math.round(data.bytesUploaded / data.bytesTotal * 100) : 0
      })
    });
    this.calculateTotalProgress();
  };

  _proto.calculateTotalProgress = function calculateTotalProgress() {
    // calculate total progress, using the number of files currently uploading,
    // multiplied by 100 and the summ of individual progress of each file
    var files = this.getFiles();
    var inProgress = files.filter(function (file) {
      return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;
    });

    if (inProgress.length === 0) {
      this.emit('progress', 0);
      this.setState({
        totalProgress: 0
      });
      return;
    }

    var sizedFiles = inProgress.filter(function (file) {
      return file.progress.bytesTotal != null;
    });
    var unsizedFiles = inProgress.filter(function (file) {
      return file.progress.bytesTotal == null;
    });

    if (sizedFiles.length === 0) {
      var progressMax = inProgress.length * 100;
      var currentProgress = unsizedFiles.reduce(function (acc, file) {
        return acc + file.progress.percentage;
      }, 0);

      var _totalProgress = Math.round(currentProgress / progressMax * 100);

      this.setState({
        totalProgress: _totalProgress
      });
      return;
    }

    var totalSize = sizedFiles.reduce(function (acc, file) {
      return acc + file.progress.bytesTotal;
    }, 0);
    var averageSize = totalSize / sizedFiles.length;
    totalSize += averageSize * unsizedFiles.length;
    var uploadedSize = 0;
    sizedFiles.forEach(function (file) {
      uploadedSize += file.progress.bytesUploaded;
    });
    unsizedFiles.forEach(function (file) {
      uploadedSize += averageSize * (file.progress.percentage || 0) / 100;
    });
    var totalProgress = totalSize === 0 ? 0 : Math.round(uploadedSize / totalSize * 100); // hot fix, because:
    // uploadedSize ended up larger than totalSize, resulting in 1325% total

    if (totalProgress > 100) {
      totalProgress = 100;
    }

    this.setState({
      totalProgress: totalProgress
    });
    this.emit('progress', totalProgress);
  }
  /**
   * Registers listeners for all global actions, like:
   * `error`, `file-removed`, `upload-progress`
   */
  ;

  _proto.addListeners = function addListeners() {
    var _this6 = this;

    /**
     * @param {Error} error
     * @param {object} [file]
     * @param {object} [response]
     */
    var errorHandler = function errorHandler(error, file, response) {
      var errorMsg = error.message || 'Unknown error';

      if (error.details) {
        errorMsg += " " + error.details;
      }

      _this6.setState({
        error: errorMsg
      }); // When a file is also given, we store the error on the file object.


      if (file != null && typeof file.id === 'string') {
        _this6.setFileState(file.id, {
          error: errorMsg,
          response: response
        });
      }
    };

    this.on('error', errorHandler);
    this.on('upload-error', function (file, error, response) {
      errorHandler(error, file, response);

      if (typeof error === 'object' && error.message) {
        var newError = new Error(error.message);
        newError.details = error.message;

        if (error.details) {
          newError.details += " " + error.details;
        }

        newError.message = _this6.i18n('failedToUpload', {
          file: file.name
        });

        _this6.showOrLogErrorAndThrow(newError, {
          throwErr: false
        });
      } else {
        _this6.showOrLogErrorAndThrow(error, {
          throwErr: false
        });
      }
    });
    this.on('upload', function () {
      _this6.setState({
        error: null
      });
    });
    this.on('upload-started', function (file) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      _this6.setFileState(file.id, {
        progress: {
          uploadStarted: Date.now(),
          uploadComplete: false,
          percentage: 0,
          bytesUploaded: 0,
          bytesTotal: file.size
        }
      });
    });
    this.on('upload-progress', this.calculateProgress);
    this.on('upload-success', function (file, uploadResp) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      var currentProgress = _this6.getFile(file.id).progress;

      _this6.setFileState(file.id, {
        progress: _extends({}, currentProgress, {
          postprocess: _this6.postProcessors.length > 0 ? {
            mode: 'indeterminate'
          } : null,
          uploadComplete: true,
          percentage: 100,
          bytesUploaded: currentProgress.bytesTotal
        }),
        response: uploadResp,
        uploadURL: uploadResp.uploadURL,
        isPaused: false
      });

      _this6.calculateTotalProgress();
    });
    this.on('preprocess-progress', function (file, progress) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      _this6.setFileState(file.id, {
        progress: _extends({}, _this6.getFile(file.id).progress, {
          preprocess: progress
        })
      });
    });
    this.on('preprocess-complete', function (file) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      var files = _extends({}, _this6.getState().files);

      files[file.id] = _extends({}, files[file.id], {
        progress: _extends({}, files[file.id].progress)
      });
      delete files[file.id].progress.preprocess;

      _this6.setState({
        files: files
      });
    });
    this.on('postprocess-progress', function (file, progress) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      _this6.setFileState(file.id, {
        progress: _extends({}, _this6.getState().files[file.id].progress, {
          postprocess: progress
        })
      });
    });
    this.on('postprocess-complete', function (file) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      var files = _extends({}, _this6.getState().files);

      files[file.id] = _extends({}, files[file.id], {
        progress: _extends({}, files[file.id].progress)
      });
      delete files[file.id].progress.postprocess; // TODO should we set some kind of `fullyComplete` property on the file object
      // so it's easier to see that the file is upload…fully complete…rather than
      // what we have to do now (`uploadComplete && !postprocess`)

      _this6.setState({
        files: files
      });
    });
    this.on('restored', function () {
      // Files may have changed--ensure progress is still accurate.
      _this6.calculateTotalProgress();
    }); // show informer if offline

    if (typeof window !== 'undefined' && window.addEventListener) {
      window.addEventListener('online', function () {
        return _this6.updateOnlineStatus();
      });
      window.addEventListener('offline', function () {
        return _this6.updateOnlineStatus();
      });
      setTimeout(function () {
        return _this6.updateOnlineStatus();
      }, 3000);
    }
  };

  _proto.updateOnlineStatus = function updateOnlineStatus() {
    var online = typeof window.navigator.onLine !== 'undefined' ? window.navigator.onLine : true;

    if (!online) {
      this.emit('is-offline');
      this.info(this.i18n('noInternetConnection'), 'error', 0);
      this.wasOffline = true;
    } else {
      this.emit('is-online');

      if (this.wasOffline) {
        this.emit('back-online');
        this.info(this.i18n('connectedToInternet'), 'success', 3000);
        this.wasOffline = false;
      }
    }
  };

  _proto.getID = function getID() {
    return this.opts.id;
  }
  /**
   * Registers a plugin with Core.
   *
   * @param {object} Plugin object
   * @param {object} [opts] object with options to be passed to Plugin
   * @returns {object} self for chaining
   */
  // eslint-disable-next-line no-shadow
  ;

  _proto.use = function use(Plugin, opts) {
    if (typeof Plugin !== 'function') {
      var msg = "Expected a plugin class, but got " + (Plugin === null ? 'null' : typeof Plugin) + "." + ' Please verify that the plugin was imported and spelled correctly.';
      throw new TypeError(msg);
    } // Instantiate


    var plugin = new Plugin(this, opts);
    var pluginId = plugin.id;
    this.plugins[plugin.type] = this.plugins[plugin.type] || [];

    if (!pluginId) {
      throw new Error('Your plugin must have an id');
    }

    if (!plugin.type) {
      throw new Error('Your plugin must have a type');
    }

    var existsPluginAlready = this.getPlugin(pluginId);

    if (existsPluginAlready) {
      var _msg = "Already found a plugin named '" + existsPluginAlready.id + "'. " + ("Tried to use: '" + pluginId + "'.\n") + 'Uppy plugins must have unique `id` options. See https://uppy.io/docs/plugins/#id.';

      throw new Error(_msg);
    }

    if (Plugin.VERSION) {
      this.log("Using " + pluginId + " v" + Plugin.VERSION);
    }

    this.plugins[plugin.type].push(plugin);
    plugin.install();
    return this;
  }
  /**
   * Find one Plugin by name.
   *
   * @param {string} id plugin id
   * @returns {object|boolean}
   */
  ;

  _proto.getPlugin = function getPlugin(id) {
    var foundPlugin = null;
    this.iteratePlugins(function (plugin) {
      if (plugin.id === id) {
        foundPlugin = plugin;
        return false;
      }
    });
    return foundPlugin;
  }
  /**
   * Iterate through all `use`d plugins.
   *
   * @param {Function} method that will be run on each plugin
   */
  ;

  _proto.iteratePlugins = function iteratePlugins(method) {
    var _this7 = this;

    Object.keys(this.plugins).forEach(function (pluginType) {
      _this7.plugins[pluginType].forEach(method);
    });
  }
  /**
   * Uninstall and remove a plugin.
   *
   * @param {object} instance The plugin instance to remove.
   */
  ;

  _proto.removePlugin = function removePlugin(instance) {
    var _extends4;

    this.log("Removing plugin " + instance.id);
    this.emit('plugin-remove', instance);

    if (instance.uninstall) {
      instance.uninstall();
    }

    var list = this.plugins[instance.type].slice(); // list.indexOf failed here, because Vue3 converted the plugin instance
    // to a Proxy object, which failed the strict comparison test:
    // obj !== objProxy

    var index = findIndex(list, function (item) {
      return item.id === instance.id;
    });

    if (index !== -1) {
      list.splice(index, 1);
      this.plugins[instance.type] = list;
    }

    var state = this.getState();
    var updatedState = {
      plugins: _extends({}, state.plugins, (_extends4 = {}, _extends4[instance.id] = undefined, _extends4))
    };
    this.setState(updatedState);
  }
  /**
   * Uninstall all plugins and close down this Uppy instance.
   */
  ;

  _proto.close = function close() {
    var _this8 = this;

    this.log("Closing Uppy instance " + this.opts.id + ": removing all files and uninstalling plugins");
    this.reset();
    this.storeUnsubscribe();
    this.iteratePlugins(function (plugin) {
      _this8.removePlugin(plugin);
    });
  }
  /**
   * Set info message in `state.info`, so that UI plugins like `Informer`
   * can display the message.
   *
   * @param {string | object} message Message to be displayed by the informer
   * @param {string} [type]
   * @param {number} [duration]
   */
  ;

  _proto.info = function info(message, type, duration) {
    if (type === void 0) {
      type = 'info';
    }

    if (duration === void 0) {
      duration = 3000;
    }

    var isComplexMessage = typeof message === 'object';
    this.setState({
      info: {
        isHidden: false,
        type: type,
        message: isComplexMessage ? message.message : message,
        details: isComplexMessage ? message.details : null
      }
    });
    this.emit('info-visible');
    clearTimeout(this.infoTimeoutID);

    if (duration === 0) {
      this.infoTimeoutID = undefined;
      return;
    } // hide the informer after `duration` milliseconds


    this.infoTimeoutID = setTimeout(this.hideInfo, duration);
  };

  _proto.hideInfo = function hideInfo() {
    var newInfo = _extends({}, this.getState().info, {
      isHidden: true
    });

    this.setState({
      info: newInfo
    });
    this.emit('info-hidden');
  }
  /**
   * Passes messages to a function, provided in `opts.logger`.
   * If `opts.logger: Uppy.debugLogger` or `opts.debug: true`, logs to the browser console.
   *
   * @param {string|object} message to log
   * @param {string} [type] optional `error` or `warning`
   */
  ;

  _proto.log = function log(message, type) {
    var logger = this.opts.logger;

    switch (type) {
      case 'error':
        logger.error(message);
        break;

      case 'warning':
        logger.warn(message);
        break;

      default:
        logger.debug(message);
        break;
    }
  }
  /**
   * Obsolete, event listeners are now added in the constructor.
   */
  ;

  _proto.run = function run() {
    this.log('Calling run() is no longer necessary.', 'warning');
    return this;
  }
  /**
   * Restore an upload by its ID.
   */
  ;

  _proto.restore = function restore(uploadID) {
    this.log("Core: attempting to restore upload \"" + uploadID + "\"");

    if (!this.getState().currentUploads[uploadID]) {
      this.removeUpload(uploadID);
      return Promise.reject(new Error('Nonexistent upload'));
    }

    return this.runUpload(uploadID);
  }
  /**
   * Create an upload for a bunch of files.
   *
   * @param {Array<string>} fileIDs File IDs to include in this upload.
   * @returns {string} ID of this upload.
   */
  ;

  _proto.createUpload = function createUpload(fileIDs, opts) {
    var _extends5;

    if (opts === void 0) {
      opts = {};
    }

    // uppy.retryAll sets this to true — when retrying we want to ignore `allowNewUpload: false`
    var _opts = opts,
        _opts$forceAllowNewUp = _opts.forceAllowNewUpload,
        forceAllowNewUpload = _opts$forceAllowNewUp === void 0 ? false : _opts$forceAllowNewUp;

    var _this$getState6 = this.getState(),
        allowNewUpload = _this$getState6.allowNewUpload,
        currentUploads = _this$getState6.currentUploads;

    if (!allowNewUpload && !forceAllowNewUpload) {
      throw new Error('Cannot create a new upload: already uploading.');
    }

    var uploadID = cuid();
    this.emit('upload', {
      id: uploadID,
      fileIDs: fileIDs
    });
    this.setState({
      allowNewUpload: this.opts.allowMultipleUploads !== false,
      currentUploads: _extends({}, currentUploads, (_extends5 = {}, _extends5[uploadID] = {
        fileIDs: fileIDs,
        step: 0,
        result: {}
      }, _extends5))
    });
    return uploadID;
  };

  _proto.getUpload = function getUpload(uploadID) {
    var _this$getState7 = this.getState(),
        currentUploads = _this$getState7.currentUploads;

    return currentUploads[uploadID];
  }
  /**
   * Add data to an upload's result object.
   *
   * @param {string} uploadID The ID of the upload.
   * @param {object} data Data properties to add to the result object.
   */
  ;

  _proto.addResultData = function addResultData(uploadID, data) {
    var _extends6;

    if (!this.getUpload(uploadID)) {
      this.log("Not setting result for an upload that has been removed: " + uploadID);
      return;
    }

    var _this$getState8 = this.getState(),
        currentUploads = _this$getState8.currentUploads;

    var currentUpload = _extends({}, currentUploads[uploadID], {
      result: _extends({}, currentUploads[uploadID].result, data)
    });

    this.setState({
      currentUploads: _extends({}, currentUploads, (_extends6 = {}, _extends6[uploadID] = currentUpload, _extends6))
    });
  }
  /**
   * Remove an upload, eg. if it has been canceled or completed.
   *
   * @param {string} uploadID The ID of the upload.
   */
  ;

  _proto.removeUpload = function removeUpload(uploadID) {
    var currentUploads = _extends({}, this.getState().currentUploads);

    delete currentUploads[uploadID];
    this.setState({
      currentUploads: currentUploads
    });
  }
  /**
   * Run an upload. This picks up where it left off in case the upload is being restored.
   *
   * @private
   */
  ;

  _proto.runUpload = function runUpload(uploadID) {
    var _this9 = this;

    var uploadData = this.getState().currentUploads[uploadID];
    var restoreStep = uploadData.step;
    var steps = [].concat(this.preProcessors, this.uploaders, this.postProcessors);
    var lastStep = Promise.resolve();
    steps.forEach(function (fn, step) {
      // Skip this step if we are restoring and have already completed this step before.
      if (step < restoreStep) {
        return;
      }

      lastStep = lastStep.then(function () {
        var _extends7;

        var _this9$getState = _this9.getState(),
            currentUploads = _this9$getState.currentUploads;

        var currentUpload = currentUploads[uploadID];

        if (!currentUpload) {
          return;
        }

        var updatedUpload = _extends({}, currentUpload, {
          step: step
        });

        _this9.setState({
          currentUploads: _extends({}, currentUploads, (_extends7 = {}, _extends7[uploadID] = updatedUpload, _extends7))
        }); // TODO give this the `updatedUpload` object as its only parameter maybe?
        // Otherwise when more metadata may be added to the upload this would keep getting more parameters
        // eslint-disable-next-line consistent-return


        return fn(updatedUpload.fileIDs, uploadID);
      }).then(function () {
        return null;
      });
    }); // Not returning the `catch`ed promise, because we still want to return a rejected
    // promise from this method if the upload failed.

    lastStep.catch(function (err) {
      _this9.emit('error', err);

      _this9.removeUpload(uploadID);
    });
    return lastStep.then(function () {
      // Set result data.
      var _this9$getState2 = _this9.getState(),
          currentUploads = _this9$getState2.currentUploads;

      var currentUpload = currentUploads[uploadID];

      if (!currentUpload) {
        return;
      } // Mark postprocessing step as complete if necessary; this addresses a case where we might get
      // stuck in the postprocessing UI while the upload is fully complete.
      // If the postprocessing steps do not do any work, they may not emit postprocessing events at
      // all, and never mark the postprocessing as complete. This is fine on its own but we
      // introduced code in the @uppy/core upload-success handler to prepare postprocessing progress
      // state if any postprocessors are registered. That is to avoid a "flash of completed state"
      // before the postprocessing plugins can emit events.
      //
      // So, just in case an upload with postprocessing plugins *has* completed *without* emitting
      // postprocessing completion, we do it instead.


      currentUpload.fileIDs.forEach(function (fileID) {
        var file = _this9.getFile(fileID);

        if (file && file.progress.postprocess) {
          _this9.emit('postprocess-complete', file);
        }
      });
      var files = currentUpload.fileIDs.map(function (fileID) {
        return _this9.getFile(fileID);
      });
      var successful = files.filter(function (file) {
        return !file.error;
      });
      var failed = files.filter(function (file) {
        return file.error;
      });

      _this9.addResultData(uploadID, {
        successful: successful,
        failed: failed,
        uploadID: uploadID
      });
    }).then(function () {
      // Emit completion events.
      // This is in a separate function so that the `currentUploads` variable
      // always refers to the latest state. In the handler right above it refers
      // to an outdated object without the `.result` property.
      var _this9$getState3 = _this9.getState(),
          currentUploads = _this9$getState3.currentUploads;

      if (!currentUploads[uploadID]) {
        return;
      }

      var currentUpload = currentUploads[uploadID];
      var result = currentUpload.result;

      _this9.emit('complete', result);

      _this9.removeUpload(uploadID); // eslint-disable-next-line consistent-return


      return result;
    }).then(function (result) {
      if (result == null) {
        _this9.log("Not setting result for an upload that has been removed: " + uploadID);
      }

      return result;
    });
  }
  /**
   * Start an upload for all the files that are not currently being uploaded.
   *
   * @returns {Promise}
   */
  ;

  _proto.upload = function upload() {
    var _this10 = this;

    if (!this.plugins.uploader) {
      this.log('No uploader type plugins are used', 'warning');
    }

    var _this$getState9 = this.getState(),
        files = _this$getState9.files;

    var onBeforeUploadResult = this.opts.onBeforeUpload(files);

    if (onBeforeUploadResult === false) {
      return Promise.reject(new Error('Not starting the upload because onBeforeUpload returned false'));
    }

    if (onBeforeUploadResult && typeof onBeforeUploadResult === 'object') {
      files = onBeforeUploadResult; // Updating files in state, because uploader plugins receive file IDs,
      // and then fetch the actual file object from state

      this.setState({
        files: files
      });
    }

    return Promise.resolve().then(function () {
      return _this10.checkMinNumberOfFiles(files);
    }).catch(function (err) {
      _this10.showOrLogErrorAndThrow(err);
    }).then(function () {
      var _this10$getState = _this10.getState(),
          currentUploads = _this10$getState.currentUploads; // get a list of files that are currently assigned to uploads


      var currentlyUploadingFiles = Object.keys(currentUploads).reduce(function (prev, curr) {
        return prev.concat(currentUploads[curr].fileIDs);
      }, []);
      var waitingFileIDs = [];
      Object.keys(files).forEach(function (fileID) {
        var file = _this10.getFile(fileID); // if the file hasn't started uploading and hasn't already been assigned to an upload..


        if (!file.progress.uploadStarted && currentlyUploadingFiles.indexOf(fileID) === -1) {
          waitingFileIDs.push(file.id);
        }
      });

      var uploadID = _this10.createUpload(waitingFileIDs);

      return _this10.runUpload(uploadID);
    }).catch(function (err) {
      _this10.showOrLogErrorAndThrow(err, {
        showInformer: false
      });
    });
  };

  _createClass(Uppy, [{
    key: "state",
    get: function get() {
      return this.getState();
    }
  }]);

  return Uppy;
}();

Uppy.VERSION = version;

module.exports = function core(opts) {
  return new Uppy(opts);
}; // Expose class constructor.


module.exports.Uppy = Uppy;
module.exports.Plugin = Plugin;
module.exports.debugLogger = debugLogger;

},{"../package.json":53,"./../../store-default":152,"./../../utils/lib/Translator":167,"./../../utils/lib/findIndex":174,"./../../utils/lib/generateFileID":175,"./../../utils/lib/getFileNameAndExtension":182,"./../../utils/lib/getFileType":183,"./Plugin":54,"./loggers":56,"./supportsUploadProgress":57,"@transloadit/prettier-bytes":1,"cuid":6,"lodash.throttle":17,"mime-match":20,"namespace-emitter":21}],56:[function(require,module,exports){
var getTimeStamp = require('./../../utils/lib/getTimeStamp'); // Swallow all logs, except errors.
// default if logger is not set or debug: false


var justErrorsLogger = {
  debug: function debug() {},
  warn: function warn() {},
  error: function error() {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_console = console).error.apply(_console, ["[Uppy] [" + getTimeStamp() + "]"].concat(args));
  }
}; // Print logs to console with namespace + timestamp,
// set by logger: Uppy.debugLogger or debug: true

var debugLogger = {
  debug: function debug() {
    // IE 10 doesn’t support console.debug
    var debug = console.debug || console.log;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    debug.call.apply(debug, [console, "[Uppy] [" + getTimeStamp() + "]"].concat(args));
  },
  warn: function warn() {
    var _console2;

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return (_console2 = console).warn.apply(_console2, ["[Uppy] [" + getTimeStamp() + "]"].concat(args));
  },
  error: function error() {
    var _console3;

    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return (_console3 = console).error.apply(_console3, ["[Uppy] [" + getTimeStamp() + "]"].concat(args));
  }
};
module.exports = {
  justErrorsLogger: justErrorsLogger,
  debugLogger: debugLogger
};

},{"./../../utils/lib/getTimeStamp":188}],57:[function(require,module,exports){
// Edge 15.x does not fire 'progress' events on uploads.
// See https://github.com/transloadit/uppy/issues/945
// And https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12224510/
module.exports = function supportsUploadProgress(userAgent) {
  // Allow passing in userAgent for tests
  if (userAgent == null) {
    userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : null;
  } // Assume it works because basically everything supports progress events.


  if (!userAgent) return true;
  var m = /Edge\/(\d+\.\d+)/.exec(userAgent);
  if (!m) return true;
  var edgeVersion = m[1];

  var _edgeVersion$split = edgeVersion.split('.'),
      major = _edgeVersion$split[0],
      minor = _edgeVersion$split[1];

  major = parseInt(major, 10);
  minor = parseInt(minor, 10); // Worked before:
  // Edge 40.15063.0.0
  // Microsoft EdgeHTML 15.15063

  if (major < 15 || major === 15 && minor < 15063) {
    return true;
  } // Fixed in:
  // Microsoft EdgeHTML 18.18218


  if (major > 18 || major === 18 && minor >= 18218) {
    return true;
  } // other versions don't work.


  return false;
};

},{}],58:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],59:[function(require,module,exports){
module.exports={
  "name": "@uppy/dashboard",
  "description": "Universal UI plugin for Uppy.",
  "version": "1.20.2",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "dashboard",
    "ui"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@transloadit/prettier-bytes": "0.0.7",
    "@uppy/informer": "file:../informer",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/status-bar": "file:../status-bar",
    "@uppy/thumbnail-generator": "file:../thumbnail-generator",
    "@uppy/utils": "file:../utils",
    "classnames": "^2.2.6",
    "cuid": "^2.1.1",
    "is-shallow-equal": "^1.0.1",
    "lodash.debounce": "^4.0.8",
    "lodash.throttle": "^4.1.1",
    "memoize-one": "^5.0.4",
    "preact": "8.2.9",
    "resize-observer-polyfill": "^1.5.0"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],60:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var AddFiles = /*#__PURE__*/function (_Component) {
  _inheritsLoose(AddFiles, _Component);

  function AddFiles() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;

    _this.triggerFileInputClick = function () {
      _this.fileInput.click();
    };

    _this.triggerFolderInputClick = function () {
      _this.folderInput.click();
    };

    _this.onFileInputChange = function (event) {
      _this.props.handleInputChange(event); // We clear the input after a file is selected, because otherwise
      // change event is not fired in Chrome and Safari when a file
      // with the same name is selected.
      // ___Why not use value="" on <input/> instead?
      //    Because if we use that method of clearing the input,
      //    Chrome will not trigger change if we drop the same file twice (Issue #768).


      event.target.value = null;
    };

    _this.renderHiddenInput = function (isFolder, refCallback) {
      return h("input", {
        className: "uppy-Dashboard-input",
        hidden: true,
        "aria-hidden": "true",
        tabIndex: -1,
        webkitdirectory: isFolder,
        type: "file",
        name: "files[]",
        multiple: _this.props.maxNumberOfFiles !== 1,
        onChange: _this.onFileInputChange,
        accept: _this.props.allowedFileTypes,
        ref: refCallback
      });
    };

    _this.renderMyDeviceAcquirer = function () {
      return h("div", {
        className: "uppy-DashboardTab",
        role: "presentation",
        "data-uppy-acquirer-id": "MyDevice"
      }, h("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
        role: "tab",
        tabIndex: 0,
        "data-uppy-super-focusable": true,
        onClick: _this.triggerFileInputClick
      }, h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        width: "32",
        height: "32",
        rx: "16",
        fill: "#2275D7"
      }), h("path", {
        d: "M21.973 21.152H9.863l-1.108-5.087h14.464l-1.246 5.087zM9.935 11.37h3.958l.886 1.444a.673.673 0 0 0 .585.316h6.506v1.37H9.935v-3.13zm14.898 3.44a.793.793 0 0 0-.616-.31h-.978v-2.126c0-.379-.275-.613-.653-.613H15.75l-.886-1.445a.673.673 0 0 0-.585-.316H9.232c-.378 0-.667.209-.667.587V14.5h-.782a.793.793 0 0 0-.61.303.795.795 0 0 0-.155.663l1.45 6.633c.078.36.396.618.764.618h13.354c.36 0 .674-.246.76-.595l1.631-6.636a.795.795 0 0 0-.144-.675z",
        fill: "#FFF"
      }))), h("div", {
        className: "uppy-DashboardTab-name"
      }, _this.props.i18n('myDevice'))));
    };

    _this.renderBrowseButton = function (text, onClickFn) {
      var numberOfAcquirers = _this.props.acquirers.length;
      return h("button", {
        type: "button",
        className: "uppy-u-reset uppy-Dashboard-browse",
        onClick: onClickFn,
        "data-uppy-super-focusable": numberOfAcquirers === 0
      }, text);
    };

    _this.renderDropPasteBrowseTagline = function () {
      var numberOfAcquirers = _this.props.acquirers.length; // in order to keep the i18n CamelCase and options lower (as are defaults) we will want to transform a lower
      // to Camel

      var lowerFMSelectionType = _this.props.fileManagerSelectionType;
      var camelFMSelectionType = lowerFMSelectionType.charAt(0).toUpperCase() + lowerFMSelectionType.slice(1); // For backwards compatibility, we need to support both 'browse' and 'browseFiles'/'browseFolders' as strings here.

      var browseText = 'browse';
      var browseFilesText = 'browse';
      var browseFoldersText = 'browse';

      if (lowerFMSelectionType === 'files') {
        try {
          browseText = _this.props.i18n('browse');
          browseFilesText = _this.props.i18n('browse');
          browseFoldersText = _this.props.i18n('browse');
        } catch (_unused) {// Ignore, hopefully we can use the 'browseFiles' / 'browseFolders' strings
        }
      }

      try {
        browseFilesText = _this.props.i18n('browseFiles');
        browseFoldersText = _this.props.i18n('browseFolders');
      } catch (_unused2) {// Ignore, use the 'browse' string
      }

      var browse = _this.renderBrowseButton(browseText, _this.triggerFileInputClick);

      var browseFiles = _this.renderBrowseButton(browseFilesText, _this.triggerFileInputClick);

      var browseFolders = _this.renderBrowseButton(browseFoldersText, _this.triggerFolderInputClick); // Before the `fileManagerSelectionType` feature existed, we had two possible
      // strings here, but now we have six. We use the new-style strings by default:


      var titleText;

      if (numberOfAcquirers > 0) {
        titleText = _this.props.i18nArray("dropPasteImport" + camelFMSelectionType, {
          browseFiles: browseFiles,
          browseFolders: browseFolders,
          browse: browse
        });
      } else {
        titleText = _this.props.i18nArray("dropPaste" + camelFMSelectionType, {
          browseFiles: browseFiles,
          browseFolders: browseFolders,
          browse: browse
        });
      } // We use the old-style strings if available: this implies that the user has
      // manually specified them, so they should take precedence over the new-style
      // defaults.


      if (lowerFMSelectionType === 'files') {
        try {
          if (numberOfAcquirers > 0) {
            titleText = _this.props.i18nArray('dropPasteImport', {
              browse: browse
            });
          } else {
            titleText = _this.props.i18nArray('dropPaste', {
              browse: browse
            });
          }
        } catch (_unused3) {// Ignore, the new-style strings will be used.
        }
      }

      if (_this.props.disableLocalFiles) {
        titleText = _this.props.i18n('importFiles');
      }

      return h("div", {
        className: "uppy-Dashboard-AddFiles-title"
      }, titleText);
    };

    _this.renderAcquirer = function (acquirer) {
      return h("div", {
        className: "uppy-DashboardTab",
        role: "presentation",
        "data-uppy-acquirer-id": acquirer.id
      }, h("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
        role: "tab",
        tabIndex: 0,
        "aria-controls": "uppy-DashboardContent-panel--" + acquirer.id,
        "aria-selected": _this.props.activePickerPanel.id === acquirer.id,
        "data-uppy-super-focusable": true,
        onClick: function onClick() {
          return _this.props.showPanel(acquirer.id);
        }
      }, acquirer.icon(), h("div", {
        className: "uppy-DashboardTab-name"
      }, acquirer.name)));
    };

    _this.renderAcquirers = function (acquirers, disableLocalFiles) {
      // Group last two buttons, so we don’t end up with
      // just one button on a new line
      var acquirersWithoutLastTwo = [].concat(acquirers);
      var lastTwoAcquirers = acquirersWithoutLastTwo.splice(acquirers.length - 2, acquirers.length);
      return h("div", {
        className: "uppy-Dashboard-AddFiles-list",
        role: "tablist"
      }, !disableLocalFiles && _this.renderMyDeviceAcquirer(), acquirersWithoutLastTwo.map(function (acquirer) {
        return _this.renderAcquirer(acquirer);
      }), h("span", {
        role: "presentation",
        style: "white-space: nowrap;"
      }, lastTwoAcquirers.map(function (acquirer) {
        return _this.renderAcquirer(acquirer);
      })));
    };

    return _this;
  }

  var _proto = AddFiles.prototype;

  _proto.renderPoweredByUppy = function renderPoweredByUppy() {
    var uppyBranding = h("span", null, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-Dashboard-poweredByIcon",
      width: "11",
      height: "11",
      viewBox: "0 0 11 11"
    }, h("path", {
      d: "M7.365 10.5l-.01-4.045h2.612L5.5.806l-4.467 5.65h2.604l.01 4.044h3.718z",
      fillRule: "evenodd"
    })), h("span", {
      className: "uppy-Dashboard-poweredByUppy"
    }, "Uppy")); // Support both the old word-order-insensitive string `poweredBy` and the new word-order-sensitive string `poweredBy2`

    var linkText = this.props.i18nArray('poweredBy2', {
      backwardsCompat: this.props.i18n('poweredBy'),
      uppy: uppyBranding
    });
    return h("a", {
      tabIndex: "-1",
      href: "https://uppy.io",
      rel: "noreferrer noopener",
      target: "_blank",
      className: "uppy-Dashboard-poweredBy"
    }, linkText);
  };

  _proto.render = function render() {
    var _this2 = this;

    return h("div", {
      className: "uppy-Dashboard-AddFiles"
    }, this.renderHiddenInput(false, function (ref) {
      _this2.fileInput = ref;
    }), this.renderHiddenInput(true, function (ref) {
      _this2.folderInput = ref;
    }), this.renderDropPasteBrowseTagline(), this.props.acquirers.length > 0 && this.renderAcquirers(this.props.acquirers, this.props.disableLocalFiles), h("div", {
      className: "uppy-Dashboard-AddFiles-info"
    }, this.props.note && h("div", {
      className: "uppy-Dashboard-note"
    }, this.props.note), this.props.proudlyDisplayPoweredByUppy && this.renderPoweredByUppy(this.props)));
  };

  return AddFiles;
}(Component);

module.exports = AddFiles;

},{"preact":58}],61:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

var AddFiles = require('./AddFiles');

var AddFilesPanel = function AddFilesPanel(props) {
  return h("div", {
    className: classNames('uppy-Dashboard-AddFilesPanel', props.className),
    "data-uppy-panelType": "AddFiles",
    "aria-hidden": props.showAddFilesPanel
  }, h("div", {
    className: "uppy-DashboardContent-bar"
  }, h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18n('addingMoreFiles')), h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: function onClick(ev) {
      return props.toggleAddFilesPanel(false);
    }
  }, props.i18n('back'))), h(AddFiles, props));
};

module.exports = AddFilesPanel;

},{"./AddFiles":60,"classnames":4,"preact":58}],62:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

var FileList = require('./FileList');

var AddFiles = require('./AddFiles');

var AddFilesPanel = require('./AddFilesPanel');

var PickerPanelContent = require('./PickerPanelContent');

var EditorPanel = require('./EditorPanel');

var PanelTopBar = require('./PickerPanelTopBar');

var FileCard = require('./FileCard');

var Slide = require('./Slide');

var isDragDropSupported = require('./../../../utils/lib/isDragDropSupported'); // http://dev.edenspiekermann.com/2016/02/11/introducing-accessible-modal-dialog
// https://github.com/ghosh/micromodal


var WIDTH_XL = 900;
var WIDTH_LG = 700;
var WIDTH_MD = 576;
var HEIGHT_MD = 400;

module.exports = function Dashboard(props) {
  var noFiles = props.totalFileCount === 0;
  var isSizeMD = props.containerWidth > WIDTH_MD;
  var wrapperClassName = classNames({
    'uppy-Root': props.isTargetDOMEl
  });
  var dashboardClassName = classNames({
    'uppy-Dashboard': true,
    'uppy-Dashboard--isDisabled': props.disabled,
    'uppy-Dashboard--animateOpenClose': props.animateOpenClose,
    'uppy-Dashboard--isClosing': props.isClosing,
    'uppy-Dashboard--isDraggingOver': props.isDraggingOver,
    'uppy-Dashboard--modal': !props.inline,
    'uppy-size--md': props.containerWidth > WIDTH_MD,
    'uppy-size--lg': props.containerWidth > WIDTH_LG,
    'uppy-size--xl': props.containerWidth > WIDTH_XL,
    'uppy-size--height-md': props.containerHeight > HEIGHT_MD,
    'uppy-Dashboard--isAddFilesPanelVisible': props.showAddFilesPanel,
    'uppy-Dashboard--isInnerWrapVisible': props.areInsidesReadyToBeVisible
  }); // Important: keep these in sync with the percent width values in `src/components/FileItem/index.scss`.

  var itemsPerRow = 1; // mobile

  if (props.containerWidth > WIDTH_XL) {
    itemsPerRow = 5;
  } else if (props.containerWidth > WIDTH_LG) {
    itemsPerRow = 4;
  } else if (props.containerWidth > WIDTH_MD) {
    itemsPerRow = 3;
  }

  var showFileList = props.showSelectedFiles && !noFiles;
  var numberOfFilesForRecovery = props.recoveredState ? Object.keys(props.recoveredState.files).length : null;
  var numberOfGhosts = props.files ? Object.keys(props.files).filter(function (fileID) {
    return props.files[fileID].isGhost;
  }).length : null;

  var renderRestoredText = function renderRestoredText() {
    if (numberOfGhosts > 0) {
      return props.i18n('recoveredXFiles', {
        smart_count: numberOfGhosts
      });
    }

    return props.i18n('recoveredAllFiles');
  };

  var dashboard = h("div", {
    className: dashboardClassName,
    "data-uppy-theme": props.theme,
    "data-uppy-num-acquirers": props.acquirers.length,
    "data-uppy-drag-drop-supported": !props.disableLocalFiles && isDragDropSupported(),
    "aria-hidden": props.inline ? 'false' : props.isHidden,
    "aria-disabled": props.disabled,
    "aria-label": !props.inline ? props.i18n('dashboardWindowTitle') : props.i18n('dashboardTitle'),
    onPaste: props.handlePaste,
    onDragOver: props.handleDragOver,
    onDragLeave: props.handleDragLeave,
    onDrop: props.handleDrop
  }, h("div", {
    className: "uppy-Dashboard-overlay",
    tabIndex: -1,
    onClick: props.handleClickOutside
  }), h("div", {
    className: "uppy-Dashboard-inner",
    "aria-modal": !props.inline && 'true',
    role: !props.inline && 'dialog',
    style: {
      width: props.inline && props.width ? props.width : '',
      height: props.inline && props.height ? props.height : ''
    }
  }, !props.inline ? h("button", {
    className: "uppy-u-reset uppy-Dashboard-close",
    type: "button",
    "aria-label": props.i18n('closeModal'),
    title: props.i18n('closeModal'),
    onClick: props.closeModal
  }, h("span", {
    "aria-hidden": "true"
  }, "\xD7")) : null, h("div", {
    className: "uppy-Dashboard-innerWrap"
  }, h("div", {
    className: "uppy-Dashboard-dropFilesHereHint"
  }, props.i18n('dropHint')), showFileList && h(PanelTopBar, props), numberOfFilesForRecovery && h("div", {
    className: "uppy-Dashboard-serviceMsg"
  }, h("svg", {
    className: "uppy-Dashboard-serviceMsg-icon",
    "aria-hidden": "true",
    focusable: "false",
    width: "21",
    height: "16",
    viewBox: "0 0 24 19"
  }, h("g", {
    transform: "translate(0 -1)",
    fill: "none",
    fillRule: "evenodd"
  }, h("path", {
    d: "M12.857 1.43l10.234 17.056A1 1 0 0122.234 20H1.766a1 1 0 01-.857-1.514L11.143 1.429a1 1 0 011.714 0z",
    fill: "#FFD300"
  }), h("path", {
    fill: "#000",
    d: "M11 6h2l-.3 8h-1.4z"
  }), h("circle", {
    fill: "#000",
    cx: "12",
    cy: "17",
    r: "1"
  }))), h("strong", {
    className: "uppy-Dashboard-serviceMsg-title"
  }, props.i18n('sessionRestored')), h("div", {
    class: "uppy-Dashboard-serviceMsg-text"
  }, renderRestoredText())), showFileList ? h(FileList, _extends({}, props, {
    itemsPerRow: itemsPerRow
  })) : h(AddFiles, _extends({}, props, {
    isSizeMD: isSizeMD
  })), h(Slide, null, props.showAddFilesPanel ? h(AddFilesPanel, _extends({
    key: "AddFiles"
  }, props, {
    isSizeMD: isSizeMD
  })) : null), h(Slide, null, props.fileCardFor ? h(FileCard, _extends({
    key: "FileCard"
  }, props)) : null), h(Slide, null, props.activePickerPanel ? h(PickerPanelContent, _extends({
    key: "Picker"
  }, props)) : null), h(Slide, null, props.showFileEditor ? h(EditorPanel, _extends({
    key: "Editor"
  }, props)) : null), h("div", {
    className: "uppy-Dashboard-progressindicators"
  }, props.progressindicators.map(function (target) {
    return props.getPlugin(target.id).render(props.state);
  })))));
  return (// Wrap it for RTL language support
    h("div", {
      className: wrapperClassName,
      dir: props.direction
    }, dashboard)
  );
};

},{"./../../../utils/lib/isDragDropSupported":191,"./AddFiles":60,"./AddFilesPanel":61,"./EditorPanel":63,"./FileCard":64,"./FileList":70,"./PickerPanelContent":72,"./PickerPanelTopBar":73,"./Slide":74,"classnames":4,"preact":58}],63:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

function EditorPanel(props) {
  var file = this.props.files[this.props.fileCardFor];
  return h("div", {
    className: classNames('uppy-DashboardContent-panel', props.className),
    role: "tabpanel",
    "data-uppy-panelType": "FileEditor",
    id: "uppy-DashboardContent-panel--editor"
  }, h("div", {
    className: "uppy-DashboardContent-bar"
  }, h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18nArray('editing', {
    file: h("span", {
      className: "uppy-DashboardContent-titleFile"
    }, file.meta ? file.meta.name : file.name)
  })), h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: props.hideAllPanels
  }, props.i18n('cancel')), h("button", {
    className: "uppy-DashboardContent-save",
    type: "button",
    onClick: props.saveFileEditor
  }, props.i18n('save'))), h("div", {
    className: "uppy-DashboardContent-panelBody"
  }, props.editors.map(function (target) {
    return props.getPlugin(target.id).render(props.state);
  })));
}

module.exports = EditorPanel;

},{"classnames":4,"preact":58}],64:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var classNames = require('classnames');

var getFileTypeIcon = require('../../utils/getFileTypeIcon');

var ignoreEvent = require('../../utils/ignoreEvent.js');

var FilePreview = require('../FilePreview');

var FileCard = /*#__PURE__*/function (_Component) {
  _inheritsLoose(FileCard, _Component);

  function FileCard(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.saveOnEnter = function (ev) {
      if (ev.keyCode === 13) {
        ev.stopPropagation();
        ev.preventDefault();
        var file = _this.props.files[_this.props.fileCardFor];

        _this.props.saveFileCard(_this.state.formState, file.id);
      }
    };

    _this.updateMeta = function (newVal, name) {
      var _extends2;

      _this.setState({
        formState: _extends({}, _this.state.formState, (_extends2 = {}, _extends2[name] = newVal, _extends2))
      });
    };

    _this.handleSave = function () {
      var fileID = _this.props.fileCardFor;

      _this.props.saveFileCard(_this.state.formState, fileID);
    };

    _this.handleCancel = function () {
      _this.props.toggleFileCard(false);
    };

    _this.renderMetaFields = function () {
      var metaFields = _this.getMetaFields() || [];
      var fieldCSSClasses = {
        text: 'uppy-u-reset uppy-c-textInput uppy-Dashboard-FileCard-input'
      };
      return metaFields.map(function (field) {
        var id = "uppy-Dashboard-FileCard-input-" + field.id;
        return h("fieldset", {
          key: field.id,
          className: "uppy-Dashboard-FileCard-fieldset"
        }, h("label", {
          className: "uppy-Dashboard-FileCard-label",
          htmlFor: id
        }, field.name), field.render !== undefined ? field.render({
          value: _this.state.formState[field.id],
          onChange: function onChange(newVal) {
            return _this.updateMeta(newVal, field.id);
          },
          fieldCSSClasses: fieldCSSClasses
        }, h) : h("input", {
          className: fieldCSSClasses.text,
          id: id,
          type: field.type || 'text',
          value: _this.state.formState[field.id],
          placeholder: field.placeholder,
          onKeyUp: _this.saveOnEnter,
          onKeyDown: _this.saveOnEnter,
          onKeyPress: _this.saveOnEnter,
          onInput: function onInput(ev) {
            return _this.updateMeta(ev.target.value, field.id);
          },
          "data-uppy-super-focusable": true
        }));
      });
    };

    var _file = _this.props.files[_this.props.fileCardFor];

    var _metaFields = _this.getMetaFields() || [];

    var storedMetaData = {};

    _metaFields.forEach(function (field) {
      storedMetaData[field.id] = _file.meta[field.id] || '';
    });

    _this.state = {
      formState: storedMetaData
    };
    return _this;
  }

  var _proto = FileCard.prototype;

  _proto.getMetaFields = function getMetaFields() {
    return typeof this.props.metaFields === 'function' ? this.props.metaFields(this.props.files[this.props.fileCardFor]) : this.props.metaFields;
  };

  _proto.render = function render() {
    var _this2 = this;

    var file = this.props.files[this.props.fileCardFor];
    var showEditButton = this.props.canEditFile(file);
    return h("div", {
      className: classNames('uppy-Dashboard-FileCard', this.props.className),
      "data-uppy-panelType": "FileCard",
      onDragOver: ignoreEvent,
      onDragLeave: ignoreEvent,
      onDrop: ignoreEvent,
      onPaste: ignoreEvent
    }, h("div", {
      className: "uppy-DashboardContent-bar"
    }, h("div", {
      className: "uppy-DashboardContent-title",
      role: "heading",
      "aria-level": "1"
    }, this.props.i18nArray('editing', {
      file: h("span", {
        className: "uppy-DashboardContent-titleFile"
      }, file.meta ? file.meta.name : file.name)
    })), h("button", {
      className: "uppy-DashboardContent-back",
      type: "button",
      title: this.props.i18n('finishEditingFile'),
      onClick: this.handleCancel
    }, this.props.i18n('cancel'))), h("div", {
      className: "uppy-Dashboard-FileCard-inner"
    }, h("div", {
      className: "uppy-Dashboard-FileCard-preview",
      style: {
        backgroundColor: getFileTypeIcon(file.type).color
      }
    }, h(FilePreview, {
      file: file
    }), showEditButton && h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn uppy-Dashboard-FileCard-edit",
      onClick: function onClick() {
        return _this2.props.openFileEditor(file);
      }
    }, this.props.i18n('editFile'))), h("div", {
      className: "uppy-Dashboard-FileCard-info"
    }, this.renderMetaFields()), h("div", {
      className: "uppy-Dashboard-FileCard-actions"
    }, h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Dashboard-FileCard-actionsBtn",
      type: "button",
      onClick: this.handleSave
    }, this.props.i18n('saveChanges')), h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-link uppy-Dashboard-FileCard-actionsBtn",
      type: "button",
      onClick: this.handleCancel
    }, this.props.i18n('cancel')))));
  };

  return FileCard;
}(Component);

module.exports = FileCard;

},{"../../utils/getFileTypeIcon":80,"../../utils/ignoreEvent.js":81,"../FilePreview":71,"classnames":4,"preact":58}],65:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var copyToClipboard = require('../../../utils/copyToClipboard');

function EditButton(_ref) {
  var file = _ref.file,
      uploadInProgressOrComplete = _ref.uploadInProgressOrComplete,
      metaFields = _ref.metaFields,
      canEditFile = _ref.canEditFile,
      i18n = _ref.i18n,
      _onClick = _ref.onClick;

  if (!uploadInProgressOrComplete && metaFields && metaFields.length > 0 || !uploadInProgressOrComplete && canEditFile(file)) {
    return h("button", {
      className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--edit",
      type: "button",
      "aria-label": i18n('editFile') + " " + file.meta.name,
      title: i18n('editFile'),
      onClick: function onClick() {
        return _onClick();
      }
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      width: "14",
      height: "14",
      viewBox: "0 0 14 14"
    }, h("g", {
      fillRule: "evenodd"
    }, h("path", {
      d: "M1.5 10.793h2.793A1 1 0 0 0 5 10.5L11.5 4a1 1 0 0 0 0-1.414L9.707.793a1 1 0 0 0-1.414 0l-6.5 6.5A1 1 0 0 0 1.5 8v2.793zm1-1V8L9 1.5l1.793 1.793-6.5 6.5H2.5z",
      fillRule: "nonzero"
    }), h("rect", {
      x: "1",
      y: "12.293",
      width: "11",
      height: "1",
      rx: ".5"
    }), h("path", {
      fillRule: "nonzero",
      d: "M6.793 2.5L9.5 5.207l.707-.707L7.5 1.793z"
    }))));
  }

  return null;
}

function RemoveButton(_ref2) {
  var i18n = _ref2.i18n,
      _onClick2 = _ref2.onClick;
  return h("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--remove",
    type: "button",
    "aria-label": i18n('removeFile'),
    title: i18n('removeFile'),
    onClick: function onClick() {
      return _onClick2();
    }
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "18",
    height: "18",
    viewBox: "0 0 18 18"
  }, h("path", {
    d: "M9 0C4.034 0 0 4.034 0 9s4.034 9 9 9 9-4.034 9-9-4.034-9-9-9z"
  }), h("path", {
    fill: "#FFF",
    d: "M13 12.222l-.778.778L9 9.778 5.778 13 5 12.222 8.222 9 5 5.778 5.778 5 9 8.222 12.222 5l.778.778L9.778 9z"
  })));
}

var copyLinkToClipboard = function copyLinkToClipboard(event, props) {
  copyToClipboard(props.file.uploadURL, props.i18n('copyLinkToClipboardFallback')).then(function () {
    props.log('Link copied to clipboard.');
    props.info(props.i18n('copyLinkToClipboardSuccess'), 'info', 3000);
  }).catch(props.log) // avoid losing focus
  .then(function () {
    return event.target.focus({
      preventScroll: true
    });
  });
};

function CopyLinkButton(props) {
  return h("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--copyLink",
    type: "button",
    "aria-label": props.i18n('copyLink'),
    title: props.i18n('copyLink'),
    onClick: function onClick(event) {
      return copyLinkToClipboard(event, props);
    }
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "14",
    height: "14",
    viewBox: "0 0 14 12"
  }, h("path", {
    d: "M7.94 7.703a2.613 2.613 0 0 1-.626 2.681l-.852.851a2.597 2.597 0 0 1-1.849.766A2.616 2.616 0 0 1 2.764 7.54l.852-.852a2.596 2.596 0 0 1 2.69-.625L5.267 7.099a1.44 1.44 0 0 0-.833.407l-.852.851a1.458 1.458 0 0 0 1.03 2.486c.39 0 .755-.152 1.03-.426l.852-.852c.231-.231.363-.522.406-.824l1.04-1.038zm4.295-5.937A2.596 2.596 0 0 0 10.387 1c-.698 0-1.355.272-1.849.766l-.852.851a2.614 2.614 0 0 0-.624 2.688l1.036-1.036c.041-.304.173-.6.407-.833l.852-.852c.275-.275.64-.426 1.03-.426a1.458 1.458 0 0 1 1.03 2.486l-.852.851a1.442 1.442 0 0 1-.824.406l-1.04 1.04a2.596 2.596 0 0 0 2.683-.628l.851-.85a2.616 2.616 0 0 0 0-3.697zm-6.88 6.883a.577.577 0 0 0 .82 0l3.474-3.474a.579.579 0 1 0-.819-.82L5.355 7.83a.579.579 0 0 0 0 .819z"
  })));
}

module.exports = function Buttons(props) {
  var file = props.file,
      uploadInProgressOrComplete = props.uploadInProgressOrComplete,
      canEditFile = props.canEditFile,
      metaFields = props.metaFields,
      showLinkToFileUploadResult = props.showLinkToFileUploadResult,
      showRemoveButton = props.showRemoveButton,
      i18n = props.i18n,
      removeFile = props.removeFile,
      toggleFileCard = props.toggleFileCard,
      openFileEditor = props.openFileEditor,
      log = props.log,
      info = props.info;

  var editAction = function editAction() {
    if (metaFields && metaFields.length > 0) {
      toggleFileCard(true, file.id);
    } else {
      openFileEditor(file);
    }
  };

  return h("div", {
    className: "uppy-Dashboard-Item-actionWrapper"
  }, h(EditButton, {
    i18n: i18n,
    file: file,
    uploadInProgressOrComplete: uploadInProgressOrComplete,
    canEditFile: canEditFile,
    metaFields: metaFields,
    onClick: editAction
  }), showLinkToFileUploadResult && file.uploadURL ? h(CopyLinkButton, {
    file: file,
    i18n: i18n,
    info: info,
    log: log
  }) : null, showRemoveButton ? h(RemoveButton, {
    i18n: i18n,
    info: props.info,
    log: props.log,
    onClick: function onClick() {
      return removeFile(file.id, 'removed-by-user');
    }
  }) : null);
};

},{"../../../utils/copyToClipboard":77,"preact":58}],66:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var prettierBytes = require('@transloadit/prettier-bytes');

var truncateString = require('./../../../../../utils/lib/truncateString');

var renderAcquirerIcon = function renderAcquirerIcon(acquirer, props) {
  return h("span", {
    title: props.i18n('fileSource', {
      name: acquirer.name
    })
  }, acquirer.icon());
};

var renderFileName = function renderFileName(props) {
  // Take up at most 2 lines on any screen
  var maxNameLength; // For very small mobile screens

  if (props.containerWidth <= 352) {
    maxNameLength = 35; // For regular mobile screens
  } else if (props.containerWidth <= 576) {
    maxNameLength = 60; // For desktops
  } else {
    maxNameLength = 30;
  }

  return h("div", {
    className: "uppy-Dashboard-Item-name",
    title: props.file.meta.name
  }, truncateString(props.file.meta.name, maxNameLength));
};

var renderFileSize = function renderFileSize(props) {
  return props.file.size && h("div", {
    className: "uppy-Dashboard-Item-statusSize"
  }, prettierBytes(props.file.size));
};

var ReSelectButton = function ReSelectButton(props) {
  return props.file.isGhost && h("span", null, " \u2022 ", h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-reSelect",
    type: "button",
    onClick: props.toggleAddFilesPanel
  }, props.i18n('reSelect')));
};

var ErrorButton = function ErrorButton(_ref) {
  var file = _ref.file,
      onClick = _ref.onClick;

  if (file.error) {
    return h("span", {
      className: "uppy-Dashboard-Item-errorDetails",
      "aria-label": file.error,
      "data-microtip-position": "bottom",
      "data-microtip-size": "medium",
      role: "tooltip",
      onClick: onClick
    }, "?");
  }

  return null;
};

module.exports = function FileInfo(props) {
  return h("div", {
    className: "uppy-Dashboard-Item-fileInfo",
    "data-uppy-file-source": props.file.source
  }, renderFileName(props), h("div", {
    className: "uppy-Dashboard-Item-status"
  }, renderFileSize(props), ReSelectButton(props), h(ErrorButton, {
    file: props.file,
    onClick: function onClick() {
      alert(props.file.error);
    }
  })));
};

},{"./../../../../../utils/lib/truncateString":201,"@transloadit/prettier-bytes":1,"preact":58}],67:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var FilePreview = require('../../FilePreview');

var getFileTypeIcon = require('../../../utils/getFileTypeIcon');

module.exports = function FilePreviewAndLink(props) {
  return h("div", {
    className: "uppy-Dashboard-Item-previewInnerWrap",
    style: {
      backgroundColor: getFileTypeIcon(props.file.type).color
    }
  }, props.showLinkToFileUploadResult && props.file.uploadURL && h("a", {
    className: "uppy-Dashboard-Item-previewLink",
    href: props.file.uploadURL,
    rel: "noreferrer noopener",
    target: "_blank",
    "aria-label": props.file.meta.name
  }), h(FilePreview, {
    file: props.file
  }));
};

},{"../../../utils/getFileTypeIcon":80,"../../FilePreview":71,"preact":58}],68:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function onPauseResumeCancelRetry(props) {
  if (props.isUploaded) return;

  if (props.error && !props.hideRetryButton) {
    props.retryUpload(props.file.id);
    return;
  }

  if (props.resumableUploads && !props.hidePauseResumeButton) {
    props.pauseUpload(props.file.id);
  } else if (props.individualCancellation && !props.hideCancelButton) {
    props.cancelUpload(props.file.id);
  }
}

function progressIndicatorTitle(props) {
  if (props.isUploaded) {
    return props.i18n('uploadComplete');
  }

  if (props.error) {
    return props.i18n('retryUpload');
  }

  if (props.resumableUploads) {
    if (props.file.isPaused) {
      return props.i18n('resumeUpload');
    }

    return props.i18n('pauseUpload');
  }

  if (props.individualCancellation) {
    return props.i18n('cancelUpload');
  }

  return '';
}

function ProgressIndicatorButton(props) {
  return h("div", {
    className: "uppy-Dashboard-Item-progress"
  }, h("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-progressIndicator",
    type: "button",
    "aria-label": progressIndicatorTitle(props),
    title: progressIndicatorTitle(props),
    onClick: function onClick() {
      return onPauseResumeCancelRetry(props);
    }
  }, props.children));
}

function ProgressCircleContainer(_ref) {
  var children = _ref.children;
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "70",
    height: "70",
    viewBox: "0 0 36 36",
    className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--circle"
  }, children);
}

function ProgressCircle(_ref2) {
  var progress = _ref2.progress;
  // circle length equals 2 * PI * R
  var circleLength = 2 * Math.PI * 15;
  return h("g", null, h("circle", {
    className: "uppy-Dashboard-Item-progressIcon--bg",
    r: "15",
    cx: "18",
    cy: "18",
    "stroke-width": "2",
    fill: "none"
  }), h("circle", {
    className: "uppy-Dashboard-Item-progressIcon--progress",
    r: "15",
    cx: "18",
    cy: "18",
    transform: "rotate(-90, 18, 18)",
    fill: "none",
    "stroke-width": "2",
    "stroke-dasharray": circleLength,
    "stroke-dashoffset": circleLength - circleLength / 100 * progress
  }));
}

module.exports = function FileProgress(props) {
  // Nothing if upload has not started
  if (!props.file.progress.uploadStarted) {
    return null;
  } // Green checkmark when complete


  if (props.isUploaded) {
    return h("div", {
      className: "uppy-Dashboard-Item-progress"
    }, h("div", {
      className: "uppy-Dashboard-Item-progressIndicator"
    }, h(ProgressCircleContainer, null, h("circle", {
      r: "15",
      cx: "18",
      cy: "18",
      fill: "#1bb240"
    }), h("polygon", {
      className: "uppy-Dashboard-Item-progressIcon--check",
      transform: "translate(2, 3)",
      points: "14 22.5 7 15.2457065 8.99985857 13.1732815 14 18.3547104 22.9729883 9 25 11.1005634"
    }))));
  }

  if (props.recoveredState) {
    return;
  } // Retry button for error


  if (props.error && !props.hideRetryButton) {
    return h(ProgressIndicatorButton, props, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--retry",
      width: "28",
      height: "31",
      viewBox: "0 0 16 19"
    }, h("path", {
      d: "M16 11a8 8 0 1 1-8-8v2a6 6 0 1 0 6 6h2z"
    }), h("path", {
      d: "M7.9 3H10v2H7.9z"
    }), h("path", {
      d: "M8.536.5l3.535 3.536-1.414 1.414L7.12 1.914z"
    }), h("path", {
      d: "M10.657 2.621l1.414 1.415L8.536 7.57 7.12 6.157z"
    })));
  } // Pause/resume button for resumable uploads


  if (props.resumableUploads && !props.hidePauseResumeButton) {
    return h(ProgressIndicatorButton, props, h(ProgressCircleContainer, null, h(ProgressCircle, {
      progress: props.file.progress.percentage
    }), props.file.isPaused ? h("polygon", {
      className: "uppy-Dashboard-Item-progressIcon--play",
      transform: "translate(3, 3)",
      points: "12 20 12 10 20 15"
    }) : h("g", {
      className: "uppy-Dashboard-Item-progressIcon--pause",
      transform: "translate(14.5, 13)"
    }, h("rect", {
      x: "0",
      y: "0",
      width: "2",
      height: "10",
      rx: "0"
    }), h("rect", {
      x: "5",
      y: "0",
      width: "2",
      height: "10",
      rx: "0"
    }))));
  } // Cancel button for non-resumable uploads if individualCancellation is supported (not bundled)


  if (!props.resumableUploads && props.individualCancellation && !props.hideCancelButton) {
    return h(ProgressIndicatorButton, props, h(ProgressCircleContainer, null, h(ProgressCircle, {
      progress: props.file.progress.percentage
    }), h("polygon", {
      className: "cancel",
      transform: "translate(2, 2)",
      points: "19.8856516 11.0625 16 14.9481516 12.1019737 11.0625 11.0625 12.1143484 14.9481516 16 11.0625 19.8980263 12.1019737 20.9375 16 17.0518484 19.8856516 20.9375 20.9375 19.8980263 17.0518484 16 20.9375 12"
    })));
  } // Just progress when buttons are disabled


  return h("div", {
    className: "uppy-Dashboard-Item-progress"
  }, h("div", {
    className: "uppy-Dashboard-Item-progressIndicator"
  }, h(ProgressCircleContainer, null, h(ProgressCircle, {
    progress: props.file.progress.percentage
  }))));
};

},{"preact":58}],69:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var classNames = require('classnames');

var shallowEqual = require('is-shallow-equal');

var FilePreviewAndLink = require('./FilePreviewAndLink');

var FileProgress = require('./FileProgress');

var FileInfo = require('./FileInfo');

var Buttons = require('./Buttons');

module.exports = /*#__PURE__*/function (_Component) {
  _inheritsLoose(FileItem, _Component);

  function FileItem() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = FileItem.prototype;

  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    return !shallowEqual(this.props, nextProps);
  };

  _proto.componentDidMount = function componentDidMount() {
    var file = this.props.file;

    if (!file.preview) {
      this.props.handleRequestThumbnail(file);
    }
  } // VirtualList mounts FileItems again and they emit `thumbnail:request`
  // Otherwise thumbnails are broken or missing after Golden Retriever restores files
  ;

  _proto.componentDidUpdate = function componentDidUpdate() {
    var file = this.props.file;

    if (!file.preview) {
      this.props.handleRequestThumbnail(file);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var file = this.props.file;

    if (!file.preview) {
      this.props.handleCancelThumbnail(file);
    }
  };

  _proto.render = function render() {
    var file = this.props.file;
    var isProcessing = file.progress.preprocess || file.progress.postprocess;
    var isUploaded = file.progress.uploadComplete && !isProcessing && !file.error;
    var uploadInProgressOrComplete = file.progress.uploadStarted || isProcessing;
    var uploadInProgress = file.progress.uploadStarted && !file.progress.uploadComplete || isProcessing;
    var error = file.error || false; // File that Golden Retriever was able to partly restore (only meta, not blob),
    // users still need to re-add it, so it’s a ghost

    var isGhost = file.isGhost;
    var showRemoveButton = this.props.individualCancellation ? !isUploaded : !uploadInProgress && !isUploaded;

    if (isUploaded && this.props.showRemoveButtonAfterComplete) {
      showRemoveButton = true;
    }

    var dashboardItemClass = classNames({
      'uppy-Dashboard-Item': true,
      'is-inprogress': uploadInProgress && !this.props.recoveredState,
      'is-processing': isProcessing,
      'is-complete': isUploaded,
      'is-error': !!error,
      'is-resumable': this.props.resumableUploads,
      'is-noIndividualCancellation': !this.props.individualCancellation,
      'is-ghost': isGhost
    });
    return h("div", {
      className: dashboardItemClass,
      id: "uppy_" + file.id,
      role: this.props.role
    }, h("div", {
      className: "uppy-Dashboard-Item-preview"
    }, h(FilePreviewAndLink, {
      file: file,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult
    }), h(FileProgress, {
      file: file,
      error: error,
      isUploaded: isUploaded,
      hideRetryButton: this.props.hideRetryButton,
      hideCancelButton: this.props.hideCancelButton,
      hidePauseResumeButton: this.props.hidePauseResumeButton,
      recoveredState: this.props.recoveredState,
      showRemoveButtonAfterComplete: this.props.showRemoveButtonAfterComplete,
      resumableUploads: this.props.resumableUploads,
      individualCancellation: this.props.individualCancellation,
      pauseUpload: this.props.pauseUpload,
      cancelUpload: this.props.cancelUpload,
      retryUpload: this.props.retryUpload,
      i18n: this.props.i18n
    })), h("div", {
      className: "uppy-Dashboard-Item-fileInfoAndButtons"
    }, h(FileInfo, {
      file: file,
      id: this.props.id,
      acquirers: this.props.acquirers,
      containerWidth: this.props.containerWidth,
      i18n: this.props.i18n,
      toggleAddFilesPanel: this.props.toggleAddFilesPanel
    }), h(Buttons, {
      file: file,
      metaFields: this.props.metaFields,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
      showRemoveButton: showRemoveButton,
      canEditFile: this.props.canEditFile,
      uploadInProgressOrComplete: uploadInProgressOrComplete,
      removeFile: this.props.removeFile,
      toggleFileCard: this.props.toggleFileCard,
      openFileEditor: this.props.openFileEditor,
      i18n: this.props.i18n,
      log: this.props.log,
      info: this.props.info
    })));
  };

  return FileItem;
}(Component);

},{"./Buttons":65,"./FileInfo":66,"./FilePreviewAndLink":67,"./FileProgress":68,"classnames":4,"is-shallow-equal":14,"preact":58}],70:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var FileItem = require('./FileItem/index.js');

var VirtualList = require('./VirtualList');

var classNames = require('classnames');

var _require = require('preact'),
    h = _require.h;

function chunks(list, size) {
  var chunked = [];
  var currentChunk = [];
  list.forEach(function (item, i) {
    if (currentChunk.length < size) {
      currentChunk.push(item);
    } else {
      chunked.push(currentChunk);
      currentChunk = [item];
    }
  });
  if (currentChunk.length) chunked.push(currentChunk);
  return chunked;
}

module.exports = function (props) {
  var noFiles = props.totalFileCount === 0;
  var dashboardFilesClass = classNames('uppy-Dashboard-files', {
    'uppy-Dashboard-files--noFiles': noFiles
  }); // It's not great that this is hardcoded!
  // It's ESPECIALLY not great that this is checking against `itemsPerRow`!

  var rowHeight = props.itemsPerRow === 1 // Mobile
  ? 71 // 190px height + 2 * 5px margin
  : 200;
  var fileProps = {
    // FIXME This is confusing, it's actually the Dashboard's plugin ID
    id: props.id,
    error: props.error,
    // TODO move this to context
    i18n: props.i18n,
    log: props.log,
    info: props.info,
    // features
    acquirers: props.acquirers,
    resumableUploads: props.resumableUploads,
    individualCancellation: props.individualCancellation,
    // visual options
    hideRetryButton: props.hideRetryButton,
    hidePauseResumeButton: props.hidePauseResumeButton,
    hideCancelButton: props.hideCancelButton,
    showLinkToFileUploadResult: props.showLinkToFileUploadResult,
    showRemoveButtonAfterComplete: props.showRemoveButtonAfterComplete,
    isWide: props.isWide,
    metaFields: props.metaFields,
    recoveredState: props.recoveredState,
    // callbacks
    retryUpload: props.retryUpload,
    pauseUpload: props.pauseUpload,
    cancelUpload: props.cancelUpload,
    toggleFileCard: props.toggleFileCard,
    removeFile: props.removeFile,
    handleRequestThumbnail: props.handleRequestThumbnail,
    handleCancelThumbnail: props.handleCancelThumbnail
  };

  var sortByGhostComesFirst = function sortByGhostComesFirst(file1, file2) {
    return props.files[file2].isGhost - props.files[file1].isGhost;
  }; // Sort files by file.isGhost, ghost files first, only if recoveredState is present


  var files = Object.keys(props.files);
  if (props.recoveredState) files.sort(sortByGhostComesFirst);
  var rows = chunks(files, props.itemsPerRow);

  function renderRow(row) {
    return (// The `role="presentation` attribute ensures that the list items are properly associated with the `VirtualList` element
      // We use the first file ID as the key—this should not change across scroll rerenders
      h("div", {
        role: "presentation",
        key: row[0]
      }, row.map(function (fileID) {
        return h(FileItem, _extends({
          key: fileID
        }, fileProps, {
          role: "listitem",
          openFileEditor: props.openFileEditor,
          canEditFile: props.canEditFile,
          toggleAddFilesPanel: props.toggleAddFilesPanel,
          file: props.files[fileID]
        }));
      }))
    );
  }

  return h(VirtualList, {
    class: dashboardFilesClass,
    role: "list",
    data: rows,
    renderRow: renderRow,
    rowHeight: rowHeight
  });
};

},{"./FileItem/index.js":69,"./VirtualList":75,"classnames":4,"preact":58}],71:[function(require,module,exports){
var getFileTypeIcon = require('../utils/getFileTypeIcon');

var _require = require('preact'),
    h = _require.h;

module.exports = function FilePreview(props) {
  var file = props.file;

  if (file.preview) {
    return h("img", {
      className: "uppy-Dashboard-Item-previewImg",
      alt: file.name,
      src: file.preview
    });
  }

  var _getFileTypeIcon = getFileTypeIcon(file.type),
      color = _getFileTypeIcon.color,
      icon = _getFileTypeIcon.icon;

  return h("div", {
    className: "uppy-Dashboard-Item-previewIconWrap"
  }, h("span", {
    className: "uppy-Dashboard-Item-previewIcon",
    style: {
      color: color
    }
  }, icon), h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-Dashboard-Item-previewIconBg",
    width: "58",
    height: "76",
    viewBox: "0 0 58 76"
  }, h("rect", {
    fill: "#FFF",
    width: "58",
    height: "76",
    rx: "3",
    fillRule: "evenodd"
  })));
};

},{"../utils/getFileTypeIcon":80,"preact":58}],72:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

var ignoreEvent = require('../utils/ignoreEvent.js');

function PickerPanelContent(props) {
  return h("div", {
    className: classNames('uppy-DashboardContent-panel', props.className),
    role: "tabpanel",
    "data-uppy-panelType": "PickerPanel",
    id: "uppy-DashboardContent-panel--" + props.activePickerPanel.id,
    onDragOver: ignoreEvent,
    onDragLeave: ignoreEvent,
    onDrop: ignoreEvent,
    onPaste: ignoreEvent
  }, h("div", {
    className: "uppy-DashboardContent-bar"
  }, h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18n('importFrom', {
    name: props.activePickerPanel.name
  })), h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: props.hideAllPanels
  }, props.i18n('cancel'))), h("div", {
    className: "uppy-DashboardContent-panelBody"
  }, props.getPlugin(props.activePickerPanel.id).render(props.state)));
}

module.exports = PickerPanelContent;

},{"../utils/ignoreEvent.js":81,"classnames":4,"preact":58}],73:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var uploadStates = {
  STATE_ERROR: 'error',
  STATE_WAITING: 'waiting',
  STATE_PREPROCESSING: 'preprocessing',
  STATE_UPLOADING: 'uploading',
  STATE_POSTPROCESSING: 'postprocessing',
  STATE_COMPLETE: 'complete',
  STATE_PAUSED: 'paused'
};

function getUploadingState(isAllErrored, isAllComplete, isAllPaused, files) {
  if (files === void 0) {
    files = {};
  }

  if (isAllErrored) {
    return uploadStates.STATE_ERROR;
  }

  if (isAllComplete) {
    return uploadStates.STATE_COMPLETE;
  }

  if (isAllPaused) {
    return uploadStates.STATE_PAUSED;
  }

  var state = uploadStates.STATE_WAITING;
  var fileIDs = Object.keys(files);

  for (var i = 0; i < fileIDs.length; i++) {
    var progress = files[fileIDs[i]].progress; // If ANY files are being uploaded right now, show the uploading state.

    if (progress.uploadStarted && !progress.uploadComplete) {
      return uploadStates.STATE_UPLOADING;
    } // If files are being preprocessed AND postprocessed at this time, we show the
    // preprocess state. If any files are being uploaded we show uploading.


    if (progress.preprocess && state !== uploadStates.STATE_UPLOADING) {
      state = uploadStates.STATE_PREPROCESSING;
    } // If NO files are being preprocessed or uploaded right now, but some files are
    // being postprocessed, show the postprocess state.


    if (progress.postprocess && state !== uploadStates.STATE_UPLOADING && state !== uploadStates.STATE_PREPROCESSING) {
      state = uploadStates.STATE_POSTPROCESSING;
    }
  }

  return state;
}

function UploadStatus(props) {
  var uploadingState = getUploadingState(props.isAllErrored, props.isAllComplete, props.isAllPaused, props.files);

  switch (uploadingState) {
    case 'uploading':
      return props.i18n('uploadingXFiles', {
        smart_count: props.inProgressNotPausedFiles.length
      });

    case 'preprocessing':
    case 'postprocessing':
      return props.i18n('processingXFiles', {
        smart_count: props.processingFiles.length
      });

    case 'paused':
      return props.i18n('uploadPaused');

    case 'waiting':
      return props.i18n('xFilesSelected', {
        smart_count: props.newFiles.length
      });

    case 'complete':
      return props.i18n('uploadComplete');
  }
}

function PanelTopBar(props) {
  var allowNewUpload = props.allowNewUpload; // TODO maybe this should be done in ../index.js, then just pass that down as `allowNewUpload`

  if (allowNewUpload && props.maxNumberOfFiles) {
    allowNewUpload = props.totalFileCount < props.maxNumberOfFiles;
  }

  return h("div", {
    className: "uppy-DashboardContent-bar"
  }, !props.isAllComplete && !props.hideCancelButton ? h("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: props.cancelAll
  }, props.i18n('cancel')) : h("div", null), h("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, h(UploadStatus, props)), allowNewUpload ? h("button", {
    className: "uppy-DashboardContent-addMore",
    type: "button",
    "aria-label": props.i18n('addMoreFiles'),
    title: props.i18n('addMoreFiles'),
    onClick: function onClick() {
      return props.toggleAddFilesPanel(true);
    }
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "15",
    height: "15",
    viewBox: "0 0 15 15"
  }, h("path", {
    d: "M8 6.5h6a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H8v6a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V8h-6a.5.5 0 0 1-.5-.5V7a.5.5 0 0 1 .5-.5h6v-6A.5.5 0 0 1 7 0h.5a.5.5 0 0 1 .5.5v6z"
  })), h("span", {
    className: "uppy-DashboardContent-addMoreCaption"
  }, props.i18n('addMore'))) : h("div", null));
}

module.exports = PanelTopBar;

},{"preact":58}],74:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    cloneElement = _require.cloneElement,
    Component = _require.Component;

var classNames = require('classnames');

var transitionName = 'uppy-transition-slideDownUp';
var duration = 250;
/**
 * Vertical slide transition.
 *
 * This can take a _single_ child component, which _must_ accept a `className` prop.
 *
 * Currently this is specific to the `uppy-transition-slideDownUp` transition,
 * but it should be simple to extend this for any type of single-element
 * transition by setting the CSS name and duration as props.
 */

var Slide = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Slide, _Component);

  function Slide(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.state = {
      cachedChildren: null,
      className: ''
    };
    return _this;
  }

  var _proto = Slide.prototype;

  _proto.componentWillUpdate = function componentWillUpdate(nextProps) {
    var _this2 = this;

    var cachedChildren = this.state.cachedChildren;
    var child = nextProps.children[0];
    if (cachedChildren === child) return;
    var patch = {
      cachedChildren: child
    }; // Enter transition

    if (child && !cachedChildren) {
      patch.className = transitionName + "-enter";
      cancelAnimationFrame(this.animationFrame);
      clearTimeout(this.leaveTimeout);
      this.leaveTimeout = undefined;
      this.animationFrame = requestAnimationFrame(function () {
        // Force it to render before we add the active class
        _this2.base.getBoundingClientRect();

        _this2.setState({
          className: transitionName + "-enter " + transitionName + "-enter-active"
        });

        _this2.enterTimeout = setTimeout(function () {
          _this2.setState({
            className: ''
          });
        }, duration);
      });
    } // Leave transition


    if (cachedChildren && !child && this.leaveTimeout === undefined) {
      patch.cachedChildren = cachedChildren;
      patch.className = transitionName + "-leave";
      cancelAnimationFrame(this.animationFrame);
      clearTimeout(this.enterTimeout);
      this.enterTimeout = undefined;
      this.animationFrame = requestAnimationFrame(function () {
        _this2.setState({
          className: transitionName + "-leave " + transitionName + "-leave-active"
        });

        _this2.leaveTimeout = setTimeout(function () {
          _this2.setState({
            cachedChildren: null,
            className: ''
          });
        }, duration);
      });
    }

    this.setState(patch);
  };

  _proto.render = function render() {
    var _this$state = this.state,
        cachedChildren = _this$state.cachedChildren,
        className = _this$state.className;

    if (!cachedChildren) {
      return null;
    }

    return cloneElement(cachedChildren, {
      className: classNames(className, cachedChildren.attributes.className)
    });
  };

  return Slide;
}(Component);

module.exports = Slide;

},{"classnames":4,"preact":58}],75:[function(require,module,exports){
var _excluded = ["data", "rowHeight", "renderRow", "overscanCount", "sync"];

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Adapted from preact-virtual-list: https://github.com/developit/preact-virtual-list
 *
 * © 2016 Jason Miller
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Adaptations:
 * - Added role=presentation to helper elements
 * - Tweaked styles for Uppy's Dashboard use case
 */
var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var STYLE_INNER = {
  position: 'relative',
  // Disabled for our use case: the wrapper elements around FileList already deal with overflow,
  // and this additional property would hide things that we want to show.
  //
  // overflow: 'hidden',
  width: '100%',
  minHeight: '100%'
};
var STYLE_CONTENT = {
  position: 'absolute',
  top: 0,
  left: 0,
  // Because the `top` value gets set to some offset, this `height` being 100% would make the scrollbar
  // stretch far beyond the content. For our use case, the content div actually can get its height from
  // the elements inside it, so we don't need to specify a `height` property at all.
  //
  // height: '100%',
  width: '100%',
  overflow: 'visible'
};

var VirtualList = /*#__PURE__*/function (_Component) {
  _inheritsLoose(VirtualList, _Component);

  function VirtualList(props) {
    var _this;

    _this = _Component.call(this, props) || this; // The currently focused node, used to retain focus when the visible rows change.
    // To avoid update loops, this should not cause state updates, so it's kept as a plain property.

    _this.handleResize = function () {
      _this.resize();
    };

    _this.handleScroll = function () {
      _this.setState({
        offset: _this.base.scrollTop
      });

      if (_this.props.sync) {
        _this.forceUpdate();
      }
    };

    _this.focusElement = null;
    _this.state = {
      offset: 0,
      height: 0
    };
    return _this;
  }

  var _proto = VirtualList.prototype;

  _proto.resize = function resize() {
    if (this.state.height !== this.base.offsetHeight) {
      this.setState({
        height: this.base.offsetHeight
      });
    }
  };

  _proto.componentWillUpdate = function componentWillUpdate() {
    if (this.base.contains(document.activeElement)) {
      this.focusElement = document.activeElement;
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    // Maintain focus when rows are added and removed.
    if (this.focusElement && this.focusElement.parentNode && document.activeElement !== this.focusElement) {
      this.focusElement.focus();
    }

    this.focusElement = null;
    this.resize();
  };

  _proto.componentDidMount = function componentDidMount() {
    this.resize();
    window.addEventListener('resize', this.handleResize);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
  };

  _proto.render = function render(_ref) {
    var data = _ref.data,
        rowHeight = _ref.rowHeight,
        renderRow = _ref.renderRow,
        _ref$overscanCount = _ref.overscanCount,
        overscanCount = _ref$overscanCount === void 0 ? 10 : _ref$overscanCount,
        sync = _ref.sync,
        props = _objectWithoutPropertiesLoose(_ref, _excluded);

    var _this$state = this.state,
        offset = _this$state.offset,
        height = _this$state.height; // first visible row index

    var start = Math.floor(offset / rowHeight); // actual number of visible rows (without overscan)

    var visibleRowCount = Math.floor(height / rowHeight); // Overscan: render blocks of rows modulo an overscan row count
    // This dramatically reduces DOM writes during scrolling

    if (overscanCount) {
      start = Math.max(0, start - start % overscanCount);
      visibleRowCount += overscanCount;
    } // last visible + overscan row index + padding to allow keyboard focus to travel past the visible area


    var end = start + visibleRowCount + 4; // data slice currently in viewport plus overscan items

    var selection = data.slice(start, end);

    var styleInner = _extends({}, STYLE_INNER, {
      height: data.length * rowHeight
    });

    var styleContent = _extends({}, STYLE_CONTENT, {
      top: start * rowHeight
    }); // The `role="presentation"` attributes ensure that these wrapper elements are not treated as list
    // items by accessibility and outline tools.


    return h("div", _extends({
      onScroll: this.handleScroll
    }, props), h("div", {
      role: "presentation",
      style: styleInner
    }, h("div", {
      role: "presentation",
      style: styleContent
    }, selection.map(renderRow))));
  };

  return VirtualList;
}(Component);

module.exports = VirtualList;

},{"preact":58}],76:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h;

var _require2 = require('./../../core'),
    Plugin = _require2.Plugin;

var Translator = require('./../../utils/lib/Translator');

var DashboardUI = require('./components/Dashboard');

var StatusBar = require('./../../status-bar');

var Informer = require('./../../informer');

var ThumbnailGenerator = require('./../../thumbnail-generator');

var findAllDOMElements = require('./../../utils/lib/findAllDOMElements');

var toArray = require('./../../utils/lib/toArray');

var getDroppedFiles = require('./../../utils/lib/getDroppedFiles');

var getTextDirection = require('./../../utils/lib/getTextDirection');

var trapFocus = require('./utils/trapFocus');

var cuid = require('cuid');

var ResizeObserver = require('resize-observer-polyfill').default || require('resize-observer-polyfill');

var createSuperFocus = require('./utils/createSuperFocus');

var memoize = require('memoize-one').default || require('memoize-one');

var FOCUSABLE_ELEMENTS = require('./../../utils/lib/FOCUSABLE_ELEMENTS');

var TAB_KEY = 9;
var ESC_KEY = 27;

function createPromise() {
  var o = {};
  o.promise = new Promise(function (resolve, reject) {
    o.resolve = resolve;
    o.reject = reject;
  });
  return o;
}

function defaultPickerIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "30",
    height: "30",
    viewBox: "0 0 30 30"
  }, h("path", {
    d: "M15 30c8.284 0 15-6.716 15-15 0-8.284-6.716-15-15-15C6.716 0 0 6.716 0 15c0 8.284 6.716 15 15 15zm4.258-12.676v6.846h-8.426v-6.846H5.204l9.82-12.364 9.82 12.364H19.26z"
  }));
}
/**
 * Dashboard UI with previews, metadata editing, tabs for various services and more
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Dashboard, _Plugin);

  function Dashboard(uppy, _opts) {
    var _this;

    _this = _Plugin.call(this, uppy, _opts) || this;

    _this.setOptions = function (newOpts) {
      _Plugin.prototype.setOptions.call(_assertThisInitialized(_this), newOpts);

      _this.i18nInit();
    };

    _this.i18nInit = function () {
      _this.translator = new Translator([_this.defaultLocale, _this.uppy.locale, _this.opts.locale]);
      _this.i18n = _this.translator.translate.bind(_this.translator);
      _this.i18nArray = _this.translator.translateArray.bind(_this.translator);

      _this.setPluginState(); // so that UI re-renders and we see the updated locale

    };

    _this.removeTarget = function (plugin) {
      var pluginState = _this.getPluginState(); // filter out the one we want to remove


      var newTargets = pluginState.targets.filter(function (target) {
        return target.id !== plugin.id;
      });

      _this.setPluginState({
        targets: newTargets
      });
    };

    _this.addTarget = function (plugin) {
      var callerPluginId = plugin.id || plugin.constructor.name;
      var callerPluginName = plugin.title || callerPluginId;
      var callerPluginType = plugin.type;

      if (callerPluginType !== 'acquirer' && callerPluginType !== 'progressindicator' && callerPluginType !== 'editor') {
        var msg = 'Dashboard: can only be targeted by plugins of types: acquirer, progressindicator, editor';

        _this.uppy.log(msg, 'error');

        return;
      }

      var target = {
        id: callerPluginId,
        name: callerPluginName,
        type: callerPluginType
      };

      var state = _this.getPluginState();

      var newTargets = state.targets.slice();
      newTargets.push(target);

      _this.setPluginState({
        targets: newTargets
      });

      return _this.el;
    };

    _this.hideAllPanels = function () {
      var update = {
        activePickerPanel: false,
        showAddFilesPanel: false,
        activeOverlayType: null,
        fileCardFor: null,
        showFileEditor: false
      };

      var current = _this.getPluginState();

      if (current.activePickerPanel === update.activePickerPanel && current.showAddFilesPanel === update.showAddFilesPanel && current.showFileEditor === update.showFileEditor && current.activeOverlayType === update.activeOverlayType) {
        // avoid doing a state update if nothing changed
        return;
      }

      _this.setPluginState(update);
    };

    _this.showPanel = function (id) {
      var _this$getPluginState = _this.getPluginState(),
          targets = _this$getPluginState.targets;

      var activePickerPanel = targets.filter(function (target) {
        return target.type === 'acquirer' && target.id === id;
      })[0];

      _this.setPluginState({
        activePickerPanel: activePickerPanel,
        activeOverlayType: 'PickerPanel'
      });
    };

    _this.canEditFile = function (file) {
      var _this$getPluginState2 = _this.getPluginState(),
          targets = _this$getPluginState2.targets;

      var editors = _this._getEditors(targets);

      return editors.some(function (target) {
        return _this.uppy.getPlugin(target.id).canEditFile(file);
      });
    };

    _this.openFileEditor = function (file) {
      var _this$getPluginState3 = _this.getPluginState(),
          targets = _this$getPluginState3.targets;

      var editors = _this._getEditors(targets);

      _this.setPluginState({
        showFileEditor: true,
        fileCardFor: file.id || null,
        activeOverlayType: 'FileEditor'
      });

      editors.forEach(function (editor) {
        _this.uppy.getPlugin(editor.id).selectFile(file);
      });
    };

    _this.saveFileEditor = function () {
      var _this$getPluginState4 = _this.getPluginState(),
          targets = _this$getPluginState4.targets;

      var editors = _this._getEditors(targets);

      editors.forEach(function (editor) {
        _this.uppy.getPlugin(editor.id).save();
      });

      _this.hideAllPanels();
    };

    _this.openModal = function () {
      var _createPromise = createPromise(),
          promise = _createPromise.promise,
          resolve = _createPromise.resolve; // save scroll position


      _this.savedScrollPosition = window.pageYOffset; // save active element, so we can restore focus when modal is closed

      _this.savedActiveElement = document.activeElement;

      if (_this.opts.disablePageScrollWhenModalOpen) {
        document.body.classList.add('uppy-Dashboard-isFixed');
      }

      if (_this.opts.animateOpenClose && _this.getPluginState().isClosing) {
        var handler = function handler() {
          _this.setPluginState({
            isHidden: false
          });

          _this.el.removeEventListener('animationend', handler, false);

          resolve();
        };

        _this.el.addEventListener('animationend', handler, false);
      } else {
        _this.setPluginState({
          isHidden: false
        });

        resolve();
      }

      if (_this.opts.browserBackButtonClose) {
        _this.updateBrowserHistory();
      } // handle ESC and TAB keys in modal dialog


      document.addEventListener('keydown', _this.handleKeyDownInModal);

      _this.uppy.emit('dashboard:modal-open');

      return promise;
    };

    _this.closeModal = function (opts) {
      if (opts === void 0) {
        opts = {};
      }

      var _opts2 = opts,
          _opts2$manualClose = _opts2.manualClose,
          manualClose = _opts2$manualClose === void 0 ? true : _opts2$manualClose;

      var _this$getPluginState5 = _this.getPluginState(),
          isHidden = _this$getPluginState5.isHidden,
          isClosing = _this$getPluginState5.isClosing;

      if (isHidden || isClosing) {
        // short-circuit if animation is ongoing
        return;
      }

      var _createPromise2 = createPromise(),
          promise = _createPromise2.promise,
          resolve = _createPromise2.resolve;

      if (_this.opts.disablePageScrollWhenModalOpen) {
        document.body.classList.remove('uppy-Dashboard-isFixed');
      }

      if (_this.opts.animateOpenClose) {
        _this.setPluginState({
          isClosing: true
        });

        var handler = function handler() {
          _this.setPluginState({
            isHidden: true,
            isClosing: false
          });

          _this.superFocus.cancel();

          _this.savedActiveElement.focus();

          _this.el.removeEventListener('animationend', handler, false);

          resolve();
        };

        _this.el.addEventListener('animationend', handler, false);
      } else {
        _this.setPluginState({
          isHidden: true
        });

        _this.superFocus.cancel();

        _this.savedActiveElement.focus();

        resolve();
      } // handle ESC and TAB keys in modal dialog


      document.removeEventListener('keydown', _this.handleKeyDownInModal);

      if (manualClose) {
        if (_this.opts.browserBackButtonClose) {
          // Make sure that the latest entry in the history state is our modal name
          if (history.state && history.state[_this.modalName]) {
            // Go back in history to clear out the entry we created (ultimately closing the modal)
            history.go(-1);
          }
        }
      }

      _this.uppy.emit('dashboard:modal-closed');

      return promise;
    };

    _this.isModalOpen = function () {
      return !_this.getPluginState().isHidden || false;
    };

    _this.requestCloseModal = function () {
      if (_this.opts.onRequestCloseModal) {
        return _this.opts.onRequestCloseModal();
      }

      return _this.closeModal();
    };

    _this.setDarkModeCapability = function (isDarkModeOn) {
      var _this$uppy$getState = _this.uppy.getState(),
          capabilities = _this$uppy$getState.capabilities;

      _this.uppy.setState({
        capabilities: _extends({}, capabilities, {
          darkMode: isDarkModeOn
        })
      });
    };

    _this.handleSystemDarkModeChange = function (event) {
      var isDarkModeOnNow = event.matches;

      _this.uppy.log("[Dashboard] Dark mode is " + (isDarkModeOnNow ? 'on' : 'off'));

      _this.setDarkModeCapability(isDarkModeOnNow);
    };

    _this.toggleFileCard = function (show, fileID) {
      var file = _this.uppy.getFile(fileID);

      if (show) {
        _this.uppy.emit('dashboard:file-edit-start', file);
      } else {
        _this.uppy.emit('dashboard:file-edit-complete', file);
      }

      _this.setPluginState({
        fileCardFor: show ? fileID : null,
        activeOverlayType: show ? 'FileCard' : null
      });
    };

    _this.toggleAddFilesPanel = function (show) {
      _this.setPluginState({
        showAddFilesPanel: show,
        activeOverlayType: show ? 'AddFiles' : null
      });
    };

    _this.addFiles = function (files) {
      var descriptors = files.map(function (file) {
        return {
          source: _this.id,
          name: file.name,
          type: file.type,
          data: file,
          meta: {
            // path of the file relative to the ancestor directory the user selected.
            // e.g. 'docs/Old Prague/airbnb.pdf'
            relativePath: file.relativePath || null
          }
        };
      });

      try {
        _this.uppy.addFiles(descriptors);
      } catch (err) {
        _this.uppy.log(err);
      }
    };

    _this.startListeningToResize = function () {
      // Watch for Dashboard container (`.uppy-Dashboard-inner`) resize
      // and update containerWidth/containerHeight in plugin state accordingly.
      // Emits first event on initialization.
      _this.resizeObserver = new ResizeObserver(function (entries, observer) {
        var uppyDashboardInnerEl = entries[0];
        var _uppyDashboardInnerEl = uppyDashboardInnerEl.contentRect,
            width = _uppyDashboardInnerEl.width,
            height = _uppyDashboardInnerEl.height;

        _this.uppy.log("[Dashboard] resized: " + width + " / " + height, 'debug');

        _this.setPluginState({
          containerWidth: width,
          containerHeight: height,
          areInsidesReadyToBeVisible: true
        });
      });

      _this.resizeObserver.observe(_this.el.querySelector('.uppy-Dashboard-inner')); // If ResizeObserver fails to emit an event telling us what size to use - default to the mobile view


      _this.makeDashboardInsidesVisibleAnywayTimeout = setTimeout(function () {
        var pluginState = _this.getPluginState();

        var isModalAndClosed = !_this.opts.inline && pluginState.isHidden;

        if ( // if ResizeObserver hasn't yet fired,
        !pluginState.areInsidesReadyToBeVisible // and it's not due to the modal being closed
        && !isModalAndClosed) {
          _this.uppy.log("[Dashboard] resize event didn't fire on time: defaulted to mobile layout", 'debug');

          _this.setPluginState({
            areInsidesReadyToBeVisible: true
          });
        }
      }, 1000);
    };

    _this.stopListeningToResize = function () {
      _this.resizeObserver.disconnect();

      clearTimeout(_this.makeDashboardInsidesVisibleAnywayTimeout);
    };

    _this.recordIfFocusedOnUppyRecently = function (event) {
      if (_this.el.contains(event.target)) {
        _this.ifFocusedOnUppyRecently = true;
      } else {
        _this.ifFocusedOnUppyRecently = false; // ___Why run this.superFocus.cancel here when it already runs in superFocusOnEachUpdate?
        //    Because superFocus is debounced, when we move from Uppy to some other element on the page,
        //    previously run superFocus sometimes hits and moves focus back to Uppy.

        _this.superFocus.cancel();
      }
    };

    _this.disableAllFocusableElements = function (disable) {
      var focusableNodes = toArray(_this.el.querySelectorAll(FOCUSABLE_ELEMENTS));

      if (disable) {
        focusableNodes.forEach(function (node) {
          // save previous tabindex in a data-attribute, to restore when enabling
          var currentTabIndex = node.getAttribute('tabindex');

          if (currentTabIndex) {
            node.dataset.inertTabindex = currentTabIndex;
          }

          node.setAttribute('tabindex', '-1');
        });
      } else {
        focusableNodes.forEach(function (node) {
          if ('inertTabindex' in node.dataset) {
            node.setAttribute('tabindex', node.dataset.inertTabindex);
          } else {
            node.removeAttribute('tabindex');
          }
        });
      }

      _this.dashboardIsDisabled = disable;
    };

    _this.updateBrowserHistory = function () {
      // Ensure history state does not already contain our modal name to avoid double-pushing
      if (!history.state || !history.state[_this.modalName]) {
        var _extends2;

        // Push to history so that the page is not lost on browser back button press
        history.pushState(_extends({}, history.state, (_extends2 = {}, _extends2[_this.modalName] = true, _extends2)), '');
      } // Listen for back button presses


      window.addEventListener('popstate', _this.handlePopState, false);
    };

    _this.handlePopState = function (event) {
      // Close the modal if the history state no longer contains our modal name
      if (_this.isModalOpen() && (!event.state || !event.state[_this.modalName])) {
        _this.closeModal({
          manualClose: false
        });
      } // When the browser back button is pressed and uppy is now the latest entry in the history but the modal is closed, fix the history by removing the uppy history entry
      // This occurs when another entry is added into the history state while the modal is open, and then the modal gets manually closed
      // Solves PR #575 (https://github.com/transloadit/uppy/pull/575)


      if (!_this.isModalOpen() && event.state && event.state[_this.modalName]) {
        history.go(-1);
      }
    };

    _this.handleKeyDownInModal = function (event) {
      // close modal on esc key press
      if (event.keyCode === ESC_KEY) _this.requestCloseModal(event); // trap focus on tab key press

      if (event.keyCode === TAB_KEY) trapFocus.forModal(event, _this.getPluginState().activeOverlayType, _this.el);
    };

    _this.handleClickOutside = function () {
      if (_this.opts.closeModalOnClickOutside) _this.requestCloseModal();
    };

    _this.handlePaste = function (event) {
      // 1. Let any acquirer plugin (Url/Webcam/etc.) handle pastes to the root
      _this.uppy.iteratePlugins(function (plugin) {
        if (plugin.type === 'acquirer') {
          // Every Plugin with .type acquirer can define handleRootPaste(event)
          plugin.handleRootPaste && plugin.handleRootPaste(event);
        }
      }); // 2. Add all dropped files


      var files = toArray(event.clipboardData.files);

      _this.addFiles(files);
    };

    _this.handleInputChange = function (event) {
      event.preventDefault();
      var files = toArray(event.target.files);

      _this.addFiles(files);
    };

    _this.handleDragOver = function (event) {
      event.preventDefault();
      event.stopPropagation();

      if (_this.opts.disabled || _this.opts.disableLocalFiles) {
        return;
      } // 1. Add a small (+) icon on drop
      // (and prevent browsers from interpreting this as files being _moved_ into the browser, https://github.com/transloadit/uppy/issues/1978)


      event.dataTransfer.dropEffect = 'copy';
      clearTimeout(_this.removeDragOverClassTimeout);

      _this.setPluginState({
        isDraggingOver: true
      });
    };

    _this.handleDragLeave = function (event) {
      event.preventDefault();
      event.stopPropagation();

      if (_this.opts.disabled || _this.opts.disableLocalFiles) {
        return;
      }

      clearTimeout(_this.removeDragOverClassTimeout); // Timeout against flickering, this solution is taken from drag-drop library. Solution with 'pointer-events: none' didn't work across browsers.

      _this.removeDragOverClassTimeout = setTimeout(function () {
        _this.setPluginState({
          isDraggingOver: false
        });
      }, 50);
    };

    _this.handleDrop = function (event, dropCategory) {
      event.preventDefault();
      event.stopPropagation();

      if (_this.opts.disabled || _this.opts.disableLocalFiles) {
        return;
      }

      clearTimeout(_this.removeDragOverClassTimeout); // 2. Remove dragover class

      _this.setPluginState({
        isDraggingOver: false
      }); // 3. Let any acquirer plugin (Url/Webcam/etc.) handle drops to the root


      _this.uppy.iteratePlugins(function (plugin) {
        if (plugin.type === 'acquirer') {
          // Every Plugin with .type acquirer can define handleRootDrop(event)
          plugin.handleRootDrop && plugin.handleRootDrop(event);
        }
      }); // 4. Add all dropped files


      var executedDropErrorOnce = false;

      var logDropError = function logDropError(error) {
        _this.uppy.log(error, 'error'); // In practice all drop errors are most likely the same, so let's just show one to avoid overwhelming the user


        if (!executedDropErrorOnce) {
          _this.uppy.info(error.message, 'error');

          executedDropErrorOnce = true;
        }
      };

      getDroppedFiles(event.dataTransfer, {
        logDropError: logDropError
      }).then(function (files) {
        if (files.length > 0) {
          _this.uppy.log('[Dashboard] Files were dropped');

          _this.addFiles(files);
        }
      });
    };

    _this.handleRequestThumbnail = function (file) {
      if (!_this.opts.waitForThumbnailsBeforeUpload) {
        _this.uppy.emit('thumbnail:request', file);
      }
    };

    _this.handleCancelThumbnail = function (file) {
      if (!_this.opts.waitForThumbnailsBeforeUpload) {
        _this.uppy.emit('thumbnail:cancel', file);
      }
    };

    _this.handleKeyDownInInline = function (event) {
      // Trap focus on tab key press.
      if (event.keyCode === TAB_KEY) trapFocus.forInline(event, _this.getPluginState().activeOverlayType, _this.el);
    };

    _this.handlePasteOnBody = function (event) {
      var isFocusInOverlay = _this.el.contains(document.activeElement);

      if (isFocusInOverlay) {
        _this.handlePaste(event);
      }
    };

    _this.handleComplete = function (_ref) {
      var failed = _ref.failed;

      if (_this.opts.closeAfterFinish && failed.length === 0) {
        // All uploads are done
        _this.requestCloseModal();
      }
    };

    _this.handleCancelRestore = function () {
      _this.uppy.emit('restore-canceled');
    };

    _this._openFileEditorWhenFilesAdded = function (files) {
      var firstFile = files[0];

      if (_this.canEditFile(firstFile)) {
        _this.openFileEditor(firstFile);
      }
    };

    _this.initEvents = function () {
      // Modal open button
      if (_this.opts.trigger && !_this.opts.inline) {
        var showModalTrigger = findAllDOMElements(_this.opts.trigger);

        if (showModalTrigger) {
          showModalTrigger.forEach(function (trigger) {
            return trigger.addEventListener('click', _this.openModal);
          });
        } else {
          _this.uppy.log('Dashboard modal trigger not found. Make sure `trigger` is set in Dashboard options, unless you are planning to call `dashboard.openModal()` method yourself', 'warning');
        }
      }

      _this.startListeningToResize();

      document.addEventListener('paste', _this.handlePasteOnBody);

      _this.uppy.on('plugin-remove', _this.removeTarget);

      _this.uppy.on('file-added', _this.hideAllPanels);

      _this.uppy.on('dashboard:modal-closed', _this.hideAllPanels);

      _this.uppy.on('file-editor:complete', _this.hideAllPanels);

      _this.uppy.on('complete', _this.handleComplete); // ___Why fire on capture?
      //    Because this.ifFocusedOnUppyRecently needs to change before onUpdate() fires.


      document.addEventListener('focus', _this.recordIfFocusedOnUppyRecently, true);
      document.addEventListener('click', _this.recordIfFocusedOnUppyRecently, true);

      if (_this.opts.inline) {
        _this.el.addEventListener('keydown', _this.handleKeyDownInInline);
      }

      if (_this.opts.autoOpenFileEditor) {
        _this.uppy.on('files-added', _this._openFileEditorWhenFilesAdded);
      }
    };

    _this.removeEvents = function () {
      var showModalTrigger = findAllDOMElements(_this.opts.trigger);

      if (!_this.opts.inline && showModalTrigger) {
        showModalTrigger.forEach(function (trigger) {
          return trigger.removeEventListener('click', _this.openModal);
        });
      }

      _this.stopListeningToResize();

      document.removeEventListener('paste', _this.handlePasteOnBody);
      window.removeEventListener('popstate', _this.handlePopState, false);

      _this.uppy.off('plugin-remove', _this.removeTarget);

      _this.uppy.off('file-added', _this.hideAllPanels);

      _this.uppy.off('dashboard:modal-closed', _this.hideAllPanels);

      _this.uppy.off('file-editor:complete', _this.hideAllPanels);

      _this.uppy.off('complete', _this.handleComplete);

      document.removeEventListener('focus', _this.recordIfFocusedOnUppyRecently);
      document.removeEventListener('click', _this.recordIfFocusedOnUppyRecently);

      if (_this.opts.inline) {
        _this.el.removeEventListener('keydown', _this.handleKeyDownInInline);
      }

      if (_this.opts.autoOpenFileEditor) {
        _this.uppy.off('files-added', _this._openFileEditorWhenFilesAdded);
      }
    };

    _this.superFocusOnEachUpdate = function () {
      var isFocusInUppy = _this.el.contains(document.activeElement); // When focus is lost on the page (== focus is on body for most browsers, or focus is null for IE11)


      var isFocusNowhere = document.activeElement === document.body || document.activeElement === null;

      var isInformerHidden = _this.uppy.getState().info.isHidden;

      var isModal = !_this.opts.inline;

      if ( // If update is connected to showing the Informer - let the screen reader calmly read it.
      isInformerHidden && ( // If we are in a modal - always superfocus without concern for other elements on the page (user is unlikely to want to interact with the rest of the page)
      isModal // If we are already inside of Uppy, or
      || isFocusInUppy // If we are not focused on anything BUT we have already, at least once, focused on uppy
      //   1. We focus when isFocusNowhere, because when the element we were focused on disappears (e.g. an overlay), - focus gets lost. If user is typing something somewhere else on the page, - focus won't be 'nowhere'.
      //   2. We only focus when focus is nowhere AND this.ifFocusedOnUppyRecently, to avoid focus jumps if we do something else on the page.
      //   [Practical check] Without '&& this.ifFocusedOnUppyRecently', in Safari, in inline mode, when file is uploading, - navigate via tab to the checkbox, try to press space multiple times. Focus will jump to Uppy.
      || isFocusNowhere && _this.ifFocusedOnUppyRecently)) {
        _this.superFocus(_this.el, _this.getPluginState().activeOverlayType);
      } else {
        _this.superFocus.cancel();
      }
    };

    _this.afterUpdate = function () {
      if (_this.opts.disabled && !_this.dashboardIsDisabled) {
        _this.disableAllFocusableElements(true);

        return;
      }

      if (!_this.opts.disabled && _this.dashboardIsDisabled) {
        _this.disableAllFocusableElements(false);
      }

      _this.superFocusOnEachUpdate();
    };

    _this.cancelUpload = function (fileID) {
      _this.uppy.removeFile(fileID);
    };

    _this.saveFileCard = function (meta, fileID) {
      _this.uppy.setFileMeta(fileID, meta);

      _this.toggleFileCard(false, fileID);
    };

    _this._attachRenderFunctionToTarget = function (target) {
      var plugin = _this.uppy.getPlugin(target.id);

      return _extends({}, target, {
        icon: plugin.icon || _this.opts.defaultPickerIcon,
        render: plugin.render
      });
    };

    _this._isTargetSupported = function (target) {
      var plugin = _this.uppy.getPlugin(target.id); // If the plugin does not provide a `supported` check, assume the plugin works everywhere.


      if (typeof plugin.isSupported !== 'function') {
        return true;
      }

      return plugin.isSupported();
    };

    _this._getAcquirers = memoize(function (targets) {
      return targets.filter(function (target) {
        return target.type === 'acquirer' && _this._isTargetSupported(target);
      }).map(_this._attachRenderFunctionToTarget);
    });
    _this._getProgressIndicators = memoize(function (targets) {
      return targets.filter(function (target) {
        return target.type === 'progressindicator';
      }).map(_this._attachRenderFunctionToTarget);
    });
    _this._getEditors = memoize(function (targets) {
      return targets.filter(function (target) {
        return target.type === 'editor';
      }).map(_this._attachRenderFunctionToTarget);
    });

    _this.render = function (state) {
      var pluginState = _this.getPluginState();

      var files = state.files,
          capabilities = state.capabilities,
          allowNewUpload = state.allowNewUpload; // TODO: move this to Core, to share between Status Bar and Dashboard
      // (and any other plugin that might need it, too)

      var newFiles = Object.keys(files).filter(function (file) {
        return !files[file].progress.uploadStarted;
      });
      var uploadStartedFiles = Object.keys(files).filter(function (file) {
        return files[file].progress.uploadStarted;
      });
      var pausedFiles = Object.keys(files).filter(function (file) {
        return files[file].isPaused;
      });
      var completeFiles = Object.keys(files).filter(function (file) {
        return files[file].progress.uploadComplete;
      });
      var erroredFiles = Object.keys(files).filter(function (file) {
        return files[file].error;
      });
      var inProgressFiles = Object.keys(files).filter(function (file) {
        return !files[file].progress.uploadComplete && files[file].progress.uploadStarted;
      });
      var inProgressNotPausedFiles = inProgressFiles.filter(function (file) {
        return !files[file].isPaused;
      });
      var processingFiles = Object.keys(files).filter(function (file) {
        return files[file].progress.preprocess || files[file].progress.postprocess;
      });
      var isUploadStarted = uploadStartedFiles.length > 0;
      var isAllComplete = state.totalProgress === 100 && completeFiles.length === Object.keys(files).length && processingFiles.length === 0;
      var isAllErrored = isUploadStarted && erroredFiles.length === uploadStartedFiles.length;
      var isAllPaused = inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length;

      var acquirers = _this._getAcquirers(pluginState.targets);

      var progressindicators = _this._getProgressIndicators(pluginState.targets);

      var editors = _this._getEditors(pluginState.targets);

      var theme;

      if (_this.opts.theme === 'auto') {
        theme = capabilities.darkMode ? 'dark' : 'light';
      } else {
        theme = _this.opts.theme;
      }

      if (['files', 'folders', 'both'].indexOf(_this.opts.fileManagerSelectionType) < 0) {
        _this.opts.fileManagerSelectionType = 'files';
        console.error("Unsupported option for \"fileManagerSelectionType\". Using default of \"" + _this.opts.fileManagerSelectionType + "\".");
      }

      return DashboardUI({
        state: state,
        isHidden: pluginState.isHidden,
        files: files,
        newFiles: newFiles,
        uploadStartedFiles: uploadStartedFiles,
        completeFiles: completeFiles,
        erroredFiles: erroredFiles,
        inProgressFiles: inProgressFiles,
        inProgressNotPausedFiles: inProgressNotPausedFiles,
        processingFiles: processingFiles,
        isUploadStarted: isUploadStarted,
        isAllComplete: isAllComplete,
        isAllErrored: isAllErrored,
        isAllPaused: isAllPaused,
        totalFileCount: Object.keys(files).length,
        totalProgress: state.totalProgress,
        allowNewUpload: allowNewUpload,
        acquirers: acquirers,
        theme: theme,
        disabled: _this.opts.disabled,
        disableLocalFiles: _this.opts.disableLocalFiles,
        direction: _this.opts.direction,
        activePickerPanel: pluginState.activePickerPanel,
        showFileEditor: pluginState.showFileEditor,
        saveFileEditor: _this.saveFileEditor,
        disableAllFocusableElements: _this.disableAllFocusableElements,
        animateOpenClose: _this.opts.animateOpenClose,
        isClosing: pluginState.isClosing,
        getPlugin: _this.uppy.getPlugin,
        progressindicators: progressindicators,
        editors: editors,
        autoProceed: _this.uppy.opts.autoProceed,
        id: _this.id,
        closeModal: _this.requestCloseModal,
        handleClickOutside: _this.handleClickOutside,
        handleInputChange: _this.handleInputChange,
        handlePaste: _this.handlePaste,
        inline: _this.opts.inline,
        showPanel: _this.showPanel,
        hideAllPanels: _this.hideAllPanels,
        log: _this.uppy.log,
        i18n: _this.i18n,
        i18nArray: _this.i18nArray,
        removeFile: _this.uppy.removeFile,
        uppy: _this.uppy,
        info: _this.uppy.info,
        note: _this.opts.note,
        recoveredState: state.recoveredState,
        metaFields: pluginState.metaFields,
        resumableUploads: capabilities.resumableUploads || false,
        individualCancellation: capabilities.individualCancellation,
        isMobileDevice: capabilities.isMobileDevice,
        pauseUpload: _this.uppy.pauseResume,
        retryUpload: _this.uppy.retryUpload,
        cancelUpload: _this.cancelUpload,
        cancelAll: _this.uppy.cancelAll,
        fileCardFor: pluginState.fileCardFor,
        toggleFileCard: _this.toggleFileCard,
        toggleAddFilesPanel: _this.toggleAddFilesPanel,
        showAddFilesPanel: pluginState.showAddFilesPanel,
        saveFileCard: _this.saveFileCard,
        openFileEditor: _this.openFileEditor,
        canEditFile: _this.canEditFile,
        width: _this.opts.width,
        height: _this.opts.height,
        showLinkToFileUploadResult: _this.opts.showLinkToFileUploadResult,
        fileManagerSelectionType: _this.opts.fileManagerSelectionType,
        proudlyDisplayPoweredByUppy: _this.opts.proudlyDisplayPoweredByUppy,
        hideCancelButton: _this.opts.hideCancelButton,
        hideRetryButton: _this.opts.hideRetryButton,
        hidePauseResumeButton: _this.opts.hidePauseResumeButton,
        showRemoveButtonAfterComplete: _this.opts.showRemoveButtonAfterComplete,
        containerWidth: pluginState.containerWidth,
        containerHeight: pluginState.containerHeight,
        areInsidesReadyToBeVisible: pluginState.areInsidesReadyToBeVisible,
        isTargetDOMEl: _this.isTargetDOMEl,
        parentElement: _this.el,
        allowedFileTypes: _this.uppy.opts.restrictions.allowedFileTypes,
        maxNumberOfFiles: _this.uppy.opts.restrictions.maxNumberOfFiles,
        showSelectedFiles: _this.opts.showSelectedFiles,
        handleCancelRestore: _this.handleCancelRestore,
        handleRequestThumbnail: _this.handleRequestThumbnail,
        handleCancelThumbnail: _this.handleCancelThumbnail,
        // drag props
        isDraggingOver: pluginState.isDraggingOver,
        handleDragOver: _this.handleDragOver,
        handleDragLeave: _this.handleDragLeave,
        handleDrop: _this.handleDrop
      });
    };

    _this.discoverProviderPlugins = function () {
      _this.uppy.iteratePlugins(function (plugin) {
        if (plugin && !plugin.target && plugin.opts && plugin.opts.target === _this.constructor) {
          _this.addTarget(plugin);
        }
      });
    };

    _this.install = function () {
      // Set default state for Dashboard
      _this.setPluginState({
        isHidden: true,
        fileCardFor: null,
        activeOverlayType: null,
        showAddFilesPanel: false,
        activePickerPanel: false,
        showFileEditor: false,
        metaFields: _this.opts.metaFields,
        targets: [],
        // We'll make them visible once .containerWidth is determined
        areInsidesReadyToBeVisible: false,
        isDraggingOver: false
      });

      var _this$opts = _this.opts,
          inline = _this$opts.inline,
          closeAfterFinish = _this$opts.closeAfterFinish;

      if (inline && closeAfterFinish) {
        throw new Error('[Dashboard] `closeAfterFinish: true` cannot be used on an inline Dashboard, because an inline Dashboard cannot be closed at all. Either set `inline: false`, or disable the `closeAfterFinish` option.');
      }

      var allowMultipleUploads = _this.uppy.opts.allowMultipleUploads;

      if (allowMultipleUploads && closeAfterFinish) {
        _this.uppy.log('[Dashboard] When using `closeAfterFinish`, we recommended setting the `allowMultipleUploads` option to `false` in the Uppy constructor. See https://uppy.io/docs/uppy/#allowMultipleUploads-true', 'warning');
      }

      var target = _this.opts.target;

      if (target) {
        _this.mount(target, _assertThisInitialized(_this));
      }

      var plugins = _this.opts.plugins || [];
      plugins.forEach(function (pluginID) {
        var plugin = _this.uppy.getPlugin(pluginID);

        if (plugin) {
          plugin.mount(_assertThisInitialized(_this), plugin);
        }
      });

      if (!_this.opts.disableStatusBar) {
        _this.uppy.use(StatusBar, {
          id: _this.id + ":StatusBar",
          target: _assertThisInitialized(_this),
          hideUploadButton: _this.opts.hideUploadButton,
          hideRetryButton: _this.opts.hideRetryButton,
          hidePauseResumeButton: _this.opts.hidePauseResumeButton,
          hideCancelButton: _this.opts.hideCancelButton,
          showProgressDetails: _this.opts.showProgressDetails,
          hideAfterFinish: _this.opts.hideProgressAfterFinish,
          locale: _this.opts.locale,
          doneButtonHandler: _this.opts.doneButtonHandler
        });
      }

      if (!_this.opts.disableInformer) {
        _this.uppy.use(Informer, {
          id: _this.id + ":Informer",
          target: _assertThisInitialized(_this)
        });
      }

      if (!_this.opts.disableThumbnailGenerator) {
        _this.uppy.use(ThumbnailGenerator, {
          id: _this.id + ":ThumbnailGenerator",
          thumbnailWidth: _this.opts.thumbnailWidth,
          thumbnailType: _this.opts.thumbnailType,
          waitForThumbnailsBeforeUpload: _this.opts.waitForThumbnailsBeforeUpload,
          // If we don't block on thumbnails, we can lazily generate them
          lazy: !_this.opts.waitForThumbnailsBeforeUpload
        });
      } // Dark Mode / theme


      _this.darkModeMediaQuery = typeof window !== 'undefined' && window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
      var isDarkModeOnFromTheStart = _this.darkModeMediaQuery ? _this.darkModeMediaQuery.matches : false;

      _this.uppy.log("[Dashboard] Dark mode is " + (isDarkModeOnFromTheStart ? 'on' : 'off'));

      _this.setDarkModeCapability(isDarkModeOnFromTheStart);

      if (_this.opts.theme === 'auto') {
        _this.darkModeMediaQuery.addListener(_this.handleSystemDarkModeChange);
      }

      _this.discoverProviderPlugins();

      _this.initEvents();
    };

    _this.uninstall = function () {
      if (!_this.opts.disableInformer) {
        var informer = _this.uppy.getPlugin(_this.id + ":Informer"); // Checking if this plugin exists, in case it was removed by uppy-core
        // before the Dashboard was.


        if (informer) _this.uppy.removePlugin(informer);
      }

      if (!_this.opts.disableStatusBar) {
        var statusBar = _this.uppy.getPlugin(_this.id + ":StatusBar");

        if (statusBar) _this.uppy.removePlugin(statusBar);
      }

      if (!_this.opts.disableThumbnailGenerator) {
        var thumbnail = _this.uppy.getPlugin(_this.id + ":ThumbnailGenerator");

        if (thumbnail) _this.uppy.removePlugin(thumbnail);
      }

      var plugins = _this.opts.plugins || [];
      plugins.forEach(function (pluginID) {
        var plugin = _this.uppy.getPlugin(pluginID);

        if (plugin) plugin.unmount();
      });

      if (_this.opts.theme === 'auto') {
        _this.darkModeMediaQuery.removeListener(_this.handleSystemDarkModeChange);
      }

      _this.unmount();

      _this.removeEvents();
    };

    _this.id = _this.opts.id || 'Dashboard';
    _this.title = 'Dashboard';
    _this.type = 'orchestrator';
    _this.modalName = "uppy-Dashboard-" + cuid();
    _this.defaultLocale = {
      strings: {
        closeModal: 'Close Modal',
        importFrom: 'Import from %{name}',
        addingMoreFiles: 'Adding more files',
        addMoreFiles: 'Add more files',
        dashboardWindowTitle: 'File Uploader Window (Press escape to close)',
        dashboardTitle: 'File Uploader',
        copyLinkToClipboardSuccess: 'Link copied to clipboard',
        copyLinkToClipboardFallback: 'Copy the URL below',
        copyLink: 'Copy link',
        fileSource: 'File source: %{name}',
        back: 'Back',
        addMore: 'Add more',
        removeFile: 'Remove file',
        editFile: 'Edit file',
        editing: 'Editing %{file}',
        finishEditingFile: 'Finish editing file',
        save: 'Save',
        saveChanges: 'Save changes',
        cancel: 'Cancel',
        myDevice: 'My Device',
        dropPasteFiles: 'Drop files here or %{browseFiles}',
        dropPasteFolders: 'Drop files here or %{browseFolders}',
        dropPasteBoth: 'Drop files here, %{browseFiles} or %{browseFolders}',
        dropPasteImportFiles: 'Drop files here, %{browseFiles} or import from:',
        dropPasteImportFolders: 'Drop files here, %{browseFolders} or import from:',
        dropPasteImportBoth: 'Drop files here, %{browseFiles}, %{browseFolders} or import from:',
        importFiles: 'Import files from:',
        dropHint: 'Drop your files here',
        browseFiles: 'browse files',
        browseFolders: 'browse folders',
        uploadComplete: 'Upload complete',
        uploadPaused: 'Upload paused',
        resumeUpload: 'Resume upload',
        pauseUpload: 'Pause upload',
        retryUpload: 'Retry upload',
        cancelUpload: 'Cancel upload',
        xFilesSelected: {
          0: '%{smart_count} file selected',
          1: '%{smart_count} files selected'
        },
        uploadingXFiles: {
          0: 'Uploading %{smart_count} file',
          1: 'Uploading %{smart_count} files'
        },
        processingXFiles: {
          0: 'Processing %{smart_count} file',
          1: 'Processing %{smart_count} files'
        },
        recoveredXFiles: {
          0: 'We could not fully recover 1 file. Please re-select it and resume the upload.',
          1: 'We could not fully recover %{smart_count} files. Please re-select them and resume the upload.'
        },
        recoveredAllFiles: 'We restored all files. You can now resume the upload.',
        sessionRestored: 'Session restored',
        reSelect: 'Re-select',
        // The default `poweredBy2` string only combines the `poweredBy` string (%{backwardsCompat}) with the size.
        // Locales can override `poweredBy2` to specify a different word order. This is for backwards compat with
        // Uppy 1.9.x and below which did a naive concatenation of `poweredBy2 + size` instead of using a locale-specific
        // substitution.
        // TODO: In 2.0 `poweredBy2` should be removed in and `poweredBy` updated to use substitution.
        poweredBy2: '%{backwardsCompat} %{uppy}',
        poweredBy: 'Powered by'
      }
    }; // set default options

    var defaultOptions = {
      target: 'body',
      metaFields: [],
      trigger: '#uppy-select-files',
      inline: false,
      width: 750,
      height: 550,
      thumbnailWidth: 280,
      thumbnailType: 'image/jpeg',
      waitForThumbnailsBeforeUpload: false,
      defaultPickerIcon: defaultPickerIcon,
      showLinkToFileUploadResult: true,
      showProgressDetails: false,
      hideUploadButton: false,
      hideCancelButton: false,
      hideRetryButton: false,
      hidePauseResumeButton: false,
      hideProgressAfterFinish: false,
      doneButtonHandler: function doneButtonHandler() {
        _this.uppy.reset();

        _this.requestCloseModal();
      },
      note: null,
      closeModalOnClickOutside: false,
      closeAfterFinish: false,
      disableStatusBar: false,
      disableInformer: false,
      disableThumbnailGenerator: false,
      disablePageScrollWhenModalOpen: true,
      animateOpenClose: true,
      fileManagerSelectionType: 'files',
      proudlyDisplayPoweredByUppy: true,
      onRequestCloseModal: function onRequestCloseModal() {
        return _this.closeModal();
      },
      showSelectedFiles: true,
      showRemoveButtonAfterComplete: false,
      browserBackButtonClose: false,
      theme: 'light',
      autoOpenFileEditor: false,
      disabled: false,
      disableLocalFiles: false
    }; // merge default options with the ones set by user

    _this.opts = _extends({}, defaultOptions, _opts);

    _this.i18nInit();

    _this.superFocus = createSuperFocus();
    _this.ifFocusedOnUppyRecently = false; // Timeouts

    _this.makeDashboardInsidesVisibleAnywayTimeout = null;
    _this.removeDragOverClassTimeout = null;
    return _this;
  }

  var _proto = Dashboard.prototype;

  _proto.onMount = function onMount() {
    // Set the text direction if the page has not defined one.
    var element = this.el;
    var direction = getTextDirection(element);

    if (!direction) {
      element.dir = 'ltr';
    }
  };

  return Dashboard;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":59,"./../../core":55,"./../../informer":106,"./../../status-bar":150,"./../../thumbnail-generator":154,"./../../utils/lib/FOCUSABLE_ELEMENTS":164,"./../../utils/lib/Translator":167,"./../../utils/lib/findAllDOMElements":172,"./../../utils/lib/getDroppedFiles":177,"./../../utils/lib/getTextDirection":187,"./../../utils/lib/toArray":200,"./components/Dashboard":62,"./utils/createSuperFocus":78,"./utils/trapFocus":82,"cuid":6,"memoize-one":19,"preact":58,"resize-observer-polyfill":26}],77:[function(require,module,exports){
/**
 * Copies text to clipboard by creating an almost invisible textarea,
 * adding text there, then running execCommand('copy').
 * Falls back to prompt() when the easy way fails (hello, Safari!)
 * From http://stackoverflow.com/a/30810322
 *
 * @param {string} textToCopy
 * @param {string} fallbackString
 * @returns {Promise}
 */
module.exports = function copyToClipboard(textToCopy, fallbackString) {
  fallbackString = fallbackString || 'Copy the URL below';
  return new Promise(function (resolve) {
    var textArea = document.createElement('textarea');
    textArea.setAttribute('style', {
      position: 'fixed',
      top: 0,
      left: 0,
      width: '2em',
      height: '2em',
      padding: 0,
      border: 'none',
      outline: 'none',
      boxShadow: 'none',
      background: 'transparent'
    });
    textArea.value = textToCopy;
    document.body.appendChild(textArea);
    textArea.select();

    var magicCopyFailed = function magicCopyFailed() {
      document.body.removeChild(textArea);
      window.prompt(fallbackString, textToCopy);
      resolve();
    };

    try {
      var successful = document.execCommand('copy');

      if (!successful) {
        return magicCopyFailed('copy command unavailable');
      }

      document.body.removeChild(textArea);
      return resolve();
    } catch (err) {
      document.body.removeChild(textArea);
      return magicCopyFailed(err);
    }
  });
};

},{}],78:[function(require,module,exports){
var debounce = require('lodash.debounce');

var FOCUSABLE_ELEMENTS = require('./../../../utils/lib/FOCUSABLE_ELEMENTS');

var getActiveOverlayEl = require('./getActiveOverlayEl');
/*
  Focuses on some element in the currently topmost overlay.

  1. If there are some [data-uppy-super-focusable] elements rendered already - focuses on the first superfocusable element, and leaves focus up to the control of a user (until currently focused element disappears from the screen [which can happen when overlay changes, or, e.g., when we click on a folder in googledrive]).
  2. If there are no [data-uppy-super-focusable] elements yet (or ever) - focuses on the first focusable element, but switches focus if superfocusable elements appear on next render.
*/


module.exports = function createSuperFocus() {
  var lastFocusWasOnSuperFocusableEl = false;

  var superFocus = function superFocus(dashboardEl, activeOverlayType) {
    var overlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
    var isFocusInOverlay = overlayEl.contains(document.activeElement); // If focus is already in the topmost overlay, AND on last update we focused on the superfocusable element - then leave focus up to the user.
    // [Practical check] without this line, typing in the search input in googledrive overlay won't work.

    if (isFocusInOverlay && lastFocusWasOnSuperFocusableEl) return;
    var superFocusableEl = overlayEl.querySelector('[data-uppy-super-focusable]'); // If we are already in the topmost overlay, AND there are no super focusable elements yet, - leave focus up to the user.
    // [Practical check] without this line, if you are in an empty folder in google drive, and something's uploading in the bg, - focus will be jumping to Done all the time.

    if (isFocusInOverlay && !superFocusableEl) return;

    if (superFocusableEl) {
      superFocusableEl.focus({
        preventScroll: true
      });
      lastFocusWasOnSuperFocusableEl = true;
    } else {
      var firstEl = overlayEl.querySelector(FOCUSABLE_ELEMENTS);
      firstEl && firstEl.focus({
        preventScroll: true
      });
      lastFocusWasOnSuperFocusableEl = false;
    }
  }; // ___Why do we need to debounce?
  //    1. To deal with animations: overlay changes via animations, which results in the DOM updating AFTER plugin.update() already executed.
  //    [Practical check] without debounce, if we open the Url overlay, and click 'Done', Dashboard won't get focused again.
  //    [Practical check] if we delay 250ms instead of 260ms - IE11 won't get focused in same situation.
  //    2. Performance: there can be many state update()s in a second, and this function is called every time.


  return debounce(superFocus, 260);
};

},{"./../../../utils/lib/FOCUSABLE_ELEMENTS":164,"./getActiveOverlayEl":79,"lodash.debounce":16}],79:[function(require,module,exports){
/**
 * @returns {HTMLElement} - either dashboard element, or the overlay that's most on top
 */
module.exports = function getActiveOverlayEl(dashboardEl, activeOverlayType) {
  if (activeOverlayType) {
    var overlayEl = dashboardEl.querySelector("[data-uppy-paneltype=\"" + activeOverlayType + "\"]"); // if an overlay is already mounted

    if (overlayEl) return overlayEl;
  }

  return dashboardEl;
};

},{}],80:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function iconImage() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("g", {
    fill: "#686DE0",
    fillRule: "evenodd"
  }, h("path", {
    d: "M5 7v10h15V7H5zm0-1h15a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1z",
    fillRule: "nonzero"
  }), h("path", {
    d: "M6.35 17.172l4.994-5.026a.5.5 0 0 1 .707 0l2.16 2.16 3.505-3.505a.5.5 0 0 1 .707 0l2.336 2.31-.707.72-1.983-1.97-3.505 3.505a.5.5 0 0 1-.707 0l-2.16-2.159-3.938 3.939-1.409.026z",
    fillRule: "nonzero"
  }), h("circle", {
    cx: "7.5",
    cy: "9.5",
    r: "1.5"
  })));
}

function iconAudio() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M9.5 18.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V7.25a.5.5 0 0 1 .379-.485l9-2.25A.5.5 0 0 1 18.5 5v11.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V8.67l-8 2v7.97zm8-11v-2l-8 2v2l8-2zM7 19.64c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1zm9-2c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1z",
    fill: "#049BCF",
    fillRule: "nonzero"
  }));
}

function iconVideo() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M16 11.834l4.486-2.691A1 1 0 0 1 22 10v6a1 1 0 0 1-1.514.857L16 14.167V17a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2.834zM15 9H5v8h10V9zm1 4l5 3v-6l-5 3z",
    fill: "#19AF67",
    fillRule: "nonzero"
  }));
}

function iconPDF() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M9.766 8.295c-.691-1.843-.539-3.401.747-3.726 1.643-.414 2.505.938 2.39 3.299-.039.79-.194 1.662-.537 3.148.324.49.66.967 1.055 1.51.17.231.382.488.629.757 1.866-.128 3.653.114 4.918.655 1.487.635 2.192 1.685 1.614 2.84-.566 1.133-1.839 1.084-3.416.249-1.141-.604-2.457-1.634-3.51-2.707a13.467 13.467 0 0 0-2.238.426c-1.392 4.051-4.534 6.453-5.707 4.572-.986-1.58 1.38-4.206 4.914-5.375.097-.322.185-.656.264-1.001.08-.353.306-1.31.407-1.737-.678-1.059-1.2-2.031-1.53-2.91zm2.098 4.87c-.033.144-.068.287-.104.427l.033-.01-.012.038a14.065 14.065 0 0 1 1.02-.197l-.032-.033.052-.004a7.902 7.902 0 0 1-.208-.271c-.197-.27-.38-.526-.555-.775l-.006.028-.002-.003c-.076.323-.148.632-.186.8zm5.77 2.978c1.143.605 1.832.632 2.054.187.26-.519-.087-1.034-1.113-1.473-.911-.39-2.175-.608-3.55-.608.845.766 1.787 1.459 2.609 1.894zM6.559 18.789c.14.223.693.16 1.425-.413.827-.648 1.61-1.747 2.208-3.206-2.563 1.064-4.102 2.867-3.633 3.62zm5.345-10.97c.088-1.793-.351-2.48-1.146-2.28-.473.119-.564 1.05-.056 2.405.213.566.52 1.188.908 1.859.18-.858.268-1.453.294-1.984z",
    fill: "#E2514A",
    fillRule: "nonzero"
  }));
}

function iconArchive() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M10.45 2.05h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V2.55a.5.5 0 0 1 .5-.5zm2.05 1.024h1.05a.5.5 0 0 1 .5.5V3.6a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5v-.001zM10.45 0h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 3.074h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 1.024h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm-2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-1.656 3.074l-.82 5.946c.52.302 1.174.458 1.976.458.803 0 1.455-.156 1.975-.458l-.82-5.946h-2.311zm0-1.025h2.312c.512 0 .946.378 1.015.885l.82 5.946c.056.412-.142.817-.501 1.026-.686.398-1.515.597-2.49.597-.974 0-1.804-.199-2.49-.597a1.025 1.025 0 0 1-.5-1.026l.819-5.946c.07-.507.503-.885 1.015-.885zm.545 6.6a.5.5 0 0 1-.397-.561l.143-.999a.5.5 0 0 1 .495-.429h.74a.5.5 0 0 1 .495.43l.143.998a.5.5 0 0 1-.397.561c-.404.08-.819.08-1.222 0z",
    fill: "#00C469",
    fillRule: "nonzero"
  }));
}

function iconFile() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("g", {
    fill: "#A7AFB7",
    fillRule: "nonzero"
  }, h("path", {
    d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z"
  }), h("path", {
    d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z"
  })));
}

function iconText() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M4.5 7h13a.5.5 0 1 1 0 1h-13a.5.5 0 0 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h10a.5.5 0 1 1 0 1h-10a.5.5 0 1 1 0-1z",
    fill: "#5A5E69",
    fillRule: "nonzero"
  }));
}

module.exports = function getIconByMime(fileType) {
  var defaultChoice = {
    color: '#838999',
    icon: iconFile()
  };
  if (!fileType) return defaultChoice;
  var fileTypeGeneral = fileType.split('/')[0];
  var fileTypeSpecific = fileType.split('/')[1]; // Text

  if (fileTypeGeneral === 'text') {
    return {
      color: '#5a5e69',
      icon: iconText()
    };
  } // Image


  if (fileTypeGeneral === 'image') {
    return {
      color: '#686de0',
      icon: iconImage()
    };
  } // Audio


  if (fileTypeGeneral === 'audio') {
    return {
      color: '#068dbb',
      icon: iconAudio()
    };
  } // Video


  if (fileTypeGeneral === 'video') {
    return {
      color: '#19af67',
      icon: iconVideo()
    };
  } // PDF


  if (fileTypeGeneral === 'application' && fileTypeSpecific === 'pdf') {
    return {
      color: '#e25149',
      icon: iconPDF()
    };
  } // Archive


  var archiveTypes = ['zip', 'x-7z-compressed', 'x-rar-compressed', 'x-tar', 'x-gzip', 'x-apple-diskimage'];

  if (fileTypeGeneral === 'application' && archiveTypes.indexOf(fileTypeSpecific) !== -1) {
    return {
      color: '#00C469',
      icon: iconArchive()
    };
  }

  return defaultChoice;
};

},{"preact":58}],81:[function(require,module,exports){
// ignore drop/paste events if they are not in input or textarea —
// otherwise when Url plugin adds drop/paste listeners to this.el,
// draging UI elements or pasting anything into any field triggers those events —
// Url treats them as URLs that need to be imported
function ignoreEvent(ev) {
  var tagName = ev.target.tagName;

  if (tagName === 'INPUT' || tagName === 'TEXTAREA') {
    ev.stopPropagation();
    return;
  }

  ev.preventDefault();
  ev.stopPropagation();
}

module.exports = ignoreEvent;

},{}],82:[function(require,module,exports){
var toArray = require('./../../../utils/lib/toArray');

var getActiveOverlayEl = require('./getActiveOverlayEl');

var FOCUSABLE_ELEMENTS = require('./../../../utils/lib/FOCUSABLE_ELEMENTS');

function focusOnFirstNode(event, nodes) {
  var node = nodes[0];

  if (node) {
    node.focus();
    event.preventDefault();
  }
}

function focusOnLastNode(event, nodes) {
  var node = nodes[nodes.length - 1];

  if (node) {
    node.focus();
    event.preventDefault();
  }
} // ___Why not just use (focusedItemIndex === -1)?
//    Firefox thinks <ul> is focusable, but we don't have <ul>s in our FOCUSABLE_ELEMENTS. Which means that if we tab into the <ul>, code will think that we are not in the active overlay, and we should focusOnFirstNode() of the currently active overlay!
//    [Practical check] if we use (focusedItemIndex === -1), instagram provider in firefox will never get focus on its pics in the <ul>.


function isFocusInOverlay(activeOverlayEl) {
  return activeOverlayEl.contains(document.activeElement);
}

function trapFocus(event, activeOverlayType, dashboardEl) {
  var activeOverlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
  var focusableNodes = toArray(activeOverlayEl.querySelectorAll(FOCUSABLE_ELEMENTS));
  var focusedItemIndex = focusableNodes.indexOf(document.activeElement); // If we pressed tab, and focus is not yet within the current overlay - focus on the first element within the current overlay.
  // This is a safety measure (for when user returns from another tab e.g.), most plugins will try to focus on some important element as it loads.

  if (!isFocusInOverlay(activeOverlayEl)) {
    focusOnFirstNode(event, focusableNodes); // If we pressed shift + tab, and we're on the first element of a modal
  } else if (event.shiftKey && focusedItemIndex === 0) {
    focusOnLastNode(event, focusableNodes); // If we pressed tab, and we're on the last element of the modal
  } else if (!event.shiftKey && focusedItemIndex === focusableNodes.length - 1) {
    focusOnFirstNode(event, focusableNodes);
  }
}

module.exports = {
  // Traps focus inside of the currently open overlay (e.g. Dashboard, or e.g. Instagram), never lets focus disappear from the modal.
  forModal: function forModal(event, activeOverlayType, dashboardEl) {
    trapFocus(event, activeOverlayType, dashboardEl);
  },
  // Traps focus inside of the currently open overlay, unless overlay is null - then let the user tab away.
  forInline: function forInline(event, activeOverlayType, dashboardEl) {
    // ___When we're in the bare 'Drop files here, paste, browse or import from' screen
    if (activeOverlayType === null) {// Do nothing and let the browser handle it, user can tab away from Uppy to other elements on the page
      // ___When there is some overlay with 'Done' button
    } else {
      // Trap the focus inside this overlay!
      // User can close the overlay (click 'Done') if they want to travel away from Uppy.
      trapFocus(event, activeOverlayType, dashboardEl);
    }
  }
};

},{"./../../../utils/lib/FOCUSABLE_ELEMENTS":164,"./../../../utils/lib/toArray":200,"./getActiveOverlayEl":79}],83:[function(require,module,exports){
module.exports={
  "name": "@uppy/drop-target",
  "description": "Lets your users drag and drop files on a DOM element",
  "version": "0.2.4",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "drag-drop",
    "drag",
    "drop",
    "dropzone",
    "upload"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  },
  "publishConfig": {
    "access": "public"
  }
}

},{}],84:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var getDroppedFiles = require('./../../utils/lib/getDroppedFiles');

var toArray = require('./../../utils/lib/toArray');
/**
 * Drop Target plugin
 *
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(DropTarget, _Plugin);

  function DropTarget(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.addFiles = function (files) {
      var descriptors = files.map(function (file) {
        return {
          source: _this.id,
          name: file.name,
          type: file.type,
          data: file,
          meta: {
            // path of the file relative to the ancestor directory the user selected.
            // e.g. 'docs/Old Prague/airbnb.pdf'
            relativePath: file.relativePath || null
          }
        };
      });

      try {
        _this.uppy.addFiles(descriptors);
      } catch (err) {
        _this.uppy.log(err);
      }
    };

    _this.handleDrop = function (event) {
      event.preventDefault();
      event.stopPropagation();
      clearTimeout(_this.removeDragOverClassTimeout); // 2. Remove dragover class

      event.currentTarget.classList.remove('uppy-is-drag-over');

      _this.setPluginState({
        isDraggingOver: false
      }); // 3. Add all dropped files


      _this.uppy.log('[DropTarget] Files were dropped');

      var logDropError = function logDropError(error) {
        _this.uppy.log(error, 'error');
      };

      getDroppedFiles(event.dataTransfer, {
        logDropError: logDropError
      }).then(function (files) {
        return _this.addFiles(files);
      });
    };

    _this.handleDragOver = function (event) {
      event.preventDefault();
      event.stopPropagation(); // 1. Add a small (+) icon on drop
      // (and prevent browsers from interpreting this as files being _moved_ into the browser,
      // https://github.com/transloadit/uppy/issues/1978)

      event.dataTransfer.dropEffect = 'copy';
      clearTimeout(_this.removeDragOverClassTimeout);
      event.currentTarget.classList.add('uppy-is-drag-over');

      _this.setPluginState({
        isDraggingOver: true
      });
    };

    _this.handleDragLeave = function (event) {
      event.preventDefault();
      event.stopPropagation();
      var currentTarget = event.currentTarget;
      clearTimeout(_this.removeDragOverClassTimeout); // Timeout against flickering, this solution is taken from drag-drop library.
      // Solution with 'pointer-events: none' didn't work across browsers.

      _this.removeDragOverClassTimeout = setTimeout(function () {
        currentTarget.classList.remove('uppy-is-drag-over');

        _this.setPluginState({
          isDraggingOver: false
        });
      }, 50);
    };

    _this.addListeners = function () {
      var target = _this.opts.target;

      if (target instanceof Element) {
        _this.nodes = [target];
      } else if (typeof target === 'string') {
        _this.nodes = toArray(document.querySelectorAll(target));
      }

      if (!_this.nodes && !_this.nodes.length > 0) {
        throw new Error("\"" + target + "\" does not match any HTML elements");
      }

      _this.nodes.forEach(function (node) {
        node.addEventListener('dragover', _this.handleDragOver, false);
        node.addEventListener('dragleave', _this.handleDragLeave, false);
        node.addEventListener('drop', _this.handleDrop, false);
      });
    };

    _this.removeListeners = function () {
      if (_this.nodes) {
        _this.nodes.forEach(function (node) {
          node.removeEventListener('dragover', _this.handleDragOver, false);
          node.removeEventListener('dragleave', _this.handleDragLeave, false);
          node.removeEventListener('drop', _this.handleDrop, false);
        });
      }
    };

    _this.type = 'acquirer';
    _this.id = _this.opts.id || 'DropTarget';
    _this.title = 'Drop Target'; // Default options

    var defaultOpts = {
      target: null
    }; // Merge default options with the ones set by user

    _this.opts = _extends({}, defaultOpts, opts);
    _this.removeDragOverClassTimeout = null;
    return _this;
  }

  var _proto = DropTarget.prototype;

  _proto.install = function install() {
    this.setPluginState({
      isDraggingOver: false
    });
    this.addListeners();
  };

  _proto.uninstall = function uninstall() {
    this.removeListeners();
  };

  return DropTarget;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":83,"./../../core":55,"./../../utils/lib/getDroppedFiles":177,"./../../utils/lib/toArray":200}],85:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],86:[function(require,module,exports){
module.exports={
  "name": "@uppy/dropbox",
  "description": "Import files from Dropbox, into Uppy.",
  "version": "1.5.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "dropbox"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],87:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var _require3 = require('./../../provider-views'),
    ProviderViews = _require3.ProviderViews;

var _require4 = require('preact'),
    h = _require4.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Dropbox, _Plugin);

  function Dropbox(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Dropbox';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Dropbox';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        fill: "#0D2481",
        width: "32",
        height: "32",
        rx: "16"
      }), h("path", {
        d: "M11 8l5 3.185-5 3.186-5-3.186L11 8zm10 0l5 3.185-5 3.186-5-3.186L21 8zM6 17.556l5-3.185 5 3.185-5 3.186-5-3.186zm15-3.185l5 3.185-5 3.186-5-3.186 5-3.185zm-10 7.432l5-3.185 5 3.185-5 3.186-5-3.186z",
        fill: "#FFF",
        fillRule: "nonzero"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionKeysParams: _this.opts.companionKeysParams,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'dropbox',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Dropbox.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return Dropbox;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":86,"./../../companion-client":50,"./../../core":55,"./../../provider-views":136,"preact":85}],88:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],89:[function(require,module,exports){
module.exports={
  "name": "@uppy/facebook",
  "description": "Import files from Facebook, into Uppy.",
  "version": "1.2.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "facebook"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],90:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var _require3 = require('./../../provider-views'),
    ProviderViews = _require3.ProviderViews;

var _require4 = require('preact'),
    h = _require4.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Facebook, _Plugin);

  function Facebook(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Facebook';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Facebook';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        width: "32",
        height: "32",
        rx: "16",
        fill: "#3C5A99"
      }), h("path", {
        d: "M17.842 26v-8.667h2.653l.398-3.377h-3.051v-2.157c0-.978.248-1.644 1.527-1.644H21V7.132A19.914 19.914 0 0 0 18.623 7c-2.352 0-3.963 1.574-3.963 4.465v2.49H12v3.378h2.66V26h3.182z",
        fill: "#FFF",
        fillRule: "nonzero"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionKeysParams: _this.opts.companionKeysParams,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'facebook',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Facebook.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  };

  _proto.render = function render(state) {
    var viewOptions = {};

    if (this.getPluginState().files.length && !this.getPluginState().folders.length) {
      viewOptions.viewType = 'grid';
      viewOptions.showFilter = false;
      viewOptions.showTitles = false;
    }

    return this.view.render(state, viewOptions);
  };

  return Facebook;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":89,"./../../companion-client":50,"./../../core":55,"./../../provider-views":136,"preact":88}],91:[function(require,module,exports){
module.exports={
  "name": "@uppy/golden-retriever",
  "description": "The GoldenRetriever Uppy plugin saves selected files in browser cache to seamlessly resume uploding after browser crash or accidentally closed tab",
  "version": "1.4.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "restore files",
    "crash recovery",
    "golden retriever",
    "resumable uploads",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@transloadit/prettier-bytes": "0.0.7",
    "@uppy/utils": "file:../utils",
    "lodash.throttle": "^4.1.1"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],92:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var prettierBytes = require('@transloadit/prettier-bytes');

var indexedDB = typeof window !== 'undefined' && (window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.OIndexedDB || window.msIndexedDB);
var isSupported = !!indexedDB;
var DB_NAME = 'uppy-blobs';
var STORE_NAME = 'files'; // maybe have a thumbnail store in the future

var DEFAULT_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours

var DB_VERSION = 3; // Set default `expires` dates on existing stored blobs.

function migrateExpiration(store) {
  var request = store.openCursor();

  request.onsuccess = function (event) {
    var cursor = event.target.result;

    if (!cursor) {
      return;
    }

    var entry = cursor.value;
    entry.expires = Date.now() + DEFAULT_EXPIRY;
    cursor.update(entry);
  };
}

function connect(dbName) {
  var request = indexedDB.open(dbName, DB_VERSION);
  return new Promise(function (resolve, reject) {
    request.onupgradeneeded = function (event) {
      var db = event.target.result;
      var transaction = event.currentTarget.transaction;

      if (event.oldVersion < 2) {
        // Added in v2: DB structure changed to a single shared object store
        var store = db.createObjectStore(STORE_NAME, {
          keyPath: 'id'
        });
        store.createIndex('store', 'store', {
          unique: false
        });
      }

      if (event.oldVersion < 3) {
        // Added in v3
        var _store = transaction.objectStore(STORE_NAME);

        _store.createIndex('expires', 'expires', {
          unique: false
        });

        migrateExpiration(_store);
      }

      transaction.oncomplete = function () {
        resolve(db);
      };
    };

    request.onsuccess = function (event) {
      resolve(event.target.result);
    };

    request.onerror = reject;
  });
}

function waitForRequest(request) {
  return new Promise(function (resolve, reject) {
    request.onsuccess = function (event) {
      resolve(event.target.result);
    };

    request.onerror = reject;
  });
}

var cleanedUp = false;

var IndexedDBStore = /*#__PURE__*/function () {
  function IndexedDBStore(opts) {
    var _this = this;

    this.opts = _extends({
      dbName: DB_NAME,
      storeName: 'default',
      expires: DEFAULT_EXPIRY,
      // 24 hours
      maxFileSize: 10 * 1024 * 1024,
      // 10 MB
      maxTotalSize: 300 * 1024 * 1024
    }, opts);
    this.name = this.opts.storeName;

    var createConnection = function createConnection() {
      return connect(_this.opts.dbName);
    };

    if (!cleanedUp) {
      cleanedUp = true;
      this.ready = IndexedDBStore.cleanup().then(createConnection, createConnection);
    } else {
      this.ready = createConnection();
    }
  }

  var _proto = IndexedDBStore.prototype;

  _proto.key = function key(fileID) {
    return this.name + "!" + fileID;
  }
  /**
   * List all file blobs currently in the store.
   */
  ;

  _proto.list = function list() {
    var _this2 = this;

    return this.ready.then(function (db) {
      var transaction = db.transaction([STORE_NAME], 'readonly');
      var store = transaction.objectStore(STORE_NAME);
      var request = store.index('store').getAll(IDBKeyRange.only(_this2.name));
      return waitForRequest(request);
    }).then(function (files) {
      var result = {};
      files.forEach(function (file) {
        result[file.fileID] = file.data;
      });
      return result;
    });
  }
  /**
   * Get one file blob from the store.
   */
  ;

  _proto.get = function get(fileID) {
    var _this3 = this;

    return this.ready.then(function (db) {
      var transaction = db.transaction([STORE_NAME], 'readonly');
      var request = transaction.objectStore(STORE_NAME).get(_this3.key(fileID));
      return waitForRequest(request);
    }).then(function (result) {
      return {
        id: result.data.fileID,
        data: result.data.data
      };
    });
  }
  /**
   * Get the total size of all stored files.
   *
   * @private
   */
  ;

  _proto.getSize = function getSize() {
    var _this4 = this;

    return this.ready.then(function (db) {
      var transaction = db.transaction([STORE_NAME], 'readonly');
      var store = transaction.objectStore(STORE_NAME);
      var request = store.index('store').openCursor(IDBKeyRange.only(_this4.name));
      return new Promise(function (resolve, reject) {
        var size = 0;

        request.onsuccess = function (event) {
          var cursor = event.target.result;

          if (cursor) {
            size += cursor.value.data.size;
            cursor.continue();
          } else {
            resolve(size);
          }
        };

        request.onerror = function () {
          reject(new Error('Could not retrieve stored blobs size'));
        };
      });
    });
  }
  /**
   * Save a file in the store.
   */
  ;

  _proto.put = function put(file) {
    var _this5 = this;

    if (file.data.size > this.opts.maxFileSize) {
      return Promise.reject(new Error('File is too big to store.'));
    }

    return this.getSize().then(function (size) {
      if (size > _this5.opts.maxTotalSize) {
        return Promise.reject(new Error('No space left'));
      }

      return _this5.ready;
    }).then(function (db) {
      var transaction = db.transaction([STORE_NAME], 'readwrite');
      var request = transaction.objectStore(STORE_NAME).add({
        id: _this5.key(file.id),
        fileID: file.id,
        store: _this5.name,
        expires: Date.now() + _this5.opts.expires,
        data: file.data
      });
      return waitForRequest(request);
    });
  }
  /**
   * Delete a file blob from the store.
   */
  ;

  _proto.delete = function _delete(fileID) {
    var _this6 = this;

    return this.ready.then(function (db) {
      var transaction = db.transaction([STORE_NAME], 'readwrite');
      var request = transaction.objectStore(STORE_NAME).delete(_this6.key(fileID));
      return waitForRequest(request);
    });
  }
  /**
   * Delete all stored blobs that have an expiry date that is before Date.now().
   * This is a static method because it deletes expired blobs from _all_ Uppy instances.
   */
  ;

  IndexedDBStore.cleanup = function cleanup() {
    return connect(DB_NAME).then(function (db) {
      var transaction = db.transaction([STORE_NAME], 'readwrite');
      var store = transaction.objectStore(STORE_NAME);
      var request = store.index('expires').openCursor(IDBKeyRange.upperBound(Date.now()));
      return new Promise(function (resolve, reject) {
        request.onsuccess = function (event) {
          var cursor = event.target.result;

          if (cursor) {
            var entry = cursor.value;
            console.log('[IndexedDBStore] Deleting record', entry.fileID, 'of size', prettierBytes(entry.data.size), '- expired on', new Date(entry.expires));
            cursor.delete(); // Ignoring return value … it's not terrible if this goes wrong.

            cursor.continue();
          } else {
            resolve(db);
          }
        };

        request.onerror = reject;
      });
    }).then(function (db) {
      db.close();
    });
  };

  return IndexedDBStore;
}();

IndexedDBStore.isSupported = isSupported;
module.exports = IndexedDBStore;

},{"@transloadit/prettier-bytes":1}],93:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/**
 * Get uppy instance IDs for which state is stored.
 */
function findUppyInstances() {
  var instances = [];

  for (var i = 0; i < localStorage.length; i++) {
    var key = localStorage.key(i);

    if (/^uppyState:/.test(key)) {
      instances.push(key.slice('uppyState:'.length));
    }
  }

  return instances;
}
/**
 * Try to JSON-parse a string, return null on failure.
 */


function maybeParse(str) {
  try {
    return JSON.parse(str);
  } catch (err) {
    return null;
  }
}

var cleanedUp = false;

module.exports = /*#__PURE__*/function () {
  function MetaDataStore(opts) {
    this.opts = _extends({
      expires: 24 * 60 * 60 * 1000
    }, opts);
    this.name = "uppyState:" + opts.storeName;

    if (!cleanedUp) {
      cleanedUp = true;
      MetaDataStore.cleanup();
    }
  }
  /**
   *
   */


  var _proto = MetaDataStore.prototype;

  _proto.load = function load() {
    var savedState = localStorage.getItem(this.name);
    if (!savedState) return null;
    var data = maybeParse(savedState);
    if (!data) return null; // Upgrade pre-0.20.0 uppyState: it used to be just a flat object,
    // without `expires`.

    if (!data.metadata) {
      this.save(data);
      return data;
    }

    return data.metadata;
  };

  _proto.save = function save(metadata) {
    var expires = Date.now() + this.opts.expires;
    var state = JSON.stringify({
      metadata: metadata,
      expires: expires
    });
    localStorage.setItem(this.name, state);
  }
  /**
   * Remove all expired state.
   */
  ;

  MetaDataStore.cleanup = function cleanup(instanceID) {
    if (instanceID) {
      localStorage.removeItem("uppyState:" + instanceID);
      return;
    }

    var instanceIDs = findUppyInstances();
    var now = Date.now();
    instanceIDs.forEach(function (id) {
      var data = localStorage.getItem("uppyState:" + id);
      if (!data) return null;
      var obj = maybeParse(data);
      if (!obj) return null;

      if (obj.expires && obj.expires < now) {
        localStorage.removeItem("uppyState:" + id);
      }
    });
  };

  return MetaDataStore;
}();

},{}],94:[function(require,module,exports){
/*eslint-disable */
var isSupported = typeof navigator !== 'undefined' && 'serviceWorker' in navigator;

function waitForServiceWorker() {
  return new Promise(function (resolve, reject) {
    if (!isSupported) {
      reject(new Error('Unsupported'));
    } else if (navigator.serviceWorker.controller) {
      // A serviceWorker is already registered and active.
      resolve();
    } else {
      navigator.serviceWorker.addEventListener('controllerchange', function () {
        resolve();
      });
    }
  });
}

var ServiceWorkerStore = /*#__PURE__*/function () {
  function ServiceWorkerStore(opts) {
    this.ready = waitForServiceWorker();
    this.name = opts.storeName;
  }

  var _proto = ServiceWorkerStore.prototype;

  _proto.list = function list() {
    var _this = this;

    var defer = {};
    var promise = new Promise(function (resolve, reject) {
      defer.resolve = resolve;
      defer.reject = reject;
    });
    console.log('Loading stored blobs from Service Worker');

    var onMessage = function onMessage(event) {
      if (event.data.store !== _this.name) {
        return;
      }

      switch (event.data.type) {
        case 'uppy/ALL_FILES':
          defer.resolve(event.data.files);
          navigator.serviceWorker.removeEventListener('message', onMessage);
          break;
      }
    };

    this.ready.then(function () {
      navigator.serviceWorker.addEventListener('message', onMessage);
      navigator.serviceWorker.controller.postMessage({
        type: 'uppy/GET_FILES',
        store: _this.name
      });
    });
    return promise;
  };

  _proto.put = function put(file) {
    var _this2 = this;

    return this.ready.then(function () {
      navigator.serviceWorker.controller.postMessage({
        type: 'uppy/ADD_FILE',
        store: _this2.name,
        file: file
      });
    });
  };

  _proto.delete = function _delete(fileID) {
    var _this3 = this;

    return this.ready.then(function () {
      navigator.serviceWorker.controller.postMessage({
        type: 'uppy/REMOVE_FILE',
        store: _this3.name,
        fileID: fileID
      });
    });
  };

  return ServiceWorkerStore;
}();

ServiceWorkerStore.isSupported = isSupported;
module.exports = ServiceWorkerStore;

},{}],95:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var throttle = require('lodash.throttle');

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var ServiceWorkerStore = require('./ServiceWorkerStore');

var IndexedDBStore = require('./IndexedDBStore');

var MetaDataStore = require('./MetaDataStore');
/**
 * The GoldenRetriever plugin — restores selected files and resumes uploads
 * after a closed tab or a browser crash!
 *
 * Uses localStorage, IndexedDB and ServiceWorker to do its magic, read more:
 * https://uppy.io/blog/2017/07/golden-retriever/
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(GoldenRetriever, _Plugin);

  function GoldenRetriever(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.addBlobToStores = function (file) {
      if (file.isRemote) return;

      if (_this.ServiceWorkerStore) {
        _this.ServiceWorkerStore.put(file).catch(function (err) {
          _this.uppy.log('[GoldenRetriever] Could not store file', 'warning');

          _this.uppy.log(err);
        });
      }

      _this.IndexedDBStore.put(file).catch(function (err) {
        _this.uppy.log('[GoldenRetriever] Could not store file', 'warning');

        _this.uppy.log(err);
      });
    };

    _this.removeBlobFromStores = function (file) {
      if (_this.ServiceWorkerStore) {
        _this.ServiceWorkerStore.delete(file.id).catch(function (err) {
          _this.uppy.log('[GoldenRetriever] Failed to remove file', 'warning');

          _this.uppy.log(err);
        });
      }

      _this.IndexedDBStore.delete(file.id).catch(function (err) {
        _this.uppy.log('[GoldenRetriever] Failed to remove file', 'warning');

        _this.uppy.log(err);
      });
    };

    _this.replaceBlobInStores = function (file) {
      _this.removeBlobFromStores(file);

      _this.addBlobToStores(file);
    };

    _this.handleRestoreConfirmed = function () {
      _this.uppy.log('[GoldenRetriever] Restore confirmed, proceeding...'); // start all uploads again when file blobs are restored


      var _this$uppy$getState = _this.uppy.getState(),
          currentUploads = _this$uppy$getState.currentUploads;

      if (currentUploads) {
        Object.keys(currentUploads).forEach(function (uploadId) {
          _this.uppy.restore(uploadId, currentUploads[uploadId]);
        });

        _this.uppy.resumeAll();
      }

      _this.uppy.upload();

      _this.uppy.setState({
        recoveredState: null
      });
    };

    _this.abortRestore = function () {
      _this.uppy.log('[GoldenRetriever] Aborting restore...');

      var fileIDs = Object.keys(_this.uppy.getState().files);

      _this.deleteBlobs(fileIDs).then(function () {
        _this.uppy.log("[GoldenRetriever] Removed " + fileIDs.length + " files");
      }).catch(function (err) {
        _this.uppy.log("[GoldenRetriever] Could not remove " + fileIDs.length + " files", 'warning');

        _this.uppy.log(err);
      });

      _this.uppy.cancelAll();

      _this.uppy.setState({
        recoveredState: null
      });

      MetaDataStore.cleanup(_this.uppy.opts.id);
    };

    _this.handleComplete = function (_ref) {
      var successful = _ref.successful;
      var fileIDs = successful.map(function (file) {
        return file.id;
      });

      _this.deleteBlobs(fileIDs).then(function () {
        _this.uppy.log("[GoldenRetriever] Removed " + successful.length + " files that finished uploading");
      }).catch(function (err) {
        _this.uppy.log("[GoldenRetriever] Could not remove " + successful.length + " files that finished uploading", 'warning');

        _this.uppy.log(err);
      });

      _this.uppy.setState({
        recoveredState: null
      });

      MetaDataStore.cleanup(_this.uppy.opts.id);
    };

    _this.restoreBlobs = function () {
      if (_this.uppy.getFiles().length > 0) {
        Promise.all([_this.loadFileBlobsFromServiceWorker(), _this.loadFileBlobsFromIndexedDB()]).then(function (resultingArrayOfObjects) {
          var blobs = _extends({}, resultingArrayOfObjects[0], resultingArrayOfObjects[1]);

          _this.onBlobsLoaded(blobs);
        });
      } else {
        _this.uppy.log('[GoldenRetriever] No files need to be loaded, only restoring processing state...');

        _this.onBlobsLoaded([]);
      }
    };

    _this.type = 'debugger';
    _this.id = _this.opts.id || 'GoldenRetriever';
    _this.title = 'Golden Retriever';
    var defaultOptions = {
      expires: 24 * 60 * 60 * 1000,
      // 24 hours
      serviceWorker: false
    };
    _this.opts = _extends({}, defaultOptions, opts);
    _this.MetaDataStore = new MetaDataStore({
      expires: _this.opts.expires,
      storeName: uppy.getID()
    });
    _this.ServiceWorkerStore = null;

    if (_this.opts.serviceWorker) {
      _this.ServiceWorkerStore = new ServiceWorkerStore({
        storeName: uppy.getID()
      });
    }

    _this.IndexedDBStore = new IndexedDBStore(_extends({
      expires: _this.opts.expires
    }, _this.opts.indexedDB || {}, {
      storeName: uppy.getID()
    }));
    _this.saveFilesStateToLocalStorage = throttle(_this.saveFilesStateToLocalStorage.bind(_assertThisInitialized(_this)), 500, {
      leading: true,
      trailing: true
    });
    _this.restoreState = _this.restoreState.bind(_assertThisInitialized(_this));
    _this.loadFileBlobsFromServiceWorker = _this.loadFileBlobsFromServiceWorker.bind(_assertThisInitialized(_this));
    _this.loadFileBlobsFromIndexedDB = _this.loadFileBlobsFromIndexedDB.bind(_assertThisInitialized(_this));
    _this.onBlobsLoaded = _this.onBlobsLoaded.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = GoldenRetriever.prototype;

  _proto.restoreState = function restoreState() {
    var savedState = this.MetaDataStore.load();

    if (savedState) {
      this.uppy.log('[GoldenRetriever] Recovered some state from Local Storage');
      this.uppy.setState({
        currentUploads: savedState.currentUploads || {},
        files: savedState.files || {},
        recoveredState: savedState
      });
      this.savedPluginData = savedState.pluginData;
    }
  }
  /**
   * Get file objects that are currently waiting: they've been selected,
   * but aren't yet being uploaded.
   */
  ;

  _proto.getWaitingFiles = function getWaitingFiles() {
    var waitingFiles = {};
    this.uppy.getFiles().forEach(function (file) {
      if (!file.progress || !file.progress.uploadStarted) {
        waitingFiles[file.id] = file;
      }
    });
    return waitingFiles;
  }
  /**
   * Get file objects that are currently being uploaded. If a file has finished
   * uploading, but the other files in the same batch have not, the finished
   * file is also returned.
   */
  ;

  _proto.getUploadingFiles = function getUploadingFiles() {
    var _this2 = this;

    var uploadingFiles = {};

    var _this$uppy$getState2 = this.uppy.getState(),
        currentUploads = _this$uppy$getState2.currentUploads;

    if (currentUploads) {
      var uploadIDs = Object.keys(currentUploads);
      uploadIDs.forEach(function (uploadID) {
        var filesInUpload = currentUploads[uploadID].fileIDs;
        filesInUpload.forEach(function (fileID) {
          uploadingFiles[fileID] = _this2.uppy.getFile(fileID);
        });
      });
    }

    return uploadingFiles;
  };

  _proto.saveFilesStateToLocalStorage = function saveFilesStateToLocalStorage() {
    var filesToSave = _extends({}, this.getWaitingFiles(), this.getUploadingFiles()); // If all files have been removed by the user, clear recovery state


    if (Object.keys(filesToSave).length === 0) {
      this.uppy.setState({
        recoveredState: null
      });
      MetaDataStore.cleanup(this.uppy.opts.id);
      return;
    } // We dont’t need to store file.data on local files, because the actual blob will be restored later,
    // and we want to avoid having weird properties in the serialized object.
    // Also adding file.isRestored to all files, since they will be restored from local storage


    var filesToSaveWithoutData = {};
    Object.keys(filesToSave).forEach(function (file) {
      if (filesToSave[file].isRemote) {
        filesToSaveWithoutData[file] = _extends({}, filesToSave[file], {
          isRestored: true
        });
      } else {
        filesToSaveWithoutData[file] = _extends({}, filesToSave[file], {
          isRestored: true,
          data: null,
          preview: null
        });
      }
    });
    var pluginData = {}; // TODO Find a better way to do this?
    // Other plugins can attach a restore:get-data listener that receives this callback.
    // Plugins can then use this callback (sync) to provide data to be stored.

    this.uppy.emit('restore:get-data', function (data) {
      _extends(pluginData, data);
    });

    var _this$uppy$getState3 = this.uppy.getState(),
        currentUploads = _this$uppy$getState3.currentUploads;

    this.MetaDataStore.save({
      currentUploads: currentUploads,
      files: filesToSaveWithoutData,
      pluginData: pluginData
    });
  };

  _proto.loadFileBlobsFromServiceWorker = function loadFileBlobsFromServiceWorker() {
    var _this3 = this;

    if (!this.ServiceWorkerStore) {
      return Promise.resolve({});
    }

    return this.ServiceWorkerStore.list().then(function (blobs) {
      var files = _this3.uppy.getFiles();

      var localFilesOnly = files.filter(function (file) {
        // maybe && !file.progress.uploadComplete
        return !file.isRemote;
      });
      var numberOfFilesRecovered = Object.keys(blobs).length;
      var numberOfFilesTryingToRecover = localFilesOnly.length;

      if (numberOfFilesRecovered === numberOfFilesTryingToRecover) {
        _this3.uppy.log("[GoldenRetriever] Successfully recovered " + numberOfFilesRecovered + " blobs from Service Worker!");

        return blobs;
      }

      _this3.uppy.log('[GoldenRetriever] No blobs found in Service Worker, trying IndexedDB now...');

      return {};
    }).catch(function (err) {
      _this3.uppy.log('[GoldenRetriever] Failed to recover blobs from Service Worker', 'warning');

      _this3.uppy.log(err);

      return {};
    });
  };

  _proto.loadFileBlobsFromIndexedDB = function loadFileBlobsFromIndexedDB() {
    var _this4 = this;

    return this.IndexedDBStore.list().then(function (blobs) {
      var numberOfFilesRecovered = Object.keys(blobs).length;

      if (numberOfFilesRecovered > 0) {
        _this4.uppy.log("[GoldenRetriever] Successfully recovered " + numberOfFilesRecovered + " blobs from IndexedDB!");

        return blobs;
      }

      _this4.uppy.log('[GoldenRetriever] No blobs found in IndexedDB');

      return {};
    }).catch(function (err) {
      _this4.uppy.log('[GoldenRetriever] Failed to recover blobs from IndexedDB', 'warning');

      _this4.uppy.log(err);

      return {};
    });
  };

  _proto.onBlobsLoaded = function onBlobsLoaded(blobs) {
    var _this5 = this;

    var obsoleteBlobs = [];

    var updatedFiles = _extends({}, this.uppy.getState().files); // Loop through blobs that we can restore, add blobs to file objects


    Object.keys(blobs).forEach(function (fileID) {
      var originalFile = _this5.uppy.getFile(fileID);

      if (!originalFile) {
        obsoleteBlobs.push(fileID);
        return;
      }

      var cachedData = blobs[fileID];
      var updatedFileData = {
        data: cachedData,
        isRestored: true,
        isGhost: false
      };
      updatedFiles[fileID] = _extends({}, originalFile, updatedFileData);
    }); // Loop through files that we can’t restore fully — we only have meta, not blobs,
    // set .isGhost on them, also set isRestored to all files

    Object.keys(updatedFiles).forEach(function (fileID) {
      if (updatedFiles[fileID].data === null) {
        updatedFiles[fileID] = _extends({}, updatedFiles[fileID], {
          isGhost: true
        });
      }
    });
    this.uppy.setState({
      files: updatedFiles
    });
    this.uppy.emit('restored', this.savedPluginData);

    if (obsoleteBlobs.length) {
      this.deleteBlobs(obsoleteBlobs).then(function () {
        _this5.uppy.log("[GoldenRetriever] Cleaned up " + obsoleteBlobs.length + " old files");
      }).catch(function (err) {
        _this5.uppy.log("[GoldenRetriever] Could not clean up " + obsoleteBlobs.length + " old files", 'warning');

        _this5.uppy.log(err);
      });
    }
  };

  _proto.deleteBlobs = function deleteBlobs(fileIDs) {
    var _this6 = this;

    var promises = [];
    fileIDs.forEach(function (id) {
      if (_this6.ServiceWorkerStore) {
        promises.push(_this6.ServiceWorkerStore.delete(id));
      }

      if (_this6.IndexedDBStore) {
        promises.push(_this6.IndexedDBStore.delete(id));
      }
    });
    return Promise.all(promises);
  };

  _proto.install = function install() {
    this.restoreState();
    this.restoreBlobs();
    this.uppy.on('file-added', this.addBlobToStores);
    this.uppy.on('file-editor:complete', this.replaceBlobInStores);
    this.uppy.on('file-removed', this.removeBlobFromStores);
    this.uppy.on('state-update', this.saveFilesStateToLocalStorage);
    this.uppy.on('restore-confirmed', this.handleRestoreConfirmed);
    this.uppy.on('restore-canceled', this.abortRestore);
    this.uppy.on('complete', this.handleComplete);
  };

  _proto.uninstall = function uninstall() {
    this.uppy.off('file-added', this.addBlobToStores);
    this.uppy.off('file-editor:complete', this.replaceBlobInStores);
    this.uppy.off('file-removed', this.removeBlobFromStores);
    this.uppy.off('state-update', this.saveFilesStateToLocalStorage);
    this.uppy.off('restore-confirmed', this.handleRestoreConfirmed);
    this.uppy.off('restore-canceled', this.abortRestore);
    this.uppy.off('complete', this.handleComplete);
  };

  return GoldenRetriever;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":91,"./../../core":55,"./IndexedDBStore":92,"./MetaDataStore":93,"./ServiceWorkerStore":94,"lodash.throttle":17}],96:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],97:[function(require,module,exports){
module.exports={
  "name": "@uppy/google-drive",
  "description": "The Google Drive plugin for Uppy lets users import files from their Google Drive account",
  "version": "1.7.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "google drive",
    "cloud storage",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],98:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../provider-views'),
    ProviderViews = _require.ProviderViews;

module.exports = /*#__PURE__*/function (_ProviderViews) {
  _inheritsLoose(DriveProviderViews, _ProviderViews);

  function DriveProviderViews() {
    return _ProviderViews.apply(this, arguments) || this;
  }

  var _proto = DriveProviderViews.prototype;

  _proto.toggleCheckbox = function toggleCheckbox(e, file) {
    e.stopPropagation();
    e.preventDefault(); // Shared Drives aren't selectable; for all else, defer to the base ProviderView.
    // @todo isTeamDrive is left for backward compatibility. We should remove it in the next
    // major release.

    if (!file.custom.isTeamDrive && !file.custom.isSharedDrive) {
      _ProviderViews.prototype.toggleCheckbox.call(this, e, file);
    }
  };

  return DriveProviderViews;
}(ProviderViews);

},{"./../../provider-views":136}],99:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var DriveProviderViews = require('./DriveProviderViews');

var _require3 = require('preact'),
    h = _require3.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(GoogleDrive, _Plugin);

  function GoogleDrive(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'GoogleDrive';
    _this.title = _this.opts.title || 'Google Drive';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Google Drive';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        fill: "#4285F4",
        width: "32",
        height: "32",
        rx: "16"
      }), h("path", {
        d: "M10.324 23.3l3-5.1H25l-3 5.1H10.324zM13 18.2l-3 5.1-3-5.1 5.839-9.924 2.999 5.1L13 18.2zm11.838-.276h-6L13 8h6l5.84 9.924h-.002z",
        fill: "#FFF"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionKeysParams: _this.opts.companionKeysParams,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'drive',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = GoogleDrive.prototype;

  _proto.install = function install() {
    this.view = new DriveProviderViews(this, {
      provider: this.provider
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder('root', '/')]);
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return GoogleDrive;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":97,"./../../companion-client":50,"./../../core":55,"./DriveProviderViews":98,"preact":96}],100:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],101:[function(require,module,exports){
module.exports={
  "name": "@uppy/image-editor",
  "description": "Image editor and cropping UI",
  "version": "0.3.0",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "upload",
    "uppy",
    "uppy-plugin",
    "image editor",
    "cropper",
    "crop",
    "rotate",
    "resize"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "cropperjs": "1.5.7",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  },
  "publishConfig": {
    "access": "public"
  }
}

},{}],102:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Cropper = require('cropperjs');

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

module.exports = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Editor, _Component);

  function Editor(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.granularRotateOnChange = function (ev) {
      var _this$state = _this.state,
          rotationAngle = _this$state.rotationAngle,
          rotationDelta = _this$state.rotationDelta;
      var pendingRotationDelta = Number(ev.target.value) - rotationDelta;
      cancelAnimationFrame(_this.granularRotateOnInputNextFrame);

      if (pendingRotationDelta !== 0) {
        var pendingRotationAngle = rotationAngle + pendingRotationDelta;
        _this.granularRotateOnInputNextFrame = requestAnimationFrame(function () {
          _this.cropper.rotateTo(pendingRotationAngle);
        });
      }
    };

    _this.state = {
      rotationAngle: 0,
      rotationDelta: 0
    };
    return _this;
  }

  var _proto = Editor.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var _this$props = this.props,
        opts = _this$props.opts,
        storeCropperInstance = _this$props.storeCropperInstance;
    this.cropper = new Cropper(this.imgElement, opts.cropperOptions);
    storeCropperInstance(this.cropper);

    if (opts.actions.granularRotate) {
      this.imgElement.addEventListener('crop', function (ev) {
        var rotationAngle = ev.detail.rotate;

        _this2.setState({
          rotationAngle: rotationAngle,
          // 405 == 360 + 45
          rotationDelta: (rotationAngle + 405) % 90 - 45
        });
      });
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cropper.destroy();
  };

  _proto.renderRevert = function renderRevert() {
    var _this3 = this;

    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": this.props.i18n('revert'),
      "data-microtip-position": "top",
      role: "tooltip",
      onClick: function onClick() {
        _this3.cropper.reset();

        _this3.cropper.setAspectRatio(0);
      }
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), h("path", {
      d: "M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"
    })));
  };

  _proto.renderRotate = function renderRotate() {
    var _this4 = this;

    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      onClick: function onClick() {
        return _this4.cropper.rotate(-90);
      },
      "aria-label": this.props.i18n('rotate'),
      "data-microtip-position": "top",
      role: "tooltip"
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M0 0h24v24H0V0zm0 0h24v24H0V0z",
      fill: "none"
    }), h("path", {
      d: "M14 10a2 2 0 012 2v7a2 2 0 01-2 2H6a2 2 0 01-2-2v-7a2 2 0 012-2h8zm0 1.75H6a.25.25 0 00-.243.193L5.75 12v7a.25.25 0 00.193.243L6 19.25h8a.25.25 0 00.243-.193L14.25 19v-7a.25.25 0 00-.193-.243L14 11.75zM12 .76V4c2.3 0 4.61.88 6.36 2.64a8.95 8.95 0 012.634 6.025L21 13a1 1 0 01-1.993.117L19 13h-.003a6.979 6.979 0 00-2.047-4.95 6.97 6.97 0 00-4.652-2.044L12 6v3.24L7.76 5 12 .76z"
    })));
  };

  _proto.renderGranularRotate = function renderGranularRotate() {
    return h("label", {
      "data-microtip-position": "top",
      role: "tooltip",
      "aria-label": this.state.rotationAngle + "\xBA",
      className: "uppy-ImageCropper-rangeWrapper uppy-u-reset"
    }, h("input", {
      className: "uppy-ImageCropper-range uppy-u-reset",
      type: "range",
      onInput: this.granularRotateOnChange,
      onChange: this.granularRotateOnChange,
      value: this.state.rotationDelta,
      min: "-45",
      max: "44",
      "aria-label": this.props.i18n('rotate')
    }));
  };

  _proto.renderFlip = function renderFlip() {
    var _this5 = this;

    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": this.props.i18n('flipHorizontal'),
      "data-microtip-position": "top",
      role: "tooltip",
      onClick: function onClick() {
        return _this5.cropper.scaleX(-_this5.cropper.getData().scaleX || -1);
      }
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), h("path", {
      d: "M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z"
    })));
  };

  _proto.renderZoomIn = function renderZoomIn() {
    var _this6 = this;

    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": this.props.i18n('zoomIn'),
      "data-microtip-position": "top",
      role: "tooltip",
      onClick: function onClick() {
        return _this6.cropper.zoom(0.1);
      }
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      height: "24",
      viewBox: "0 0 24 24",
      width: "24"
    }, h("path", {
      d: "M0 0h24v24H0V0z",
      fill: "none"
    }), h("path", {
      d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
    }), h("path", {
      d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"
    })));
  };

  _proto.renderZoomOut = function renderZoomOut() {
    var _this7 = this;

    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": this.props.i18n('zoomOut'),
      "data-microtip-position": "top",
      role: "tooltip",
      onClick: function onClick() {
        return _this7.cropper.zoom(-0.1);
      }
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M0 0h24v24H0V0z",
      fill: "none"
    }), h("path", {
      d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z"
    })));
  };

  _proto.renderCropSquare = function renderCropSquare() {
    var _this8 = this;

    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": this.props.i18n('aspectRatioSquare'),
      "data-microtip-position": "top",
      role: "tooltip",
      onClick: function onClick() {
        return _this8.cropper.setAspectRatio(1);
      }
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), h("path", {
      d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
    })));
  };

  _proto.renderCropWidescreen = function renderCropWidescreen() {
    var _this9 = this;

    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": this.props.i18n('aspectRatioLandscape'),
      "data-microtip-position": "top",
      role: "tooltip",
      onClick: function onClick() {
        return _this9.cropper.setAspectRatio(16 / 9);
      }
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M 19,4.9999992 V 17.000001 H 4.9999998 V 6.9999992 H 19 m 0,-2 H 4.9999998 c -1.0999999,0 -1.9999999,0.9000001 -1.9999999,2 V 17.000001 c 0,1.1 0.9,2 1.9999999,2 H 19 c 1.1,0 2,-0.9 2,-2 V 6.9999992 c 0,-1.0999999 -0.9,-2 -2,-2 z"
    }), h("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    })));
  };

  _proto.renderCropWidescreenVertical = function renderCropWidescreenVertical() {
    var _this10 = this;

    return h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn",
      "aria-label": this.props.i18n('aspectRatioPortrait'),
      "data-microtip-position": "top",
      role: "tooltip",
      onClick: function onClick() {
        return _this10.cropper.setAspectRatio(9 / 16);
      }
    }, h("svg", {
      "aria-hidden": "true",
      className: "uppy-c-icon",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M 19.000001,19 H 6.999999 V 5 h 10.000002 v 14 m 2,0 V 5 c 0,-1.0999999 -0.9,-1.9999999 -2,-1.9999999 H 6.999999 c -1.1,0 -2,0.9 -2,1.9999999 v 14 c 0,1.1 0.9,2 2,2 h 10.000002 c 1.1,0 2,-0.9 2,-2 z"
    }), h("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    })));
  };

  _proto.render = function render() {
    var _this11 = this;

    var _this$props2 = this.props,
        currentImage = _this$props2.currentImage,
        i18n = _this$props2.i18n,
        opts = _this$props2.opts;
    var actions = opts.actions; // eslint-disable-next-line compat/compat

    var imageURL = URL.createObjectURL(currentImage.data);
    return h("div", {
      className: "uppy-ImageCropper"
    }, h("div", {
      className: "uppy-ImageCropper-container"
    }, h("img", {
      className: "uppy-ImageCropper-image",
      alt: currentImage.name,
      src: imageURL,
      ref: function ref(_ref) {
        _this11.imgElement = _ref;
      }
    })), h("div", {
      className: "uppy-ImageCropper-controls"
    }, actions.revert && this.renderRevert(), actions.rotate && this.renderRotate(), actions.granularRotate && this.renderGranularRotate(), actions.flip && this.renderFlip(), actions.zoomIn && this.renderZoomIn(), actions.zoomOut && this.renderZoomOut(), actions.cropSquare && this.renderCropSquare(), actions.cropWidescreen && this.renderCropWidescreen(), actions.cropWidescreenVertical && this.renderCropWidescreenVertical()));
  };

  return Editor;
}(Component);

},{"cropperjs":5,"preact":100}],103:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Editor = require('./Editor');

var Translator = require('./../../utils/lib/Translator');

var _require2 = require('preact'),
    h = _require2.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(ImageEditor, _Plugin);

  function ImageEditor(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.save = function () {
      var saveBlobCallback = function saveBlobCallback(blob) {
        var _this$getPluginState = _this.getPluginState(),
            currentImage = _this$getPluginState.currentImage;

        _this.uppy.setFileState(currentImage.id, {
          data: blob,
          size: blob.size,
          preview: null
        });

        var updatedFile = _this.uppy.getFile(currentImage.id);

        _this.uppy.emit('thumbnail:request', updatedFile);

        _this.setPluginState({
          currentImage: updatedFile
        });

        _this.uppy.emit('file-editor:complete', updatedFile);
      };

      var _this$getPluginState2 = _this.getPluginState(),
          currentImage = _this$getPluginState2.currentImage;

      _this.cropper.getCroppedCanvas().toBlob(saveBlobCallback, currentImage.type, _this.opts.quality);
    };

    _this.storeCropperInstance = function (cropper) {
      _this.cropper = cropper;
    };

    _this.selectFile = function (file) {
      _this.uppy.emit('file-editor:start', file);

      _this.setPluginState({
        currentImage: file
      });
    };

    _this.id = _this.opts.id || 'ImageEditor';
    _this.title = 'Image Editor';
    _this.type = 'editor';
    _this.defaultLocale = {
      strings: {
        revert: 'Revert',
        rotate: 'Rotate',
        zoomIn: 'Zoom in',
        zoomOut: 'Zoom out',
        flipHorizontal: 'Flip horizontal',
        aspectRatioSquare: 'Crop square',
        aspectRatioLandscape: 'Crop landscape (16:9)',
        aspectRatioPortrait: 'Crop portrait (9:16)'
      }
    };
    var defaultCropperOptions = {
      viewMode: 1,
      background: false,
      autoCropArea: 1,
      responsive: true
    };
    var defaultActions = {
      revert: true,
      rotate: true,
      granularRotate: true,
      flip: true,
      zoomIn: true,
      zoomOut: true,
      cropSquare: true,
      cropWidescreen: true,
      cropWidescreenVertical: true
    };
    var defaultOptions = {
      quality: 0.8
    };
    _this.opts = _extends({}, defaultOptions, opts, {
      actions: _extends({}, defaultActions, opts.actions),
      cropperOptions: _extends({}, defaultCropperOptions, opts.cropperOptions)
    });

    _this.i18nInit();

    return _this;
  }

  var _proto = ImageEditor.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator); // this.i18nArray = this.translator.translateArray.bind(this.translator)

    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.canEditFile = function canEditFile(file) {
    if (!file.type || file.isRemote) {
      return false;
    }

    var fileTypeSpecific = file.type.split('/')[1];

    if (/^(jpe?g|gif|png|bmp|webp)$/.test(fileTypeSpecific)) {
      return true;
    }

    return false;
  };

  _proto.install = function install() {
    this.setPluginState({
      currentImage: null
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.unmount();
  };

  _proto.render = function render() {
    var _this$getPluginState3 = this.getPluginState(),
        currentImage = _this$getPluginState3.currentImage;

    if (currentImage === null || currentImage.isRemote) {
      return;
    }

    return h(Editor, {
      currentImage: currentImage,
      storeCropperInstance: this.storeCropperInstance,
      save: this.save,
      opts: this.opts,
      i18n: this.i18n
    });
  };

  return ImageEditor;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":101,"./../../core":55,"./../../utils/lib/Translator":167,"./Editor":102,"preact":100}],104:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],105:[function(require,module,exports){
module.exports={
  "name": "@uppy/informer",
  "description": "A notification and error pop-up bar for Uppy.",
  "version": "1.6.6",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "notification",
    "bar",
    "ui"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],106:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('preact'),
    h = _require2.h;
/**
 * Informer
 * Shows rad message bubbles
 * used like this: `uppy.info('hello world', 'info', 5000)`
 * or for errors: `uppy.info('Error uploading img.jpg', 'error', 5000)`
 *
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Informer, _Plugin);

  function Informer(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.render = function (state) {
      var _state$info = state.info,
          isHidden = _state$info.isHidden,
          message = _state$info.message,
          details = _state$info.details;

      function displayErrorAlert() {
        var errorMessage = message + " \n\n " + details;
        alert(errorMessage);
      }

      var handleMouseOver = function handleMouseOver() {
        clearTimeout(_this.uppy.infoTimeoutID);
      };

      var handleMouseLeave = function handleMouseLeave() {
        _this.uppy.infoTimeoutID = setTimeout(_this.uppy.hideInfo, 2000);
      };

      return h("div", {
        className: "uppy uppy-Informer",
        "aria-hidden": isHidden
      }, h("p", {
        role: "alert"
      }, message, ' ', details && h("span", {
        "aria-label": details,
        "data-microtip-position": "top-left",
        "data-microtip-size": "medium",
        role: "tooltip",
        onClick: displayErrorAlert,
        onMouseOver: handleMouseOver,
        onMouseLeave: handleMouseLeave
      }, "?")));
    };

    _this.type = 'progressindicator';
    _this.id = _this.opts.id || 'Informer';
    _this.title = 'Informer'; // set default options

    var defaultOptions = {}; // merge default options with the ones set by user

    _this.opts = _extends({}, defaultOptions, opts);
    return _this;
  }

  var _proto = Informer.prototype;

  _proto.install = function install() {
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  return Informer;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":105,"./../../core":55,"preact":104}],107:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],108:[function(require,module,exports){
module.exports={
  "name": "@uppy/instagram",
  "description": "Import photos and videos from Instagram, into Uppy.",
  "version": "1.5.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "instagram",
    "provider",
    "photos",
    "videos"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],109:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var _require3 = require('./../../provider-views'),
    ProviderViews = _require3.ProviderViews;

var _require4 = require('preact'),
    h = _require4.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Instagram, _Plugin);

  function Instagram(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Instagram';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Instagram';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        fill: "#E1306C",
        width: "32",
        height: "32",
        rx: "16"
      }), h("path", {
        d: "M16 8.622c2.403 0 2.688.009 3.637.052.877.04 1.354.187 1.67.31.392.144.745.374 1.036.673.299.29.529.644.673 1.035.123.317.27.794.31 1.671.043.95.052 1.234.052 3.637s-.009 2.688-.052 3.637c-.04.877-.187 1.354-.31 1.671a2.98 2.98 0 0 1-1.708 1.708c-.317.123-.794.27-1.671.31-.95.043-1.234.053-3.637.053s-2.688-.01-3.637-.053c-.877-.04-1.354-.187-1.671-.31a2.788 2.788 0 0 1-1.035-.673 2.788 2.788 0 0 1-.673-1.035c-.123-.317-.27-.794-.31-1.671-.043-.949-.052-1.234-.052-3.637s.009-2.688.052-3.637c.04-.877.187-1.354.31-1.67.144-.392.374-.745.673-1.036.29-.299.644-.529 1.035-.673.317-.123.794-.27 1.671-.31.95-.043 1.234-.052 3.637-.052zM16 7c-2.444 0-2.75.01-3.71.054-.959.044-1.613.196-2.185.419-.6.225-1.145.58-1.594 1.038-.458.45-.813.993-1.039 1.594-.222.572-.374 1.226-.418 2.184C7.01 13.25 7 13.556 7 16s.01 2.75.054 3.71c.044.959.196 1.613.419 2.185.226.6.58 1.145 1.038 1.594.45.458.993.813 1.594 1.038.572.223 1.227.375 2.184.419.96.044 1.267.054 3.711.054s2.75-.01 3.71-.054c.959-.044 1.613-.196 2.185-.419a4.602 4.602 0 0 0 2.632-2.632c.223-.572.375-1.226.419-2.184.044-.96.054-1.267.054-3.711s-.01-2.75-.054-3.71c-.044-.959-.196-1.613-.419-2.185A4.412 4.412 0 0 0 23.49 8.51a4.412 4.412 0 0 0-1.594-1.039c-.572-.222-1.226-.374-2.184-.418C18.75 7.01 18.444 7 16 7zm0 4.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9zm0 7.421a2.921 2.921 0 1 1 0-5.842 2.921 2.921 0 0 1 0 5.842zm4.875-6.671a1.125 1.125 0 1 1 0-2.25 1.125 1.125 0 0 1 0 2.25z",
        fill: "#FFF"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionKeysParams: _this.opts.companionKeysParams,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'instagram',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Instagram.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider,
      viewType: 'grid',
      showTitles: false,
      showFilter: false,
      showBreadcrumbs: false
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder('recent')]);
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return Instagram;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":108,"./../../companion-client":50,"./../../core":55,"./../../provider-views":136,"preact":107}],110:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],111:[function(require,module,exports){
module.exports={
  "name": "@uppy/onedrive",
  "description": "Import files from OneDrive, into Uppy.",
  "version": "1.2.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "onedrive"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],112:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var _require3 = require('./../../provider-views'),
    ProviderViews = _require3.ProviderViews;

var _require4 = require('preact'),
    h = _require4.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(OneDrive, _Plugin);

  function OneDrive(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'OneDrive';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'OneDrive';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        width: "32",
        height: "32",
        rx: "16",
        fill: "#0262C0"
      }), h("g", {
        fill: "#FFF",
        fillRule: "nonzero"
      }, h("path", {
        d: "M24.157 22s1.492-.205 1.79-1.655a2.624 2.624 0 0 0 .03-.878c-.22-1.64-1.988-2.01-1.988-2.01s.307-1.765-1.312-2.69c-1.62-.925-3.1 0-3.1 0S18.711 13 16.366 13c-3.016 0-3.519 3.448-3.519 3.448S10 16.618 10 19.14c0 2.523 2.597 2.86 2.597 2.86h11.56z"
      }), h("path", {
        d: "M9.421 19.246c0-2.197 1.606-3.159 2.871-3.472.44-1.477 1.654-3.439 4.135-3.439H16.445c1.721 0 2.79.823 3.368 1.476a3.99 3.99 0 0 1 1.147-.171h.01l.03.002C21.017 13.5 20.691 10 16.757 10c-2.69 0-3.639 2.345-3.639 2.345s-1.95-1.482-3.955.567c-1.028 1.052-.79 2.669-.79 2.669S6 15.824 6 18.412C6 20.757 8.452 21 8.452 21h1.372a3.77 3.77 0 0 1-.403-1.754z"
      }))));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'onedrive',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = OneDrive.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return OneDrive;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":111,"./../../companion-client":50,"./../../core":55,"./../../provider-views":136,"preact":110}],113:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],114:[function(require,module,exports){
module.exports={
  "name": "@uppy/provider-views",
  "description": "View library for Uppy remote provider plugins.",
  "version": "1.12.3",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "classnames": "^2.2.6",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],115:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h; // TODO use Fragment when upgrading to preact X


var Breadcrumb = function Breadcrumb(props) {
  return h("span", null, h("button", {
    type: "button",
    className: "uppy-u-reset",
    onClick: props.getFolder
  }, props.title), !props.isLast ? ' / ' : '');
};

module.exports = function (props) {
  return h("div", {
    className: "uppy-Provider-breadcrumbs"
  }, h("div", {
    className: "uppy-Provider-breadcrumbsIcon"
  }, props.breadcrumbsIcon), props.directories.map(function (directory, i) {
    return h(Breadcrumb, {
      key: directory.id,
      getFolder: function getFolder() {
        return props.getFolder(directory.id);
      },
      title: i === 0 ? props.title : directory.title,
      isLast: i + 1 === props.directories.length
    });
  }));
};

},{"preact":113}],116:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var classNames = require('classnames');

var Filter = require('./Filter');

var ItemList = require('./ItemList');

var FooterActions = require('./FooterActions');

var _require = require('preact'),
    h = _require.h;

var Browser = function Browser(props) {
  var currentSelection = props.currentSelection,
      folders = props.folders,
      files = props.files,
      uppyFiles = props.uppyFiles,
      filterItems = props.filterItems,
      filterInput = props.filterInput;
  var filteredFolders = folders;
  var filteredFiles = files;

  if (filterInput !== '') {
    filteredFolders = filterItems(folders);
    filteredFiles = filterItems(files);
  }

  var selected = currentSelection.length;
  return h("div", {
    className: classNames('uppy-ProviderBrowser', "uppy-ProviderBrowser-viewType--" + props.viewType)
  }, h("div", {
    className: "uppy-ProviderBrowser-header"
  }, h("div", {
    className: classNames('uppy-ProviderBrowser-headerBar', !props.showBreadcrumbs && 'uppy-ProviderBrowser-headerBar--simple')
  }, props.headerComponent)), props.showFilter && h(Filter, props), h(ItemList, {
    columns: [{
      name: 'Name',
      key: 'title'
    }],
    folders: filteredFolders,
    files: filteredFiles,
    sortByTitle: props.sortByTitle,
    sortByDate: props.sortByDate,
    isChecked: props.isChecked,
    handleFolderClick: props.getNextFolder,
    toggleCheckbox: props.toggleCheckbox,
    handleScroll: props.handleScroll,
    title: props.title,
    showTitles: props.showTitles,
    i18n: props.i18n,
    viewType: props.viewType,
    validateRestrictions: props.validateRestrictions,
    uppyFiles: uppyFiles,
    currentSelection: currentSelection
  }), selected > 0 && h(FooterActions, _extends({
    selected: selected
  }, props)));
};

module.exports = Browser;

},{"./Filter":118,"./FooterActions":119,"./ItemList":124,"classnames":4,"preact":113}],117:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    Component = _require.Component;

module.exports = /*#__PURE__*/function (_Component) {
  _inheritsLoose(CloseWrapper, _Component);

  function CloseWrapper() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = CloseWrapper.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.onUnmount();
  };

  _proto.render = function render() {
    return this.props.children[0];
  };

  return CloseWrapper;
}(Component);

},{"preact":113}],118:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

module.exports = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Filter, _Component);

  function Filter(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.preventEnterPress = _this.preventEnterPress.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Filter.prototype;

  _proto.preventEnterPress = function preventEnterPress(ev) {
    if (ev.keyCode === 13) {
      ev.stopPropagation();
      ev.preventDefault();
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    return h("div", {
      className: "uppy-ProviderBrowser-search"
    }, h("input", {
      className: "uppy-u-reset uppy-ProviderBrowser-searchInput",
      type: "text",
      placeholder: this.props.i18n('filter'),
      "aria-label": this.props.i18n('filter'),
      onKeyUp: this.preventEnterPress,
      onKeyDown: this.preventEnterPress,
      onKeyPress: this.preventEnterPress,
      onInput: function onInput(e) {
        return _this2.props.filterQuery(e);
      },
      value: this.props.filterInput
    }), h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-ProviderBrowser-searchIcon",
      width: "12",
      height: "12",
      viewBox: "0 0 12 12"
    }, h("path", {
      d: "M8.638 7.99l3.172 3.172a.492.492 0 1 1-.697.697L7.91 8.656a4.977 4.977 0 0 1-2.983.983C2.206 9.639 0 7.481 0 4.819 0 2.158 2.206 0 4.927 0c2.721 0 4.927 2.158 4.927 4.82a4.74 4.74 0 0 1-1.216 3.17zm-3.71.685c2.176 0 3.94-1.726 3.94-3.856 0-2.129-1.764-3.855-3.94-3.855C2.75.964.984 2.69.984 4.819c0 2.13 1.765 3.856 3.942 3.856z"
    })), this.props.filterInput && h("button", {
      className: "uppy-u-reset uppy-ProviderBrowser-searchClose",
      type: "button",
      "aria-label": this.props.i18n('resetFilter'),
      title: this.props.i18n('resetFilter'),
      onClick: this.props.filterQuery
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      viewBox: "0 0 19 19"
    }, h("path", {
      d: "M17.318 17.232L9.94 9.854 9.586 9.5l-.354.354-7.378 7.378h.707l-.62-.62v.706L9.318 9.94l.354-.354-.354-.354L1.94 1.854v.707l.62-.62h-.706l7.378 7.378.354.354.354-.354 7.378-7.378h-.707l.622.62v-.706L9.854 9.232l-.354.354.354.354 7.378 7.378.708-.707-7.38-7.378v.708l7.38-7.38.353-.353-.353-.353-.622-.622-.353-.353-.354.352-7.378 7.38h.708L2.56 1.23 2.208.88l-.353.353-.622.62-.353.355.352.353 7.38 7.38v-.708l-7.38 7.38-.353.353.352.353.622.622.353.353.354-.353 7.38-7.38h-.708l7.38 7.38z"
    }))));
  };

  return Filter;
}(Component);

},{"preact":113}],119:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("div", {
    className: "uppy-ProviderBrowser-footer"
  }, h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary",
    onClick: props.done
  }, props.i18n('selectX', {
    smart_count: props.selected
  })), h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-link",
    onClick: props.cancel
  }, props.i18n('cancel')));
};

},{"preact":113}],120:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h; // it could be a <li><button class="fake-checkbox"/> <button/></li>


module.exports = function (props) {
  return h("li", {
    className: props.className,
    title: props.isDisabled ? props.restrictionReason : null
  }, h("div", {
    "aria-hidden": true,
    className: "uppy-ProviderBrowserItem-fakeCheckbox " + (props.isChecked ? 'uppy-ProviderBrowserItem-fakeCheckbox--is-checked' : '')
  }), h("button", {
    type: "button",
    className: "uppy-u-reset uppy-ProviderBrowserItem-inner",
    onClick: props.toggleCheckbox,
    role: "option",
    "aria-label": props.isChecked ? props.i18n('unselectFileNamed', {
      name: props.title
    }) : props.i18n('selectFileNamed', {
      name: props.title
    }),
    "aria-selected": props.isChecked,
    "aria-disabled": props.isDisabled,
    disabled: props.isDisabled,
    "data-uppy-super-focusable": true
  }, props.itemIconEl, props.showTitles && props.title));
};

},{"preact":113}],121:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function FileIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: 11,
    height: 14.5,
    viewBox: "0 0 44 58"
  }, h("path", {
    d: "M27.437.517a1 1 0 0 0-.094.03H4.25C2.037.548.217 2.368.217 4.58v48.405c0 2.212 1.82 4.03 4.03 4.03H39.03c2.21 0 4.03-1.818 4.03-4.03V15.61a1 1 0 0 0-.03-.28 1 1 0 0 0 0-.093 1 1 0 0 0-.03-.032 1 1 0 0 0 0-.03 1 1 0 0 0-.032-.063 1 1 0 0 0-.03-.063 1 1 0 0 0-.032 0 1 1 0 0 0-.03-.063 1 1 0 0 0-.032-.03 1 1 0 0 0-.03-.063 1 1 0 0 0-.063-.062l-14.593-14a1 1 0 0 0-.062-.062A1 1 0 0 0 28 .708a1 1 0 0 0-.374-.157 1 1 0 0 0-.156 0 1 1 0 0 0-.03-.03l-.003-.003zM4.25 2.547h22.218v9.97c0 2.21 1.82 4.03 4.03 4.03h10.564v36.438a2.02 2.02 0 0 1-2.032 2.032H4.25c-1.13 0-2.032-.9-2.032-2.032V4.58c0-1.13.902-2.032 2.03-2.032zm24.218 1.345l10.375 9.937.75.718H30.5c-1.13 0-2.032-.9-2.032-2.03V3.89z"
  }));
}

function FolderIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    style: {
      minWidth: 16,
      marginRight: 3
    },
    viewBox: "0 0 276.157 276.157"
  }, h("path", {
    d: "M273.08 101.378c-3.3-4.65-8.86-7.32-15.254-7.32h-24.34V67.59c0-10.2-8.3-18.5-18.5-18.5h-85.322c-3.63 0-9.295-2.875-11.436-5.805l-6.386-8.735c-4.982-6.814-15.104-11.954-23.546-11.954H58.73c-9.292 0-18.638 6.608-21.737 15.372l-2.033 5.752c-.958 2.71-4.72 5.37-7.596 5.37H18.5C8.3 49.09 0 57.39 0 67.59v167.07c0 .886.16 1.73.443 2.52.152 3.306 1.18 6.424 3.053 9.064 3.3 4.652 8.86 7.32 15.255 7.32h188.487c11.395 0 23.27-8.425 27.035-19.18l40.677-116.188c2.11-6.035 1.43-12.164-1.87-16.816zM18.5 64.088h8.864c9.295 0 18.64-6.607 21.738-15.37l2.032-5.75c.96-2.712 4.722-5.373 7.597-5.373h29.565c3.63 0 9.295 2.876 11.437 5.806l6.386 8.735c4.982 6.815 15.104 11.954 23.546 11.954h85.322c1.898 0 3.5 1.602 3.5 3.5v26.47H69.34c-11.395 0-23.27 8.423-27.035 19.178L15 191.23V67.59c0-1.898 1.603-3.5 3.5-3.5zm242.29 49.15l-40.676 116.188c-1.674 4.78-7.812 9.135-12.877 9.135H18.75c-1.447 0-2.576-.372-3.02-.997-.442-.625-.422-1.814.057-3.18l40.677-116.19c1.674-4.78 7.812-9.134 12.877-9.134h188.487c1.448 0 2.577.372 3.02.997.443.625.423 1.814-.056 3.18z"
  }));
}

function VideoIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    style: {
      width: 16,
      marginRight: 4
    },
    viewBox: "0 0 58 58"
  }, h("path", {
    d: "M36.537 28.156l-11-7a1.005 1.005 0 0 0-1.02-.033C24.2 21.3 24 21.635 24 22v14a1 1 0 0 0 1.537.844l11-7a1.002 1.002 0 0 0 0-1.688zM26 34.18V23.82L34.137 29 26 34.18z"
  }), h("path", {
    d: "M57 6H1a1 1 0 0 0-1 1v44a1 1 0 0 0 1 1h56a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zM10 28H2v-9h8v9zm-8 2h8v9H2v-9zm10 10V8h34v42H12V40zm44-12h-8v-9h8v9zm-8 2h8v9h-8v-9zm8-22v9h-8V8h8zM2 8h8v9H2V8zm0 42v-9h8v9H2zm54 0h-8v-9h8v9z"
  }));
}

module.exports = function (props) {
  if (props.itemIconString === null) return;

  switch (props.itemIconString) {
    case 'file':
      return h(FileIcon, null);

    case 'folder':
      return h(FolderIcon, null);

    case 'video':
      return h(VideoIcon, null);

    default:
      return h("img", {
        src: props.itemIconString
      });
  }
};

},{"preact":113}],122:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var getAriaLabelOfCheckbox = function getAriaLabelOfCheckbox(props) {
  if (props.type === 'folder') {
    if (props.isChecked) {
      return props.i18n('unselectAllFilesFromFolderNamed', {
        name: props.title
      });
    }

    return props.i18n('selectAllFilesFromFolderNamed', {
      name: props.title
    });
  }

  if (props.isChecked) {
    return props.i18n('unselectFileNamed', {
      name: props.title
    });
  }

  return props.i18n('selectFileNamed', {
    name: props.title
  });
}; // if folder:
//   + checkbox (selects all files from folder)
//   + folder name (opens folder)
// if file:
//   + checkbox (selects file)
//   + file name (selects file)


module.exports = function (props) {
  return h("li", {
    className: props.className,
    title: props.isDisabled ? props.restrictionReason : null
  }, !props.isCheckboxDisabled ? h("button", {
    type: "button",
    className: "uppy-u-reset uppy-ProviderBrowserItem-fakeCheckbox " + (props.isChecked ? 'uppy-ProviderBrowserItem-fakeCheckbox--is-checked' : ''),
    onClick: props.toggleCheckbox // for the <label/>
    ,
    id: props.id,
    role: "option",
    "aria-label": getAriaLabelOfCheckbox(props),
    "aria-selected": props.isChecked,
    "aria-disabled": props.isDisabled,
    disabled: props.isDisabled,
    "data-uppy-super-focusable": true
  }) : null, props.type === 'file' ? // label for a checkbox
  h("label", {
    htmlFor: props.id,
    className: "uppy-u-reset uppy-ProviderBrowserItem-inner"
  }, h("div", {
    className: "uppy-ProviderBrowserItem-iconWrap"
  }, props.itemIconEl), props.showTitles && props.title) : // button to open a folder
  h("button", {
    type: "button",
    className: "uppy-u-reset uppy-ProviderBrowserItem-inner",
    onClick: props.handleFolderClick,
    "aria-label": props.i18n('openFolderNamed', {
      name: props.title
    })
  }, h("div", {
    className: "uppy-ProviderBrowserItem-iconWrap"
  }, props.itemIconEl), props.showTitles && h("span", null, props.title)));
};

},{"preact":113}],123:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

var ItemIcon = require('./components/ItemIcon');

var GridLi = require('./components/GridLi');

var ListLi = require('./components/ListLi');

module.exports = function (props) {
  var itemIconString = props.getItemIcon();
  var className = classNames('uppy-ProviderBrowserItem', {
    'uppy-ProviderBrowserItem--selected': props.isChecked
  }, {
    'uppy-ProviderBrowserItem--disabled': props.isDisabled
  }, {
    'uppy-ProviderBrowserItem--noPreview': itemIconString === 'video'
  });
  var itemIconEl = h(ItemIcon, {
    itemIconString: itemIconString
  });

  switch (props.viewType) {
    case 'grid':
      return h(GridLi, _extends({}, props, {
        className: className,
        itemIconEl: itemIconEl
      }));

    case 'list':
      return h(ListLi, _extends({}, props, {
        className: className,
        itemIconEl: itemIconEl
      }));

    default:
      throw new Error("There is no such type " + props.viewType);
  }
};

},{"./components/GridLi":120,"./components/ItemIcon":121,"./components/ListLi":122,"classnames":4,"preact":113}],124:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var remoteFileObjToLocal = require('./../../utils/lib/remoteFileObjToLocal');

var Item = require('./Item/index'); // Hopefully this name will not be used by Google


var VIRTUAL_SHARED_DIR = 'shared-with-me';

var getSharedProps = function getSharedProps(fileOrFolder, props) {
  return {
    id: fileOrFolder.id,
    title: fileOrFolder.name,
    getItemIcon: function getItemIcon() {
      return fileOrFolder.icon;
    },
    isChecked: props.isChecked(fileOrFolder),
    toggleCheckbox: function toggleCheckbox(e) {
      return props.toggleCheckbox(e, fileOrFolder);
    },
    columns: props.columns,
    showTitles: props.showTitles,
    viewType: props.viewType,
    i18n: props.i18n
  };
};

module.exports = function (props) {
  var folders = props.folders,
      files = props.files,
      handleScroll = props.handleScroll,
      isChecked = props.isChecked;

  if (!folders.length && !files.length) {
    return h("div", {
      className: "uppy-Provider-empty"
    }, props.i18n('noFilesFound'));
  }

  return h("div", {
    className: "uppy-ProviderBrowser-body"
  }, h("ul", {
    className: "uppy-ProviderBrowser-list",
    onScroll: handleScroll,
    role: "listbox" // making <ul> not focusable for firefox
    ,
    tabIndex: "-1"
  }, folders.map(function (folder) {
    return Item(_extends({}, getSharedProps(folder, props), {
      type: 'folder',
      isDisabled: isChecked(folder) ? isChecked(folder).loading : false,
      isCheckboxDisabled: folder.id === VIRTUAL_SHARED_DIR,
      handleFolderClick: function handleFolderClick() {
        return props.handleFolderClick(folder);
      }
    }));
  }), files.map(function (file) {
    var validateRestrictions = props.validateRestrictions(remoteFileObjToLocal(file), [].concat(props.uppyFiles, props.currentSelection));
    var sharedProps = getSharedProps(file, props);
    var restrictionReason = validateRestrictions.reason;
    return Item(_extends({}, sharedProps, {
      type: 'file',
      isDisabled: !validateRestrictions.result && !sharedProps.isChecked,
      restrictionReason: restrictionReason
    }));
  })));
};

},{"./../../utils/lib/remoteFileObjToLocal":197,"./Item/index":123,"preact":113}],125:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("div", {
    className: "uppy-Provider-loading"
  }, h("span", null, props.i18n('loading')));
};

},{"preact":113}],126:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var AuthView = /*#__PURE__*/function (_Component) {
  _inheritsLoose(AuthView, _Component);

  function AuthView() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = AuthView.prototype;

  _proto.render = function render() {
    var pluginNameComponent = h("span", {
      className: "uppy-Provider-authTitleName"
    }, this.props.pluginName, h("br", null));
    return h("div", {
      className: "uppy-Provider-auth"
    }, h("div", {
      className: "uppy-Provider-authIcon"
    }, this.props.pluginIcon()), h("div", {
      className: "uppy-Provider-authTitle"
    }, this.props.i18nArray('authenticateWithTitle', {
      pluginName: pluginNameComponent
    })), h("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Provider-authBtn",
      onClick: this.props.handleAuth,
      "data-uppy-super-focusable": true
    }, this.props.i18nArray('authenticateWith', {
      pluginName: this.props.pluginName
    })));
  };

  return AuthView;
}(Component);

module.exports = AuthView;

},{"preact":113}],127:[function(require,module,exports){
var User = require('./User');

var Breadcrumbs = require('../Breadcrumbs');

module.exports = function (props) {
  var components = [];

  if (props.showBreadcrumbs) {
    components.push(Breadcrumbs({
      getFolder: props.getFolder,
      directories: props.directories,
      breadcrumbsIcon: props.pluginIcon && props.pluginIcon(),
      title: props.title
    }));
  }

  components.push(User({
    logout: props.logout,
    username: props.username,
    i18n: props.i18n
  }));
  return components;
};

},{"../Breadcrumbs":115,"./User":129}],128:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var AuthView = require('./AuthView');

var Header = require('./Header');

var Browser = require('../Browser');

var LoaderView = require('../Loader');

var generateFileID = require('./../../../utils/lib/generateFileID');

var getFileType = require('./../../../utils/lib/getFileType');

var findIndex = require('./../../../utils/lib/findIndex');

var isPreviewSupported = require('./../../../utils/lib/isPreviewSupported');

var SharedHandler = require('../SharedHandler');

var CloseWrapper = require('../CloseWrapper'); // location.origin does not exist in IE


function getOrigin() {
  if ('origin' in location) {
    return location.origin; // eslint-disable-line compat/compat
  }

  return location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : '');
}
/**
 * Class to easily generate generic views for Provider plugins
 */


module.exports = (_temp = _class = /*#__PURE__*/function () {
  /**
   * @param {object} plugin instance of the plugin
   * @param {object} opts
   */
  function ProviderView(plugin, opts) {
    this.plugin = plugin;
    this.provider = opts.provider;
    this._sharedHandler = new SharedHandler(plugin); // set default options

    var defaultOptions = {
      viewType: 'list',
      showTitles: true,
      showFilter: true,
      showBreadcrumbs: true
    }; // merge default options with the ones set by user

    this.opts = _extends({}, defaultOptions, opts); // Logic

    this.addFile = this.addFile.bind(this);
    this.filterQuery = this.filterQuery.bind(this);
    this.getFolder = this.getFolder.bind(this);
    this.getNextFolder = this.getNextFolder.bind(this);
    this.logout = this.logout.bind(this);
    this.preFirstRender = this.preFirstRender.bind(this);
    this.handleAuth = this.handleAuth.bind(this);
    this.sortByTitle = this.sortByTitle.bind(this);
    this.sortByDate = this.sortByDate.bind(this);
    this.handleError = this.handleError.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.listAllFiles = this.listAllFiles.bind(this);
    this.donePicking = this.donePicking.bind(this);
    this.cancelPicking = this.cancelPicking.bind(this);
    this.clearSelection = this.clearSelection.bind(this); // Visual

    this.render = this.render.bind(this);
    this.clearSelection(); // Set default state for the plugin

    this.plugin.setPluginState({
      authenticated: false,
      files: [],
      folders: [],
      directories: [],
      filterInput: '',
      isSearchVisible: false
    });
  }

  var _proto = ProviderView.prototype;

  _proto.tearDown = function tearDown() {// Nothing.
  };

  _proto._updateFilesAndFolders = function _updateFilesAndFolders(res, files, folders) {
    this.nextPagePath = res.nextPagePath;
    res.items.forEach(function (item) {
      if (item.isFolder) {
        folders.push(item);
      } else {
        files.push(item);
      }
    });
    this.plugin.setPluginState({
      folders: folders,
      files: files
    });
  }
  /**
   * Called only the first time the provider view is rendered.
   * Kind of like an init function.
   */
  ;

  _proto.preFirstRender = function preFirstRender() {
    this.plugin.setPluginState({
      didFirstRender: true
    });
    this.plugin.onFirstRender();
  }
  /**
   * Based on folder ID, fetch a new folder and update it to state
   *
   * @param  {string} id Folder id
   * @returns {Promise}   Folders/files in folder
   */
  ;

  _proto.getFolder = function getFolder(id, name) {
    var _this = this;

    return this._sharedHandler.loaderWrapper(this.provider.list(id), function (res) {
      var folders = [];
      var files = [];
      var updatedDirectories;

      var state = _this.plugin.getPluginState();

      var index = findIndex(state.directories, function (dir) {
        return id === dir.id;
      });

      if (index !== -1) {
        updatedDirectories = state.directories.slice(0, index + 1);
      } else {
        updatedDirectories = state.directories.concat([{
          id: id,
          title: name
        }]);
      }

      _this.username = res.username || _this.username;

      _this._updateFilesAndFolders(res, files, folders);

      _this.plugin.setPluginState({
        directories: updatedDirectories
      });
    }, this.handleError);
  }
  /**
   * Fetches new folder
   *
   * @param  {object} folder
   */
  ;

  _proto.getNextFolder = function getNextFolder(folder) {
    this.getFolder(folder.requestPath, folder.name);
    this.lastCheckbox = undefined;
  };

  _proto.addFile = function addFile(file) {
    var tagFile = {
      id: this.providerFileToId(file),
      source: this.plugin.id,
      data: file,
      name: file.name || file.id,
      type: file.mimeType,
      isRemote: true,
      body: {
        fileId: file.id
      },
      remote: {
        companionUrl: this.plugin.opts.companionUrl,
        url: "" + this.provider.fileUrl(file.requestPath),
        body: {
          fileId: file.id
        },
        providerOptions: this.provider.opts
      }
    };
    var fileType = getFileType(tagFile); // TODO Should we just always use the thumbnail URL if it exists?

    if (fileType && isPreviewSupported(fileType)) {
      tagFile.preview = file.thumbnail;
    }

    this.plugin.uppy.log('Adding remote file');

    try {
      this.plugin.uppy.addFile(tagFile);
      return true;
    } catch (err) {
      if (!err.isRestriction) {
        this.plugin.uppy.log(err);
      }

      return false;
    }
  }
  /**
   * Removes session token on client side.
   */
  ;

  _proto.logout = function logout() {
    var _this2 = this;

    this.provider.logout().then(function (res) {
      if (res.ok) {
        if (!res.revoked) {
          var message = _this2.plugin.uppy.i18n('companionUnauthorizeHint', {
            provider: _this2.plugin.title,
            url: res.manual_revoke_url
          });

          _this2.plugin.uppy.info(message, 'info', 7000);
        }

        var newState = {
          authenticated: false,
          files: [],
          folders: [],
          directories: []
        };

        _this2.plugin.setPluginState(newState);
      }
    }).catch(this.handleError);
  };

  _proto.filterQuery = function filterQuery(e) {
    var state = this.plugin.getPluginState();
    this.plugin.setPluginState(_extends({}, state, {
      filterInput: e ? e.target.value : ''
    }));
  };

  _proto.sortByTitle = function sortByTitle() {
    var state = _extends({}, this.plugin.getPluginState());

    var files = state.files,
        folders = state.folders,
        sorting = state.sorting;
    var sortedFiles = files.sort(function (fileA, fileB) {
      if (sorting === 'titleDescending') {
        return fileB.name.localeCompare(fileA.name);
      }

      return fileA.name.localeCompare(fileB.name);
    });
    var sortedFolders = folders.sort(function (folderA, folderB) {
      if (sorting === 'titleDescending') {
        return folderB.name.localeCompare(folderA.name);
      }

      return folderA.name.localeCompare(folderB.name);
    });
    this.plugin.setPluginState(_extends({}, state, {
      files: sortedFiles,
      folders: sortedFolders,
      sorting: sorting === 'titleDescending' ? 'titleAscending' : 'titleDescending'
    }));
  };

  _proto.sortByDate = function sortByDate() {
    var state = _extends({}, this.plugin.getPluginState());

    var files = state.files,
        folders = state.folders,
        sorting = state.sorting;
    var sortedFiles = files.sort(function (fileA, fileB) {
      var a = new Date(fileA.modifiedDate);
      var b = new Date(fileB.modifiedDate);

      if (sorting === 'dateDescending') {
        return a > b ? -1 : a < b ? 1 : 0;
      }

      return a > b ? 1 : a < b ? -1 : 0;
    });
    var sortedFolders = folders.sort(function (folderA, folderB) {
      var a = new Date(folderA.modifiedDate);
      var b = new Date(folderB.modifiedDate);

      if (sorting === 'dateDescending') {
        return a > b ? -1 : a < b ? 1 : 0;
      }

      return a > b ? 1 : a < b ? -1 : 0;
    });
    this.plugin.setPluginState(_extends({}, state, {
      files: sortedFiles,
      folders: sortedFolders,
      sorting: sorting === 'dateDescending' ? 'dateAscending' : 'dateDescending'
    }));
  };

  _proto.sortBySize = function sortBySize() {
    var state = _extends({}, this.plugin.getPluginState());

    var files = state.files,
        sorting = state.sorting; // check that plugin supports file sizes

    if (!files.length || !this.plugin.getItemData(files[0]).size) {
      return;
    }

    var sortedFiles = files.sort(function (fileA, fileB) {
      var a = fileA.size;
      var b = fileB.size;

      if (sorting === 'sizeDescending') {
        return a > b ? -1 : a < b ? 1 : 0;
      }

      return a > b ? 1 : a < b ? -1 : 0;
    });
    this.plugin.setPluginState(_extends({}, state, {
      files: sortedFiles,
      sorting: sorting === 'sizeDescending' ? 'sizeAscending' : 'sizeDescending'
    }));
  }
  /**
   * Adds all files found inside of specified folder.
   *
   * Uses separated state while folder contents are being fetched and
   * mantains list of selected folders, which are separated from files.
   */
  ;

  _proto.addFolder = function addFolder(folder) {
    var _this3 = this;

    var folderId = this.providerFileToId(folder);
    var state = this.plugin.getPluginState();

    var folders = _extends({}, state.selectedFolders);

    if (folderId in folders && folders[folderId].loading) {
      return;
    }

    folders[folderId] = {
      loading: true,
      files: []
    };
    this.plugin.setPluginState({
      selectedFolders: _extends({}, folders)
    });
    return this.listAllFiles(folder.requestPath).then(function (files) {
      var count = 0;
      files.forEach(function (file) {
        var success = _this3.addFile(file);

        if (success) count++;
      });
      var ids = files.map(_this3.providerFileToId);
      folders[folderId] = {
        loading: false,
        files: ids
      };

      _this3.plugin.setPluginState({
        selectedFolders: folders
      });

      var message;

      if (files.length) {
        message = _this3.plugin.uppy.i18n('folderAdded', {
          smart_count: count,
          folder: folder.name
        });
      } else {
        message = _this3.plugin.uppy.i18n('emptyFolderAdded');
      }

      _this3.plugin.uppy.info(message);
    }).catch(function (e) {
      var state = _this3.plugin.getPluginState();

      var selectedFolders = _extends({}, state.selectedFolders);

      delete selectedFolders[folderId];

      _this3.plugin.setPluginState({
        selectedFolders: selectedFolders
      });

      _this3.handleError(e);
    });
  };

  _proto.providerFileToId = function providerFileToId(file) {
    return generateFileID({
      data: file,
      name: file.name || file.id,
      type: file.mimeType
    });
  };

  _proto.handleAuth = function handleAuth() {
    var _this4 = this;

    var authState = btoa(JSON.stringify({
      origin: getOrigin()
    }));
    var clientVersion = "@uppy/provider-views=" + ProviderView.VERSION;
    var link = this.provider.authUrl({
      state: authState,
      uppyVersions: clientVersion
    });
    var authWindow = window.open(link, '_blank');

    var handleToken = function handleToken(e) {
      if (!_this4._isOriginAllowed(e.origin, _this4.plugin.opts.companionAllowedHosts) || e.source !== authWindow) {
        _this4.plugin.uppy.log("rejecting event from " + e.origin + " vs allowed pattern " + _this4.plugin.opts.companionAllowedHosts);

        return;
      } // Check if it's a string before doing the JSON.parse to maintain support
      // for older Companion versions that used object references


      var data = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;

      if (!data.token) {
        _this4.plugin.uppy.log('did not receive token from auth window');

        return;
      }

      authWindow.close();
      window.removeEventListener('message', handleToken);

      _this4.provider.setAuthToken(data.token);

      _this4.preFirstRender();
    };

    window.addEventListener('message', handleToken);
  };

  _proto._isOriginAllowed = function _isOriginAllowed(origin, allowedOrigin) {
    var getRegex = function getRegex(value) {
      if (typeof value === 'string') {
        return new RegExp("^" + value + "$");
      }

      if (value instanceof RegExp) {
        return value;
      }
    };

    var patterns = Array.isArray(allowedOrigin) ? allowedOrigin.map(getRegex) : [getRegex(allowedOrigin)];
    return patterns.filter(function (pattern) {
      return pattern != null;
    }) // loose comparison to catch undefined
    .some(function (pattern) {
      return pattern.test(origin) || pattern.test(origin + "/");
    }); // allowing for trailing '/'
  };

  _proto.handleError = function handleError(error) {
    var uppy = this.plugin.uppy;
    uppy.log(error.toString());

    if (error.isAuthError) {
      return;
    }

    var message = uppy.i18n('companionError');
    uppy.info({
      message: message,
      details: error.toString()
    }, 'error', 5000);
  };

  _proto.handleScroll = function handleScroll(e) {
    var _this5 = this;

    var scrollPos = e.target.scrollHeight - (e.target.scrollTop + e.target.offsetHeight);
    var path = this.nextPagePath || null;

    if (scrollPos < 50 && path && !this._isHandlingScroll) {
      this.provider.list(path).then(function (res) {
        var _this5$plugin$getPlug = _this5.plugin.getPluginState(),
            files = _this5$plugin$getPlug.files,
            folders = _this5$plugin$getPlug.folders;

        _this5._updateFilesAndFolders(res, files, folders);
      }).catch(this.handleError).then(function () {
        _this5._isHandlingScroll = false;
      }); // always called

      this._isHandlingScroll = true;
    }
  };

  _proto.listAllFiles = function listAllFiles(path, files) {
    var _this6 = this;

    if (files === void 0) {
      files = null;
    }

    files = files || [];
    return new Promise(function (resolve, reject) {
      _this6.provider.list(path).then(function (res) {
        res.items.forEach(function (item) {
          if (!item.isFolder) {
            files.push(item);
          } else {
            _this6.addFolder(item);
          }
        });
        var moreFiles = res.nextPagePath || null;

        if (moreFiles) {
          return _this6.listAllFiles(moreFiles, files).then(function (files) {
            return resolve(files);
          }).catch(function (e) {
            return reject(e);
          });
        }

        return resolve(files);
      }).catch(function (e) {
        return reject(e);
      });
    });
  };

  _proto.donePicking = function donePicking() {
    var _this7 = this;

    var _this$plugin$getPlugi = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi.currentSelection;

    var promises = currentSelection.map(function (file) {
      if (file.isFolder) {
        return _this7.addFolder(file);
      }

      return _this7.addFile(file);
    });

    this._sharedHandler.loaderWrapper(Promise.all(promises), function () {
      _this7.clearSelection();
    }, function () {});
  };

  _proto.cancelPicking = function cancelPicking() {
    this.clearSelection();
    var dashboard = this.plugin.uppy.getPlugin('Dashboard');
    if (dashboard) dashboard.hideAllPanels();
  };

  _proto.clearSelection = function clearSelection() {
    this.plugin.setPluginState({
      currentSelection: []
    });
  };

  _proto.render = function render(state, viewOptions) {
    if (viewOptions === void 0) {
      viewOptions = {};
    }

    var _this$plugin$getPlugi2 = this.plugin.getPluginState(),
        authenticated = _this$plugin$getPlugi2.authenticated,
        didFirstRender = _this$plugin$getPlugi2.didFirstRender;

    if (!didFirstRender) {
      this.preFirstRender();
    } // reload pluginState for "loading" attribute because it might
    // have changed above.


    if (this.plugin.getPluginState().loading) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(LoaderView, {
        i18n: this.plugin.uppy.i18n
      }));
    }

    if (!authenticated) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(AuthView, {
        pluginName: this.plugin.title,
        pluginIcon: this.plugin.icon,
        handleAuth: this.handleAuth,
        i18n: this.plugin.uppy.i18n,
        i18nArray: this.plugin.uppy.i18nArray
      }));
    }

    var targetViewOptions = _extends({}, this.opts, viewOptions);

    var headerProps = {
      showBreadcrumbs: targetViewOptions.showBreadcrumbs,
      getFolder: this.getFolder,
      directories: this.plugin.getPluginState().directories,
      pluginIcon: this.plugin.icon,
      title: this.plugin.title,
      logout: this.logout,
      username: this.username,
      i18n: this.plugin.uppy.i18n
    };

    var browserProps = _extends({}, this.plugin.getPluginState(), {
      username: this.username,
      getNextFolder: this.getNextFolder,
      getFolder: this.getFolder,
      filterItems: this._sharedHandler.filterItems,
      filterQuery: this.filterQuery,
      sortByTitle: this.sortByTitle,
      sortByDate: this.sortByDate,
      logout: this.logout,
      isChecked: this._sharedHandler.isChecked,
      toggleCheckbox: this._sharedHandler.toggleCheckbox,
      handleScroll: this.handleScroll,
      listAllFiles: this.listAllFiles,
      done: this.donePicking,
      cancel: this.cancelPicking,
      headerComponent: Header(headerProps),
      title: this.plugin.title,
      viewType: targetViewOptions.viewType,
      showTitles: targetViewOptions.showTitles,
      showFilter: targetViewOptions.showFilter,
      showBreadcrumbs: targetViewOptions.showBreadcrumbs,
      pluginIcon: this.plugin.icon,
      i18n: this.plugin.uppy.i18n,
      uppyFiles: this.plugin.uppy.getFiles(),
      validateRestrictions: this.plugin.uppy.validateRestrictions
    });

    return h(CloseWrapper, {
      onUnmount: this.clearSelection
    }, h(Browser, browserProps));
  };

  return ProviderView;
}(), _class.VERSION = require('../../package.json').version, _temp);

},{"../../package.json":114,"../Browser":116,"../CloseWrapper":117,"../Loader":125,"../SharedHandler":135,"./../../../utils/lib/findIndex":174,"./../../../utils/lib/generateFileID":175,"./../../../utils/lib/getFileType":183,"./../../../utils/lib/isPreviewSupported":194,"./AuthView":126,"./Header":127,"preact":113}],129:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return [h("span", {
    className: "uppy-ProviderBrowser-user",
    key: "username"
  }, props.username), h("button", {
    type: "button",
    onClick: props.logout,
    className: "uppy-u-reset uppy-ProviderBrowser-userLogout",
    key: "logout"
  }, props.i18n('logOut'))];
};

},{"preact":113}],130:[function(require,module,exports){
module.exports = require('./ProviderView');

},{"./ProviderView":128}],131:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("button", {
    type: "button",
    onClick: props.triggerSearchInput,
    className: "uppy-u-reset uppy-ProviderBrowser-userLogout"
  }, props.i18n('backToSearch'));
};

},{"preact":113}],132:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  var input;

  var handleKeyPress = function handleKeyPress(ev) {
    if (ev.keyCode === 13) {
      validateAndSearch();
    }
  };

  var validateAndSearch = function validateAndSearch() {
    if (input.value) {
      props.search(input.value);
    }
  };

  return h("div", {
    className: "uppy-SearchProvider"
  }, h("input", {
    className: "uppy-u-reset uppy-c-textInput uppy-SearchProvider-input",
    type: "text",
    "aria-label": props.i18n('enterTextToSearch'),
    placeholder: props.i18n('enterTextToSearch'),
    onKeyUp: handleKeyPress,
    ref: function ref(input_) {
      input = input_;
    },
    "data-uppy-super-focusable": true
  }), h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-SearchProvider-searchButton",
    type: "button",
    onClick: validateAndSearch
  }, props.i18n('searchImages')));
};

},{"preact":113}],133:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var SearchInput = require('./InputView');

var Browser = require('../Browser');

var LoaderView = require('../Loader');

var generateFileID = require('./../../../utils/lib/generateFileID');

var getFileType = require('./../../../utils/lib/getFileType');

var isPreviewSupported = require('./../../../utils/lib/isPreviewSupported');

var Header = require('./Header');

var SharedHandler = require('../SharedHandler');

var CloseWrapper = require('../CloseWrapper');
/**
 * Class to easily generate generic views for Provider plugins
 */


module.exports = (_temp = _class = /*#__PURE__*/function () {
  /**
   * @param {object} plugin instance of the plugin
   * @param {object} opts
   */
  function ProviderView(plugin, opts) {
    this.plugin = plugin;
    this.provider = opts.provider;
    this._sharedHandler = new SharedHandler(plugin); // set default options

    var defaultOptions = {
      viewType: 'grid',
      showTitles: false,
      showFilter: false,
      showBreadcrumbs: false
    }; // merge default options with the ones set by user

    this.opts = _extends({}, defaultOptions, opts); // Logic

    this.search = this.search.bind(this);
    this.triggerSearchInput = this.triggerSearchInput.bind(this);
    this.addFile = this.addFile.bind(this);
    this.preFirstRender = this.preFirstRender.bind(this);
    this.handleError = this.handleError.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.donePicking = this.donePicking.bind(this);
    this.cancelPicking = this.cancelPicking.bind(this);
    this.clearSelection = this.clearSelection.bind(this); // Visual

    this.render = this.render.bind(this);
    this.clearSelection(); // Set default state for the plugin

    this.plugin.setPluginState({
      isInputMode: true,
      files: [],
      folders: [],
      directories: [],
      filterInput: '',
      isSearchVisible: false
    });
  }

  var _proto = ProviderView.prototype;

  _proto.tearDown = function tearDown() {// Nothing.
  };

  _proto._updateFilesAndInputMode = function _updateFilesAndInputMode(res, files) {
    this.nextPageQuery = res.nextPageQuery;
    this._searchTerm = res.searchedFor;
    res.items.forEach(function (item) {
      files.push(item);
    });
    this.plugin.setPluginState({
      isInputMode: false,
      files: files
    });
  }
  /**
   * Called only the first time the provider view is rendered.
   * Kind of like an init function.
   */
  ;

  _proto.preFirstRender = function preFirstRender() {
    this.plugin.setPluginState({
      didFirstRender: true
    });
    this.plugin.onFirstRender();
  };

  _proto.search = function search(query) {
    var _this = this;

    if (query && query === this._searchTerm) {
      // no need to search again as this is the same as the previous search
      this.plugin.setPluginState({
        isInputMode: false
      });
      return;
    }

    return this._sharedHandler.loaderWrapper(this.provider.search(query), function (res) {
      _this._updateFilesAndInputMode(res, []);
    }, this.handleError);
  };

  _proto.triggerSearchInput = function triggerSearchInput() {
    this.plugin.setPluginState({
      isInputMode: true
    });
  } // @todo this function should really be a function of the plugin and not the view.
  // maybe we should consider creating a base ProviderPlugin class that has this method
  ;

  _proto.addFile = function addFile(file) {
    var tagFile = {
      id: this.providerFileToId(file),
      source: this.plugin.id,
      data: file,
      name: file.name || file.id,
      type: file.mimeType,
      isRemote: true,
      body: {
        fileId: file.id
      },
      remote: {
        companionUrl: this.plugin.opts.companionUrl,
        url: "" + this.provider.fileUrl(file.requestPath),
        body: {
          fileId: file.id
        },
        providerOptions: _extends({}, this.provider.opts, {
          provider: null
        })
      }
    };
    var fileType = getFileType(tagFile); // TODO Should we just always use the thumbnail URL if it exists?

    if (fileType && isPreviewSupported(fileType)) {
      tagFile.preview = file.thumbnail;
    }

    this.plugin.uppy.log('Adding remote file');

    try {
      this.plugin.uppy.addFile(tagFile);
    } catch (err) {
      if (!err.isRestriction) {
        this.plugin.uppy.log(err);
      }
    }
  };

  _proto.providerFileToId = function providerFileToId(file) {
    return generateFileID({
      data: file,
      name: file.name || file.id,
      type: file.mimeType
    });
  };

  _proto.handleError = function handleError(error) {
    var uppy = this.plugin.uppy;
    uppy.log(error.toString());
    var message = uppy.i18n('companionError');
    uppy.info({
      message: message,
      details: error.toString()
    }, 'error', 5000);
  };

  _proto.handleScroll = function handleScroll(e) {
    var _this2 = this;

    var scrollPos = e.target.scrollHeight - (e.target.scrollTop + e.target.offsetHeight);
    var query = this.nextPageQuery || null;

    if (scrollPos < 50 && query && !this._isHandlingScroll) {
      this.provider.search(this._searchTerm, query).then(function (res) {
        var _this2$plugin$getPlug = _this2.plugin.getPluginState(),
            files = _this2$plugin$getPlug.files;

        _this2._updateFilesAndInputMode(res, files);
      }).catch(this.handleError).then(function () {
        _this2._isHandlingScroll = false;
      }); // always called

      this._isHandlingScroll = true;
    }
  };

  _proto.donePicking = function donePicking() {
    var _this3 = this;

    var _this$plugin$getPlugi = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi.currentSelection;

    var promises = currentSelection.map(function (file) {
      return _this3.addFile(file);
    });

    this._sharedHandler.loaderWrapper(Promise.all(promises), function () {
      _this3.clearSelection();
    }, function () {});
  };

  _proto.cancelPicking = function cancelPicking() {
    this.clearSelection();
    var dashboard = this.plugin.uppy.getPlugin('Dashboard');
    if (dashboard) dashboard.hideAllPanels();
  };

  _proto.clearSelection = function clearSelection() {
    this.plugin.setPluginState({
      currentSelection: []
    });
  };

  _proto.render = function render(state, viewOptions) {
    if (viewOptions === void 0) {
      viewOptions = {};
    }

    var _this$plugin$getPlugi2 = this.plugin.getPluginState(),
        didFirstRender = _this$plugin$getPlugi2.didFirstRender,
        isInputMode = _this$plugin$getPlugi2.isInputMode;

    if (!didFirstRender) {
      this.preFirstRender();
    } // reload pluginState for "loading" attribute because it might
    // have changed above.


    if (this.plugin.getPluginState().loading) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(LoaderView, {
        i18n: this.plugin.uppy.i18n
      }));
    }

    if (isInputMode) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(SearchInput, {
        search: this.search,
        i18n: this.plugin.uppy.i18n
      }));
    }

    var targetViewOptions = _extends({}, this.opts, viewOptions);

    var browserProps = _extends({}, this.plugin.getPluginState(), {
      isChecked: this._sharedHandler.isChecked,
      toggleCheckbox: this._sharedHandler.toggleCheckbox,
      handleScroll: this.handleScroll,
      done: this.donePicking,
      cancel: this.cancelPicking,
      headerComponent: Header({
        triggerSearchInput: this.triggerSearchInput,
        i18n: this.plugin.uppy.i18n
      }),
      title: this.plugin.title,
      viewType: targetViewOptions.viewType,
      showTitles: targetViewOptions.showTitles,
      showFilter: targetViewOptions.showFilter,
      showBreadcrumbs: targetViewOptions.showBreadcrumbs,
      pluginIcon: this.plugin.icon,
      i18n: this.plugin.uppy.i18n,
      uppyFiles: this.plugin.uppy.getFiles(),
      validateRestrictions: this.plugin.uppy.validateRestrictions
    });

    return h(CloseWrapper, {
      onUnmount: this.clearSelection
    }, h(Browser, browserProps));
  };

  return ProviderView;
}(), _class.VERSION = require('../../package.json').version, _temp);

},{"../../package.json":114,"../Browser":116,"../CloseWrapper":117,"../Loader":125,"../SharedHandler":135,"./../../../utils/lib/generateFileID":175,"./../../../utils/lib/getFileType":183,"./../../../utils/lib/isPreviewSupported":194,"./Header":131,"./InputView":132,"preact":113}],134:[function(require,module,exports){
module.exports = require('./SearchProviderView');

},{"./SearchProviderView":133}],135:[function(require,module,exports){
var remoteFileObjToLocal = require('./../../utils/lib/remoteFileObjToLocal');

module.exports = /*#__PURE__*/function () {
  function SharedHandler(plugin) {
    this.plugin = plugin;
    this.filterItems = this.filterItems.bind(this);
    this.toggleCheckbox = this.toggleCheckbox.bind(this);
    this.isChecked = this.isChecked.bind(this);
    this.loaderWrapper = this.loaderWrapper.bind(this);
  }

  var _proto = SharedHandler.prototype;

  _proto.filterItems = function filterItems(items) {
    var state = this.plugin.getPluginState();

    if (!state.filterInput || state.filterInput === '') {
      return items;
    }

    return items.filter(function (folder) {
      return folder.name.toLowerCase().indexOf(state.filterInput.toLowerCase()) !== -1;
    });
  }
  /**
   * Toggles file/folder checkbox to on/off state while updating files list.
   *
   * Note that some extra complexity comes from supporting shift+click to
   * toggle multiple checkboxes at once, which is done by getting all files
   * in between last checked file and current one.
   */
  ;

  _proto.toggleCheckbox = function toggleCheckbox(e, file) {
    var _this = this;

    e.stopPropagation();
    e.preventDefault();
    e.currentTarget.focus();

    var _this$plugin$getPlugi = this.plugin.getPluginState(),
        folders = _this$plugin$getPlugi.folders,
        files = _this$plugin$getPlugi.files;

    var items = this.filterItems(folders.concat(files)); // Shift-clicking selects a single consecutive list of items
    // starting at the previous click and deselects everything else.

    if (this.lastCheckbox && e.shiftKey) {
      var _currentSelection;

      var prevIndex = items.indexOf(this.lastCheckbox);
      var currentIndex = items.indexOf(file);

      if (prevIndex < currentIndex) {
        _currentSelection = items.slice(prevIndex, currentIndex + 1);
      } else {
        _currentSelection = items.slice(currentIndex, prevIndex + 1);
      } // Check restrictions on each file in currentSelection,
      // reduce it to only contain files that pass restrictions


      _currentSelection = _currentSelection.reduce(function (reducedCurrentSelection, item) {
        var uppy = _this.plugin.uppy;
        var validatedRestrictions = uppy.validateRestrictions(remoteFileObjToLocal(item), [].concat(uppy.getFiles(), reducedCurrentSelection));

        if (!validatedRestrictions.result) {
          uppy.info({
            message: validatedRestrictions.reason
          }, 'error', uppy.opts.infoTimeout);
          return reducedCurrentSelection;
        }

        return [].concat(reducedCurrentSelection, [item]);
      });
      this.plugin.setPluginState({
        currentSelection: _currentSelection
      });
      return;
    }

    this.lastCheckbox = file;

    var _this$plugin$getPlugi2 = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi2.currentSelection;

    if (this.isChecked(file)) {
      this.plugin.setPluginState({
        currentSelection: currentSelection.filter(function (item) {
          return item.id !== file.id;
        })
      });
    } else {
      this.plugin.setPluginState({
        currentSelection: currentSelection.concat([file])
      });
    }
  };

  _proto.isChecked = function isChecked(file) {
    var _this$plugin$getPlugi3 = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi3.currentSelection; // comparing id instead of the file object, because the reference to the object
    // changes when we switch folders, and the file list is updated


    return currentSelection.some(function (item) {
      return item.id === file.id;
    });
  };

  _proto.loaderWrapper = function loaderWrapper(promise, then, catch_) {
    var _this2 = this;

    promise.then(function (result) {
      _this2.plugin.setPluginState({
        loading: false
      });

      then(result);
    }).catch(function (err) {
      _this2.plugin.setPluginState({
        loading: false
      });

      catch_(err);
    });
    this.plugin.setPluginState({
      loading: true
    });
  };

  return SharedHandler;
}();

},{"./../../utils/lib/remoteFileObjToLocal":197}],136:[function(require,module,exports){
var ProviderViews = require('./ProviderView');

var SearchProviderViews = require('./SearchProviderView');

module.exports = {
  ProviderViews: ProviderViews,
  SearchProviderViews: SearchProviderViews
};

},{"./ProviderView":130,"./SearchProviderView":134}],137:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],138:[function(require,module,exports){
module.exports={
  "name": "@uppy/screen-capture",
  "description": "Uppy plugin that captures video from display or application.",
  "version": "1.0.21",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "screen capture",
    "video",
    "record",
    "mediarecorder"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  },
  "publishConfig": {
    "access": "public"
  }
}

},{}],139:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var RecordButton = require('./RecordButton');

var SubmitButton = require('./SubmitButton');

var StopWatch = require('./StopWatch');

var StreamStatus = require('./StreamStatus');

var RecorderScreen = /*#__PURE__*/function (_Component) {
  _inheritsLoose(RecorderScreen, _Component);

  function RecorderScreen() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = RecorderScreen.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.onStop();
  };

  _proto.render = function render() {
    var _this = this;

    var _this$props = this.props,
        recording = _this$props.recording,
        videoStream = _this$props.stream,
        recordedVideo = _this$props.recordedVideo;
    var videoProps = {
      playsinline: true
    }; // show stream

    if (recording || !recordedVideo && !recording) {
      videoProps.muted = true;
      videoProps.autoplay = true;
      videoProps.srcObject = videoStream;
    } // show preview


    if (recordedVideo && !recording) {
      videoProps.muted = false;
      videoProps.controls = true;
      videoProps.src = recordedVideo; // reset srcObject in dom. If not resetted, stream sticks in element

      if (this.videoElement) {
        this.videoElement.srcObject = undefined;
      }
    }

    return h("div", {
      className: "uppy uppy-ScreenCapture-container"
    }, h("div", {
      className: "uppy-ScreenCapture-videoContainer"
    }, h(StreamStatus, this.props), h("video", _extends({
      ref: function ref(videoElement) {
        return _this.videoElement = videoElement;
      },
      className: "uppy-ScreenCapture-video"
    }, videoProps)), h(StopWatch, this.props)), h("div", {
      className: "uppy-ScreenCapture-buttonContainer"
    }, h(RecordButton, this.props), h(SubmitButton, this.props)));
  };

  return RecorderScreen;
}(Component);

module.exports = RecorderScreen;

},{"./RecordButton":140,"./StopWatch":142,"./StreamStatus":143,"./SubmitButton":144,"preact":137}],140:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;
/**
 * Control screen capture recording. Will show record or stop button.
 */


module.exports = function RecordButton(_ref) {
  var recording = _ref.recording,
      onStartRecording = _ref.onStartRecording,
      onStopRecording = _ref.onStopRecording,
      i18n = _ref.i18n;

  if (recording) {
    return h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-ScreenCapture-button uppy-ScreenCapture-button--video uppy-ScreenCapture-button--stop-rec",
      type: "button",
      title: i18n('stopCapturing'),
      "aria-label": i18n('stopCapturing'),
      onClick: onStopRecording,
      "data-uppy-super-focusable": true
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      width: "100",
      height: "100",
      viewBox: "0 0 100 100"
    }, h("rect", {
      x: "15",
      y: "15",
      width: "70",
      height: "70"
    })));
  }

  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-ScreenCapture-button uppy-ScreenCapture-button--video",
    type: "button",
    title: i18n('startCapturing'),
    "aria-label": i18n('startCapturing'),
    onClick: onStartRecording,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "100",
    height: "100",
    viewBox: "0 0 100 100"
  }, h("circle", {
    cx: "50",
    cy: "50",
    r: "40"
  })));
};

},{"preact":137}],141:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function () {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("rect", {
    className: "uppy-ProviderIconBg",
    fill: "#2C3E50",
    width: "32",
    height: "32",
    rx: "16"
  }), h("path", {
    d: "M24.182 9H7.818C6.81 9 6 9.742 6 10.667v10c0 .916.81 1.666 1.818 1.666h4.546V24h7.272v-1.667h4.546c1 0 1.809-.75 1.809-1.666l.009-10C26 9.742 25.182 9 24.182 9zM24 21H8V11h16v10z",
    fill: "#FFF",
    fillRule: "nonzero"
  }), h("circle", {
    fill: "#FFF",
    cx: "16",
    cy: "16",
    r: "2"
  })));
};

},{"preact":137}],142:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var Stopwatch = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Stopwatch, _Component);

  function Stopwatch(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.state = {
      elapsedTime: 0
    };
    _this.wrapperStyle = {
      width: '100%',
      height: '100%',
      display: 'flex'
    };
    _this.overlayStyle = {
      position: 'absolute',
      width: '100%',
      height: '100%',
      background: 'black',
      opacity: 0.7
    };
    _this.infoContainerStyle = {
      marginLeft: 'auto',
      marginRight: 'auto',
      marginTop: 'auto',
      marginBottom: 'auto',
      zIndex: 1,
      color: 'white'
    };
    _this.infotextStyle = {
      marginLeft: 'auto',
      marginRight: 'auto',
      marginBottom: '1rem',
      fontSize: '1.5rem'
    };
    _this.timeStyle = {
      display: 'block',
      fontWeight: 'bold',
      marginLeft: 'auto',
      marginRight: 'auto',
      fontSize: '3rem',
      fontFamily: 'Courier New'
    };
    return _this;
  }

  var _proto = Stopwatch.prototype;

  _proto.startTimer = function startTimer() {
    this.timerTick();
    this.timerRunning = true;
  };

  _proto.resetTimer = function resetTimer() {
    clearTimeout(this.timer);
    this.setState({
      elapsedTime: 0
    });
    this.timerRunning = false;
  };

  _proto.timerTick = function timerTick() {
    var _this2 = this;

    this.timer = setTimeout(function () {
      _this2.setState({
        elapsedTime: _this2.state.elapsedTime + 1
      });

      _this2.timerTick();
    }, 1000);
  };

  _proto.fmtMSS = function fmtMSS(s) {
    return (s - (s %= 60)) / 60 + (s > 9 ? ':' : ':0') + s;
  };

  _proto.render = function render() {
    var _this$props = _extends({}, this.props),
        recording = _this$props.recording,
        i18n = _this$props.i18n; // second to minutes and seconds


    var minAndSec = this.fmtMSS(this.state.elapsedTime);

    if (recording && !this.timerRunning) {
      this.startTimer();
    }

    if (!recording && this.timerRunning) {
      this.resetTimer();
    }

    if (recording) {
      return h("div", {
        style: this.wrapperStyle
      }, h("div", {
        style: this.overlayStyle
      }), h("div", {
        style: this.infoContainerStyle
      }, h("div", {
        style: this.infotextStyle
      }, i18n('recording')), h("div", {
        style: this.timeStyle
      }, minAndSec)));
    }

    return null;
  };

  return Stopwatch;
}(Component);

module.exports = Stopwatch;

},{"preact":137}],143:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (_ref) {
  var streamActive = _ref.streamActive,
      i18n = _ref.i18n;

  if (streamActive) {
    return h("div", {
      title: i18n('streamActive'),
      "aria-label": i18n('streamActive'),
      className: "uppy-ScreenCapture-icon--stream uppy-ScreenCapture-icon--streamActive"
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24"
    }, h("path", {
      d: "M0 0h24v24H0z",
      opacity: ".1",
      fill: "none"
    }), h("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }), h("path", {
      d: "M1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm18-7H5v1.63c3.96 1.28 7.09 4.41 8.37 8.37H19V7zM1 10v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11zm20-7H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
    })));
  }

  return h("div", {
    title: i18n('streamPassive'),
    "aria-label": i18n('streamPassive'),
    className: "uppy-ScreenCapture-icon--stream"
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24"
  }, h("path", {
    d: "M0 0h24v24H0z",
    opacity: ".1",
    fill: "none"
  }), h("path", {
    d: "M0 0h24v24H0z",
    fill: "none"
  }), h("path", {
    d: "M21 3H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0-4v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11z"
  })));
};

},{"preact":137}],144:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;
/**
 * Submit recorded video to uppy. Enabled when file is available
 */


module.exports = function SubmitButton(_ref) {
  var recording = _ref.recording,
      recordedVideo = _ref.recordedVideo,
      onSubmit = _ref.onSubmit,
      i18n = _ref.i18n;

  if (recordedVideo && !recording) {
    return h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-ScreenCapture-button uppy-ScreenCapture-button--submit",
      type: "button",
      title: i18n('submitRecordedFile'),
      "aria-label": i18n('submitRecordedFile'),
      onClick: onSubmit,
      "data-uppy-super-focusable": true
    }, h("svg", {
      width: "12",
      height: "9",
      viewBox: "0 0 12 9",
      xmlns: "http://www.w3.org/2000/svg",
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon"
    }, h("path", {
      fill: "#fff",
      fillRule: "nonzero",
      d: "M10.66 0L12 1.31 4.136 9 0 4.956l1.34-1.31L4.136 6.38z"
    })));
  }

  return null;
};

},{"preact":137}],145:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h;

var _require2 = require('./../../core'),
    Plugin = _require2.Plugin;

var Translator = require('./../../utils/lib/Translator');

var getFileTypeExtension = require('./../../utils/lib/getFileTypeExtension');

var ScreenRecIcon = require('./ScreenRecIcon');

var CaptureScreen = require('./CaptureScreen'); // Adapted from: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia


function getMediaDevices() {
  // check if screen capturing is supported

  /* eslint-disable */
  if (navigator && navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia && window && window.MediaRecorder) {
    return navigator.mediaDevices;
  }
  /* eslint-enable */


  return null;
}
/**
 * Screen capture
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(ScreenCapture, _Plugin);

  function ScreenCapture(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.mediaDevices = getMediaDevices();
    _this.protocol = location.protocol.match(/https/i) ? 'https' : 'http';
    _this.id = _this.opts.id || 'ScreenCapture';
    _this.title = _this.opts.title || 'Screencast';
    _this.type = 'acquirer';
    _this.icon = ScreenRecIcon;
    _this.defaultLocale = {
      strings: {
        startCapturing: 'Begin screen capturing',
        stopCapturing: 'Stop screen capturing',
        submitRecordedFile: 'Submit recorded file',
        streamActive: 'Stream active',
        streamPassive: 'Stream passive',
        micDisabled: 'Microphone access denied by user',
        recording: 'Recording'
      }
    }; // set default options
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints

    var defaultOptions = {
      // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#Properties_of_shared_screen_tracks
      displayMediaConstraints: {
        video: {
          width: 1280,
          height: 720,
          frameRate: {
            ideal: 3,
            max: 5
          },
          cursor: 'motion',
          displaySurface: 'monitor'
        }
      },
      // https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints/audio
      userMediaConstraints: {
        audio: true
      },
      preferredVideoMimeType: 'video/webm'
    }; // merge default options with the ones set by user

    _this.opts = _extends({}, defaultOptions, opts); // i18n

    _this.translator = new Translator([_this.defaultLocale, _this.uppy.locale, _this.opts.locale]);
    _this.i18n = _this.translator.translate.bind(_this.translator);
    _this.i18nArray = _this.translator.translateArray.bind(_this.translator); // uppy plugin class related

    _this.install = _this.install.bind(_assertThisInitialized(_this));
    _this.setPluginState = _this.setPluginState.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this)); // screen capturer related

    _this.start = _this.start.bind(_assertThisInitialized(_this));
    _this.stop = _this.stop.bind(_assertThisInitialized(_this));
    _this.startRecording = _this.startRecording.bind(_assertThisInitialized(_this));
    _this.stopRecording = _this.stopRecording.bind(_assertThisInitialized(_this));
    _this.submit = _this.submit.bind(_assertThisInitialized(_this));
    _this.streamInterrupted = _this.streamInactivated.bind(_assertThisInitialized(_this)); // initialize

    _this.captureActive = false;
    _this.capturedMediaFile = null;
    return _this;
  }

  var _proto = ScreenCapture.prototype;

  _proto.install = function install() {
    // Return if browser doesn’t support getDisplayMedia and
    if (!this.mediaDevices) {
      this.uppy.log('Screen recorder access is not supported', 'error');
      return null;
    }

    this.setPluginState({
      streamActive: false,
      audioStreamActive: false
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    if (this.videoStream) {
      this.stop();
    }

    this.unmount();
  };

  _proto.start = function start() {
    var _this2 = this;

    if (!this.mediaDevices) {
      return Promise.reject(new Error('Screen recorder access not supported'));
    }

    this.captureActive = true;
    this.selectAudioStreamSource();
    this.selectVideoStreamSource().then(function (res) {
      // something happened in start -> return
      if (res === false) {
        // Close the Dashboard panel if plugin is installed
        // into Dashboard (could be other parent UI plugin)
        if (_this2.parent && _this2.parent.hideAllPanels) {
          _this2.parent.hideAllPanels();

          _this2.captureActive = false;
        }
      }
    });
  };

  _proto.selectVideoStreamSource = function selectVideoStreamSource() {
    var _this3 = this;

    // if active stream available, return it
    if (this.videoStream) {
      return new Promise(function (resolve) {
        return resolve(_this3.videoStream);
      });
    } // ask user to select source to record and get mediastream from that
    // eslint-disable-next-line compat/compat


    return this.mediaDevices.getDisplayMedia(this.opts.displayMediaConstraints).then(function (videoStream) {
      _this3.videoStream = videoStream; // add event listener to stop recording if stream is interrupted

      _this3.videoStream.addEventListener('inactive', function (event) {
        _this3.streamInactivated();
      });

      _this3.setPluginState({
        streamActive: true
      });

      return videoStream;
    }).catch(function (err) {
      _this3.setPluginState({
        screenRecError: err
      });

      _this3.userDenied = true;
      setTimeout(function () {
        _this3.userDenied = false;
      }, 1000);
      return false;
    });
  };

  _proto.selectAudioStreamSource = function selectAudioStreamSource() {
    var _this4 = this;

    // if active stream available, return it
    if (this.audioStream) {
      return new Promise(function (resolve) {
        return resolve(_this4.audioStream);
      });
    } // ask user to select source to record and get mediastream from that
    // eslint-disable-next-line compat/compat


    return this.mediaDevices.getUserMedia(this.opts.userMediaConstraints).then(function (audioStream) {
      _this4.audioStream = audioStream;

      _this4.setPluginState({
        audioStreamActive: true
      });

      return audioStream;
    }).catch(function (err) {
      if (err.name === 'NotAllowedError') {
        _this4.uppy.info(_this4.i18n('micDisabled'), 'error', 5000);
      }

      return false;
    });
  };

  _proto.startRecording = function startRecording() {
    var _this5 = this;

    var options = {};
    this.capturedMediaFile = null;
    this.recordingChunks = [];
    var preferredVideoMimeType = this.opts.preferredVideoMimeType;
    this.selectVideoStreamSource().then(function (videoStream) {
      // Attempt to use the passed preferredVideoMimeType (if any) during recording.
      // If the browser doesn't support it, we'll fall back to the browser default instead
      if (preferredVideoMimeType && MediaRecorder.isTypeSupported(preferredVideoMimeType) && getFileTypeExtension(preferredVideoMimeType)) {
        options.mimeType = preferredVideoMimeType;
      } // prepare tracks


      var tracks = [videoStream.getVideoTracks()[0]]; // merge audio if exits

      if (_this5.audioStream) {
        tracks.push(_this5.audioStream.getAudioTracks()[0]);
      } // create new stream from video and audio
      // eslint-disable-next-line compat/compat


      _this5.outputStream = new MediaStream(tracks); // initialize mediarecorder
      // eslint-disable-next-line compat/compat

      _this5.recorder = new MediaRecorder(_this5.outputStream, options); // push data to buffer when data available

      _this5.recorder.addEventListener('dataavailable', function (event) {
        _this5.recordingChunks.push(event.data);
      }); // start recording


      _this5.recorder.start(); // set plugin state to recording


      _this5.setPluginState({
        recording: true
      });
    }).catch(function (err) {
      _this5.uppy.log(err, 'error');
    });
  };

  _proto.streamInactivated = function streamInactivated() {
    // get screen recorder state
    var _this$getPluginState = _extends({}, this.getPluginState()),
        recordedVideo = _this$getPluginState.recordedVideo,
        recording = _this$getPluginState.recording;

    if (!recordedVideo && !recording) {
      // Close the Dashboard panel if plugin is installed
      // into Dashboard (could be other parent UI plugin)
      if (this.parent && this.parent.hideAllPanels) {
        this.parent.hideAllPanels();
      }
    } else if (recording) {
      // stop recorder if it is active
      this.uppy.log('Capture stream inactive — stop recording');
      this.stopRecording();
    }

    this.videoStream = null;
    this.audioStream = null;
    this.setPluginState({
      streamActive: false,
      audioStreamActive: false
    });
  };

  _proto.stopRecording = function stopRecording() {
    var _this6 = this;

    var stopped = new Promise(function (resolve, reject) {
      _this6.recorder.addEventListener('stop', function () {
        resolve();
      });

      _this6.recorder.stop();
    });
    return stopped.then(function () {
      // recording stopped
      _this6.setPluginState({
        recording: false
      }); // get video file after recorder stopped


      return _this6.getVideo();
    }).then(function (file) {
      // store media file
      _this6.capturedMediaFile = file; // create object url for capture result preview

      _this6.setPluginState({
        // eslint-disable-next-line compat/compat
        recordedVideo: URL.createObjectURL(file.data)
      });
    }).then(function () {
      _this6.recordingChunks = null;
      _this6.recorder = null;
    }, function (error) {
      _this6.recordingChunks = null;
      _this6.recorder = null;
      throw error;
    });
  };

  _proto.submit = function submit() {
    try {
      // add recorded file to uppy
      if (this.capturedMediaFile) {
        this.uppy.addFile(this.capturedMediaFile);
      }
    } catch (err) {
      // Logging the error, exept restrictions, which is handled in Core
      if (!err.isRestriction) {
        this.uppy.log(err, 'error');
      }
    }
  };

  _proto.stop = function stop() {
    // flush video stream
    if (this.videoStream) {
      this.videoStream.getVideoTracks().forEach(function (track) {
        track.stop();
      });
      this.videoStream.getAudioTracks().forEach(function (track) {
        track.stop();
      });
      this.videoStream = null;
    } // flush audio stream


    if (this.audioStream) {
      this.audioStream.getAudioTracks().forEach(function (track) {
        track.stop();
      });
      this.audioStream.getVideoTracks().forEach(function (track) {
        track.stop();
      });
      this.audioStream = null;
    } // flush output stream


    if (this.outputStream) {
      this.outputStream.getAudioTracks().forEach(function (track) {
        track.stop();
      });
      this.outputStream.getVideoTracks().forEach(function (track) {
        track.stop();
      });
      this.outputStream = null;
    } // remove preview video


    this.setPluginState({
      recordedVideo: null
    });
    this.captureActive = false;
  };

  _proto.getVideo = function getVideo() {
    var mimeType = this.recordingChunks[0].type;
    var fileExtension = getFileTypeExtension(mimeType);

    if (!fileExtension) {
      return Promise.reject(new Error("Could not retrieve recording: Unsupported media type \"" + mimeType + "\""));
    }

    var name = "screencap-" + Date.now() + "." + fileExtension;
    var blob = new Blob(this.recordingChunks, {
      type: mimeType
    });
    var file = {
      source: this.id,
      name: name,
      data: new Blob([blob], {
        type: mimeType
      }),
      type: mimeType
    };
    return Promise.resolve(file);
  };

  _proto.render = function render(state) {
    // get screen recorder state
    var recorderState = this.getPluginState();

    if (!recorderState.streamActive && !this.captureActive && !this.userDenied) {
      this.start();
    }

    return h(CaptureScreen, _extends({}, recorderState, {
      onStartRecording: this.startRecording,
      onStopRecording: this.stopRecording,
      onStop: this.stop,
      onSubmit: this.submit,
      i18n: this.i18n,
      stream: this.videoStream
    }));
  };

  return ScreenCapture;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":138,"./../../core":55,"./../../utils/lib/Translator":167,"./../../utils/lib/getFileTypeExtension":184,"./CaptureScreen":139,"./ScreenRecIcon":141,"preact":137}],146:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],147:[function(require,module,exports){
module.exports={
  "name": "@uppy/status-bar",
  "description": "A progress bar for Uppy, with many bells and whistles.",
  "version": "1.9.6",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "progress bar",
    "status bar",
    "progress",
    "upload",
    "eta",
    "speed"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@transloadit/prettier-bytes": "0.0.7",
    "@uppy/utils": "file:../utils",
    "classnames": "^2.2.6",
    "lodash.throttle": "^4.1.1",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],148:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var throttle = require('lodash.throttle');

var classNames = require('classnames');

var statusBarStates = require('./StatusBarStates');

var prettierBytes = require('@transloadit/prettier-bytes');

var prettyETA = require('./../../utils/lib/prettyETA');

var _require = require('preact'),
    h = _require.h;

function calculateProcessingProgress(files) {
  // Collect pre or postprocessing progress states.
  var progresses = [];
  Object.keys(files).forEach(function (fileID) {
    var progress = files[fileID].progress;

    if (progress.preprocess) {
      progresses.push(progress.preprocess);
    }

    if (progress.postprocess) {
      progresses.push(progress.postprocess);
    }
  }); // In the future we should probably do this differently. For now we'll take the
  // mode and message from the first file…

  var _progresses$ = progresses[0],
      mode = _progresses$.mode,
      message = _progresses$.message;
  var value = progresses.filter(isDeterminate).reduce(function (total, progress, index, all) {
    return total + progress.value / all.length;
  }, 0);

  function isDeterminate(progress) {
    return progress.mode === 'determinate';
  }

  return {
    mode: mode,
    message: message,
    value: value
  };
}

function togglePauseResume(props) {
  if (props.isAllComplete) return;

  if (!props.resumableUploads) {
    return props.cancelAll();
  }

  if (props.isAllPaused) {
    return props.resumeAll();
  }

  return props.pauseAll();
}

function RenderReSelectGhosts(_ref) {
  var i18n = _ref.i18n;
  return h("div", {
    className: "uppy-StatusBar-serviceMsg"
  }, i18n('reSelectGhosts'), h("svg", {
    className: "uppy-c-icon uppy-StatusBar-serviceMsg-ghostsIcon",
    "aria-hidden": "true",
    width: "15",
    height: "19",
    viewBox: "0 0 35 39"
  }, h("path", {
    d: "M1.708 38.66c1.709 0 3.417-3.417 6.834-3.417 3.416 0 5.125 3.417 8.61 3.417 3.348 0 5.056-3.417 8.473-3.417 4.305 0 5.125 3.417 6.833 3.417.889 0 1.709-.889 1.709-1.709v-19.68C34.167-5.757 0-5.757 0 17.271v19.68c0 .82.888 1.709 1.708 1.709zm8.542-17.084a3.383 3.383 0 01-3.417-3.416 3.383 3.383 0 013.417-3.417 3.383 3.383 0 013.417 3.417 3.383 3.383 0 01-3.417 3.416zm13.667 0A3.383 3.383 0 0120.5 18.16a3.383 3.383 0 013.417-3.417 3.383 3.383 0 013.416 3.417 3.383 3.383 0 01-3.416 3.416z",
    fillRule: "nonzero"
  })));
}

module.exports = function (props) {
  props = props || {};
  var _props = props,
      newFiles = _props.newFiles,
      allowNewUpload = _props.allowNewUpload,
      isUploadInProgress = _props.isUploadInProgress,
      isAllPaused = _props.isAllPaused,
      resumableUploads = _props.resumableUploads,
      error = _props.error,
      hideUploadButton = _props.hideUploadButton,
      hidePauseResumeButton = _props.hidePauseResumeButton,
      hideCancelButton = _props.hideCancelButton,
      hideRetryButton = _props.hideRetryButton,
      recoveredState = _props.recoveredState;
  var uploadState = props.uploadState;
  var progressValue = props.totalProgress;
  var progressMode;
  var progressBarContent;

  if (uploadState === statusBarStates.STATE_PREPROCESSING || uploadState === statusBarStates.STATE_POSTPROCESSING) {
    var progress = calculateProcessingProgress(props.files);
    progressMode = progress.mode;

    if (progressMode === 'determinate') {
      progressValue = progress.value * 100;
    }

    progressBarContent = ProgressBarProcessing(progress);
  } else if (uploadState === statusBarStates.STATE_COMPLETE) {
    progressBarContent = ProgressBarComplete(props);
  } else if (uploadState === statusBarStates.STATE_UPLOADING) {
    if (!props.supportsUploadProgress) {
      progressMode = 'indeterminate';
      progressValue = null;
    }

    progressBarContent = ProgressBarUploading(props);
  } else if (uploadState === statusBarStates.STATE_ERROR) {
    progressValue = undefined;
    progressBarContent = ProgressBarError(props);
  }

  var width = typeof progressValue === 'number' ? progressValue : 100;
  var isHidden = uploadState === statusBarStates.STATE_WAITING && props.hideUploadButton || uploadState === statusBarStates.STATE_WAITING && !props.newFiles > 0 || uploadState === statusBarStates.STATE_COMPLETE && props.hideAfterFinish;
  var showUploadBtn = !error && newFiles && !isUploadInProgress && !isAllPaused && allowNewUpload && !hideUploadButton;

  if (recoveredState) {
    isHidden = false;
    showUploadBtn = true;
  }

  var showCancelBtn = !hideCancelButton && uploadState !== statusBarStates.STATE_WAITING && uploadState !== statusBarStates.STATE_COMPLETE;
  var showPauseResumeBtn = resumableUploads && !hidePauseResumeButton && uploadState === statusBarStates.STATE_UPLOADING;
  var showRetryBtn = error && !hideRetryButton;
  var showDoneBtn = props.doneButtonHandler && uploadState === statusBarStates.STATE_COMPLETE;
  var progressClassNames = "uppy-StatusBar-progress\n                           " + (progressMode ? "is-" + progressMode : '');
  var statusBarClassNames = classNames({
    'uppy-Root': props.isTargetDOMEl
  }, 'uppy-StatusBar', "is-" + uploadState, {
    'has-ghosts': props.isSomeGhost
  });
  return h("div", {
    className: statusBarClassNames,
    "aria-hidden": isHidden
  }, h("div", {
    className: progressClassNames,
    style: {
      width: width + "%"
    },
    role: "progressbar",
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    "aria-valuenow": progressValue
  }), progressBarContent, h("div", {
    className: "uppy-StatusBar-actions"
  }, showUploadBtn ? h(UploadBtn, _extends({}, props, {
    uploadState: uploadState
  })) : null, showRetryBtn ? h(RetryBtn, props) : null, showPauseResumeBtn ? h(PauseResumeButton, props) : null, showCancelBtn ? h(CancelBtn, props) : null, showDoneBtn ? h(DoneBtn, props) : null));
};

var UploadBtn = function UploadBtn(props) {
  var uploadBtnClassNames = classNames('uppy-u-reset', 'uppy-c-btn', 'uppy-StatusBar-actionBtn', 'uppy-StatusBar-actionBtn--upload', {
    'uppy-c-btn-primary': props.uploadState === statusBarStates.STATE_WAITING
  }, {
    'uppy-StatusBar-actionBtn--disabled': props.isSomeGhost
  });
  var uploadBtnText = props.newFiles && props.isUploadStarted && !props.recoveredState ? props.i18n('uploadXNewFiles', {
    smart_count: props.newFiles
  }) : props.i18n('uploadXFiles', {
    smart_count: props.newFiles
  });
  return h("button", {
    type: "button",
    className: uploadBtnClassNames,
    "aria-label": props.i18n('uploadXFiles', {
      smart_count: props.newFiles
    }),
    onClick: props.startUpload,
    disabled: props.isSomeGhost,
    "data-uppy-super-focusable": true
  }, uploadBtnText);
};

var RetryBtn = function RetryBtn(props) {
  return h("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--retry",
    "aria-label": props.i18n('retryUpload'),
    onClick: props.retryAll,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "8",
    height: "10",
    viewBox: "0 0 8 10"
  }, h("path", {
    d: "M4 2.408a2.75 2.75 0 1 0 2.75 2.75.626.626 0 0 1 1.25.018v.023a4 4 0 1 1-4-4.041V.25a.25.25 0 0 1 .389-.208l2.299 1.533a.25.25 0 0 1 0 .416l-2.3 1.533A.25.25 0 0 1 4 3.316v-.908z"
  })), props.i18n('retry'));
};

var CancelBtn = function CancelBtn(props) {
  return h("button", {
    type: "button",
    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    title: props.i18n('cancel'),
    "aria-label": props.i18n('cancel'),
    onClick: props.cancelAll,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    fill: "#FFF",
    d: "M9.283 8l2.567 2.567-1.283 1.283L8 9.283 5.433 11.85 4.15 10.567 6.717 8 4.15 5.433 5.433 4.15 8 6.717l2.567-2.567 1.283 1.283z"
  }))));
};

var PauseResumeButton = function PauseResumeButton(props) {
  var isAllPaused = props.isAllPaused,
      i18n = props.i18n;
  var title = isAllPaused ? i18n('resume') : i18n('pause');
  return h("button", {
    title: title,
    "aria-label": title,
    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    type: "button",
    onClick: function onClick() {
      return togglePauseResume(props);
    },
    "data-uppy-super-focusable": true
  }, isAllPaused ? h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    fill: "#FFF",
    d: "M6 4.25L11.5 8 6 11.75z"
  }))) : h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    d: "M5 4.5h2v7H5v-7zm4 0h2v7H9v-7z",
    fill: "#FFF"
  }))));
};

var DoneBtn = function DoneBtn(props) {
  var i18n = props.i18n;
  return h("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--done",
    onClick: props.doneButtonHandler,
    "data-uppy-super-focusable": true
  }, i18n('done'));
};

var LoadingSpinner = function LoadingSpinner() {
  return h("svg", {
    className: "uppy-StatusBar-spinner",
    "aria-hidden": "true",
    focusable: "false",
    width: "14",
    height: "14"
  }, h("path", {
    d: "M13.983 6.547c-.12-2.509-1.64-4.893-3.939-5.936-2.48-1.127-5.488-.656-7.556 1.094C.524 3.367-.398 6.048.162 8.562c.556 2.495 2.46 4.52 4.94 5.183 2.932.784 5.61-.602 7.256-3.015-1.493 1.993-3.745 3.309-6.298 2.868-2.514-.434-4.578-2.349-5.153-4.84a6.226 6.226 0 0 1 2.98-6.778C6.34.586 9.74 1.1 11.373 3.493c.407.596.693 1.282.842 1.988.127.598.073 1.197.161 1.794.078.525.543 1.257 1.15.864.525-.341.49-1.05.456-1.592-.007-.15.02.3 0 0",
    fillRule: "evenodd"
  }));
};

var ProgressBarProcessing = function ProgressBarProcessing(props) {
  var value = Math.round(props.value * 100);
  return h("div", {
    className: "uppy-StatusBar-content"
  }, h(LoadingSpinner, null), props.mode === 'determinate' ? value + "% \xB7 " : '', props.message);
};

var renderDot = function renderDot() {
  return " \xB7 ";
};

var ProgressDetails = function ProgressDetails(props) {
  var ifShowFilesUploadedOfTotal = props.numUploads > 1;
  return h("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, ifShowFilesUploadedOfTotal && props.i18n('filesUploadedOfTotal', {
    complete: props.complete,
    smart_count: props.numUploads
  }), h("span", {
    className: "uppy-StatusBar-additionalInfo"
  }, ifShowFilesUploadedOfTotal && renderDot(), props.i18n('dataUploadedOfTotal', {
    complete: prettierBytes(props.totalUploadedSize),
    total: prettierBytes(props.totalSize)
  }), renderDot(), props.i18n('xTimeLeft', {
    time: prettyETA(props.totalETA)
  })));
};

var UnknownProgressDetails = function UnknownProgressDetails(props) {
  return h("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, props.i18n('filesUploadedOfTotal', {
    complete: props.complete,
    smart_count: props.numUploads
  }));
};

var UploadNewlyAddedFiles = function UploadNewlyAddedFiles(props) {
  var uploadBtnClassNames = classNames('uppy-u-reset', 'uppy-c-btn', 'uppy-StatusBar-actionBtn', 'uppy-StatusBar-actionBtn--uploadNewlyAdded');
  return h("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, h("div", {
    className: "uppy-StatusBar-statusSecondaryHint"
  }, props.i18n('xMoreFilesAdded', {
    smart_count: props.newFiles
  })), h("button", {
    type: "button",
    className: uploadBtnClassNames,
    "aria-label": props.i18n('uploadXFiles', {
      smart_count: props.newFiles
    }),
    onClick: props.startUpload
  }, props.i18n('upload')));
};

var ThrottledProgressDetails = throttle(ProgressDetails, 500, {
  leading: true,
  trailing: true
});

var ProgressBarUploading = function ProgressBarUploading(props) {
  if (!props.isUploadStarted || props.isAllComplete) {
    return null;
  }

  var title = props.isAllPaused ? props.i18n('paused') : props.i18n('uploading');
  var showUploadNewlyAddedFiles = props.newFiles && props.isUploadStarted;
  return h("div", {
    className: "uppy-StatusBar-content",
    "aria-label": title,
    title: title
  }, !props.isAllPaused ? h(LoadingSpinner, null) : null, h("div", {
    className: "uppy-StatusBar-status"
  }, h("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, props.supportsUploadProgress ? title + ": " + props.totalProgress + "%" : title), !props.isAllPaused && !showUploadNewlyAddedFiles && props.showProgressDetails ? props.supportsUploadProgress ? h(ThrottledProgressDetails, props) : h(UnknownProgressDetails, props) : null, showUploadNewlyAddedFiles ? h(UploadNewlyAddedFiles, props) : null));
};

var ProgressBarComplete = function ProgressBarComplete(_ref2) {
  var totalProgress = _ref2.totalProgress,
      i18n = _ref2.i18n;
  return h("div", {
    className: "uppy-StatusBar-content",
    role: "status",
    title: i18n('complete')
  }, h("div", {
    className: "uppy-StatusBar-status"
  }, h("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
    width: "15",
    height: "11",
    viewBox: "0 0 15 11"
  }, h("path", {
    d: "M.414 5.843L1.627 4.63l3.472 3.472L13.202 0l1.212 1.213L5.1 10.528z"
  })), i18n('complete'))));
};

var ProgressBarError = function ProgressBarError(_ref3) {
  var error = _ref3.error,
      retryAll = _ref3.retryAll,
      hideRetryButton = _ref3.hideRetryButton,
      i18n = _ref3.i18n;

  function displayErrorAlert() {
    var errorMessage = i18n('uploadFailed') + " \n\n " + error;
    alert(errorMessage);
  }

  return h("div", {
    className: "uppy-StatusBar-content",
    role: "alert",
    title: i18n('uploadFailed')
  }, h("div", {
    className: "uppy-StatusBar-status"
  }, h("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
    width: "11",
    height: "11",
    viewBox: "0 0 11 11"
  }, h("path", {
    d: "M4.278 5.5L0 1.222 1.222 0 5.5 4.278 9.778 0 11 1.222 6.722 5.5 11 9.778 9.778 11 5.5 6.722 1.222 11 0 9.778z"
  })), i18n('uploadFailed'))), h("span", {
    className: "uppy-StatusBar-details",
    "aria-label": error,
    "data-microtip-position": "top-right",
    "data-microtip-size": "medium",
    role: "tooltip",
    onClick: displayErrorAlert
  }, "?"));
};

},{"./../../utils/lib/prettyETA":196,"./StatusBarStates":149,"@transloadit/prettier-bytes":1,"classnames":4,"lodash.throttle":17,"preact":146}],149:[function(require,module,exports){
module.exports = {
  STATE_ERROR: 'error',
  STATE_WAITING: 'waiting',
  STATE_PREPROCESSING: 'preprocessing',
  STATE_UPLOADING: 'uploading',
  STATE_POSTPROCESSING: 'postprocessing',
  STATE_COMPLETE: 'complete'
};

},{}],150:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Translator = require('./../../utils/lib/Translator');

var StatusBarUI = require('./StatusBar');

var statusBarStates = require('./StatusBarStates');

var getSpeed = require('./../../utils/lib/getSpeed');

var getBytesRemaining = require('./../../utils/lib/getBytesRemaining');

var getTextDirection = require('./../../utils/lib/getTextDirection');
/**
 * StatusBar: renders a status bar with upload/pause/resume/cancel/retry buttons,
 * progress percentage and time remaining.
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(StatusBar, _Plugin);

  function StatusBar(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.startUpload = function () {
      var _this$uppy$getState = _this.uppy.getState(),
          recoveredState = _this$uppy$getState.recoveredState;

      if (recoveredState) {
        _this.uppy.emit('restore-confirmed');

        return;
      }

      return _this.uppy.upload().catch(function () {// Error logged in Core
      });
    };

    _this.id = _this.opts.id || 'StatusBar';
    _this.title = 'StatusBar';
    _this.type = 'progressindicator';
    _this.defaultLocale = {
      strings: {
        uploading: 'Uploading',
        upload: 'Upload',
        complete: 'Complete',
        uploadFailed: 'Upload failed',
        paused: 'Paused',
        retry: 'Retry',
        retryUpload: 'Retry upload',
        cancel: 'Cancel',
        pause: 'Pause',
        resume: 'Resume',
        done: 'Done',
        filesUploadedOfTotal: {
          0: '%{complete} of %{smart_count} file uploaded',
          1: '%{complete} of %{smart_count} files uploaded'
        },
        dataUploadedOfTotal: '%{complete} of %{total}',
        xTimeLeft: '%{time} left',
        uploadXFiles: {
          0: 'Upload %{smart_count} file',
          1: 'Upload %{smart_count} files'
        },
        uploadXNewFiles: {
          0: 'Upload +%{smart_count} file',
          1: 'Upload +%{smart_count} files'
        },
        xMoreFilesAdded: {
          0: '%{smart_count} more file added',
          1: '%{smart_count} more files added'
        }
      }
    }; // set default options

    var defaultOptions = {
      target: 'body',
      hideUploadButton: false,
      hideRetryButton: false,
      hidePauseResumeButton: false,
      hideCancelButton: false,
      showProgressDetails: false,
      hideAfterFinish: true,
      doneButtonHandler: null
    };
    _this.opts = _extends({}, defaultOptions, opts);

    _this.i18nInit();

    _this.render = _this.render.bind(_assertThisInitialized(_this));
    _this.install = _this.install.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = StatusBar.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.getTotalSpeed = function getTotalSpeed(files) {
    var totalSpeed = 0;
    files.forEach(function (file) {
      totalSpeed += getSpeed(file.progress);
    });
    return totalSpeed;
  };

  _proto.getTotalETA = function getTotalETA(files) {
    var totalSpeed = this.getTotalSpeed(files);

    if (totalSpeed === 0) {
      return 0;
    }

    var totalBytesRemaining = files.reduce(function (total, file) {
      return total + getBytesRemaining(file.progress);
    }, 0);
    return Math.round(totalBytesRemaining / totalSpeed * 10) / 10;
  };

  _proto.getUploadingState = function getUploadingState(isAllErrored, isAllComplete, recoveredState, files) {
    if (isAllErrored) {
      return statusBarStates.STATE_ERROR;
    }

    if (isAllComplete) {
      return statusBarStates.STATE_COMPLETE;
    }

    if (recoveredState) {
      return statusBarStates.STATE_WAITING;
    }

    var state = statusBarStates.STATE_WAITING;
    var fileIDs = Object.keys(files);

    for (var i = 0; i < fileIDs.length; i++) {
      var progress = files[fileIDs[i]].progress; // If ANY files are being uploaded right now, show the uploading state.

      if (progress.uploadStarted && !progress.uploadComplete) {
        return statusBarStates.STATE_UPLOADING;
      } // If files are being preprocessed AND postprocessed at this time, we show the
      // preprocess state. If any files are being uploaded we show uploading.


      if (progress.preprocess && state !== statusBarStates.STATE_UPLOADING) {
        state = statusBarStates.STATE_PREPROCESSING;
      } // If NO files are being preprocessed or uploaded right now, but some files are
      // being postprocessed, show the postprocess state.


      if (progress.postprocess && state !== statusBarStates.STATE_UPLOADING && state !== statusBarStates.STATE_PREPROCESSING) {
        state = statusBarStates.STATE_POSTPROCESSING;
      }
    }

    return state;
  };

  _proto.render = function render(state) {
    var capabilities = state.capabilities,
        files = state.files,
        allowNewUpload = state.allowNewUpload,
        totalProgress = state.totalProgress,
        error = state.error,
        recoveredState = state.recoveredState; // TODO: move this to Core, to share between Status Bar and Dashboard
    // (and any other plugin that might need it, too)

    var filesArray = Object.keys(files).map(function (file) {
      return files[file];
    });
    var newFiles = filesArray.filter(function (file) {
      return !file.progress.uploadStarted && !file.progress.preprocess && !file.progress.postprocess;
    }); // If some state was recovered, we want to show Upload button/counter
    // for all the files, because in this case it’s not an Upload button,
    // but “Confirm Restore Button”

    if (recoveredState) {
      newFiles = filesArray;
    }

    var uploadStartedFiles = filesArray.filter(function (file) {
      return file.progress.uploadStarted;
    });
    var pausedFiles = uploadStartedFiles.filter(function (file) {
      return file.isPaused;
    });
    var completeFiles = filesArray.filter(function (file) {
      return file.progress.uploadComplete;
    });
    var erroredFiles = filesArray.filter(function (file) {
      return file.error;
    });
    var inProgressFiles = filesArray.filter(function (file) {
      return !file.progress.uploadComplete && file.progress.uploadStarted;
    });
    var inProgressNotPausedFiles = inProgressFiles.filter(function (file) {
      return !file.isPaused;
    });
    var startedFiles = filesArray.filter(function (file) {
      return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;
    });
    var processingFiles = filesArray.filter(function (file) {
      return file.progress.preprocess || file.progress.postprocess;
    });
    var totalETA = this.getTotalETA(inProgressNotPausedFiles);
    var totalSize = 0;
    var totalUploadedSize = 0;
    startedFiles.forEach(function (file) {
      totalSize += file.progress.bytesTotal || 0;
      totalUploadedSize += file.progress.bytesUploaded || 0;
    });
    var isUploadStarted = startedFiles.length > 0;
    var isAllComplete = totalProgress === 100 && completeFiles.length === Object.keys(files).length && processingFiles.length === 0;
    var isAllErrored = error && erroredFiles.length === filesArray.length;
    var isAllPaused = inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length;
    var isUploadInProgress = inProgressFiles.length > 0;
    var resumableUploads = capabilities.resumableUploads || false;
    var supportsUploadProgress = capabilities.uploadProgress !== false;
    var isSomeGhost = filesArray.some(function (file) {
      return file.isGhost;
    });
    return StatusBarUI({
      error: error,
      uploadState: this.getUploadingState(isAllErrored, isAllComplete, recoveredState, state.files || {}),
      allowNewUpload: allowNewUpload,
      totalProgress: totalProgress,
      totalSize: totalSize,
      totalUploadedSize: totalUploadedSize,
      isAllComplete: isAllComplete,
      isAllPaused: isAllPaused,
      isAllErrored: isAllErrored,
      isUploadStarted: isUploadStarted,
      isUploadInProgress: isUploadInProgress,
      isSomeGhost: isSomeGhost,
      recoveredState: recoveredState,
      complete: completeFiles.length,
      newFiles: newFiles.length,
      numUploads: startedFiles.length,
      totalETA: totalETA,
      files: files,
      i18n: this.i18n,
      pauseAll: this.uppy.pauseAll,
      resumeAll: this.uppy.resumeAll,
      retryAll: this.uppy.retryAll,
      cancelAll: this.uppy.cancelAll,
      startUpload: this.startUpload,
      doneButtonHandler: this.opts.doneButtonHandler,
      resumableUploads: resumableUploads,
      supportsUploadProgress: supportsUploadProgress,
      showProgressDetails: this.opts.showProgressDetails,
      hideUploadButton: this.opts.hideUploadButton,
      hideRetryButton: this.opts.hideRetryButton,
      hidePauseResumeButton: this.opts.hidePauseResumeButton,
      hideCancelButton: this.opts.hideCancelButton,
      hideAfterFinish: this.opts.hideAfterFinish,
      isTargetDOMEl: this.isTargetDOMEl
    });
  };

  _proto.onMount = function onMount() {
    // Set the text direction if the page has not defined one.
    var element = this.el;
    var direction = getTextDirection(element);

    if (!direction) {
      element.dir = 'ltr';
    }
  };

  _proto.install = function install() {
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.unmount();
  };

  return StatusBar;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":147,"./../../core":55,"./../../utils/lib/Translator":167,"./../../utils/lib/getBytesRemaining":176,"./../../utils/lib/getSpeed":186,"./../../utils/lib/getTextDirection":187,"./StatusBar":148,"./StatusBarStates":149}],151:[function(require,module,exports){
module.exports={
  "name": "@uppy/store-default",
  "description": "The default simple object-based store for Uppy.",
  "version": "1.2.7",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-store"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  }
}

},{}],152:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/**
 * Default store that keeps state in a simple object.
 */
var DefaultStore = /*#__PURE__*/function () {
  function DefaultStore() {
    this.state = {};
    this.callbacks = [];
  }

  var _proto = DefaultStore.prototype;

  _proto.getState = function getState() {
    return this.state;
  };

  _proto.setState = function setState(patch) {
    var prevState = _extends({}, this.state);

    var nextState = _extends({}, this.state, patch);

    this.state = nextState;

    this._publish(prevState, nextState, patch);
  };

  _proto.subscribe = function subscribe(listener) {
    var _this = this;

    this.callbacks.push(listener);
    return function () {
      // Remove the listener.
      _this.callbacks.splice(_this.callbacks.indexOf(listener), 1);
    };
  };

  _proto._publish = function _publish() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.callbacks.forEach(function (listener) {
      listener.apply(void 0, args);
    });
  };

  return DefaultStore;
}();

DefaultStore.VERSION = require('../package.json').version;

module.exports = function defaultStore() {
  return new DefaultStore();
};

},{"../package.json":151}],153:[function(require,module,exports){
module.exports={
  "name": "@uppy/thumbnail-generator",
  "description": "Uppy plugin that generates small previews of images to show on your upload UI.",
  "version": "1.7.11",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "thumbnail",
    "preview",
    "resize"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "exifr": "^6.0.0",
    "math-log2": "^1.0.1"
  },
  "devDependencies": {
    "namespace-emitter": "2.0.1"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],154:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Translator = require('./../../utils/lib/Translator');

var dataURItoBlob = require('./../../utils/lib/dataURItoBlob');

var isObjectURL = require('./../../utils/lib/isObjectURL');

var isPreviewSupported = require('./../../utils/lib/isPreviewSupported');

var MathLog2 = require('math-log2'); // Polyfill for IE.


var exifr = require('exifr/dist/mini.legacy.umd.js');
/**
 * The Thumbnail Generator plugin
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(ThumbnailGenerator, _Plugin);

  function ThumbnailGenerator(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.onFileAdded = function (file) {
      if (!file.preview && file.data && isPreviewSupported(file.type) && !file.isRemote) {
        _this.addToQueue(file.id);
      }
    };

    _this.onCancelRequest = function (file) {
      var index = _this.queue.indexOf(file.id);

      if (index !== -1) {
        _this.queue.splice(index, 1);
      }
    };

    _this.onFileRemoved = function (file) {
      var index = _this.queue.indexOf(file.id);

      if (index !== -1) {
        _this.queue.splice(index, 1);
      } // Clean up object URLs.


      if (file.preview && isObjectURL(file.preview)) {
        URL.revokeObjectURL(file.preview);
      }
    };

    _this.onRestored = function () {
      var restoredFiles = _this.uppy.getFiles().filter(function (file) {
        return file.isRestored;
      });

      restoredFiles.forEach(function (file) {
        // Only add blob URLs; they are likely invalid after being restored.
        if (!file.preview || isObjectURL(file.preview)) {
          _this.addToQueue(file.id);
        }
      });
    };

    _this.waitUntilAllProcessed = function (fileIDs) {
      fileIDs.forEach(function (fileID) {
        var file = _this.uppy.getFile(fileID);

        _this.uppy.emit('preprocess-progress', file, {
          mode: 'indeterminate',
          message: _this.i18n('generatingThumbnails')
        });
      });

      var emitPreprocessCompleteForAll = function emitPreprocessCompleteForAll() {
        fileIDs.forEach(function (fileID) {
          var file = _this.uppy.getFile(fileID);

          _this.uppy.emit('preprocess-complete', file);
        });
      };

      return new Promise(function (resolve, reject) {
        if (_this.queueProcessing) {
          _this.uppy.once('thumbnail:all-generated', function () {
            emitPreprocessCompleteForAll();
            resolve();
          });
        } else {
          emitPreprocessCompleteForAll();
          resolve();
        }
      });
    };

    _this.type = 'modifier';
    _this.id = _this.opts.id || 'ThumbnailGenerator';
    _this.title = 'Thumbnail Generator';
    _this.queue = [];
    _this.queueProcessing = false;
    _this.defaultThumbnailDimension = 200;
    _this.thumbnailType = _this.opts.thumbnailType || 'image/jpeg';
    _this.defaultLocale = {
      strings: {
        generatingThumbnails: 'Generating thumbnails...'
      }
    };
    var defaultOptions = {
      thumbnailWidth: null,
      thumbnailHeight: null,
      waitForThumbnailsBeforeUpload: false,
      lazy: false
    };
    _this.opts = _extends({}, defaultOptions, opts);

    if (_this.opts.lazy && _this.opts.waitForThumbnailsBeforeUpload) {
      throw new Error('ThumbnailGenerator: The `lazy` and `waitForThumbnailsBeforeUpload` options are mutually exclusive. Please ensure at most one of them is set to `true`.');
    }

    _this.i18nInit();

    return _this;
  }

  var _proto = ThumbnailGenerator.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  }
  /**
   * Create a thumbnail for the given Uppy file object.
   *
   * @param {{data: Blob}} file
   * @param {number} targetWidth
   * @param {number} targetHeight
   * @returns {Promise}
   */
  ;

  _proto.createThumbnail = function createThumbnail(file, targetWidth, targetHeight) {
    var _this2 = this;

    // bug in the compatibility data
    // eslint-disable-next-line compat/compat
    var originalUrl = URL.createObjectURL(file.data);
    var onload = new Promise(function (resolve, reject) {
      var image = new Image();
      image.src = originalUrl;
      image.addEventListener('load', function () {
        // bug in the compatibility data
        // eslint-disable-next-line compat/compat
        URL.revokeObjectURL(originalUrl);
        resolve(image);
      });
      image.addEventListener('error', function (event) {
        // bug in the compatibility data
        // eslint-disable-next-line compat/compat
        URL.revokeObjectURL(originalUrl);
        reject(event.error || new Error('Could not create thumbnail'));
      });
    });
    var orientationPromise = exifr.rotation(file.data).catch(function (_err) {
      return 1;
    });
    return Promise.all([onload, orientationPromise]).then(function (_ref) {
      var image = _ref[0],
          orientation = _ref[1];

      var dimensions = _this2.getProportionalDimensions(image, targetWidth, targetHeight, orientation.deg);

      var rotatedImage = _this2.rotateImage(image, orientation);

      var resizedImage = _this2.resizeImage(rotatedImage, dimensions.width, dimensions.height);

      return _this2.canvasToBlob(resizedImage, _this2.thumbnailType, 80);
    }).then(function (blob) {
      // bug in the compatibility data
      // eslint-disable-next-line compat/compat
      return URL.createObjectURL(blob);
    });
  }
  /**
   * Get the new calculated dimensions for the given image and a target width
   * or height. If both width and height are given, only width is taken into
   * account. If neither width nor height are given, the default dimension
   * is used.
   */
  ;

  _proto.getProportionalDimensions = function getProportionalDimensions(img, width, height, rotation) {
    var aspect = img.width / img.height;

    if (rotation === 90 || rotation === 270) {
      aspect = img.height / img.width;
    }

    if (width != null) {
      return {
        width: width,
        height: Math.round(width / aspect)
      };
    }

    if (height != null) {
      return {
        width: Math.round(height * aspect),
        height: height
      };
    }

    return {
      width: this.defaultThumbnailDimension,
      height: Math.round(this.defaultThumbnailDimension / aspect)
    };
  }
  /**
   * Make sure the image doesn’t exceed browser/device canvas limits.
   * For ios with 256 RAM and ie
   */
  ;

  _proto.protect = function protect(image) {
    // https://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element
    var ratio = image.width / image.height;
    var maxSquare = 5000000; // ios max canvas square

    var maxSize = 4096; // ie max canvas dimensions

    var maxW = Math.floor(Math.sqrt(maxSquare * ratio));
    var maxH = Math.floor(maxSquare / Math.sqrt(maxSquare * ratio));

    if (maxW > maxSize) {
      maxW = maxSize;
      maxH = Math.round(maxW / ratio);
    }

    if (maxH > maxSize) {
      maxH = maxSize;
      maxW = Math.round(ratio * maxH);
    }

    if (image.width > maxW) {
      var canvas = document.createElement('canvas');
      canvas.width = maxW;
      canvas.height = maxH;
      canvas.getContext('2d').drawImage(image, 0, 0, maxW, maxH);
      image = canvas;
    }

    return image;
  }
  /**
   * Resize an image to the target `width` and `height`.
   *
   * Returns a Canvas with the resized image on it.
   */
  ;

  _proto.resizeImage = function resizeImage(image, targetWidth, targetHeight) {
    // Resizing in steps refactored to use a solution from
    // https://blog.uploadcare.com/image-resize-in-browsers-is-broken-e38eed08df01
    image = this.protect(image);
    var steps = Math.ceil(MathLog2(image.width / targetWidth));

    if (steps < 1) {
      steps = 1;
    }

    var sW = targetWidth * Math.pow(2, steps - 1);
    var sH = targetHeight * Math.pow(2, steps - 1);
    var x = 2;

    while (steps--) {
      var canvas = document.createElement('canvas');
      canvas.width = sW;
      canvas.height = sH;
      canvas.getContext('2d').drawImage(image, 0, 0, sW, sH);
      image = canvas;
      sW = Math.round(sW / x);
      sH = Math.round(sH / x);
    }

    return image;
  };

  _proto.rotateImage = function rotateImage(image, translate) {
    var w = image.width;
    var h = image.height;

    if (translate.deg === 90 || translate.deg === 270) {
      w = image.height;
      h = image.width;
    }

    var canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    var context = canvas.getContext('2d');
    context.translate(w / 2, h / 2);

    if (translate.canvas) {
      context.rotate(translate.rad);
      context.scale(translate.scaleX, translate.scaleY);
    }

    context.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
    return canvas;
  }
  /**
   * Save a <canvas> element's content to a Blob object.
   *
   * @param {HTMLCanvasElement} canvas
   * @returns {Promise}
   */
  ;

  _proto.canvasToBlob = function canvasToBlob(canvas, type, quality) {
    try {
      canvas.getContext('2d').getImageData(0, 0, 1, 1);
    } catch (err) {
      if (err.code === 18) {
        return Promise.reject(new Error('cannot read image, probably an svg with external resources'));
      }
    }

    if (canvas.toBlob) {
      return new Promise(function (resolve) {
        canvas.toBlob(resolve, type, quality);
      }).then(function (blob) {
        if (blob === null) {
          throw new Error('cannot read image, probably an svg with external resources');
        }

        return blob;
      });
    }

    return Promise.resolve().then(function () {
      return dataURItoBlob(canvas.toDataURL(type, quality), {});
    }).then(function (blob) {
      if (blob === null) {
        throw new Error('could not extract blob, probably an old browser');
      }

      return blob;
    });
  }
  /**
   * Set the preview URL for a file.
   */
  ;

  _proto.setPreviewURL = function setPreviewURL(fileID, preview) {
    this.uppy.setFileState(fileID, {
      preview: preview
    });
  };

  _proto.addToQueue = function addToQueue(item) {
    this.queue.push(item);

    if (this.queueProcessing === false) {
      this.processQueue();
    }
  };

  _proto.processQueue = function processQueue() {
    var _this3 = this;

    this.queueProcessing = true;

    if (this.queue.length > 0) {
      var current = this.uppy.getFile(this.queue.shift());

      if (!current) {
        this.uppy.log('[ThumbnailGenerator] file was removed before a thumbnail could be generated, but not removed from the queue. This is probably a bug', 'error');
        return;
      }

      return this.requestThumbnail(current).catch(function (err) {}) // eslint-disable-line handle-callback-err
      .then(function () {
        return _this3.processQueue();
      });
    }

    this.queueProcessing = false;
    this.uppy.log('[ThumbnailGenerator] Emptied thumbnail queue');
    this.uppy.emit('thumbnail:all-generated');
  };

  _proto.requestThumbnail = function requestThumbnail(file) {
    var _this4 = this;

    if (isPreviewSupported(file.type) && !file.isRemote) {
      return this.createThumbnail(file, this.opts.thumbnailWidth, this.opts.thumbnailHeight).then(function (preview) {
        _this4.setPreviewURL(file.id, preview);

        _this4.uppy.log("[ThumbnailGenerator] Generated thumbnail for " + file.id);

        _this4.uppy.emit('thumbnail:generated', _this4.uppy.getFile(file.id), preview);
      }).catch(function (err) {
        _this4.uppy.log("[ThumbnailGenerator] Failed thumbnail for " + file.id + ":", 'warning');

        _this4.uppy.log(err, 'warning');

        _this4.uppy.emit('thumbnail:error', _this4.uppy.getFile(file.id), err);
      });
    }

    return Promise.resolve();
  };

  _proto.install = function install() {
    this.uppy.on('file-removed', this.onFileRemoved);

    if (this.opts.lazy) {
      this.uppy.on('thumbnail:request', this.onFileAdded);
      this.uppy.on('thumbnail:cancel', this.onCancelRequest);
    } else {
      this.uppy.on('file-added', this.onFileAdded);
      this.uppy.on('restored', this.onRestored);
    }

    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.addPreProcessor(this.waitUntilAllProcessed);
    }
  };

  _proto.uninstall = function uninstall() {
    this.uppy.off('file-removed', this.onFileRemoved);

    if (this.opts.lazy) {
      this.uppy.off('thumbnail:request', this.onFileAdded);
      this.uppy.off('thumbnail:cancel', this.onCancelRequest);
    } else {
      this.uppy.off('file-added', this.onFileAdded);
      this.uppy.off('restored', this.onRestored);
    }

    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.removePreProcessor(this.waitUntilAllProcessed);
    }
  };

  return ThumbnailGenerator;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":153,"./../../core":55,"./../../utils/lib/Translator":167,"./../../utils/lib/dataURItoBlob":169,"./../../utils/lib/isObjectURL":193,"./../../utils/lib/isPreviewSupported":194,"exifr/dist/mini.legacy.umd.js":12,"math-log2":18}],155:[function(require,module,exports){
module.exports={
  "name": "@uppy/tus",
  "description": "Resumable uploads for Uppy using Tus.io",
  "version": "1.9.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "upload",
    "resumable",
    "tus"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/utils": "file:../utils",
    "tus-js-client": "^2.1.1"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],156:[function(require,module,exports){
var tus = require('tus-js-client');

function isCordova() {
  return typeof window !== 'undefined' && (typeof window.PhoneGap !== 'undefined' || typeof window.Cordova !== 'undefined' || typeof window.cordova !== 'undefined');
}

function isReactNative() {
  return typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative';
} // We override tus fingerprint to uppy’s `file.id`, since the `file.id`
// now also includes `relativePath` for files added from folders.
// This means you can add 2 identical files, if one is in folder a,
// the other in folder b — `a/file.jpg` and `b/file.jpg`, when added
// together with a folder, will be treated as 2 separate files.
//
// For React Native and Cordova, we let tus-js-client’s default
// fingerprint handling take charge.


module.exports = function getFingerprint(uppyFileObj) {
  return function (file, options) {
    if (isCordova() || isReactNative()) {
      return tus.defaultOptions.fingerprint(file, options);
    }

    var uppyFingerprint = ['tus', uppyFileObj.id, options.endpoint].join('-');
    return Promise.resolve(uppyFingerprint);
  };
};

},{"tus-js-client":30}],157:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var tus = require('tus-js-client');

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider,
    RequestClient = _require2.RequestClient,
    Socket = _require2.Socket;

var emitSocketProgress = require('./../../utils/lib/emitSocketProgress');

var getSocketHost = require('./../../utils/lib/getSocketHost');

var settle = require('./../../utils/lib/settle');

var EventTracker = require('./../../utils/lib/EventTracker');

var NetworkError = require('./../../utils/lib/NetworkError');

var isNetworkError = require('./../../utils/lib/isNetworkError');

var RateLimitedQueue = require('./../../utils/lib/RateLimitedQueue');

var hasProperty = require('./../../utils/lib/hasProperty');

var getFingerprint = require('./getFingerprint');
/** @typedef {import('..').TusOptions} TusOptions */

/** @typedef {import('tus-js-client').UploadOptions} RawTusOptions */

/** @typedef {import('@uppy/core').Uppy} Uppy */

/** @typedef {import('@uppy/core').UppyFile} UppyFile */

/** @typedef {import('@uppy/core').FailedUppyFile<{}>} FailedUppyFile */

/**
 * Extracted from https://github.com/tus/tus-js-client/blob/master/lib/upload.js#L13
 * excepted we removed 'fingerprint' key to avoid adding more dependencies
 *
 * @type {RawTusOptions}
 */


var tusDefaultOptions = {
  endpoint: '',
  uploadUrl: null,
  metadata: {},
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  chunkSize: Infinity,
  retryDelays: [0, 1000, 3000, 5000],
  parallelUploads: 1,
  storeFingerprintForResuming: true,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false
};
/**
 * Tus resumable file uploader
 */

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Tus, _Plugin);

  /**
   * @param {Uppy} uppy
   * @param {TusOptions} opts
   */
  function Tus(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.type = 'uploader';
    _this.id = _this.opts.id || 'Tus';
    _this.title = 'Tus'; // set default options

    var defaultOptions = {
      autoRetry: true,
      resume: true,
      useFastRemoteRetry: true,
      limit: 0,
      retryDelays: [0, 1000, 3000, 5000],
      withCredentials: false
    }; // merge default options with the ones set by user

    /** @type {import("..").TusOptions} */

    _this.opts = _extends({}, defaultOptions, opts);
    /**
     * Simultaneous upload limiting is shared across all uploads with this plugin.
     *
     * @type {RateLimitedQueue}
     */

    _this.requests = new RateLimitedQueue(_this.opts.limit);
    _this.uploaders = Object.create(null);
    _this.uploaderEvents = Object.create(null);
    _this.uploaderSockets = Object.create(null);
    _this.handleResetProgress = _this.handleResetProgress.bind(_assertThisInitialized(_this));
    _this.handleUpload = _this.handleUpload.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Tus.prototype;

  _proto.handleResetProgress = function handleResetProgress() {
    var files = _extends({}, this.uppy.getState().files);

    Object.keys(files).forEach(function (fileID) {
      // Only clone the file object if it has a Tus `uploadUrl` attached.
      if (files[fileID].tus && files[fileID].tus.uploadUrl) {
        var tusState = _extends({}, files[fileID].tus);

        delete tusState.uploadUrl;
        files[fileID] = _extends({}, files[fileID], {
          tus: tusState
        });
      }
    });
    this.uppy.setState({
      files: files
    });
  }
  /**
   * Clean up all references for a file's upload: the tus.Upload instance,
   * any events related to the file, and the Companion WebSocket connection.
   *
   * @param {string} fileID
   */
  ;

  _proto.resetUploaderReferences = function resetUploaderReferences(fileID, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (this.uploaders[fileID]) {
      var uploader = this.uploaders[fileID];
      uploader.abort();

      if (opts.abort) {
        // to avoid 423 error from tus server, we wait
        // to be sure the previous request has been aborted before terminating the upload
        // @todo remove the timeout when this "wait" is handled in tus-js-client internally
        setTimeout(function () {
          return uploader.abort(true);
        }, 1000);
      }

      this.uploaders[fileID] = null;
    }

    if (this.uploaderEvents[fileID]) {
      this.uploaderEvents[fileID].remove();
      this.uploaderEvents[fileID] = null;
    }

    if (this.uploaderSockets[fileID]) {
      this.uploaderSockets[fileID].close();
      this.uploaderSockets[fileID] = null;
    }
  }
  /**
   * Create a new Tus upload.
   *
   * A lot can happen during an upload, so this is quite hard to follow!
   * - First, the upload is started. If the file was already paused by the time the upload starts, nothing should happen.
   *   If the `limit` option is used, the upload must be queued onto the `this.requests` queue.
   *   When an upload starts, we store the tus.Upload instance, and an EventTracker instance that manages the event listeners
   *   for pausing, cancellation, removal, etc.
   * - While the upload is in progress, it may be paused or cancelled.
   *   Pausing aborts the underlying tus.Upload, and removes the upload from the `this.requests` queue. All other state is
   *   maintained.
   *   Cancelling removes the upload from the `this.requests` queue, and completely aborts the upload--the tus.Upload instance
   *   is aborted and discarded, the EventTracker instance is destroyed (removing all listeners).
   *   Resuming the upload uses the `this.requests` queue as well, to prevent selectively pausing and resuming uploads from
   *   bypassing the limit.
   * - After completing an upload, the tus.Upload and EventTracker instances are cleaned up, and the upload is marked as done
   *   in the `this.requests` queue.
   * - When an upload completed with an error, the same happens as on successful completion, but the `upload()` promise is rejected.
   *
   * When working on this function, keep in mind:
   *  - When an upload is completed or cancelled for any reason, the tus.Upload and EventTracker instances need to be cleaned up using this.resetUploaderReferences().
   *  - When an upload is cancelled or paused, for any reason, it needs to be removed from the `this.requests` queue using `queuedRequest.abort()`.
   *  - When an upload is completed for any reason, including errors, it needs to be marked as such using `queuedRequest.done()`.
   *  - When an upload is started or resumed, it needs to go through the `this.requests` queue. The `queuedRequest` variable must be updated so the other uses of it are valid.
   *  - Before replacing the `queuedRequest` variable, the previous `queuedRequest` must be aborted, else it will keep taking up a spot in the queue.
   *
   * @param {UppyFile} file for use with upload
   * @param {number} current file in a queue
   * @param {number} total number of files in a queue
   * @returns {Promise<void>}
   */
  ;

  _proto.upload = function upload(file, current, total) {
    var _this2 = this;

    this.resetUploaderReferences(file.id); // Create a new tus upload

    return new Promise(function (resolve, reject) {
      _this2.uppy.emit('upload-started', file);

      var opts = _extends({}, _this2.opts, file.tus || {});
      /** @type {RawTusOptions} */


      var uploadOptions = _extends({}, tusDefaultOptions, opts);

      delete uploadOptions.resume; // Make `resume: true` work like it did in tus-js-client v1.
      // TODO: Remove in @uppy/tus v2

      if (opts.resume) {
        uploadOptions.storeFingerprintForResuming = true;
      } // We override tus fingerprint to uppy’s `file.id`, since the `file.id`
      // now also includes `relativePath` for files added from folders.
      // This means you can add 2 identical files, if one is in folder a,
      // the other in folder b.


      uploadOptions.fingerprint = getFingerprint(file);

      uploadOptions.onBeforeRequest = function (req) {
        var xhr = req.getUnderlyingObject();
        xhr.withCredentials = !!opts.withCredentials;

        if (typeof opts.onBeforeRequest === 'function') {
          opts.onBeforeRequest(req);
        }
      };

      uploadOptions.onError = function (err) {
        _this2.uppy.log(err);

        var xhr = err.originalRequest ? err.originalRequest.getUnderlyingObject() : null;

        if (isNetworkError(xhr)) {
          err = new NetworkError(err, xhr);
        }

        _this2.resetUploaderReferences(file.id);

        queuedRequest.done();

        _this2.uppy.emit('upload-error', file, err);

        reject(err);
      };

      uploadOptions.onProgress = function (bytesUploaded, bytesTotal) {
        _this2.onReceiveUploadUrl(file, upload.url);

        _this2.uppy.emit('upload-progress', file, {
          uploader: _this2,
          bytesUploaded: bytesUploaded,
          bytesTotal: bytesTotal
        });
      };

      uploadOptions.onSuccess = function () {
        var uploadResp = {
          uploadURL: upload.url
        };

        _this2.resetUploaderReferences(file.id);

        queuedRequest.done();

        _this2.uppy.emit('upload-success', file, uploadResp);

        if (upload.url) {
          _this2.uppy.log("Download " + upload.file.name + " from " + upload.url);
        }

        resolve(upload);
      };

      var copyProp = function copyProp(obj, srcProp, destProp) {
        if (hasProperty(obj, srcProp) && !hasProperty(obj, destProp)) {
          obj[destProp] = obj[srcProp];
        }
      };
      /** @type {Record<string, string>} */


      var meta = {};
      var metaFields = Array.isArray(opts.metaFields) ? opts.metaFields // Send along all fields by default.
      : Object.keys(file.meta);
      metaFields.forEach(function (item) {
        meta[item] = file.meta[item];
      }); // tusd uses metadata fields 'filetype' and 'filename'

      copyProp(meta, 'type', 'filetype');
      copyProp(meta, 'name', 'filename');
      uploadOptions.metadata = meta;
      var upload = new tus.Upload(file.data, uploadOptions);
      _this2.uploaders[file.id] = upload;
      _this2.uploaderEvents[file.id] = new EventTracker(_this2.uppy); // Make `resume: true` work like it did in tus-js-client v1.
      // TODO: Remove in @uppy/tus v2.

      if (opts.resume) {
        upload.findPreviousUploads().then(function (previousUploads) {
          var previousUpload = previousUploads[0];

          if (previousUpload) {
            _this2.uppy.log("[Tus] Resuming upload of " + file.id + " started at " + previousUpload.creationTime);

            upload.resumeFromPreviousUpload(previousUpload);
          }
        });
      }

      var queuedRequest = _this2.requests.run(function () {
        if (!file.isPaused) {
          // Ensure this gets scheduled to run _after_ `findPreviousUploads()` returns.
          // TODO: Remove in @uppy/tus v2.
          Promise.resolve().then(function () {
            upload.start();
          });
        } // Don't do anything here, the caller will take care of cancelling the upload itself
        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be
        // called when this request is still in the queue, and has not been started yet, too. At
        // that point this cancellation function is not going to be called.
        // Also, we need to remove the request from the queue _without_ destroying everything
        // related to this upload to handle pauses.


        return function () {};
      });

      _this2.onFileRemove(file.id, function (targetFileID) {
        queuedRequest.abort();

        _this2.resetUploaderReferences(file.id, {
          abort: !!upload.url
        });

        resolve("upload " + targetFileID + " was removed");
      });

      _this2.onPause(file.id, function (isPaused) {
        if (isPaused) {
          // Remove this file from the queue so another file can start in its place.
          queuedRequest.abort();
          upload.abort();
        } else {
          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.
          queuedRequest.abort();
          queuedRequest = _this2.requests.run(function () {
            upload.start();
            return function () {};
          });
        }
      });

      _this2.onPauseAll(file.id, function () {
        queuedRequest.abort();
        upload.abort();
      });

      _this2.onCancelAll(file.id, function () {
        queuedRequest.abort();

        _this2.resetUploaderReferences(file.id, {
          abort: !!upload.url
        });

        resolve("upload " + file.id + " was canceled");
      });

      _this2.onResumeAll(file.id, function () {
        queuedRequest.abort();

        if (file.error) {
          upload.abort();
        }

        queuedRequest = _this2.requests.run(function () {
          upload.start();
          return function () {};
        });
      });
    }).catch(function (err) {
      _this2.uppy.emit('upload-error', file, err);

      throw err;
    });
  }
  /**
   * @param {UppyFile} file for use with upload
   * @param {number} current file in a queue
   * @param {number} total number of files in a queue
   * @returns {Promise<void>}
   */
  ;

  _proto.uploadRemote = function uploadRemote(file, current, total) {
    var _this3 = this;

    this.resetUploaderReferences(file.id);

    var opts = _extends({}, this.opts);

    if (file.tus) {
      // Install file-specific upload overrides.
      _extends(opts, file.tus);
    }

    this.uppy.emit('upload-started', file);
    this.uppy.log(file.remote.url);

    if (file.serverToken) {
      return this.connectToServerSocket(file);
    }

    return new Promise(function (resolve, reject) {
      var Client = file.remote.providerOptions.provider ? Provider : RequestClient;
      var client = new Client(_this3.uppy, file.remote.providerOptions); // !! cancellation is NOT supported at this stage yet

      client.post(file.remote.url, _extends({}, file.remote.body, {
        endpoint: opts.endpoint,
        uploadUrl: opts.uploadUrl,
        protocol: 'tus',
        size: file.data.size,
        headers: opts.headers,
        metadata: file.meta
      })).then(function (res) {
        _this3.uppy.setFileState(file.id, {
          serverToken: res.token
        });

        file = _this3.uppy.getFile(file.id);
        return _this3.connectToServerSocket(file);
      }).then(function () {
        resolve();
      }).catch(function (err) {
        _this3.uppy.emit('upload-error', file, err);

        reject(err);
      });
    });
  }
  /**
   * See the comment on the upload() method.
   *
   * Additionally, when an upload is removed, completed, or cancelled, we need to close the WebSocket connection. This is handled by the resetUploaderReferences() function, so the same guidelines apply as in upload().
   *
   * @param {UppyFile} file
   */
  ;

  _proto.connectToServerSocket = function connectToServerSocket(file) {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
      var token = file.serverToken;
      var host = getSocketHost(file.remote.companionUrl);
      var socket = new Socket({
        target: host + "/api/" + token,
        autoOpen: false
      });
      _this4.uploaderSockets[file.id] = socket;
      _this4.uploaderEvents[file.id] = new EventTracker(_this4.uppy);

      _this4.onFileRemove(file.id, function () {
        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion
        // @todo don't send pause event in the next major release.

        socket.send('pause', {});
        socket.send('cancel', {});

        _this4.resetUploaderReferences(file.id);

        resolve("upload " + file.id + " was removed");
      });

      _this4.onPause(file.id, function (isPaused) {
        if (isPaused) {
          // Remove this file from the queue so another file can start in its place.
          queuedRequest.abort();
          socket.send('pause', {});
        } else {
          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.
          queuedRequest.abort();
          queuedRequest = _this4.requests.run(function () {
            socket.send('resume', {});
            return function () {};
          });
        }
      });

      _this4.onPauseAll(file.id, function () {
        queuedRequest.abort();
        socket.send('pause', {});
      });

      _this4.onCancelAll(file.id, function () {
        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion
        // @todo don't send pause event in the next major release.

        socket.send('pause', {});
        socket.send('cancel', {});

        _this4.resetUploaderReferences(file.id);

        resolve("upload " + file.id + " was canceled");
      });

      _this4.onResumeAll(file.id, function () {
        queuedRequest.abort();

        if (file.error) {
          socket.send('pause', {});
        }

        queuedRequest = _this4.requests.run(function () {
          socket.send('resume', {});
          return function () {};
        });
      });

      _this4.onRetry(file.id, function () {
        // Only do the retry if the upload is actually in progress;
        // else we could try to send these messages when the upload is still queued.
        // We may need a better check for this since the socket may also be closed
        // for other reasons, like network failures.
        if (socket.isOpen) {
          socket.send('pause', {});
          socket.send('resume', {});
        }
      });

      _this4.onRetryAll(file.id, function () {
        // See the comment in the onRetry() call
        if (socket.isOpen) {
          socket.send('pause', {});
          socket.send('resume', {});
        }
      });

      socket.on('progress', function (progressData) {
        return emitSocketProgress(_this4, progressData, file);
      });
      socket.on('error', function (errData) {
        var message = errData.error.message;

        var error = _extends(new Error(message), {
          cause: errData.error
        }); // If the remote retry optimisation should not be used,
        // close the socket—this will tell companion to clear state and delete the file.


        if (!_this4.opts.useFastRemoteRetry) {
          _this4.resetUploaderReferences(file.id); // Remove the serverToken so that a new one will be created for the retry.


          _this4.uppy.setFileState(file.id, {
            serverToken: null
          });
        } else {
          socket.close();
        }

        _this4.uppy.emit('upload-error', file, error);

        queuedRequest.done();
        reject(error);
      });
      socket.on('success', function (data) {
        var uploadResp = {
          uploadURL: data.url
        };

        _this4.uppy.emit('upload-success', file, uploadResp);

        _this4.resetUploaderReferences(file.id);

        queuedRequest.done();
        resolve();
      });

      var queuedRequest = _this4.requests.run(function () {
        socket.open();

        if (file.isPaused) {
          socket.send('pause', {});
        } // Don't do anything here, the caller will take care of cancelling the upload itself
        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be
        // called when this request is still in the queue, and has not been started yet, too. At
        // that point this cancellation function is not going to be called.
        // Also, we need to remove the request from the queue _without_ destroying everything
        // related to this upload to handle pauses.


        return function () {};
      });
    });
  }
  /**
   * Store the uploadUrl on the file options, so that when Golden Retriever
   * restores state, we will continue uploading to the correct URL.
   *
   * @param {UppyFile} file
   * @param {string} uploadURL
   */
  ;

  _proto.onReceiveUploadUrl = function onReceiveUploadUrl(file, uploadURL) {
    var currentFile = this.uppy.getFile(file.id);
    if (!currentFile) return; // Only do the update if we didn't have an upload URL yet.

    if (!currentFile.tus || currentFile.tus.uploadUrl !== uploadURL) {
      this.uppy.log('[Tus] Storing upload url');
      this.uppy.setFileState(currentFile.id, {
        tus: _extends({}, currentFile.tus, {
          uploadUrl: uploadURL
        })
      });
    }
  }
  /**
   * @param {string} fileID
   * @param {function(string): void} cb
   */
  ;

  _proto.onFileRemove = function onFileRemove(fileID, cb) {
    this.uploaderEvents[fileID].on('file-removed', function (file) {
      if (fileID === file.id) cb(file.id);
    });
  }
  /**
   * @param {string} fileID
   * @param {function(boolean): void} cb
   */
  ;

  _proto.onPause = function onPause(fileID, cb) {
    this.uploaderEvents[fileID].on('upload-pause', function (targetFileID, isPaused) {
      if (fileID === targetFileID) {
        // const isPaused = this.uppy.pauseResume(fileID)
        cb(isPaused);
      }
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onRetry = function onRetry(fileID, cb) {
    this.uploaderEvents[fileID].on('upload-retry', function (targetFileID) {
      if (fileID === targetFileID) {
        cb();
      }
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onRetryAll = function onRetryAll(fileID, cb) {
    var _this5 = this;

    this.uploaderEvents[fileID].on('retry-all', function (filesToRetry) {
      if (!_this5.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onPauseAll = function onPauseAll(fileID, cb) {
    var _this6 = this;

    this.uploaderEvents[fileID].on('pause-all', function () {
      if (!_this6.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onCancelAll = function onCancelAll(fileID, cb) {
    var _this7 = this;

    this.uploaderEvents[fileID].on('cancel-all', function () {
      if (!_this7.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onResumeAll = function onResumeAll(fileID, cb) {
    var _this8 = this;

    this.uploaderEvents[fileID].on('resume-all', function () {
      if (!_this8.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {(UppyFile | FailedUppyFile)[]} files
   */
  ;

  _proto.uploadFiles = function uploadFiles(files) {
    var _this9 = this;

    var promises = files.map(function (file, i) {
      var current = i + 1;
      var total = files.length;

      if ('error' in file && file.error) {
        return Promise.reject(new Error(file.error));
      }

      if (file.isRemote) {
        // We emit upload-started here, so that it's also emitted for files
        // that have to wait due to the `limit` option.
        // Don't double-emit upload-started for Golden Retriever-restored files that were already started
        if (!file.progress.uploadStarted || !file.isRestored) {
          _this9.uppy.emit('upload-started', file);
        }

        return _this9.uploadRemote(file, current, total);
      } // Don't double-emit upload-started for Golden Retriever-restored files that were already started


      if (!file.progress.uploadStarted || !file.isRestored) {
        _this9.uppy.emit('upload-started', file);
      }

      return _this9.upload(file, current, total);
    });
    return settle(promises);
  }
  /**
   * @param {string[]} fileIDs
   */
  ;

  _proto.handleUpload = function handleUpload(fileIDs) {
    var _this10 = this;

    if (fileIDs.length === 0) {
      this.uppy.log('[Tus] No files to upload');
      return Promise.resolve();
    }

    if (this.opts.limit === 0) {
      this.uppy.log('[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0', 'warning');
    }

    this.uppy.log('[Tus] Uploading...');
    var filesToUpload = fileIDs.map(function (fileID) {
      return _this10.uppy.getFile(fileID);
    });
    return this.uploadFiles(filesToUpload).then(function () {
      return null;
    });
  };

  _proto.install = function install() {
    this.uppy.setState({
      capabilities: _extends({}, this.uppy.getState().capabilities, {
        resumableUploads: true
      })
    });
    this.uppy.addUploader(this.handleUpload);
    this.uppy.on('reset-progress', this.handleResetProgress);

    if (this.opts.autoRetry) {
      this.uppy.on('back-online', this.uppy.retryAll);
    }
  };

  _proto.uninstall = function uninstall() {
    this.uppy.setState({
      capabilities: _extends({}, this.uppy.getState().capabilities, {
        resumableUploads: false
      })
    });
    this.uppy.removeUploader(this.handleUpload);

    if (this.opts.autoRetry) {
      this.uppy.off('back-online', this.uppy.retryAll);
    }
  };

  return Tus;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":155,"./../../companion-client":50,"./../../core":55,"./../../utils/lib/EventTracker":163,"./../../utils/lib/NetworkError":165,"./../../utils/lib/RateLimitedQueue":166,"./../../utils/lib/emitSocketProgress":170,"./../../utils/lib/getSocketHost":185,"./../../utils/lib/hasProperty":189,"./../../utils/lib/isNetworkError":192,"./../../utils/lib/settle":199,"./getFingerprint":156,"tus-js-client":30}],158:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],159:[function(require,module,exports){
module.exports={
  "name": "@uppy/url",
  "description": "The Url plugin lets users import files from the Internet. Paste any URL and it’ll be added!",
  "version": "1.5.23",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "url",
    "import from url",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],160:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var UrlUI = /*#__PURE__*/function (_Component) {
  _inheritsLoose(UrlUI, _Component);

  function UrlUI(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.handleKeyPress = _this.handleKeyPress.bind(_assertThisInitialized(_this));
    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = UrlUI.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.input.value = '';
  };

  _proto.handleKeyPress = function handleKeyPress(ev) {
    if (ev.keyCode === 13) {
      this.props.addFile(this.input.value);
    }
  };

  _proto.handleClick = function handleClick() {
    this.props.addFile(this.input.value);
  };

  _proto.render = function render() {
    var _this2 = this;

    return h("div", {
      className: "uppy-Url"
    }, h("input", {
      className: "uppy-u-reset uppy-c-textInput uppy-Url-input",
      type: "text",
      "aria-label": this.props.i18n('enterUrlToImport'),
      placeholder: this.props.i18n('enterUrlToImport'),
      onKeyUp: this.handleKeyPress,
      ref: function ref(input) {
        _this2.input = input;
      },
      "data-uppy-super-focusable": true
    }), h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Url-importButton",
      type: "button",
      onClick: this.handleClick
    }, this.props.i18n('import')));
  };

  return UrlUI;
}(Component);

module.exports = UrlUI;

},{"preact":158}],161:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Translator = require('./../../utils/lib/Translator');

var _require2 = require('preact'),
    h = _require2.h;

var _require3 = require('./../../companion-client'),
    RequestClient = _require3.RequestClient;

var UrlUI = require('./UrlUI.js');

var forEachDroppedOrPastedUrl = require('./utils/forEachDroppedOrPastedUrl');

function UrlIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "32",
    height: "32",
    viewBox: "0 0 32 32"
  }, h("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h("rect", {
    className: "uppy-ProviderIconBg",
    fill: "#FF753E",
    width: "32",
    height: "32",
    rx: "16"
  }), h("path", {
    d: "M22.788 15.389l-2.199 2.19a3.184 3.184 0 0 1-.513.437c-.806.584-1.686.876-2.638.876a4.378 4.378 0 0 1-3.519-1.752c-.22-.292-.146-.802.147-1.021.293-.22.806-.146 1.026.146.953 1.313 2.785 1.532 4.105.583a.571.571 0 0 0 .293-.292l2.199-2.189c1.1-1.167 1.1-2.992-.073-4.086a2.976 2.976 0 0 0-4.105 0l-1.246 1.24a.71.71 0 0 1-1.026 0 .703.703 0 0 1 0-1.022l1.246-1.24a4.305 4.305 0 0 1 6.083 0c1.833 1.605 1.906 4.451.22 6.13zm-7.183 5.035l-1.246 1.24a2.976 2.976 0 0 1-4.105 0c-1.172-1.094-1.172-2.991-.073-4.086l2.2-2.19.292-.291c.66-.438 1.393-.657 2.2-.584.805.146 1.465.51 1.905 1.168.22.292.733.365 1.026.146.293-.22.367-.73.147-1.022-.733-.949-1.76-1.532-2.859-1.678-1.1-.22-2.272.073-3.225.802l-.44.438-2.199 2.19c-1.686 1.75-1.612 4.524.074 6.202.88.803 1.979 1.241 3.078 1.241 1.1 0 2.199-.438 3.079-1.24l1.246-1.241a.703.703 0 0 0 0-1.022c-.294-.292-.807-.365-1.1-.073z",
    fill: "#FFF",
    fillRule: "nonzero"
  })));
}
/**
 * Url
 *
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Url, _Plugin);

  function Url(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Url';
    _this.title = _this.opts.title || 'Link';
    _this.type = 'acquirer';

    _this.icon = function () {
      return h(UrlIcon, null);
    }; // Set default options and locale


    _this.defaultLocale = {
      strings: {
        import: 'Import',
        enterUrlToImport: 'Enter URL to import a file',
        failedToFetch: 'Companion failed to fetch this URL, please make sure it’s correct',
        enterCorrectUrl: 'Incorrect URL: Please make sure you are entering a direct link to a file'
      }
    };
    var defaultOptions = {};
    _this.opts = _extends({}, defaultOptions, opts);

    _this.i18nInit();

    _this.hostname = _this.opts.companionUrl;

    if (!_this.hostname) {
      throw new Error('Companion hostname is required, please consult https://uppy.io/docs/companion');
    } // Bind all event handlers for referencability


    _this.getMeta = _this.getMeta.bind(_assertThisInitialized(_this));
    _this.addFile = _this.addFile.bind(_assertThisInitialized(_this));
    _this.handleRootDrop = _this.handleRootDrop.bind(_assertThisInitialized(_this));
    _this.handleRootPaste = _this.handleRootPaste.bind(_assertThisInitialized(_this));
    _this.client = new RequestClient(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionCookiesRule: _this.opts.companionCookiesRule
    });
    return _this;
  }

  var _proto = Url.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.getFileNameFromUrl = function getFileNameFromUrl(url) {
    return url.substring(url.lastIndexOf('/') + 1);
  };

  _proto.checkIfCorrectURL = function checkIfCorrectURL(url) {
    if (!url) return false;
    var protocol = url.match(/^([a-z0-9]+):\/\//)[1];

    if (protocol !== 'http' && protocol !== 'https') {
      return false;
    }

    return true;
  };

  _proto.addProtocolToURL = function addProtocolToURL(url) {
    var protocolRegex = /^[a-z0-9]+:\/\//;
    var defaultProtocol = 'http://';

    if (protocolRegex.test(url)) {
      return url;
    }

    return defaultProtocol + url;
  };

  _proto.getMeta = function getMeta(url) {
    var _this2 = this;

    return this.client.post('url/meta', {
      url: url
    }).then(function (res) {
      if (res.error) {
        _this2.uppy.log('[URL] Error:');

        _this2.uppy.log(res.error);

        throw new Error('Failed to fetch the file');
      }

      return res;
    });
  };

  _proto.addFile = function addFile(url) {
    var _this3 = this;

    url = this.addProtocolToURL(url);

    if (!this.checkIfCorrectURL(url)) {
      this.uppy.log("[URL] Incorrect URL entered: " + url);
      this.uppy.info(this.i18n('enterCorrectUrl'), 'error', 4000);
      return;
    }

    return this.getMeta(url).then(function (meta) {
      var tagFile = {
        source: _this3.id,
        name: _this3.getFileNameFromUrl(url),
        type: meta.type,
        data: {
          size: meta.size
        },
        isRemote: true,
        body: {
          url: url
        },
        remote: {
          companionUrl: _this3.opts.companionUrl,
          url: _this3.hostname + "/url/get",
          body: {
            fileId: url,
            url: url
          },
          providerOptions: _this3.client.opts
        }
      };
      return tagFile;
    }).then(function (tagFile) {
      _this3.uppy.log('[Url] Adding remote file');

      try {
        return _this3.uppy.addFile(tagFile);
      } catch (err) {
        if (!err.isRestriction) {
          _this3.uppy.log(err);
        }

        return err;
      }
    }).catch(function (err) {
      _this3.uppy.log(err);

      _this3.uppy.info({
        message: _this3.i18n('failedToFetch'),
        details: err
      }, 'error', 4000);

      return err;
    });
  };

  _proto.handleRootDrop = function handleRootDrop(e) {
    var _this4 = this;

    forEachDroppedOrPastedUrl(e.dataTransfer, 'drop', function (url) {
      _this4.uppy.log("[URL] Adding file from dropped url: " + url);

      _this4.addFile(url);
    });
  };

  _proto.handleRootPaste = function handleRootPaste(e) {
    var _this5 = this;

    forEachDroppedOrPastedUrl(e.clipboardData, 'paste', function (url) {
      _this5.uppy.log("[URL] Adding file from pasted url: " + url);

      _this5.addFile(url);
    });
  };

  _proto.render = function render(state) {
    return h(UrlUI, {
      i18n: this.i18n,
      addFile: this.addFile
    });
  };

  _proto.install = function install() {
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.unmount();
  };

  return Url;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":159,"./../../companion-client":50,"./../../core":55,"./../../utils/lib/Translator":167,"./UrlUI.js":160,"./utils/forEachDroppedOrPastedUrl":162,"preact":158}],162:[function(require,module,exports){
var toArray = require('./../../../utils/lib/toArray');
/*
  SITUATION

    1. Cross-browser dataTransfer.items

      paste in chrome [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}
      paste in safari [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}
      2: {kind: "string", type: "text/plain"}
      3: {kind: "string", type: "text/uri-list"}
      paste in firefox [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}

      paste in chrome [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}
      paste in safari [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}
      1: {kind: "string", type: "text/uri-list"}
      paste in firefox [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}

      drop in chrome [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/html"}
      drop in safari [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/html"}
      2: {kind: "file", type: "image/png"}
      drop in firefox [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/x-moz-url"}
      2: {kind: "string", type: "text/plain"}

    2. We can determine if it's a 'copypaste' or a 'drop', but we can't discern between [Copy Image] and [Copy Image Address].

  CONCLUSION

    1. 'paste' ([Copy Image] or [Copy Image Address], we can't discern between these two)
      Don't do anything if there is 'file' item. .handlePaste in the DashboardPlugin will deal with all 'file' items.
      If there are no 'file' items - handle 'text/plain' items.

    2. 'drop'
      Take 'text/uri-list' items. Safari has an additional item of .kind === 'file', and you may worry about the item being duplicated (first by DashboardPlugin, and then by UrlPlugin, now), but don't. Directory handling code won't pay attention to this particular item of kind 'file'.
*/

/**
 * Finds all links dropped/pasted from one browser window to another.
 *
 * @param {object} dataTransfer - DataTransfer instance, e.g. e.clipboardData, or e.dataTransfer
 * @param {string} isDropOrPaste - either 'drop' or 'paste'
 * @param {Function} callback - (urlString) => {}
 */


module.exports = function forEachDroppedOrPastedUrl(dataTransfer, isDropOrPaste, callback) {
  var items = toArray(dataTransfer.items);
  var urlItems;

  switch (isDropOrPaste) {
    case 'paste':
      {
        var atLeastOneFileIsDragged = items.some(function (item) {
          return item.kind === 'file';
        });

        if (atLeastOneFileIsDragged) {
          return;
        }

        urlItems = items.filter(function (item) {
          return item.kind === 'string' && item.type === 'text/plain';
        });
        break;
      }

    case 'drop':
      {
        urlItems = items.filter(function (item) {
          return item.kind === 'string' && item.type === 'text/uri-list';
        });
        break;
      }

    default:
      {
        throw new Error("isDropOrPaste must be either 'drop' or 'paste', but it's " + isDropOrPaste);
      }
  }

  urlItems.forEach(function (item) {
    item.getAsString(function (urlString) {
      return callback(urlString);
    });
  });
};

},{"./../../../utils/lib/toArray":200}],163:[function(require,module,exports){
/**
 * Create a wrapper around an event emitter with a `remove` method to remove
 * all events that were added using the wrapped emitter.
 */
module.exports = /*#__PURE__*/function () {
  function EventTracker(emitter) {
    this._events = [];
    this._emitter = emitter;
  }

  var _proto = EventTracker.prototype;

  _proto.on = function on(event, fn) {
    this._events.push([event, fn]);

    return this._emitter.on(event, fn);
  };

  _proto.remove = function remove() {
    var _this = this;

    this._events.forEach(function (_ref) {
      var event = _ref[0],
          fn = _ref[1];

      _this._emitter.off(event, fn);
    });
  };

  return EventTracker;
}();

},{}],164:[function(require,module,exports){
module.exports = ['a[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'area[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'input:not([disabled]):not([inert]):not([aria-hidden])', 'select:not([disabled]):not([inert]):not([aria-hidden])', 'textarea:not([disabled]):not([inert]):not([aria-hidden])', 'button:not([disabled]):not([inert]):not([aria-hidden])', 'iframe:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'object:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'embed:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[contenteditable]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[tabindex]:not([tabindex^="-"]):not([inert]):not([aria-hidden])'];

},{}],165:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var NetworkError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(NetworkError, _Error);

  function NetworkError(error, xhr) {
    var _this;

    if (xhr === void 0) {
      xhr = null;
    }

    _this = _Error.call(this, "This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.\n\nSource error: [" + error + "]") || this;
    _this.isNetworkError = true;
    _this.request = xhr;
    return _this;
  }

  return NetworkError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

module.exports = NetworkError;

},{}],166:[function(require,module,exports){
var findIndex = require('./findIndex');

function createCancelError() {
  return new Error('Cancelled');
}

module.exports = /*#__PURE__*/function () {
  function RateLimitedQueue(limit) {
    if (typeof limit !== 'number' || limit === 0) {
      this.limit = Infinity;
    } else {
      this.limit = limit;
    }

    this.activeRequests = 0;
    this.queuedHandlers = [];
  }

  var _proto = RateLimitedQueue.prototype;

  _proto._call = function _call(fn) {
    var _this = this;

    this.activeRequests += 1;
    var _done = false;
    var cancelActive;

    try {
      cancelActive = fn();
    } catch (err) {
      this.activeRequests -= 1;
      throw err;
    }

    return {
      abort: function abort() {
        if (_done) return;
        _done = true;
        _this.activeRequests -= 1;
        cancelActive();

        _this._queueNext();
      },
      done: function done() {
        if (_done) return;
        _done = true;
        _this.activeRequests -= 1;

        _this._queueNext();
      }
    };
  };

  _proto._queueNext = function _queueNext() {
    var _this2 = this;

    // Do it soon but not immediately, this allows clearing out the entire queue synchronously
    // one by one without continuously _advancing_ it (and starting new tasks before immediately
    // aborting them)
    Promise.resolve().then(function () {
      _this2._next();
    });
  };

  _proto._next = function _next() {
    if (this.activeRequests >= this.limit) {
      return;
    }

    if (this.queuedHandlers.length === 0) {
      return;
    } // Dispatch the next request, and update the abort/done handlers
    // so that cancelling it does the Right Thing (and doesn't just try
    // to dequeue an already-running request).


    var next = this.queuedHandlers.shift();

    var handler = this._call(next.fn);

    next.abort = handler.abort;
    next.done = handler.done;
  };

  _proto._queue = function _queue(fn, options) {
    var _this3 = this;

    if (options === void 0) {
      options = {};
    }

    var handler = {
      fn: fn,
      priority: options.priority || 0,
      abort: function abort() {
        _this3._dequeue(handler);
      },
      done: function done() {
        throw new Error('Cannot mark a queued request as done: this indicates a bug');
      }
    };
    var index = findIndex(this.queuedHandlers, function (other) {
      return handler.priority > other.priority;
    });

    if (index === -1) {
      this.queuedHandlers.push(handler);
    } else {
      this.queuedHandlers.splice(index, 0, handler);
    }

    return handler;
  };

  _proto._dequeue = function _dequeue(handler) {
    var index = this.queuedHandlers.indexOf(handler);

    if (index !== -1) {
      this.queuedHandlers.splice(index, 1);
    }
  };

  _proto.run = function run(fn, queueOptions) {
    if (this.activeRequests < this.limit) {
      return this._call(fn);
    }

    return this._queue(fn, queueOptions);
  };

  _proto.wrapPromiseFunction = function wrapPromiseFunction(fn, queueOptions) {
    var _this4 = this;

    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var queuedRequest;
      var outerPromise = new Promise(function (resolve, reject) {
        queuedRequest = _this4.run(function () {
          var cancelError;
          var innerPromise;

          try {
            innerPromise = Promise.resolve(fn.apply(void 0, args));
          } catch (err) {
            innerPromise = Promise.reject(err);
          }

          innerPromise.then(function (result) {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              resolve(result);
            }
          }, function (err) {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              reject(err);
            }
          });
          return function () {
            cancelError = createCancelError();
          };
        }, queueOptions);
      });

      outerPromise.abort = function () {
        queuedRequest.abort();
      };

      return outerPromise;
    };
  };

  return RateLimitedQueue;
}();

},{"./findIndex":174}],167:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var has = require('./hasProperty');
/**
 * Translates strings with interpolation & pluralization support.
 * Extensible with custom dictionaries and pluralization functions.
 *
 * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,
 * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded
 * and can be easily added among with dictionaries, nested objects are used for pluralization
 * as opposed to `||||` delimeter
 *
 * Usage example: `translator.translate('files_chosen', {smart_count: 3})`
 */


module.exports = /*#__PURE__*/function () {
  /**
   * @param {object|Array<object>} locales - locale or list of locales.
   */
  function Translator(locales) {
    var _this = this;

    this.locale = {
      strings: {},
      pluralize: function pluralize(n) {
        if (n === 1) {
          return 0;
        }

        return 1;
      }
    };

    if (Array.isArray(locales)) {
      locales.forEach(function (locale) {
        return _this._apply(locale);
      });
    } else {
      this._apply(locales);
    }
  }

  var _proto = Translator.prototype;

  _proto._apply = function _apply(locale) {
    if (!locale || !locale.strings) {
      return;
    }

    var prevLocale = this.locale;
    this.locale = _extends({}, prevLocale, {
      strings: _extends({}, prevLocale.strings, locale.strings)
    });
    this.locale.pluralize = locale.pluralize || prevLocale.pluralize;
  }
  /**
   * Takes a string with placeholder variables like `%{smart_count} file selected`
   * and replaces it with values from options `{smart_count: 5}`
   *
   * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
   * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
   *
   * @param {string} phrase that needs interpolation, with placeholders
   * @param {object} options with values that will be used to replace placeholders
   * @returns {any[]} interpolated
   */
  ;

  _proto.interpolate = function interpolate(phrase, options) {
    var _String$prototype = String.prototype,
        split = _String$prototype.split,
        replace = _String$prototype.replace;
    var dollarRegex = /\$/g;
    var dollarBillsYall = '$$$$';
    var interpolated = [phrase];

    for (var arg in options) {
      if (arg !== '_' && has(options, arg)) {
        // Ensure replacement value is escaped to prevent special $-prefixed
        // regex replace tokens. the "$$$$" is needed because each "$" needs to
        // be escaped with "$" itself, and we need two in the resulting output.
        var replacement = options[arg];

        if (typeof replacement === 'string') {
          replacement = replace.call(options[arg], dollarRegex, dollarBillsYall);
        } // We create a new `RegExp` each time instead of using a more-efficient
        // string replace so that the same argument can be replaced multiple times
        // in the same phrase.


        interpolated = insertReplacement(interpolated, new RegExp("%\\{" + arg + "\\}", 'g'), replacement);
      }
    }

    return interpolated;

    function insertReplacement(source, rx, replacement) {
      var newParts = [];
      source.forEach(function (chunk) {
        // When the source contains multiple placeholders for interpolation,
        // we should ignore chunks that are not strings, because those
        // can be JSX objects and will be otherwise incorrectly turned into strings.
        // Without this condition we’d get this: [object Object] hello [object Object] my <button>
        if (typeof chunk !== 'string') {
          return newParts.push(chunk);
        }

        split.call(chunk, rx).forEach(function (raw, i, list) {
          if (raw !== '') {
            newParts.push(raw);
          } // Interlace with the `replacement` value


          if (i < list.length - 1) {
            newParts.push(replacement);
          }
        });
      });
      return newParts;
    }
  }
  /**
   * Public translate method
   *
   * @param {string} key
   * @param {object} options with values that will be used later to replace placeholders in string
   * @returns {string} translated (and interpolated)
   */
  ;

  _proto.translate = function translate(key, options) {
    return this.translateArray(key, options).join('');
  }
  /**
   * Get a translation and return the translated and interpolated parts as an array.
   *
   * @param {string} key
   * @param {object} options with values that will be used to replace placeholders
   * @returns {Array} The translated and interpolated parts, in order.
   */
  ;

  _proto.translateArray = function translateArray(key, options) {
    if (!has(this.locale.strings, key)) {
      throw new Error("missing string: " + key);
    }

    var string = this.locale.strings[key];
    var hasPluralForms = typeof string === 'object';

    if (hasPluralForms) {
      if (options && typeof options.smart_count !== 'undefined') {
        var plural = this.locale.pluralize(options.smart_count);
        return this.interpolate(string[plural], options);
      }

      throw new Error('Attempted to use a string with plural forms, but no value was given for %{smart_count}');
    }

    return this.interpolate(string, options);
  };

  return Translator;
}();

},{"./hasProperty":189}],168:[function(require,module,exports){
var dataURItoBlob = require('./dataURItoBlob');
/**
 * Save a <canvas> element's content to a Blob object.
 *
 * @param {HTMLCanvasElement} canvas
 * @returns {Promise}
 */


module.exports = function canvasToBlob(canvas, type, quality) {
  if (canvas.toBlob) {
    return new Promise(function (resolve) {
      canvas.toBlob(resolve, type, quality);
    });
  }

  return Promise.resolve().then(function () {
    return dataURItoBlob(canvas.toDataURL(type, quality), {});
  });
};

},{"./dataURItoBlob":169}],169:[function(require,module,exports){
module.exports = function dataURItoBlob(dataURI, opts, toFile) {
  // get the base64 data
  var data = dataURI.split(',')[1]; // user may provide mime type, if not get it from data URI

  var mimeType = opts.mimeType || dataURI.split(',')[0].split(':')[1].split(';')[0]; // default to plain/text if data URI has no mimeType

  if (mimeType == null) {
    mimeType = 'plain/text';
  }

  var binary = atob(data);
  var array = [];

  for (var i = 0; i < binary.length; i++) {
    array.push(binary.charCodeAt(i));
  }

  var bytes;

  try {
    bytes = new Uint8Array(array); // eslint-disable-line compat/compat
  } catch (err) {
    return null;
  } // Convert to a File?


  if (toFile) {
    return new File([bytes], opts.name || '', {
      type: mimeType
    });
  }

  return new Blob([bytes], {
    type: mimeType
  });
};

},{}],170:[function(require,module,exports){
var throttle = require('lodash.throttle');

function _emitSocketProgress(uploader, progressData, file) {
  var progress = progressData.progress,
      bytesUploaded = progressData.bytesUploaded,
      bytesTotal = progressData.bytesTotal;

  if (progress) {
    uploader.uppy.log("Upload progress: " + progress);
    uploader.uppy.emit('upload-progress', file, {
      uploader: uploader,
      bytesUploaded: bytesUploaded,
      bytesTotal: bytesTotal
    });
  }
}

module.exports = throttle(_emitSocketProgress, 300, {
  leading: true,
  trailing: true
});

},{"lodash.throttle":17}],171:[function(require,module,exports){
var NetworkError = require('./NetworkError');
/**
 * Wrapper around window.fetch that throws a NetworkError when appropriate
 */


module.exports = function fetchWithNetworkError() {
  return fetch.apply(void 0, arguments).catch(function (err) {
    if (err.name === 'AbortError') {
      throw err;
    } else {
      throw new NetworkError(err);
    }
  });
};

},{"./NetworkError":165}],172:[function(require,module,exports){
var isDOMElement = require('./isDOMElement');
/**
 * Find one or more DOM elements.
 *
 * @param {string} element
 * @returns {Array|null}
 */


module.exports = function findAllDOMElements(element) {
  if (typeof element === 'string') {
    var elements = [].slice.call(document.querySelectorAll(element));
    return elements.length > 0 ? elements : null;
  }

  if (typeof element === 'object' && isDOMElement(element)) {
    return [element];
  }
};

},{"./isDOMElement":190}],173:[function(require,module,exports){
var isDOMElement = require('./isDOMElement');
/**
 * Find a DOM element.
 *
 * @param {Node|string} element
 * @returns {Node|null}
 */


module.exports = function findDOMElement(element, context) {
  if (context === void 0) {
    context = document;
  }

  if (typeof element === 'string') {
    return context.querySelector(element);
  }

  if (isDOMElement(element)) {
    return element;
  }
};

},{"./isDOMElement":190}],174:[function(require,module,exports){
/**
 * Array.prototype.findIndex ponyfill for old browsers.
 *
 * @param {Array} array
 * @param {Function} predicate
 * @returns {number}
 */
module.exports = function findIndex(array, predicate) {
  for (var i = 0; i < array.length; i++) {
    if (predicate(array[i])) return i;
  }

  return -1;
};

},{}],175:[function(require,module,exports){
/**
 * Takes a file object and turns it into fileID, by converting file.name to lowercase,
 * removing extra characters and adding type, size and lastModified
 *
 * @param {object} file
 * @returns {string} the fileID
 */
module.exports = function generateFileID(file) {
  // It's tempting to do `[items].filter(Boolean).join('-')` here, but that
  // is slower! simple string concatenation is fast
  var id = 'uppy';

  if (typeof file.name === 'string') {
    id += "-" + encodeFilename(file.name.toLowerCase());
  }

  if (file.type !== undefined) {
    id += "-" + file.type;
  }

  if (file.meta && typeof file.meta.relativePath === 'string') {
    id += "-" + encodeFilename(file.meta.relativePath.toLowerCase());
  }

  if (file.data.size !== undefined) {
    id += "-" + file.data.size;
  }

  if (file.data.lastModified !== undefined) {
    id += "-" + file.data.lastModified;
  }

  return id;
};

function encodeFilename(name) {
  var suffix = '';
  return name.replace(/[^A-Z0-9]/ig, function (character) {
    suffix += "-" + encodeCharacter(character);
    return '/';
  }) + suffix;
}

function encodeCharacter(character) {
  return character.charCodeAt(0).toString(32);
}

},{}],176:[function(require,module,exports){
module.exports = function getBytesRemaining(fileProgress) {
  return fileProgress.bytesTotal - fileProgress.bytesUploaded;
};

},{}],177:[function(require,module,exports){
var webkitGetAsEntryApi = require('./utils/webkitGetAsEntryApi/index');

var fallbackApi = require('./utils/fallbackApi');
/**
 * Returns a promise that resolves to the array of dropped files (if a folder is dropped, and browser supports folder parsing - promise resolves to the flat array of all files in all directories).
 * Each file has .relativePath prop appended to it (e.g. "/docs/Prague/ticket_from_prague_to_ufa.pdf") if browser supports it. Otherwise it's undefined.
 *
 * @param {DataTransfer} dataTransfer
 * @param {Function} logDropError - a function that's called every time some folder or some file error out (e.g. because of the folder name being too long on Windows). Notice that resulting promise will always be resolved anyway.
 *
 * @returns {Promise} - Array<File>
 */


module.exports = function getDroppedFiles(dataTransfer, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$logDropError = _ref.logDropError,
      logDropError = _ref$logDropError === void 0 ? function () {} : _ref$logDropError;

  // Get all files from all subdirs. Works (at least) in Chrome, Mozilla, and Safari
  if (dataTransfer.items && dataTransfer.items[0] && 'webkitGetAsEntry' in dataTransfer.items[0]) {
    return webkitGetAsEntryApi(dataTransfer, logDropError); // Otherwise just return all first-order files
  }

  return fallbackApi(dataTransfer);
};

},{"./utils/fallbackApi":178,"./utils/webkitGetAsEntryApi/index":181}],178:[function(require,module,exports){
var toArray = require('../../toArray'); // .files fallback, should be implemented in any browser


module.exports = function fallbackApi(dataTransfer) {
  var files = toArray(dataTransfer.files);
  return Promise.resolve(files);
};

},{"../../toArray":200}],179:[function(require,module,exports){
/**
 * Recursive function, calls the original callback() when the directory is entirely parsed.
 *
 * @param {FileSystemDirectoryReader} directoryReader
 * @param {Array} oldEntries
 * @param {Function} logDropError
 * @param {Function} callback - called with ([ all files and directories in that directoryReader ])
 */
module.exports = function getFilesAndDirectoriesFromDirectory(directoryReader, oldEntries, logDropError, _ref) {
  var onSuccess = _ref.onSuccess;
  directoryReader.readEntries(function (entries) {
    var newEntries = [].concat(oldEntries, entries); // According to the FileSystem API spec, getFilesAndDirectoriesFromDirectory() must be called until it calls the onSuccess with an empty array.

    if (entries.length) {
      setTimeout(function () {
        getFilesAndDirectoriesFromDirectory(directoryReader, newEntries, logDropError, {
          onSuccess: onSuccess
        });
      }, 0); // Done iterating this particular directory
    } else {
      onSuccess(newEntries);
    }
  }, // Make sure we resolve on error anyway, it's fine if only one directory couldn't be parsed!
  function (error) {
    logDropError(error);
    onSuccess(oldEntries);
  });
};

},{}],180:[function(require,module,exports){
/**
 * Get the relative path from the FileEntry#fullPath, because File#webkitRelativePath is always '', at least onDrop.
 *
 * @param {FileEntry} fileEntry
 *
 * @returns {string|null} - if file is not in a folder - return null (this is to be consistent with .relativePath-s of files selected from My Device). If file is in a folder - return its fullPath, e.g. '/simpsons/hi.jpeg'.
 */
module.exports = function getRelativePath(fileEntry) {
  // fileEntry.fullPath - "/simpsons/hi.jpeg" or undefined (for browsers that don't support it)
  // fileEntry.name - "hi.jpeg"
  if (!fileEntry.fullPath || fileEntry.fullPath === "/" + fileEntry.name) {
    return null;
  }

  return fileEntry.fullPath;
};

},{}],181:[function(require,module,exports){
var toArray = require('../../../toArray');

var getRelativePath = require('./getRelativePath');

var getFilesAndDirectoriesFromDirectory = require('./getFilesAndDirectoriesFromDirectory');

module.exports = function webkitGetAsEntryApi(dataTransfer, logDropError) {
  var files = [];
  var rootPromises = [];
  /**
   * Returns a resolved promise, when :files array is enhanced
   *
   * @param {(FileSystemFileEntry|FileSystemDirectoryEntry)} entry
   * @returns {Promise} - empty promise that resolves when :files is enhanced with a file
   */

  var createPromiseToAddFileOrParseDirectory = function createPromiseToAddFileOrParseDirectory(entry) {
    return new Promise(function (resolve) {
      // This is a base call
      if (entry.isFile) {
        // Creates a new File object which can be used to read the file.
        entry.file(function (file) {
          file.relativePath = getRelativePath(entry);
          files.push(file);
          resolve();
        }, // Make sure we resolve on error anyway, it's fine if only one file couldn't be read!
        function (error) {
          logDropError(error);
          resolve();
        }); // This is a recursive call
      } else if (entry.isDirectory) {
        var directoryReader = entry.createReader();
        getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {
          onSuccess: function onSuccess(entries) {
            var promises = entries.map(function (entry) {
              return createPromiseToAddFileOrParseDirectory(entry);
            });
            Promise.all(promises).then(function () {
              return resolve();
            });
          }
        });
      }
    });
  }; // For each dropped item, - make sure it's a file/directory, and start deepening in!


  toArray(dataTransfer.items).forEach(function (item) {
    var entry = item.webkitGetAsEntry(); // :entry can be null when we drop the url e.g.

    if (entry) {
      rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));
    }
  });
  return Promise.all(rootPromises).then(function () {
    return files;
  });
};

},{"../../../toArray":200,"./getFilesAndDirectoriesFromDirectory":179,"./getRelativePath":180}],182:[function(require,module,exports){
/**
 * Takes a full filename string and returns an object {name, extension}
 *
 * @param {string} fullFileName
 * @returns {object} {name, extension}
 */
module.exports = function getFileNameAndExtension(fullFileName) {
  var lastDot = fullFileName.lastIndexOf('.'); // these count as no extension: "no-dot", "trailing-dot."

  if (lastDot === -1 || lastDot === fullFileName.length - 1) {
    return {
      name: fullFileName,
      extension: undefined
    };
  }

  return {
    name: fullFileName.slice(0, lastDot),
    extension: fullFileName.slice(lastDot + 1)
  };
};

},{}],183:[function(require,module,exports){
var getFileNameAndExtension = require('./getFileNameAndExtension');

var mimeTypes = require('./mimeTypes');

module.exports = function getFileType(file) {
  var fileExtension = file.name ? getFileNameAndExtension(file.name).extension : null;
  fileExtension = fileExtension ? fileExtension.toLowerCase() : null;

  if (file.type) {
    // if mime type is set in the file object already, use that
    return file.type;
  }

  if (fileExtension && mimeTypes[fileExtension]) {
    // else, see if we can map extension to a mime type
    return mimeTypes[fileExtension];
  } // if all fails, fall back to a generic byte stream type


  return 'application/octet-stream';
};

},{"./getFileNameAndExtension":182,"./mimeTypes":195}],184:[function(require,module,exports){
// TODO Check which types are actually supported in browsers. Chrome likes webm
// from my testing, but we may need more.
// We could use a library but they tend to contain dozens of KBs of mappings,
// most of which will go unused, so not sure if that's worth it.
var mimeToExtensions = {
  'audio/mp3': 'mp3',
  'audio/mp4': 'mp4',
  'audio/ogg': 'ogg',
  'audio/webm': 'webm',
  'image/gif': 'gif',
  'image/heic': 'heic',
  'image/heif': 'heif',
  'image/jpeg': 'jpg',
  'image/png': 'png',
  'image/svg+xml': 'svg',
  'video/mp4': 'mp4',
  'video/ogg': 'ogv',
  'video/quicktime': 'mov',
  'video/webm': 'webm',
  'video/x-matroska': 'mkv',
  'video/x-msvideo': 'avi'
};

module.exports = function getFileTypeExtension(mimeType) {
  // Remove the ; bit in 'video/x-matroska;codecs=avc1'
  mimeType = mimeType.replace(/;.*$/, '');
  return mimeToExtensions[mimeType] || null;
};

},{}],185:[function(require,module,exports){
module.exports = function getSocketHost(url) {
  // get the host domain
  var regex = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i;
  var host = regex.exec(url)[1];
  var socketProtocol = /^http:\/\//i.test(url) ? 'ws' : 'wss';
  return socketProtocol + "://" + host;
};

},{}],186:[function(require,module,exports){
module.exports = function getSpeed(fileProgress) {
  if (!fileProgress.bytesUploaded) return 0;
  var timeElapsed = new Date() - fileProgress.uploadStarted;
  var uploadSpeed = fileProgress.bytesUploaded / (timeElapsed / 1000);
  return uploadSpeed;
};

},{}],187:[function(require,module,exports){
/**
 * Get the declared text direction for an element.
 *
 * @param {Node} element
 * @returns {string|undefined}
 */
function getTextDirection(element) {
  // There is another way to determine text direction using getComputedStyle(), as done here:
  // https://github.com/pencil-js/text-direction/blob/2a235ce95089b3185acec3b51313cbba921b3811/text-direction.js
  //
  // We do not use that approach because we are interested specifically in the _declared_ text direction.
  // If no text direction is declared, we have to provide our own explicit text direction so our
  // bidirectional CSS style sheets work.
  while (element && !element.dir) {
    element = element.parentNode;
  }

  return element ? element.dir : undefined;
}

module.exports = getTextDirection;

},{}],188:[function(require,module,exports){
/**
 * Returns a timestamp in the format of `hours:minutes:seconds`
 */
module.exports = function getTimeStamp() {
  var date = new Date();
  var hours = pad(date.getHours().toString());
  var minutes = pad(date.getMinutes().toString());
  var seconds = pad(date.getSeconds().toString());
  return hours + ":" + minutes + ":" + seconds;
};
/**
 * Adds zero to strings shorter than two characters
 */


function pad(str) {
  return str.length !== 2 ? 0 + str : str;
}

},{}],189:[function(require,module,exports){
module.exports = function has(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
};

},{}],190:[function(require,module,exports){
/**
 * Check if an object is a DOM element. Duck-typing based on `nodeType`.
 *
 * @param {*} obj
 */
module.exports = function isDOMElement(obj) {
  return obj && typeof obj === 'object' && obj.nodeType === Node.ELEMENT_NODE;
};

},{}],191:[function(require,module,exports){
/**
 * Checks if the browser supports Drag & Drop (not supported on mobile devices, for example).
 *
 * @returns {boolean}
 */
module.exports = function isDragDropSupported() {
  var div = document.createElement('div');

  if (!('draggable' in div) || !('ondragstart' in div && 'ondrop' in div)) {
    return false;
  }

  if (!('FormData' in window)) {
    return false;
  }

  if (!('FileReader' in window)) {
    return false;
  }

  return true;
};

},{}],192:[function(require,module,exports){
function isNetworkError(xhr) {
  if (!xhr) {
    return false;
  }

  return xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0;
}

module.exports = isNetworkError;

},{}],193:[function(require,module,exports){
/**
 * Check if a URL string is an object URL from `URL.createObjectURL`.
 *
 * @param {string} url
 * @returns {boolean}
 */
module.exports = function isObjectURL(url) {
  return url.indexOf('blob:') === 0;
};

},{}],194:[function(require,module,exports){
module.exports = function isPreviewSupported(fileType) {
  if (!fileType) return false;
  var fileTypeSpecific = fileType.split('/')[1]; // list of images that browsers can preview

  if (/^(jpe?g|gif|png|svg|svg\+xml|bmp|webp|avif)$/.test(fileTypeSpecific)) {
    return true;
  }

  return false;
};

},{}],195:[function(require,module,exports){
// ___Why not add the mime-types package?
//    It's 19.7kB gzipped, and we only need mime types for well-known extensions (for file previews).
// ___Where to take new extensions from?
//    https://github.com/jshttp/mime-db/blob/master/db.json
module.exports = {
  md: 'text/markdown',
  markdown: 'text/markdown',
  mp4: 'video/mp4',
  mp3: 'audio/mp3',
  svg: 'image/svg+xml',
  jpg: 'image/jpeg',
  png: 'image/png',
  gif: 'image/gif',
  heic: 'image/heic',
  heif: 'image/heif',
  yaml: 'text/yaml',
  yml: 'text/yaml',
  csv: 'text/csv',
  tsv: 'text/tab-separated-values',
  tab: 'text/tab-separated-values',
  avi: 'video/x-msvideo',
  mks: 'video/x-matroska',
  mkv: 'video/x-matroska',
  mov: 'video/quicktime',
  doc: 'application/msword',
  docm: 'application/vnd.ms-word.document.macroenabled.12',
  docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  dot: 'application/msword',
  dotm: 'application/vnd.ms-word.template.macroenabled.12',
  dotx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
  xla: 'application/vnd.ms-excel',
  xlam: 'application/vnd.ms-excel.addin.macroenabled.12',
  xlc: 'application/vnd.ms-excel',
  xlf: 'application/x-xliff+xml',
  xlm: 'application/vnd.ms-excel',
  xls: 'application/vnd.ms-excel',
  xlsb: 'application/vnd.ms-excel.sheet.binary.macroenabled.12',
  xlsm: 'application/vnd.ms-excel.sheet.macroenabled.12',
  xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  xlt: 'application/vnd.ms-excel',
  xltm: 'application/vnd.ms-excel.template.macroenabled.12',
  xltx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
  xlw: 'application/vnd.ms-excel',
  txt: 'text/plain',
  text: 'text/plain',
  conf: 'text/plain',
  log: 'text/plain',
  pdf: 'application/pdf',
  zip: 'application/zip',
  '7z': 'application/x-7z-compressed',
  rar: 'application/x-rar-compressed',
  tar: 'application/x-tar',
  gz: 'application/gzip',
  dmg: 'application/x-apple-diskimage'
};

},{}],196:[function(require,module,exports){
var secondsToTime = require('./secondsToTime');

module.exports = function prettyETA(seconds) {
  var time = secondsToTime(seconds); // Only display hours and minutes if they are greater than 0 but always
  // display minutes if hours is being displayed
  // Display a leading zero if the there is a preceding unit: 1m 05s, but 5s

  var hoursStr = time.hours ? time.hours + "h " : '';
  var minutesVal = time.hours ? ("0" + time.minutes).substr(-2) : time.minutes;
  var minutesStr = minutesVal ? minutesVal + "m" : '';
  var secondsVal = minutesVal ? ("0" + time.seconds).substr(-2) : time.seconds;
  var secondsStr = time.hours ? '' : minutesVal ? " " + secondsVal + "s" : secondsVal + "s";
  return "" + hoursStr + minutesStr + secondsStr;
};

},{"./secondsToTime":198}],197:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var getFileNameAndExtension = require('./getFileNameAndExtension');

module.exports = function remoteFileObjToLocal(file) {
  return _extends({}, file, {
    type: file.mimeType,
    extension: file.name ? getFileNameAndExtension(file.name).extension : null
  });
};

},{"./getFileNameAndExtension":182}],198:[function(require,module,exports){
module.exports = function secondsToTime(rawSeconds) {
  var hours = Math.floor(rawSeconds / 3600) % 24;
  var minutes = Math.floor(rawSeconds / 60) % 60;
  var seconds = Math.floor(rawSeconds % 60);
  return {
    hours: hours,
    minutes: minutes,
    seconds: seconds
  };
};

},{}],199:[function(require,module,exports){
module.exports = function settle(promises) {
  var resolutions = [];
  var rejections = [];

  function resolved(value) {
    resolutions.push(value);
  }

  function rejected(error) {
    rejections.push(error);
  }

  var wait = Promise.all(promises.map(function (promise) {
    return promise.then(resolved, rejected);
  }));
  return wait.then(function () {
    return {
      successful: resolutions,
      failed: rejections
    };
  });
};

},{}],200:[function(require,module,exports){
/**
 * Converts list into array
 */
module.exports = function toArray(list) {
  return Array.prototype.slice.call(list || [], 0);
};

},{}],201:[function(require,module,exports){
/**
 * Truncates a string to the given number of chars (maxLength) by inserting '...' in the middle of that string.
 * Partially taken from https://stackoverflow.com/a/5723274/3192470.
 *
 * @param {string} string - string to be truncated
 * @param {number} maxLength - maximum size of the resulting string
 * @returns {string}
 */
module.exports = function truncateString(string, maxLength) {
  var separator = '...'; // Return original string if it's already shorter than maxLength

  if (string.length <= maxLength) {
    return string; // Return truncated substring without '...' if string can't be meaningfully truncated
  }

  if (maxLength <= separator.length) {
    return string.substr(0, maxLength); // Return truncated string divided in half by '...'
  }

  var charsToShow = maxLength - separator.length;
  var frontChars = Math.ceil(charsToShow / 2);
  var backChars = Math.floor(charsToShow / 2);
  return string.substr(0, frontChars) + separator + string.substr(string.length - backChars);
};

},{}],202:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],203:[function(require,module,exports){
module.exports={
  "name": "@uppy/webcam",
  "description": "Uppy plugin that takes photos or records videos using the device's camera.",
  "version": "1.8.12",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "webcam",
    "picture",
    "photo",
    "video",
    "record",
    "mediarecorder"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],204:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    fill: "#0097DC",
    width: "66",
    height: "55",
    viewBox: "0 0 66 55"
  }, h("path", {
    d: "M57.3 8.433c4.59 0 8.1 3.51 8.1 8.1v29.7c0 4.59-3.51 8.1-8.1 8.1H8.7c-4.59 0-8.1-3.51-8.1-8.1v-29.7c0-4.59 3.51-8.1 8.1-8.1h9.45l4.59-7.02c.54-.54 1.35-1.08 2.16-1.08h16.2c.81 0 1.62.54 2.16 1.08l4.59 7.02h9.45zM33 14.64c-8.62 0-15.393 6.773-15.393 15.393 0 8.62 6.773 15.393 15.393 15.393 8.62 0 15.393-6.773 15.393-15.393 0-8.62-6.773-15.393-15.393-15.393zM33 40c-5.648 0-9.966-4.319-9.966-9.967 0-5.647 4.318-9.966 9.966-9.966s9.966 4.319 9.966 9.966C42.966 35.681 38.648 40 33 40z",
    fillRule: "evenodd"
  }));
};

},{"preact":202}],205:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/* eslint-disable jsx-a11y/media-has-caption */
var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var SnapshotButton = require('./SnapshotButton');

var RecordButton = require('./RecordButton');

var RecordingLength = require('./RecordingLength');

var VideoSourceSelect = require('./VideoSourceSelect');

var SubmitButton = require('./SubmitButton');

var DiscardButton = require('./DiscardButton');

function isModeAvailable(modes, mode) {
  return modes.indexOf(mode) !== -1;
}

var CameraScreen = /*#__PURE__*/function (_Component) {
  _inheritsLoose(CameraScreen, _Component);

  function CameraScreen() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = CameraScreen.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var onFocus = this.props.onFocus;
    onFocus();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var onStop = this.props.onStop;
    onStop();
  };

  _proto.render = function render() {
    var _this = this;

    var _this$props = this.props,
        src = _this$props.src,
        recordedVideo = _this$props.recordedVideo,
        recording = _this$props.recording,
        modes = _this$props.modes,
        supportsRecording = _this$props.supportsRecording,
        videoSources = _this$props.videoSources,
        showVideoSourceDropdown = _this$props.showVideoSourceDropdown,
        showRecordingLength = _this$props.showRecordingLength,
        onSubmit = _this$props.onSubmit,
        i18n = _this$props.i18n,
        mirror = _this$props.mirror,
        onSnapshot = _this$props.onSnapshot,
        onStartRecording = _this$props.onStartRecording,
        onStopRecording = _this$props.onStopRecording,
        onDiscardRecordedVideo = _this$props.onDiscardRecordedVideo,
        recordingLengthSeconds = _this$props.recordingLengthSeconds;
    var hasRecordedVideo = !!recordedVideo;
    var shouldShowRecordButton = !hasRecordedVideo && supportsRecording && (isModeAvailable(modes, 'video-only') || isModeAvailable(modes, 'audio-only') || isModeAvailable(modes, 'video-audio'));
    var shouldShowSnapshotButton = !hasRecordedVideo && isModeAvailable(modes, 'picture');
    var shouldShowRecordingLength = supportsRecording && showRecordingLength;
    var shouldShowVideoSourceDropdown = showVideoSourceDropdown && videoSources && videoSources.length > 1;
    var videoProps = {
      playsinline: true
    };

    if (recordedVideo) {
      videoProps.muted = false;
      videoProps.controls = true;
      videoProps.src = recordedVideo; // reset srcObject in dom. If not resetted, stream sticks in element

      if (this.videoElement) {
        this.videoElement.srcObject = undefined;
      }
    } else {
      videoProps.muted = true;
      videoProps.autoplay = true;
      videoProps.srcObject = src;
    }

    return h("div", {
      className: "uppy uppy-Webcam-container"
    }, h("div", {
      className: "uppy-Webcam-videoContainer"
    }, h("video", _extends({
      /* eslint-disable-next-line no-return-assign */
      ref: function ref(videoElement) {
        return _this.videoElement = videoElement;
      },
      className: "uppy-Webcam-video  " + (mirror ? 'uppy-Webcam-video--mirrored' : '')
      /* eslint-disable-next-line react/jsx-props-no-spreading */

    }, videoProps))), h("div", {
      className: "uppy-Webcam-footer"
    }, h("div", {
      className: "uppy-Webcam-videoSourceContainer"
    }, shouldShowVideoSourceDropdown ? VideoSourceSelect(this.props) : null), h("div", {
      className: "uppy-Webcam-buttonContainer"
    }, shouldShowSnapshotButton && h(SnapshotButton, {
      onSnapshot: onSnapshot,
      i18n: i18n
    }), shouldShowRecordButton && h(RecordButton, {
      recording: recording,
      onStartRecording: onStartRecording,
      onStopRecording: onStopRecording,
      i18n: i18n
    }), hasRecordedVideo && h(SubmitButton, {
      onSubmit: onSubmit,
      i18n: i18n
    }), hasRecordedVideo && h(DiscardButton, {
      onDiscard: onDiscardRecordedVideo,
      i18n: i18n
    })), shouldShowRecordingLength && h("div", {
      className: "uppy-Webcam-recordingLength"
    }, h(RecordingLength, {
      recordingLengthSeconds: recordingLengthSeconds,
      i18n: i18n
    }))));
  };

  return CameraScreen;
}(Component);

module.exports = CameraScreen;

},{"./DiscardButton":206,"./RecordButton":208,"./RecordingLength":209,"./SnapshotButton":210,"./SubmitButton":211,"./VideoSourceSelect":212,"preact":202}],206:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function DiscardButton(_ref) {
  var onDiscard = _ref.onDiscard,
      i18n = _ref.i18n;
  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button",
    type: "button",
    title: i18n('discardRecordedFile'),
    "aria-label": i18n('discardRecordedFile'),
    onClick: onDiscard,
    "data-uppy-super-focusable": true
  }, h("svg", {
    width: "13",
    height: "13",
    viewBox: "0 0 13 13",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon"
  }, h("g", {
    fill: "#FFF",
    fillRule: "evenodd"
  }, h("path", {
    d: "M.496 11.367L11.103.76l1.414 1.414L1.911 12.781z"
  }), h("path", {
    d: "M11.104 12.782L.497 2.175 1.911.76l10.607 10.606z"
  }))));
}

module.exports = DiscardButton;

},{"preact":202}],207:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("div", {
    className: "uppy-Webcam-permissons"
  }, h("div", {
    className: "uppy-Webcam-permissonsIcon"
  }, props.icon()), h("h1", {
    className: "uppy-Webcam-title"
  }, props.hasCamera ? props.i18n('allowAccessTitle') : props.i18n('noCameraTitle')), h("p", null, props.hasCamera ? props.i18n('allowAccessDescription') : props.i18n('noCameraDescription')));
};

},{"preact":202}],208:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function RecordButton(_ref) {
  var recording = _ref.recording,
      onStartRecording = _ref.onStartRecording,
      onStopRecording = _ref.onStopRecording,
      i18n = _ref.i18n;

  if (recording) {
    return h("button", {
      className: "uppy-u-reset uppy-c-btn uppy-Webcam-button",
      type: "button",
      title: i18n('stopRecording'),
      "aria-label": i18n('stopRecording'),
      onClick: onStopRecording,
      "data-uppy-super-focusable": true
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      width: "100",
      height: "100",
      viewBox: "0 0 100 100"
    }, h("rect", {
      x: "15",
      y: "15",
      width: "70",
      height: "70"
    })));
  }

  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button",
    type: "button",
    title: i18n('startRecording'),
    "aria-label": i18n('startRecording'),
    onClick: onStartRecording,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "100",
    height: "100",
    viewBox: "0 0 100 100"
  }, h("circle", {
    cx: "50",
    cy: "50",
    r: "40"
  })));
};

},{"preact":202}],209:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var formatSeconds = require('./formatSeconds');

module.exports = function RecordingLength(_ref) {
  var recordingLengthSeconds = _ref.recordingLengthSeconds,
      i18n = _ref.i18n;
  var formattedRecordingLengthSeconds = formatSeconds(recordingLengthSeconds);
  return h("span", {
    "aria-label": i18n('recordingLength', {
      recording_length: formattedRecordingLengthSeconds
    })
  }, formattedRecordingLengthSeconds);
};

},{"./formatSeconds":213,"preact":202}],210:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var CameraIcon = require('./CameraIcon');

module.exports = function (_ref) {
  var onSnapshot = _ref.onSnapshot,
      i18n = _ref.i18n;
  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--picture",
    type: "button",
    title: i18n('takePicture'),
    "aria-label": i18n('takePicture'),
    onClick: onSnapshot,
    "data-uppy-super-focusable": true
  }, CameraIcon());
};

},{"./CameraIcon":204,"preact":202}],211:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function SubmitButton(_ref) {
  var onSubmit = _ref.onSubmit,
      i18n = _ref.i18n;
  return h("button", {
    className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--submit",
    type: "button",
    title: i18n('submitRecordedFile'),
    "aria-label": i18n('submitRecordedFile'),
    onClick: onSubmit,
    "data-uppy-super-focusable": true
  }, h("svg", {
    width: "12",
    height: "9",
    viewBox: "0 0 12 9",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon"
  }, h("path", {
    fill: "#fff",
    fillRule: "nonzero",
    d: "M10.66 0L12 1.31 4.136 9 0 4.956l1.34-1.31L4.136 6.38z"
  })));
}

module.exports = SubmitButton;

},{"preact":202}],212:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (_ref) {
  var currentDeviceId = _ref.currentDeviceId,
      videoSources = _ref.videoSources,
      onChangeVideoSource = _ref.onChangeVideoSource;
  return h("div", {
    className: "uppy-Webcam-videoSource"
  }, h("select", {
    className: "uppy-u-reset uppy-Webcam-videoSource-select",
    onChange: function onChange(event) {
      onChangeVideoSource(event.target.value);
    }
  }, videoSources.map(function (videoSource) {
    return h("option", {
      key: videoSource.deviceId,
      value: videoSource.deviceId,
      selected: videoSource.deviceId === currentDeviceId
    }, videoSource.label);
  })));
};

},{"preact":202}],213:[function(require,module,exports){
/**
 * Takes an Integer value of seconds (e.g. 83) and converts it into a human-readable formatted string (e.g. '1:23').
 *
 * @param {Integer} seconds
 * @returns {string} the formatted seconds (e.g. '1:23' for 1 minute and 23 seconds)
 *
 */
module.exports = function formatSeconds(seconds) {
  return Math.floor(seconds / 60) + ":" + String(seconds % 60).padStart(2, 0);
};

},{}],214:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('preact'),
    h = _require.h;

var _require2 = require('./../../core'),
    Plugin = _require2.Plugin;

var Translator = require('./../../utils/lib/Translator');

var getFileTypeExtension = require('./../../utils/lib/getFileTypeExtension');

var mimeTypes = require('./../../utils/lib/mimeTypes');

var canvasToBlob = require('./../../utils/lib/canvasToBlob');

var supportsMediaRecorder = require('./supportsMediaRecorder');

var CameraIcon = require('./CameraIcon');

var CameraScreen = require('./CameraScreen');

var PermissionsScreen = require('./PermissionsScreen');

var packageJsonVersion = require('../package.json').version;
/**
 * Normalize a MIME type or file extension into a MIME type.
 *
 * @param {string} fileType - MIME type or a file extension prefixed with `.`.
 * @returns {string|undefined} The MIME type or `undefined` if the fileType is an extension and is not known.
 */


function toMimeType(fileType) {
  if (fileType[0] === '.') {
    return mimeTypes[fileType.slice(1)];
  }

  return fileType;
}
/**
 * Is this MIME type a video?
 *
 * @param {string} mimeType - MIME type.
 * @returns {boolean}
 */


function isVideoMimeType(mimeType) {
  return /^video\/[^*]+$/.test(mimeType);
}
/**
 * Is this MIME type an image?
 *
 * @param {string} mimeType - MIME type.
 * @returns {boolean}
 */


function isImageMimeType(mimeType) {
  return /^image\/[^*]+$/.test(mimeType);
}
/**
 * Setup getUserMedia, with polyfill for older browsers
 * Adapted from: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
 */


function getMediaDevices() {
  // eslint-disable-next-line compat/compat
  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    // eslint-disable-next-line compat/compat
    return navigator.mediaDevices;
  }

  var _getUserMedia = navigator.mozGetUserMedia || navigator.webkitGetUserMedia;

  if (!_getUserMedia) {
    return null;
  }

  return {
    getUserMedia: function getUserMedia(opts) {
      return new Promise(function (resolve, reject) {
        _getUserMedia.call(navigator, opts, resolve, reject);
      });
    }
  };
}
/**
 * Webcam
 */


module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Webcam, _Plugin);

  function Webcam(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.mediaDevices = getMediaDevices();
    _this.supportsUserMedia = !!_this.mediaDevices; // eslint-disable-next-line no-restricted-globals

    _this.protocol = location.protocol.match(/https/i) ? 'https' : 'http';
    _this.id = _this.opts.id || 'Webcam';
    _this.title = _this.opts.title || 'Camera';
    _this.type = 'acquirer';
    _this.capturedMediaFile = null;

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        fill: "#03BFEF",
        width: "32",
        height: "32",
        rx: "16"
      }), h("path", {
        d: "M22 11c1.133 0 2 .867 2 2v7.333c0 1.134-.867 2-2 2H10c-1.133 0-2-.866-2-2V13c0-1.133.867-2 2-2h2.333l1.134-1.733C13.6 9.133 13.8 9 14 9h4c.2 0 .4.133.533.267L19.667 11H22zm-6 1.533a3.764 3.764 0 0 0-3.8 3.8c0 2.129 1.672 3.801 3.8 3.801s3.8-1.672 3.8-3.8c0-2.13-1.672-3.801-3.8-3.801zm0 6.261c-1.395 0-2.46-1.066-2.46-2.46 0-1.395 1.065-2.461 2.46-2.461s2.46 1.066 2.46 2.46c0 1.395-1.065 2.461-2.46 2.461z",
        fill: "#FFF",
        fillRule: "nonzero"
      })));
    };

    _this.defaultLocale = {
      strings: {
        smile: 'Smile!',
        takePicture: 'Take a picture',
        startRecording: 'Begin video recording',
        stopRecording: 'Stop video recording',
        allowAccessTitle: 'Please allow access to your camera',
        allowAccessDescription: 'In order to take pictures or record video with your camera, please allow camera access for this site.',
        noCameraTitle: 'Camera Not Available',
        noCameraDescription: 'In order to take pictures or record video, please connect a camera device',
        recordingStoppedMaxSize: 'Recording stopped because the file size is about to exceed the limit',
        recordingLength: 'Recording length %{recording_length}',
        submitRecordedFile: 'Submit recorded file',
        discardRecordedFile: 'Discard recorded file'
      }
    }; // set default options

    var defaultOptions = {
      onBeforeSnapshot: function onBeforeSnapshot() {
        return Promise.resolve();
      },
      countdown: false,
      modes: ['video-audio', 'video-only', 'audio-only', 'picture'],
      mirror: true,
      showVideoSourceDropdown: false,
      facingMode: 'user',
      preferredImageMimeType: null,
      preferredVideoMimeType: null,
      showRecordingLength: false
    };
    _this.opts = _extends({}, defaultOptions, opts);

    _this.i18nInit();

    _this.install = _this.install.bind(_assertThisInitialized(_this));
    _this.setPluginState = _this.setPluginState.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this)); // Camera controls

    _this.start = _this.start.bind(_assertThisInitialized(_this));
    _this.stop = _this.stop.bind(_assertThisInitialized(_this));
    _this.takeSnapshot = _this.takeSnapshot.bind(_assertThisInitialized(_this));
    _this.startRecording = _this.startRecording.bind(_assertThisInitialized(_this));
    _this.stopRecording = _this.stopRecording.bind(_assertThisInitialized(_this));
    _this.discardRecordedVideo = _this.discardRecordedVideo.bind(_assertThisInitialized(_this));
    _this.submit = _this.submit.bind(_assertThisInitialized(_this));
    _this.oneTwoThreeSmile = _this.oneTwoThreeSmile.bind(_assertThisInitialized(_this));
    _this.focus = _this.focus.bind(_assertThisInitialized(_this));
    _this.changeVideoSource = _this.changeVideoSource.bind(_assertThisInitialized(_this));
    _this.webcamActive = false;

    if (_this.opts.countdown) {
      _this.opts.onBeforeSnapshot = _this.oneTwoThreeSmile;
    }

    _this.setPluginState({
      hasCamera: false,
      cameraReady: false,
      cameraError: null,
      recordingLengthSeconds: 0,
      videoSources: [],
      currentDeviceId: null
    });

    return _this;
  }

  var _proto = Webcam.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, _extends({}, newOpts, {
      videoConstraints: _extends({}, this.opts.videoConstraints, newOpts == null ? void 0 : newOpts.videoConstraints)
    }));

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.hasCameraCheck = function hasCameraCheck() {
    if (!this.mediaDevices) {
      return Promise.resolve(false);
    }

    return this.mediaDevices.enumerateDevices().then(function (devices) {
      return devices.some(function (device) {
        return device.kind === 'videoinput';
      });
    });
  };

  _proto.isAudioOnly = function isAudioOnly() {
    return this.opts.modes.length === 1 && this.opts.modes[0] === 'audio-only';
  };

  _proto.getConstraints = function getConstraints(deviceId) {
    var _this$opts$videoConst;

    if (deviceId === void 0) {
      deviceId = null;
    }

    var acceptsAudio = this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('audio-only') !== -1;
    var acceptsVideo = !this.isAudioOnly() && (this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('video-only') !== -1 || this.opts.modes.indexOf('picture') !== -1);

    var videoConstraints = _extends({}, (_this$opts$videoConst = this.opts.videoConstraints) != null ? _this$opts$videoConst : {
      facingMode: this.opts.facingMode
    }, deviceId ? {
      deviceId: deviceId,
      facingMode: null
    } : {});

    return {
      audio: acceptsAudio,
      video: acceptsVideo ? videoConstraints : false
    };
  } // eslint-disable-next-line consistent-return
  ;

  _proto.start = function start(options) {
    var _this2 = this;

    if (options === void 0) {
      options = null;
    }

    if (!this.supportsUserMedia) {
      return Promise.reject(new Error('Webcam access not supported'));
    }

    this.webcamActive = true;
    this.opts.mirror = true;
    var constraints = this.getConstraints(options && options.deviceId ? options.deviceId : null);
    this.hasCameraCheck().then(function (hasCamera) {
      _this2.setPluginState({
        hasCamera: hasCamera
      }); // ask user for access to their camera


      return _this2.mediaDevices.getUserMedia(constraints).then(function (stream) {
        _this2.stream = stream;
        var currentDeviceId = null;
        var tracks = _this2.isAudioOnly() ? stream.getAudioTracks() : stream.getVideoTracks();

        if (!options || !options.deviceId) {
          currentDeviceId = tracks[0].getSettings().deviceId;
        } else {
          tracks.forEach(function (track) {
            if (track.getSettings().deviceId === options.deviceId) {
              currentDeviceId = track.getSettings().deviceId;
            }
          });
        } // Update the sources now, so we can access the names.


        _this2.updateVideoSources();

        _this2.setPluginState({
          currentDeviceId: currentDeviceId,
          cameraReady: true
        });
      }).catch(function (err) {
        _this2.setPluginState({
          cameraReady: false,
          cameraError: err
        });

        _this2.uppy.info(err.message, 'error');
      });
    });
  }
  /**
   * @returns {object}
   */
  ;

  _proto.getMediaRecorderOptions = function getMediaRecorderOptions() {
    var options = {}; // Try to use the `opts.preferredVideoMimeType` or one of the `allowedFileTypes` for the recording.
    // If the browser doesn't support it, we'll fall back to the browser default instead.
    // Safari doesn't have the `isTypeSupported` API.

    if (MediaRecorder.isTypeSupported) {
      var restrictions = this.uppy.opts.restrictions;
      var preferredVideoMimeTypes = [];

      if (this.opts.preferredVideoMimeType) {
        preferredVideoMimeTypes = [this.opts.preferredVideoMimeType];
      } else if (restrictions.allowedFileTypes) {
        preferredVideoMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isVideoMimeType);
      }

      var filterSupportedTypes = function filterSupportedTypes(candidateType) {
        return MediaRecorder.isTypeSupported(candidateType) && getFileTypeExtension(candidateType);
      };

      var acceptableMimeTypes = preferredVideoMimeTypes.filter(filterSupportedTypes);

      if (acceptableMimeTypes.length > 0) {
        // eslint-disable-next-line prefer-destructuring
        options.mimeType = acceptableMimeTypes[0];
      }
    }

    return options;
  };

  _proto.startRecording = function startRecording() {
    var _this3 = this;

    // only used if supportsMediaRecorder() returned true
    // eslint-disable-next-line compat/compat
    this.recorder = new MediaRecorder(this.stream, this.getMediaRecorderOptions());
    this.recordingChunks = [];
    var stoppingBecauseOfMaxSize = false;
    this.recorder.addEventListener('dataavailable', function (event) {
      _this3.recordingChunks.push(event.data);

      var restrictions = _this3.uppy.opts.restrictions;

      if (_this3.recordingChunks.length > 1 && restrictions.maxFileSize != null && !stoppingBecauseOfMaxSize) {
        var totalSize = _this3.recordingChunks.reduce(function (acc, chunk) {
          return acc + chunk.size;
        }, 0); // Exclude the initial chunk from the average size calculation because it is likely to be a very small outlier


        var averageChunkSize = (totalSize - _this3.recordingChunks[0].size) / (_this3.recordingChunks.length - 1);
        var expectedEndChunkSize = averageChunkSize * 3;
        var maxSize = Math.max(0, restrictions.maxFileSize - expectedEndChunkSize);

        if (totalSize > maxSize) {
          stoppingBecauseOfMaxSize = true;

          _this3.uppy.info(_this3.i18n('recordingStoppedMaxSize'), 'warning', 4000);

          _this3.stopRecording();
        }
      }
    }); // use a "time slice" of 500ms: ondataavailable will be called each 500ms
    // smaller time slices mean we can more accurately check the max file size restriction

    this.recorder.start(500);

    if (this.opts.showRecordingLength) {
      // Start the recordingLengthTimer if we are showing the recording length.
      this.recordingLengthTimer = setInterval(function () {
        var currentRecordingLength = _this3.getPluginState().recordingLengthSeconds;

        _this3.setPluginState({
          recordingLengthSeconds: currentRecordingLength + 1
        });
      }, 1000);
    }

    this.setPluginState({
      isRecording: true
    });
  };

  _proto.stopRecording = function stopRecording() {
    var _this4 = this;

    var stopped = new Promise(function (resolve) {
      _this4.recorder.addEventListener('stop', function () {
        resolve();
      });

      _this4.recorder.stop();

      if (_this4.opts.showRecordingLength) {
        // Stop the recordingLengthTimer if we are showing the recording length.
        clearInterval(_this4.recordingLengthTimer);

        _this4.setPluginState({
          recordingLengthSeconds: 0
        });
      }
    });
    return stopped.then(function () {
      _this4.setPluginState({
        isRecording: false
      });

      return _this4.getVideo();
    }).then(function (file) {
      try {
        _this4.capturedMediaFile = file; // create object url for capture result preview

        _this4.setPluginState({
          // eslint-disable-next-line compat/compat
          recordedVideo: URL.createObjectURL(file.data)
        });

        _this4.opts.mirror = false;
      } catch (err) {
        // Logging the error, exept restrictions, which is handled in Core
        if (!err.isRestriction) {
          _this4.uppy.log(err);
        }
      }
    }).then(function () {
      _this4.recordingChunks = null;
      _this4.recorder = null;
    }, function (error) {
      _this4.recordingChunks = null;
      _this4.recorder = null;
      throw error;
    });
  };

  _proto.discardRecordedVideo = function discardRecordedVideo() {
    this.setPluginState({
      recordedVideo: null
    });
    this.opts.mirror = true;
    this.capturedMediaFile = null;
  };

  _proto.submit = function submit() {
    try {
      if (this.capturedMediaFile) {
        this.uppy.addFile(this.capturedMediaFile);
      }
    } catch (err) {
      // Logging the error, exept restrictions, which is handled in Core
      if (!err.isRestriction) {
        this.uppy.log(err, 'error');
      }
    }
  };

  _proto.stop = function stop() {
    if (this.stream) {
      this.stream.getAudioTracks().forEach(function (track) {
        track.stop();
      });
      this.stream.getVideoTracks().forEach(function (track) {
        track.stop();
      });
    }

    this.webcamActive = false;
    this.stream = null;
    this.setPluginState({
      recordedVideo: null
    });
  };

  _proto.getVideoElement = function getVideoElement() {
    return this.el.querySelector('.uppy-Webcam-video');
  };

  _proto.oneTwoThreeSmile = function oneTwoThreeSmile() {
    var _this5 = this;

    return new Promise(function (resolve, reject) {
      var count = _this5.opts.countdown; // eslint-disable-next-line consistent-return

      var countDown = setInterval(function () {
        if (!_this5.webcamActive) {
          clearInterval(countDown);
          _this5.captureInProgress = false;
          return reject(new Error('Webcam is not active'));
        }

        if (count > 0) {
          _this5.uppy.info(count + "...", 'warning', 800);

          count--;
        } else {
          clearInterval(countDown);

          _this5.uppy.info(_this5.i18n('smile'), 'success', 1500);

          setTimeout(function () {
            return resolve();
          }, 1500);
        }
      }, 1000);
    });
  };

  _proto.takeSnapshot = function takeSnapshot() {
    var _this6 = this;

    if (this.captureInProgress) return;
    this.captureInProgress = true;
    this.opts.onBeforeSnapshot().catch(function (err) {
      var message = typeof err === 'object' ? err.message : err;

      _this6.uppy.info(message, 'error', 5000);

      return Promise.reject(new Error("onBeforeSnapshot: " + message));
    }).then(function () {
      return _this6.getImage();
    }).then(function (tagFile) {
      _this6.captureInProgress = false;

      try {
        _this6.uppy.addFile(tagFile);
      } catch (err) {
        // Logging the error, except restrictions, which is handled in Core
        if (!err.isRestriction) {
          _this6.uppy.log(err);
        }
      }
    }, function (error) {
      _this6.captureInProgress = false;
      throw error;
    });
  };

  _proto.getImage = function getImage() {
    var _this7 = this;

    var video = this.getVideoElement();

    if (!video) {
      return Promise.reject(new Error('No video element found, likely due to the Webcam tab being closed.'));
    }

    var width = video.videoWidth;
    var height = video.videoHeight;
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);
    var restrictions = this.uppy.opts.restrictions;
    var preferredImageMimeTypes = [];

    if (this.opts.preferredImageMimeType) {
      preferredImageMimeTypes = [this.opts.preferredImageMimeType];
    } else if (restrictions.allowedFileTypes) {
      preferredImageMimeTypes = restrictions.allowedFileTypes.map(toMimeType).filter(isImageMimeType);
    }

    var mimeType = preferredImageMimeTypes[0] || 'image/jpeg';
    var ext = getFileTypeExtension(mimeType) || 'jpg';
    var name = "cam-" + Date.now() + "." + ext;
    return canvasToBlob(canvas, mimeType).then(function (blob) {
      return {
        source: _this7.id,
        name: name,
        data: new Blob([blob], {
          type: mimeType
        }),
        type: mimeType
      };
    });
  };

  _proto.getVideo = function getVideo() {
    // Sometimes in iOS Safari, Blobs (especially the first Blob in the recordingChunks Array)
    // have empty 'type' attributes (e.g. '') so we need to find a Blob that has a defined 'type'
    // attribute in order to determine the correct MIME type.
    var mimeType = this.recordingChunks.find(function (blob) {
      var _blob$type;

      return ((_blob$type = blob.type) == null ? void 0 : _blob$type.length) > 0;
    }).type;
    var fileExtension = getFileTypeExtension(mimeType);

    if (!fileExtension) {
      return Promise.reject(new Error("Could not retrieve recording: Unsupported media type \"" + mimeType + "\""));
    }

    var name = "webcam-" + Date.now() + "." + fileExtension;
    var blob = new Blob(this.recordingChunks, {
      type: mimeType
    });
    var file = {
      source: this.id,
      name: name,
      data: new Blob([blob], {
        type: mimeType
      }),
      type: mimeType
    };
    return Promise.resolve(file);
  };

  _proto.focus = function focus() {
    var _this8 = this;

    if (!this.opts.countdown) return;
    setTimeout(function () {
      _this8.uppy.info(_this8.i18n('smile'), 'success', 1500);
    }, 1000);
  };

  _proto.changeVideoSource = function changeVideoSource(deviceId) {
    this.stop();
    this.start({
      deviceId: deviceId
    });
  };

  _proto.updateVideoSources = function updateVideoSources() {
    var _this9 = this;

    this.mediaDevices.enumerateDevices().then(function (devices) {
      _this9.setPluginState({
        videoSources: devices.filter(function (device) {
          return device.kind === 'videoinput';
        })
      });
    });
  };

  _proto.render = function render() {
    if (!this.webcamActive) {
      this.start();
    }

    var webcamState = this.getPluginState();

    if (!webcamState.cameraReady || !webcamState.hasCamera) {
      return h(PermissionsScreen, {
        icon: CameraIcon,
        i18n: this.i18n,
        hasCamera: webcamState.hasCamera
      });
    }

    return h(CameraScreen // eslint-disable-next-line react/jsx-props-no-spreading
    , _extends({}, webcamState, {
      onChangeVideoSource: this.changeVideoSource,
      onSnapshot: this.takeSnapshot,
      onStartRecording: this.startRecording,
      onStopRecording: this.stopRecording,
      onDiscardRecordedVideo: this.discardRecordedVideo,
      onSubmit: this.submit,
      onFocus: this.focus,
      onStop: this.stop,
      i18n: this.i18n,
      modes: this.opts.modes,
      showRecordingLength: this.opts.showRecordingLength,
      showVideoSourceDropdown: this.opts.showVideoSourceDropdown,
      supportsRecording: supportsMediaRecorder(),
      recording: webcamState.isRecording,
      mirror: this.opts.mirror,
      src: this.stream
    }));
  };

  _proto.install = function install() {
    var _this10 = this;

    this.setPluginState({
      cameraReady: false,
      recordingLengthSeconds: 0
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }

    if (this.mediaDevices) {
      this.updateVideoSources();

      this.mediaDevices.ondevicechange = function () {
        _this10.updateVideoSources();

        if (_this10.stream) {
          var restartStream = true;

          var _this10$getPluginStat = _this10.getPluginState(),
              videoSources = _this10$getPluginStat.videoSources,
              currentDeviceId = _this10$getPluginStat.currentDeviceId;

          videoSources.forEach(function (videoSource) {
            if (currentDeviceId === videoSource.deviceId) {
              restartStream = false;
            }
          });

          if (restartStream) {
            _this10.stop();

            _this10.start();
          }
        }
      };
    }
  };

  _proto.uninstall = function uninstall() {
    if (this.stream) {
      this.stop();
    }

    this.unmount();
  };

  return Webcam;
}(Plugin), _class.VERSION = packageJsonVersion, _temp);

},{"../package.json":203,"./../../core":55,"./../../utils/lib/Translator":167,"./../../utils/lib/canvasToBlob":168,"./../../utils/lib/getFileTypeExtension":184,"./../../utils/lib/mimeTypes":195,"./CameraIcon":204,"./CameraScreen":205,"./PermissionsScreen":207,"./supportsMediaRecorder":215,"preact":202}],215:[function(require,module,exports){
module.exports = function supportsMediaRecorder() {
  /* eslint-disable compat/compat */
  return typeof MediaRecorder === 'function' && !!MediaRecorder.prototype && typeof MediaRecorder.prototype.start === 'function';
  /* eslint-enable compat/compat */
};

},{}],216:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],217:[function(require,module,exports){
module.exports={
  "name": "@uppy/zoom",
  "description": "Import files from zoom, into Uppy.",
  "version": "0.1.18",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "zoom"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  },
  "publishConfig": {
    "access": "public"
  }
}

},{}],218:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var _require3 = require('./../../provider-views'),
    ProviderViews = _require3.ProviderViews;

var _require4 = require('preact'),
    h = _require4.h;

module.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {
  _inheritsLoose(Zoom, _Plugin);

  function Zoom(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Zoom';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Zoom';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h("rect", {
        className: "uppy-ProviderIconBg",
        width: "32",
        height: "32",
        rx: "16",
        fill: "#0E71EB"
      }), h("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h("path", {
        fill: "#fff",
        d: "M29,31H14c-1.657,0-3-1.343-3-3V17h15c1.657,0,3,1.343,3,3V31z",
        style: "transform: translate(-5px, -5px) scale(0.9);"
      }), h("polygon", {
        fill: "#fff",
        points: "37,31 31,27 31,21 37,17",
        style: "transform: translate(-5px, -5px) scale(0.9);"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      companionKeysParams: _this.opts.companionKeysParams,
      companionCookiesRule: _this.opts.companionCookiesRule,
      provider: 'zoom',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Zoom.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]);
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return Zoom;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":217,"./../../companion-client":50,"./../../core":55,"./../../provider-views":136,"preact":216}],219:[function(require,module,exports){
require('es6-promise/auto');

require('whatwg-fetch');

var Uppy = require('./../../../../packages/@uppy/core');

var Dashboard = require('./../../../../packages/@uppy/dashboard');

var GoogleDrive = require('./../../../../packages/@uppy/google-drive');

var Dropbox = require('./../../../../packages/@uppy/dropbox');

var Instagram = require('./../../../../packages/@uppy/instagram');

var Facebook = require('./../../../../packages/@uppy/facebook');

var OneDrive = require('./../../../../packages/@uppy/onedrive');

var Zoom = require('./../../../../packages/@uppy/zoom');

var ImageEditor = require('./../../../../packages/@uppy/image-editor');

var Url = require('./../../../../packages/@uppy/url');

var Webcam = require('./../../../../packages/@uppy/webcam');

var ScreenCapture = require('./../../../../packages/@uppy/screen-capture');

var Tus = require('./../../../../packages/@uppy/tus');

var DropTarget = require('./../../../../packages/@uppy/drop-target');

var GoldenRetriever = require('./../../../../packages/@uppy/golden-retriever');

var localeList = require('../locale_list.json');

var COMPANION = require('../env');

var RTL_LOCALES = ['ar_SA', 'fa_IR', 'he_IL'];

if (typeof window !== 'undefined' && typeof window.Uppy === 'undefined') {
  window.Uppy = {
    locales: {}
  };
}

function uppyInit() {
  if (window.uppy) {
    window.uppy.close();
  }

  var opts = window.uppyOptions;
  var uppy = new Uppy({
    logger: Uppy.debugLogger
  });
  uppy.use(Tus, {
    endpoint: 'https://tusd.tusdemo.net/files/',
    resume: true
  });
  uppy.on('complete', function (result) {
    console.log('successful files:');
    console.log(result.successful);
    console.log('failed files:');
    console.log(result.failed);
  });
  uppy.use(Dashboard, {
    trigger: '.UppyModalOpenerBtn',
    target: opts.DashboardInline ? '.DashboardContainer' : 'body',
    inline: opts.DashboardInline,
    replaceTargetContent: opts.DashboardInline,
    height: 470,
    showProgressDetails: true,
    metaFields: [{
      id: 'name',
      name: 'Name',
      placeholder: 'file name'
    }, {
      id: 'caption',
      name: 'Caption',
      placeholder: 'add description'
    }]
  });
  window.uppy = uppy;
}

function uppySetOptions() {
  var opts = window.uppyOptions;
  var defaultNullRestrictions = {
    maxFileSize: null,
    minFileSize: null,
    maxNumberOfFiles: null,
    minNumberOfFiles: null,
    allowedFileTypes: null
  };
  var restrictions = {
    maxFileSize: 1000000,
    maxNumberOfFiles: 3,
    minNumberOfFiles: 2,
    allowedFileTypes: ['image/*', 'video/*']
  };
  window.uppy.setOptions({
    autoProceed: opts.autoProceed,
    restrictions: opts.restrictions ? restrictions : defaultNullRestrictions
  });
  window.uppy.getPlugin('Dashboard').setOptions({
    note: opts.restrictions ? 'Images and video only, 2–3 files, up to 1 MB' : '',
    theme: opts.darkMode ? 'dark' : 'light',
    disabled: opts.disabled
  });
  var googleDriveInstance = window.uppy.getPlugin('GoogleDrive');

  if (opts.GoogleDrive && !googleDriveInstance) {
    window.uppy.use(GoogleDrive, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.GoogleDrive && googleDriveInstance) {
    window.uppy.removePlugin(googleDriveInstance);
  }

  var dropboxInstance = window.uppy.getPlugin('Dropbox');

  if (opts.Dropbox && !dropboxInstance) {
    window.uppy.use(Dropbox, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.Dropbox && dropboxInstance) {
    window.uppy.removePlugin(dropboxInstance);
  }

  var instagramInstance = window.uppy.getPlugin('Instagram');

  if (opts.Instagram && !instagramInstance) {
    window.uppy.use(Instagram, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.Instagram && instagramInstance) {
    window.uppy.removePlugin(instagramInstance);
  }

  var urlInstance = window.uppy.getPlugin('Url');

  if (opts.Url && !urlInstance) {
    window.uppy.use(Url, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.Url && urlInstance) {
    window.uppy.removePlugin(urlInstance);
  }

  var facebookInstance = window.uppy.getPlugin('Facebook');

  if (opts.Facebook && !facebookInstance) {
    window.uppy.use(Facebook, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.Facebook && facebookInstance) {
    window.uppy.removePlugin(facebookInstance);
  }

  var oneDriveInstance = window.uppy.getPlugin('OneDrive');

  if (opts.OneDrive && !oneDriveInstance) {
    window.uppy.use(OneDrive, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.OneDrive && oneDriveInstance) {
    window.uppy.removePlugin(oneDriveInstance);
  }

  var zoomInstance = window.uppy.getPlugin('Zoom');

  if (opts.Zoom && !zoomInstance) {
    window.uppy.use(Zoom, {
      target: Dashboard,
      companionUrl: 'https://intense-meadow-61813.herokuapp.com/'
    });
  }

  if (!opts.Zoom && zoomInstance) {
    window.uppy.removePlugin(zoomInstance);
  }

  var webcamInstance = window.uppy.getPlugin('Webcam');

  if (opts.Webcam && !webcamInstance) {
    window.uppy.use(Webcam, {
      target: Dashboard,
      showVideoSourceDropdown: true
    });
  }

  if (!opts.Webcam && webcamInstance) {
    window.uppy.removePlugin(webcamInstance);
  }

  var screenCaptureInstance = window.uppy.getPlugin('ScreenCapture');

  if (opts.ScreenCapture && !screenCaptureInstance) {
    window.uppy.use(ScreenCapture, {
      target: Dashboard
    });
  }

  if (!opts.ScreenCapture && screenCaptureInstance) {
    window.uppy.removePlugin(screenCaptureInstance);
  }

  var imageEditorInstance = window.uppy.getPlugin('ImageEditor');

  if (opts.imageEditor && !imageEditorInstance) {
    window.uppy.use(ImageEditor, {
      target: Dashboard
    });
  }

  if (!opts.imageEditor && imageEditorInstance) {
    window.uppy.removePlugin(imageEditorInstance);
  }

  var dropTargetInstance = window.uppy.getPlugin('DropTarget');

  if (opts.DropTarget && !dropTargetInstance) {
    window.uppy.use(DropTarget, {
      target: document.body
    });
  }

  if (!opts.DropTarget && dropTargetInstance) {
    window.uppy.removePlugin(dropTargetInstance);
  }

  var goldenRetrieverInstance = window.uppy.getPlugin('GoldenRetriever');

  if (opts.GoldenRetriever && !goldenRetrieverInstance) {
    window.uppy.use(GoldenRetriever);
  }

  if (!opts.GoldenRetriever && goldenRetrieverInstance) {
    window.uppy.removePlugin(goldenRetrieverInstance);
  }
}

function whenLocaleAvailable(localeName, callback) {
  var interval = 100; // ms

  var loop = setInterval(function () {
    if (window.Uppy && window.Uppy.locales && window.Uppy.locales[localeName]) {
      clearInterval(loop);
      callback(window.Uppy.locales[localeName]);
    }
  }, interval);
}

function loadLocaleFromCDN(localeName) {
  var head = document.getElementsByTagName('head')[0];
  var js = document.createElement('script');
  js.type = 'text/javascript';
  js.src = "https://releases.transloadit.com/uppy/locales/v1.21.0/" + localeName + ".min.js";
  head.appendChild(js);
}

function setLocale(localeName) {
  if (typeof window.Uppy.locales[localeName] === 'undefined') {
    loadLocaleFromCDN(localeName);
  }

  whenLocaleAvailable(localeName, function (localeObj) {
    var direction = RTL_LOCALES.indexOf(localeName) !== -1 ? 'rtl' : 'ltr';
    window.uppy.setOptions({
      locale: localeObj
    });
    window.uppy.getPlugin('Dashboard').setOptions({
      direction: direction
    });
  });
}

function populateLocaleSelect() {
  var localeSelect = document.getElementById('localeList');
  Object.keys(localeList).forEach(function (localeName) {
    if (localeName === 'en_US') return;
    localeSelect.innerHTML += "<option value=\"" + localeName + "\">" + localeList[localeName] + " \u2014 (" + localeName + ")</option>";
  });
  localeSelect.addEventListener('change', function (event) {
    var localeName = event.target.value;
    setLocale(localeName);
  });
}

window.uppySetOptions = uppySetOptions;
window.uppyInit = uppyInit;
window.uppySetLocale = setLocale;
populateLocaleSelect();
uppyInit();
uppySetOptions();

},{"../env":220,"../locale_list.json":221,"./../../../../packages/@uppy/core":55,"./../../../../packages/@uppy/dashboard":76,"./../../../../packages/@uppy/drop-target":84,"./../../../../packages/@uppy/dropbox":87,"./../../../../packages/@uppy/facebook":90,"./../../../../packages/@uppy/golden-retriever":95,"./../../../../packages/@uppy/google-drive":99,"./../../../../packages/@uppy/image-editor":103,"./../../../../packages/@uppy/instagram":109,"./../../../../packages/@uppy/onedrive":112,"./../../../../packages/@uppy/screen-capture":145,"./../../../../packages/@uppy/tus":157,"./../../../../packages/@uppy/url":161,"./../../../../packages/@uppy/webcam":214,"./../../../../packages/@uppy/zoom":218,"es6-promise/auto":10,"whatwg-fetch":42}],220:[function(require,module,exports){
var companionEndpoint = 'http://localhost:3020';

if (location.hostname === 'uppy.io' || /--uppy\.netlify\.app$/.test(location.hostname)) {
  companionEndpoint = '//companion.uppy.io';
}

var COMPANION = companionEndpoint;
module.exports = COMPANION;

},{}],221:[function(require,module,exports){
module.exports={"ar_SA":"Arabic (Saudi Arabia)","bg_BG":"Bulgarian (Bulgaria)","cs_CZ":"Czech (Czechia)","da_DK":"Danish (Denmark)","de_DE":"German (Germany)","el_GR":"Greek (Greece)","en_US":"English (United States)","es_ES":"Spanish (Spain)","fa_IR":"Persian (Iran)","fi_FI":"Finnish (Finland)","fr_FR":"French (France)","gl_ES":"Galician (Spain)","he_IL":"Hebrew (Israel)","hr_HR":"Croatian (Croatia)","hu_HU":"Hungarian (Hungary)","id_ID":"Indonesian (Indonesia)","is_IS":"Icelandic (Iceland)","it_IT":"Italian (Italy)","ja_JP":"Japanese (Japan)","ko_KR":"Korean (South Korea)","nb_NO":"Norwegian Bokmål (Norway)","nl_NL":"Dutch (Netherlands)","pl_PL":"Polish (Poland)","pt_BR":"Portuguese (Brazil)","pt_PT":"Portuguese (Portugal)","ro_RO":"Romanian (Romania)","ru_RU":"Russian (Russia)","sk_SK":"Slovak (Slovakia)","sr_RS_Cyrillic":"Serbian (Serbia, Cyrillic)","sr_RS_Latin":"Serbian (Serbia, Latin)","sv_SE":"Swedish (Sweden)","th_TH":"Thai (Thailand)","tr_TR":"Turkish (Turkey)","uk_UA":"Ukrainian (Ukraine)","vi_VN":"Vietnamese (Vietnam)","zh_CN":"Chinese (China)","zh_TW":"Chinese (Taiwan)"}
},{}]},{},[219])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzL3ByZXR0aWVyQnl0ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Nyb3BwZXJqcy9kaXN0L2Nyb3BwZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvY3VpZC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jdWlkL2xpYi9maW5nZXJwcmludC5icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2N1aWQvbGliL2dldFJhbmRvbVZhbHVlLmJyb3dzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvY3VpZC9saWIvcGFkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2F1dG8uanMiLCIuLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9leGlmci9kaXN0L21pbmkubGVnYWN5LnVtZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2lzLXNoYWxsb3ctZXF1YWwvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLnRocm90dGxlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL21hdGgtbG9nMi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9tZW1vaXplLW9uZS9kaXN0L21lbW9pemUtb25lLmNqcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9taW1lLW1hdGNoL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL25hbWVzcGFjZS1lbWl0dGVyL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9xcy1zdHJpbmdpZnkvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmdpZnkvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcmVxdWlyZXMtcG9ydC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvYnJvd3Nlci9maWxlUmVhZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL2ZpbmdlcnByaW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL2h0dHBTdGFjay5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvYnJvd3Nlci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvYnJvd3Nlci9pc0NvcmRvdmEuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvaXNSZWFjdE5hdGl2ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvYnJvd3Nlci9yZWFkQXNCeXRlQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvdXJpVG9CbG9iLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL3VybFN0b3JhZ2UuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Vycm9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9sb2dnZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L25vb3BVcmxTdG9yYWdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS91cGxvYWQuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L3V1aWQuanMiLCIuLi9ub2RlX21vZHVsZXMvdXJsLXBhcnNlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9kaXN0L2ZldGNoLnVtZC5qcyIsIi4uL25vZGVfbW9kdWxlcy93aWxkY2FyZC9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvbXBhbmlvbi1jbGllbnQvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvY29tcGFuaW9uLWNsaWVudC9zcmMvQXV0aEVycm9yLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29tcGFuaW9uLWNsaWVudC9zcmMvUHJvdmlkZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb21wYW5pb24tY2xpZW50L3NyYy9SZXF1ZXN0Q2xpZW50LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29tcGFuaW9uLWNsaWVudC9zcmMvU2VhcmNoUHJvdmlkZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb21wYW5pb24tY2xpZW50L3NyYy9Tb2NrZXQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb21wYW5pb24tY2xpZW50L3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvbXBhbmlvbi1jbGllbnQvc3JjL3Rva2VuU3RvcmFnZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvcmUvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvY29yZS9zcmMvUGx1Z2luLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29yZS9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb3JlL3NyYy9sb2dnZXJzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29yZS9zcmMvc3VwcG9ydHNVcGxvYWRQcm9ncmVzcy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvQWRkRmlsZXMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvQWRkRmlsZXNQYW5lbC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9EYXNoYm9hcmQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRWRpdG9yUGFuZWwuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUNhcmQvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vQnV0dG9ucy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9GaWxlSXRlbS9GaWxlSW5mby9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9GaWxlSXRlbS9GaWxlUHJldmlld0FuZExpbmsvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vRmlsZVByb2dyZXNzL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVJdGVtL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVMaXN0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL0ZpbGVQcmV2aWV3LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL1BpY2tlclBhbmVsQ29udGVudC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9QaWNrZXJQYW5lbFRvcEJhci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9TbGlkZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9WaXJ0dWFsTGlzdC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL3V0aWxzL2NvcHlUb0NsaXBib2FyZC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvdXRpbHMvY3JlYXRlU3VwZXJGb2N1cy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvdXRpbHMvZ2V0QWN0aXZlT3ZlcmxheUVsLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy91dGlscy9nZXRGaWxlVHlwZUljb24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL3V0aWxzL2lnbm9yZUV2ZW50LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy91dGlscy90cmFwRm9jdXMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kcm9wLXRhcmdldC9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9kcm9wLXRhcmdldC9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kcm9wYm94L3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L2Ryb3Bib3gvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZmFjZWJvb2svcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvZmFjZWJvb2svc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZ29sZGVuLXJldHJpZXZlci9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9nb2xkZW4tcmV0cmlldmVyL3NyYy9JbmRleGVkREJTdG9yZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2dvbGRlbi1yZXRyaWV2ZXIvc3JjL01ldGFEYXRhU3RvcmUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9nb2xkZW4tcmV0cmlldmVyL3NyYy9TZXJ2aWNlV29ya2VyU3RvcmUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9nb2xkZW4tcmV0cmlldmVyL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2dvb2dsZS1kcml2ZS9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9nb29nbGUtZHJpdmUvc3JjL0RyaXZlUHJvdmlkZXJWaWV3cy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2dvb2dsZS1kcml2ZS9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9pbWFnZS1lZGl0b3IvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvaW1hZ2UtZWRpdG9yL3NyYy9FZGl0b3IuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9pbWFnZS1lZGl0b3Ivc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvaW5mb3JtZXIvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvaW5mb3JtZXIvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvaW5zdGFncmFtL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L2luc3RhZ3JhbS9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9vbmVkcml2ZS9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9vbmVkcml2ZS9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvQnJlYWRjcnVtYnMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvQnJvd3Nlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9DbG9zZVdyYXBwZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvRmlsdGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0Zvb3RlckFjdGlvbnMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvSXRlbS9jb21wb25lbnRzL0dyaWRMaS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9JdGVtL2NvbXBvbmVudHMvSXRlbUljb24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvSXRlbS9jb21wb25lbnRzL0xpc3RMaS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9JdGVtL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0l0ZW1MaXN0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0xvYWRlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9Qcm92aWRlclZpZXcvQXV0aFZpZXcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvUHJvdmlkZXJWaWV3L0hlYWRlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9Qcm92aWRlclZpZXcvUHJvdmlkZXJWaWV3LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1Byb3ZpZGVyVmlldy9Vc2VyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1Byb3ZpZGVyVmlldy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9TZWFyY2hQcm92aWRlclZpZXcvSGVhZGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL1NlYXJjaFByb3ZpZGVyVmlldy9JbnB1dFZpZXcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvU2VhcmNoUHJvdmlkZXJWaWV3L1NlYXJjaFByb3ZpZGVyVmlldy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9TZWFyY2hQcm92aWRlclZpZXcvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvU2hhcmVkSGFuZGxlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3NjcmVlbi1jYXB0dXJlL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3NjcmVlbi1jYXB0dXJlL3NyYy9DYXB0dXJlU2NyZWVuLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc2NyZWVuLWNhcHR1cmUvc3JjL1JlY29yZEJ1dHRvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3NjcmVlbi1jYXB0dXJlL3NyYy9TY3JlZW5SZWNJY29uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc2NyZWVuLWNhcHR1cmUvc3JjL1N0b3BXYXRjaC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3NjcmVlbi1jYXB0dXJlL3NyYy9TdHJlYW1TdGF0dXMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9zY3JlZW4tY2FwdHVyZS9zcmMvU3VibWl0QnV0dG9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc2NyZWVuLWNhcHR1cmUvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc3RhdHVzLWJhci9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9zdGF0dXMtYmFyL3NyYy9TdGF0dXNCYXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9zdGF0dXMtYmFyL3NyYy9TdGF0dXNCYXJTdGF0ZXMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9zdGF0dXMtYmFyL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3N0b3JlLWRlZmF1bHQvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvc3RvcmUtZGVmYXVsdC9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS90aHVtYm5haWwtZ2VuZXJhdG9yL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3RodW1ibmFpbC1nZW5lcmF0b3Ivc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdHVzL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3R1cy9zcmMvZ2V0RmluZ2VycHJpbnQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS90dXMvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXJsL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3VybC9zcmMvVXJsVUkuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91cmwvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXJsL3NyYy91dGlscy9mb3JFYWNoRHJvcHBlZE9yUGFzdGVkVXJsLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL0V2ZW50VHJhY2tlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9GT0NVU0FCTEVfRUxFTUVOVFMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvTmV0d29ya0Vycm9yLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL1JhdGVMaW1pdGVkUXVldWUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvVHJhbnNsYXRvci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9jYW52YXNUb0Jsb2IuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZGF0YVVSSXRvQmxvYi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9lbWl0U29ja2V0UHJvZ3Jlc3MuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZmV0Y2hXaXRoTmV0d29ya0Vycm9yLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2ZpbmRBbGxET01FbGVtZW50cy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9maW5kRE9NRWxlbWVudC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9maW5kSW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2VuZXJhdGVGaWxlSUQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0Qnl0ZXNSZW1haW5pbmcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RHJvcHBlZEZpbGVzL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldERyb3BwZWRGaWxlcy91dGlscy9mYWxsYmFja0FwaS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXREcm9wcGVkRmlsZXMvdXRpbHMvd2Via2l0R2V0QXNFbnRyeUFwaS9nZXRGaWxlc0FuZERpcmVjdG9yaWVzRnJvbURpcmVjdG9yeS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXREcm9wcGVkRmlsZXMvdXRpbHMvd2Via2l0R2V0QXNFbnRyeUFwaS9nZXRSZWxhdGl2ZVBhdGguanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RHJvcHBlZEZpbGVzL3V0aWxzL3dlYmtpdEdldEFzRW50cnlBcGkvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RmlsZVR5cGUuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RmlsZVR5cGVFeHRlbnNpb24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0U29ja2V0SG9zdC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRTcGVlZC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRUZXh0RGlyZWN0aW9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldFRpbWVTdGFtcC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9oYXNQcm9wZXJ0eS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9pc0RPTUVsZW1lbnQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvaXNEcmFnRHJvcFN1cHBvcnRlZC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9pc05ldHdvcmtFcnJvci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9pc09iamVjdFVSTC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9pc1ByZXZpZXdTdXBwb3J0ZWQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvbWltZVR5cGVzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL3ByZXR0eUVUQS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9yZW1vdGVGaWxlT2JqVG9Mb2NhbC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9zZWNvbmRzVG9UaW1lLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL3NldHRsZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy90b0FycmF5LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL3RydW5jYXRlU3RyaW5nLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvQ2FtZXJhSWNvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvQ2FtZXJhU2NyZWVuLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9EaXNjYXJkQnV0dG9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9QZXJtaXNzaW9uc1NjcmVlbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvUmVjb3JkQnV0dG9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9SZWNvcmRpbmdMZW5ndGguanMiLCIuLi9wYWNrYWdlcy9AdXBweS93ZWJjYW0vc3JjL1NuYXBzaG90QnV0dG9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9TdWJtaXRCdXR0b24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS93ZWJjYW0vc3JjL1ZpZGVvU291cmNlU2VsZWN0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9mb3JtYXRTZWNvbmRzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvc3VwcG9ydHNNZWRpYVJlY29yZGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvem9vbS9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS96b29tL3NyYy9pbmRleC5qcyIsInNyYy9leGFtcGxlcy9kYXNoYm9hcmQvYXBwLmVzNiIsInNyYy9leGFtcGxlcy9lbnYuanMiLCJzcmMvZXhhbXBsZXMvbG9jYWxlX2xpc3QuanNvbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoaUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RwQ0E7QUFDQTs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDelhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4NkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDam9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QyxVQUFiLENBQXdCLEdBQXhCO0FBQ0EsSUFBQSxPQUFPO0FBQ1IsR0FITSxDQUFQO0FBSUQsQ0FMRDs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUF4QjtBQUNBLE1BQU0sQ0FBQyxRQUFQLEdBQWtCLFFBQWxCO0FBQ0EsTUFBTSxDQUFDLGFBQVAsR0FBdUIsU0FBdkI7QUFFQSxvQkFBb0I7QUFDcEIsUUFBUTtBQUNSLGNBQWM7OztBQzVQZCxJQUFJLGlCQUFpQixHQUFHLHVCQUF4Qjs7QUFFQSxJQUFJLFFBQVEsQ0FBQyxRQUFULEtBQXNCLFNBQXRCLElBQW1DLHdCQUF3QixJQUF4QixDQUE2QixRQUFRLENBQUMsUUFBdEMsQ0FBdkMsRUFBd0Y7QUFDdEYsRUFBQSxpQkFBaUIsR0FBRyxxQkFBcEI7QUFDRDs7QUFFRCxJQUFNLFNBQVMsR0FBRyxpQkFBbEI7QUFDQSxNQUFNLENBQUMsT0FBUCxHQUFpQixTQUFqQjs7O0FDUEEiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0ZsZXQvcHJldHRpZXItYnl0ZXMvXG4vLyBDaGFuZ2luZyAxMDAwIGJ5dGVzIHRvIDEwMjQsIHNvIHdlIGNhbiBrZWVwIHVwcGVyY2FzZSBLQiB2cyBrQlxuLy8gSVNDIExpY2Vuc2UgKGMpIERhbiBGbGV0dHJlIGh0dHBzOi8vZ2l0aHViLmNvbS9GbGV0L3ByZXR0aWVyLWJ5dGVzL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJldHRpZXJCeXRlcyAobnVtKSB7XG4gIGlmICh0eXBlb2YgbnVtICE9PSAnbnVtYmVyJyB8fCBpc05hTihudW0pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBudW1iZXIsIGdvdCAnICsgdHlwZW9mIG51bSlcbiAgfVxuXG4gIHZhciBuZWcgPSBudW0gPCAwXG4gIHZhciB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddXG5cbiAgaWYgKG5lZykge1xuICAgIG51bSA9IC1udW1cbiAgfVxuXG4gIGlmIChudW0gPCAxKSB7XG4gICAgcmV0dXJuIChuZWcgPyAnLScgOiAnJykgKyBudW0gKyAnIEInXG4gIH1cblxuICB2YXIgZXhwb25lbnQgPSBNYXRoLm1pbihNYXRoLmZsb29yKE1hdGgubG9nKG51bSkgLyBNYXRoLmxvZygxMDI0KSksIHVuaXRzLmxlbmd0aCAtIDEpXG4gIG51bSA9IE51bWJlcihudW0gLyBNYXRoLnBvdygxMDI0LCBleHBvbmVudCkpXG4gIHZhciB1bml0ID0gdW5pdHNbZXhwb25lbnRdXG5cbiAgaWYgKG51bSA+PSAxMCB8fCBudW0gJSAxID09PSAwKSB7XG4gICAgLy8gRG8gbm90IHNob3cgZGVjaW1hbHMgd2hlbiB0aGUgbnVtYmVyIGlzIHR3by1kaWdpdCwgb3IgaWYgdGhlIG51bWJlciBoYXMgbm9cbiAgICAvLyBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICByZXR1cm4gKG5lZyA/ICctJyA6ICcnKSArIG51bS50b0ZpeGVkKDApICsgJyAnICsgdW5pdFxuICB9IGVsc2Uge1xuICAgIHJldHVybiAobmVnID8gJy0nIDogJycpICsgbnVtLnRvRml4ZWQoMSkgKyAnICcgKyB1bml0XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTggSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRpZiAoYXJnLmxlbmd0aCkge1xuXHRcdFx0XHRcdHZhciBpbm5lciA9IGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHRcdFx0XHRpZiAoaW5uZXIpIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChpbm5lcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGlmIChhcmcudG9TdHJpbmcgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIiwiLyohXG4gKiBDcm9wcGVyLmpzIHYxLjUuN1xuICogaHR0cHM6Ly9mZW5neXVhbmNoZW4uZ2l0aHViLmlvL2Nyb3BwZXJqc1xuICpcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQgQ2hlbiBGZW5neXVhblxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMC0wNS0yM1QwNToyMzowMC4wODFaXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5Dcm9wcGVyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgICAgaWYgKGkgJSAyKSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIHZhciBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBXSU5ET1cgPSBJU19CUk9XU0VSID8gd2luZG93IDoge307XG4gIHZhciBJU19UT1VDSF9ERVZJQ0UgPSBJU19CUk9XU0VSICYmIFdJTkRPVy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAnb250b3VjaHN0YXJ0JyBpbiBXSU5ET1cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZmFsc2U7XG4gIHZhciBIQVNfUE9JTlRFUl9FVkVOVCA9IElTX0JST1dTRVIgPyAnUG9pbnRlckV2ZW50JyBpbiBXSU5ET1cgOiBmYWxzZTtcbiAgdmFyIE5BTUVTUEFDRSA9ICdjcm9wcGVyJzsgLy8gQWN0aW9uc1xuXG4gIHZhciBBQ1RJT05fQUxMID0gJ2FsbCc7XG4gIHZhciBBQ1RJT05fQ1JPUCA9ICdjcm9wJztcbiAgdmFyIEFDVElPTl9NT1ZFID0gJ21vdmUnO1xuICB2YXIgQUNUSU9OX1pPT00gPSAnem9vbSc7XG4gIHZhciBBQ1RJT05fRUFTVCA9ICdlJztcbiAgdmFyIEFDVElPTl9XRVNUID0gJ3cnO1xuICB2YXIgQUNUSU9OX1NPVVRIID0gJ3MnO1xuICB2YXIgQUNUSU9OX05PUlRIID0gJ24nO1xuICB2YXIgQUNUSU9OX05PUlRIX0VBU1QgPSAnbmUnO1xuICB2YXIgQUNUSU9OX05PUlRIX1dFU1QgPSAnbncnO1xuICB2YXIgQUNUSU9OX1NPVVRIX0VBU1QgPSAnc2UnO1xuICB2YXIgQUNUSU9OX1NPVVRIX1dFU1QgPSAnc3cnOyAvLyBDbGFzc2VzXG5cbiAgdmFyIENMQVNTX0NST1AgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWNyb3BcIik7XG4gIHZhciBDTEFTU19ESVNBQkxFRCA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItZGlzYWJsZWRcIik7XG4gIHZhciBDTEFTU19ISURERU4gPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWhpZGRlblwiKTtcbiAgdmFyIENMQVNTX0hJREUgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWhpZGVcIik7XG4gIHZhciBDTEFTU19JTlZJU0lCTEUgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWludmlzaWJsZVwiKTtcbiAgdmFyIENMQVNTX01PREFMID0gXCJcIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1tb2RhbFwiKTtcbiAgdmFyIENMQVNTX01PVkUgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLW1vdmVcIik7IC8vIERhdGEga2V5c1xuXG4gIHZhciBEQVRBX0FDVElPTiA9IFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCJBY3Rpb25cIik7XG4gIHZhciBEQVRBX1BSRVZJRVcgPSBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiUHJldmlld1wiKTsgLy8gRHJhZyBtb2Rlc1xuXG4gIHZhciBEUkFHX01PREVfQ1JPUCA9ICdjcm9wJztcbiAgdmFyIERSQUdfTU9ERV9NT1ZFID0gJ21vdmUnO1xuICB2YXIgRFJBR19NT0RFX05PTkUgPSAnbm9uZSc7IC8vIEV2ZW50c1xuXG4gIHZhciBFVkVOVF9DUk9QID0gJ2Nyb3AnO1xuICB2YXIgRVZFTlRfQ1JPUF9FTkQgPSAnY3JvcGVuZCc7XG4gIHZhciBFVkVOVF9DUk9QX01PVkUgPSAnY3JvcG1vdmUnO1xuICB2YXIgRVZFTlRfQ1JPUF9TVEFSVCA9ICdjcm9wc3RhcnQnO1xuICB2YXIgRVZFTlRfREJMQ0xJQ0sgPSAnZGJsY2xpY2snO1xuICB2YXIgRVZFTlRfVE9VQ0hfU1RBUlQgPSBJU19UT1VDSF9ERVZJQ0UgPyAndG91Y2hzdGFydCcgOiAnbW91c2Vkb3duJztcbiAgdmFyIEVWRU5UX1RPVUNIX01PVkUgPSBJU19UT1VDSF9ERVZJQ0UgPyAndG91Y2htb3ZlJyA6ICdtb3VzZW1vdmUnO1xuICB2YXIgRVZFTlRfVE9VQ0hfRU5EID0gSVNfVE9VQ0hfREVWSUNFID8gJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJyA6ICdtb3VzZXVwJztcbiAgdmFyIEVWRU5UX1BPSU5URVJfRE9XTiA9IEhBU19QT0lOVEVSX0VWRU5UID8gJ3BvaW50ZXJkb3duJyA6IEVWRU5UX1RPVUNIX1NUQVJUO1xuICB2YXIgRVZFTlRfUE9JTlRFUl9NT1ZFID0gSEFTX1BPSU5URVJfRVZFTlQgPyAncG9pbnRlcm1vdmUnIDogRVZFTlRfVE9VQ0hfTU9WRTtcbiAgdmFyIEVWRU5UX1BPSU5URVJfVVAgPSBIQVNfUE9JTlRFUl9FVkVOVCA/ICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCcgOiBFVkVOVF9UT1VDSF9FTkQ7XG4gIHZhciBFVkVOVF9SRUFEWSA9ICdyZWFkeSc7XG4gIHZhciBFVkVOVF9SRVNJWkUgPSAncmVzaXplJztcbiAgdmFyIEVWRU5UX1dIRUVMID0gJ3doZWVsJztcbiAgdmFyIEVWRU5UX1pPT00gPSAnem9vbSc7IC8vIE1pbWUgdHlwZXNcblxuICB2YXIgTUlNRV9UWVBFX0pQRUcgPSAnaW1hZ2UvanBlZyc7IC8vIFJlZ0V4cHNcblxuICB2YXIgUkVHRVhQX0FDVElPTlMgPSAvXmV8d3xzfG58c2V8c3d8bmV8bnd8YWxsfGNyb3B8bW92ZXx6b29tJC87XG4gIHZhciBSRUdFWFBfREFUQV9VUkwgPSAvXmRhdGE6LztcbiAgdmFyIFJFR0VYUF9EQVRBX1VSTF9KUEVHID0gL15kYXRhOmltYWdlXFwvanBlZztiYXNlNjQsLztcbiAgdmFyIFJFR0VYUF9UQUdfTkFNRSA9IC9eaW1nfGNhbnZhcyQvaTsgLy8gTWlzY1xuXG4gIHZhciBERUZBVUxUUyA9IHtcbiAgICAvLyBEZWZpbmUgdGhlIHZpZXcgbW9kZSBvZiB0aGUgY3JvcHBlclxuICAgIHZpZXdNb2RlOiAwLFxuICAgIC8vIDAsIDEsIDIsIDNcbiAgICAvLyBEZWZpbmUgdGhlIGRyYWdnaW5nIG1vZGUgb2YgdGhlIGNyb3BwZXJcbiAgICBkcmFnTW9kZTogRFJBR19NT0RFX0NST1AsXG4gICAgLy8gJ2Nyb3AnLCAnbW92ZScgb3IgJ25vbmUnXG4gICAgLy8gRGVmaW5lIHRoZSBpbml0aWFsIGFzcGVjdCByYXRpbyBvZiB0aGUgY3JvcCBib3hcbiAgICBpbml0aWFsQXNwZWN0UmF0aW86IE5hTixcbiAgICAvLyBEZWZpbmUgdGhlIGFzcGVjdCByYXRpbyBvZiB0aGUgY3JvcCBib3hcbiAgICBhc3BlY3RSYXRpbzogTmFOLFxuICAgIC8vIEFuIG9iamVjdCB3aXRoIHRoZSBwcmV2aW91cyBjcm9wcGluZyByZXN1bHQgZGF0YVxuICAgIGRhdGE6IG51bGwsXG4gICAgLy8gQSBzZWxlY3RvciBmb3IgYWRkaW5nIGV4dHJhIGNvbnRhaW5lcnMgdG8gcHJldmlld1xuICAgIHByZXZpZXc6ICcnLFxuICAgIC8vIFJlLXJlbmRlciB0aGUgY3JvcHBlciB3aGVuIHJlc2l6ZSB0aGUgd2luZG93XG4gICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAvLyBSZXN0b3JlIHRoZSBjcm9wcGVkIGFyZWEgYWZ0ZXIgcmVzaXplIHRoZSB3aW5kb3dcbiAgICByZXN0b3JlOiB0cnVlLFxuICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGltYWdlIGlzIGEgY3Jvc3Mtb3JpZ2luIGltYWdlXG4gICAgY2hlY2tDcm9zc09yaWdpbjogdHJ1ZSxcbiAgICAvLyBDaGVjayB0aGUgY3VycmVudCBpbWFnZSdzIEV4aWYgT3JpZW50YXRpb24gaW5mb3JtYXRpb25cbiAgICBjaGVja09yaWVudGF0aW9uOiB0cnVlLFxuICAgIC8vIFNob3cgdGhlIGJsYWNrIG1vZGFsXG4gICAgbW9kYWw6IHRydWUsXG4gICAgLy8gU2hvdyB0aGUgZGFzaGVkIGxpbmVzIGZvciBndWlkaW5nXG4gICAgZ3VpZGVzOiB0cnVlLFxuICAgIC8vIFNob3cgdGhlIGNlbnRlciBpbmRpY2F0b3IgZm9yIGd1aWRpbmdcbiAgICBjZW50ZXI6IHRydWUsXG4gICAgLy8gU2hvdyB0aGUgd2hpdGUgbW9kYWwgdG8gaGlnaGxpZ2h0IHRoZSBjcm9wIGJveFxuICAgIGhpZ2hsaWdodDogdHJ1ZSxcbiAgICAvLyBTaG93IHRoZSBncmlkIGJhY2tncm91bmRcbiAgICBiYWNrZ3JvdW5kOiB0cnVlLFxuICAgIC8vIEVuYWJsZSB0byBjcm9wIHRoZSBpbWFnZSBhdXRvbWF0aWNhbGx5IHdoZW4gaW5pdGlhbGl6ZVxuICAgIGF1dG9Dcm9wOiB0cnVlLFxuICAgIC8vIERlZmluZSB0aGUgcGVyY2VudGFnZSBvZiBhdXRvbWF0aWMgY3JvcHBpbmcgYXJlYSB3aGVuIGluaXRpYWxpemVzXG4gICAgYXV0b0Nyb3BBcmVhOiAwLjgsXG4gICAgLy8gRW5hYmxlIHRvIG1vdmUgdGhlIGltYWdlXG4gICAgbW92YWJsZTogdHJ1ZSxcbiAgICAvLyBFbmFibGUgdG8gcm90YXRlIHRoZSBpbWFnZVxuICAgIHJvdGF0YWJsZTogdHJ1ZSxcbiAgICAvLyBFbmFibGUgdG8gc2NhbGUgdGhlIGltYWdlXG4gICAgc2NhbGFibGU6IHRydWUsXG4gICAgLy8gRW5hYmxlIHRvIHpvb20gdGhlIGltYWdlXG4gICAgem9vbWFibGU6IHRydWUsXG4gICAgLy8gRW5hYmxlIHRvIHpvb20gdGhlIGltYWdlIGJ5IGRyYWdnaW5nIHRvdWNoXG4gICAgem9vbU9uVG91Y2g6IHRydWUsXG4gICAgLy8gRW5hYmxlIHRvIHpvb20gdGhlIGltYWdlIGJ5IHdoZWVsaW5nIG1vdXNlXG4gICAgem9vbU9uV2hlZWw6IHRydWUsXG4gICAgLy8gRGVmaW5lIHpvb20gcmF0aW8gd2hlbiB6b29tIHRoZSBpbWFnZSBieSB3aGVlbGluZyBtb3VzZVxuICAgIHdoZWVsWm9vbVJhdGlvOiAwLjEsXG4gICAgLy8gRW5hYmxlIHRvIG1vdmUgdGhlIGNyb3AgYm94XG4gICAgY3JvcEJveE1vdmFibGU6IHRydWUsXG4gICAgLy8gRW5hYmxlIHRvIHJlc2l6ZSB0aGUgY3JvcCBib3hcbiAgICBjcm9wQm94UmVzaXphYmxlOiB0cnVlLFxuICAgIC8vIFRvZ2dsZSBkcmFnIG1vZGUgYmV0d2VlbiBcImNyb3BcIiBhbmQgXCJtb3ZlXCIgd2hlbiBjbGljayB0d2ljZSBvbiB0aGUgY3JvcHBlclxuICAgIHRvZ2dsZURyYWdNb2RlT25EYmxjbGljazogdHJ1ZSxcbiAgICAvLyBTaXplIGxpbWl0YXRpb25cbiAgICBtaW5DYW52YXNXaWR0aDogMCxcbiAgICBtaW5DYW52YXNIZWlnaHQ6IDAsXG4gICAgbWluQ3JvcEJveFdpZHRoOiAwLFxuICAgIG1pbkNyb3BCb3hIZWlnaHQ6IDAsXG4gICAgbWluQ29udGFpbmVyV2lkdGg6IDIwMCxcbiAgICBtaW5Db250YWluZXJIZWlnaHQ6IDEwMCxcbiAgICAvLyBTaG9ydGN1dHMgb2YgZXZlbnRzXG4gICAgcmVhZHk6IG51bGwsXG4gICAgY3JvcHN0YXJ0OiBudWxsLFxuICAgIGNyb3Btb3ZlOiBudWxsLFxuICAgIGNyb3BlbmQ6IG51bGwsXG4gICAgY3JvcDogbnVsbCxcbiAgICB6b29tOiBudWxsXG4gIH07XG5cbiAgdmFyIFRFTVBMQVRFID0gJzxkaXYgY2xhc3M9XCJjcm9wcGVyLWNvbnRhaW5lclwiIHRvdWNoLWFjdGlvbj1cIm5vbmVcIj4nICsgJzxkaXYgY2xhc3M9XCJjcm9wcGVyLXdyYXAtYm94XCI+JyArICc8ZGl2IGNsYXNzPVwiY3JvcHBlci1jYW52YXNcIj48L2Rpdj4nICsgJzwvZGl2PicgKyAnPGRpdiBjbGFzcz1cImNyb3BwZXItZHJhZy1ib3hcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJjcm9wcGVyLWNyb3AtYm94XCI+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItdmlldy1ib3hcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItZGFzaGVkIGRhc2hlZC1oXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLWRhc2hlZCBkYXNoZWQtdlwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1jZW50ZXJcIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItZmFjZVwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1saW5lIGxpbmUtZVwiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJlXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLWxpbmUgbGluZS1uXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIm5cIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItbGluZSBsaW5lLXdcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwid1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1saW5lIGxpbmUtc1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJzXCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LWVcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwiZVwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1uXCIgZGF0YS1jcm9wcGVyLWFjdGlvbj1cIm5cIj48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImNyb3BwZXItcG9pbnQgcG9pbnQtd1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJ3XCI+PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJjcm9wcGVyLXBvaW50IHBvaW50LXNcIiBkYXRhLWNyb3BwZXItYWN0aW9uPVwic1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1uZVwiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJuZVwiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1ud1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJud1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1zd1wiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJzd1wiPjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiY3JvcHBlci1wb2ludCBwb2ludC1zZVwiIGRhdGEtY3JvcHBlci1hY3Rpb249XCJzZVwiPjwvc3Bhbj4nICsgJzwvZGl2PicgKyAnPC9kaXY+JztcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cbiAgICovXG5cbiAgdmFyIGlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IFdJTkRPVy5pc05hTjtcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG51bWJlci5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBvc2l0aXZlIG51bWJlci5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBvc2l0aXZlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuICB2YXIgaXNQb3NpdGl2ZU51bWJlciA9IGZ1bmN0aW9uIGlzUG9zaXRpdmVOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPiAwICYmIHZhbHVlIDwgSW5maW5pdHk7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdW5kZWZpbmVkLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHVuZGVmaW5lZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG4gIH1cbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIF9jb25zdHJ1Y3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgICAgdmFyIHByb3RvdHlwZSA9IF9jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gX2NvbnN0cnVjdG9yICYmIHByb3RvdHlwZSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvdHlwZSwgJ2lzUHJvdG90eXBlT2YnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgKi9cblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIC8qKlxuICAgKiBDb252ZXJ0IGFycmF5LWxpa2Ugb3IgaXRlcmFibGUgb2JqZWN0IHRvIGFuIGFycmF5LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICovXG5cbiAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tID8gQXJyYXkuZnJvbSh2YWx1ZSkgOiBzbGljZS5jYWxsKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogSXRlcmF0ZSB0aGUgZ2l2ZW4gZGF0YS5cbiAgICogQHBhcmFtIHsqfSBkYXRhIC0gVGhlIGRhdGEgdG8gaXRlcmF0ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgcHJvY2VzcyBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7Kn0gVGhlIG9yaWdpbmFsIGRhdGEuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGZvckVhY2goZGF0YSwgY2FsbGJhY2spIHtcbiAgICBpZiAoZGF0YSAmJiBpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNOdW1iZXIoZGF0YS5sZW5ndGgpXG4gICAgICAvKiBhcnJheS1saWtlICovXG4gICAgICApIHtcbiAgICAgICAgICB0b0FycmF5KGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoZGF0YSwgdmFsdWUsIGtleSwgZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChkYXRhLCBkYXRhW2tleV0sIGtleSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBFeHRlbmQgdGhlIGdpdmVuIG9iamVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCB0byBleHRlbmQuXG4gICAqIEBwYXJhbSB7Kn0gYXJncyAtIFRoZSByZXN0IG9iamVjdHMgZm9yIG1lcmdpbmcgdG8gdGhlIHRhcmdldCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBleHRlbmRlZCBvYmplY3QuXG4gICAqL1xuXG4gIHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QodGFyZ2V0KSAmJiBhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIGlmIChpc09iamVjdChhcmcpKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gYXJnW2tleV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHZhciBSRUdFWFBfREVDSU1BTFMgPSAvXFwuXFxkKig/OjB8OSl7MTJ9XFxkKiQvO1xuICAvKipcbiAgICogTm9ybWFsaXplIGRlY2ltYWwgbnVtYmVyLlxuICAgKiBDaGVjayBvdXQge0BsaW5rIGh0dHBzOi8vMC4zMDAwMDAwMDAwMDAwMDAwNC5jb20vfVxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gbm9ybWFsaXplLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVzPTEwMDAwMDAwMDAwMF0gLSBUaGUgdGltZXMgZm9yIG5vcm1hbGl6aW5nLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBub3JtYWxpemVkIG51bWJlci5cbiAgICovXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplRGVjaW1hbE51bWJlcih2YWx1ZSkge1xuICAgIHZhciB0aW1lcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTAwMDAwMDAwMDAwO1xuICAgIHJldHVybiBSRUdFWFBfREVDSU1BTFMudGVzdCh2YWx1ZSkgPyBNYXRoLnJvdW5kKHZhbHVlICogdGltZXMpIC8gdGltZXMgOiB2YWx1ZTtcbiAgfVxuICB2YXIgUkVHRVhQX1NVRkZJWCA9IC9ed2lkdGh8aGVpZ2h0fGxlZnR8dG9wfG1hcmdpbkxlZnR8bWFyZ2luVG9wJC87XG4gIC8qKlxuICAgKiBBcHBseSBzdHlsZXMgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyAtIFRoZSBzdHlsZXMgZm9yIGFwcGx5aW5nLlxuICAgKi9cblxuICBmdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZXMpIHtcbiAgICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIGZvckVhY2goc3R5bGVzLCBmdW5jdGlvbiAodmFsdWUsIHByb3BlcnR5KSB7XG4gICAgICBpZiAoUkVHRVhQX1NVRkZJWC50ZXN0KHByb3BlcnR5KSAmJiBpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBcIlwiLmNvbmNhdCh2YWx1ZSwgXCJweFwiKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGhhcyBhIHNwZWNpYWwgY2xhc3MuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgY2xhc3MgdG8gc2VhcmNoLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpYWwgY2xhc3Mgd2FzIGZvdW5kLlxuICAgKi9cblxuICBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCB2YWx1ZSkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdCA/IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHZhbHVlKSA6IGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YodmFsdWUpID4gLTE7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjbGFzc2VzIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzc2VzIHRvIGJlIGFkZGVkLlxuICAgKi9cblxuICBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCB2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIoZWxlbWVudC5sZW5ndGgpKSB7XG4gICAgICBmb3JFYWNoKGVsZW1lbnQsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIGFkZENsYXNzKGVsZW0sIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUudHJpbSgpO1xuXG4gICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChjbGFzc05hbWUuaW5kZXhPZih2YWx1ZSkgPCAwKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KGNsYXNzTmFtZSwgXCIgXCIpLmNvbmNhdCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgY2xhc3NlcyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzc2VzIHRvIGJlIHJlbW92ZWQuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcihlbGVtZW50Lmxlbmd0aCkpIHtcbiAgICAgIGZvckVhY2goZWxlbWVudCwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKHZhbHVlKSA+PSAwKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UodmFsdWUsICcnKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBvciByZW1vdmUgY2xhc3NlcyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjbGFzc2VzIHRvIGJlIHRvZ2dsZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWRkZWQgLSBBZGQgb25seS5cbiAgICovXG5cbiAgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgdmFsdWUsIGFkZGVkKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcihlbGVtZW50Lmxlbmd0aCkpIHtcbiAgICAgIGZvckVhY2goZWxlbWVudCwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWxlbSwgdmFsdWUsIGFkZGVkKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSUUxMC0xMSBkb2Vzbid0IHN1cHBvcnQgdGhlIHNlY29uZCBwYXJhbWV0ZXIgb2YgYGNsYXNzTGlzdC50b2dnbGVgXG5cblxuICAgIGlmIChhZGRlZCkge1xuICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHZhciBSRUdFWFBfQ0FNRUxfQ0FTRSA9IC8oW2EtelxcZF0pKFtBLVpdKS9nO1xuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBnaXZlbiBzdHJpbmcgZnJvbSBjYW1lbENhc2UgdG8ga2ViYWItY2FzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHJhbnNmb3JtZWQgdmFsdWUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRvUGFyYW1DYXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoUkVHRVhQX0NBTUVMX0NBU0UsICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBkYXRhIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgZGF0YSBrZXkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGF0YSB2YWx1ZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0RGF0YShlbGVtZW50LCBuYW1lKSB7XG4gICAgaWYgKGlzT2JqZWN0KGVsZW1lbnRbbmFtZV0pKSB7XG4gICAgICByZXR1cm4gZWxlbWVudFtuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5kYXRhc2V0W25hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtXCIuY29uY2F0KHRvUGFyYW1DYXNlKG5hbWUpKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBkYXRhIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGRhdGEga2V5IHRvIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZGF0YSB2YWx1ZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gc2V0RGF0YShlbGVtZW50LCBuYW1lLCBkYXRhKSB7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBlbGVtZW50W25hbWVdID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQuZGF0YXNldCkge1xuICAgICAgZWxlbWVudC5kYXRhc2V0W25hbWVdID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiLmNvbmNhdCh0b1BhcmFtQ2FzZShuYW1lKSksIGRhdGEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGRhdGEgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBkYXRhIGtleSB0byByZW1vdmUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZURhdGEoZWxlbWVudCwgbmFtZSkge1xuICAgIGlmIChpc09iamVjdChlbGVtZW50W25hbWVdKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVsZXRlIGVsZW1lbnRbbmFtZV07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlbGVtZW50W25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgICAvLyAjMTI4IFNhZmFyaSBub3QgYWxsb3dzIHRvIGRlbGV0ZSBkYXRhc2V0IHByb3BlcnR5XG4gICAgICB0cnkge1xuICAgICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0W25hbWVdO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZWxlbWVudC5kYXRhc2V0W25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtXCIuY29uY2F0KHRvUGFyYW1DYXNlKG5hbWUpKSk7XG4gICAgfVxuICB9XG4gIHZhciBSRUdFWFBfU1BBQ0VTID0gL1xcc1xccyovO1xuXG4gIHZhciBvbmNlU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdXBwb3J0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChJU19CUk9XU0VSKSB7XG4gICAgICB2YXIgb25jZSA9IGZhbHNlO1xuXG4gICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHt9O1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ29uY2UnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIG9uY2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgc2V0dGVyIGNhbiBmaXggYSBgVHlwZUVycm9yYCBpbiBzdHJpY3QgbW9kZVxuICAgICAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRXJyb3JzL0dldHRlcl9vbmx5fVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBvbmNlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgV0lORE9XLmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICBXSU5ET1cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwcG9ydGVkO1xuICB9KCk7XG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCB0YXJnZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIGV2ZW50IHR5cGUocykuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBldmVudCBvcHRpb25zLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIHZhciBoYW5kbGVyID0gbGlzdGVuZXI7XG4gICAgdHlwZS50cmltKCkuc3BsaXQoUkVHRVhQX1NQQUNFUykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghb25jZVN1cHBvcnRlZCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gZWxlbWVudC5saXN0ZW5lcnM7XG5cbiAgICAgICAgaWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbZXZlbnRdICYmIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdKSB7XG4gICAgICAgICAgaGFuZGxlciA9IGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdO1xuICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXTtcblxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhsaXN0ZW5lcnNbZXZlbnRdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhsaXN0ZW5lcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQubGlzdGVuZXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZXZlbnQgdGFyZ2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlKHMpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBldmVudCBsaXN0ZW5lci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgZXZlbnQgb3B0aW9ucy5cbiAgICovXG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgdmFyIF9oYW5kbGVyID0gbGlzdGVuZXI7XG4gICAgdHlwZS50cmltKCkuc3BsaXQoUkVHRVhQX1NQQUNFUykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChvcHRpb25zLm9uY2UgJiYgIW9uY2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgdmFyIF9lbGVtZW50JGxpc3RlbmVycyA9IGVsZW1lbnQubGlzdGVuZXJzLFxuICAgICAgICAgICAgbGlzdGVuZXJzID0gX2VsZW1lbnQkbGlzdGVuZXJzID09PSB2b2lkIDAgPyB7fSA6IF9lbGVtZW50JGxpc3RlbmVycztcblxuICAgICAgICBfaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdO1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX2hhbmRsZXIsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXIuYXBwbHkoZWxlbWVudCwgYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFsaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyc1tldmVudF1bbGlzdGVuZXJdKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdW2xpc3RlbmVyXSA9IF9oYW5kbGVyO1xuICAgICAgICBlbGVtZW50Lmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBfaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERpc3BhdGNoIGV2ZW50IG9uIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIGV2ZW50IHRhcmdldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZShzKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgYWRkaXRpb25hbCBldmVudCBkYXRhLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSW5kaWNhdGUgaWYgdGhlIGV2ZW50IGlzIGRlZmF1bHQgcHJldmVudGVkIG9yIG5vdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChlbGVtZW50LCB0eXBlLCBkYXRhKSB7XG4gICAgdmFyIGV2ZW50OyAvLyBFdmVudCBhbmQgQ3VzdG9tRXZlbnQgb24gSUU5LTExIGFyZSBnbG9iYWwgb2JqZWN0cywgbm90IGNvbnN0cnVjdG9yc1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oRXZlbnQpICYmIGlzRnVuY3Rpb24oQ3VzdG9tRXZlbnQpKSB7XG4gICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudCh0eXBlLCB7XG4gICAgICAgIGRldGFpbDogZGF0YSxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgb2Zmc2V0IGJhc2Ugb24gdGhlIGRvY3VtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBvZmZzZXQgZGF0YS5cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsZW1lbnQpIHtcbiAgICB2YXIgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogYm94LmxlZnQgKyAod2luZG93LnBhZ2VYT2Zmc2V0IC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudExlZnQpLFxuICAgICAgdG9wOiBib3gudG9wICsgKHdpbmRvdy5wYWdlWU9mZnNldCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRUb3ApXG4gICAgfTtcbiAgfVxuICB2YXIgbG9jYXRpb24gPSBXSU5ET1cubG9jYXRpb247XG4gIHZhciBSRUdFWFBfT1JJR0lOUyA9IC9eKFxcdys6KVxcL1xcLyhbXjovPyNdKik6PyhcXGQqKS9pO1xuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIFVSTCBpcyBhIGNyb3NzIG9yaWdpbiBVUkwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdGFyZ2V0IFVSTC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBVUkwgaXMgYSBjcm9zcyBvcmlnaW4gVVJMLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGlzQ3Jvc3NPcmlnaW5VUkwodXJsKSB7XG4gICAgdmFyIHBhcnRzID0gdXJsLm1hdGNoKFJFR0VYUF9PUklHSU5TKTtcbiAgICByZXR1cm4gcGFydHMgIT09IG51bGwgJiYgKHBhcnRzWzFdICE9PSBsb2NhdGlvbi5wcm90b2NvbCB8fCBwYXJ0c1syXSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcGFydHNbM10gIT09IGxvY2F0aW9uLnBvcnQpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgdGltZXN0YW1wIHRvIHRoZSBnaXZlbiBVUkwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdGFyZ2V0IFVSTC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHJlc3VsdCBVUkwuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFkZFRpbWVzdGFtcCh1cmwpIHtcbiAgICB2YXIgdGltZXN0YW1wID0gXCJ0aW1lc3RhbXA9XCIuY29uY2F0KG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHRpbWVzdGFtcDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRyYW5zZm9ybXMgYmFzZSBvbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIHRhcmdldCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIGNvbnRhaW5zIHRyYW5zZm9ybSB2YWx1ZXMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFRyYW5zZm9ybXMoX3JlZikge1xuICAgIHZhciByb3RhdGUgPSBfcmVmLnJvdGF0ZSxcbiAgICAgICAgc2NhbGVYID0gX3JlZi5zY2FsZVgsXG4gICAgICAgIHNjYWxlWSA9IF9yZWYuc2NhbGVZLFxuICAgICAgICB0cmFuc2xhdGVYID0gX3JlZi50cmFuc2xhdGVYLFxuICAgICAgICB0cmFuc2xhdGVZID0gX3JlZi50cmFuc2xhdGVZO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGlmIChpc051bWJlcih0cmFuc2xhdGVYKSAmJiB0cmFuc2xhdGVYICE9PSAwKSB7XG4gICAgICB2YWx1ZXMucHVzaChcInRyYW5zbGF0ZVgoXCIuY29uY2F0KHRyYW5zbGF0ZVgsIFwicHgpXCIpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIodHJhbnNsYXRlWSkgJiYgdHJhbnNsYXRlWSAhPT0gMCkge1xuICAgICAgdmFsdWVzLnB1c2goXCJ0cmFuc2xhdGVZKFwiLmNvbmNhdCh0cmFuc2xhdGVZLCBcInB4KVwiKSk7XG4gICAgfSAvLyBSb3RhdGUgc2hvdWxkIGNvbWUgZmlyc3QgYmVmb3JlIHNjYWxlIHRvIG1hdGNoIG9yaWVudGF0aW9uIHRyYW5zZm9ybVxuXG5cbiAgICBpZiAoaXNOdW1iZXIocm90YXRlKSAmJiByb3RhdGUgIT09IDApIHtcbiAgICAgIHZhbHVlcy5wdXNoKFwicm90YXRlKFwiLmNvbmNhdChyb3RhdGUsIFwiZGVnKVwiKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKHNjYWxlWCkgJiYgc2NhbGVYICE9PSAxKSB7XG4gICAgICB2YWx1ZXMucHVzaChcInNjYWxlWChcIi5jb25jYXQoc2NhbGVYLCBcIilcIikpO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcihzY2FsZVkpICYmIHNjYWxlWSAhPT0gMSkge1xuICAgICAgdmFsdWVzLnB1c2goXCJzY2FsZVkoXCIuY29uY2F0KHNjYWxlWSwgXCIpXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdmFsdWVzLmxlbmd0aCA/IHZhbHVlcy5qb2luKCcgJykgOiAnbm9uZSc7XG4gICAgcmV0dXJuIHtcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgbXNUcmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtYXggcmF0aW8gb2YgYSBncm91cCBvZiBwb2ludGVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvaW50ZXJzIC0gVGhlIHRhcmdldCBwb2ludGVycy5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJlc3VsdCByYXRpby5cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0TWF4Wm9vbVJhdGlvKHBvaW50ZXJzKSB7XG4gICAgdmFyIHBvaW50ZXJzMiA9IF9vYmplY3RTcHJlYWQyKHt9LCBwb2ludGVycyk7XG5cbiAgICB2YXIgcmF0aW9zID0gW107XG4gICAgZm9yRWFjaChwb2ludGVycywgZnVuY3Rpb24gKHBvaW50ZXIsIHBvaW50ZXJJZCkge1xuICAgICAgZGVsZXRlIHBvaW50ZXJzMltwb2ludGVySWRdO1xuICAgICAgZm9yRWFjaChwb2ludGVyczIsIGZ1bmN0aW9uIChwb2ludGVyMikge1xuICAgICAgICB2YXIgeDEgPSBNYXRoLmFicyhwb2ludGVyLnN0YXJ0WCAtIHBvaW50ZXIyLnN0YXJ0WCk7XG4gICAgICAgIHZhciB5MSA9IE1hdGguYWJzKHBvaW50ZXIuc3RhcnRZIC0gcG9pbnRlcjIuc3RhcnRZKTtcbiAgICAgICAgdmFyIHgyID0gTWF0aC5hYnMocG9pbnRlci5lbmRYIC0gcG9pbnRlcjIuZW5kWCk7XG4gICAgICAgIHZhciB5MiA9IE1hdGguYWJzKHBvaW50ZXIuZW5kWSAtIHBvaW50ZXIyLmVuZFkpO1xuICAgICAgICB2YXIgejEgPSBNYXRoLnNxcnQoeDEgKiB4MSArIHkxICogeTEpO1xuICAgICAgICB2YXIgejIgPSBNYXRoLnNxcnQoeDIgKiB4MiArIHkyICogeTIpO1xuICAgICAgICB2YXIgcmF0aW8gPSAoejIgLSB6MSkgLyB6MTtcbiAgICAgICAgcmF0aW9zLnB1c2gocmF0aW8pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmF0aW9zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyhhKSA8IE1hdGguYWJzKGIpO1xuICAgIH0pO1xuICAgIHJldHVybiByYXRpb3NbMF07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHBvaW50ZXIgZnJvbSBhbiBldmVudCBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSB0YXJnZXQgZXZlbnQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuZE9ubHkgLSBJbmRpY2F0ZXMgaWYgb25seSByZXR1cm5zIHRoZSBlbmQgcG9pbnQgY29vcmRpbmF0ZSBvciBub3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgcG9pbnRlciBjb250YWlucyBzdGFydCBhbmQvb3IgZW5kIHBvaW50IGNvb3JkaW5hdGVzLlxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRQb2ludGVyKF9yZWYyLCBlbmRPbmx5KSB7XG4gICAgdmFyIHBhZ2VYID0gX3JlZjIucGFnZVgsXG4gICAgICAgIHBhZ2VZID0gX3JlZjIucGFnZVk7XG4gICAgdmFyIGVuZCA9IHtcbiAgICAgIGVuZFg6IHBhZ2VYLFxuICAgICAgZW5kWTogcGFnZVlcbiAgICB9O1xuICAgIHJldHVybiBlbmRPbmx5ID8gZW5kIDogX29iamVjdFNwcmVhZDIoe1xuICAgICAgc3RhcnRYOiBwYWdlWCxcbiAgICAgIHN0YXJ0WTogcGFnZVlcbiAgICB9LCBlbmQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNlbnRlciBwb2ludCBjb29yZGluYXRlIG9mIGEgZ3JvdXAgb2YgcG9pbnRlcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVycyAtIFRoZSB0YXJnZXQgcG9pbnRlcnMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjZW50ZXIgcG9pbnQgY29vcmRpbmF0ZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0UG9pbnRlcnNDZW50ZXIocG9pbnRlcnMpIHtcbiAgICB2YXIgcGFnZVggPSAwO1xuICAgIHZhciBwYWdlWSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3JFYWNoKHBvaW50ZXJzLCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciBzdGFydFggPSBfcmVmMy5zdGFydFgsXG4gICAgICAgICAgc3RhcnRZID0gX3JlZjMuc3RhcnRZO1xuICAgICAgcGFnZVggKz0gc3RhcnRYO1xuICAgICAgcGFnZVkgKz0gc3RhcnRZO1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9KTtcbiAgICBwYWdlWCAvPSBjb3VudDtcbiAgICBwYWdlWSAvPSBjb3VudDtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZVg6IHBhZ2VYLFxuICAgICAgcGFnZVk6IHBhZ2VZXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtYXggc2l6ZXMgaW4gYSByZWN0YW5nbGUgdW5kZXIgdGhlIGdpdmVuIGFzcGVjdCByYXRpby5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgb3JpZ2luYWwgc2l6ZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT0nY29udGFpbiddIC0gVGhlIGFkanVzdCB0eXBlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IHNpemVzLlxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRBZGp1c3RlZFNpemVzKF9yZWY0KSAvLyBvciAnY292ZXInXG4gIHtcbiAgICB2YXIgYXNwZWN0UmF0aW8gPSBfcmVmNC5hc3BlY3RSYXRpbyxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjQuaGVpZ2h0LFxuICAgICAgICB3aWR0aCA9IF9yZWY0LndpZHRoO1xuICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnY29udGFpbic7XG4gICAgdmFyIGlzVmFsaWRXaWR0aCA9IGlzUG9zaXRpdmVOdW1iZXIod2lkdGgpO1xuICAgIHZhciBpc1ZhbGlkSGVpZ2h0ID0gaXNQb3NpdGl2ZU51bWJlcihoZWlnaHQpO1xuXG4gICAgaWYgKGlzVmFsaWRXaWR0aCAmJiBpc1ZhbGlkSGVpZ2h0KSB7XG4gICAgICB2YXIgYWRqdXN0ZWRXaWR0aCA9IGhlaWdodCAqIGFzcGVjdFJhdGlvO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2NvbnRhaW4nICYmIGFkanVzdGVkV2lkdGggPiB3aWR0aCB8fCB0eXBlID09PSAnY292ZXInICYmIGFkanVzdGVkV2lkdGggPCB3aWR0aCkge1xuICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRXaWR0aCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRIZWlnaHQpIHtcbiAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBuZXcgc2l6ZXMgb2YgYSByZWN0YW5nbGUgYWZ0ZXIgcm90YXRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgb3JpZ2luYWwgc2l6ZXMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgc2l6ZXMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFJvdGF0ZWRTaXplcyhfcmVmNSkge1xuICAgIHZhciB3aWR0aCA9IF9yZWY1LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfcmVmNS5oZWlnaHQsXG4gICAgICAgIGRlZ3JlZSA9IF9yZWY1LmRlZ3JlZTtcbiAgICBkZWdyZWUgPSBNYXRoLmFicyhkZWdyZWUpICUgMTgwO1xuXG4gICAgaWYgKGRlZ3JlZSA9PT0gOTApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBoZWlnaHQsXG4gICAgICAgIGhlaWdodDogd2lkdGhcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFyYyA9IGRlZ3JlZSAlIDkwICogTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgc2luQXJjID0gTWF0aC5zaW4oYXJjKTtcbiAgICB2YXIgY29zQXJjID0gTWF0aC5jb3MoYXJjKTtcbiAgICB2YXIgbmV3V2lkdGggPSB3aWR0aCAqIGNvc0FyYyArIGhlaWdodCAqIHNpbkFyYztcbiAgICB2YXIgbmV3SGVpZ2h0ID0gd2lkdGggKiBzaW5BcmMgKyBoZWlnaHQgKiBjb3NBcmM7XG4gICAgcmV0dXJuIGRlZ3JlZSA+IDkwID8ge1xuICAgICAgd2lkdGg6IG5ld0hlaWdodCxcbiAgICAgIGhlaWdodDogbmV3V2lkdGhcbiAgICB9IDoge1xuICAgICAgd2lkdGg6IG5ld1dpZHRoLFxuICAgICAgaGVpZ2h0OiBuZXdIZWlnaHRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBjYW52YXMgd2hpY2ggZHJldyB0aGUgZ2l2ZW4gaW1hZ2UuXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1hZ2UgLSBUaGUgaW1hZ2UgZm9yIGRyYXdpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGEgLSBUaGUgaW1hZ2UgZGF0YS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0RhdGEgLSBUaGUgY2FudmFzIGRhdGEuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIHJlc3VsdCBjYW52YXMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFNvdXJjZUNhbnZhcyhpbWFnZSwgX3JlZjYsIF9yZWY3LCBfcmVmOCkge1xuICAgIHZhciBpbWFnZUFzcGVjdFJhdGlvID0gX3JlZjYuYXNwZWN0UmF0aW8sXG4gICAgICAgIGltYWdlTmF0dXJhbFdpZHRoID0gX3JlZjYubmF0dXJhbFdpZHRoLFxuICAgICAgICBpbWFnZU5hdHVyYWxIZWlnaHQgPSBfcmVmNi5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICBfcmVmNiRyb3RhdGUgPSBfcmVmNi5yb3RhdGUsXG4gICAgICAgIHJvdGF0ZSA9IF9yZWY2JHJvdGF0ZSA9PT0gdm9pZCAwID8gMCA6IF9yZWY2JHJvdGF0ZSxcbiAgICAgICAgX3JlZjYkc2NhbGVYID0gX3JlZjYuc2NhbGVYLFxuICAgICAgICBzY2FsZVggPSBfcmVmNiRzY2FsZVggPT09IHZvaWQgMCA/IDEgOiBfcmVmNiRzY2FsZVgsXG4gICAgICAgIF9yZWY2JHNjYWxlWSA9IF9yZWY2LnNjYWxlWSxcbiAgICAgICAgc2NhbGVZID0gX3JlZjYkc2NhbGVZID09PSB2b2lkIDAgPyAxIDogX3JlZjYkc2NhbGVZO1xuICAgIHZhciBhc3BlY3RSYXRpbyA9IF9yZWY3LmFzcGVjdFJhdGlvLFxuICAgICAgICBuYXR1cmFsV2lkdGggPSBfcmVmNy5uYXR1cmFsV2lkdGgsXG4gICAgICAgIG5hdHVyYWxIZWlnaHQgPSBfcmVmNy5uYXR1cmFsSGVpZ2h0O1xuICAgIHZhciBfcmVmOCRmaWxsQ29sb3IgPSBfcmVmOC5maWxsQ29sb3IsXG4gICAgICAgIGZpbGxDb2xvciA9IF9yZWY4JGZpbGxDb2xvciA9PT0gdm9pZCAwID8gJ3RyYW5zcGFyZW50JyA6IF9yZWY4JGZpbGxDb2xvcixcbiAgICAgICAgX3JlZjgkaW1hZ2VTbW9vdGhpbmdFID0gX3JlZjguaW1hZ2VTbW9vdGhpbmdFbmFibGVkLFxuICAgICAgICBpbWFnZVNtb290aGluZ0VuYWJsZWQgPSBfcmVmOCRpbWFnZVNtb290aGluZ0UgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmOCRpbWFnZVNtb290aGluZ0UsXG4gICAgICAgIF9yZWY4JGltYWdlU21vb3RoaW5nUSA9IF9yZWY4LmltYWdlU21vb3RoaW5nUXVhbGl0eSxcbiAgICAgICAgaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gX3JlZjgkaW1hZ2VTbW9vdGhpbmdRID09PSB2b2lkIDAgPyAnbG93JyA6IF9yZWY4JGltYWdlU21vb3RoaW5nUSxcbiAgICAgICAgX3JlZjgkbWF4V2lkdGggPSBfcmVmOC5tYXhXaWR0aCxcbiAgICAgICAgbWF4V2lkdGggPSBfcmVmOCRtYXhXaWR0aCA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfcmVmOCRtYXhXaWR0aCxcbiAgICAgICAgX3JlZjgkbWF4SGVpZ2h0ID0gX3JlZjgubWF4SGVpZ2h0LFxuICAgICAgICBtYXhIZWlnaHQgPSBfcmVmOCRtYXhIZWlnaHQgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX3JlZjgkbWF4SGVpZ2h0LFxuICAgICAgICBfcmVmOCRtaW5XaWR0aCA9IF9yZWY4Lm1pbldpZHRoLFxuICAgICAgICBtaW5XaWR0aCA9IF9yZWY4JG1pbldpZHRoID09PSB2b2lkIDAgPyAwIDogX3JlZjgkbWluV2lkdGgsXG4gICAgICAgIF9yZWY4JG1pbkhlaWdodCA9IF9yZWY4Lm1pbkhlaWdodCxcbiAgICAgICAgbWluSGVpZ2h0ID0gX3JlZjgkbWluSGVpZ2h0ID09PSB2b2lkIDAgPyAwIDogX3JlZjgkbWluSGVpZ2h0O1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBtYXhTaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxuICAgICAgd2lkdGg6IG1heFdpZHRoLFxuICAgICAgaGVpZ2h0OiBtYXhIZWlnaHRcbiAgICB9KTtcbiAgICB2YXIgbWluU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcbiAgICAgIHdpZHRoOiBtaW5XaWR0aCxcbiAgICAgIGhlaWdodDogbWluSGVpZ2h0XG4gICAgfSwgJ2NvdmVyJyk7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5taW4obWF4U2l6ZXMud2lkdGgsIE1hdGgubWF4KG1pblNpemVzLndpZHRoLCBuYXR1cmFsV2lkdGgpKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5taW4obWF4U2l6ZXMuaGVpZ2h0LCBNYXRoLm1heChtaW5TaXplcy5oZWlnaHQsIG5hdHVyYWxIZWlnaHQpKTsgLy8gTm90ZTogc2hvdWxkIGFsd2F5cyB1c2UgaW1hZ2UncyBuYXR1cmFsIHNpemVzIGZvciBkcmF3aW5nIGFzXG4gICAgLy8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCA9PT0gY2FudmFzRGF0YS5uYXR1cmFsSGVpZ2h0IHdoZW4gcm90YXRlICUgMTgwID09PSA5MFxuXG4gICAgdmFyIGRlc3RNYXhTaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgYXNwZWN0UmF0aW86IGltYWdlQXNwZWN0UmF0aW8sXG4gICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICBoZWlnaHQ6IG1heEhlaWdodFxuICAgIH0pO1xuICAgIHZhciBkZXN0TWluU2l6ZXMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICAgIGFzcGVjdFJhdGlvOiBpbWFnZUFzcGVjdFJhdGlvLFxuICAgICAgd2lkdGg6IG1pbldpZHRoLFxuICAgICAgaGVpZ2h0OiBtaW5IZWlnaHRcbiAgICB9LCAnY292ZXInKTtcbiAgICB2YXIgZGVzdFdpZHRoID0gTWF0aC5taW4oZGVzdE1heFNpemVzLndpZHRoLCBNYXRoLm1heChkZXN0TWluU2l6ZXMud2lkdGgsIGltYWdlTmF0dXJhbFdpZHRoKSk7XG4gICAgdmFyIGRlc3RIZWlnaHQgPSBNYXRoLm1pbihkZXN0TWF4U2l6ZXMuaGVpZ2h0LCBNYXRoLm1heChkZXN0TWluU2l6ZXMuaGVpZ2h0LCBpbWFnZU5hdHVyYWxIZWlnaHQpKTtcbiAgICB2YXIgcGFyYW1zID0gWy1kZXN0V2lkdGggLyAyLCAtZGVzdEhlaWdodCAvIDIsIGRlc3RXaWR0aCwgZGVzdEhlaWdodF07XG4gICAgY2FudmFzLndpZHRoID0gbm9ybWFsaXplRGVjaW1hbE51bWJlcih3aWR0aCk7XG4gICAgY2FudmFzLmhlaWdodCA9IG5vcm1hbGl6ZURlY2ltYWxOdW1iZXIoaGVpZ2h0KTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxDb2xvcjtcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgY29udGV4dC5yb3RhdGUocm90YXRlICogTWF0aC5QSSAvIDE4MCk7XG4gICAgY29udGV4dC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBpbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgY29udGV4dC5pbWFnZVNtb290aGluZ1F1YWxpdHkgPSBpbWFnZVNtb290aGluZ1F1YWxpdHk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UuYXBwbHkoY29udGV4dCwgW2ltYWdlXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihub3JtYWxpemVEZWNpbWFsTnVtYmVyKHBhcmFtKSk7XG4gICAgfSkpKSk7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgLyoqXG4gICAqIEdldCBzdHJpbmcgZnJvbSBjaGFyIGNvZGUgaW4gZGF0YSB2aWV3LlxuICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlldyAtIFRoZSBkYXRhIHZpZXcgZm9yIHJlYWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFRoZSBzdGFydCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCAtIFRoZSByZWFkIGxlbmd0aC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHJlYWQgcmVzdWx0LlxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRTdHJpbmdGcm9tQ2hhckNvZGUoZGF0YVZpZXcsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgbGVuZ3RoICs9IHN0YXJ0O1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHN0ciArPSBmcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyIFJFR0VYUF9EQVRBX1VSTF9IRUFEID0gL15kYXRhOi4qLC87XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gRGF0YSBVUkwgdG8gYXJyYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVSTCAtIFRoZSBEYXRhIFVSTCB0byB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gVGhlIHJlc3VsdCBhcnJheSBidWZmZXIuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGRhdGFVUkxUb0FycmF5QnVmZmVyKGRhdGFVUkwpIHtcbiAgICB2YXIgYmFzZTY0ID0gZGF0YVVSTC5yZXBsYWNlKFJFR0VYUF9EQVRBX1VSTF9IRUFELCAnJyk7XG4gICAgdmFyIGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcbiAgICB2YXIgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYmluYXJ5Lmxlbmd0aCk7XG4gICAgdmFyIHVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgIGZvckVhY2godWludDgsIGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgdWludDhbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXlCdWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBhcnJheSBidWZmZXIgdG8gRGF0YSBVUkwuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIC0gVGhlIGFycmF5IGJ1ZmZlciB0byB0cmFuc2Zvcm0uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lVHlwZSAtIFRoZSBtaW1lIHR5cGUgb2YgdGhlIERhdGEgVVJMLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcmVzdWx0IERhdGEgVVJMLlxuICAgKi9cblxuICBmdW5jdGlvbiBhcnJheUJ1ZmZlclRvRGF0YVVSTChhcnJheUJ1ZmZlciwgbWltZVR5cGUpIHtcbiAgICB2YXIgY2h1bmtzID0gW107IC8vIENodW5rIFR5cGVkIEFycmF5IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UgKCM0MzUpXG5cbiAgICB2YXIgY2h1bmtTaXplID0gODE5MjtcbiAgICB2YXIgdWludDggPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG5cbiAgICB3aGlsZSAodWludDgubGVuZ3RoID4gMCkge1xuICAgICAgLy8gWFhYOiBCYWJlbCdzIGB0b0NvbnN1bWFibGVBcnJheWAgaGVscGVyIHdpbGwgdGhyb3cgZXJyb3IgaW4gSUUgb3IgU2FmYXJpIDlcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgICBjaHVua3MucHVzaChmcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdG9BcnJheSh1aW50OC5zdWJhcnJheSgwLCBjaHVua1NpemUpKSkpO1xuICAgICAgdWludDggPSB1aW50OC5zdWJhcnJheShjaHVua1NpemUpO1xuICAgIH1cblxuICAgIHJldHVybiBcImRhdGE6XCIuY29uY2F0KG1pbWVUeXBlLCBcIjtiYXNlNjQsXCIpLmNvbmNhdChidG9hKGNodW5rcy5qb2luKCcnKSkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgb3JpZW50YXRpb24gdmFsdWUgZnJvbSBnaXZlbiBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIC0gVGhlIGFycmF5IGJ1ZmZlciB0byByZWFkLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVhZCBvcmllbnRhdGlvbiB2YWx1ZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVzZXRBbmRHZXRPcmllbnRhdGlvbihhcnJheUJ1ZmZlcikge1xuICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgdmFyIG9yaWVudGF0aW9uOyAvLyBJZ25vcmVzIHJhbmdlIGVycm9yIHdoZW4gdGhlIGltYWdlIGRvZXMgbm90IGhhdmUgY29ycmVjdCBFeGlmIGluZm9ybWF0aW9uXG5cbiAgICB0cnkge1xuICAgICAgdmFyIGxpdHRsZUVuZGlhbjtcbiAgICAgIHZhciBhcHAxU3RhcnQ7XG4gICAgICB2YXIgaWZkU3RhcnQ7IC8vIE9ubHkgaGFuZGxlIEpQRUcgaW1hZ2UgKHN0YXJ0IGJ5IDB4RkZEOClcblxuICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KDApID09PSAweEZGICYmIGRhdGFWaWV3LmdldFVpbnQ4KDEpID09PSAweEQ4KSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBkYXRhVmlldy5ieXRlTGVuZ3RoO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMjtcblxuICAgICAgICB3aGlsZSAob2Zmc2V0ICsgMSA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpID09PSAweEZGICYmIGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDEpID09PSAweEUxKSB7XG4gICAgICAgICAgICBhcHAxU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXBwMVN0YXJ0KSB7XG4gICAgICAgIHZhciBleGlmSURDb2RlID0gYXBwMVN0YXJ0ICsgNDtcbiAgICAgICAgdmFyIHRpZmZPZmZzZXQgPSBhcHAxU3RhcnQgKyAxMDtcblxuICAgICAgICBpZiAoZ2V0U3RyaW5nRnJvbUNoYXJDb2RlKGRhdGFWaWV3LCBleGlmSURDb2RlLCA0KSA9PT0gJ0V4aWYnKSB7XG4gICAgICAgICAgdmFyIGVuZGlhbm5lc3MgPSBkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCk7XG4gICAgICAgICAgbGl0dGxlRW5kaWFuID0gZW5kaWFubmVzcyA9PT0gMHg0OTQ5O1xuXG4gICAgICAgICAgaWYgKGxpdHRsZUVuZGlhbiB8fCBlbmRpYW5uZXNzID09PSAweDRENERcbiAgICAgICAgICAvKiBiaWdFbmRpYW4gKi9cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgbGl0dGxlRW5kaWFuKSA9PT0gMHgwMDJBKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0SUZET2Zmc2V0ID0gZGF0YVZpZXcuZ2V0VWludDMyKHRpZmZPZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0SUZET2Zmc2V0ID49IDB4MDAwMDAwMDgpIHtcbiAgICAgICAgICAgICAgICAgIGlmZFN0YXJ0ID0gdGlmZk9mZnNldCArIGZpcnN0SUZET2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpZmRTdGFydCkge1xuICAgICAgICB2YXIgX2xlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNihpZmRTdGFydCwgbGl0dGxlRW5kaWFuKTtcblxuICAgICAgICB2YXIgX29mZnNldDtcblxuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX2xlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgX29mZnNldCA9IGlmZFN0YXJ0ICsgaSAqIDEyICsgMjtcblxuICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYoX29mZnNldCwgbGl0dGxlRW5kaWFuKSA9PT0gMHgwMTEyXG4gICAgICAgICAgLyogT3JpZW50YXRpb24gKi9cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gOCBpcyB0aGUgb2Zmc2V0IG9mIHRoZSBjdXJyZW50IHRhZydzIHZhbHVlXG4gICAgICAgICAgICAgIF9vZmZzZXQgKz0gODsgLy8gR2V0IHRoZSBvcmlnaW5hbCBvcmllbnRhdGlvbiB2YWx1ZVxuXG4gICAgICAgICAgICAgIG9yaWVudGF0aW9uID0gZGF0YVZpZXcuZ2V0VWludDE2KF9vZmZzZXQsIGxpdHRsZUVuZGlhbik7IC8vIE92ZXJyaWRlIHRoZSBvcmllbnRhdGlvbiB3aXRoIGl0cyBkZWZhdWx0IHZhbHVlXG5cbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KF9vZmZzZXQsIDEsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9yaWVudGF0aW9uID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZW50YXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIEV4aWYgT3JpZW50YXRpb24gdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmllbnRhdGlvbiAtIFRoZSBvcmllbnRhdGlvbiB0byBwYXJzZS5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHBhcnNlZCByZXN1bHQuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBhcnNlT3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcbiAgICB2YXIgcm90YXRlID0gMDtcbiAgICB2YXIgc2NhbGVYID0gMTtcbiAgICB2YXIgc2NhbGVZID0gMTtcblxuICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgIC8vIEZsaXAgaG9yaXpvbnRhbFxuICAgICAgY2FzZSAyOlxuICAgICAgICBzY2FsZVggPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBSb3RhdGUgbGVmdCAxODDCsFxuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJvdGF0ZSA9IC0xODA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRmxpcCB2ZXJ0aWNhbFxuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHNjYWxlWSA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIEZsaXAgdmVydGljYWwgYW5kIHJvdGF0ZSByaWdodCA5MMKwXG5cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcm90YXRlID0gOTA7XG4gICAgICAgIHNjYWxlWSA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFJvdGF0ZSByaWdodCA5MMKwXG5cbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcm90YXRlID0gOTA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRmxpcCBob3Jpem9udGFsIGFuZCByb3RhdGUgcmlnaHQgOTDCsFxuXG4gICAgICBjYXNlIDc6XG4gICAgICAgIHJvdGF0ZSA9IDkwO1xuICAgICAgICBzY2FsZVggPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBSb3RhdGUgbGVmdCA5MMKwXG5cbiAgICAgIGNhc2UgODpcbiAgICAgICAgcm90YXRlID0gLTkwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRlOiByb3RhdGUsXG4gICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgIHNjYWxlWTogc2NhbGVZXG4gICAgfTtcbiAgfVxuXG4gIHZhciByZW5kZXIgPSB7XG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLmluaXRDb250YWluZXIoKTtcbiAgICAgIHRoaXMuaW5pdENhbnZhcygpO1xuICAgICAgdGhpcy5pbml0Q3JvcEJveCgpO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoKTtcblxuICAgICAgaWYgKHRoaXMuY3JvcHBlZCkge1xuICAgICAgICB0aGlzLnJlbmRlckNyb3BCb3goKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluaXRDb250YWluZXI6IGZ1bmN0aW9uIGluaXRDb250YWluZXIoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgIGNyb3BwZXIgPSB0aGlzLmNyb3BwZXI7XG4gICAgICBhZGRDbGFzcyhjcm9wcGVyLCBDTEFTU19ISURERU4pO1xuICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgQ0xBU1NfSElEREVOKTtcbiAgICAgIHZhciBjb250YWluZXJEYXRhID0ge1xuICAgICAgICB3aWR0aDogTWF0aC5tYXgoY29udGFpbmVyLm9mZnNldFdpZHRoLCBOdW1iZXIob3B0aW9ucy5taW5Db250YWluZXJXaWR0aCkgfHwgMjAwKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChjb250YWluZXIub2Zmc2V0SGVpZ2h0LCBOdW1iZXIob3B0aW9ucy5taW5Db250YWluZXJIZWlnaHQpIHx8IDEwMClcbiAgICAgIH07XG4gICAgICB0aGlzLmNvbnRhaW5lckRhdGEgPSBjb250YWluZXJEYXRhO1xuICAgICAgc2V0U3R5bGUoY3JvcHBlciwge1xuICAgICAgICB3aWR0aDogY29udGFpbmVyRGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjb250YWluZXJEYXRhLmhlaWdodFxuICAgICAgfSk7XG4gICAgICBhZGRDbGFzcyhlbGVtZW50LCBDTEFTU19ISURERU4pO1xuICAgICAgcmVtb3ZlQ2xhc3MoY3JvcHBlciwgQ0xBU1NfSElEREVOKTtcbiAgICB9LFxuICAgIC8vIENhbnZhcyAoaW1hZ2Ugd3JhcHBlcilcbiAgICBpbml0Q2FudmFzOiBmdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgICAgdmFyIGNvbnRhaW5lckRhdGEgPSB0aGlzLmNvbnRhaW5lckRhdGEsXG4gICAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG4gICAgICB2YXIgdmlld01vZGUgPSB0aGlzLm9wdGlvbnMudmlld01vZGU7XG4gICAgICB2YXIgcm90YXRlZCA9IE1hdGguYWJzKGltYWdlRGF0YS5yb3RhdGUpICUgMTgwID09PSA5MDtcbiAgICAgIHZhciBuYXR1cmFsV2lkdGggPSByb3RhdGVkID8gaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQgOiBpbWFnZURhdGEubmF0dXJhbFdpZHRoO1xuICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSByb3RhdGVkID8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aCA6IGltYWdlRGF0YS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gbmF0dXJhbFdpZHRoIC8gbmF0dXJhbEhlaWdodDtcbiAgICAgIHZhciBjYW52YXNXaWR0aCA9IGNvbnRhaW5lckRhdGEud2lkdGg7XG4gICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gY29udGFpbmVyRGF0YS5oZWlnaHQ7XG5cbiAgICAgIGlmIChjb250YWluZXJEYXRhLmhlaWdodCAqIGFzcGVjdFJhdGlvID4gY29udGFpbmVyRGF0YS53aWR0aCkge1xuICAgICAgICBpZiAodmlld01vZGUgPT09IDMpIHtcbiAgICAgICAgICBjYW52YXNXaWR0aCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FudmFzSGVpZ2h0ID0gY29udGFpbmVyRGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZpZXdNb2RlID09PSAzKSB7XG4gICAgICAgIGNhbnZhc0hlaWdodCA9IGNvbnRhaW5lckRhdGEud2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhc1dpZHRoID0gY29udGFpbmVyRGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbnZhc0RhdGEgPSB7XG4gICAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcbiAgICAgICAgbmF0dXJhbFdpZHRoOiBuYXR1cmFsV2lkdGgsXG4gICAgICAgIG5hdHVyYWxIZWlnaHQ6IG5hdHVyYWxIZWlnaHQsXG4gICAgICAgIHdpZHRoOiBjYW52YXNXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXNIZWlnaHRcbiAgICAgIH07XG4gICAgICBjYW52YXNEYXRhLmxlZnQgPSAoY29udGFpbmVyRGF0YS53aWR0aCAtIGNhbnZhc1dpZHRoKSAvIDI7XG4gICAgICBjYW52YXNEYXRhLnRvcCA9IChjb250YWluZXJEYXRhLmhlaWdodCAtIGNhbnZhc0hlaWdodCkgLyAyO1xuICAgICAgY2FudmFzRGF0YS5vbGRMZWZ0ID0gY2FudmFzRGF0YS5sZWZ0O1xuICAgICAgY2FudmFzRGF0YS5vbGRUb3AgPSBjYW52YXNEYXRhLnRvcDtcbiAgICAgIHRoaXMuY2FudmFzRGF0YSA9IGNhbnZhc0RhdGE7XG4gICAgICB0aGlzLmxpbWl0ZWQgPSB2aWV3TW9kZSA9PT0gMSB8fCB2aWV3TW9kZSA9PT0gMjtcbiAgICAgIHRoaXMubGltaXRDYW52YXModHJ1ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmluaXRpYWxJbWFnZURhdGEgPSBhc3NpZ24oe30sIGltYWdlRGF0YSk7XG4gICAgICB0aGlzLmluaXRpYWxDYW52YXNEYXRhID0gYXNzaWduKHt9LCBjYW52YXNEYXRhKTtcbiAgICB9LFxuICAgIGxpbWl0Q2FudmFzOiBmdW5jdGlvbiBsaW1pdENhbnZhcyhzaXplTGltaXRlZCwgcG9zaXRpb25MaW1pdGVkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhLFxuICAgICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXG4gICAgICAgICAgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhO1xuICAgICAgdmFyIHZpZXdNb2RlID0gb3B0aW9ucy52aWV3TW9kZTtcbiAgICAgIHZhciBhc3BlY3RSYXRpbyA9IGNhbnZhc0RhdGEuYXNwZWN0UmF0aW87XG4gICAgICB2YXIgY3JvcHBlZCA9IHRoaXMuY3JvcHBlZCAmJiBjcm9wQm94RGF0YTtcblxuICAgICAgaWYgKHNpemVMaW1pdGVkKSB7XG4gICAgICAgIHZhciBtaW5DYW52YXNXaWR0aCA9IE51bWJlcihvcHRpb25zLm1pbkNhbnZhc1dpZHRoKSB8fCAwO1xuICAgICAgICB2YXIgbWluQ2FudmFzSGVpZ2h0ID0gTnVtYmVyKG9wdGlvbnMubWluQ2FudmFzSGVpZ2h0KSB8fCAwO1xuXG4gICAgICAgIGlmICh2aWV3TW9kZSA+IDEpIHtcbiAgICAgICAgICBtaW5DYW52YXNXaWR0aCA9IE1hdGgubWF4KG1pbkNhbnZhc1dpZHRoLCBjb250YWluZXJEYXRhLndpZHRoKTtcbiAgICAgICAgICBtaW5DYW52YXNIZWlnaHQgPSBNYXRoLm1heChtaW5DYW52YXNIZWlnaHQsIGNvbnRhaW5lckRhdGEuaGVpZ2h0KTtcblxuICAgICAgICAgIGlmICh2aWV3TW9kZSA9PT0gMykge1xuICAgICAgICAgICAgaWYgKG1pbkNhbnZhc0hlaWdodCAqIGFzcGVjdFJhdGlvID4gbWluQ2FudmFzV2lkdGgpIHtcbiAgICAgICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBtaW5DYW52YXNIZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IG1pbkNhbnZhc1dpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZpZXdNb2RlID4gMCkge1xuICAgICAgICAgIGlmIChtaW5DYW52YXNXaWR0aCkge1xuICAgICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBNYXRoLm1heChtaW5DYW52YXNXaWR0aCwgY3JvcHBlZCA/IGNyb3BCb3hEYXRhLndpZHRoIDogMCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtaW5DYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IE1hdGgubWF4KG1pbkNhbnZhc0hlaWdodCwgY3JvcHBlZCA/IGNyb3BCb3hEYXRhLmhlaWdodCA6IDApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3JvcHBlZCkge1xuICAgICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBjcm9wQm94RGF0YS53aWR0aDtcbiAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IGNyb3BCb3hEYXRhLmhlaWdodDtcblxuICAgICAgICAgICAgaWYgKG1pbkNhbnZhc0hlaWdodCAqIGFzcGVjdFJhdGlvID4gbWluQ2FudmFzV2lkdGgpIHtcbiAgICAgICAgICAgICAgbWluQ2FudmFzV2lkdGggPSBtaW5DYW52YXNIZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1pbkNhbnZhc0hlaWdodCA9IG1pbkNhbnZhc1dpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9nZXRBZGp1c3RlZFNpemVzID0gZ2V0QWRqdXN0ZWRTaXplcyh7XG4gICAgICAgICAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxuICAgICAgICAgIHdpZHRoOiBtaW5DYW52YXNXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IG1pbkNhbnZhc0hlaWdodFxuICAgICAgICB9KTtcblxuICAgICAgICBtaW5DYW52YXNXaWR0aCA9IF9nZXRBZGp1c3RlZFNpemVzLndpZHRoO1xuICAgICAgICBtaW5DYW52YXNIZWlnaHQgPSBfZ2V0QWRqdXN0ZWRTaXplcy5oZWlnaHQ7XG4gICAgICAgIGNhbnZhc0RhdGEubWluV2lkdGggPSBtaW5DYW52YXNXaWR0aDtcbiAgICAgICAgY2FudmFzRGF0YS5taW5IZWlnaHQgPSBtaW5DYW52YXNIZWlnaHQ7XG4gICAgICAgIGNhbnZhc0RhdGEubWF4V2lkdGggPSBJbmZpbml0eTtcbiAgICAgICAgY2FudmFzRGF0YS5tYXhIZWlnaHQgPSBJbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc2l0aW9uTGltaXRlZCkge1xuICAgICAgICBpZiAodmlld01vZGUgPiAoY3JvcHBlZCA/IDAgOiAxKSkge1xuICAgICAgICAgIHZhciBuZXdDYW52YXNMZWZ0ID0gY29udGFpbmVyRGF0YS53aWR0aCAtIGNhbnZhc0RhdGEud2lkdGg7XG4gICAgICAgICAgdmFyIG5ld0NhbnZhc1RvcCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0IC0gY2FudmFzRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgY2FudmFzRGF0YS5taW5MZWZ0ID0gTWF0aC5taW4oMCwgbmV3Q2FudmFzTGVmdCk7XG4gICAgICAgICAgY2FudmFzRGF0YS5taW5Ub3AgPSBNYXRoLm1pbigwLCBuZXdDYW52YXNUb3ApO1xuICAgICAgICAgIGNhbnZhc0RhdGEubWF4TGVmdCA9IE1hdGgubWF4KDAsIG5ld0NhbnZhc0xlZnQpO1xuICAgICAgICAgIGNhbnZhc0RhdGEubWF4VG9wID0gTWF0aC5tYXgoMCwgbmV3Q2FudmFzVG9wKTtcblxuICAgICAgICAgIGlmIChjcm9wcGVkICYmIHRoaXMubGltaXRlZCkge1xuICAgICAgICAgICAgY2FudmFzRGF0YS5taW5MZWZ0ID0gTWF0aC5taW4oY3JvcEJveERhdGEubGVmdCwgY3JvcEJveERhdGEubGVmdCArIChjcm9wQm94RGF0YS53aWR0aCAtIGNhbnZhc0RhdGEud2lkdGgpKTtcbiAgICAgICAgICAgIGNhbnZhc0RhdGEubWluVG9wID0gTWF0aC5taW4oY3JvcEJveERhdGEudG9wLCBjcm9wQm94RGF0YS50b3AgKyAoY3JvcEJveERhdGEuaGVpZ2h0IC0gY2FudmFzRGF0YS5oZWlnaHQpKTtcbiAgICAgICAgICAgIGNhbnZhc0RhdGEubWF4TGVmdCA9IGNyb3BCb3hEYXRhLmxlZnQ7XG4gICAgICAgICAgICBjYW52YXNEYXRhLm1heFRvcCA9IGNyb3BCb3hEYXRhLnRvcDtcblxuICAgICAgICAgICAgaWYgKHZpZXdNb2RlID09PSAyKSB7XG4gICAgICAgICAgICAgIGlmIChjYW52YXNEYXRhLndpZHRoID49IGNvbnRhaW5lckRhdGEud2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNEYXRhLm1pbkxlZnQgPSBNYXRoLm1pbigwLCBuZXdDYW52YXNMZWZ0KTtcbiAgICAgICAgICAgICAgICBjYW52YXNEYXRhLm1heExlZnQgPSBNYXRoLm1heCgwLCBuZXdDYW52YXNMZWZ0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjYW52YXNEYXRhLmhlaWdodCA+PSBjb250YWluZXJEYXRhLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGNhbnZhc0RhdGEubWluVG9wID0gTWF0aC5taW4oMCwgbmV3Q2FudmFzVG9wKTtcbiAgICAgICAgICAgICAgICBjYW52YXNEYXRhLm1heFRvcCA9IE1hdGgubWF4KDAsIG5ld0NhbnZhc1RvcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FudmFzRGF0YS5taW5MZWZ0ID0gLWNhbnZhc0RhdGEud2lkdGg7XG4gICAgICAgICAgY2FudmFzRGF0YS5taW5Ub3AgPSAtY2FudmFzRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgY2FudmFzRGF0YS5tYXhMZWZ0ID0gY29udGFpbmVyRGF0YS53aWR0aDtcbiAgICAgICAgICBjYW52YXNEYXRhLm1heFRvcCA9IGNvbnRhaW5lckRhdGEuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJDYW52YXM6IGZ1bmN0aW9uIHJlbmRlckNhbnZhcyhjaGFuZ2VkLCB0cmFuc2Zvcm1lZCkge1xuICAgICAgdmFyIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXG4gICAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm1lZCkge1xuICAgICAgICB2YXIgX2dldFJvdGF0ZWRTaXplcyA9IGdldFJvdGF0ZWRTaXplcyh7XG4gICAgICAgICAgd2lkdGg6IGltYWdlRGF0YS5uYXR1cmFsV2lkdGggKiBNYXRoLmFicyhpbWFnZURhdGEuc2NhbGVYIHx8IDEpLFxuICAgICAgICAgIGhlaWdodDogaW1hZ2VEYXRhLm5hdHVyYWxIZWlnaHQgKiBNYXRoLmFicyhpbWFnZURhdGEuc2NhbGVZIHx8IDEpLFxuICAgICAgICAgIGRlZ3JlZTogaW1hZ2VEYXRhLnJvdGF0ZSB8fCAwXG4gICAgICAgIH0pLFxuICAgICAgICAgICAgbmF0dXJhbFdpZHRoID0gX2dldFJvdGF0ZWRTaXplcy53aWR0aCxcbiAgICAgICAgICAgIG5hdHVyYWxIZWlnaHQgPSBfZ2V0Um90YXRlZFNpemVzLmhlaWdodDtcblxuICAgICAgICB2YXIgd2lkdGggPSBjYW52YXNEYXRhLndpZHRoICogKG5hdHVyYWxXaWR0aCAvIGNhbnZhc0RhdGEubmF0dXJhbFdpZHRoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGNhbnZhc0RhdGEuaGVpZ2h0ICogKG5hdHVyYWxIZWlnaHQgLyBjYW52YXNEYXRhLm5hdHVyYWxIZWlnaHQpO1xuICAgICAgICBjYW52YXNEYXRhLmxlZnQgLT0gKHdpZHRoIC0gY2FudmFzRGF0YS53aWR0aCkgLyAyO1xuICAgICAgICBjYW52YXNEYXRhLnRvcCAtPSAoaGVpZ2h0IC0gY2FudmFzRGF0YS5oZWlnaHQpIC8gMjtcbiAgICAgICAgY2FudmFzRGF0YS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXNEYXRhLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgY2FudmFzRGF0YS5hc3BlY3RSYXRpbyA9IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHQ7XG4gICAgICAgIGNhbnZhc0RhdGEubmF0dXJhbFdpZHRoID0gbmF0dXJhbFdpZHRoO1xuICAgICAgICBjYW52YXNEYXRhLm5hdHVyYWxIZWlnaHQgPSBuYXR1cmFsSGVpZ2h0O1xuICAgICAgICB0aGlzLmxpbWl0Q2FudmFzKHRydWUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbnZhc0RhdGEud2lkdGggPiBjYW52YXNEYXRhLm1heFdpZHRoIHx8IGNhbnZhc0RhdGEud2lkdGggPCBjYW52YXNEYXRhLm1pbldpZHRoKSB7XG4gICAgICAgIGNhbnZhc0RhdGEubGVmdCA9IGNhbnZhc0RhdGEub2xkTGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbnZhc0RhdGEuaGVpZ2h0ID4gY2FudmFzRGF0YS5tYXhIZWlnaHQgfHwgY2FudmFzRGF0YS5oZWlnaHQgPCBjYW52YXNEYXRhLm1pbkhlaWdodCkge1xuICAgICAgICBjYW52YXNEYXRhLnRvcCA9IGNhbnZhc0RhdGEub2xkVG9wO1xuICAgICAgfVxuXG4gICAgICBjYW52YXNEYXRhLndpZHRoID0gTWF0aC5taW4oTWF0aC5tYXgoY2FudmFzRGF0YS53aWR0aCwgY2FudmFzRGF0YS5taW5XaWR0aCksIGNhbnZhc0RhdGEubWF4V2lkdGgpO1xuICAgICAgY2FudmFzRGF0YS5oZWlnaHQgPSBNYXRoLm1pbihNYXRoLm1heChjYW52YXNEYXRhLmhlaWdodCwgY2FudmFzRGF0YS5taW5IZWlnaHQpLCBjYW52YXNEYXRhLm1heEhlaWdodCk7XG4gICAgICB0aGlzLmxpbWl0Q2FudmFzKGZhbHNlLCB0cnVlKTtcbiAgICAgIGNhbnZhc0RhdGEubGVmdCA9IE1hdGgubWluKE1hdGgubWF4KGNhbnZhc0RhdGEubGVmdCwgY2FudmFzRGF0YS5taW5MZWZ0KSwgY2FudmFzRGF0YS5tYXhMZWZ0KTtcbiAgICAgIGNhbnZhc0RhdGEudG9wID0gTWF0aC5taW4oTWF0aC5tYXgoY2FudmFzRGF0YS50b3AsIGNhbnZhc0RhdGEubWluVG9wKSwgY2FudmFzRGF0YS5tYXhUb3ApO1xuICAgICAgY2FudmFzRGF0YS5vbGRMZWZ0ID0gY2FudmFzRGF0YS5sZWZ0O1xuICAgICAgY2FudmFzRGF0YS5vbGRUb3AgPSBjYW52YXNEYXRhLnRvcDtcbiAgICAgIHNldFN0eWxlKHRoaXMuY2FudmFzLCBhc3NpZ24oe1xuICAgICAgICB3aWR0aDogY2FudmFzRGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXNEYXRhLmhlaWdodFxuICAgICAgfSwgZ2V0VHJhbnNmb3Jtcyh7XG4gICAgICAgIHRyYW5zbGF0ZVg6IGNhbnZhc0RhdGEubGVmdCxcbiAgICAgICAgdHJhbnNsYXRlWTogY2FudmFzRGF0YS50b3BcbiAgICAgIH0pKSk7XG4gICAgICB0aGlzLnJlbmRlckltYWdlKGNoYW5nZWQpO1xuXG4gICAgICBpZiAodGhpcy5jcm9wcGVkICYmIHRoaXMubGltaXRlZCkge1xuICAgICAgICB0aGlzLmxpbWl0Q3JvcEJveCh0cnVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckltYWdlOiBmdW5jdGlvbiByZW5kZXJJbWFnZShjaGFuZ2VkKSB7XG4gICAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YSxcbiAgICAgICAgICBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTtcbiAgICAgIHZhciB3aWR0aCA9IGltYWdlRGF0YS5uYXR1cmFsV2lkdGggKiAoY2FudmFzRGF0YS53aWR0aCAvIGNhbnZhc0RhdGEubmF0dXJhbFdpZHRoKTtcbiAgICAgIHZhciBoZWlnaHQgPSBpbWFnZURhdGEubmF0dXJhbEhlaWdodCAqIChjYW52YXNEYXRhLmhlaWdodCAvIGNhbnZhc0RhdGEubmF0dXJhbEhlaWdodCk7XG4gICAgICBhc3NpZ24oaW1hZ2VEYXRhLCB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGxlZnQ6IChjYW52YXNEYXRhLndpZHRoIC0gd2lkdGgpIC8gMixcbiAgICAgICAgdG9wOiAoY2FudmFzRGF0YS5oZWlnaHQgLSBoZWlnaHQpIC8gMlxuICAgICAgfSk7XG4gICAgICBzZXRTdHlsZSh0aGlzLmltYWdlLCBhc3NpZ24oe1xuICAgICAgICB3aWR0aDogaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGltYWdlRGF0YS5oZWlnaHRcbiAgICAgIH0sIGdldFRyYW5zZm9ybXMoYXNzaWduKHtcbiAgICAgICAgdHJhbnNsYXRlWDogaW1hZ2VEYXRhLmxlZnQsXG4gICAgICAgIHRyYW5zbGF0ZVk6IGltYWdlRGF0YS50b3BcbiAgICAgIH0sIGltYWdlRGF0YSkpKSk7XG5cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMub3V0cHV0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0Q3JvcEJveDogZnVuY3Rpb24gaW5pdENyb3BCb3goKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhO1xuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gb3B0aW9ucy5hc3BlY3RSYXRpbyB8fCBvcHRpb25zLmluaXRpYWxBc3BlY3RSYXRpbztcbiAgICAgIHZhciBhdXRvQ3JvcEFyZWEgPSBOdW1iZXIob3B0aW9ucy5hdXRvQ3JvcEFyZWEpIHx8IDAuODtcbiAgICAgIHZhciBjcm9wQm94RGF0YSA9IHtcbiAgICAgICAgd2lkdGg6IGNhbnZhc0RhdGEud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzRGF0YS5oZWlnaHRcbiAgICAgIH07XG5cbiAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICBpZiAoY2FudmFzRGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbyA+IGNhbnZhc0RhdGEud2lkdGgpIHtcbiAgICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBjcm9wQm94RGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNyb3BCb3hEYXRhLndpZHRoID0gY3JvcEJveERhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jcm9wQm94RGF0YSA9IGNyb3BCb3hEYXRhO1xuICAgICAgdGhpcy5saW1pdENyb3BCb3godHJ1ZSwgdHJ1ZSk7IC8vIEluaXRpYWxpemUgYXV0byBjcm9wIGFyZWFcblxuICAgICAgY3JvcEJveERhdGEud2lkdGggPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS53aWR0aCwgY3JvcEJveERhdGEubWluV2lkdGgpLCBjcm9wQm94RGF0YS5tYXhXaWR0aCk7XG4gICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS5oZWlnaHQsIGNyb3BCb3hEYXRhLm1pbkhlaWdodCksIGNyb3BCb3hEYXRhLm1heEhlaWdodCk7IC8vIFRoZSB3aWR0aC9oZWlnaHQgb2YgYXV0byBjcm9wIGFyZWEgbXVzdCBsYXJnZSB0aGFuIFwibWluV2lkdGgvSGVpZ2h0XCJcblxuICAgICAgY3JvcEJveERhdGEud2lkdGggPSBNYXRoLm1heChjcm9wQm94RGF0YS5taW5XaWR0aCwgY3JvcEJveERhdGEud2lkdGggKiBhdXRvQ3JvcEFyZWEpO1xuICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gTWF0aC5tYXgoY3JvcEJveERhdGEubWluSGVpZ2h0LCBjcm9wQm94RGF0YS5oZWlnaHQgKiBhdXRvQ3JvcEFyZWEpO1xuICAgICAgY3JvcEJveERhdGEubGVmdCA9IGNhbnZhc0RhdGEubGVmdCArIChjYW52YXNEYXRhLndpZHRoIC0gY3JvcEJveERhdGEud2lkdGgpIC8gMjtcbiAgICAgIGNyb3BCb3hEYXRhLnRvcCA9IGNhbnZhc0RhdGEudG9wICsgKGNhbnZhc0RhdGEuaGVpZ2h0IC0gY3JvcEJveERhdGEuaGVpZ2h0KSAvIDI7XG4gICAgICBjcm9wQm94RGF0YS5vbGRMZWZ0ID0gY3JvcEJveERhdGEubGVmdDtcbiAgICAgIGNyb3BCb3hEYXRhLm9sZFRvcCA9IGNyb3BCb3hEYXRhLnRvcDtcbiAgICAgIHRoaXMuaW5pdGlhbENyb3BCb3hEYXRhID0gYXNzaWduKHt9LCBjcm9wQm94RGF0YSk7XG4gICAgfSxcbiAgICBsaW1pdENyb3BCb3g6IGZ1bmN0aW9uIGxpbWl0Q3JvcEJveChzaXplTGltaXRlZCwgcG9zaXRpb25MaW1pdGVkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhLFxuICAgICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXG4gICAgICAgICAgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhLFxuICAgICAgICAgIGxpbWl0ZWQgPSB0aGlzLmxpbWl0ZWQ7XG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPSBvcHRpb25zLmFzcGVjdFJhdGlvO1xuXG4gICAgICBpZiAoc2l6ZUxpbWl0ZWQpIHtcbiAgICAgICAgdmFyIG1pbkNyb3BCb3hXaWR0aCA9IE51bWJlcihvcHRpb25zLm1pbkNyb3BCb3hXaWR0aCkgfHwgMDtcbiAgICAgICAgdmFyIG1pbkNyb3BCb3hIZWlnaHQgPSBOdW1iZXIob3B0aW9ucy5taW5Dcm9wQm94SGVpZ2h0KSB8fCAwO1xuICAgICAgICB2YXIgbWF4Q3JvcEJveFdpZHRoID0gbGltaXRlZCA/IE1hdGgubWluKGNvbnRhaW5lckRhdGEud2lkdGgsIGNhbnZhc0RhdGEud2lkdGgsIGNhbnZhc0RhdGEud2lkdGggKyBjYW52YXNEYXRhLmxlZnQsIGNvbnRhaW5lckRhdGEud2lkdGggLSBjYW52YXNEYXRhLmxlZnQpIDogY29udGFpbmVyRGF0YS53aWR0aDtcbiAgICAgICAgdmFyIG1heENyb3BCb3hIZWlnaHQgPSBsaW1pdGVkID8gTWF0aC5taW4oY29udGFpbmVyRGF0YS5oZWlnaHQsIGNhbnZhc0RhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLmhlaWdodCArIGNhbnZhc0RhdGEudG9wLCBjb250YWluZXJEYXRhLmhlaWdodCAtIGNhbnZhc0RhdGEudG9wKSA6IGNvbnRhaW5lckRhdGEuaGVpZ2h0OyAvLyBUaGUgbWluL21heENyb3BCb3hXaWR0aC9IZWlnaHQgbXVzdCBiZSBsZXNzIHRoYW4gY29udGFpbmVyJ3Mgd2lkdGgvaGVpZ2h0XG5cbiAgICAgICAgbWluQ3JvcEJveFdpZHRoID0gTWF0aC5taW4obWluQ3JvcEJveFdpZHRoLCBjb250YWluZXJEYXRhLndpZHRoKTtcbiAgICAgICAgbWluQ3JvcEJveEhlaWdodCA9IE1hdGgubWluKG1pbkNyb3BCb3hIZWlnaHQsIGNvbnRhaW5lckRhdGEuaGVpZ2h0KTtcblxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBpZiAobWluQ3JvcEJveFdpZHRoICYmIG1pbkNyb3BCb3hIZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChtaW5Dcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW8gPiBtaW5Dcm9wQm94V2lkdGgpIHtcbiAgICAgICAgICAgICAgbWluQ3JvcEJveEhlaWdodCA9IG1pbkNyb3BCb3hXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWluQ3JvcEJveFdpZHRoID0gbWluQ3JvcEJveEhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobWluQ3JvcEJveFdpZHRoKSB7XG4gICAgICAgICAgICBtaW5Dcm9wQm94SGVpZ2h0ID0gbWluQ3JvcEJveFdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgfSBlbHNlIGlmIChtaW5Dcm9wQm94SGVpZ2h0KSB7XG4gICAgICAgICAgICBtaW5Dcm9wQm94V2lkdGggPSBtaW5Dcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1heENyb3BCb3hIZWlnaHQgKiBhc3BlY3RSYXRpbyA+IG1heENyb3BCb3hXaWR0aCkge1xuICAgICAgICAgICAgbWF4Q3JvcEJveEhlaWdodCA9IG1heENyb3BCb3hXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXhDcm9wQm94V2lkdGggPSBtYXhDcm9wQm94SGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRoZSBtaW5XaWR0aC9IZWlnaHQgbXVzdCBiZSBsZXNzIHRoYW4gbWF4V2lkdGgvSGVpZ2h0XG5cblxuICAgICAgICBjcm9wQm94RGF0YS5taW5XaWR0aCA9IE1hdGgubWluKG1pbkNyb3BCb3hXaWR0aCwgbWF4Q3JvcEJveFdpZHRoKTtcbiAgICAgICAgY3JvcEJveERhdGEubWluSGVpZ2h0ID0gTWF0aC5taW4obWluQ3JvcEJveEhlaWdodCwgbWF4Q3JvcEJveEhlaWdodCk7XG4gICAgICAgIGNyb3BCb3hEYXRhLm1heFdpZHRoID0gbWF4Q3JvcEJveFdpZHRoO1xuICAgICAgICBjcm9wQm94RGF0YS5tYXhIZWlnaHQgPSBtYXhDcm9wQm94SGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zaXRpb25MaW1pdGVkKSB7XG4gICAgICAgIGlmIChsaW1pdGVkKSB7XG4gICAgICAgICAgY3JvcEJveERhdGEubWluTGVmdCA9IE1hdGgubWF4KDAsIGNhbnZhc0RhdGEubGVmdCk7XG4gICAgICAgICAgY3JvcEJveERhdGEubWluVG9wID0gTWF0aC5tYXgoMCwgY2FudmFzRGF0YS50b3ApO1xuICAgICAgICAgIGNyb3BCb3hEYXRhLm1heExlZnQgPSBNYXRoLm1pbihjb250YWluZXJEYXRhLndpZHRoLCBjYW52YXNEYXRhLmxlZnQgKyBjYW52YXNEYXRhLndpZHRoKSAtIGNyb3BCb3hEYXRhLndpZHRoO1xuICAgICAgICAgIGNyb3BCb3hEYXRhLm1heFRvcCA9IE1hdGgubWluKGNvbnRhaW5lckRhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLnRvcCArIGNhbnZhc0RhdGEuaGVpZ2h0KSAtIGNyb3BCb3hEYXRhLmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjcm9wQm94RGF0YS5taW5MZWZ0ID0gMDtcbiAgICAgICAgICBjcm9wQm94RGF0YS5taW5Ub3AgPSAwO1xuICAgICAgICAgIGNyb3BCb3hEYXRhLm1heExlZnQgPSBjb250YWluZXJEYXRhLndpZHRoIC0gY3JvcEJveERhdGEud2lkdGg7XG4gICAgICAgICAgY3JvcEJveERhdGEubWF4VG9wID0gY29udGFpbmVyRGF0YS5oZWlnaHQgLSBjcm9wQm94RGF0YS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckNyb3BCb3g6IGZ1bmN0aW9uIHJlbmRlckNyb3BCb3goKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhLFxuICAgICAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcblxuICAgICAgaWYgKGNyb3BCb3hEYXRhLndpZHRoID4gY3JvcEJveERhdGEubWF4V2lkdGggfHwgY3JvcEJveERhdGEud2lkdGggPCBjcm9wQm94RGF0YS5taW5XaWR0aCkge1xuICAgICAgICBjcm9wQm94RGF0YS5sZWZ0ID0gY3JvcEJveERhdGEub2xkTGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNyb3BCb3hEYXRhLmhlaWdodCA+IGNyb3BCb3hEYXRhLm1heEhlaWdodCB8fCBjcm9wQm94RGF0YS5oZWlnaHQgPCBjcm9wQm94RGF0YS5taW5IZWlnaHQpIHtcbiAgICAgICAgY3JvcEJveERhdGEudG9wID0gY3JvcEJveERhdGEub2xkVG9wO1xuICAgICAgfVxuXG4gICAgICBjcm9wQm94RGF0YS53aWR0aCA9IE1hdGgubWluKE1hdGgubWF4KGNyb3BCb3hEYXRhLndpZHRoLCBjcm9wQm94RGF0YS5taW5XaWR0aCksIGNyb3BCb3hEYXRhLm1heFdpZHRoKTtcbiAgICAgIGNyb3BCb3hEYXRhLmhlaWdodCA9IE1hdGgubWluKE1hdGgubWF4KGNyb3BCb3hEYXRhLmhlaWdodCwgY3JvcEJveERhdGEubWluSGVpZ2h0KSwgY3JvcEJveERhdGEubWF4SGVpZ2h0KTtcbiAgICAgIHRoaXMubGltaXRDcm9wQm94KGZhbHNlLCB0cnVlKTtcbiAgICAgIGNyb3BCb3hEYXRhLmxlZnQgPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS5sZWZ0LCBjcm9wQm94RGF0YS5taW5MZWZ0KSwgY3JvcEJveERhdGEubWF4TGVmdCk7XG4gICAgICBjcm9wQm94RGF0YS50b3AgPSBNYXRoLm1pbihNYXRoLm1heChjcm9wQm94RGF0YS50b3AsIGNyb3BCb3hEYXRhLm1pblRvcCksIGNyb3BCb3hEYXRhLm1heFRvcCk7XG4gICAgICBjcm9wQm94RGF0YS5vbGRMZWZ0ID0gY3JvcEJveERhdGEubGVmdDtcbiAgICAgIGNyb3BCb3hEYXRhLm9sZFRvcCA9IGNyb3BCb3hEYXRhLnRvcDtcblxuICAgICAgaWYgKG9wdGlvbnMubW92YWJsZSAmJiBvcHRpb25zLmNyb3BCb3hNb3ZhYmxlKSB7XG4gICAgICAgIC8vIFR1cm4gdG8gbW92ZSB0aGUgY2FudmFzIHdoZW4gdGhlIGNyb3AgYm94IGlzIGVxdWFsIHRvIHRoZSBjb250YWluZXJcbiAgICAgICAgc2V0RGF0YSh0aGlzLmZhY2UsIERBVEFfQUNUSU9OLCBjcm9wQm94RGF0YS53aWR0aCA+PSBjb250YWluZXJEYXRhLndpZHRoICYmIGNyb3BCb3hEYXRhLmhlaWdodCA+PSBjb250YWluZXJEYXRhLmhlaWdodCA/IEFDVElPTl9NT1ZFIDogQUNUSU9OX0FMTCk7XG4gICAgICB9XG5cbiAgICAgIHNldFN0eWxlKHRoaXMuY3JvcEJveCwgYXNzaWduKHtcbiAgICAgICAgd2lkdGg6IGNyb3BCb3hEYXRhLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNyb3BCb3hEYXRhLmhlaWdodFxuICAgICAgfSwgZ2V0VHJhbnNmb3Jtcyh7XG4gICAgICAgIHRyYW5zbGF0ZVg6IGNyb3BCb3hEYXRhLmxlZnQsXG4gICAgICAgIHRyYW5zbGF0ZVk6IGNyb3BCb3hEYXRhLnRvcFxuICAgICAgfSkpKTtcblxuICAgICAgaWYgKHRoaXMuY3JvcHBlZCAmJiB0aGlzLmxpbWl0ZWQpIHtcbiAgICAgICAgdGhpcy5saW1pdENhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMub3V0cHV0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvdXRwdXQ6IGZ1bmN0aW9uIG91dHB1dCgpIHtcbiAgICAgIHRoaXMucHJldmlldygpO1xuICAgICAgZGlzcGF0Y2hFdmVudCh0aGlzLmVsZW1lbnQsIEVWRU5UX0NST1AsIHRoaXMuZ2V0RGF0YSgpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHByZXZpZXcgPSB7XG4gICAgaW5pdFByZXZpZXc6IGZ1bmN0aW9uIGluaXRQcmV2aWV3KCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuICAgICAgdmFyIHByZXZpZXcgPSB0aGlzLm9wdGlvbnMucHJldmlldztcbiAgICAgIHZhciB1cmwgPSBjcm9zc09yaWdpbiA/IHRoaXMuY3Jvc3NPcmlnaW5VcmwgOiB0aGlzLnVybDtcbiAgICAgIHZhciBhbHQgPSBlbGVtZW50LmFsdCB8fCAnVGhlIGltYWdlIHRvIHByZXZpZXcnO1xuICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgfVxuXG4gICAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgICBpbWFnZS5hbHQgPSBhbHQ7XG4gICAgICB0aGlzLnZpZXdCb3guYXBwZW5kQ2hpbGQoaW1hZ2UpO1xuICAgICAgdGhpcy52aWV3Qm94SW1hZ2UgPSBpbWFnZTtcblxuICAgICAgaWYgKCFwcmV2aWV3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZpZXdzID0gcHJldmlldztcblxuICAgICAgaWYgKHR5cGVvZiBwcmV2aWV3ID09PSAnc3RyaW5nJykge1xuICAgICAgICBwcmV2aWV3cyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHByZXZpZXcpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2aWV3LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICAgICAgcHJldmlld3MgPSBbcHJldmlld107XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJldmlld3MgPSBwcmV2aWV3cztcbiAgICAgIGZvckVhY2gocHJldmlld3MsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7IC8vIFNhdmUgdGhlIG9yaWdpbmFsIHNpemUgZm9yIHJlY292ZXJcblxuICAgICAgICBzZXREYXRhKGVsLCBEQVRBX1BSRVZJRVcsIHtcbiAgICAgICAgICB3aWR0aDogZWwub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBlbC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgaHRtbDogZWwuaW5uZXJIVE1MXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjcm9zc09yaWdpbikge1xuICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgICAgaW1nLmFsdCA9IGFsdDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlIGltZyBlbGVtZW50IHN0eWxlc1xuICAgICAgICAgKiBBZGQgYGRpc3BsYXk6YmxvY2tgIHRvIGF2b2lkIG1hcmdpbiB0b3AgaXNzdWVcbiAgICAgICAgICogQWRkIGBoZWlnaHQ6YXV0b2AgdG8gb3ZlcnJpZGUgYGhlaWdodGAgYXR0cmlidXRlIG9uIElFOFxuICAgICAgICAgKiAoT2NjdXIgb25seSB3aGVuIG1hcmdpbi10b3AgPD0gLWhlaWdodClcbiAgICAgICAgICovXG5cbiAgICAgICAgaW1nLnN0eWxlLmNzc1RleHQgPSAnZGlzcGxheTpibG9jazsnICsgJ3dpZHRoOjEwMCU7JyArICdoZWlnaHQ6YXV0bzsnICsgJ21pbi13aWR0aDowIWltcG9ydGFudDsnICsgJ21pbi1oZWlnaHQ6MCFpbXBvcnRhbnQ7JyArICdtYXgtd2lkdGg6bm9uZSFpbXBvcnRhbnQ7JyArICdtYXgtaGVpZ2h0Om5vbmUhaW1wb3J0YW50OycgKyAnaW1hZ2Utb3JpZW50YXRpb246MGRlZyFpbXBvcnRhbnQ7XCInO1xuICAgICAgICBlbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVzZXRQcmV2aWV3OiBmdW5jdGlvbiByZXNldFByZXZpZXcoKSB7XG4gICAgICBmb3JFYWNoKHRoaXMucHJldmlld3MsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtZW50LCBEQVRBX1BSRVZJRVcpO1xuICAgICAgICBzZXRTdHlsZShlbGVtZW50LCB7XG4gICAgICAgICAgd2lkdGg6IGRhdGEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBkYXRhLmhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBkYXRhLmh0bWw7XG4gICAgICAgIHJlbW92ZURhdGEoZWxlbWVudCwgREFUQV9QUkVWSUVXKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcHJldmlldzogZnVuY3Rpb24gcHJldmlldygpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YSxcbiAgICAgICAgICBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhLFxuICAgICAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcbiAgICAgIHZhciBjcm9wQm94V2lkdGggPSBjcm9wQm94RGF0YS53aWR0aCxcbiAgICAgICAgICBjcm9wQm94SGVpZ2h0ID0gY3JvcEJveERhdGEuaGVpZ2h0O1xuICAgICAgdmFyIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICB2YXIgbGVmdCA9IGNyb3BCb3hEYXRhLmxlZnQgLSBjYW52YXNEYXRhLmxlZnQgLSBpbWFnZURhdGEubGVmdDtcbiAgICAgIHZhciB0b3AgPSBjcm9wQm94RGF0YS50b3AgLSBjYW52YXNEYXRhLnRvcCAtIGltYWdlRGF0YS50b3A7XG5cbiAgICAgIGlmICghdGhpcy5jcm9wcGVkIHx8IHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXRTdHlsZSh0aGlzLnZpZXdCb3hJbWFnZSwgYXNzaWduKHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfSwgZ2V0VHJhbnNmb3Jtcyhhc3NpZ24oe1xuICAgICAgICB0cmFuc2xhdGVYOiAtbGVmdCxcbiAgICAgICAgdHJhbnNsYXRlWTogLXRvcFxuICAgICAgfSwgaW1hZ2VEYXRhKSkpKTtcbiAgICAgIGZvckVhY2godGhpcy5wcmV2aWV3cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKGVsZW1lbnQsIERBVEFfUFJFVklFVyk7XG4gICAgICAgIHZhciBvcmlnaW5hbFdpZHRoID0gZGF0YS53aWR0aDtcbiAgICAgICAgdmFyIG9yaWdpbmFsSGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICAgIHZhciBuZXdXaWR0aCA9IG9yaWdpbmFsV2lkdGg7XG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSBvcmlnaW5hbEhlaWdodDtcbiAgICAgICAgdmFyIHJhdGlvID0gMTtcblxuICAgICAgICBpZiAoY3JvcEJveFdpZHRoKSB7XG4gICAgICAgICAgcmF0aW8gPSBvcmlnaW5hbFdpZHRoIC8gY3JvcEJveFdpZHRoO1xuICAgICAgICAgIG5ld0hlaWdodCA9IGNyb3BCb3hIZWlnaHQgKiByYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjcm9wQm94SGVpZ2h0ICYmIG5ld0hlaWdodCA+IG9yaWdpbmFsSGVpZ2h0KSB7XG4gICAgICAgICAgcmF0aW8gPSBvcmlnaW5hbEhlaWdodCAvIGNyb3BCb3hIZWlnaHQ7XG4gICAgICAgICAgbmV3V2lkdGggPSBjcm9wQm94V2lkdGggKiByYXRpbztcbiAgICAgICAgICBuZXdIZWlnaHQgPSBvcmlnaW5hbEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFN0eWxlKGVsZW1lbnQsIHtcbiAgICAgICAgICB3aWR0aDogbmV3V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFN0eWxlKGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpWzBdLCBhc3NpZ24oe1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCAqIHJhdGlvLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICogcmF0aW9cbiAgICAgICAgfSwgZ2V0VHJhbnNmb3Jtcyhhc3NpZ24oe1xuICAgICAgICAgIHRyYW5zbGF0ZVg6IC1sZWZ0ICogcmF0aW8sXG4gICAgICAgICAgdHJhbnNsYXRlWTogLXRvcCAqIHJhdGlvXG4gICAgICAgIH0sIGltYWdlRGF0YSkpKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGV2ZW50cyA9IHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBjcm9wcGVyID0gdGhpcy5jcm9wcGVyO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3BzdGFydCkpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ1JPUF9TVEFSVCwgb3B0aW9ucy5jcm9wc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3Btb3ZlKSkge1xuICAgICAgICBhZGRMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX01PVkUsIG9wdGlvbnMuY3JvcG1vdmUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3BlbmQpKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1BfRU5ELCBvcHRpb25zLmNyb3BlbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLmNyb3ApKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1AsIG9wdGlvbnMuY3JvcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuem9vbSkpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfWk9PTSwgb3B0aW9ucy56b29tKTtcbiAgICAgIH1cblxuICAgICAgYWRkTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfUE9JTlRFUl9ET1dOLCB0aGlzLm9uQ3JvcFN0YXJ0ID0gdGhpcy5jcm9wU3RhcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgIGlmIChvcHRpb25zLnpvb21hYmxlICYmIG9wdGlvbnMuem9vbU9uV2hlZWwpIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfV0hFRUwsIHRoaXMub25XaGVlbCA9IHRoaXMud2hlZWwuYmluZCh0aGlzKSwge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnRvZ2dsZURyYWdNb2RlT25EYmxjbGljaykge1xuICAgICAgICBhZGRMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9EQkxDTElDSywgdGhpcy5vbkRibGNsaWNrID0gdGhpcy5kYmxjbGljay5iaW5kKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudC5vd25lckRvY3VtZW50LCBFVkVOVF9QT0lOVEVSX01PVkUsIHRoaXMub25Dcm9wTW92ZSA9IHRoaXMuY3JvcE1vdmUuYmluZCh0aGlzKSk7XG4gICAgICBhZGRMaXN0ZW5lcihlbGVtZW50Lm93bmVyRG9jdW1lbnQsIEVWRU5UX1BPSU5URVJfVVAsIHRoaXMub25Dcm9wRW5kID0gdGhpcy5jcm9wRW5kLmJpbmQodGhpcykpO1xuXG4gICAgICBpZiAob3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKHdpbmRvdywgRVZFTlRfUkVTSVpFLCB0aGlzLm9uUmVzaXplID0gdGhpcy5yZXNpemUuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgY3JvcHBlciA9IHRoaXMuY3JvcHBlcjtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wc3RhcnQpKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX0NST1BfU1RBUlQsIG9wdGlvbnMuY3JvcHN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wbW92ZSkpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfQ1JPUF9NT1ZFLCBvcHRpb25zLmNyb3Btb3ZlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wZW5kKSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QX0VORCwgb3B0aW9ucy5jcm9wZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jcm9wKSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCBFVkVOVF9DUk9QLCBvcHRpb25zLmNyb3ApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnpvb20pKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIEVWRU5UX1pPT00sIG9wdGlvbnMuem9vbSk7XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZUxpc3RlbmVyKGNyb3BwZXIsIEVWRU5UX1BPSU5URVJfRE9XTiwgdGhpcy5vbkNyb3BTdGFydCk7XG5cbiAgICAgIGlmIChvcHRpb25zLnpvb21hYmxlICYmIG9wdGlvbnMuem9vbU9uV2hlZWwpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoY3JvcHBlciwgRVZFTlRfV0hFRUwsIHRoaXMub25XaGVlbCwge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnRvZ2dsZURyYWdNb2RlT25EYmxjbGljaykge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihjcm9wcGVyLCBFVkVOVF9EQkxDTElDSywgdGhpcy5vbkRibGNsaWNrKTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudC5vd25lckRvY3VtZW50LCBFVkVOVF9QT0lOVEVSX01PVkUsIHRoaXMub25Dcm9wTW92ZSk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50Lm93bmVyRG9jdW1lbnQsIEVWRU5UX1BPSU5URVJfVVAsIHRoaXMub25Dcm9wRW5kKTtcblxuICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcih3aW5kb3csIEVWRU5UX1JFU0laRSwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVycyA9IHtcbiAgICByZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgY29udGFpbmVyRGF0YSA9IHRoaXMuY29udGFpbmVyRGF0YTtcbiAgICAgIHZhciByYXRpbyA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCAvIGNvbnRhaW5lckRhdGEud2lkdGg7IC8vIFJlc2l6ZSB3aGVuIHdpZHRoIGNoYW5nZWQgb3IgaGVpZ2h0IGNoYW5nZWRcblxuICAgICAgaWYgKHJhdGlvICE9PSAxIHx8IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgIT09IGNvbnRhaW5lckRhdGEuaGVpZ2h0KSB7XG4gICAgICAgIHZhciBjYW52YXNEYXRhO1xuICAgICAgICB2YXIgY3JvcEJveERhdGE7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVzdG9yZSkge1xuICAgICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmdldENhbnZhc0RhdGEoKTtcbiAgICAgICAgICBjcm9wQm94RGF0YSA9IHRoaXMuZ2V0Q3JvcEJveERhdGEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVzdG9yZSkge1xuICAgICAgICAgIHRoaXMuc2V0Q2FudmFzRGF0YShmb3JFYWNoKGNhbnZhc0RhdGEsIGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgICBjYW52YXNEYXRhW2ldID0gbiAqIHJhdGlvO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB0aGlzLnNldENyb3BCb3hEYXRhKGZvckVhY2goY3JvcEJveERhdGEsIGZ1bmN0aW9uIChuLCBpKSB7XG4gICAgICAgICAgICBjcm9wQm94RGF0YVtpXSA9IG4gKiByYXRpbztcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRibGNsaWNrOiBmdW5jdGlvbiBkYmxjbGljaygpIHtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMub3B0aW9ucy5kcmFnTW9kZSA9PT0gRFJBR19NT0RFX05PTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldERyYWdNb2RlKGhhc0NsYXNzKHRoaXMuZHJhZ0JveCwgQ0xBU1NfQ1JPUCkgPyBEUkFHX01PREVfTU9WRSA6IERSQUdfTU9ERV9DUk9QKTtcbiAgICB9LFxuICAgIHdoZWVsOiBmdW5jdGlvbiB3aGVlbChldmVudCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHJhdGlvID0gTnVtYmVyKHRoaXMub3B0aW9ucy53aGVlbFpvb21SYXRpbykgfHwgMC4xO1xuICAgICAgdmFyIGRlbHRhID0gMTtcblxuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBMaW1pdCB3aGVlbCBzcGVlZCB0byBwcmV2ZW50IHpvb20gdG9vIGZhc3QgKCMyMSlcblxuICAgICAgaWYgKHRoaXMud2hlZWxpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLndoZWVsaW5nID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy53aGVlbGluZyA9IGZhbHNlO1xuICAgICAgfSwgNTApO1xuXG4gICAgICBpZiAoZXZlbnQuZGVsdGFZKSB7XG4gICAgICAgIGRlbHRhID0gZXZlbnQuZGVsdGFZID4gMCA/IDEgOiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQud2hlZWxEZWx0YSkge1xuICAgICAgICBkZWx0YSA9IC1ldmVudC53aGVlbERlbHRhIC8gMTIwO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5kZXRhaWwpIHtcbiAgICAgICAgZGVsdGEgPSBldmVudC5kZXRhaWwgPiAwID8gMSA6IC0xO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnpvb20oLWRlbHRhICogcmF0aW8sIGV2ZW50KTtcbiAgICB9LFxuICAgIGNyb3BTdGFydDogZnVuY3Rpb24gY3JvcFN0YXJ0KGV2ZW50KSB7XG4gICAgICB2YXIgYnV0dG9ucyA9IGV2ZW50LmJ1dHRvbnMsXG4gICAgICAgICAgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCAvLyBIYW5kbGUgbW91c2UgZXZlbnQgYW5kIHBvaW50ZXIgZXZlbnQgYW5kIGlnbm9yZSB0b3VjaCBldmVudFxuICAgICAgfHwgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdwb2ludGVyZG93bicgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScpICYmICggLy8gTm8gcHJpbWFyeSBidXR0b24gKFVzdWFsbHkgdGhlIGxlZnQgYnV0dG9uKVxuICAgICAgaXNOdW1iZXIoYnV0dG9ucykgJiYgYnV0dG9ucyAhPT0gMSB8fCBpc051bWJlcihidXR0b24pICYmIGJ1dHRvbiAhPT0gMCAvLyBPcGVuIGNvbnRleHQgbWVudVxuICAgICAgfHwgZXZlbnQuY3RybEtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBwb2ludGVycyA9IHRoaXMucG9pbnRlcnM7XG4gICAgICB2YXIgYWN0aW9uO1xuXG4gICAgICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgLy8gSGFuZGxlIHRvdWNoIGV2ZW50XG4gICAgICAgIGZvckVhY2goZXZlbnQuY2hhbmdlZFRvdWNoZXMsIGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgICAgIHBvaW50ZXJzW3RvdWNoLmlkZW50aWZpZXJdID0gZ2V0UG9pbnRlcih0b3VjaCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIG1vdXNlIGV2ZW50IGFuZCBwb2ludGVyIGV2ZW50XG4gICAgICAgIHBvaW50ZXJzW2V2ZW50LnBvaW50ZXJJZCB8fCAwXSA9IGdldFBvaW50ZXIoZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LmtleXMocG9pbnRlcnMpLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy56b29tYWJsZSAmJiBvcHRpb25zLnpvb21PblRvdWNoKSB7XG4gICAgICAgIGFjdGlvbiA9IEFDVElPTl9aT09NO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uID0gZ2V0RGF0YShldmVudC50YXJnZXQsIERBVEFfQUNUSU9OKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFSRUdFWFBfQUNUSU9OUy50ZXN0KGFjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlzcGF0Y2hFdmVudCh0aGlzLmVsZW1lbnQsIEVWRU5UX0NST1BfU1RBUlQsIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUaGlzIGxpbmUgaXMgcmVxdWlyZWQgZm9yIHByZXZlbnRpbmcgcGFnZSB6b29taW5nIGluIGlPUyBicm93c2Vyc1xuXG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgIHRoaXMuY3JvcHBpbmcgPSBmYWxzZTtcblxuICAgICAgaWYgKGFjdGlvbiA9PT0gQUNUSU9OX0NST1ApIHtcbiAgICAgICAgdGhpcy5jcm9wcGluZyA9IHRydWU7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuZHJhZ0JveCwgQ0xBU1NfTU9EQUwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JvcE1vdmU6IGZ1bmN0aW9uIGNyb3BNb3ZlKGV2ZW50KSB7XG4gICAgICB2YXIgYWN0aW9uID0gdGhpcy5hY3Rpb247XG5cbiAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICFhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlcnMgPSB0aGlzLnBvaW50ZXJzO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKGRpc3BhdGNoRXZlbnQodGhpcy5lbGVtZW50LCBFVkVOVF9DUk9QX01PVkUsIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgZm9yRWFjaChldmVudC5jaGFuZ2VkVG91Y2hlcywgZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICAgICAgLy8gVGhlIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgbm90IGJlIHVuZGVmaW5lZCAoIzQzMilcbiAgICAgICAgICBhc3NpZ24ocG9pbnRlcnNbdG91Y2guaWRlbnRpZmllcl0gfHwge30sIGdldFBvaW50ZXIodG91Y2gsIHRydWUpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NpZ24ocG9pbnRlcnNbZXZlbnQucG9pbnRlcklkIHx8IDBdIHx8IHt9LCBnZXRQb2ludGVyKGV2ZW50LCB0cnVlKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hhbmdlKGV2ZW50KTtcbiAgICB9LFxuICAgIGNyb3BFbmQ6IGZ1bmN0aW9uIGNyb3BFbmQoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuYWN0aW9uLFxuICAgICAgICAgIHBvaW50ZXJzID0gdGhpcy5wb2ludGVycztcblxuICAgICAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgIGZvckVhY2goZXZlbnQuY2hhbmdlZFRvdWNoZXMsIGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgICAgIGRlbGV0ZSBwb2ludGVyc1t0b3VjaC5pZGVudGlmaWVyXTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcG9pbnRlcnNbZXZlbnQucG9pbnRlcklkIHx8IDBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmICghT2JqZWN0LmtleXMocG9pbnRlcnMpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmFjdGlvbiA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jcm9wcGluZykge1xuICAgICAgICB0aGlzLmNyb3BwaW5nID0gZmFsc2U7XG4gICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuZHJhZ0JveCwgQ0xBU1NfTU9EQUwsIHRoaXMuY3JvcHBlZCAmJiB0aGlzLm9wdGlvbnMubW9kYWwpO1xuICAgICAgfVxuXG4gICAgICBkaXNwYXRjaEV2ZW50KHRoaXMuZWxlbWVudCwgRVZFTlRfQ1JPUF9FTkQsIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNoYW5nZSA9IHtcbiAgICBjaGFuZ2U6IGZ1bmN0aW9uIGNoYW5nZShldmVudCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YSxcbiAgICAgICAgICBjb250YWluZXJEYXRhID0gdGhpcy5jb250YWluZXJEYXRhLFxuICAgICAgICAgIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YSxcbiAgICAgICAgICBwb2ludGVycyA9IHRoaXMucG9pbnRlcnM7XG4gICAgICB2YXIgYWN0aW9uID0gdGhpcy5hY3Rpb247XG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPSBvcHRpb25zLmFzcGVjdFJhdGlvO1xuICAgICAgdmFyIGxlZnQgPSBjcm9wQm94RGF0YS5sZWZ0LFxuICAgICAgICAgIHRvcCA9IGNyb3BCb3hEYXRhLnRvcCxcbiAgICAgICAgICB3aWR0aCA9IGNyb3BCb3hEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGNyb3BCb3hEYXRhLmhlaWdodDtcbiAgICAgIHZhciByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICAgIHZhciBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgICB2YXIgbWluTGVmdCA9IDA7XG4gICAgICB2YXIgbWluVG9wID0gMDtcbiAgICAgIHZhciBtYXhXaWR0aCA9IGNvbnRhaW5lckRhdGEud2lkdGg7XG4gICAgICB2YXIgbWF4SGVpZ2h0ID0gY29udGFpbmVyRGF0YS5oZWlnaHQ7XG4gICAgICB2YXIgcmVuZGVyYWJsZSA9IHRydWU7XG4gICAgICB2YXIgb2Zmc2V0OyAvLyBMb2NraW5nIGFzcGVjdCByYXRpbyBpbiBcImZyZWUgbW9kZVwiIGJ5IGhvbGRpbmcgc2hpZnQga2V5XG5cbiAgICAgIGlmICghYXNwZWN0UmF0aW8gJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgYXNwZWN0UmF0aW8gPSB3aWR0aCAmJiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxpbWl0ZWQpIHtcbiAgICAgICAgbWluTGVmdCA9IGNyb3BCb3hEYXRhLm1pbkxlZnQ7XG4gICAgICAgIG1pblRvcCA9IGNyb3BCb3hEYXRhLm1pblRvcDtcbiAgICAgICAgbWF4V2lkdGggPSBtaW5MZWZ0ICsgTWF0aC5taW4oY29udGFpbmVyRGF0YS53aWR0aCwgY2FudmFzRGF0YS53aWR0aCwgY2FudmFzRGF0YS5sZWZ0ICsgY2FudmFzRGF0YS53aWR0aCk7XG4gICAgICAgIG1heEhlaWdodCA9IG1pblRvcCArIE1hdGgubWluKGNvbnRhaW5lckRhdGEuaGVpZ2h0LCBjYW52YXNEYXRhLmhlaWdodCwgY2FudmFzRGF0YS50b3AgKyBjYW52YXNEYXRhLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gcG9pbnRlcnNbT2JqZWN0LmtleXMocG9pbnRlcnMpWzBdXTtcbiAgICAgIHZhciByYW5nZSA9IHtcbiAgICAgICAgeDogcG9pbnRlci5lbmRYIC0gcG9pbnRlci5zdGFydFgsXG4gICAgICAgIHk6IHBvaW50ZXIuZW5kWSAtIHBvaW50ZXIuc3RhcnRZXG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hlY2sgPSBmdW5jdGlvbiBjaGVjayhzaWRlKSB7XG4gICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgIGNhc2UgQUNUSU9OX0VBU1Q6XG4gICAgICAgICAgICBpZiAocmlnaHQgKyByYW5nZS54ID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgcmFuZ2UueCA9IG1heFdpZHRoIC0gcmlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBBQ1RJT05fV0VTVDpcbiAgICAgICAgICAgIGlmIChsZWZ0ICsgcmFuZ2UueCA8IG1pbkxlZnQpIHtcbiAgICAgICAgICAgICAgcmFuZ2UueCA9IG1pbkxlZnQgLSBsZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgQUNUSU9OX05PUlRIOlxuICAgICAgICAgICAgaWYgKHRvcCArIHJhbmdlLnkgPCBtaW5Ub3ApIHtcbiAgICAgICAgICAgICAgcmFuZ2UueSA9IG1pblRvcCAtIHRvcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIEFDVElPTl9TT1VUSDpcbiAgICAgICAgICAgIGlmIChib3R0b20gKyByYW5nZS55ID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHJhbmdlLnkgPSBtYXhIZWlnaHQgLSBib3R0b207XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAvLyBNb3ZlIGNyb3AgYm94XG4gICAgICAgIGNhc2UgQUNUSU9OX0FMTDpcbiAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFJlc2l6ZSBjcm9wIGJveFxuXG4gICAgICAgIGNhc2UgQUNUSU9OX0VBU1Q6XG4gICAgICAgICAgaWYgKHJhbmdlLnggPj0gMCAmJiAocmlnaHQgPj0gbWF4V2lkdGggfHwgYXNwZWN0UmF0aW8gJiYgKHRvcCA8PSBtaW5Ub3AgfHwgYm90dG9tID49IG1heEhlaWdodCkpKSB7XG4gICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGVjayhBQ1RJT05fRUFTVCk7XG4gICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcblxuICAgICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9XRVNUO1xuICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIHRvcCArPSAoY3JvcEJveERhdGEuaGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBBQ1RJT05fTk9SVEg6XG4gICAgICAgICAgaWYgKHJhbmdlLnkgPD0gMCAmJiAodG9wIDw9IG1pblRvcCB8fCBhc3BlY3RSYXRpbyAmJiAobGVmdCA8PSBtaW5MZWZ0IHx8IHJpZ2h0ID49IG1heFdpZHRoKSkpIHtcbiAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoZWNrKEFDVElPTl9OT1JUSCk7XG4gICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG5cbiAgICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIO1xuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgbGVmdCArPSAoY3JvcEJveERhdGEud2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQUNUSU9OX1dFU1Q6XG4gICAgICAgICAgaWYgKHJhbmdlLnggPD0gMCAmJiAobGVmdCA8PSBtaW5MZWZ0IHx8IGFzcGVjdFJhdGlvICYmICh0b3AgPD0gbWluVG9wIHx8IGJvdHRvbSA+PSBtYXhIZWlnaHQpKSkge1xuICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hlY2soQUNUSU9OX1dFU1QpO1xuICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgbGVmdCArPSByYW5nZS54O1xuXG4gICAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX0VBU1Q7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgdG9wICs9IChjcm9wQm94RGF0YS5oZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9TT1VUSDpcbiAgICAgICAgICBpZiAocmFuZ2UueSA+PSAwICYmIChib3R0b20gPj0gbWF4SGVpZ2h0IHx8IGFzcGVjdFJhdGlvICYmIChsZWZ0IDw9IG1pbkxlZnQgfHwgcmlnaHQgPj0gbWF4V2lkdGgpKSkge1xuICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hlY2soQUNUSU9OX1NPVVRIKTtcbiAgICAgICAgICBoZWlnaHQgKz0gcmFuZ2UueTtcblxuICAgICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fTk9SVEg7XG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICBsZWZ0ICs9IChjcm9wQm94RGF0YS53aWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBBQ1RJT05fTk9SVEhfRUFTVDpcbiAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIGlmIChyYW5nZS55IDw9IDAgJiYgKHRvcCA8PSBtaW5Ub3AgfHwgcmlnaHQgPj0gbWF4V2lkdGgpKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9OT1JUSCk7XG4gICAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcbiAgICAgICAgICAgIHRvcCArPSByYW5nZS55O1xuICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2soQUNUSU9OX05PUlRIKTtcbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9FQVNUKTtcblxuICAgICAgICAgICAgaWYgKHJhbmdlLnggPj0gMCkge1xuICAgICAgICAgICAgICBpZiAocmlnaHQgPCBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIHdpZHRoICs9IHJhbmdlLng7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UueSA8PSAwICYmIHRvcCA8PSBtaW5Ub3ApIHtcbiAgICAgICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdpZHRoICs9IHJhbmdlLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS55IDw9IDApIHtcbiAgICAgICAgICAgICAgaWYgKHRvcCA+IG1pblRvcCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCAtPSByYW5nZS55O1xuICAgICAgICAgICAgICAgIHRvcCArPSByYW5nZS55O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoZWlnaHQgLT0gcmFuZ2UueTtcbiAgICAgICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdpZHRoIDwgMCAmJiBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fU09VVEhfV0VTVDtcbiAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fTk9SVEhfV0VTVDtcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9FQVNUO1xuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBBQ1RJT05fTk9SVEhfV0VTVDpcbiAgICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIGlmIChyYW5nZS55IDw9IDAgJiYgKHRvcCA8PSBtaW5Ub3AgfHwgbGVmdCA8PSBtaW5MZWZ0KSkge1xuICAgICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fTk9SVEgpO1xuICAgICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgICAgICB0b3AgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICBsZWZ0ICs9IGNyb3BCb3hEYXRhLndpZHRoIC0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9OT1JUSCk7XG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fV0VTVCk7XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS54IDw9IDApIHtcbiAgICAgICAgICAgICAgaWYgKGxlZnQgPiBtaW5MZWZ0KSB7XG4gICAgICAgICAgICAgICAgd2lkdGggLT0gcmFuZ2UueDtcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UueSA8PSAwICYmIHRvcCA8PSBtaW5Ub3ApIHtcbiAgICAgICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgICAgIGxlZnQgKz0gcmFuZ2UueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJhbmdlLnkgPD0gMCkge1xuICAgICAgICAgICAgICBpZiAodG9wID4gbWluVG9wKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0IC09IHJhbmdlLnk7XG4gICAgICAgICAgICAgICAgdG9wICs9IHJhbmdlLnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhlaWdodCAtPSByYW5nZS55O1xuICAgICAgICAgICAgICB0b3AgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod2lkdGggPCAwICYmIGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9FQVNUO1xuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9FQVNUO1xuICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX1NPVVRIX1dFU1Q7XG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9TT1VUSF9XRVNUOlxuICAgICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnggPD0gMCAmJiAobGVmdCA8PSBtaW5MZWZ0IHx8IGJvdHRvbSA+PSBtYXhIZWlnaHQpKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9XRVNUKTtcbiAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fU09VVEgpO1xuICAgICAgICAgICAgY2hlY2soQUNUSU9OX1dFU1QpO1xuXG4gICAgICAgICAgICBpZiAocmFuZ2UueCA8PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChsZWZ0ID4gbWluTGVmdCkge1xuICAgICAgICAgICAgICAgIHdpZHRoIC09IHJhbmdlLng7XG4gICAgICAgICAgICAgICAgbGVmdCArPSByYW5nZS54O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnkgPj0gMCAmJiBib3R0b20gPj0gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aWR0aCAtPSByYW5nZS54O1xuICAgICAgICAgICAgICBsZWZ0ICs9IHJhbmdlLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS55ID49IDApIHtcbiAgICAgICAgICAgICAgaWYgKGJvdHRvbSA8IG1heEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCArPSByYW5nZS55O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoZWlnaHQgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod2lkdGggPCAwICYmIGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9FQVNUO1xuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9TT1VUSF9FQVNUO1xuICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgYWN0aW9uID0gQUNUSU9OX05PUlRIX1dFU1Q7XG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9TT1VUSF9FQVNUOlxuICAgICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnggPj0gMCAmJiAocmlnaHQgPj0gbWF4V2lkdGggfHwgYm90dG9tID49IG1heEhlaWdodCkpIHtcbiAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hlY2soQUNUSU9OX0VBU1QpO1xuICAgICAgICAgICAgd2lkdGggKz0gcmFuZ2UueDtcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrKEFDVElPTl9TT1VUSCk7XG4gICAgICAgICAgICBjaGVjayhBQ1RJT05fRUFTVCk7XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS54ID49IDApIHtcbiAgICAgICAgICAgICAgaWYgKHJpZ2h0IDwgbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCArPSByYW5nZS54O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnkgPj0gMCAmJiBib3R0b20gPj0gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aWR0aCArPSByYW5nZS54O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmFuZ2UueSA+PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChib3R0b20gPCBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgKz0gcmFuZ2UueTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaGVpZ2h0ICs9IHJhbmdlLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdpZHRoIDwgMCAmJiBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fTk9SVEhfV0VTVDtcbiAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBBQ1RJT05fU09VVEhfV0VTVDtcbiAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IEFDVElPTl9OT1JUSF9FQVNUO1xuICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIE1vdmUgY2FudmFzXG5cbiAgICAgICAgY2FzZSBBQ1RJT05fTU9WRTpcbiAgICAgICAgICB0aGlzLm1vdmUocmFuZ2UueCwgcmFuZ2UueSk7XG4gICAgICAgICAgcmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBab29tIGNhbnZhc1xuXG4gICAgICAgIGNhc2UgQUNUSU9OX1pPT006XG4gICAgICAgICAgdGhpcy56b29tKGdldE1heFpvb21SYXRpbyhwb2ludGVycyksIGV2ZW50KTtcbiAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENyZWF0ZSBjcm9wIGJveFxuXG4gICAgICAgIGNhc2UgQUNUSU9OX0NST1A6XG4gICAgICAgICAgaWYgKCFyYW5nZS54IHx8ICFyYW5nZS55KSB7XG4gICAgICAgICAgICByZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvZmZzZXQgPSBnZXRPZmZzZXQodGhpcy5jcm9wcGVyKTtcbiAgICAgICAgICBsZWZ0ID0gcG9pbnRlci5zdGFydFggLSBvZmZzZXQubGVmdDtcbiAgICAgICAgICB0b3AgPSBwb2ludGVyLnN0YXJ0WSAtIG9mZnNldC50b3A7XG4gICAgICAgICAgd2lkdGggPSBjcm9wQm94RGF0YS5taW5XaWR0aDtcbiAgICAgICAgICBoZWlnaHQgPSBjcm9wQm94RGF0YS5taW5IZWlnaHQ7XG5cbiAgICAgICAgICBpZiAocmFuZ2UueCA+IDApIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IHJhbmdlLnkgPiAwID8gQUNUSU9OX1NPVVRIX0VBU1QgOiBBQ1RJT05fTk9SVEhfRUFTVDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnggPCAwKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgICAgYWN0aW9uID0gcmFuZ2UueSA+IDAgPyBBQ1RJT05fU09VVEhfV0VTVCA6IEFDVElPTl9OT1JUSF9XRVNUO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZS55IDwgMCkge1xuICAgICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICB9IC8vIFNob3cgdGhlIGNyb3AgYm94IGlmIGlzIGhpZGRlblxuXG5cbiAgICAgICAgICBpZiAoIXRoaXMuY3JvcHBlZCkge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5jcm9wQm94LCBDTEFTU19ISURERU4pO1xuICAgICAgICAgICAgdGhpcy5jcm9wcGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubGltaXRlZCkge1xuICAgICAgICAgICAgICB0aGlzLmxpbWl0Q3JvcEJveCh0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbmRlcmFibGUpIHtcbiAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBjcm9wQm94RGF0YS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgY3JvcEJveERhdGEudG9wID0gdG9wO1xuICAgICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICB9IC8vIE92ZXJyaWRlXG5cblxuICAgICAgZm9yRWFjaChwb2ludGVycywgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC5zdGFydFggPSBwLmVuZFg7XG4gICAgICAgIHAuc3RhcnRZID0gcC5lbmRZO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBtZXRob2RzID0ge1xuICAgIC8vIFNob3cgdGhlIGNyb3AgYm94IG1hbnVhbGx5XG4gICAgY3JvcDogZnVuY3Rpb24gY3JvcCgpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmNyb3BwZWQgJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jcm9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saW1pdENyb3BCb3godHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tb2RhbCkge1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMuZHJhZ0JveCwgQ0xBU1NfTU9EQUwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5jcm9wQm94LCBDTEFTU19ISURERU4pO1xuICAgICAgICB0aGlzLnNldENyb3BCb3hEYXRhKHRoaXMuaW5pdGlhbENyb3BCb3hEYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBSZXNldCB0aGUgaW1hZ2UgYW5kIGNyb3AgYm94IHRvIHRoZWlyIGluaXRpYWwgc3RhdGVzXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5pbWFnZURhdGEgPSBhc3NpZ24oe30sIHRoaXMuaW5pdGlhbEltYWdlRGF0YSk7XG4gICAgICAgIHRoaXMuY2FudmFzRGF0YSA9IGFzc2lnbih7fSwgdGhpcy5pbml0aWFsQ2FudmFzRGF0YSk7XG4gICAgICAgIHRoaXMuY3JvcEJveERhdGEgPSBhc3NpZ24oe30sIHRoaXMuaW5pdGlhbENyb3BCb3hEYXRhKTtcbiAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMoKTtcblxuICAgICAgICBpZiAodGhpcy5jcm9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBDbGVhciB0aGUgY3JvcCBib3hcbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBpZiAodGhpcy5jcm9wcGVkICYmICF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIGFzc2lnbih0aGlzLmNyb3BCb3hEYXRhLCB7XG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNyb3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICAgIHRoaXMubGltaXRDYW52YXModHJ1ZSwgdHJ1ZSk7IC8vIFJlbmRlciBjYW52YXMgYWZ0ZXIgY3JvcCBib3ggcmVuZGVyZWRcblxuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcygpO1xuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmRyYWdCb3gsIENMQVNTX01PREFMKTtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy5jcm9wQm94LCBDTEFTU19ISURERU4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgaW1hZ2UncyBzcmMgYW5kIHJlYnVpbGQgdGhlIGNyb3BwZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIG5ldyBVUkwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaGFzU2FtZVNpemVdIC0gSW5kaWNhdGUgaWYgdGhlIG5ldyBpbWFnZSBoYXMgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgb2xkIG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2UodXJsKSB7XG4gICAgICB2YXIgaGFzU2FtZVNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgdXJsKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW1nKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LnNyYyA9IHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNTYW1lU2l6ZSkge1xuICAgICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICAgIHRoaXMuaW1hZ2Uuc3JjID0gdXJsO1xuXG4gICAgICAgICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0JveEltYWdlLnNyYyA9IHVybDtcbiAgICAgICAgICAgIGZvckVhY2godGhpcy5wcmV2aWV3cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJylbMF0uc3JjID0gdXJsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmlzSW1nKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZGF0YSA9IG51bGw7XG4gICAgICAgICAgdGhpcy51bmNyZWF0ZSgpO1xuICAgICAgICAgIHRoaXMubG9hZCh1cmwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gRW5hYmxlICh1bmZyZWV6ZSkgdGhlIGNyb3BwZXJcbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmIHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmNyb3BwZXIsIENMQVNTX0RJU0FCTEVEKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBEaXNhYmxlIChmcmVlemUpIHRoZSBjcm9wcGVyXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBhZGRDbGFzcyh0aGlzLmNyb3BwZXIsIENMQVNTX0RJU0FCTEVEKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIGNyb3BwZXIgYW5kIHJlbW92ZSB0aGUgaW5zdGFuY2UgZnJvbSB0aGUgaW1hZ2VcbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICAgICAgaWYgKCFlbGVtZW50W05BTUVTUEFDRV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnRbTkFNRVNQQUNFXSA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHRoaXMuaXNJbWcgJiYgdGhpcy5yZXBsYWNlZCkge1xuICAgICAgICBlbGVtZW50LnNyYyA9IHRoaXMub3JpZ2luYWxVcmw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudW5jcmVhdGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBjYW52YXMgd2l0aCByZWxhdGl2ZSBvZmZzZXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBUaGUgcmVsYXRpdmUgb2Zmc2V0IGRpc3RhbmNlIG9uIHRoZSB4LWF4aXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRZPW9mZnNldFhdIC0gVGhlIHJlbGF0aXZlIG9mZnNldCBkaXN0YW5jZSBvbiB0aGUgeS1heGlzLlxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAgICovXG4gICAgbW92ZTogZnVuY3Rpb24gbW92ZShvZmZzZXRYKSB7XG4gICAgICB2YXIgb2Zmc2V0WSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogb2Zmc2V0WDtcbiAgICAgIHZhciBfdGhpcyRjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhLFxuICAgICAgICAgIGxlZnQgPSBfdGhpcyRjYW52YXNEYXRhLmxlZnQsXG4gICAgICAgICAgdG9wID0gX3RoaXMkY2FudmFzRGF0YS50b3A7XG4gICAgICByZXR1cm4gdGhpcy5tb3ZlVG8oaXNVbmRlZmluZWQob2Zmc2V0WCkgPyBvZmZzZXRYIDogbGVmdCArIE51bWJlcihvZmZzZXRYKSwgaXNVbmRlZmluZWQob2Zmc2V0WSkgPyBvZmZzZXRZIDogdG9wICsgTnVtYmVyKG9mZnNldFkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0aGUgY2FudmFzIHRvIGFuIGFic29sdXRlIHBvaW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeC1heGlzIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PXhdIC0gVGhlIHktYXhpcyBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAgICovXG4gICAgbW92ZVRvOiBmdW5jdGlvbiBtb3ZlVG8oeCkge1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHg7XG4gICAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICB4ID0gTnVtYmVyKHgpO1xuICAgICAgeSA9IE51bWJlcih5KTtcblxuICAgICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5vcHRpb25zLm1vdmFibGUpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKHgpKSB7XG4gICAgICAgICAgY2FudmFzRGF0YS5sZWZ0ID0geDtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcih5KSkge1xuICAgICAgICAgIGNhbnZhc0RhdGEudG9wID0geTtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJDYW52YXModHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFpvb20gdGhlIGNhbnZhcyB3aXRoIGEgcmVsYXRpdmUgcmF0aW9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gLSBUaGUgdGFyZ2V0IHJhdGlvLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IF9vcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIGV2ZW50IGlmIGFueS5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHpvb206IGZ1bmN0aW9uIHpvb20ocmF0aW8sIF9vcmlnaW5hbEV2ZW50KSB7XG4gICAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcbiAgICAgIHJhdGlvID0gTnVtYmVyKHJhdGlvKTtcblxuICAgICAgaWYgKHJhdGlvIDwgMCkge1xuICAgICAgICByYXRpbyA9IDEgLyAoMSAtIHJhdGlvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhdGlvID0gMSArIHJhdGlvO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy56b29tVG8oY2FudmFzRGF0YS53aWR0aCAqIHJhdGlvIC8gY2FudmFzRGF0YS5uYXR1cmFsV2lkdGgsIG51bGwsIF9vcmlnaW5hbEV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbSB0aGUgY2FudmFzIHRvIGFuIGFic29sdXRlIHJhdGlvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIC0gVGhlIHRhcmdldCByYXRpby5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGl2b3QgLSBUaGUgem9vbSBwaXZvdCBwb2ludCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IF9vcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIGV2ZW50IGlmIGFueS5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHpvb21UbzogZnVuY3Rpb24gem9vbVRvKHJhdGlvLCBwaXZvdCwgX29yaWdpbmFsRXZlbnQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XG4gICAgICB2YXIgd2lkdGggPSBjYW52YXNEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGNhbnZhc0RhdGEuaGVpZ2h0LFxuICAgICAgICAgIG5hdHVyYWxXaWR0aCA9IGNhbnZhc0RhdGEubmF0dXJhbFdpZHRoLFxuICAgICAgICAgIG5hdHVyYWxIZWlnaHQgPSBjYW52YXNEYXRhLm5hdHVyYWxIZWlnaHQ7XG4gICAgICByYXRpbyA9IE51bWJlcihyYXRpbyk7XG5cbiAgICAgIGlmIChyYXRpbyA+PSAwICYmIHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQgJiYgb3B0aW9ucy56b29tYWJsZSkge1xuICAgICAgICB2YXIgbmV3V2lkdGggPSBuYXR1cmFsV2lkdGggKiByYXRpbztcbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IG5hdHVyYWxIZWlnaHQgKiByYXRpbztcblxuICAgICAgICBpZiAoZGlzcGF0Y2hFdmVudCh0aGlzLmVsZW1lbnQsIEVWRU5UX1pPT00sIHtcbiAgICAgICAgICByYXRpbzogcmF0aW8sXG4gICAgICAgICAgb2xkUmF0aW86IHdpZHRoIC8gbmF0dXJhbFdpZHRoLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IF9vcmlnaW5hbEV2ZW50XG4gICAgICAgIH0pID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgdmFyIHBvaW50ZXJzID0gdGhpcy5wb2ludGVycztcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gZ2V0T2Zmc2V0KHRoaXMuY3JvcHBlcik7XG4gICAgICAgICAgdmFyIGNlbnRlciA9IHBvaW50ZXJzICYmIE9iamVjdC5rZXlzKHBvaW50ZXJzKS5sZW5ndGggPyBnZXRQb2ludGVyc0NlbnRlcihwb2ludGVycykgOiB7XG4gICAgICAgICAgICBwYWdlWDogX29yaWdpbmFsRXZlbnQucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogX29yaWdpbmFsRXZlbnQucGFnZVlcbiAgICAgICAgICB9OyAvLyBab29tIGZyb20gdGhlIHRyaWdnZXJpbmcgcG9pbnQgb2YgdGhlIGV2ZW50XG5cbiAgICAgICAgICBjYW52YXNEYXRhLmxlZnQgLT0gKG5ld1dpZHRoIC0gd2lkdGgpICogKChjZW50ZXIucGFnZVggLSBvZmZzZXQubGVmdCAtIGNhbnZhc0RhdGEubGVmdCkgLyB3aWR0aCk7XG4gICAgICAgICAgY2FudmFzRGF0YS50b3AgLT0gKG5ld0hlaWdodCAtIGhlaWdodCkgKiAoKGNlbnRlci5wYWdlWSAtIG9mZnNldC50b3AgLSBjYW52YXNEYXRhLnRvcCkgLyBoZWlnaHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocGl2b3QpICYmIGlzTnVtYmVyKHBpdm90LngpICYmIGlzTnVtYmVyKHBpdm90LnkpKSB7XG4gICAgICAgICAgY2FudmFzRGF0YS5sZWZ0IC09IChuZXdXaWR0aCAtIHdpZHRoKSAqICgocGl2b3QueCAtIGNhbnZhc0RhdGEubGVmdCkgLyB3aWR0aCk7XG4gICAgICAgICAgY2FudmFzRGF0YS50b3AgLT0gKG5ld0hlaWdodCAtIGhlaWdodCkgKiAoKHBpdm90LnkgLSBjYW52YXNEYXRhLnRvcCkgLyBoZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFpvb20gZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBjYW52YXNcbiAgICAgICAgICBjYW52YXNEYXRhLmxlZnQgLT0gKG5ld1dpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICBjYW52YXNEYXRhLnRvcCAtPSAobmV3SGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBjYW52YXNEYXRhLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgIGNhbnZhc0RhdGEuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSB0aGUgY2FudmFzIHdpdGggYSByZWxhdGl2ZSBkZWdyZWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVncmVlIC0gVGhlIHJvdGF0ZSBkZWdyZWUuXG4gICAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByb3RhdGU6IGZ1bmN0aW9uIHJvdGF0ZShkZWdyZWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvdGF0ZVRvKCh0aGlzLmltYWdlRGF0YS5yb3RhdGUgfHwgMCkgKyBOdW1iZXIoZGVncmVlKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSB0aGUgY2FudmFzIHRvIGFuIGFic29sdXRlIGRlZ3JlZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWUgLSBUaGUgcm90YXRlIGRlZ3JlZS5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHJvdGF0ZVRvOiBmdW5jdGlvbiByb3RhdGVUbyhkZWdyZWUpIHtcbiAgICAgIGRlZ3JlZSA9IE51bWJlcihkZWdyZWUpO1xuXG4gICAgICBpZiAoaXNOdW1iZXIoZGVncmVlKSAmJiB0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkICYmIHRoaXMub3B0aW9ucy5yb3RhdGFibGUpIHtcbiAgICAgICAgdGhpcy5pbWFnZURhdGEucm90YXRlID0gZGVncmVlICUgMzYwO1xuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIHRoZSBpbWFnZSBvbiB0aGUgeC1heGlzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVggLSBUaGUgc2NhbGUgcmF0aW8gb24gdGhlIHgtYXhpcy5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHNjYWxlWDogZnVuY3Rpb24gc2NhbGVYKF9zY2FsZVgpIHtcbiAgICAgIHZhciBzY2FsZVkgPSB0aGlzLmltYWdlRGF0YS5zY2FsZVk7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZShfc2NhbGVYLCBpc051bWJlcihzY2FsZVkpID8gc2NhbGVZIDogMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIHRoZSBpbWFnZSBvbiB0aGUgeS1heGlzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVkgLSBUaGUgc2NhbGUgcmF0aW8gb24gdGhlIHktYXhpcy5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHNjYWxlWTogZnVuY3Rpb24gc2NhbGVZKF9zY2FsZVkpIHtcbiAgICAgIHZhciBzY2FsZVggPSB0aGlzLmltYWdlRGF0YS5zY2FsZVg7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZShpc051bWJlcihzY2FsZVgpID8gc2NhbGVYIDogMSwgX3NjYWxlWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVggLSBUaGUgc2NhbGUgcmF0aW8gb24gdGhlIHgtYXhpcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlWT1zY2FsZVhdIC0gVGhlIHNjYWxlIHJhdGlvIG9uIHRoZSB5LWF4aXMuXG4gICAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBzY2FsZTogZnVuY3Rpb24gc2NhbGUoc2NhbGVYKSB7XG4gICAgICB2YXIgc2NhbGVZID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBzY2FsZVg7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gdGhpcy5pbWFnZURhdGE7XG4gICAgICB2YXIgdHJhbnNmb3JtZWQgPSBmYWxzZTtcbiAgICAgIHNjYWxlWCA9IE51bWJlcihzY2FsZVgpO1xuICAgICAgc2NhbGVZID0gTnVtYmVyKHNjYWxlWSk7XG5cbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkICYmIHRoaXMub3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoc2NhbGVYKSkge1xuICAgICAgICAgIGltYWdlRGF0YS5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgICAgdHJhbnNmb3JtZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjYWxlWSkpIHtcbiAgICAgICAgICBpbWFnZURhdGEuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICAgIHRyYW5zZm9ybWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyQ2FudmFzKHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNyb3BwZWQgYXJlYSBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhIChiYXNlIG9uIHRoZSBvcmlnaW5hbCBpbWFnZSlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyb3VuZGVkPWZhbHNlXSAtIEluZGljYXRlIGlmIHJvdW5kIHRoZSBkYXRhIHZhbHVlcyBvciBub3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBjcm9wcGVkIGRhdGEuXG4gICAgICovXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgICAgIHZhciByb3VuZGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGEsXG4gICAgICAgICAgY3JvcEJveERhdGEgPSB0aGlzLmNyb3BCb3hEYXRhO1xuICAgICAgdmFyIGRhdGE7XG5cbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmIHRoaXMuY3JvcHBlZCkge1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgIHg6IGNyb3BCb3hEYXRhLmxlZnQgLSBjYW52YXNEYXRhLmxlZnQsXG4gICAgICAgICAgeTogY3JvcEJveERhdGEudG9wIC0gY2FudmFzRGF0YS50b3AsXG4gICAgICAgICAgd2lkdGg6IGNyb3BCb3hEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogY3JvcEJveERhdGEuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIHZhciByYXRpbyA9IGltYWdlRGF0YS53aWR0aCAvIGltYWdlRGF0YS5uYXR1cmFsV2lkdGg7XG4gICAgICAgIGZvckVhY2goZGF0YSwgZnVuY3Rpb24gKG4sIGkpIHtcbiAgICAgICAgICBkYXRhW2ldID0gbiAvIHJhdGlvO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocm91bmRlZCkge1xuICAgICAgICAgIC8vIEluIGNhc2Ugcm91bmRpbmcgb2ZmIGxlYWRzIHRvIGV4dHJhIDFweCBpbiByaWdodCBvciBib3R0b20gYm9yZGVyXG4gICAgICAgICAgLy8gd2Ugc2hvdWxkIHJvdW5kIHRoZSB0b3AtbGVmdCBjb3JuZXIgYW5kIHRoZSBkaW1lbnNpb24gKCMzNDMpLlxuICAgICAgICAgIHZhciBib3R0b20gPSBNYXRoLnJvdW5kKGRhdGEueSArIGRhdGEuaGVpZ2h0KTtcbiAgICAgICAgICB2YXIgcmlnaHQgPSBNYXRoLnJvdW5kKGRhdGEueCArIGRhdGEud2lkdGgpO1xuICAgICAgICAgIGRhdGEueCA9IE1hdGgucm91bmQoZGF0YS54KTtcbiAgICAgICAgICBkYXRhLnkgPSBNYXRoLnJvdW5kKGRhdGEueSk7XG4gICAgICAgICAgZGF0YS53aWR0aCA9IHJpZ2h0IC0gZGF0YS54O1xuICAgICAgICAgIGRhdGEuaGVpZ2h0ID0gYm90dG9tIC0gZGF0YS55O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucm90YXRhYmxlKSB7XG4gICAgICAgIGRhdGEucm90YXRlID0gaW1hZ2VEYXRhLnJvdGF0ZSB8fCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgICBkYXRhLnNjYWxlWCA9IGltYWdlRGF0YS5zY2FsZVggfHwgMTtcbiAgICAgICAgZGF0YS5zY2FsZVkgPSBpbWFnZURhdGEuc2NhbGVZIHx8IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNyb3BwZWQgYXJlYSBwb3NpdGlvbiBhbmQgc2l6ZSB3aXRoIG5ldyBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgbmV3IGRhdGEuXG4gICAgICogQHJldHVybnMge0Nyb3BwZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKGRhdGEpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGltYWdlRGF0YSA9IHRoaXMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XG4gICAgICB2YXIgY3JvcEJveERhdGEgPSB7fTtcblxuICAgICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQgJiYgaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAob3B0aW9ucy5yb3RhdGFibGUpIHtcbiAgICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5yb3RhdGUpICYmIGRhdGEucm90YXRlICE9PSBpbWFnZURhdGEucm90YXRlKSB7XG4gICAgICAgICAgICBpbWFnZURhdGEucm90YXRlID0gZGF0YS5yb3RhdGU7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5zY2FsZVgpICYmIGRhdGEuc2NhbGVYICE9PSBpbWFnZURhdGEuc2NhbGVYKSB7XG4gICAgICAgICAgICBpbWFnZURhdGEuc2NhbGVYID0gZGF0YS5zY2FsZVg7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuc2NhbGVZKSAmJiBkYXRhLnNjYWxlWSAhPT0gaW1hZ2VEYXRhLnNjYWxlWSkge1xuICAgICAgICAgICAgaW1hZ2VEYXRhLnNjYWxlWSA9IGRhdGEuc2NhbGVZO1xuICAgICAgICAgICAgdHJhbnNmb3JtZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyQ2FudmFzKHRydWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhdGlvID0gaW1hZ2VEYXRhLndpZHRoIC8gaW1hZ2VEYXRhLm5hdHVyYWxXaWR0aDtcblxuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS54KSkge1xuICAgICAgICAgIGNyb3BCb3hEYXRhLmxlZnQgPSBkYXRhLnggKiByYXRpbyArIGNhbnZhc0RhdGEubGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLnkpKSB7XG4gICAgICAgICAgY3JvcEJveERhdGEudG9wID0gZGF0YS55ICogcmF0aW8gKyBjYW52YXNEYXRhLnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLndpZHRoKSkge1xuICAgICAgICAgIGNyb3BCb3hEYXRhLndpZHRoID0gZGF0YS53aWR0aCAqIHJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSkge1xuICAgICAgICAgIGNyb3BCb3hEYXRhLmhlaWdodCA9IGRhdGEuaGVpZ2h0ICogcmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldENyb3BCb3hEYXRhKGNyb3BCb3hEYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29udGFpbmVyIHNpemUgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IGNvbnRhaW5lciBkYXRhLlxuICAgICAqL1xuICAgIGdldENvbnRhaW5lckRhdGE6IGZ1bmN0aW9uIGdldENvbnRhaW5lckRhdGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkeSA/IGFzc2lnbih7fSwgdGhpcy5jb250YWluZXJEYXRhKSA6IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGltYWdlIHBvc2l0aW9uIGFuZCBzaXplIGRhdGEuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdCBpbWFnZSBkYXRhLlxuICAgICAqL1xuICAgIGdldEltYWdlRGF0YTogZnVuY3Rpb24gZ2V0SW1hZ2VEYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZWQgPyBhc3NpZ24oe30sIHRoaXMuaW1hZ2VEYXRhKSA6IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNhbnZhcyBwb3NpdGlvbiBhbmQgc2l6ZSBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgY2FudmFzIGRhdGEuXG4gICAgICovXG4gICAgZ2V0Q2FudmFzRGF0YTogZnVuY3Rpb24gZ2V0Q2FudmFzRGF0YSgpIHtcbiAgICAgIHZhciBjYW52YXNEYXRhID0gdGhpcy5jYW52YXNEYXRhO1xuICAgICAgdmFyIGRhdGEgPSB7fTtcblxuICAgICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgICAgZm9yRWFjaChbJ2xlZnQnLCAndG9wJywgJ3dpZHRoJywgJ2hlaWdodCcsICduYXR1cmFsV2lkdGgnLCAnbmF0dXJhbEhlaWdodCddLCBmdW5jdGlvbiAobikge1xuICAgICAgICAgIGRhdGFbbl0gPSBjYW52YXNEYXRhW25dO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY2FudmFzIHBvc2l0aW9uIGFuZCBzaXplIHdpdGggbmV3IGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgbmV3IGNhbnZhcyBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAgICovXG4gICAgc2V0Q2FudmFzRGF0YTogZnVuY3Rpb24gc2V0Q2FudmFzRGF0YShkYXRhKSB7XG4gICAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMuY2FudmFzRGF0YTtcbiAgICAgIHZhciBhc3BlY3RSYXRpbyA9IGNhbnZhc0RhdGEuYXNwZWN0UmF0aW87XG5cbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmICF0aGlzLmRpc2FibGVkICYmIGlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEubGVmdCkpIHtcbiAgICAgICAgICBjYW52YXNEYXRhLmxlZnQgPSBkYXRhLmxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS50b3ApKSB7XG4gICAgICAgICAgY2FudmFzRGF0YS50b3AgPSBkYXRhLnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLndpZHRoKSkge1xuICAgICAgICAgIGNhbnZhc0RhdGEud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgICAgIGNhbnZhc0RhdGEuaGVpZ2h0ID0gZGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSkge1xuICAgICAgICAgIGNhbnZhc0RhdGEuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICAgICAgY2FudmFzRGF0YS53aWR0aCA9IGRhdGEuaGVpZ2h0ICogYXNwZWN0UmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3JvcCBib3ggcG9zaXRpb24gYW5kIHNpemUgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0IGNyb3AgYm94IGRhdGEuXG4gICAgICovXG4gICAgZ2V0Q3JvcEJveERhdGE6IGZ1bmN0aW9uIGdldENyb3BCb3hEYXRhKCkge1xuICAgICAgdmFyIGNyb3BCb3hEYXRhID0gdGhpcy5jcm9wQm94RGF0YTtcbiAgICAgIHZhciBkYXRhO1xuXG4gICAgICBpZiAodGhpcy5yZWFkeSAmJiB0aGlzLmNyb3BwZWQpIHtcbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICBsZWZ0OiBjcm9wQm94RGF0YS5sZWZ0LFxuICAgICAgICAgIHRvcDogY3JvcEJveERhdGEudG9wLFxuICAgICAgICAgIHdpZHRoOiBjcm9wQm94RGF0YS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNyb3BCb3hEYXRhLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YSB8fCB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjcm9wIGJveCBwb3NpdGlvbiBhbmQgc2l6ZSB3aXRoIG5ldyBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIG5ldyBjcm9wIGJveCBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAgICovXG4gICAgc2V0Q3JvcEJveERhdGE6IGZ1bmN0aW9uIHNldENyb3BCb3hEYXRhKGRhdGEpIHtcbiAgICAgIHZhciBjcm9wQm94RGF0YSA9IHRoaXMuY3JvcEJveERhdGE7XG4gICAgICB2YXIgYXNwZWN0UmF0aW8gPSB0aGlzLm9wdGlvbnMuYXNwZWN0UmF0aW87XG4gICAgICB2YXIgd2lkdGhDaGFuZ2VkO1xuICAgICAgdmFyIGhlaWdodENoYW5nZWQ7XG5cbiAgICAgIGlmICh0aGlzLnJlYWR5ICYmIHRoaXMuY3JvcHBlZCAmJiAhdGhpcy5kaXNhYmxlZCAmJiBpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLmxlZnQpKSB7XG4gICAgICAgICAgY3JvcEJveERhdGEubGVmdCA9IGRhdGEubGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLnRvcCkpIHtcbiAgICAgICAgICBjcm9wQm94RGF0YS50b3AgPSBkYXRhLnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcihkYXRhLndpZHRoKSAmJiBkYXRhLndpZHRoICE9PSBjcm9wQm94RGF0YS53aWR0aCkge1xuICAgICAgICAgIHdpZHRoQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSAmJiBkYXRhLmhlaWdodCAhPT0gY3JvcEJveERhdGEuaGVpZ2h0KSB7XG4gICAgICAgICAgaGVpZ2h0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgY3JvcEJveERhdGEuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBpZiAod2lkdGhDaGFuZ2VkKSB7XG4gICAgICAgICAgICBjcm9wQm94RGF0YS5oZWlnaHQgPSBjcm9wQm94RGF0YS53aWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0Q2hhbmdlZCkge1xuICAgICAgICAgICAgY3JvcEJveERhdGEud2lkdGggPSBjcm9wQm94RGF0YS5oZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlckNyb3BCb3goKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGNhbnZhcyBkcmF3biB0aGUgY3JvcHBlZCBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gVGhlIGNvbmZpZyBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH0gLSBUaGUgcmVzdWx0IGNhbnZhcy5cbiAgICAgKi9cbiAgICBnZXRDcm9wcGVkQ2FudmFzOiBmdW5jdGlvbiBnZXRDcm9wcGVkQ2FudmFzKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBpZiAoIXRoaXMucmVhZHkgfHwgIXdpbmRvdy5IVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbnZhc0RhdGEgPSB0aGlzLmNhbnZhc0RhdGE7XG4gICAgICB2YXIgc291cmNlID0gZ2V0U291cmNlQ2FudmFzKHRoaXMuaW1hZ2UsIHRoaXMuaW1hZ2VEYXRhLCBjYW52YXNEYXRhLCBvcHRpb25zKTsgLy8gUmV0dXJucyB0aGUgc291cmNlIGNhbnZhcyBpZiBpdCBpcyBub3QgY3JvcHBlZC5cblxuICAgICAgaWYgKCF0aGlzLmNyb3BwZWQpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJGdldERhdGEgPSB0aGlzLmdldERhdGEoKSxcbiAgICAgICAgICBpbml0aWFsWCA9IF90aGlzJGdldERhdGEueCxcbiAgICAgICAgICBpbml0aWFsWSA9IF90aGlzJGdldERhdGEueSxcbiAgICAgICAgICBpbml0aWFsV2lkdGggPSBfdGhpcyRnZXREYXRhLndpZHRoLFxuICAgICAgICAgIGluaXRpYWxIZWlnaHQgPSBfdGhpcyRnZXREYXRhLmhlaWdodDtcblxuICAgICAgdmFyIHJhdGlvID0gc291cmNlLndpZHRoIC8gTWF0aC5mbG9vcihjYW52YXNEYXRhLm5hdHVyYWxXaWR0aCk7XG5cbiAgICAgIGlmIChyYXRpbyAhPT0gMSkge1xuICAgICAgICBpbml0aWFsWCAqPSByYXRpbztcbiAgICAgICAgaW5pdGlhbFkgKj0gcmF0aW87XG4gICAgICAgIGluaXRpYWxXaWR0aCAqPSByYXRpbztcbiAgICAgICAgaW5pdGlhbEhlaWdodCAqPSByYXRpbztcbiAgICAgIH1cblxuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gaW5pdGlhbFdpZHRoIC8gaW5pdGlhbEhlaWdodDtcbiAgICAgIHZhciBtYXhTaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgICAgIHdpZHRoOiBvcHRpb25zLm1heFdpZHRoIHx8IEluZmluaXR5LFxuICAgICAgICBoZWlnaHQ6IG9wdGlvbnMubWF4SGVpZ2h0IHx8IEluZmluaXR5XG4gICAgICB9KTtcbiAgICAgIHZhciBtaW5TaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgICAgIHdpZHRoOiBvcHRpb25zLm1pbldpZHRoIHx8IDAsXG4gICAgICAgIGhlaWdodDogb3B0aW9ucy5taW5IZWlnaHQgfHwgMFxuICAgICAgfSwgJ2NvdmVyJyk7XG5cbiAgICAgIHZhciBfZ2V0QWRqdXN0ZWRTaXplcyA9IGdldEFkanVzdGVkU2l6ZXMoe1xuICAgICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoIHx8IChyYXRpbyAhPT0gMSA/IHNvdXJjZS53aWR0aCA6IGluaXRpYWxXaWR0aCksXG4gICAgICAgIGhlaWdodDogb3B0aW9ucy5oZWlnaHQgfHwgKHJhdGlvICE9PSAxID8gc291cmNlLmhlaWdodCA6IGluaXRpYWxIZWlnaHQpXG4gICAgICB9KSxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRBZGp1c3RlZFNpemVzLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9nZXRBZGp1c3RlZFNpemVzLmhlaWdodDtcblxuICAgICAgd2lkdGggPSBNYXRoLm1pbihtYXhTaXplcy53aWR0aCwgTWF0aC5tYXgobWluU2l6ZXMud2lkdGgsIHdpZHRoKSk7XG4gICAgICBoZWlnaHQgPSBNYXRoLm1pbihtYXhTaXplcy5oZWlnaHQsIE1hdGgubWF4KG1pblNpemVzLmhlaWdodCwgaGVpZ2h0KSk7XG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY2FudmFzLndpZHRoID0gbm9ybWFsaXplRGVjaW1hbE51bWJlcih3aWR0aCk7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gbm9ybWFsaXplRGVjaW1hbE51bWJlcihoZWlnaHQpO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBfb3B0aW9ucyRpbWFnZVNtb290aGkgPSBvcHRpb25zLmltYWdlU21vb3RoaW5nRW5hYmxlZCxcbiAgICAgICAgICBpbWFnZVNtb290aGluZ0VuYWJsZWQgPSBfb3B0aW9ucyRpbWFnZVNtb290aGkgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRpbWFnZVNtb290aGksXG4gICAgICAgICAgaW1hZ2VTbW9vdGhpbmdRdWFsaXR5ID0gb3B0aW9ucy5pbWFnZVNtb290aGluZ1F1YWxpdHk7XG4gICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGltYWdlU21vb3RoaW5nRW5hYmxlZDtcblxuICAgICAgaWYgKGltYWdlU21vb3RoaW5nUXVhbGl0eSkge1xuICAgICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nUXVhbGl0eSA9IGltYWdlU21vb3RoaW5nUXVhbGl0eTtcbiAgICAgIH0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5kcmF3SW1hZ2VcblxuXG4gICAgICB2YXIgc291cmNlV2lkdGggPSBzb3VyY2Uud2lkdGg7XG4gICAgICB2YXIgc291cmNlSGVpZ2h0ID0gc291cmNlLmhlaWdodDsgLy8gU291cmNlIGNhbnZhcyBwYXJhbWV0ZXJzXG5cbiAgICAgIHZhciBzcmNYID0gaW5pdGlhbFg7XG4gICAgICB2YXIgc3JjWSA9IGluaXRpYWxZO1xuICAgICAgdmFyIHNyY1dpZHRoO1xuICAgICAgdmFyIHNyY0hlaWdodDsgLy8gRGVzdGluYXRpb24gY2FudmFzIHBhcmFtZXRlcnNcblxuICAgICAgdmFyIGRzdFg7XG4gICAgICB2YXIgZHN0WTtcbiAgICAgIHZhciBkc3RXaWR0aDtcbiAgICAgIHZhciBkc3RIZWlnaHQ7XG5cbiAgICAgIGlmIChzcmNYIDw9IC1pbml0aWFsV2lkdGggfHwgc3JjWCA+IHNvdXJjZVdpZHRoKSB7XG4gICAgICAgIHNyY1ggPSAwO1xuICAgICAgICBzcmNXaWR0aCA9IDA7XG4gICAgICAgIGRzdFggPSAwO1xuICAgICAgICBkc3RXaWR0aCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHNyY1ggPD0gMCkge1xuICAgICAgICBkc3RYID0gLXNyY1g7XG4gICAgICAgIHNyY1ggPSAwO1xuICAgICAgICBzcmNXaWR0aCA9IE1hdGgubWluKHNvdXJjZVdpZHRoLCBpbml0aWFsV2lkdGggKyBzcmNYKTtcbiAgICAgICAgZHN0V2lkdGggPSBzcmNXaWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoc3JjWCA8PSBzb3VyY2VXaWR0aCkge1xuICAgICAgICBkc3RYID0gMDtcbiAgICAgICAgc3JjV2lkdGggPSBNYXRoLm1pbihpbml0aWFsV2lkdGgsIHNvdXJjZVdpZHRoIC0gc3JjWCk7XG4gICAgICAgIGRzdFdpZHRoID0gc3JjV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcmNXaWR0aCA8PSAwIHx8IHNyY1kgPD0gLWluaXRpYWxIZWlnaHQgfHwgc3JjWSA+IHNvdXJjZUhlaWdodCkge1xuICAgICAgICBzcmNZID0gMDtcbiAgICAgICAgc3JjSGVpZ2h0ID0gMDtcbiAgICAgICAgZHN0WSA9IDA7XG4gICAgICAgIGRzdEhlaWdodCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHNyY1kgPD0gMCkge1xuICAgICAgICBkc3RZID0gLXNyY1k7XG4gICAgICAgIHNyY1kgPSAwO1xuICAgICAgICBzcmNIZWlnaHQgPSBNYXRoLm1pbihzb3VyY2VIZWlnaHQsIGluaXRpYWxIZWlnaHQgKyBzcmNZKTtcbiAgICAgICAgZHN0SGVpZ2h0ID0gc3JjSGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChzcmNZIDw9IHNvdXJjZUhlaWdodCkge1xuICAgICAgICBkc3RZID0gMDtcbiAgICAgICAgc3JjSGVpZ2h0ID0gTWF0aC5taW4oaW5pdGlhbEhlaWdodCwgc291cmNlSGVpZ2h0IC0gc3JjWSk7XG4gICAgICAgIGRzdEhlaWdodCA9IHNyY0hlaWdodDtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmFtcyA9IFtzcmNYLCBzcmNZLCBzcmNXaWR0aCwgc3JjSGVpZ2h0XTsgLy8gQXZvaWQgXCJJbmRleFNpemVFcnJvclwiXG5cbiAgICAgIGlmIChkc3RXaWR0aCA+IDAgJiYgZHN0SGVpZ2h0ID4gMCkge1xuICAgICAgICB2YXIgc2NhbGUgPSB3aWR0aCAvIGluaXRpYWxXaWR0aDtcbiAgICAgICAgcGFyYW1zLnB1c2goZHN0WCAqIHNjYWxlLCBkc3RZICogc2NhbGUsIGRzdFdpZHRoICogc2NhbGUsIGRzdEhlaWdodCAqIHNjYWxlKTtcbiAgICAgIH0gLy8gQWxsIHRoZSBudW1lcmljYWwgcGFyYW1ldGVycyBzaG91bGQgYmUgaW50ZWdlciBmb3IgYGRyYXdJbWFnZWBcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZW5neXVhbmNoZW4vY3JvcHBlci9pc3N1ZXMvNDc2XG5cblxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UuYXBwbHkoY29udGV4dCwgW3NvdXJjZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihub3JtYWxpemVEZWNpbWFsTnVtYmVyKHBhcmFtKSk7XG4gICAgICB9KSkpKTtcbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBjcm9wIGJveC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0UmF0aW8gLSBUaGUgbmV3IGFzcGVjdCByYXRpby5cbiAgICAgKiBAcmV0dXJucyB7Q3JvcHBlcn0gdGhpc1xuICAgICAqL1xuICAgIHNldEFzcGVjdFJhdGlvOiBmdW5jdGlvbiBzZXRBc3BlY3RSYXRpbyhhc3BlY3RSYXRpbykge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiAhaXNVbmRlZmluZWQoYXNwZWN0UmF0aW8pKSB7XG4gICAgICAgIC8vIDAgLT4gTmFOXG4gICAgICAgIG9wdGlvbnMuYXNwZWN0UmF0aW8gPSBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbykgfHwgTmFOO1xuXG4gICAgICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICAgICAgdGhpcy5pbml0Q3JvcEJveCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuY3JvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDcm9wQm94KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGRyYWcgbW9kZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIFRoZSBuZXcgZHJhZyBtb2RlLlxuICAgICAqIEByZXR1cm5zIHtDcm9wcGVyfSB0aGlzXG4gICAgICovXG4gICAgc2V0RHJhZ01vZGU6IGZ1bmN0aW9uIHNldERyYWdNb2RlKG1vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGRyYWdCb3ggPSB0aGlzLmRyYWdCb3gsXG4gICAgICAgICAgZmFjZSA9IHRoaXMuZmFjZTtcblxuICAgICAgaWYgKHRoaXMucmVhZHkgJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdmFyIGNyb3BwYWJsZSA9IG1vZGUgPT09IERSQUdfTU9ERV9DUk9QO1xuICAgICAgICB2YXIgbW92YWJsZSA9IG9wdGlvbnMubW92YWJsZSAmJiBtb2RlID09PSBEUkFHX01PREVfTU9WRTtcbiAgICAgICAgbW9kZSA9IGNyb3BwYWJsZSB8fCBtb3ZhYmxlID8gbW9kZSA6IERSQUdfTU9ERV9OT05FO1xuICAgICAgICBvcHRpb25zLmRyYWdNb2RlID0gbW9kZTtcbiAgICAgICAgc2V0RGF0YShkcmFnQm94LCBEQVRBX0FDVElPTiwgbW9kZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdCb3gsIENMQVNTX0NST1AsIGNyb3BwYWJsZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdCb3gsIENMQVNTX01PVkUsIG1vdmFibGUpO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5jcm9wQm94TW92YWJsZSkge1xuICAgICAgICAgIC8vIFN5bmMgZHJhZyBtb2RlIHRvIGNyb3AgYm94IHdoZW4gaXQgaXMgbm90IG1vdmFibGVcbiAgICAgICAgICBzZXREYXRhKGZhY2UsIERBVEFfQUNUSU9OLCBtb2RlKTtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhmYWNlLCBDTEFTU19DUk9QLCBjcm9wcGFibGUpO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGZhY2UsIENMQVNTX01PVkUsIG1vdmFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICB2YXIgQW5vdGhlckNyb3BwZXIgPSBXSU5ET1cuQ3JvcHBlcjtcblxuICB2YXIgQ3JvcHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IENyb3BwZXIuXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gVGhlIHRhcmdldCBlbGVtZW50IGZvciBjcm9wcGluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDcm9wcGVyKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENyb3BwZXIpO1xuXG4gICAgICBpZiAoIWVsZW1lbnQgfHwgIVJFR0VYUF9UQUdfTkFNRS50ZXN0KGVsZW1lbnQudGFnTmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZmlyc3QgYXJndW1lbnQgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYW4gPGltZz4gb3IgPGNhbnZhcz4gZWxlbWVudC4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgREVGQVVMVFMsIGlzUGxhaW5PYmplY3Qob3B0aW9ucykgJiYgb3B0aW9ucyk7XG4gICAgICB0aGlzLmNyb3BwZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucG9pbnRlcnMgPSB7fTtcbiAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVsb2FkaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnJlcGxhY2VkID0gZmFsc2U7XG4gICAgICB0aGlzLnNpemVkID0gZmFsc2U7XG4gICAgICB0aGlzLnNpemluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENyb3BwZXIsIFt7XG4gICAgICBrZXk6IFwiaW5pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICB2YXIgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgdXJsO1xuXG4gICAgICAgIGlmIChlbGVtZW50W05BTUVTUEFDRV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50W05BTUVTUEFDRV0gPSB0aGlzO1xuXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnaW1nJykge1xuICAgICAgICAgIHRoaXMuaXNJbWcgPSB0cnVlOyAvLyBlLmcuOiBcImltZy9waWN0dXJlLmpwZ1wiXG5cbiAgICAgICAgICB1cmwgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3JjJykgfHwgJyc7XG4gICAgICAgICAgdGhpcy5vcmlnaW5hbFVybCA9IHVybDsgLy8gU3RvcCB3aGVuIGl0J3MgYSBibGFuayBpbWFnZVxuXG4gICAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIGUuZy46IFwiaHR0cHM6Ly9leGFtcGxlLmNvbS9pbWcvcGljdHVyZS5qcGdcIlxuXG5cbiAgICAgICAgICB1cmwgPSBlbGVtZW50LnNyYztcbiAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnY2FudmFzJyAmJiB3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICB1cmwgPSBlbGVtZW50LnRvRGF0YVVSTCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2FkKHVybCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxvYWRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHVybCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaW1hZ2VEYXRhID0ge307XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICBpZiAoIW9wdGlvbnMucm90YXRhYmxlICYmICFvcHRpb25zLnNjYWxhYmxlKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGVja09yaWVudGF0aW9uID0gZmFsc2U7XG4gICAgICAgIH0gLy8gT25seSBJRTEwKyBzdXBwb3J0cyBUeXBlZCBBcnJheXNcblxuXG4gICAgICAgIGlmICghb3B0aW9ucy5jaGVja09yaWVudGF0aW9uIHx8ICF3aW5kb3cuQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIERldGVjdCB0aGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZSBkaXJlY3RseSBpZiBpdCBpcyBhIERhdGEgVVJMXG5cblxuICAgICAgICBpZiAoUkVHRVhQX0RBVEFfVVJMLnRlc3QodXJsKSkge1xuICAgICAgICAgIC8vIFJlYWQgQXJyYXlCdWZmZXIgZnJvbSBEYXRhIFVSTCBvZiBKUEVHIGltYWdlcyBkaXJlY3RseSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgICAgICAgaWYgKFJFR0VYUF9EQVRBX1VSTF9KUEVHLnRlc3QodXJsKSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkKGRhdGFVUkxUb0FycmF5QnVmZmVyKHVybCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPbmx5IGEgSlBFRyBpbWFnZSBtYXkgY29udGFpbnMgRXhpZiBPcmllbnRhdGlvbiBpbmZvcm1hdGlvbixcbiAgICAgICAgICAgIC8vIHRoZSByZXN0IHR5cGVzIG9mIERhdGEgVVJMcyBhcmUgbm90IG5lY2Vzc2FyeSB0byBjaGVjayBvcmllbnRhdGlvbiBhdCBhbGwuXG4gICAgICAgICAgICB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIDEuIERldGVjdCB0aGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZSBieSBhIFhNTEh0dHBSZXF1ZXN0LlxuICAgICAgICAvLyAyLiBMb2FkIHRoZSBpbWFnZSBhcyBBcnJheUJ1ZmZlciBmb3IgcmVhZGluZyBvcmllbnRhdGlvbiBpZiBpdHMgYSBKUEVHIGltYWdlLlxuXG5cbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy54aHIgPSB4aHI7IC8vIDEuIENyb3NzIG9yaWdpbiByZXF1ZXN0cyBhcmUgb25seSBzdXBwb3J0ZWQgZm9yIHByb3RvY29sIHNjaGVtZXM6XG4gICAgICAgIC8vIGh0dHAsIGh0dHBzLCBkYXRhLCBjaHJvbWUsIGNocm9tZS1leHRlbnNpb24uXG4gICAgICAgIC8vIDIuIEFjY2VzcyB0byBYTUxIdHRwUmVxdWVzdCBmcm9tIGEgRGF0YSBVUkwgd2lsbCBiZSBibG9ja2VkIGJ5IENPUlMgcG9saWN5XG4gICAgICAgIC8vIGluIHNvbWUgYnJvd3NlcnMgYXMgSUUxMSBhbmQgU2FmYXJpLlxuXG4gICAgICAgIHhoci5vbmFib3J0ID0gY2xvbmU7XG4gICAgICAgIHhoci5vbmVycm9yID0gY2xvbmU7XG4gICAgICAgIHhoci5vbnRpbWVvdXQgPSBjbG9uZTtcblxuICAgICAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBBYm9ydCB0aGUgcmVxdWVzdCBkaXJlY3RseSBpZiBpdCBub3QgYSBKUEVHIGltYWdlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAgICAgICBpZiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKSAhPT0gTUlNRV9UWVBFX0pQRUcpIHtcbiAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnJlYWQoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB4aHIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnJlbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzLnhociA9IG51bGw7XG4gICAgICAgIH07IC8vIEJ1c3QgY2FjaGUgd2hlbiB0aGVyZSBpcyBhIFwiY3Jvc3NPcmlnaW5cIiBwcm9wZXJ0eSB0byBhdm9pZCBicm93c2VyIGNhY2hlIGVycm9yXG5cblxuICAgICAgICBpZiAob3B0aW9ucy5jaGVja0Nyb3NzT3JpZ2luICYmIGlzQ3Jvc3NPcmlnaW5VUkwodXJsKSAmJiBlbGVtZW50LmNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgdXJsID0gYWRkVGltZXN0YW1wKHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBlbGVtZW50LmNyb3NzT3JpZ2luID09PSAndXNlLWNyZWRlbnRpYWxzJztcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVhZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWQoYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBpbWFnZURhdGEgPSB0aGlzLmltYWdlRGF0YTsgLy8gUmVzZXQgdGhlIG9yaWVudGF0aW9uIHZhbHVlIHRvIGl0cyBkZWZhdWx0IHZhbHVlIDFcbiAgICAgICAgLy8gYXMgc29tZSBpT1MgYnJvd3NlcnMgd2lsbCByZW5kZXIgaW1hZ2Ugd2l0aCBpdHMgb3JpZW50YXRpb25cblxuICAgICAgICB2YXIgb3JpZW50YXRpb24gPSByZXNldEFuZEdldE9yaWVudGF0aW9uKGFycmF5QnVmZmVyKTtcbiAgICAgICAgdmFyIHJvdGF0ZSA9IDA7XG4gICAgICAgIHZhciBzY2FsZVggPSAxO1xuICAgICAgICB2YXIgc2NhbGVZID0gMTtcblxuICAgICAgICBpZiAob3JpZW50YXRpb24gPiAxKSB7XG4gICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgVVJMIHdoaWNoIGhhcyB0aGUgZGVmYXVsdCBvcmllbnRhdGlvbiB2YWx1ZVxuICAgICAgICAgIHRoaXMudXJsID0gYXJyYXlCdWZmZXJUb0RhdGFVUkwoYXJyYXlCdWZmZXIsIE1JTUVfVFlQRV9KUEVHKTtcblxuICAgICAgICAgIHZhciBfcGFyc2VPcmllbnRhdGlvbiA9IHBhcnNlT3JpZW50YXRpb24ob3JpZW50YXRpb24pO1xuXG4gICAgICAgICAgcm90YXRlID0gX3BhcnNlT3JpZW50YXRpb24ucm90YXRlO1xuICAgICAgICAgIHNjYWxlWCA9IF9wYXJzZU9yaWVudGF0aW9uLnNjYWxlWDtcbiAgICAgICAgICBzY2FsZVkgPSBfcGFyc2VPcmllbnRhdGlvbi5zY2FsZVk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5yb3RhdGFibGUpIHtcbiAgICAgICAgICBpbWFnZURhdGEucm90YXRlID0gcm90YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgICAgICBpbWFnZURhdGEuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgIGltYWdlRGF0YS5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsb25lKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgdXJsID0gdGhpcy51cmw7XG4gICAgICAgIHZhciBjcm9zc09yaWdpbiA9IGVsZW1lbnQuY3Jvc3NPcmlnaW47XG4gICAgICAgIHZhciBjcm9zc09yaWdpblVybCA9IHVybDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNoZWNrQ3Jvc3NPcmlnaW4gJiYgaXNDcm9zc09yaWdpblVSTCh1cmwpKSB7XG4gICAgICAgICAgaWYgKCFjcm9zc09yaWdpbikge1xuICAgICAgICAgICAgY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgICB9IC8vIEJ1c3QgY2FjaGUgd2hlbiB0aGVyZSBpcyBub3QgYSBcImNyb3NzT3JpZ2luXCIgcHJvcGVydHkgKCM1MTkpXG5cblxuICAgICAgICAgIGNyb3NzT3JpZ2luVXJsID0gYWRkVGltZXN0YW1wKHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5VcmwgPSBjcm9zc09yaWdpblVybDtcbiAgICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgICAgICAgaWYgKGNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGltYWdlLnNyYyA9IGNyb3NzT3JpZ2luVXJsIHx8IHVybDtcbiAgICAgICAgaW1hZ2UuYWx0ID0gZWxlbWVudC5hbHQgfHwgJ1RoZSBpbWFnZSB0byBjcm9wJztcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIGltYWdlLm9uZXJyb3IgPSB0aGlzLnN0b3AuYmluZCh0aGlzKTtcbiAgICAgICAgYWRkQ2xhc3MoaW1hZ2UsIENMQVNTX0hJREUpO1xuICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGltYWdlLCBlbGVtZW50Lm5leHRTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RhcnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6aW5nID0gdHJ1ZTsgLy8gTWF0Y2ggYWxsIGJyb3dzZXJzIHRoYXQgdXNlIFdlYktpdCBhcyB0aGUgbGF5b3V0IGVuZ2luZSBpbiBpT1MgZGV2aWNlcyxcbiAgICAgICAgLy8gc3VjaCBhcyBTYWZhcmkgZm9yIGlPUywgQ2hyb21lIGZvciBpT1MsIGFuZCBpbi1hcHAgYnJvd3NlcnMuXG5cbiAgICAgICAgdmFyIGlzSU9TV2ViS2l0ID0gV0lORE9XLm5hdmlnYXRvciAmJiAvKD86aVBhZHxpUGhvbmV8aVBvZCkuKj9BcHBsZVdlYktpdC9pLnRlc3QoV0lORE9XLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZShuYXR1cmFsV2lkdGgsIG5hdHVyYWxIZWlnaHQpIHtcbiAgICAgICAgICBhc3NpZ24oX3RoaXMyLmltYWdlRGF0YSwge1xuICAgICAgICAgICAgbmF0dXJhbFdpZHRoOiBuYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICBuYXR1cmFsSGVpZ2h0OiBuYXR1cmFsSGVpZ2h0LFxuICAgICAgICAgICAgYXNwZWN0UmF0aW86IG5hdHVyYWxXaWR0aCAvIG5hdHVyYWxIZWlnaHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfdGhpczIuc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMyLnNpemVkID0gdHJ1ZTtcblxuICAgICAgICAgIF90aGlzMi5idWlsZCgpO1xuICAgICAgICB9OyAvLyBNb3N0IG1vZGVybiBicm93c2VycyAoZXhjZXB0cyBpT1MgV2ViS2l0KVxuXG5cbiAgICAgICAgaWYgKGltYWdlLm5hdHVyYWxXaWR0aCAmJiAhaXNJT1NXZWJLaXQpIHtcbiAgICAgICAgICBkb25lKGltYWdlLm5hdHVyYWxXaWR0aCwgaW1hZ2UubmF0dXJhbEhlaWdodCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpemluZ0ltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc2l6aW5nSW1hZ2UgPSBzaXppbmdJbWFnZTtcblxuICAgICAgICBzaXppbmdJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZG9uZShzaXppbmdJbWFnZS53aWR0aCwgc2l6aW5nSW1hZ2UuaGVpZ2h0KTtcblxuICAgICAgICAgIGlmICghaXNJT1NXZWJLaXQpIHtcbiAgICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoc2l6aW5nSW1hZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzaXppbmdJbWFnZS5zcmMgPSBpbWFnZS5zcmM7IC8vIGlPUyBXZWJLaXQgd2lsbCBjb252ZXJ0IHRoZSBpbWFnZSBhdXRvbWF0aWNhbGx5XG4gICAgICAgIC8vIHdpdGggaXRzIG9yaWVudGF0aW9uIG9uY2UgYXBwZW5kIGl0IGludG8gRE9NICgjMjc5KVxuXG4gICAgICAgIGlmICghaXNJT1NXZWJLaXQpIHtcbiAgICAgICAgICBzaXppbmdJbWFnZS5zdHlsZS5jc3NUZXh0ID0gJ2xlZnQ6MDsnICsgJ21heC1oZWlnaHQ6bm9uZSFpbXBvcnRhbnQ7JyArICdtYXgtd2lkdGg6bm9uZSFpbXBvcnRhbnQ7JyArICdtaW4taGVpZ2h0OjAhaW1wb3J0YW50OycgKyAnbWluLXdpZHRoOjAhaW1wb3J0YW50OycgKyAnb3BhY2l0eTowOycgKyAncG9zaXRpb246YWJzb2x1dGU7JyArICd0b3A6MDsnICsgJ3otaW5kZXg6LTE7JztcbiAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKHNpemluZ0ltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdG9wXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IG51bGw7XG4gICAgICAgIGltYWdlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1hZ2UpO1xuICAgICAgICB0aGlzLmltYWdlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYnVpbGRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpemVkIHx8IHRoaXMucmVhZHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBpbWFnZSA9IHRoaXMuaW1hZ2U7IC8vIENyZWF0ZSBjcm9wcGVyIGVsZW1lbnRzXG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IFRFTVBMQVRFO1xuICAgICAgICB2YXIgY3JvcHBlciA9IHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItY29udGFpbmVyXCIpKTtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGNyb3BwZXIucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1jYW52YXNcIikpO1xuICAgICAgICB2YXIgZHJhZ0JveCA9IGNyb3BwZXIucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoTkFNRVNQQUNFLCBcIi1kcmFnLWJveFwiKSk7XG4gICAgICAgIHZhciBjcm9wQm94ID0gY3JvcHBlci5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWNyb3AtYm94XCIpKTtcbiAgICAgICAgdmFyIGZhY2UgPSBjcm9wQm94LnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItZmFjZVwiKSk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNyb3BwZXIgPSBjcm9wcGVyO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5kcmFnQm94ID0gZHJhZ0JveDtcbiAgICAgICAgdGhpcy5jcm9wQm94ID0gY3JvcEJveDtcbiAgICAgICAgdGhpcy52aWV3Qm94ID0gY3JvcHBlci5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLXZpZXctYm94XCIpKTtcbiAgICAgICAgdGhpcy5mYWNlID0gZmFjZTtcbiAgICAgICAgY2FudmFzLmFwcGVuZENoaWxkKGltYWdlKTsgLy8gSGlkZSB0aGUgb3JpZ2luYWwgaW1hZ2VcblxuICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBDTEFTU19ISURERU4pOyAvLyBJbnNlcnRzIHRoZSBjcm9wcGVyIGFmdGVyIHRvIHRoZSBjdXJyZW50IGltYWdlXG5cbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShjcm9wcGVyLCBlbGVtZW50Lm5leHRTaWJsaW5nKTsgLy8gU2hvdyB0aGUgaW1hZ2UgaWYgaXMgaGlkZGVuXG5cbiAgICAgICAgaWYgKCF0aGlzLmlzSW1nKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoaW1hZ2UsIENMQVNTX0hJREUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbml0UHJldmlldygpO1xuICAgICAgICB0aGlzLmJpbmQoKTtcbiAgICAgICAgb3B0aW9ucy5pbml0aWFsQXNwZWN0UmF0aW8gPSBNYXRoLm1heCgwLCBvcHRpb25zLmluaXRpYWxBc3BlY3RSYXRpbykgfHwgTmFOO1xuICAgICAgICBvcHRpb25zLmFzcGVjdFJhdGlvID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5hc3BlY3RSYXRpbykgfHwgTmFOO1xuICAgICAgICBvcHRpb25zLnZpZXdNb2RlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMywgTWF0aC5yb3VuZChvcHRpb25zLnZpZXdNb2RlKSkpIHx8IDA7XG4gICAgICAgIGFkZENsYXNzKGNyb3BCb3gsIENMQVNTX0hJRERFTik7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmd1aWRlcykge1xuICAgICAgICAgIGFkZENsYXNzKGNyb3BCb3guZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWRhc2hlZFwiKSksIENMQVNTX0hJRERFTik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuY2VudGVyKSB7XG4gICAgICAgICAgYWRkQ2xhc3MoY3JvcEJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItY2VudGVyXCIpKSwgQ0xBU1NfSElEREVOKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmQpIHtcbiAgICAgICAgICBhZGRDbGFzcyhjcm9wcGVyLCBcIlwiLmNvbmNhdChOQU1FU1BBQ0UsIFwiLWJnXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICAgICAgICBhZGRDbGFzcyhmYWNlLCBDTEFTU19JTlZJU0lCTEUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY3JvcEJveE1vdmFibGUpIHtcbiAgICAgICAgICBhZGRDbGFzcyhmYWNlLCBDTEFTU19NT1ZFKTtcbiAgICAgICAgICBzZXREYXRhKGZhY2UsIERBVEFfQUNUSU9OLCBBQ1RJT05fQUxMKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5jcm9wQm94UmVzaXphYmxlKSB7XG4gICAgICAgICAgYWRkQ2xhc3MoY3JvcEJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItbGluZVwiKSksIENMQVNTX0hJRERFTik7XG4gICAgICAgICAgYWRkQ2xhc3MoY3JvcEJveC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiXCIuY29uY2F0KE5BTUVTUEFDRSwgXCItcG9pbnRcIikpLCBDTEFTU19ISURERU4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0RHJhZ01vZGUob3B0aW9ucy5kcmFnTW9kZSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0Nyb3ApIHtcbiAgICAgICAgICB0aGlzLmNyb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RGF0YShvcHRpb25zLmRhdGEpO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMucmVhZHkpKSB7XG4gICAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgRVZFTlRfUkVBRFksIG9wdGlvbnMucmVhZHksIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BhdGNoRXZlbnQoZWxlbWVudCwgRVZFTlRfUkVBRFkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1bmJ1aWxkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5idWlsZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWR5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVuYmluZCgpO1xuICAgICAgICB0aGlzLnJlc2V0UHJldmlldygpO1xuICAgICAgICB0aGlzLmNyb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNyb3BwZXIpO1xuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX0hJRERFTik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInVuY3JlYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5jcmVhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgICAgICAgdGhpcy51bmJ1aWxkKCk7XG4gICAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY3JvcHBlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2l6aW5nKSB7XG4gICAgICAgICAgdGhpcy5zaXppbmdJbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5zaXplZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmVsb2FkaW5nKSB7XG4gICAgICAgICAgdGhpcy54aHIub25hYm9ydCA9IG51bGw7XG4gICAgICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmltYWdlKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBubyBjb25mbGljdCBjcm9wcGVyIGNsYXNzLlxuICAgICAgICogQHJldHVybnMge0Nyb3BwZXJ9IFRoZSBjcm9wcGVyIGNsYXNzLlxuICAgICAgICovXG5cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJub0NvbmZsaWN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgICAgd2luZG93LkNyb3BwZXIgPSBBbm90aGVyQ3JvcHBlcjtcbiAgICAgICAgcmV0dXJuIENyb3BwZXI7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENoYW5nZSB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgbmV3IGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInNldERlZmF1bHRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGVmYXVsdHMob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24oREVGQVVMVFMsIGlzUGxhaW5PYmplY3Qob3B0aW9ucykgJiYgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENyb3BwZXI7XG4gIH0oKTtcblxuICBhc3NpZ24oQ3JvcHBlci5wcm90b3R5cGUsIHJlbmRlciwgcHJldmlldywgZXZlbnRzLCBoYW5kbGVycywgY2hhbmdlLCBtZXRob2RzKTtcblxuICByZXR1cm4gQ3JvcHBlcjtcblxufSkpKTtcbiIsIi8qKlxuICogY3VpZC5qc1xuICogQ29sbGlzaW9uLXJlc2lzdGFudCBVSUQgZ2VuZXJhdG9yIGZvciBicm93c2VycyBhbmQgbm9kZS5cbiAqIFNlcXVlbnRpYWwgZm9yIGZhc3QgZGIgbG9va3VwcyBhbmQgcmVjZW5jeSBzb3J0aW5nLlxuICogU2FmZSBmb3IgZWxlbWVudCBJRHMgYW5kIHNlcnZlci1zaWRlIGxvb2t1cHMuXG4gKlxuICogRXh0cmFjdGVkIGZyb20gQ0xDVFJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEVyaWMgRWxsaW90dCAyMDEyXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbnZhciBmaW5nZXJwcmludCA9IHJlcXVpcmUoJy4vbGliL2ZpbmdlcnByaW50LmpzJyk7XG52YXIgcGFkID0gcmVxdWlyZSgnLi9saWIvcGFkLmpzJyk7XG52YXIgZ2V0UmFuZG9tVmFsdWUgPSByZXF1aXJlKCcuL2xpYi9nZXRSYW5kb21WYWx1ZS5qcycpO1xuXG52YXIgYyA9IDAsXG4gIGJsb2NrU2l6ZSA9IDQsXG4gIGJhc2UgPSAzNixcbiAgZGlzY3JldGVWYWx1ZXMgPSBNYXRoLnBvdyhiYXNlLCBibG9ja1NpemUpO1xuXG5mdW5jdGlvbiByYW5kb21CbG9jayAoKSB7XG4gIHJldHVybiBwYWQoKGdldFJhbmRvbVZhbHVlKCkgKlxuICAgIGRpc2NyZXRlVmFsdWVzIDw8IDApXG4gICAgLnRvU3RyaW5nKGJhc2UpLCBibG9ja1NpemUpO1xufVxuXG5mdW5jdGlvbiBzYWZlQ291bnRlciAoKSB7XG4gIGMgPSBjIDwgZGlzY3JldGVWYWx1ZXMgPyBjIDogMDtcbiAgYysrOyAvLyB0aGlzIGlzIG5vdCBzdWJsaW1pbmFsXG4gIHJldHVybiBjIC0gMTtcbn1cblxuZnVuY3Rpb24gY3VpZCAoKSB7XG4gIC8vIFN0YXJ0aW5nIHdpdGggYSBsb3dlcmNhc2UgbGV0dGVyIG1ha2VzXG4gIC8vIGl0IEhUTUwgZWxlbWVudCBJRCBmcmllbmRseS5cbiAgdmFyIGxldHRlciA9ICdjJywgLy8gaGFyZC1jb2RlZCBhbGxvd3MgZm9yIHNlcXVlbnRpYWwgYWNjZXNzXG5cbiAgICAvLyB0aW1lc3RhbXBcbiAgICAvLyB3YXJuaW5nOiB0aGlzIGV4cG9zZXMgdGhlIGV4YWN0IGRhdGUgYW5kIHRpbWVcbiAgICAvLyB0aGF0IHRoZSB1aWQgd2FzIGNyZWF0ZWQuXG4gICAgdGltZXN0YW1wID0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKS50b1N0cmluZyhiYXNlKSxcblxuICAgIC8vIFByZXZlbnQgc2FtZS1tYWNoaW5lIGNvbGxpc2lvbnMuXG4gICAgY291bnRlciA9IHBhZChzYWZlQ291bnRlcigpLnRvU3RyaW5nKGJhc2UpLCBibG9ja1NpemUpLFxuXG4gICAgLy8gQSBmZXcgY2hhcnMgdG8gZ2VuZXJhdGUgZGlzdGluY3QgaWRzIGZvciBkaWZmZXJlbnRcbiAgICAvLyBjbGllbnRzIChzbyBkaWZmZXJlbnQgY29tcHV0ZXJzIGFyZSBmYXIgbGVzc1xuICAgIC8vIGxpa2VseSB0byBnZW5lcmF0ZSB0aGUgc2FtZSBpZClcbiAgICBwcmludCA9IGZpbmdlcnByaW50KCksXG5cbiAgICAvLyBHcmFiIHNvbWUgbW9yZSBjaGFycyBmcm9tIE1hdGgucmFuZG9tKClcbiAgICByYW5kb20gPSByYW5kb21CbG9jaygpICsgcmFuZG9tQmxvY2soKTtcblxuICByZXR1cm4gbGV0dGVyICsgdGltZXN0YW1wICsgY291bnRlciArIHByaW50ICsgcmFuZG9tO1xufVxuXG5jdWlkLnNsdWcgPSBmdW5jdGlvbiBzbHVnICgpIHtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKS50b1N0cmluZygzNiksXG4gICAgY291bnRlciA9IHNhZmVDb3VudGVyKCkudG9TdHJpbmcoMzYpLnNsaWNlKC00KSxcbiAgICBwcmludCA9IGZpbmdlcnByaW50KCkuc2xpY2UoMCwgMSkgK1xuICAgICAgZmluZ2VycHJpbnQoKS5zbGljZSgtMSksXG4gICAgcmFuZG9tID0gcmFuZG9tQmxvY2soKS5zbGljZSgtMik7XG5cbiAgcmV0dXJuIGRhdGUuc2xpY2UoLTIpICtcbiAgICBjb3VudGVyICsgcHJpbnQgKyByYW5kb207XG59O1xuXG5jdWlkLmlzQ3VpZCA9IGZ1bmN0aW9uIGlzQ3VpZCAoc3RyaW5nVG9DaGVjaykge1xuICBpZiAodHlwZW9mIHN0cmluZ1RvQ2hlY2sgIT09ICdzdHJpbmcnKSByZXR1cm4gZmFsc2U7XG4gIGlmIChzdHJpbmdUb0NoZWNrLnN0YXJ0c1dpdGgoJ2MnKSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmN1aWQuaXNTbHVnID0gZnVuY3Rpb24gaXNTbHVnIChzdHJpbmdUb0NoZWNrKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nVG9DaGVjayAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcbiAgdmFyIHN0cmluZ0xlbmd0aCA9IHN0cmluZ1RvQ2hlY2subGVuZ3RoO1xuICBpZiAoc3RyaW5nTGVuZ3RoID49IDcgJiYgc3RyaW5nTGVuZ3RoIDw9IDEwKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY3VpZC5maW5nZXJwcmludCA9IGZpbmdlcnByaW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN1aWQ7XG4iLCJ2YXIgcGFkID0gcmVxdWlyZSgnLi9wYWQuanMnKTtcblxudmFyIGVudiA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnID8gd2luZG93IDogc2VsZjtcbnZhciBnbG9iYWxDb3VudCA9IE9iamVjdC5rZXlzKGVudikubGVuZ3RoO1xudmFyIG1pbWVUeXBlc0xlbmd0aCA9IG5hdmlnYXRvci5taW1lVHlwZXMgPyBuYXZpZ2F0b3IubWltZVR5cGVzLmxlbmd0aCA6IDA7XG52YXIgY2xpZW50SWQgPSBwYWQoKG1pbWVUeXBlc0xlbmd0aCArXG4gIG5hdmlnYXRvci51c2VyQWdlbnQubGVuZ3RoKS50b1N0cmluZygzNikgK1xuICBnbG9iYWxDb3VudC50b1N0cmluZygzNiksIDQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbmdlcnByaW50ICgpIHtcbiAgcmV0dXJuIGNsaWVudElkO1xufTtcbiIsIlxudmFyIGdldFJhbmRvbVZhbHVlO1xuXG52YXIgY3J5cHRvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgKHdpbmRvdy5jcnlwdG8gfHwgd2luZG93Lm1zQ3J5cHRvKSB8fFxuICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgc2VsZi5jcnlwdG87XG5cbmlmIChjcnlwdG8pIHtcbiAgICB2YXIgbGltID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbiAgICBnZXRSYW5kb21WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXSAvIGxpbSk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgZ2V0UmFuZG9tVmFsdWUgPSBNYXRoLnJhbmRvbTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYW5kb21WYWx1ZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFkIChudW0sIHNpemUpIHtcbiAgdmFyIHMgPSAnMDAwMDAwMDAwJyArIG51bTtcbiAgcmV0dXJuIHMuc3Vic3RyKHMubGVuZ3RoIC0gc2l6ZSk7XG59O1xuIiwiLy8gVGhpcyBmaWxlIGNhbiBiZSByZXF1aXJlZCBpbiBCcm93c2VyaWZ5IGFuZCBOb2RlLmpzIGZvciBhdXRvbWF0aWMgcG9seWZpbGxcbi8vIFRvIHVzZSBpdDogIHJlcXVpcmUoJ2VzNi1wcm9taXNlL2F1dG8nKTtcbid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8nKS5wb2x5ZmlsbCgpO1xuIiwiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3N0ZWZhbnBlbm5lci9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICB2NC4yLjgrMWU2OGRjZTZcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG4gIHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuXG5cbnZhciBfaXNBcnJheSA9IHZvaWQgMDtcbmlmIChBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbn0gZWxzZSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB2b2lkIDA7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB2b2lkIDA7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4vLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxudmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuLy8gbm9kZVxuZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbi8vIHZlcnR4XG5mdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuICBpZiAodHlwZW9mIHZlcnR4TmV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdmVydHggPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpLnJlcXVpcmUoJ3ZlcnR4Jyk7XG4gICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaCA9IHZvaWQgMDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSBhdHRlbXB0VmVydHgoKTtcbn0gZWxzZSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKGNoaWxkW1BST01JU0VfSURdID09PSB1bmRlZmluZWQpIHtcbiAgICBtYWtlUHJvbWlzZShjaGlsZCk7XG4gIH1cblxuICB2YXIgX3N0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuXG4gIGlmIChfc3RhdGUpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbX3N0YXRlIC0gMV07XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkO1xufVxuXG4vKipcbiAgYFByb21pc2UucmVzb2x2ZWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZXNvbHZlZCB3aXRoIHRoZVxuICBwYXNzZWQgYHZhbHVlYC4gSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlc29sdmUoMSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKDEpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVzb2x2ZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIGZ1bGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuICBgdmFsdWVgXG4qL1xuZnVuY3Rpb24gcmVzb2x2ZSQxKG9iamVjdCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgUEVORElORyA9IHZvaWQgMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcblxuZnVuY3Rpb24gc2VsZkZ1bGZpbGxtZW50KCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG59XG5cbmZ1bmN0aW9uIGNhbm5vdFJldHVybk93bigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuJCQxLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbiQkMS5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuJCQxLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhlbiQkMSkpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgc2VsZkZ1bGZpbGxtZW50KCkpO1xuICB9IGVsc2UgaWYgKG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIHRoZW4kJDEgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIHRoZW4kJDEgPSB2YWx1ZS50aGVuO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCB0aGVuJCQxKTtcbiAgfSBlbHNlIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gIH1cblxuICBwdWJsaXNoKHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcblxuICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwcm9taXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9taXNlLl9zdGF0ZSA9IFJFSkVDVEVEO1xuICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cbiAgYXNhcChwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBfc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICB2YXIgbGVuZ3RoID0gX3N1YnNjcmliZXJzLmxlbmd0aDtcblxuXG4gIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cbiAgX3N1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgUkVKRUNURURdID0gb25SZWplY3Rpb247XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwYXJlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2gocHJvbWlzZSkge1xuICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gdm9pZCAwLFxuICAgICAgY2FsbGJhY2sgPSB2b2lkIDAsXG4gICAgICBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICB9XG4gIH1cblxuICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHZhciBoYXNDYWxsYmFjayA9IGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgdmFsdWUgPSB2b2lkIDAsXG4gICAgICBlcnJvciA9IHZvaWQgMCxcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG5cbiAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gY2FsbGJhY2soZGV0YWlsKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdWNjZWVkZWQgPSBmYWxzZTtcbiAgICAgIGVycm9yID0gZTtcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZGV0YWlsO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHN1Y2NlZWRlZCA9PT0gZmFsc2UpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZSk7XG4gIH1cbn1cblxudmFyIGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgcmV0dXJuIGlkKys7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG4gIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG59XG5cbnZhciBFbnVtZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG5cbiAgICBpZiAoIXRoaXMucHJvbWlzZVtQUk9NSVNFX0lEXSkge1xuICAgICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICAgIHRoaXMuX2VudW1lcmF0ZShpbnB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3QodGhpcy5wcm9taXNlLCB2YWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgfVxuICB9XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uIF9lbnVtZXJhdGUoaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgdGhpcy5fc3RhdGUgPT09IFBFTkRJTkcgJiYgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gX2VhY2hFbnRyeShlbnRyeSwgaSkge1xuICAgIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgICB2YXIgcmVzb2x2ZSQkMSA9IGMucmVzb2x2ZTtcblxuXG4gICAgaWYgKHJlc29sdmUkJDEgPT09IHJlc29sdmUkMSkge1xuICAgICAgdmFyIF90aGVuID0gdm9pZCAwO1xuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICBfdGhlbiA9IGVudHJ5LnRoZW47XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoZW4gPT09IHRoZW4gJiYgZW50cnkuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgX3RoZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IGVudHJ5O1xuICAgICAgfSBlbHNlIGlmIChjID09PSBQcm9taXNlJDEpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgYyhub29wKTtcbiAgICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUkJDEoZW50cnkpO1xuICAgICAgICB9KSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQxKGVudHJ5KSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiBfc2V0dGxlZEF0KHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG5cbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiBfd2lsbFNldHRsZUF0KHByb21pc2UsIGkpIHtcbiAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRW51bWVyYXRvcjtcbn0oKTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5cbnZhciBQcm9taXNlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gIH0pO1xuICBgYGBcbiAgIENoYWluaW5nXG4gIC0tLS0tLS0tXG4gICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gIH0pO1xuICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgfSk7XG4gIGBgYFxuICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgQXNzaW1pbGF0aW9uXG4gIC0tLS0tLS0tLS0tLVxuICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gIH0pO1xuICBgYGBcbiAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgU2ltcGxlIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IHJlc3VsdDtcbiAgIHRyeSB7XG4gICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBmYWlsdXJlXG4gIH0pO1xuICBgYGBcbiAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IGF1dGhvciwgYm9va3M7XG4gICB0cnkge1xuICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gICB9XG4gICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICAgfVxuICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICB9XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRBdXRob3IoKS5cbiAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgIC8vIGZvdW5kIGJvb2tzXG4gIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICAgQG1ldGhvZCB0aGVuXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG4gIC8qKlxuICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gIH1cbiAgLy8gc3luY2hyb25vdXNcbiAgdHJ5IHtcbiAgZmluZEF1dGhvcigpO1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9XG4gIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgQG1ldGhvZCBjYXRjaFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgIGBmaW5hbGx5YCB3aWxsIGJlIGludm9rZWQgcmVnYXJkbGVzcyBvZiB0aGUgcHJvbWlzZSdzIGZhdGUganVzdCBhcyBuYXRpdmVcbiAgICB0cnkvY2F0Y2gvZmluYWxseSBiZWhhdmVzXG4gIFxuICAgIFN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpIHtcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBdXRob3IoKTtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZmluZEF1dGhvcigpOyAvLyBzdWNjZWVkIG9yIGZhaWxcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGFsd2F5cyBydW5zXG4gICAgICAvLyBkb2Vzbid0IGFmZmVjdCB0aGUgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBBc3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCl7XG4gICAgICAvLyBhdXRob3Igd2FzIGVpdGhlciBmb3VuZCwgb3Igbm90XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgZmluYWxseVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShjYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihjYWxsYmFjaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIHJldHVybiBQcm9taXNlO1xufSgpO1xuXG5Qcm9taXNlJDEucHJvdG90eXBlLnRoZW4gPSB0aGVuO1xuUHJvbWlzZSQxLmFsbCA9IGFsbDtcblByb21pc2UkMS5yYWNlID0gcmFjZTtcblByb21pc2UkMS5yZXNvbHZlID0gcmVzb2x2ZSQxO1xuUHJvbWlzZSQxLnJlamVjdCA9IHJlamVjdCQxO1xuUHJvbWlzZSQxLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlJDEuX3NldEFzYXAgPSBzZXRBc2FwO1xuUHJvbWlzZSQxLl9hc2FwID0gYXNhcDtcblxuLypnbG9iYWwgc2VsZiovXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgdmFyIGxvY2FsID0gdm9pZCAwO1xuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gc2VsZjtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gIGlmIChQKSB7XG4gICAgdmFyIHByb21pc2VUb1N0cmluZyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgIH1cblxuICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2UkMTtcbn1cblxuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZSQxLnBvbHlmaWxsID0gcG9seWZpbGw7XG5Qcm9taXNlJDEuUHJvbWlzZSA9IFByb21pc2UkMTtcblxucmV0dXJuIFByb21pc2UkMTtcblxufSkpKTtcblxuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzNi1wcm9taXNlLm1hcFxuIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/dChleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFwiZXhpZnJcIixbXCJleHBvcnRzXCJdLHQpOnQoKGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczplfHxzZWxmKS5leGlmcj17fSl9KHRoaXMsKGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIG4oZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fWZ1bmN0aW9uIHIoZSx0LHIpe3JldHVybiB0JiZuKGUucHJvdG90eXBlLHQpLHImJm4oZSxyKSxlfWZ1bmN0aW9uIGkoZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfWZ1bmN0aW9uIGEoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pO3ZhciBuPVtcInByb3RvdHlwZVwiLFwiX19wcm90b19fXCIsXCJjYWxsZXJcIixcImFyZ3VtZW50c1wiLFwibGVuZ3RoXCIsXCJuYW1lXCJdO09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpLmZvckVhY2goKGZ1bmN0aW9uKHIpey0xPT09bi5pbmRleE9mKHIpJiZlW3JdIT09dFtyXSYmKGVbcl09dFtyXSl9KSksdCYmdShlLHQpfWZ1bmN0aW9uIHMoZSl7cmV0dXJuKHM9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKX0pKGUpfWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm4odT1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX0pKGUsdCl9ZnVuY3Rpb24gbygpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fWZ1bmN0aW9uIGYoZSx0LG4pe3JldHVybihmPW8oKT9SZWZsZWN0LmNvbnN0cnVjdDpmdW5jdGlvbihlLHQsbil7dmFyIHI9W251bGxdO3IucHVzaC5hcHBseShyLHQpO3ZhciBpPW5ldyhGdW5jdGlvbi5iaW5kLmFwcGx5KGUscikpO3JldHVybiBuJiZ1KGksbi5wcm90b3R5cGUpLGl9KS5hcHBseShudWxsLGFyZ3VtZW50cyl9ZnVuY3Rpb24gYyhlKXt2YXIgdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBNYXA/bmV3IE1hcDp2b2lkIDA7cmV0dXJuKGM9ZnVuY3Rpb24oZSl7aWYobnVsbD09PWV8fChuPWUsLTE9PT1GdW5jdGlvbi50b1N0cmluZy5jYWxsKG4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpKSlyZXR1cm4gZTt2YXIgbjtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtpZih2b2lkIDAhPT10KXtpZih0LmhhcyhlKSlyZXR1cm4gdC5nZXQoZSk7dC5zZXQoZSxyKX1mdW5jdGlvbiByKCl7cmV0dXJuIGYoZSxhcmd1bWVudHMscyh0aGlzKS5jb25zdHJ1Y3Rvcil9cmV0dXJuIHIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpyLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHUocixlKX0pKGUpfWZ1bmN0aW9uIGgoZSl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIGV9ZnVuY3Rpb24gbChlLHQpe3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9oKGUpOnR9ZnVuY3Rpb24gZChlKXt2YXIgdD1vKCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG4scj1zKGUpO2lmKHQpe3ZhciBpPXModGhpcykuY29uc3RydWN0b3I7bj1SZWZsZWN0LmNvbnN0cnVjdChyLGFyZ3VtZW50cyxpKX1lbHNlIG49ci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGwodGhpcyxuKX19ZnVuY3Rpb24gdihlLHQsbil7cmV0dXJuKHY9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3QuZ2V0P1JlZmxlY3QuZ2V0OmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1mdW5jdGlvbihlLHQpe2Zvcig7IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpJiZudWxsIT09KGU9cyhlKSk7KTtyZXR1cm4gZX0oZSx0KTtpZihyKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsdCk7cmV0dXJuIGkuZ2V0P2kuZ2V0LmNhbGwobik6aS52YWx1ZX19KShlLHQsbnx8ZSl9dmFyIHA9T2JqZWN0LnZhbHVlc3x8ZnVuY3Rpb24oZSl7dmFyIHQ9W107Zm9yKHZhciBuIGluIGUpdC5wdXNoKGVbbl0pO3JldHVybiB0fSx5PU9iamVjdC5lbnRyaWVzfHxmdW5jdGlvbihlKXt2YXIgdD1bXTtmb3IodmFyIG4gaW4gZSl0LnB1c2goW24sZVtuXV0pO3JldHVybiB0fSxnPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQ+MT90LTE6MCkscj0xO3I8dDtyKyspbltyLTFdPWFyZ3VtZW50c1tyXTtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXtmb3IodmFyIG4gaW4gdCllW25dPXRbbl19KSksZX0saz1PYmplY3QuZnJvbUVudHJpZXN8fGZ1bmN0aW9uKGUpe3ZhciB0PXt9O3JldHVybiBtKGUpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWVbMF0scj1lWzFdO3Rbbl09cn0pKSx0fSxtPUFycmF5LmZyb218fGZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBQKXt2YXIgdD1bXTtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbihlLG4pe3JldHVybiB0LnB1c2goW24sZV0pfSkpLHR9cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUpfTtmdW5jdGlvbiBiKGUpe3JldHVybi0xIT09dGhpcy5pbmRleE9mKGUpfUFycmF5LnByb3RvdHlwZS5pbmNsdWRlc3x8KEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcz1iKSxTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzfHwoU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcz1iKSxTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGh8fChTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGg9ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjA7cmV0dXJuIHRoaXMuc3Vic3RyaW5nKHQsdCtlLmxlbmd0aCk9PT1lfSksU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aHx8KFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGg9ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGVuZ3RoO3JldHVybiB0aGlzLnN1YnN0cmluZyh0LWUubGVuZ3RoLHQpPT09ZX0pO3ZhciBBPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6Z2xvYmFsLHc9QS5mZXRjaHx8ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24obixyKXt2YXIgaT1uZXcgWE1MSHR0cFJlcXVlc3Q7aWYoaS5vcGVuKFwiZ2V0XCIsZSwhMCksaS5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGkub25lcnJvcj1yLHQuaGVhZGVycylmb3IodmFyIGEgaW4gdC5oZWFkZXJzKWkuc2V0UmVxdWVzdEhlYWRlcihhLHQuaGVhZGVyc1thXSk7aS5vbmxvYWQ9ZnVuY3Rpb24oKXtuKHtvazppLnN0YXR1cz49MjAwJiZpLnN0YXR1czwzMDAsc3RhdHVzOmkuc3RhdHVzLGFycmF5QnVmZmVyOmZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShpLnJlc3BvbnNlKX19KX0saS5zZW5kKG51bGwpfSkpfSxPPWZ1bmN0aW9uKGUpe3ZhciB0PVtdO2lmKE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQse3NpemU6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxlbmd0aH19LGhhczp7dmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuLTEhPT10aGlzLmluZGV4T2YoZSl9fSxhZGQ6e3ZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuaGFzKGUpfHx0aGlzLnB1c2goZSl9fSxkZWxldGU6e3ZhbHVlOmZ1bmN0aW9uKGUpe2lmKHRoaXMuaGFzKGUpKXt2YXIgdD10aGlzLmluZGV4T2YoZSk7dGhpcy5zcGxpY2UodCwxKX19fX0pLEFycmF5LmlzQXJyYXkoZSkpZm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspdC5hZGQoZVtuXSk7cmV0dXJuIHR9LFM9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBQKGUpfSxQPXZvaWQgMCE9PUEuTWFwJiZ2b2lkIDAhPT1BLk1hcC5wcm90b3R5cGUua2V5cz9BLk1hcDpmdW5jdGlvbigpe2Z1bmN0aW9uIGUobil7aWYodCh0aGlzLGUpLHRoaXMuY2xlYXIoKSxuKWZvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXRoaXMuc2V0KG5bcl1bMF0sbltyXVsxXSl9cmV0dXJuIHIoZSxbe2tleTpcImNsZWFyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9tYXA9e30sdGhpcy5fa2V5cz1bXX19LHtrZXk6XCJzaXplXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2tleXMubGVuZ3RofX0se2tleTpcImdldFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9tYXBbXCJtYXBfXCIrZV19fSx7a2V5Olwic2V0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5fbWFwW1wibWFwX1wiK2VdPXQsdGhpcy5fa2V5cy5pbmRleE9mKGUpPDAmJnRoaXMuX2tleXMucHVzaChlKSx0aGlzfX0se2tleTpcImhhc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9rZXlzLmluZGV4T2YoZSk+PTB9fSx7a2V5OlwiZGVsZXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5fa2V5cy5pbmRleE9mKGUpO3JldHVybiEodDwwKSYmKGRlbGV0ZSB0aGlzLl9tYXBbXCJtYXBfXCIrZV0sdGhpcy5fa2V5cy5zcGxpY2UodCwxKSwhMCl9fSx7a2V5Olwia2V5c1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2tleXMuc2xpY2UoMCl9fSx7a2V5OlwidmFsdWVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiB0aGlzLl9rZXlzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGUuZ2V0KHQpfSkpfX0se2tleTpcImVudHJpZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIHRoaXMuX2tleXMubWFwKChmdW5jdGlvbih0KXtyZXR1cm5bdCxlLmdldCh0KV19KSl9fSx7a2V5OlwiZm9yRWFjaFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPTA7bjx0aGlzLl9rZXlzLmxlbmd0aDtuKyspZS5jYWxsKHQsdGhpcy5fbWFwW1wibWFwX1wiK3RoaXMuX2tleXNbbl1dLHRoaXMuX2tleXNbbl0sdGhpcyl9fV0pLGV9KCksVT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOmdsb2JhbCx4PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3IsQz14JiZcInVuZGVmaW5lZFwiPT10eXBlb2YgSFRNTEltYWdlRWxlbWVudCxCPSEoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGdsb2JhbHx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIHByb2Nlc3N8fCFwcm9jZXNzLnZlcnNpb25zfHwhcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSxqPVUuQnVmZmVyLF89ISFqO3ZhciBWPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT1lfTtmdW5jdGlvbiBJKGUpe3JldHVybiB2b2lkIDA9PT1lfHwoZSBpbnN0YW5jZW9mIFA/MD09PWUuc2l6ZTowPT09cChlKS5maWx0ZXIoVikubGVuZ3RoKX1mdW5jdGlvbiBMKGUpe3ZhciB0PW5ldyBFcnJvcihlKTt0aHJvdyBkZWxldGUgdC5zdGFjayx0fWZ1bmN0aW9uIFQoZSl7dmFyIHQ9ZnVuY3Rpb24oZSl7dmFyIHQ9MDtyZXR1cm4gZS5pZmQwLmVuYWJsZWQmJih0Kz0xMDI0KSxlLmV4aWYuZW5hYmxlZCYmKHQrPTIwNDgpLGUubWFrZXJOb3RlJiYodCs9MjA0OCksZS51c2VyQ29tbWVudCYmKHQrPTEwMjQpLGUuZ3BzLmVuYWJsZWQmJih0Kz01MTIpLGUuaW50ZXJvcC5lbmFibGVkJiYodCs9MTAwKSxlLmlmZDEuZW5hYmxlZCYmKHQrPTEwMjQpLHQrMjA0OH0oZSk7cmV0dXJuIGUuamZpZi5lbmFibGVkJiYodCs9NTApLGUueG1wLmVuYWJsZWQmJih0Kz0yZTQpLGUuaXB0Yy5lbmFibGVkJiYodCs9MTRlMyksZS5pY2MuZW5hYmxlZCYmKHQrPTZlMyksdH12YXIgej1mdW5jdGlvbihlKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLGUpfSxGPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTp2b2lkIDA7ZnVuY3Rpb24gRShlKXtyZXR1cm4gRj9GLmRlY29kZShlKTpfP0J1ZmZlci5mcm9tKGUpLnRvU3RyaW5nKFwidXRmOFwiKTpkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHooZSkpKX12YXIgRD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUobil7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjAsaT1hcmd1bWVudHMubGVuZ3RoPjI/YXJndW1lbnRzWzJdOnZvaWQgMCxhPWFyZ3VtZW50cy5sZW5ndGg+Mz9hcmd1bWVudHNbM106dm9pZCAwO2lmKHQodGhpcyxlKSxcImJvb2xlYW5cIj09dHlwZW9mIGEmJih0aGlzLmxlPWEpLEFycmF5LmlzQXJyYXkobikmJihuPW5ldyBVaW50OEFycmF5KG4pKSwwPT09bil0aGlzLmJ5dGVPZmZzZXQ9MCx0aGlzLmJ5dGVMZW5ndGg9MDtlbHNlIGlmKG4gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7dm9pZCAwPT09aSYmKGk9bi5ieXRlTGVuZ3RoLXIpO3ZhciBzPW5ldyBEYXRhVmlldyhuLHIsaSk7dGhpcy5fc3dhcERhdGFWaWV3KHMpfWVsc2UgaWYobiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fG4gaW5zdGFuY2VvZiBEYXRhVmlld3x8biBpbnN0YW5jZW9mIGUpe3ZvaWQgMD09PWkmJihpPW4uYnl0ZUxlbmd0aC1yKSwocis9bi5ieXRlT2Zmc2V0KStpPm4uYnl0ZU9mZnNldCtuLmJ5dGVMZW5ndGgmJkwoXCJDcmVhdGluZyB2aWV3IG91dHNpZGUgb2YgYXZhaWxhYmxlIG1lbW9yeSBpbiBBcnJheUJ1ZmZlclwiKTt2YXIgdT1uZXcgRGF0YVZpZXcobi5idWZmZXIscixpKTt0aGlzLl9zd2FwRGF0YVZpZXcodSl9ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2Ygbil7dmFyIG89bmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcihuKSk7dGhpcy5fc3dhcERhdGFWaWV3KG8pfWVsc2UgTChcIkludmFsaWQgaW5wdXQgYXJndW1lbnQgZm9yIEJ1ZmZlclZpZXc6IFwiK24pfXJldHVybiByKGUsW3trZXk6XCJfc3dhcEFycmF5QnVmZmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fc3dhcERhdGFWaWV3KG5ldyBEYXRhVmlldyhlKSl9fSx7a2V5OlwiX3N3YXBCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLl9zd2FwRGF0YVZpZXcobmV3IERhdGFWaWV3KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxlLmJ5dGVMZW5ndGgpKX19LHtrZXk6XCJfc3dhcERhdGFWaWV3XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5kYXRhVmlldz1lLHRoaXMuYnVmZmVyPWUuYnVmZmVyLHRoaXMuYnl0ZU9mZnNldD1lLmJ5dGVPZmZzZXQsdGhpcy5ieXRlTGVuZ3RoPWUuYnl0ZUxlbmd0aH19LHtrZXk6XCJfbGVuZ3RoVG9FbmRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5ieXRlTGVuZ3RoLWV9fSx7a2V5Olwic2V0XCIsdmFsdWU6ZnVuY3Rpb24odCxuKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06ZTt0IGluc3RhbmNlb2YgRGF0YVZpZXd8fHQgaW5zdGFuY2VvZiBlP3Q9bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCk6dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJiYodD1uZXcgVWludDhBcnJheSh0KSksdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fEwoXCJCdWZmZXJWaWV3LnNldCgpOiBJbnZhbGlkIGRhdGEgYXJndW1lbnQuXCIpO3ZhciBpPXRoaXMudG9VaW50OCgpO3JldHVybiBpLnNldCh0LG4pLG5ldyByKHRoaXMsbix0LmJ5dGVMZW5ndGgpfX0se2tleTpcInN1YmFycmF5XCIsdmFsdWU6ZnVuY3Rpb24odCxuKXtyZXR1cm4gbmV3IGUodGhpcyx0LG49bnx8dGhpcy5fbGVuZ3RoVG9FbmQodCkpfX0se2tleTpcInRvVWludDhcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcix0aGlzLmJ5dGVPZmZzZXQsdGhpcy5ieXRlTGVuZ3RoKX19LHtrZXk6XCJnZXRVaW50OEFycmF5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsdGhpcy5ieXRlT2Zmc2V0K2UsdCl9fSx7a2V5OlwiZ2V0U3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MCx0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmJ5dGVMZW5ndGgsbj10aGlzLmdldFVpbnQ4QXJyYXkoZSx0KTtyZXR1cm4gRShuKX19LHtrZXk6XCJnZXRMYXRpbjFTdHJpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTowLHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMuYnl0ZUxlbmd0aCxuPXRoaXMuZ2V0VWludDhBcnJheShlLHQpO3JldHVybiB6KG4pfX0se2tleTpcImdldFVuaWNvZGVTdHJpbmdcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MCx0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0aGlzLmJ5dGVMZW5ndGgsbj1bXSxyPTA7cjx0JiZlK3I8dGhpcy5ieXRlTGVuZ3RoO3IrPTIpbi5wdXNoKHRoaXMuZ2V0VWludDE2KGUrcikpO3JldHVybiB6KG4pfX0se2tleTpcImdldEludDhcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRJbnQ4KGUpfX0se2tleTpcImdldFVpbnQ4XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0VWludDgoZSl9fSx7a2V5OlwiZ2V0SW50MTZcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5sZTtyZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRJbnQxNihlLHQpfX0se2tleTpcImdldEludDMyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0SW50MzIoZSx0KX19LHtrZXk6XCJnZXRVaW50MTZcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5sZTtyZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRVaW50MTYoZSx0KX19LHtrZXk6XCJnZXRVaW50MzJcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5sZTtyZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRVaW50MzIoZSx0KX19LHtrZXk6XCJnZXRGbG9hdDMyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0RmxvYXQzMihlLHQpfX0se2tleTpcImdldEZsb2F0NjRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5sZTtyZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRGbG9hdDY0KGUsdCl9fSx7a2V5OlwiZ2V0RmxvYXRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06dGhpcy5sZTtyZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRGbG9hdDMyKGUsdCl9fSx7a2V5OlwiZ2V0RG91YmxlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnRoaXMubGU7cmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0RmxvYXQ2NChlLHQpfX0se2tleTpcImdldFVpbnRCeXRlc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtzd2l0Y2godCl7Y2FzZSAxOnJldHVybiB0aGlzLmdldFVpbnQ4KGUsbik7Y2FzZSAyOnJldHVybiB0aGlzLmdldFVpbnQxNihlLG4pO2Nhc2UgNDpyZXR1cm4gdGhpcy5nZXRVaW50MzIoZSxuKTtjYXNlIDg6cmV0dXJuIHRoaXMuZ2V0VWludDY0JiZ0aGlzLmdldFVpbnQ2NChlLG4pfX19LHtrZXk6XCJnZXRVaW50XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3N3aXRjaCh0KXtjYXNlIDg6cmV0dXJuIHRoaXMuZ2V0VWludDgoZSxuKTtjYXNlIDE2OnJldHVybiB0aGlzLmdldFVpbnQxNihlLG4pO2Nhc2UgMzI6cmV0dXJuIHRoaXMuZ2V0VWludDMyKGUsbik7Y2FzZSA2NDpyZXR1cm4gdGhpcy5nZXRVaW50NjQmJnRoaXMuZ2V0VWludDY0KGUsbil9fX0se2tleTpcInRvU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGF0YVZpZXcudG9TdHJpbmcoZSx0aGlzLmNvbnN0cnVjdG9yLm5hbWUpfX0se2tleTpcImVuc3VyZUNodW5rXCIsdmFsdWU6ZnVuY3Rpb24oKXt9fV0sW3trZXk6XCJmcm9tXCIsdmFsdWU6ZnVuY3Rpb24odCxuKXtyZXR1cm4gdCBpbnN0YW5jZW9mIHRoaXMmJnQubGU9PT1uP3Q6bmV3IGUodCx2b2lkIDAsdm9pZCAwLG4pfX1dKSxlfSgpO2Z1bmN0aW9uIFIoZSx0KXtMKFwiXCIuY29uY2F0KGUsXCIgJ1wiKS5jb25jYXQodCxcIicgd2FzIG5vdCBsb2FkZWQsIHRyeSB1c2luZyBmdWxsIGJ1aWxkIG9mIGV4aWZyLlwiKSl9dmFyIE49ZnVuY3Rpb24oZSl7YShpLGUpO3ZhciBuPWQoaSk7ZnVuY3Rpb24gaShlKXt2YXIgcjtyZXR1cm4gdCh0aGlzLGkpLChyPW4uY2FsbCh0aGlzKSkua2luZD1lLHJ9cmV0dXJuIHIoaSxbe2tleTpcImdldFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuaGFzKGUpfHxSKHRoaXMua2luZCxlKSx0JiYoZSBpbiB0fHxmdW5jdGlvbihlLHQpe0woXCJVbmtub3duIFwiLmNvbmNhdChlLFwiICdcIikuY29uY2F0KHQsXCInLlwiKSl9KHRoaXMua2luZCxlKSx0W2VdLmVuYWJsZWR8fFIodGhpcy5raW5kLGUpKSx2KHMoaS5wcm90b3R5cGUpLFwiZ2V0XCIsdGhpcykuY2FsbCh0aGlzLGUpfX0se2tleTpcImtleUxpc3RcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBtKHRoaXMua2V5cygpKX19XSksaX0oYyhQKSksTT1uZXcgTihcImZpbGUgcGFyc2VyXCIpLFc9bmV3IE4oXCJzZWdtZW50IHBhcnNlclwiKSxLPW5ldyBOKFwiZmlsZSByZWFkZXJcIik7ZnVuY3Rpb24gSChlKXtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sbj0wO248YXJndW1lbnRzLmxlbmd0aDtuKyspdFtuXT1hcmd1bWVudHNbbl07dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoZS5hcHBseSh0aGlzLHQpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX1mdW5jdGlvbiBYKGUsdCxuKXtyZXR1cm4gbj90P3QoZSk6ZTooZSYmZS50aGVufHwoZT1Qcm9taXNlLnJlc29sdmUoZSkpLHQ/ZS50aGVuKHQpOmUpfXZhciBZPUgoKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxuKXt2YXIgcj1uZXcgRmlsZVJlYWRlcjtyLm9ubG9hZGVuZD1mdW5jdGlvbigpe3JldHVybiB0KHIucmVzdWx0fHxuZXcgQXJyYXlCdWZmZXIpfSxyLm9uZXJyb3I9bixyLnJlYWRBc0FycmF5QnVmZmVyKGUpfSkpfSkpLEc9SCgoZnVuY3Rpb24oZSl7cmV0dXJuIHcoZSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXJyYXlCdWZmZXIoKX0pKX0pKSxKPUgoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIFgodChlKSwoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBEKGUpfSkpfSkpLHE9SCgoZnVuY3Rpb24oZSx0LG4pe3ZhciByPW5ldyhLLmdldChuKSkoZSx0KTtyZXR1cm4gWChyLnJlYWQoKSwoZnVuY3Rpb24oKXtyZXR1cm4gcn0pKX0pKSxRPUgoKGZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBLLmhhcyhuKT9xKGUsdCxuKTpyP0ooZSxyKTooTChcIlBhcnNlciBcIi5jb25jYXQobixcIiBpcyBub3QgbG9hZGVkXCIpKSxYKCkpfSkpLFo9XCJJbnZhbGlkIGlucHV0IGFyZ3VtZW50XCI7ZnVuY3Rpb24gJChlLHQpe3JldHVybihuPWUpLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKXx8bi5sZW5ndGg+MWU0P3EoZSx0LFwiYmFzZTY0XCIpOng/UShlLHQsXCJ1cmxcIixHKTpCP3EoZSx0LFwiZnNcIik6dm9pZCBMKFopO3ZhciBufXZhciBlZT1mdW5jdGlvbihlKXthKGksZSk7dmFyIG49ZChpKTtmdW5jdGlvbiBpKCl7cmV0dXJuIHQodGhpcyxpKSxuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gcihpLFt7a2V5OlwidGFnS2V5c1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmFsbEtleXN8fCh0aGlzLmFsbEtleXM9bSh0aGlzLmtleXMoKSkpLHRoaXMuYWxsS2V5c319LHtrZXk6XCJ0YWdWYWx1ZXNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbGxWYWx1ZXN8fCh0aGlzLmFsbFZhbHVlcz1tKHRoaXMudmFsdWVzKCkpKSx0aGlzLmFsbFZhbHVlc319XSksaX0oYyhQKSk7ZnVuY3Rpb24gdGUoZSx0LG4pe3ZhciByPW5ldyBlZSxpPW47QXJyYXkuaXNBcnJheShpKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGkuZW50cmllcyYmKGk9aS5lbnRyaWVzKCkpLGk9bShpKSk7Zm9yKHZhciBhPTA7YTxpLmxlbmd0aDthKyspe3ZhciBzPWlbYV0sdT1zWzBdLG89c1sxXTtyLnNldCh1LG8pfWlmKEFycmF5LmlzQXJyYXkodCkpe3ZhciBmPXQ7QXJyYXkuaXNBcnJheShmKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGYuZW50cmllcyYmKGY9Zi5lbnRyaWVzKCkpLGY9bShmKSk7Zm9yKHZhciBjPTA7YzxmLmxlbmd0aDtjKyspe3ZhciBoPWZbY107ZS5zZXQoaCxyKX19ZWxzZSBlLnNldCh0LHIpO3JldHVybiByfWZ1bmN0aW9uIG5lKGUsdCxuKXt2YXIgcixpPWUuZ2V0KHQpLGE9bjtBcnJheS5pc0FycmF5KGEpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgYS5lbnRyaWVzJiYoYT1hLmVudHJpZXMoKSksYT1tKGEpKTtmb3IodmFyIHM9MDtzPGEubGVuZ3RoO3MrKylyPWFbc10saS5zZXQoclswXSxyWzFdKX12YXIgcmU9UygpLGllPVMoKSxhZT1TKCksc2U9Mzc1MDAsdWU9Mzc1MTAsb2U9MzM3MjMsZmU9MzQ2NzUsY2U9MzQ2NjUsaGU9MzQ4NTMsbGU9NDA5NjUsZGU9W1wiY2h1bmtlZFwiLFwiZmlyc3RDaHVua1NpemVcIixcImZpcnN0Q2h1bmtTaXplTm9kZVwiLFwiZmlyc3RDaHVua1NpemVCcm93c2VyXCIsXCJjaHVua1NpemVcIixcImNodW5rTGltaXRcIl0sdmU9W1wiamZpZlwiLFwieG1wXCIsXCJpY2NcIixcImlwdGNcIixcImloZHJcIl0scGU9W1widGlmZlwiXS5jb25jYXQodmUpLHllPVtcImlmZDBcIixcImlmZDFcIixcImV4aWZcIixcImdwc1wiLFwiaW50ZXJvcFwiXSxnZT1bXS5jb25jYXQocGUseWUpLGtlPVtcIm1ha2VyTm90ZVwiLFwidXNlckNvbW1lbnRcIl0sbWU9W1widHJhbnNsYXRlS2V5c1wiLFwidHJhbnNsYXRlVmFsdWVzXCIsXCJyZXZpdmVWYWx1ZXNcIixcIm11bHRpU2VnbWVudFwiXSxiZT1bXS5jb25jYXQobWUsW1wic2FuaXRpemVcIixcIm1lcmdlT3V0cHV0XCIsXCJzaWxlbnRFcnJvcnNcIl0pLEFlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3QodGhpcyxlKX1yZXR1cm4gcihlLFt7a2V5OlwidHJhbnNsYXRlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhbnNsYXRlS2V5c3x8dGhpcy50cmFuc2xhdGVWYWx1ZXN8fHRoaXMucmV2aXZlVmFsdWVzfX1dKSxlfSgpLHdlPWZ1bmN0aW9uKGUpe2EocyxlKTt2YXIgbj1kKHMpO2Z1bmN0aW9uIHMoZSxyLGEsdSl7dmFyIG87aWYodCh0aGlzLHMpLGkoaChvPW4uY2FsbCh0aGlzKSksXCJlbmFibGVkXCIsITEpLGkoaChvKSxcInNraXBcIixPKCkpLGkoaChvKSxcInBpY2tcIixPKCkpLGkoaChvKSxcImRlcHNcIixPKCkpLGkoaChvKSxcInRyYW5zbGF0ZUtleXNcIiwhMSksaShoKG8pLFwidHJhbnNsYXRlVmFsdWVzXCIsITEpLGkoaChvKSxcInJldml2ZVZhbHVlc1wiLCExKSxvLmtleT1lLG8uZW5hYmxlZD1yLG8ucGFyc2U9by5lbmFibGVkLG8uYXBwbHlJbmhlcml0YWJsZXModSksby5jYW5CZUZpbHRlcmVkPXllLmluY2x1ZGVzKGUpLG8uY2FuQmVGaWx0ZXJlZCYmKG8uZGljdD1yZS5nZXQoZSkpLHZvaWQgMCE9PWEpaWYoQXJyYXkuaXNBcnJheShhKSlvLnBhcnNlPW8uZW5hYmxlZD0hMCxvLmNhbkJlRmlsdGVyZWQmJmEubGVuZ3RoPjAmJm8udHJhbnNsYXRlVGFnU2V0KGEsby5waWNrKTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBhKXtpZihvLmVuYWJsZWQ9ITAsby5wYXJzZT0hMSE9PWEucGFyc2Usby5jYW5CZUZpbHRlcmVkKXt2YXIgZj1hLnBpY2ssYz1hLnNraXA7ZiYmZi5sZW5ndGg+MCYmby50cmFuc2xhdGVUYWdTZXQoZixvLnBpY2spLGMmJmMubGVuZ3RoPjAmJm8udHJhbnNsYXRlVGFnU2V0KGMsby5za2lwKX1vLmFwcGx5SW5oZXJpdGFibGVzKGEpfWVsc2UhMD09PWF8fCExPT09YT9vLnBhcnNlPW8uZW5hYmxlZD1hOkwoXCJJbnZhbGlkIG9wdGlvbnMgYXJndW1lbnQ6IFwiLmNvbmNhdChhKSk7cmV0dXJuIG99cmV0dXJuIHIocyxbe2tleTpcIm5lZWRlZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVuYWJsZWR8fHRoaXMuZGVwcy5zaXplPjB9fSx7a2V5OlwiYXBwbHlJbmhlcml0YWJsZXNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdCxuLHI9bWU7QXJyYXkuaXNBcnJheShyKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHIuZW50cmllcyYmKHI9ci5lbnRyaWVzKCkpLHI9bShyKSk7Zm9yKHZhciBpPTA7aTxyLmxlbmd0aDtpKyspdm9pZCAwIT09KG49ZVt0PXJbaV1dKSYmKHRoaXNbdF09bil9fSx7a2V5OlwidHJhbnNsYXRlVGFnU2V0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZih0aGlzLmRpY3Qpe3ZhciBuLHIsaT10aGlzLmRpY3QsYT1pLnRhZ0tleXMscz1pLnRhZ1ZhbHVlcyx1PWU7QXJyYXkuaXNBcnJheSh1KXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHUuZW50cmllcyYmKHU9dS5lbnRyaWVzKCkpLHU9bSh1KSk7Zm9yKHZhciBvPTA7bzx1Lmxlbmd0aDtvKyspXCJzdHJpbmdcIj09dHlwZW9mKG49dVtvXSk/KC0xPT09KHI9cy5pbmRleE9mKG4pKSYmKHI9YS5pbmRleE9mKE51bWJlcihuKSkpLC0xIT09ciYmdC5hZGQoTnVtYmVyKGFbcl0pKSk6dC5hZGQobil9ZWxzZXt2YXIgZj1lO0FycmF5LmlzQXJyYXkoZil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBmLmVudHJpZXMmJihmPWYuZW50cmllcygpKSxmPW0oZikpO2Zvcih2YXIgYz0wO2M8Zi5sZW5ndGg7YysrKXt2YXIgaD1mW2NdO3QuYWRkKGgpfX19fSx7a2V5OlwiZmluYWxpemVGaWx0ZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXshdGhpcy5lbmFibGVkJiZ0aGlzLmRlcHMuc2l6ZT4wPyh0aGlzLmVuYWJsZWQ9ITAsQ2UodGhpcy5waWNrLHRoaXMuZGVwcykpOnRoaXMuZW5hYmxlZCYmdGhpcy5waWNrLnNpemU+MCYmQ2UodGhpcy5waWNrLHRoaXMuZGVwcyl9fV0pLHN9KEFlKSxPZT17amZpZjohMSx0aWZmOiEwLHhtcDohMSxpY2M6ITEsaXB0YzohMSxpZmQwOiEwLGlmZDE6ITEsZXhpZjohMCxncHM6ITAsaW50ZXJvcDohMSxpaGRyOnZvaWQgMCxtYWtlck5vdGU6ITEsdXNlckNvbW1lbnQ6ITEsbXVsdGlTZWdtZW50OiExLHNraXA6W10scGljazpbXSx0cmFuc2xhdGVLZXlzOiEwLHRyYW5zbGF0ZVZhbHVlczohMCxyZXZpdmVWYWx1ZXM6ITAsc2FuaXRpemU6ITAsbWVyZ2VPdXRwdXQ6ITAsc2lsZW50RXJyb3JzOiEwLGNodW5rZWQ6ITAsZmlyc3RDaHVua1NpemU6dm9pZCAwLGZpcnN0Q2h1bmtTaXplTm9kZTo1MTIsZmlyc3RDaHVua1NpemVCcm93c2VyOjY1NTM2LGNodW5rU2l6ZTo2NTUzNixjaHVua0xpbWl0OjV9LFNlPVMoKSxQZT1mdW5jdGlvbihlKXthKGksZSk7dmFyIG49ZChpKTtmdW5jdGlvbiBpKGUpe3ZhciByO3JldHVybiB0KHRoaXMsaSkscj1uLmNhbGwodGhpcyksITA9PT1lP3Iuc2V0dXBGcm9tVHJ1ZSgpOnZvaWQgMD09PWU/ci5zZXR1cEZyb21VbmRlZmluZWQoKTpBcnJheS5pc0FycmF5KGUpP3Iuc2V0dXBGcm9tQXJyYXkoZSk6XCJvYmplY3RcIj09dHlwZW9mIGU/ci5zZXR1cEZyb21PYmplY3QoZSk6TChcIkludmFsaWQgb3B0aW9ucyBhcmd1bWVudCBcIi5jb25jYXQoZSkpLHZvaWQgMD09PXIuZmlyc3RDaHVua1NpemUmJihyLmZpcnN0Q2h1bmtTaXplPXg/ci5maXJzdENodW5rU2l6ZUJyb3dzZXI6ci5maXJzdENodW5rU2l6ZU5vZGUpLHIubWVyZ2VPdXRwdXQmJihyLmlmZDEuZW5hYmxlZD0hMSksci5maWx0ZXJOZXN0ZWRTZWdtZW50VGFncygpLHIudHJhdmVyc2VUaWZmRGVwZW5kZW5jeVRyZWUoKSxyLmNoZWNrTG9hZGVkUGx1Z2lucygpLHJ9cmV0dXJuIHIoaSxbe2tleTpcInNldHVwRnJvbVVuZGVmaW5lZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGUsdD1kZTtBcnJheS5pc0FycmF5KHQpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5lbnRyaWVzJiYodD10LmVudHJpZXMoKSksdD1tKHQpKTtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl0aGlzW2U9dFtuXV09T2VbZV07dmFyIHI9YmU7QXJyYXkuaXNBcnJheShyKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHIuZW50cmllcyYmKHI9ci5lbnRyaWVzKCkpLHI9bShyKSk7Zm9yKHZhciBpPTA7aTxyLmxlbmd0aDtpKyspdGhpc1tlPXJbaV1dPU9lW2VdO3ZhciBhPWtlO0FycmF5LmlzQXJyYXkoYSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLmVudHJpZXMmJihhPWEuZW50cmllcygpKSxhPW0oYSkpO2Zvcih2YXIgcz0wO3M8YS5sZW5ndGg7cysrKXRoaXNbZT1hW3NdXT1PZVtlXTt2YXIgdT1nZTtBcnJheS5pc0FycmF5KHUpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgdS5lbnRyaWVzJiYodT11LmVudHJpZXMoKSksdT1tKHUpKTtmb3IodmFyIG89MDtvPHUubGVuZ3RoO28rKyl0aGlzW2U9dVtvXV09bmV3IHdlKGUsT2VbZV0sdm9pZCAwLHRoaXMpfX0se2tleTpcInNldHVwRnJvbVRydWVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlLHQ9ZGU7QXJyYXkuaXNBcnJheSh0KXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZW50cmllcyYmKHQ9dC5lbnRyaWVzKCkpLHQ9bSh0KSk7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspdGhpc1tlPXRbbl1dPU9lW2VdO3ZhciByPWJlO0FycmF5LmlzQXJyYXkocil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiByLmVudHJpZXMmJihyPXIuZW50cmllcygpKSxyPW0ocikpO2Zvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKXRoaXNbZT1yW2ldXT1PZVtlXTt2YXIgYT1rZTtBcnJheS5pc0FycmF5KGEpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgYS5lbnRyaWVzJiYoYT1hLmVudHJpZXMoKSksYT1tKGEpKTtmb3IodmFyIHM9MDtzPGEubGVuZ3RoO3MrKyl0aGlzW2U9YVtzXV09ITA7dmFyIHU9Z2U7QXJyYXkuaXNBcnJheSh1KXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHUuZW50cmllcyYmKHU9dS5lbnRyaWVzKCkpLHU9bSh1KSk7Zm9yKHZhciBvPTA7bzx1Lmxlbmd0aDtvKyspdGhpc1tlPXVbb11dPW5ldyB3ZShlLCEwLHZvaWQgMCx0aGlzKX19LHtrZXk6XCJzZXR1cEZyb21BcnJheVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0LG49ZGU7QXJyYXkuaXNBcnJheShuKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG4uZW50cmllcyYmKG49bi5lbnRyaWVzKCkpLG49bShuKSk7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspdGhpc1t0PW5bcl1dPU9lW3RdO3ZhciBpPWJlO0FycmF5LmlzQXJyYXkoaSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLmVudHJpZXMmJihpPWkuZW50cmllcygpKSxpPW0oaSkpO2Zvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKXRoaXNbdD1pW2FdXT1PZVt0XTt2YXIgcz1rZTtBcnJheS5pc0FycmF5KHMpfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5lbnRyaWVzJiYocz1zLmVudHJpZXMoKSkscz1tKHMpKTtmb3IodmFyIHU9MDt1PHMubGVuZ3RoO3UrKyl0aGlzW3Q9c1t1XV09T2VbdF07dmFyIG89Z2U7QXJyYXkuaXNBcnJheShvKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG8uZW50cmllcyYmKG89by5lbnRyaWVzKCkpLG89bShvKSk7Zm9yKHZhciBmPTA7ZjxvLmxlbmd0aDtmKyspdGhpc1t0PW9bZl1dPW5ldyB3ZSh0LCExLHZvaWQgMCx0aGlzKTt0aGlzLnNldHVwR2xvYmFsRmlsdGVycyhlLHZvaWQgMCx5ZSl9fSx7a2V5Olwic2V0dXBGcm9tT2JqZWN0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ7eWUuaWZkMD15ZS5pZmQwfHx5ZS5pbWFnZSx5ZS5pZmQxPXllLmlmZDF8fHllLnRodW1ibmFpbCxnKHRoaXMsZSk7dmFyIG49ZGU7QXJyYXkuaXNBcnJheShuKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG4uZW50cmllcyYmKG49bi5lbnRyaWVzKCkpLG49bShuKSk7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspdGhpc1t0PW5bcl1dPXhlKGVbdF0sT2VbdF0pO3ZhciBpPWJlO0FycmF5LmlzQXJyYXkoaSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLmVudHJpZXMmJihpPWkuZW50cmllcygpKSxpPW0oaSkpO2Zvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKXRoaXNbdD1pW2FdXT14ZShlW3RdLE9lW3RdKTt2YXIgcz1rZTtBcnJheS5pc0FycmF5KHMpfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5lbnRyaWVzJiYocz1zLmVudHJpZXMoKSkscz1tKHMpKTtmb3IodmFyIHU9MDt1PHMubGVuZ3RoO3UrKyl0aGlzW3Q9c1t1XV09eGUoZVt0XSxPZVt0XSk7dmFyIG89cGU7QXJyYXkuaXNBcnJheShvKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG8uZW50cmllcyYmKG89by5lbnRyaWVzKCkpLG89bShvKSk7Zm9yKHZhciBmPTA7ZjxvLmxlbmd0aDtmKyspdGhpc1t0PW9bZl1dPW5ldyB3ZSh0LE9lW3RdLGVbdF0sdGhpcyk7dmFyIGM9eWU7QXJyYXkuaXNBcnJheShjKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGMuZW50cmllcyYmKGM9Yy5lbnRyaWVzKCkpLGM9bShjKSk7Zm9yKHZhciBoPTA7aDxjLmxlbmd0aDtoKyspdGhpc1t0PWNbaF1dPW5ldyB3ZSh0LE9lW3RdLGVbdF0sdGhpcy50aWZmKTt0aGlzLnNldHVwR2xvYmFsRmlsdGVycyhlLnBpY2ssZS5za2lwLHllLGdlKSwhMD09PWUudGlmZj90aGlzLmJhdGNoRW5hYmxlV2l0aEJvb2woeWUsITApOiExPT09ZS50aWZmP3RoaXMuYmF0Y2hFbmFibGVXaXRoVXNlclZhbHVlKHllLGUpOkFycmF5LmlzQXJyYXkoZS50aWZmKT90aGlzLnNldHVwR2xvYmFsRmlsdGVycyhlLnRpZmYsdm9pZCAwLHllKTpcIm9iamVjdFwiPT10eXBlb2YgZS50aWZmJiZ0aGlzLnNldHVwR2xvYmFsRmlsdGVycyhlLnRpZmYucGljayxlLnRpZmYuc2tpcCx5ZSl9fSx7a2V5OlwiYmF0Y2hFbmFibGVXaXRoQm9vbFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZTtBcnJheS5pc0FycmF5KG4pfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygbi5lbnRyaWVzJiYobj1uLmVudHJpZXMoKSksbj1tKG4pKTtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dGhpc1tuW3JdXS5lbmFibGVkPXR9fX0se2tleTpcImJhdGNoRW5hYmxlV2l0aFVzZXJWYWx1ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZTtBcnJheS5pc0FycmF5KG4pfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygbi5lbnRyaWVzJiYobj1uLmVudHJpZXMoKSksbj1tKG4pKTtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGk9bltyXSxhPXRbaV07dGhpc1tpXS5lbmFibGVkPSExIT09YSYmdm9pZCAwIT09YX19fSx7a2V5Olwic2V0dXBHbG9iYWxGaWx0ZXJzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTpuO2lmKGUmJmUubGVuZ3RoKXt2YXIgaT1yO0FycmF5LmlzQXJyYXkoaSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLmVudHJpZXMmJihpPWkuZW50cmllcygpKSxpPW0oaSkpO2Zvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKXt2YXIgcz1pW2FdO3RoaXNbc10uZW5hYmxlZD0hMX12YXIgdT1VZShlLG4pLG89dTtBcnJheS5pc0FycmF5KG8pfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygby5lbnRyaWVzJiYobz1vLmVudHJpZXMoKSksbz1tKG8pKTtmb3IodmFyIGY9MDtmPG8ubGVuZ3RoO2YrKyl7dmFyIGM9b1tmXSxoPWNbMF0sbD1jWzFdO0NlKHRoaXNbaF0ucGljayxsKSx0aGlzW2hdLmVuYWJsZWQ9ITB9fWVsc2UgaWYodCYmdC5sZW5ndGgpe3ZhciBkPVVlKHQsbiksdj1kO0FycmF5LmlzQXJyYXkodil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiB2LmVudHJpZXMmJih2PXYuZW50cmllcygpKSx2PW0odikpO2Zvcih2YXIgcD0wO3A8di5sZW5ndGg7cCsrKXt2YXIgeT12W3BdLGc9eVswXSxrPXlbMV07Q2UodGhpc1tnXS5za2lwLGspfX19fSx7a2V5OlwiZmlsdGVyTmVzdGVkU2VnbWVudFRhZ3NcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuaWZkMCx0PXRoaXMuZXhpZixuPXRoaXMueG1wLHI9dGhpcy5pcHRjLGk9dGhpcy5pY2M7dGhpcy5tYWtlck5vdGU/dC5kZXBzLmFkZChzZSk6dC5za2lwLmFkZChzZSksdGhpcy51c2VyQ29tbWVudD90LmRlcHMuYWRkKHVlKTp0LnNraXAuYWRkKHVlKSxuLmVuYWJsZWR8fGUuc2tpcC5hZGQoNzAwKSxyLmVuYWJsZWR8fGUuc2tpcC5hZGQob2UpLGkuZW5hYmxlZHx8ZS5za2lwLmFkZChmZSl9fSx7a2V5OlwidHJhdmVyc2VUaWZmRGVwZW5kZW5jeVRyZWVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLmlmZDAsbj10aGlzLmV4aWYscj10aGlzLmdwczt0aGlzLmludGVyb3AubmVlZGVkJiYobi5kZXBzLmFkZChsZSksdC5kZXBzLmFkZChsZSkpLG4ubmVlZGVkJiZ0LmRlcHMuYWRkKGNlKSxyLm5lZWRlZCYmdC5kZXBzLmFkZChoZSksdGhpcy50aWZmLmVuYWJsZWQ9eWUuc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuITA9PT1lW3RdLmVuYWJsZWR9KSl8fHRoaXMubWFrZXJOb3RlfHx0aGlzLnVzZXJDb21tZW50O3ZhciBpPXllO0FycmF5LmlzQXJyYXkoaSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLmVudHJpZXMmJihpPWkuZW50cmllcygpKSxpPW0oaSkpO2Zvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKXt0aGlzW2lbYV1dLmZpbmFsaXplRmlsdGVycygpfX19LHtrZXk6XCJvbmx5VGlmZlwiLGdldDpmdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIXZlLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF0uZW5hYmxlZH0pKS5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4hMD09PWV9KSkmJnRoaXMudGlmZi5lbmFibGVkfX0se2tleTpcImNoZWNrTG9hZGVkUGx1Z2luc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9cGU7QXJyYXkuaXNBcnJheShlKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZW50cmllcyYmKGU9ZS5lbnRyaWVzKCkpLGU9bShlKSk7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe3ZhciBuPWVbdF07dGhpc1tuXS5lbmFibGVkJiYhVy5oYXMobikmJlIoXCJzZWdtZW50IHBhcnNlclwiLG4pfX19XSxbe2tleTpcInVzZUNhY2hlZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PVNlLmdldChlKTtyZXR1cm4gdm9pZCAwIT09dHx8KHQ9bmV3IHRoaXMoZSksU2Uuc2V0KGUsdCkpLHR9fV0pLGl9KEFlKTtmdW5jdGlvbiBVZShlLHQpe3ZhciBuLHIsaSxhPVtdLHM9dDtBcnJheS5pc0FycmF5KHMpfHwoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5lbnRyaWVzJiYocz1zLmVudHJpZXMoKSkscz1tKHMpKTtmb3IodmFyIHU9MDt1PHMubGVuZ3RoO3UrKyl7cj1zW3VdLG49W107dmFyIG89cmUuZ2V0KHIpO0FycmF5LmlzQXJyYXkobyl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBvLmVudHJpZXMmJihvPW8uZW50cmllcygpKSxvPW0obykpO2Zvcih2YXIgZj0wO2Y8by5sZW5ndGg7ZisrKWk9b1tmXSwoZS5pbmNsdWRlcyhpWzBdKXx8ZS5pbmNsdWRlcyhpWzFdKSkmJm4ucHVzaChpWzBdKTtuLmxlbmd0aCYmYS5wdXNoKFtyLG5dKX1yZXR1cm4gYX1mdW5jdGlvbiB4ZShlLHQpe3JldHVybiB2b2lkIDAhPT1lP2U6dm9pZCAwIT09dD90OnZvaWQgMH1mdW5jdGlvbiBDZShlLHQpe3ZhciBuPXQ7QXJyYXkuaXNBcnJheShuKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG4uZW50cmllcyYmKG49bi5lbnRyaWVzKCkpLG49bShuKSk7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBpPW5bcl07ZS5hZGQoaSl9fWZ1bmN0aW9uIEJlKGUsdCxuKXtyZXR1cm4gbj90P3QoZSk6ZTooZSYmZS50aGVufHwoZT1Qcm9taXNlLnJlc29sdmUoZSkpLHQ/ZS50aGVuKHQpOmUpfWZ1bmN0aW9uIGplKCl7fWZ1bmN0aW9uIF9lKGUsdCl7aWYoIXQpcmV0dXJuIGUmJmUudGhlbj9lLnRoZW4oamUpOlByb21pc2UucmVzb2x2ZSgpfWZ1bmN0aW9uIFZlKGUsdCl7dmFyIG49ZSgpO3JldHVybiBuJiZuLnRoZW4/bi50aGVuKHQpOnQobil9aShQZSxcImRlZmF1bHRcIixPZSk7dmFyIEllPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShuKXt0KHRoaXMsZSksaSh0aGlzLFwicGFyc2Vyc1wiLHt9KSx0aGlzLm9wdGlvbnM9UGUudXNlQ2FjaGVkKG4pfXJldHVybiByKGUsW3trZXk6XCJzZXR1cFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYoIXRoaXMuZmlsZVBhcnNlcil7dmFyIGU9dGhpcy5maWxlLHQ9ZS5nZXRVaW50MTYoMCksbj1NO0FycmF5LmlzQXJyYXkobil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLmVudHJpZXMmJihuPW4uZW50cmllcygpKSxuPW0obikpO2Zvcih2YXIgcj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgaT1uW3JdLGE9aVswXSxzPWlbMV07aWYocy5jYW5IYW5kbGUoZSx0KSlyZXR1cm4gdGhpcy5maWxlUGFyc2VyPW5ldyBzKHRoaXMub3B0aW9ucyx0aGlzLmZpbGUsdGhpcy5wYXJzZXJzKSxlW2FdPSEwfUwoXCJVbmtub3duIGZpbGUgZm9ybWF0XCIpfX19LHtrZXk6XCJyZWFkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dHJ5e3ZhciB0PXRoaXM7cmV0dXJuIEJlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/JChlLHQpOngmJiFDJiZlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudD8kKGUuc3JjLHQpOmUgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ8fGUgaW5zdGFuY2VvZiBEYXRhVmlldz9uZXcgRChlKTp4JiZlIGluc3RhbmNlb2YgQmxvYj9RKGUsdCxcImJsb2JcIixZKTp2b2lkIEwoWil9KGUsdC5vcHRpb25zKSwoZnVuY3Rpb24oZSl7dC5maWxlPWV9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJwYXJzZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7ZS5zZXR1cCgpO3ZhciB0PXt9LG49W107cmV0dXJuIFZlKChmdW5jdGlvbigpe3JldHVybiBlLm9wdGlvbnMuc2lsZW50RXJyb3JzP0JlKGUuZG9QYXJzZSh0LG4pLmNhdGNoKChmdW5jdGlvbihlKXtyZXR1cm4gbi5wdXNoKGUpfSkpLChmdW5jdGlvbigpe24ucHVzaC5hcHBseShuLGUuZmlsZVBhcnNlci5lcnJvcnMpfSkpOl9lKGUuZG9QYXJzZSh0LG4pKX0pLChmdW5jdGlvbigpe3JldHVybiBlLmZpbGUuY2xvc2UmJmUuZmlsZS5jbG9zZSgpLGUub3B0aW9ucy5zaWxlbnRFcnJvcnMmJm4ubGVuZ3RoPjAmJih0LmVycm9ycz1uKSxJKHI9dCk/dm9pZCAwOnI7dmFyIHJ9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJkb1BhcnNlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0cnl7dmFyIG49dGhpcztyZXR1cm4gQmUobi5maWxlUGFyc2VyLnBhcnNlKCksKGZ1bmN0aW9uKCl7dmFyIHIsaT1wKG4ucGFyc2VycykubWFwKChyPWZ1bmN0aW9uKHQpe3JldHVybiBCZSh0LnBhcnNlKCksKGZ1bmN0aW9uKG4pe3QuYXNzaWduVG9PdXRwdXQoZSxuKX0pKX0sZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoci5hcHBseSh0aGlzLGUpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSkpO2lmKG4ub3B0aW9ucy5zaWxlbnRFcnJvcnMpe3ZhciBhPWZ1bmN0aW9uKGUpe3JldHVybiB0LnB1c2goZSl9O2k9aS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNhdGNoKGEpfSkpfXJldHVybiBfZShQcm9taXNlLmFsbChpKSl9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJleHRyYWN0VGh1bWJuYWlsXCIsdmFsdWU6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9dGhpcztlLnNldHVwKCk7dmFyIHQsbj1lLm9wdGlvbnMscj1lLmZpbGUsaT1XLmdldChcInRpZmZcIixuKTtyZXR1cm4gVmUoKGZ1bmN0aW9uKCl7aWYoIXIudGlmZilyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9ZSgpO2lmKHQmJnQudGhlbilyZXR1cm4gdC50aGVuKGplKX0oKGZ1bmN0aW9uKCl7aWYoci5qcGVnKXJldHVybiBCZShlLmZpbGVQYXJzZXIuZ2V0T3JGaW5kU2VnbWVudChcInRpZmZcIiksKGZ1bmN0aW9uKGUpe3Q9ZX0pKX0pKTt0PXtzdGFydDowLHR5cGU6XCJ0aWZmXCJ9fSksKGZ1bmN0aW9uKCl7aWYodm9pZCAwIT09dClyZXR1cm4gQmUoZS5maWxlUGFyc2VyLmVuc3VyZVNlZ21lbnRDaHVuayh0KSwoZnVuY3Rpb24odCl7cmV0dXJuIEJlKChlLnBhcnNlcnMudGlmZj1uZXcgaSh0LG4scikpLmV4dHJhY3RUaHVtYm5haWwoKSwoZnVuY3Rpb24oZSl7cmV0dXJuIHIuY2xvc2UmJnIuY2xvc2UoKSxlfSkpfSkpfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fV0pLGV9KCk7dmFyIExlLFRlPShMZT1mdW5jdGlvbihlLHQpe3ZhciBuLHIsaSxhPW5ldyBJZSh0KTtyZXR1cm4gbj1hLnJlYWQoZSkscj1mdW5jdGlvbigpe3JldHVybiBhLnBhcnNlKCl9LGk/cj9yKG4pOm46KG4mJm4udGhlbnx8KG49UHJvbWlzZS5yZXNvbHZlKG4pKSxyP24udGhlbihyKTpuKX0sZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoTGUuYXBwbHkodGhpcyxlKSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0pLHplPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLHBhcnNlOlRlLEV4aWZyOkllLGZpbGVQYXJzZXJzOk0sc2VnbWVudFBhcnNlcnM6VyxmaWxlUmVhZGVyczpLLHRhZ0tleXM6cmUsdGFnVmFsdWVzOmllLHRhZ1Jldml2ZXJzOmFlLGNyZWF0ZURpY3Rpb25hcnk6dGUsZXh0ZW5kRGljdGlvbmFyeTpuZSxmZXRjaFVybEFzQXJyYXlCdWZmZXI6RyxyZWFkQmxvYkFzQXJyYXlCdWZmZXI6WSxjaHVua2VkUHJvcHM6ZGUsb3RoZXJTZWdtZW50czp2ZSxzZWdtZW50czpwZSx0aWZmQmxvY2tzOnllLHNlZ21lbnRzQW5kQmxvY2tzOmdlLHRpZmZFeHRyYWN0YWJsZXM6a2UsaW5oZXJpdGFibGVzOm1lLGFsbEZvcm1hdHRlcnM6YmUsT3B0aW9uczpQZX0pO2Z1bmN0aW9uIEZlKCl7fXZhciBFZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUobixyLGEpe3ZhciBzPXRoaXM7dCh0aGlzLGUpLGkodGhpcyxcImVycm9yc1wiLFtdKSxpKHRoaXMsXCJlbnN1cmVTZWdtZW50Q2h1bmtcIixmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sbj0wO248YXJndW1lbnRzLmxlbmd0aDtuKyspdFtuXT1hcmd1bWVudHNbbl07dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoZS5hcHBseSh0aGlzLHQpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0oKGZ1bmN0aW9uKGUpe3ZhciB0LG4scixpPWUuc3RhcnQsYT1lLnNpemV8fDY1NTM2O3JldHVybiB0PWZ1bmN0aW9uKCl7aWYocy5maWxlLmNodW5rZWQpcmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PWUoKTtpZih0JiZ0LnRoZW4pcmV0dXJuIHQudGhlbihGZSl9KChmdW5jdGlvbigpe2lmKCFzLmZpbGUuYXZhaWxhYmxlKGksYSkpcmV0dXJuIGZ1bmN0aW9uKGUpe2lmKGUmJmUudGhlbilyZXR1cm4gZS50aGVuKEZlKX0oZnVuY3Rpb24oZSx0KXt0cnl7dmFyIG49ZSgpfWNhdGNoKGUpe3JldHVybiB0KGUpfXJldHVybiBuJiZuLnRoZW4/bi50aGVuKHZvaWQgMCx0KTpufSgoZnVuY3Rpb24oKXtyZXR1cm4gdD1zLmZpbGUucmVhZENodW5rKGksYSksbj1mdW5jdGlvbih0KXtlLmNodW5rPXR9LHI/bj9uKHQpOnQ6KHQmJnQudGhlbnx8KHQ9UHJvbWlzZS5yZXNvbHZlKHQpKSxuP3QudGhlbihuKTp0KTt2YXIgdCxuLHJ9KSwoZnVuY3Rpb24odCl7TChcIkNvdWxkbid0IHJlYWQgc2VnbWVudDogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGUpLFwiLiBcIikuY29uY2F0KHQubWVzc2FnZSkpfSkpKTtlLmNodW5rPXMuZmlsZS5zdWJhcnJheShpLGEpfSkpO3MuZmlsZS5ieXRlTGVuZ3RoPmkrYT9lLmNodW5rPXMuZmlsZS5zdWJhcnJheShpLGEpOnZvaWQgMD09PWUuc2l6ZT9lLmNodW5rPXMuZmlsZS5zdWJhcnJheShpKTpMKFwiU2VnbWVudCB1bnJlYWNoYWJsZTogXCIrSlNPTi5zdHJpbmdpZnkoZSkpfSxuPWZ1bmN0aW9uKCl7cmV0dXJuIGUuY2h1bmt9LChyPXQoKSkmJnIudGhlbj9yLnRoZW4obik6bihyKX0pKSksdGhpcy5leHRlbmRPcHRpb25zJiZ0aGlzLmV4dGVuZE9wdGlvbnMobiksdGhpcy5vcHRpb25zPW4sdGhpcy5maWxlPXIsdGhpcy5wYXJzZXJzPWF9cmV0dXJuIHIoZSxbe2tleTpcImluamVjdFNlZ21lbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMub3B0aW9uc1tlXS5lbmFibGVkJiZ0aGlzLmNyZWF0ZVBhcnNlcihlLHQpfX0se2tleTpcImNyZWF0ZVBhcnNlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49bmV3KFcuZ2V0KGUpKSh0LHRoaXMub3B0aW9ucyx0aGlzLmZpbGUpO3JldHVybiB0aGlzLnBhcnNlcnNbZV09bn19LHtrZXk6XCJjcmVhdGVQYXJzZXJzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZTtBcnJheS5pc0FycmF5KHQpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5lbnRyaWVzJiYodD10LmVudHJpZXMoKSksdD1tKHQpKTtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXSxpPXIudHlwZSxhPXIuY2h1bmsscz10aGlzLm9wdGlvbnNbaV07aWYocyYmcy5lbmFibGVkKXt2YXIgdT10aGlzLnBhcnNlcnNbaV07dSYmdS5hcHBlbmR8fHV8fHRoaXMuY3JlYXRlUGFyc2VyKGksYSl9fX19LHtrZXk6XCJyZWFkU2VnbWVudHNcIix2YWx1ZTpmdW5jdGlvbihlKXt0cnl7dmFyIHQ9ZS5tYXAodGhpcy5lbnN1cmVTZWdtZW50Q2h1bmspO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCF0KXJldHVybiBlJiZlLnRoZW4/ZS50aGVuKEZlKTpQcm9taXNlLnJlc29sdmUoKX0oUHJvbWlzZS5hbGwodCkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fV0pLGV9KCksRGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKG4pe3ZhciByPXRoaXMsYT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30scz1hcmd1bWVudHMubGVuZ3RoPjI/YXJndW1lbnRzWzJdOnZvaWQgMDt0KHRoaXMsZSksaSh0aGlzLFwiZXJyb3JzXCIsW10pLGkodGhpcyxcInJhd1wiLFMoKSksaSh0aGlzLFwiaGFuZGxlRXJyb3JcIiwoZnVuY3Rpb24oZSl7aWYoIXIub3B0aW9ucy5zaWxlbnRFcnJvcnMpdGhyb3cgZTtyLmVycm9ycy5wdXNoKGUubWVzc2FnZSl9KSksdGhpcy5jaHVuaz10aGlzLm5vcm1hbGl6ZUlucHV0KG4pLHRoaXMuZmlsZT1zLHRoaXMudHlwZT10aGlzLmNvbnN0cnVjdG9yLnR5cGUsdGhpcy5nbG9iYWxPcHRpb25zPXRoaXMub3B0aW9ucz1hLHRoaXMubG9jYWxPcHRpb25zPWFbdGhpcy50eXBlXSx0aGlzLmNhblRyYW5zbGF0ZT10aGlzLmxvY2FsT3B0aW9ucyYmdGhpcy5sb2NhbE9wdGlvbnMudHJhbnNsYXRlfXJldHVybiByKGUsW3trZXk6XCJub3JtYWxpemVJbnB1dFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgRD9lOm5ldyBEKGUpfX0se2tleTpcInRyYW5zbGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jYW5UcmFuc2xhdGUmJih0aGlzLnRyYW5zbGF0ZWQ9dGhpcy50cmFuc2xhdGVCbG9jayh0aGlzLnJhdyx0aGlzLnR5cGUpKX19LHtrZXk6XCJvdXRwdXRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFuc2xhdGVkP3RoaXMudHJhbnNsYXRlZDp0aGlzLnJhdz9rKHRoaXMucmF3KTp2b2lkIDB9fSx7a2V5OlwidHJhbnNsYXRlQmxvY2tcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWFlLmdldCh0KSxyPWllLmdldCh0KSxpPXJlLmdldCh0KSxhPXRoaXMub3B0aW9uc1t0XSxzPWEucmV2aXZlVmFsdWVzJiYhIW4sdT1hLnRyYW5zbGF0ZVZhbHVlcyYmISFyLG89YS50cmFuc2xhdGVLZXlzJiYhIWksZj17fSxjPWU7QXJyYXkuaXNBcnJheShjKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGMuZW50cmllcyYmKGM9Yy5lbnRyaWVzKCkpLGM9bShjKSk7Zm9yKHZhciBoPTA7aDxjLmxlbmd0aDtoKyspe3ZhciBsPWNbaF0sZD1sWzBdLHY9bFsxXTtzJiZuLmhhcyhkKT92PW4uZ2V0KGQpKHYpOnUmJnIuaGFzKGQpJiYodj10aGlzLnRyYW5zbGF0ZVZhbHVlKHYsci5nZXQoZCkpKSxvJiZpLmhhcyhkKSYmKGQ9aS5nZXQoZCl8fGQpLGZbZF09dn1yZXR1cm4gZn19LHtrZXk6XCJ0cmFuc2xhdGVWYWx1ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRbZV18fHQuREVGQVVMVHx8ZX19LHtrZXk6XCJhc3NpZ25Ub091dHB1dFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5hc3NpZ25PYmplY3RUb091dHB1dChlLHRoaXMuY29uc3RydWN0b3IudHlwZSx0KX19LHtrZXk6XCJhc3NpZ25PYmplY3RUb091dHB1dFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtpZih0aGlzLmdsb2JhbE9wdGlvbnMubWVyZ2VPdXRwdXQpcmV0dXJuIGcoZSxuKTtlW3RdP2coZVt0XSxuKTplW3RdPW59fV0sW3trZXk6XCJmaW5kUG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWUuZ2V0VWludDE2KHQrMikrMixyPVwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuaGVhZGVyTGVuZ3RoP3RoaXMuaGVhZGVyTGVuZ3RoKGUsdCxuKTp0aGlzLmhlYWRlckxlbmd0aCxpPXQrcixhPW4tcjtyZXR1cm57b2Zmc2V0OnQsbGVuZ3RoOm4saGVhZGVyTGVuZ3RoOnIsc3RhcnQ6aSxzaXplOmEsZW5kOmkrYX19fSx7a2V5OlwicGFyc2VcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30sbj1uZXcgUGUoaSh7fSx0aGlzLnR5cGUsdCkpLHI9bmV3IHRoaXMoZSxuKTtyZXR1cm4gci5wYXJzZSgpfX1dKSxlfSgpO2Z1bmN0aW9uIFJlKGUsdCxuKXtyZXR1cm4gbj90P3QoZSk6ZTooZSYmZS50aGVufHwoZT1Qcm9taXNlLnJlc29sdmUoZSkpLHQ/ZS50aGVuKHQpOmUpfWkoRGUsXCJoZWFkZXJMZW5ndGhcIiw0KSxpKERlLFwidHlwZVwiLHZvaWQgMCksaShEZSxcIm11bHRpU2VnbWVudFwiLCExKSxpKERlLFwiY2FuSGFuZGxlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuITF9KSk7ZnVuY3Rpb24gTmUoKXt9ZnVuY3Rpb24gTWUoZSx0KXtpZighdClyZXR1cm4gZSYmZS50aGVuP2UudGhlbihOZSk6UHJvbWlzZS5yZXNvbHZlKCl9ZnVuY3Rpb24gV2UoZSl7dmFyIHQ9ZSgpO2lmKHQmJnQudGhlbilyZXR1cm4gdC50aGVuKE5lKX1mdW5jdGlvbiBLZShlLHQpe3ZhciBuPWUoKTtyZXR1cm4gbiYmbi50aGVuP24udGhlbih0KTp0KG4pfWZ1bmN0aW9uIEhlKGUsdCxuKXtpZighZS5zKXtpZihuIGluc3RhbmNlb2YgWGUpe2lmKCFuLnMpcmV0dXJuIHZvaWQobi5vPUhlLmJpbmQobnVsbCxlLHQpKTsxJnQmJih0PW4ucyksbj1uLnZ9aWYobiYmbi50aGVuKXJldHVybiB2b2lkIG4udGhlbihIZS5iaW5kKG51bGwsZSx0KSxIZS5iaW5kKG51bGwsZSwyKSk7ZS5zPXQsZS52PW47dmFyIHI9ZS5vO3ImJnIoZSl9fXZhciBYZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIGUucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24odCxuKXt2YXIgcj1uZXcgZSxpPXRoaXMucztpZihpKXt2YXIgYT0xJmk/dDpuO2lmKGEpe3RyeXtIZShyLDEsYSh0aGlzLnYpKX1jYXRjaChlKXtIZShyLDIsZSl9cmV0dXJuIHJ9cmV0dXJuIHRoaXN9cmV0dXJuIHRoaXMubz1mdW5jdGlvbihlKXt0cnl7dmFyIGk9ZS52OzEmZS5zP0hlKHIsMSx0P3QoaSk6aSk6bj9IZShyLDEsbihpKSk6SGUociwyLGkpfWNhdGNoKGUpe0hlKHIsMixlKX19LHJ9LGV9KCk7ZnVuY3Rpb24gWWUoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBYZSYmMSZlLnN9ZnVuY3Rpb24gR2UoZSx0LG4pe2Zvcih2YXIgcjs7KXt2YXIgaT1lKCk7aWYoWWUoaSkmJihpPWkudiksIWkpcmV0dXJuIGE7aWYoaS50aGVuKXtyPTA7YnJlYWt9dmFyIGE9bigpO2lmKGEmJmEudGhlbil7aWYoIVllKGEpKXtyPTE7YnJlYWt9YT1hLnN9aWYodCl7dmFyIHM9dCgpO2lmKHMmJnMudGhlbiYmIVllKHMpKXtyPTI7YnJlYWt9fX12YXIgdT1uZXcgWGUsbz1IZS5iaW5kKG51bGwsdSwyKTtyZXR1cm4oMD09PXI/aS50aGVuKGMpOjE9PT1yP2EudGhlbihmKTpzLnRoZW4oaCkpLnRoZW4odm9pZCAwLG8pLHU7ZnVuY3Rpb24gZihyKXthPXI7ZG97aWYodCYmKHM9dCgpKSYmcy50aGVuJiYhWWUocykpcmV0dXJuIHZvaWQgcy50aGVuKGgpLnRoZW4odm9pZCAwLG8pO2lmKCEoaT1lKCkpfHxZZShpKSYmIWkudilyZXR1cm4gdm9pZCBIZSh1LDEsYSk7aWYoaS50aGVuKXJldHVybiB2b2lkIGkudGhlbihjKS50aGVuKHZvaWQgMCxvKTtZZShhPW4oKSkmJihhPWEudil9d2hpbGUoIWF8fCFhLnRoZW4pO2EudGhlbihmKS50aGVuKHZvaWQgMCxvKX1mdW5jdGlvbiBjKGUpe2U/KGE9bigpKSYmYS50aGVuP2EudGhlbihmKS50aGVuKHZvaWQgMCxvKTpmKGEpOkhlKHUsMSxhKX1mdW5jdGlvbiBoKCl7KGk9ZSgpKT9pLnRoZW4/aS50aGVuKGMpLnRoZW4odm9pZCAwLG8pOmMoaSk6SGUodSwxLGEpfX1mdW5jdGlvbiBKZShlKXtyZXR1cm4gMTkyPT09ZXx8MTk0PT09ZXx8MTk2PT09ZXx8MjE5PT09ZXx8MjIxPT09ZXx8MjE4PT09ZXx8MjU0PT09ZX1mdW5jdGlvbiBxZShlKXtyZXR1cm4gZT49MjI0JiZlPD0yMzl9ZnVuY3Rpb24gUWUoZSx0LG4pe3ZhciByPVc7QXJyYXkuaXNBcnJheShyKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHIuZW50cmllcyYmKHI9ci5lbnRyaWVzKCkpLHI9bShyKSk7Zm9yKHZhciBpPTA7aTxyLmxlbmd0aDtpKyspe3ZhciBhPXJbaV0scz1hWzBdO2lmKGFbMV0uY2FuSGFuZGxlKGUsdCxuKSlyZXR1cm4gc319dmFyIFplPWZ1bmN0aW9uKGUpe2EocyxlKTt2YXIgbj1kKHMpO2Z1bmN0aW9uIHMoKXt2YXIgZTt0KHRoaXMscyk7Zm9yKHZhciByPWFyZ3VtZW50cy5sZW5ndGgsYT1uZXcgQXJyYXkociksdT0wO3U8cjt1KyspYVt1XT1hcmd1bWVudHNbdV07cmV0dXJuIGkoaChlPW4uY2FsbC5hcHBseShuLFt0aGlzXS5jb25jYXQoYSkpKSxcImFwcFNlZ21lbnRzXCIsW10pLGkoaChlKSxcImpwZWdTZWdtZW50c1wiLFtdKSxpKGgoZSksXCJ1bmtub3duU2VnbWVudHNcIixbXSksZX1yZXR1cm4gcihzLFt7a2V5OlwicGFyc2VcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO3JldHVybiBSZShlLmZpbmRBcHBTZWdtZW50cygpLChmdW5jdGlvbigpe3JldHVybiBSZShlLnJlYWRTZWdtZW50cyhlLmFwcFNlZ21lbnRzKSwoZnVuY3Rpb24oKXtlLm1lcmdlTXVsdGlTZWdtZW50cygpLGUuY3JlYXRlUGFyc2VycyhlLm1lcmdlZEFwcFNlZ21lbnRzfHxlLmFwcFNlZ21lbnRzKX0pKX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcInNldHVwU2VnbWVudEZpbmRlckFyZ3NcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzOyEwPT09ZT8odGhpcy5maW5kQWxsPSEwLHRoaXMud2FudGVkPU8oVy5rZXlMaXN0KCkpKTooZT12b2lkIDA9PT1lP1cua2V5TGlzdCgpLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIHQub3B0aW9uc1tlXS5lbmFibGVkfSkpOmUuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gdC5vcHRpb25zW2VdLmVuYWJsZWQmJlcuaGFzKGUpfSkpLHRoaXMuZmluZEFsbD0hMSx0aGlzLnJlbWFpbmluZz1PKGUpLHRoaXMud2FudGVkPU8oZSkpLHRoaXMudW5maW5pc2hlZE11bHRpU2VnbWVudD0hMX19LHtrZXk6XCJmaW5kQXBwU2VnbWVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTowLHQ9YXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDA7dHJ5e3ZhciBuPXRoaXM7bi5zZXR1cFNlZ21lbnRGaW5kZXJBcmdzKHQpO3ZhciByPW4uZmlsZSxpPW4uZmluZEFsbCxhPW4ud2FudGVkLHM9bi5yZW1haW5pbmc7cmV0dXJuIEtlKChmdW5jdGlvbigpe2lmKCFpJiZuLmZpbGUuY2h1bmtlZClyZXR1cm4gaT1tKGEpLnNvbWUoKGZ1bmN0aW9uKGUpe3ZhciB0PVcuZ2V0KGUpLHI9bi5vcHRpb25zW2VdO3JldHVybiB0Lm11bHRpU2VnbWVudCYmci5tdWx0aVNlZ21lbnR9KSksV2UoKGZ1bmN0aW9uKCl7aWYoaSlyZXR1cm4gTWUobi5maWxlLnJlYWRXaG9sZSgpKX0pKX0pLChmdW5jdGlvbigpe3ZhciB0PSExO2lmKGU9bi5maW5kQXBwU2VnbWVudHNJblJhbmdlKGUsci5ieXRlTGVuZ3RoKSwhbi5vcHRpb25zLm9ubHlUaWZmKXJldHVybiBmdW5jdGlvbigpe2lmKHIuY2h1bmtlZCl7dmFyIGk9ITE7cmV0dXJuIEdlKChmdW5jdGlvbigpe3JldHVybiF0JiZzLnNpemU+MCYmIWkmJighIXIuY2FuUmVhZE5leHRDaHVua3x8ISFuLnVuZmluaXNoZWRNdWx0aVNlZ21lbnQpfSksdm9pZCAwLChmdW5jdGlvbigpe3ZhciBhPXIubmV4dENodW5rT2Zmc2V0LHM9bi5hcHBTZWdtZW50cy5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4hbi5maWxlLmF2YWlsYWJsZShlLm9mZnNldHx8ZS5zdGFydCxlLmxlbmd0aHx8ZS5zaXplKX0pKTtyZXR1cm4gS2UoKGZ1bmN0aW9uKCl7cmV0dXJuIGU+YSYmIXM/UmUoci5yZWFkTmV4dENodW5rKGUpLChmdW5jdGlvbihlKXtpPSFlfSkpOlJlKHIucmVhZE5leHRDaHVuayhhKSwoZnVuY3Rpb24oZSl7aT0hZX0pKX0pLChmdW5jdGlvbigpe3ZvaWQgMD09PShlPW4uZmluZEFwcFNlZ21lbnRzSW5SYW5nZShlLHIuYnl0ZUxlbmd0aCkpJiYodD0hMCl9KSl9KSl9fSgpfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwiZmluZEFwcFNlZ21lbnRzSW5SYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dC09Mjtmb3IodmFyIG4scixpLGEscyx1LG89dGhpcy5maWxlLGY9dGhpcy5maW5kQWxsLGM9dGhpcy53YW50ZWQsaD10aGlzLnJlbWFpbmluZyxsPXRoaXMub3B0aW9ucztlPHQ7ZSsrKWlmKDI1NT09PW8uZ2V0VWludDgoZSkpaWYocWUobj1vLmdldFVpbnQ4KGUrMSkpKXtpZihyPW8uZ2V0VWludDE2KGUrMiksKGk9UWUobyxlLHIpKSYmYy5oYXMoaSkmJihzPShhPVcuZ2V0KGkpKS5maW5kUG9zaXRpb24obyxlKSx1PWxbaV0scy50eXBlPWksdGhpcy5hcHBTZWdtZW50cy5wdXNoKHMpLCFmJiYoYS5tdWx0aVNlZ21lbnQmJnUubXVsdGlTZWdtZW50Pyh0aGlzLnVuZmluaXNoZWRNdWx0aVNlZ21lbnQ9cy5jaHVua051bWJlcjxzLmNodW5rQ291bnQsdGhpcy51bmZpbmlzaGVkTXVsdGlTZWdtZW50fHxoLmRlbGV0ZShpKSk6aC5kZWxldGUoaSksMD09PWguc2l6ZSkpKWJyZWFrO2wucmVjb3JkVW5rbm93blNlZ21lbnRzJiYoKHM9RGUuZmluZFBvc2l0aW9uKG8sZSkpLm1hcmtlcj1uLHRoaXMudW5rbm93blNlZ21lbnRzLnB1c2gocykpLGUrPXIrMX1lbHNlIGlmKEplKG4pKXtpZihyPW8uZ2V0VWludDE2KGUrMiksMjE4PT09biYmITEhPT1sLnN0b3BBZnRlclNvcylyZXR1cm47bC5yZWNvcmRKcGVnU2VnbWVudHMmJnRoaXMuanBlZ1NlZ21lbnRzLnB1c2goe29mZnNldDplLGxlbmd0aDpyLG1hcmtlcjpufSksZSs9cisxfXJldHVybiBlfX0se2tleTpcIm1lcmdlTXVsdGlTZWdtZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztpZih0aGlzLmFwcFNlZ21lbnRzLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiBlLm11bHRpU2VnbWVudH0pKSl7dmFyIHQ9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG4scixpLGE9UygpLHM9MDtzPGUubGVuZ3RoO3MrKylyPShuPWVbc10pW3RdLGEuaGFzKHIpP2k9YS5nZXQocik6YS5zZXQocixpPVtdKSxpLnB1c2gobik7cmV0dXJuIG0oYSl9KHRoaXMuYXBwU2VnbWVudHMsXCJ0eXBlXCIpO3RoaXMubWVyZ2VkQXBwU2VnbWVudHM9dC5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBuPXRbMF0scj10WzFdLGk9Vy5nZXQobixlLm9wdGlvbnMpO3JldHVybiBpLmhhbmRsZU11bHRpU2VnbWVudHM/e3R5cGU6bixjaHVuazppLmhhbmRsZU11bHRpU2VnbWVudHMocil9OnJbMF19KSl9fX0se2tleTpcImdldFNlZ21lbnRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hcHBTZWdtZW50cy5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlPT09ZX0pKX19LHtrZXk6XCJnZXRPckZpbmRTZWdtZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dHJ5e3ZhciB0PXRoaXMsbj10LmdldFNlZ21lbnQoZSk7cmV0dXJuIEtlKChmdW5jdGlvbigpe2lmKHZvaWQgMD09PW4pcmV0dXJuIFJlKHQuZmluZEFwcFNlZ21lbnRzKDAsW2VdKSwoZnVuY3Rpb24oKXtuPXQuZ2V0U2VnbWVudChlKX0pKX0pLChmdW5jdGlvbigpe3JldHVybiBufSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fV0sW3trZXk6XCJjYW5IYW5kbGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiA2NTQ5Nj09PXR9fV0pLHN9KEVlKTtmdW5jdGlvbiAkZSgpe31pKFplLFwidHlwZVwiLFwianBlZ1wiKSxNLnNldChcImpwZWdcIixaZSk7ZnVuY3Rpb24gZXQoZSx0KXtpZighdClyZXR1cm4gZSYmZS50aGVuP2UudGhlbigkZSk6UHJvbWlzZS5yZXNvbHZlKCl9ZnVuY3Rpb24gdHQoZSx0KXt2YXIgbj1lKCk7cmV0dXJuIG4mJm4udGhlbj9uLnRoZW4odCk6dChuKX12YXIgbnQ9W3ZvaWQgMCwxLDEsMiw0LDgsMSwxLDIsNCw4LDQsOCw0XTt2YXIgcnQ9ZnVuY3Rpb24oZSl7YShpLGUpO3ZhciBuPWQoaSk7ZnVuY3Rpb24gaSgpe3JldHVybiB0KHRoaXMsaSksbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIHIoaSxbe2tleTpcInBhcnNlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9dGhpcztlLnBhcnNlSGVhZGVyKCk7dmFyIHQ9ZS5vcHRpb25zO3JldHVybiB0dCgoZnVuY3Rpb24oKXtpZih0LmlmZDAuZW5hYmxlZClyZXR1cm4gZXQoZS5wYXJzZUlmZDBCbG9jaygpKX0pLChmdW5jdGlvbigpe3JldHVybiB0dCgoZnVuY3Rpb24oKXtpZih0LmV4aWYuZW5hYmxlZClyZXR1cm4gZXQoZS5zYWZlUGFyc2UoXCJwYXJzZUV4aWZCbG9ja1wiKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYodC5ncHMuZW5hYmxlZClyZXR1cm4gZXQoZS5zYWZlUGFyc2UoXCJwYXJzZUdwc0Jsb2NrXCIpKX0pLChmdW5jdGlvbigpe3JldHVybiB0dCgoZnVuY3Rpb24oKXtpZih0LmludGVyb3AuZW5hYmxlZClyZXR1cm4gZXQoZS5zYWZlUGFyc2UoXCJwYXJzZUludGVyb3BCbG9ja1wiKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYodC5pZmQxLmVuYWJsZWQpcmV0dXJuIGV0KGUuc2FmZVBhcnNlKFwicGFyc2VUaHVtYm5haWxCbG9ja1wiKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gZS5jcmVhdGVPdXRwdXQoKX0pKX0pKX0pKX0pKX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcInNhZmVQYXJzZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXNbZV0oKTtyZXR1cm4gdm9pZCAwIT09dC5jYXRjaCYmKHQ9dC5jYXRjaCh0aGlzLmhhbmRsZUVycm9yKSksdH19LHtrZXk6XCJmaW5kSWZkME9mZnNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7dm9pZCAwPT09dGhpcy5pZmQwT2Zmc2V0JiYodGhpcy5pZmQwT2Zmc2V0PXRoaXMuY2h1bmsuZ2V0VWludDMyKDQpKX19LHtrZXk6XCJmaW5kSWZkMU9mZnNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodm9pZCAwPT09dGhpcy5pZmQxT2Zmc2V0KXt0aGlzLmZpbmRJZmQwT2Zmc2V0KCk7dmFyIGU9dGhpcy5jaHVuay5nZXRVaW50MTYodGhpcy5pZmQwT2Zmc2V0KSx0PXRoaXMuaWZkME9mZnNldCsyKzEyKmU7dGhpcy5pZmQxT2Zmc2V0PXRoaXMuY2h1bmsuZ2V0VWludDMyKHQpfX19LHtrZXk6XCJwYXJzZUJsb2NrXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1TKCk7cmV0dXJuIHRoaXNbdF09bix0aGlzLnBhcnNlVGFncyhlLHQsbiksbn19LHtrZXk6XCJwYXJzZUlmZDBCbG9ja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7aWYoZS5pZmQwKXJldHVybjt2YXIgdD1lLmZpbGU7cmV0dXJuIGUuZmluZElmZDBPZmZzZXQoKSxlLmlmZDBPZmZzZXQ8OCYmTChcIk1hbGZvcm1lZCBFWElGIGRhdGFcIiksIXQuY2h1bmtlZCYmZS5pZmQwT2Zmc2V0PnQuYnl0ZUxlbmd0aCYmTChcIklGRDAgb2Zmc2V0IHBvaW50cyB0byBvdXRzaWRlIG9mIGZpbGUuXFxudGhpcy5pZmQwT2Zmc2V0OiBcIi5jb25jYXQoZS5pZmQwT2Zmc2V0LFwiLCBmaWxlLmJ5dGVMZW5ndGg6IFwiKS5jb25jYXQodC5ieXRlTGVuZ3RoKSksdHQoKGZ1bmN0aW9uKCl7aWYodC50aWZmKXJldHVybiBldCh0LmVuc3VyZUNodW5rKGUuaWZkME9mZnNldCxUKGUub3B0aW9ucykpKX0pLChmdW5jdGlvbigpe3ZhciB0PWUucGFyc2VCbG9jayhlLmlmZDBPZmZzZXQsXCJpZmQwXCIpO2lmKDAhPT10LnNpemUpcmV0dXJuIGUuZXhpZk9mZnNldD10LmdldChjZSksZS5pbnRlcm9wT2Zmc2V0PXQuZ2V0KGxlKSxlLmdwc09mZnNldD10LmdldChoZSksZS54bXA9dC5nZXQoNzAwKSxlLmlwdGM9dC5nZXQob2UpLGUuaWNjPXQuZ2V0KGZlKSxlLm9wdGlvbnMuc2FuaXRpemUmJih0LmRlbGV0ZShjZSksdC5kZWxldGUobGUpLHQuZGVsZXRlKGhlKSx0LmRlbGV0ZSg3MDApLHQuZGVsZXRlKG9lKSx0LmRlbGV0ZShmZSkpLHR9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJwYXJzZUV4aWZCbG9ja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7aWYoZS5leGlmKXJldHVybjtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYoIWUuaWZkMClyZXR1cm4gZXQoZS5wYXJzZUlmZDBCbG9jaygpKX0pLChmdW5jdGlvbigpe2lmKHZvaWQgMCE9PWUuZXhpZk9mZnNldClyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYoZS5maWxlLnRpZmYpcmV0dXJuIGV0KGUuZmlsZS5lbnN1cmVDaHVuayhlLmV4aWZPZmZzZXQsVChlLm9wdGlvbnMpKSl9KSwoZnVuY3Rpb24oKXt2YXIgdD1lLnBhcnNlQmxvY2soZS5leGlmT2Zmc2V0LFwiZXhpZlwiKTtyZXR1cm4gZS5pbnRlcm9wT2Zmc2V0fHwoZS5pbnRlcm9wT2Zmc2V0PXQuZ2V0KGxlKSksZS5tYWtlck5vdGU9dC5nZXQoc2UpLGUudXNlckNvbW1lbnQ9dC5nZXQodWUpLGUub3B0aW9ucy5zYW5pdGl6ZSYmKHQuZGVsZXRlKGxlKSx0LmRlbGV0ZShzZSksdC5kZWxldGUodWUpKSxlLnVucGFjayh0LDQxNzI4KSxlLnVucGFjayh0LDQxNzI5KSx0fSkpfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwidW5wYWNrXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmdldCh0KTtuJiYxPT09bi5sZW5ndGgmJmUuc2V0KHQsblswXSl9fSx7a2V5OlwicGFyc2VHcHNCbG9ja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7aWYoZS5ncHMpcmV0dXJuO3JldHVybiB0dCgoZnVuY3Rpb24oKXtpZighZS5pZmQwKXJldHVybiBldChlLnBhcnNlSWZkMEJsb2NrKCkpfSksKGZ1bmN0aW9uKCl7aWYodm9pZCAwIT09ZS5ncHNPZmZzZXQpe3ZhciB0PWUucGFyc2VCbG9jayhlLmdwc09mZnNldCxcImdwc1wiKTtyZXR1cm4gdCYmdC5oYXMoMikmJnQuaGFzKDQpJiYodC5zZXQoXCJsYXRpdHVkZVwiLGl0LmFwcGx5KHZvaWQgMCx0LmdldCgyKS5jb25jYXQoW3QuZ2V0KDEpXSkpKSx0LnNldChcImxvbmdpdHVkZVwiLGl0LmFwcGx5KHZvaWQgMCx0LmdldCg0KS5jb25jYXQoW3QuZ2V0KDMpXSkpKSksdH19KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJwYXJzZUludGVyb3BCbG9ja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7aWYoZS5pbnRlcm9wKXJldHVybjtyZXR1cm4gdHQoKGZ1bmN0aW9uKCl7aWYoIWUuaWZkMClyZXR1cm4gZXQoZS5wYXJzZUlmZDBCbG9jaygpKX0pLChmdW5jdGlvbigpe3JldHVybiB0dCgoZnVuY3Rpb24oKXtpZih2b2lkIDA9PT1lLmludGVyb3BPZmZzZXQmJiFlLmV4aWYpcmV0dXJuIGV0KGUucGFyc2VFeGlmQmxvY2soKSl9KSwoZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1lLmludGVyb3BPZmZzZXQpcmV0dXJuIGUucGFyc2VCbG9jayhlLmludGVyb3BPZmZzZXQsXCJpbnRlcm9wXCIpfSkpfSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwicGFyc2VUaHVtYm5haWxCbG9ja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXTt0cnl7dmFyIHQ9dGhpcztpZih0LmlmZDF8fHQuaWZkMVBhcnNlZClyZXR1cm47aWYodC5vcHRpb25zLm1lcmdlT3V0cHV0JiYhZSlyZXR1cm47cmV0dXJuIHQuZmluZElmZDFPZmZzZXQoKSx0LmlmZDFPZmZzZXQ+MCYmKHQucGFyc2VCbG9jayh0LmlmZDFPZmZzZXQsXCJpZmQxXCIpLHQuaWZkMVBhcnNlZD0hMCksdC5pZmQxfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwiZXh0cmFjdFRodW1ibmFpbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXRoaXM7cmV0dXJuIGUuaGVhZGVyUGFyc2VkfHxlLnBhcnNlSGVhZGVyKCksdHQoKGZ1bmN0aW9uKCl7aWYoIWUuaWZkMVBhcnNlZClyZXR1cm4gZXQoZS5wYXJzZVRodW1ibmFpbEJsb2NrKCEwKSl9KSwoZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1lLmlmZDEpe3ZhciB0PWUuaWZkMS5nZXQoNTEzKSxuPWUuaWZkMS5nZXQoNTE0KTtyZXR1cm4gZS5jaHVuay5nZXRVaW50OEFycmF5KHQsbil9fSkpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19fSx7a2V5OlwiaW1hZ2VcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pZmQwfX0se2tleTpcInRodW1ibmFpbFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlmZDF9fSx7a2V5OlwiY3JlYXRlT3V0cHV0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSx0LG4scj17fSxpPXllO0FycmF5LmlzQXJyYXkoaSl8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLmVudHJpZXMmJihpPWkuZW50cmllcygpKSxpPW0oaSkpO2Zvcih2YXIgYT0wO2E8aS5sZW5ndGg7YSsrKWlmKCFJKGU9dGhpc1t0PWlbYV1dKSlpZihuPXRoaXMuY2FuVHJhbnNsYXRlP3RoaXMudHJhbnNsYXRlQmxvY2soZSx0KTprKGUpLHRoaXMub3B0aW9ucy5tZXJnZU91dHB1dCl7aWYoXCJpZmQxXCI9PT10KWNvbnRpbnVlO2cocixuKX1lbHNlIHJbdF09bjtyZXR1cm4gdGhpcy5tYWtlck5vdGUmJihyLm1ha2VyTm90ZT10aGlzLm1ha2VyTm90ZSksdGhpcy51c2VyQ29tbWVudCYmKHIudXNlckNvbW1lbnQ9dGhpcy51c2VyQ29tbWVudCkscn19LHtrZXk6XCJhc3NpZ25Ub091dHB1dFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYodGhpcy5nbG9iYWxPcHRpb25zLm1lcmdlT3V0cHV0KWcoZSx0KTtlbHNle3ZhciBuPXkodCk7QXJyYXkuaXNBcnJheShuKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIG4uZW50cmllcyYmKG49bi5lbnRyaWVzKCkpLG49bShuKSk7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBpPW5bcl0sYT1pWzBdLHM9aVsxXTt0aGlzLmFzc2lnbk9iamVjdFRvT3V0cHV0KGUsYSxzKX19fX1dLFt7a2V5OlwiY2FuSGFuZGxlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMjI1PT09ZS5nZXRVaW50OCh0KzEpJiYxMTY1NTE5MjA2PT09ZS5nZXRVaW50MzIodCs0KSYmMD09PWUuZ2V0VWludDE2KHQrOCl9fV0pLGl9KGZ1bmN0aW9uKGUpe2EoaSxlKTt2YXIgbj1kKGkpO2Z1bmN0aW9uIGkoKXtyZXR1cm4gdCh0aGlzLGkpLG4uYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiByKGksW3trZXk6XCJwYXJzZUhlYWRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5jaHVuay5nZXRVaW50MTYoKTsxODc2MT09PWU/dGhpcy5sZT0hMDoxOTc4OT09PWUmJih0aGlzLmxlPSExKSx0aGlzLmNodW5rLmxlPXRoaXMubGUsdGhpcy5oZWFkZXJQYXJzZWQ9ITB9fSx7a2V5OlwicGFyc2VUYWdzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06UygpLHI9dGhpcy5vcHRpb25zW3RdLGk9ci5waWNrLGE9ci5za2lwLHM9KGk9TyhpKSkuc2l6ZT4wLHU9MD09PWEuc2l6ZSxvPXRoaXMuY2h1bmsuZ2V0VWludDE2KGUpO2UrPTI7Zm9yKHZhciBmPTA7ZjxvO2YrKyl7dmFyIGM9dGhpcy5jaHVuay5nZXRVaW50MTYoZSk7aWYocyl7aWYoaS5oYXMoYykmJihuLnNldChjLHRoaXMucGFyc2VUYWcoZSxjLHQpKSxpLmRlbGV0ZShjKSwwPT09aS5zaXplKSlicmVha31lbHNlIXUmJmEuaGFzKGMpfHxuLnNldChjLHRoaXMucGFyc2VUYWcoZSxjLHQpKTtlKz0xMn1yZXR1cm4gbn19LHtrZXk6XCJwYXJzZVRhZ1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpPXRoaXMuY2h1bmssYT1pLmdldFVpbnQxNihlKzIpLHM9aS5nZXRVaW50MzIoZSs0KSx1PW50W2FdO2lmKHUqczw9ND9lKz04OmU9aS5nZXRVaW50MzIoZSs4KSwoYTwxfHxhPjEzKSYmTChcIkludmFsaWQgVElGRiB2YWx1ZSB0eXBlLiBibG9jazogXCIuY29uY2F0KG4udG9VcHBlckNhc2UoKSxcIiwgdGFnOiBcIikuY29uY2F0KHQudG9TdHJpbmcoMTYpLFwiLCB0eXBlOiBcIikuY29uY2F0KGEsXCIsIG9mZnNldCBcIikuY29uY2F0KGUpKSxlPmkuYnl0ZUxlbmd0aCYmTChcIkludmFsaWQgVElGRiB2YWx1ZSBvZmZzZXQuIGJsb2NrOiBcIi5jb25jYXQobi50b1VwcGVyQ2FzZSgpLFwiLCB0YWc6IFwiKS5jb25jYXQodC50b1N0cmluZygxNiksXCIsIHR5cGU6IFwiKS5jb25jYXQoYSxcIiwgb2Zmc2V0IFwiKS5jb25jYXQoZSxcIiBpcyBvdXRzaWRlIG9mIGNodW5rIHNpemUgXCIpLmNvbmNhdChpLmJ5dGVMZW5ndGgpKSwxPT09YSlyZXR1cm4gaS5nZXRVaW50OEFycmF5KGUscyk7aWYoMj09PWEpcmV0dXJuXCJcIj09PShyPWZ1bmN0aW9uKGUpe2Zvcig7ZS5lbmRzV2l0aChcIlxcMFwiKTspZT1lLnNsaWNlKDAsLTEpO3JldHVybiBlfShyPWkuZ2V0U3RyaW5nKGUscykpLnRyaW0oKSk/dm9pZCAwOnI7aWYoNz09PWEpcmV0dXJuIGkuZ2V0VWludDhBcnJheShlLHMpO2lmKDE9PT1zKXJldHVybiB0aGlzLnBhcnNlVGFnVmFsdWUoYSxlKTtmb3IodmFyIG89bmV3KGZ1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZSAzOnJldHVybiBVaW50MTZBcnJheTtjYXNlIDQ6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2UgNTpyZXR1cm4gQXJyYXk7Y2FzZSA2OnJldHVybiBJbnQ4QXJyYXk7Y2FzZSA4OnJldHVybiBJbnQxNkFycmF5O2Nhc2UgOTpyZXR1cm4gSW50MzJBcnJheTtjYXNlIDEwOnJldHVybiBBcnJheTtjYXNlIDExOnJldHVybiBGbG9hdDMyQXJyYXk7Y2FzZSAxMjpyZXR1cm4gRmxvYXQ2NEFycmF5O2RlZmF1bHQ6cmV0dXJuIEFycmF5fX0oYSkpKHMpLGY9dSxjPTA7YzxzO2MrKylvW2NdPXRoaXMucGFyc2VUYWdWYWx1ZShhLGUpLGUrPWY7cmV0dXJuIG99fSx7a2V5OlwicGFyc2VUYWdWYWx1ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5jaHVuaztzd2l0Y2goZSl7Y2FzZSAxOnJldHVybiBuLmdldFVpbnQ4KHQpO2Nhc2UgMzpyZXR1cm4gbi5nZXRVaW50MTYodCk7Y2FzZSA0OnJldHVybiBuLmdldFVpbnQzMih0KTtjYXNlIDU6cmV0dXJuIG4uZ2V0VWludDMyKHQpL24uZ2V0VWludDMyKHQrNCk7Y2FzZSA2OnJldHVybiBuLmdldEludDgodCk7Y2FzZSA4OnJldHVybiBuLmdldEludDE2KHQpO2Nhc2UgOTpyZXR1cm4gbi5nZXRJbnQzMih0KTtjYXNlIDEwOnJldHVybiBuLmdldEludDMyKHQpL24uZ2V0SW50MzIodCs0KTtjYXNlIDExOnJldHVybiBuLmdldEZsb2F0KHQpO2Nhc2UgMTI6cmV0dXJuIG4uZ2V0RG91YmxlKHQpO2Nhc2UgMTM6cmV0dXJuIG4uZ2V0VWludDMyKHQpO2RlZmF1bHQ6TChcIkludmFsaWQgdGlmZiB0eXBlIFwiLmNvbmNhdChlKSl9fX1dKSxpfShEZSkpO2Z1bmN0aW9uIGl0KGUsdCxuLHIpe3ZhciBpPWUrdC82MCtuLzM2MDA7cmV0dXJuXCJTXCIhPT1yJiZcIldcIiE9PXJ8fChpKj0tMSksaX1pKHJ0LFwidHlwZVwiLFwidGlmZlwiKSxpKHJ0LFwiaGVhZGVyTGVuZ3RoXCIsMTApLFcuc2V0KFwidGlmZlwiLHJ0KTt2YXIgYXQ9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsZGVmYXVsdDp6ZSxFeGlmcjpJZSxmaWxlUGFyc2VyczpNLHNlZ21lbnRQYXJzZXJzOlcsZmlsZVJlYWRlcnM6Syx0YWdLZXlzOnJlLHRhZ1ZhbHVlczppZSx0YWdSZXZpdmVyczphZSxjcmVhdGVEaWN0aW9uYXJ5OnRlLGV4dGVuZERpY3Rpb25hcnk6bmUsZmV0Y2hVcmxBc0FycmF5QnVmZmVyOkcscmVhZEJsb2JBc0FycmF5QnVmZmVyOlksY2h1bmtlZFByb3BzOmRlLG90aGVyU2VnbWVudHM6dmUsc2VnbWVudHM6cGUsdGlmZkJsb2Nrczp5ZSxzZWdtZW50c0FuZEJsb2NrczpnZSx0aWZmRXh0cmFjdGFibGVzOmtlLGluaGVyaXRhYmxlczptZSxhbGxGb3JtYXR0ZXJzOmJlLE9wdGlvbnM6UGUscGFyc2U6VGV9KTtmdW5jdGlvbiBzdChlLHQsbil7cmV0dXJuIG4/dD90KGUpOmU6KGUmJmUudGhlbnx8KGU9UHJvbWlzZS5yZXNvbHZlKGUpKSx0P2UudGhlbih0KTplKX1mdW5jdGlvbiB1dChlKXtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sbj0wO248YXJndW1lbnRzLmxlbmd0aDtuKyspdFtuXT1hcmd1bWVudHNbbl07dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoZS5hcHBseSh0aGlzLHQpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX12YXIgb3Q9dXQoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBJZSh2dCk7cmV0dXJuIHN0KHQucmVhZChlKSwoZnVuY3Rpb24oKXtyZXR1cm4gc3QodC5wYXJzZSgpLChmdW5jdGlvbihlKXtpZihlJiZlLmlmZDApcmV0dXJuIGUuaWZkMFsyNzRdfSkpfSkpfSkpLGZ0PXV0KChmdW5jdGlvbihlKXt2YXIgdD1uZXcgSWUoZHQpO3JldHVybiBzdCh0LnJlYWQoZSksKGZ1bmN0aW9uKCl7cmV0dXJuIHN0KHQucGFyc2UoKSwoZnVuY3Rpb24oZSl7aWYoZSYmZS5ncHMpe3ZhciB0PWUuZ3BzO3JldHVybntsYXRpdHVkZTp0LmxhdGl0dWRlLGxvbmdpdHVkZTp0LmxvbmdpdHVkZX19fSkpfSkpfSkpLGN0PXV0KChmdW5jdGlvbihlKXtyZXR1cm4gc3QodGhpcy50aHVtYm5haWwoZSksKGZ1bmN0aW9uKGUpe2lmKHZvaWQgMCE9PWUpe3ZhciB0PW5ldyBCbG9iKFtlXSk7cmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwodCl9fSkpfSkpLGh0PXV0KChmdW5jdGlvbihlKXt2YXIgdD1uZXcgSWUocHQpO3JldHVybiBzdCh0LnJlYWQoZSksKGZ1bmN0aW9uKCl7cmV0dXJuIHN0KHQuZXh0cmFjdFRodW1ibmFpbCgpLChmdW5jdGlvbihlKXtyZXR1cm4gZSYmXz9qLmZyb20oZSk6ZX0pKX0pKX0pKSxsdD17aWZkMDohMSxpZmQxOiExLGV4aWY6ITEsZ3BzOiExLGludGVyb3A6ITEsc2FuaXRpemU6ITEscmV2aXZlVmFsdWVzOiEwLHRyYW5zbGF0ZUtleXM6ITEsdHJhbnNsYXRlVmFsdWVzOiExLG1lcmdlT3V0cHV0OiExfSxkdD1nKHt9LGx0LHtmaXJzdENodW5rU2l6ZTo0ZTQsZ3BzOlsxLDIsMyw0XX0pLHZ0PWcoe30sbHQse2ZpcnN0Q2h1bmtTaXplOjRlNCxpZmQwOlsyNzRdfSkscHQ9Zyh7fSxsdCx7dGlmZjohMSxpZmQxOiEwLG1lcmdlT3V0cHV0OiExfSkseXQ9T2JqZWN0LmZyZWV6ZSh7MTp7ZGltZW5zaW9uU3dhcHBlZDohMSxzY2FsZVg6MSxzY2FsZVk6MSxkZWc6MCxyYWQ6MH0sMjp7ZGltZW5zaW9uU3dhcHBlZDohMSxzY2FsZVg6LTEsc2NhbGVZOjEsZGVnOjAscmFkOjB9LDM6e2RpbWVuc2lvblN3YXBwZWQ6ITEsc2NhbGVYOjEsc2NhbGVZOjEsZGVnOjE4MCxyYWQ6MTgwKk1hdGguUEkvMTgwfSw0OntkaW1lbnNpb25Td2FwcGVkOiExLHNjYWxlWDotMSxzY2FsZVk6MSxkZWc6MTgwLHJhZDoxODAqTWF0aC5QSS8xODB9LDU6e2RpbWVuc2lvblN3YXBwZWQ6ITAsc2NhbGVYOjEsc2NhbGVZOi0xLGRlZzo5MCxyYWQ6OTAqTWF0aC5QSS8xODB9LDY6e2RpbWVuc2lvblN3YXBwZWQ6ITAsc2NhbGVYOjEsc2NhbGVZOjEsZGVnOjkwLHJhZDo5MCpNYXRoLlBJLzE4MH0sNzp7ZGltZW5zaW9uU3dhcHBlZDohMCxzY2FsZVg6MSxzY2FsZVk6LTEsZGVnOjI3MCxyYWQ6MjcwKk1hdGguUEkvMTgwfSw4OntkaW1lbnNpb25Td2FwcGVkOiEwLHNjYWxlWDoxLHNjYWxlWToxLGRlZzoyNzAscmFkOjI3MCpNYXRoLlBJLzE4MH19KTtpZihlLnJvdGF0ZUNhbnZhcz0hMCxlLnJvdGF0ZUNzcz0hMCxcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yKXt2YXIgZ3Q9bmF2aWdhdG9yLnVzZXJBZ2VudDtpZihndC5pbmNsdWRlcyhcImlQYWRcIil8fGd0LmluY2x1ZGVzKFwiaVBob25lXCIpKXt2YXIga3Q9Z3QubWF0Y2goL09TIChcXGQrKV8oXFxkKykvKTtpZihrdCl7dmFyIG10PWt0WzFdLGJ0PWt0WzJdLEF0PU51bWJlcihtdCkrLjEqTnVtYmVyKGJ0KTtlLnJvdGF0ZUNhbnZhcz1BdDwxMy40LGUucm90YXRlQ3NzPSExfX1lbHNlIGlmKGd0LmluY2x1ZGVzKFwiT1MgWCAxMFwiKSl7dmFyIHd0PWd0Lm1hdGNoKC9PUyBYIDEwW18uXShcXGQrKS8pWzFdO2Uucm90YXRlQ2FudmFzPWUucm90YXRlQ3NzPU51bWJlcih3dCk8MTV9aWYoZ3QuaW5jbHVkZXMoXCJDaHJvbWUvXCIpKXt2YXIgT3Q9Z3QubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pWzFdO2Uucm90YXRlQ2FudmFzPWUucm90YXRlQ3NzPU51bWJlcihPdCk8ODF9ZWxzZSBpZihndC5pbmNsdWRlcyhcIkZpcmVmb3gvXCIpKXt2YXIgU3Q9Z3QubWF0Y2goL0ZpcmVmb3hcXC8oXFxkKykvKVsxXTtlLnJvdGF0ZUNhbnZhcz1lLnJvdGF0ZUNzcz1OdW1iZXIoU3QpPDc3fX1mdW5jdGlvbiBQdCgpe312YXIgVXQ9ZnVuY3Rpb24oZSl7YSh1LGUpO3ZhciBuPWQodSk7ZnVuY3Rpb24gdSgpe3ZhciBlO3QodGhpcyx1KTtmb3IodmFyIHI9YXJndW1lbnRzLmxlbmd0aCxhPW5ldyBBcnJheShyKSxzPTA7czxyO3MrKylhW3NdPWFyZ3VtZW50c1tzXTtyZXR1cm4gaShoKGU9bi5jYWxsLmFwcGx5KG4sW3RoaXNdLmNvbmNhdChhKSkpLFwicmFuZ2VzXCIsbmV3IHh0KSwwIT09ZS5ieXRlTGVuZ3RoJiZlLnJhbmdlcy5hZGQoMCxlLmJ5dGVMZW5ndGgpLGV9cmV0dXJuIHIodSxbe2tleTpcIl90cnlFeHRlbmRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7aWYoMD09PWUmJjA9PT10aGlzLmJ5dGVMZW5ndGgmJm4pe3ZhciByPW5ldyBEYXRhVmlldyhuLmJ1ZmZlcnx8bixuLmJ5dGVPZmZzZXQsbi5ieXRlTGVuZ3RoKTt0aGlzLl9zd2FwRGF0YVZpZXcocil9ZWxzZXt2YXIgaT1lK3Q7aWYoaT50aGlzLmJ5dGVMZW5ndGgpe3ZhciBhPXRoaXMuX2V4dGVuZChpKS5kYXRhVmlldzt0aGlzLl9zd2FwRGF0YVZpZXcoYSl9fX19LHtrZXk6XCJfZXh0ZW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ7dD1fP2ouYWxsb2NVbnNhZmUoZSk6bmV3IFVpbnQ4QXJyYXkoZSk7dmFyIG49bmV3IERhdGFWaWV3KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpO3JldHVybiB0LnNldChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcix0aGlzLmJ5dGVPZmZzZXQsdGhpcy5ieXRlTGVuZ3RoKSwwKSx7dWludFZpZXc6dCxkYXRhVmlldzpufX19LHtrZXk6XCJzdWJhcnJheVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXTtyZXR1cm4gdD10fHx0aGlzLl9sZW5ndGhUb0VuZChlKSxuJiZ0aGlzLl90cnlFeHRlbmQoZSx0KSx0aGlzLnJhbmdlcy5hZGQoZSx0KSx2KHModS5wcm90b3R5cGUpLFwic3ViYXJyYXlcIix0aGlzKS5jYWxsKHRoaXMsZSx0KX19LHtrZXk6XCJzZXRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07biYmdGhpcy5fdHJ5RXh0ZW5kKHQsZS5ieXRlTGVuZ3RoLGUpO3ZhciByPXYocyh1LnByb3RvdHlwZSksXCJzZXRcIix0aGlzKS5jYWxsKHRoaXMsZSx0KTtyZXR1cm4gdGhpcy5yYW5nZXMuYWRkKHQsci5ieXRlTGVuZ3RoKSxyfX0se2tleTpcImVuc3VyZUNodW5rXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0cnl7dmFyIG49dGhpcztpZighbi5jaHVua2VkKXJldHVybjtpZihuLnJhbmdlcy5hdmFpbGFibGUoZSx0KSlyZXR1cm47cmV0dXJuIGZ1bmN0aW9uKGUsdCl7aWYoIXQpcmV0dXJuIGUmJmUudGhlbj9lLnRoZW4oUHQpOlByb21pc2UucmVzb2x2ZSgpfShuLnJlYWRDaHVuayhlLHQpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcImF2YWlsYWJsZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMucmFuZ2VzLmF2YWlsYWJsZShlLHQpfX1dKSx1fShEKSx4dD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0KHRoaXMsZSksaSh0aGlzLFwibGlzdFwiLFtdKX1yZXR1cm4gcihlLFt7a2V5OlwibGVuZ3RoXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGlzdC5sZW5ndGh9fSx7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lK3Qscj10aGlzLmxpc3QuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gQ3QoZSx0Lm9mZnNldCxuKXx8Q3QoZSx0LmVuZCxuKX0pKTtpZihyLmxlbmd0aD4wKXtlPU1hdGgubWluLmFwcGx5KE1hdGgsW2VdLmNvbmNhdChyLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUub2Zmc2V0fSkpKSksdD0obj1NYXRoLm1heC5hcHBseShNYXRoLFtuXS5jb25jYXQoci5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmVuZH0pKSkpKS1lO3ZhciBpPXIuc2hpZnQoKTtpLm9mZnNldD1lLGkubGVuZ3RoPXQsaS5lbmQ9bix0aGlzLmxpc3Q9dGhpcy5saXN0LmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIXIuaW5jbHVkZXMoZSl9KSl9ZWxzZSB0aGlzLmxpc3QucHVzaCh7b2Zmc2V0OmUsbGVuZ3RoOnQsZW5kOm59KX19LHtrZXk6XCJhdmFpbGFibGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWUrdDtyZXR1cm4gdGhpcy5saXN0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9mZnNldDw9ZSYmbjw9dC5lbmR9KSl9fV0pLGV9KCk7ZnVuY3Rpb24gQ3QoZSx0LG4pe3JldHVybiBlPD10JiZ0PD1ufWZ1bmN0aW9uIEJ0KCl7fWZ1bmN0aW9uIGp0KGUsdCl7aWYoIXQpcmV0dXJuIGUmJmUudGhlbj9lLnRoZW4oQnQpOlByb21pc2UucmVzb2x2ZSgpfWZ1bmN0aW9uIF90KGUsdCxuKXtyZXR1cm4gbj90P3QoZSk6ZTooZSYmZS50aGVufHwoZT1Qcm9taXNlLnJlc29sdmUoZSkpLHQ/ZS50aGVuKHQpOmUpfXZhciBWdD1mdW5jdGlvbihlKXthKGksZSk7dmFyIG49ZChpKTtmdW5jdGlvbiBpKCl7cmV0dXJuIHQodGhpcyxpKSxuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gcihpLFt7a2V5OlwicmVhZFdob2xlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9dGhpcztyZXR1cm4gZS5jaHVua2VkPSExLF90KFkoZS5pbnB1dCksKGZ1bmN0aW9uKHQpe2UuX3N3YXBBcnJheUJ1ZmZlcih0KX0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcInJlYWRDaHVua2VkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaHVua2VkPSEwLHRoaXMuc2l6ZT10aGlzLmlucHV0LnNpemUsdihzKGkucHJvdG90eXBlKSxcInJlYWRDaHVua2VkXCIsdGhpcykuY2FsbCh0aGlzKX19LHtrZXk6XCJfcmVhZENodW5rXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0cnl7dmFyIG49dGhpcyxyPXQ/ZSt0OnZvaWQgMCxpPW4uaW5wdXQuc2xpY2UoZSxyKTtyZXR1cm4gX3QoWShpKSwoZnVuY3Rpb24odCl7cmV0dXJuIG4uc2V0KHQsZSwhMCl9KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19XSksaX0oZnVuY3Rpb24oZSl7YShzLGUpO3ZhciBuPWQocyk7ZnVuY3Rpb24gcyhlLHIpe3ZhciBhO3JldHVybiB0KHRoaXMscyksaShoKGE9bi5jYWxsKHRoaXMsMCkpLFwiY2h1bmtzUmVhZFwiLDApLGEuaW5wdXQ9ZSxhLm9wdGlvbnM9cixhfXJldHVybiByKHMsW3trZXk6XCJyZWFkV2hvbGVcIix2YWx1ZTpmdW5jdGlvbigpe3RyeXt2YXIgZT10aGlzO3JldHVybiBlLmNodW5rZWQ9ITEsanQoZS5yZWFkQ2h1bmsoZS5uZXh0Q2h1bmtPZmZzZXQpKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX0se2tleTpcInJlYWRDaHVua2VkXCIsdmFsdWU6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9dGhpcztyZXR1cm4gZS5jaHVua2VkPSEwLGp0KGUucmVhZENodW5rKDAsZS5vcHRpb25zLmZpcnN0Q2h1bmtTaXplKSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJyZWFkTmV4dENodW5rXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dHJ5e3ZhciB0PXRoaXM7aWYodm9pZCAwPT09ZSYmKGU9dC5uZXh0Q2h1bmtPZmZzZXQpLHQuZnVsbHlSZWFkKXJldHVybiB0LmNodW5rc1JlYWQrKywhMTt2YXIgbj10Lm9wdGlvbnMuY2h1bmtTaXplO3JldHVybiByPXQucmVhZENodW5rKGUsbiksaT1mdW5jdGlvbihlKXtyZXR1cm4hIWUmJmUuYnl0ZUxlbmd0aD09PW59LGE/aT9pKHIpOnI6KHImJnIudGhlbnx8KHI9UHJvbWlzZS5yZXNvbHZlKHIpKSxpP3IudGhlbihpKTpyKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9dmFyIHIsaSxhfX0se2tleTpcInJlYWRDaHVua1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dHJ5e3ZhciBuPXRoaXM7aWYobi5jaHVua3NSZWFkKyssMD09PSh0PW4uc2FmZVdyYXBBZGRyZXNzKGUsdCkpKXJldHVybjtyZXR1cm4gbi5fcmVhZENodW5rKGUsdCl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19LHtrZXk6XCJzYWZlV3JhcEFkZHJlc3NcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDAhPT10aGlzLnNpemUmJmUrdD50aGlzLnNpemU/TWF0aC5tYXgoMCx0aGlzLnNpemUtZSk6dH19LHtrZXk6XCJuZXh0Q2h1bmtPZmZzZXRcIixnZXQ6ZnVuY3Rpb24oKXtpZigwIT09dGhpcy5yYW5nZXMubGlzdC5sZW5ndGgpcmV0dXJuIHRoaXMucmFuZ2VzLmxpc3RbMF0ubGVuZ3RofX0se2tleTpcImNhblJlYWROZXh0Q2h1bmtcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaHVua3NSZWFkPHRoaXMub3B0aW9ucy5jaHVua0xpbWl0fX0se2tleTpcImZ1bGx5UmVhZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB2b2lkIDAhPT10aGlzLnNpemUmJnRoaXMubmV4dENodW5rT2Zmc2V0PT09dGhpcy5zaXplfX0se2tleTpcInJlYWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMuY2h1bmtlZD90aGlzLnJlYWRDaHVua2VkKCk6dGhpcy5yZWFkV2hvbGUoKX19LHtrZXk6XCJjbG9zZVwiLHZhbHVlOmZ1bmN0aW9uKCl7fX1dKSxzfShVdCkpO0suc2V0KFwiYmxvYlwiLFZ0KSxlLkV4aWZyPUllLGUuT3B0aW9ucz1QZSxlLmFsbEZvcm1hdHRlcnM9YmUsZS5jaHVua2VkUHJvcHM9ZGUsZS5jcmVhdGVEaWN0aW9uYXJ5PXRlLGUuZGVmYXVsdD1hdCxlLmRpc2FibGVBbGxPcHRpb25zPWx0LGUuZXh0ZW5kRGljdGlvbmFyeT1uZSxlLmZldGNoVXJsQXNBcnJheUJ1ZmZlcj1HLGUuZmlsZVBhcnNlcnM9TSxlLmZpbGVSZWFkZXJzPUssZS5ncHM9ZnQsZS5ncHNPbmx5T3B0aW9ucz1kdCxlLmluaGVyaXRhYmxlcz1tZSxlLm9yaWVudGF0aW9uPW90LGUub3JpZW50YXRpb25Pbmx5T3B0aW9ucz12dCxlLm90aGVyU2VnbWVudHM9dmUsZS5wYXJzZT1UZSxlLnJlYWRCbG9iQXNBcnJheUJ1ZmZlcj1ZLGUucm90YXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIHN0KG90KHQpLChmdW5jdGlvbih0KXtyZXR1cm4gZyh7Y2FudmFzOmUucm90YXRlQ2FudmFzLGNzczplLnJvdGF0ZUNzc30seXRbdF0pfSkpfSxlLnJvdGF0aW9ucz15dCxlLnNlZ21lbnRQYXJzZXJzPVcsZS5zZWdtZW50cz1wZSxlLnNlZ21lbnRzQW5kQmxvY2tzPWdlLGUudGFnS2V5cz1yZSxlLnRhZ1Jldml2ZXJzPWFlLGUudGFnVmFsdWVzPWllLGUudGh1bWJuYWlsPWh0LGUudGh1bWJuYWlsT25seU9wdGlvbnM9cHQsZS50aHVtYm5haWxVcmw9Y3QsZS50aWZmQmxvY2tzPXllLGUudGlmZkV4dHJhY3RhYmxlcz1rZSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pKTtcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTaGFsbG93RXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlXG4gIGZvciAodmFyIGkgaW4gYSkgaWYgKCEoaSBpbiBiKSkgcmV0dXJuIGZhbHNlXG4gIGZvciAodmFyIGkgaW4gYikgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZVxuICByZXR1cm4gdHJ1ZVxufVxuIiwiLypcbiAqICBiYXNlNjQuanNcbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxuICogICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqICBSZWZlcmVuY2VzOlxuICogICAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjRcbiAqL1xuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGdsb2JhbClcbiAgICAgICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICAgICAgPyBkZWZpbmUoZmFjdG9yeSkgOiBmYWN0b3J5KGdsb2JhbClcbn0oKFxuICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGZcbiAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvd1xuICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsXG46IHRoaXNcbiksIGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBleGlzdGluZyB2ZXJzaW9uIGZvciBub0NvbmZsaWN0KClcbiAgICBnbG9iYWwgPSBnbG9iYWwgfHwge307XG4gICAgdmFyIF9CYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIHZhciB2ZXJzaW9uID0gXCIyLjYuNFwiO1xuICAgIC8vIGNvbnN0YW50c1xuICAgIHZhciBiNjRjaGFyc1xuICAgICAgICA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICB2YXIgYjY0dGFiID0gZnVuY3Rpb24oYmluKSB7XG4gICAgICAgIHZhciB0ID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYmluLmxlbmd0aDsgaSA8IGw7IGkrKykgdFtiaW4uY2hhckF0KGkpXSA9IGk7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0oYjY0Y2hhcnMpO1xuICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgIC8vIGVuY29kZXIgc3R1ZmZcbiAgICB2YXIgY2JfdXRvYiA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdmFyIGNjID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgcmV0dXJuIGNjIDwgMHg4MCA/IGNcbiAgICAgICAgICAgICAgICA6IGNjIDwgMHg4MDAgPyAoZnJvbUNoYXJDb2RlKDB4YzAgfCAoY2MgPj4+IDYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKGNjICYgMHgzZikpKVxuICAgICAgICAgICAgICAgIDogKGZyb21DaGFyQ29kZSgweGUwIHwgKChjYyA+Pj4gMTIpICYgMHgwZikpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiAgNikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICggY2MgICAgICAgICAmIDB4M2YpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2MgPSAweDEwMDAwXG4gICAgICAgICAgICAgICAgKyAoYy5jaGFyQ29kZUF0KDApIC0gMHhEODAwKSAqIDB4NDAwXG4gICAgICAgICAgICAgICAgKyAoYy5jaGFyQ29kZUF0KDEpIC0gMHhEQzAwKTtcbiAgICAgICAgICAgIHJldHVybiAoZnJvbUNoYXJDb2RlKDB4ZjAgfCAoKGNjID4+PiAxOCkgJiAweDA3KSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+IDEyKSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKChjYyA+Pj4gIDYpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoIGNjICAgICAgICAgJiAweDNmKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVfdXRvYiA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZGXXxbXlxceDAwLVxceDdGXS9nO1xuICAgIHZhciB1dG9iID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gdS5yZXBsYWNlKHJlX3V0b2IsIGNiX3V0b2IpO1xuICAgIH07XG4gICAgdmFyIGNiX2VuY29kZSA9IGZ1bmN0aW9uKGNjYykge1xuICAgICAgICB2YXIgcGFkbGVuID0gWzAsIDIsIDFdW2NjYy5sZW5ndGggJSAzXSxcbiAgICAgICAgb3JkID0gY2NjLmNoYXJDb2RlQXQoMCkgPDwgMTZcbiAgICAgICAgICAgIHwgKChjY2MubGVuZ3RoID4gMSA/IGNjYy5jaGFyQ29kZUF0KDEpIDogMCkgPDwgOClcbiAgICAgICAgICAgIHwgKChjY2MubGVuZ3RoID4gMiA/IGNjYy5jaGFyQ29kZUF0KDIpIDogMCkpLFxuICAgICAgICBjaGFycyA9IFtcbiAgICAgICAgICAgIGI2NGNoYXJzLmNoYXJBdCggb3JkID4+PiAxOCksXG4gICAgICAgICAgICBiNjRjaGFycy5jaGFyQXQoKG9yZCA+Pj4gMTIpICYgNjMpLFxuICAgICAgICAgICAgcGFkbGVuID49IDIgPyAnPScgOiBiNjRjaGFycy5jaGFyQXQoKG9yZCA+Pj4gNikgJiA2MyksXG4gICAgICAgICAgICBwYWRsZW4gPj0gMSA/ICc9JyA6IGI2NGNoYXJzLmNoYXJBdChvcmQgJiA2MylcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH07XG4gICAgdmFyIGJ0b2EgPSBnbG9iYWwuYnRvYSAmJiB0eXBlb2YgZ2xvYmFsLmJ0b2EgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGZ1bmN0aW9uKGIpeyByZXR1cm4gZ2xvYmFsLmJ0b2EoYikgfSA6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgaWYgKGIubWF0Y2goL1teXFx4MDAtXFx4RkZdLykpIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgJ1RoZSBzdHJpbmcgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGIucmVwbGFjZSgvW1xcc1xcU117MSwzfS9nLCBjYl9lbmNvZGUpO1xuICAgIH07XG4gICAgdmFyIF9lbmNvZGUgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiBidG9hKHV0b2IoU3RyaW5nKHUpKSk7XG4gICAgfTtcbiAgICB2YXIgbWtVcmlTYWZlID0gZnVuY3Rpb24gKGI2NCkge1xuICAgICAgICByZXR1cm4gYjY0LnJlcGxhY2UoL1srXFwvXS9nLCBmdW5jdGlvbihtMCkge1xuICAgICAgICAgICAgcmV0dXJuIG0wID09ICcrJyA/ICctJyA6ICdfJztcbiAgICAgICAgfSkucmVwbGFjZSgvPS9nLCAnJyk7XG4gICAgfTtcbiAgICB2YXIgZW5jb2RlID0gZnVuY3Rpb24odSwgdXJpc2FmZSkge1xuICAgICAgICByZXR1cm4gdXJpc2FmZSA/IG1rVXJpU2FmZShfZW5jb2RlKHUpKSA6IF9lbmNvZGUodSk7XG4gICAgfTtcbiAgICB2YXIgZW5jb2RlVVJJID0gZnVuY3Rpb24odSkgeyByZXR1cm4gZW5jb2RlKHUsIHRydWUpIH07XG4gICAgdmFyIGZyb21VaW50OEFycmF5O1xuICAgIGlmIChnbG9iYWwuVWludDhBcnJheSkgZnJvbVVpbnQ4QXJyYXkgPSBmdW5jdGlvbihhLCB1cmlzYWZlKSB7XG4gICAgICAgIC8vIHJldHVybiBidG9hKGZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhKSk7XG4gICAgICAgIHZhciBiNjQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuICAgICAgICAgICAgdmFyIGEwID0gYVtpXSwgYTEgPSBhW2krMV0sIGEyID0gYVtpKzJdO1xuICAgICAgICAgICAgdmFyIG9yZCA9IGEwIDw8IDE2IHwgYTEgPDwgOCB8IGEyO1xuICAgICAgICAgICAgYjY0ICs9ICAgIGI2NGNoYXJzLmNoYXJBdCggb3JkID4+PiAxOClcbiAgICAgICAgICAgICAgICArICAgICBiNjRjaGFycy5jaGFyQXQoKG9yZCA+Pj4gMTIpICYgNjMpXG4gICAgICAgICAgICAgICAgKyAoIHR5cGVvZiBhMSAhPSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICA/IGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiAgNikgJiA2MykgOiAnPScpXG4gICAgICAgICAgICAgICAgKyAoIHR5cGVvZiBhMiAhPSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICA/IGI2NGNoYXJzLmNoYXJBdCggb3JkICAgICAgICAgJiA2MykgOiAnPScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmlzYWZlID8gbWtVcmlTYWZlKGI2NCkgOiBiNjQ7XG4gICAgfTtcbiAgICAvLyBkZWNvZGVyIHN0dWZmXG4gICAgdmFyIHJlX2J0b3UgPSAvW1xceEMwLVxceERGXVtcXHg4MC1cXHhCRl18W1xceEUwLVxceEVGXVtcXHg4MC1cXHhCRl17Mn18W1xceEYwLVxceEY3XVtcXHg4MC1cXHhCRl17M30vZztcbiAgICB2YXIgY2JfYnRvdSA9IGZ1bmN0aW9uKGNjY2MpIHtcbiAgICAgICAgc3dpdGNoKGNjY2MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHZhciBjcCA9ICgoMHgwNyAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgMTgpXG4gICAgICAgICAgICAgICAgfCAgICAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDEyKVxuICAgICAgICAgICAgICAgIHwgICAgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKSA8PCAgNilcbiAgICAgICAgICAgICAgICB8ICAgICAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgzKSksXG4gICAgICAgICAgICBvZmZzZXQgPSBjcCAtIDB4MTAwMDA7XG4gICAgICAgICAgICByZXR1cm4gKGZyb21DaGFyQ29kZSgob2Zmc2V0ICA+Pj4gMTApICsgMHhEODAwKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgob2Zmc2V0ICYgMHgzRkYpICsgMHhEQzAwKSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgKCgweDBmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxMilcbiAgICAgICAgICAgICAgICAgICAgfCAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDYpXG4gICAgICAgICAgICAgICAgICAgIHwgICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAgZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgICAgICgoMHgxZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgYnRvdSA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVwbGFjZShyZV9idG91LCBjYl9idG91KTtcbiAgICB9O1xuICAgIHZhciBjYl9kZWNvZGUgPSBmdW5jdGlvbihjY2NjKSB7XG4gICAgICAgIHZhciBsZW4gPSBjY2NjLmxlbmd0aCxcbiAgICAgICAgcGFkbGVuID0gbGVuICUgNCxcbiAgICAgICAgbiA9IChsZW4gPiAwID8gYjY0dGFiW2NjY2MuY2hhckF0KDApXSA8PCAxOCA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAxID8gYjY0dGFiW2NjY2MuY2hhckF0KDEpXSA8PCAxMiA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAyID8gYjY0dGFiW2NjY2MuY2hhckF0KDIpXSA8PCAgNiA6IDApXG4gICAgICAgICAgICB8IChsZW4gPiAzID8gYjY0dGFiW2NjY2MuY2hhckF0KDMpXSAgICAgICA6IDApLFxuICAgICAgICBjaGFycyA9IFtcbiAgICAgICAgICAgIGZyb21DaGFyQ29kZSggbiA+Pj4gMTYpLFxuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKChuID4+PiAgOCkgJiAweGZmKSxcbiAgICAgICAgICAgIGZyb21DaGFyQ29kZSggbiAgICAgICAgICYgMHhmZilcbiAgICAgICAgXTtcbiAgICAgICAgY2hhcnMubGVuZ3RoIC09IFswLCAwLCAyLCAxXVtwYWRsZW5dO1xuICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfTtcbiAgICB2YXIgX2F0b2IgPSBnbG9iYWwuYXRvYiAmJiB0eXBlb2YgZ2xvYmFsLmF0b2IgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGZ1bmN0aW9uKGEpeyByZXR1cm4gZ2xvYmFsLmF0b2IoYSkgfSA6IGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gYS5yZXBsYWNlKC9cXFN7MSw0fS9nLCBjYl9kZWNvZGUpO1xuICAgIH07XG4gICAgdmFyIGF0b2IgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBfYXRvYihTdHJpbmcoYSkucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKSk7XG4gICAgfTtcbiAgICB2YXIgX2RlY29kZSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGJ0b3UoX2F0b2IoYSkpIH07XG4gICAgdmFyIF9mcm9tVVJJID0gZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGEpLnJlcGxhY2UoL1stX10vZywgZnVuY3Rpb24obTApIHtcbiAgICAgICAgICAgIHJldHVybiBtMCA9PSAnLScgPyAnKycgOiAnLydcbiAgICAgICAgfSkucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKTtcbiAgICB9O1xuICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbihhKXtcbiAgICAgICAgcmV0dXJuIF9kZWNvZGUoX2Zyb21VUkkoYSkpO1xuICAgIH07XG4gICAgdmFyIHRvVWludDhBcnJheTtcbiAgICBpZiAoZ2xvYmFsLlVpbnQ4QXJyYXkpIHRvVWludDhBcnJheSA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhdG9iKF9mcm9tVVJJKGEpKSwgZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgbm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgQmFzZTY0ID0gZ2xvYmFsLkJhc2U2NDtcbiAgICAgICAgZ2xvYmFsLkJhc2U2NCA9IF9CYXNlNjQ7XG4gICAgICAgIHJldHVybiBCYXNlNjQ7XG4gICAgfTtcbiAgICAvLyBleHBvcnQgQmFzZTY0XG4gICAgZ2xvYmFsLkJhc2U2NCA9IHtcbiAgICAgICAgVkVSU0lPTjogdmVyc2lvbixcbiAgICAgICAgYXRvYjogYXRvYixcbiAgICAgICAgYnRvYTogYnRvYSxcbiAgICAgICAgZnJvbUJhc2U2NDogZGVjb2RlLFxuICAgICAgICB0b0Jhc2U2NDogZW5jb2RlLFxuICAgICAgICB1dG9iOiB1dG9iLFxuICAgICAgICBlbmNvZGU6IGVuY29kZSxcbiAgICAgICAgZW5jb2RlVVJJOiBlbmNvZGVVUkksXG4gICAgICAgIGJ0b3U6IGJ0b3UsXG4gICAgICAgIGRlY29kZTogZGVjb2RlLFxuICAgICAgICBub0NvbmZsaWN0OiBub0NvbmZsaWN0LFxuICAgICAgICBmcm9tVWludDhBcnJheTogZnJvbVVpbnQ4QXJyYXksXG4gICAgICAgIHRvVWludDhBcnJheTogdG9VaW50OEFycmF5XG4gICAgfTtcbiAgICAvLyBpZiBFUzUgaXMgYXZhaWxhYmxlLCBtYWtlIEJhc2U2NC5leHRlbmRTdHJpbmcoKSBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgbm9FbnVtID0gZnVuY3Rpb24odil7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbHVlOnYsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2xvYmFsLkJhc2U2NC5leHRlbmRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ2Zyb21CYXNlNjQnLCBub0VudW0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlKHRoaXMpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUsICd0b0Jhc2U2NCcsIG5vRW51bShmdW5jdGlvbiAodXJpc2FmZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlKHRoaXMsIHVyaXNhZmUpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUsICd0b0Jhc2U2NFVSSScsIG5vRW51bShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGUodGhpcywgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vXG4gICAgLy8gZXhwb3J0IEJhc2U2NCB0byB0aGUgbmFtZXNwYWNlXG4gICAgLy9cbiAgICBpZiAoZ2xvYmFsWydNZXRlb3InXSkgeyAvLyBNZXRlb3IuanNcbiAgICAgICAgQmFzZTY0ID0gZ2xvYmFsLkJhc2U2NDtcbiAgICB9XG4gICAgLy8gbW9kdWxlLmV4cG9ydHMgYW5kIEFNRCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgIC8vIG1vZHVsZS5leHBvcnRzIGhhcyBwcmVjZWRlbmNlLlxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cy5CYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCl7IHJldHVybiBnbG9iYWwuQmFzZTY0IH0pO1xuICAgIH1cbiAgICAvLyB0aGF0J3MgaXQhXG4gICAgcmV0dXJuIHtCYXNlNjQ6IGdsb2JhbC5CYXNlNjR9XG59KSk7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMiB8fCBmdW5jdGlvbiAoeCkge1xuXHRyZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzJFO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXJlSW5wdXRzRXF1YWwobmV3SW5wdXRzLCBsYXN0SW5wdXRzKSB7XG4gICAgaWYgKG5ld0lucHV0cy5sZW5ndGggIT09IGxhc3RJbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG5ld0lucHV0c1tpXSAhPT0gbGFzdElucHV0c1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplT25lKHJlc3VsdEZuLCBpc0VxdWFsKSB7XG4gICAgaWYgKGlzRXF1YWwgPT09IHZvaWQgMCkgeyBpc0VxdWFsID0gYXJlSW5wdXRzRXF1YWw7IH1cbiAgICB2YXIgbGFzdFRoaXM7XG4gICAgdmFyIGxhc3RBcmdzID0gW107XG4gICAgdmFyIGxhc3RSZXN1bHQ7XG4gICAgdmFyIGNhbGxlZE9uY2UgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICAgICAgdmFyIG5ld0FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG5ld0FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGVkT25jZSAmJiBsYXN0VGhpcyA9PT0gdGhpcyAmJiBpc0VxdWFsKG5ld0FyZ3MsIGxhc3RBcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFJlc3VsdCA9IHJlc3VsdEZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICBjYWxsZWRPbmNlID0gdHJ1ZTtcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0QXJncyA9IG5ld0FyZ3M7XG4gICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZU9uZTtcbiIsInZhciB3aWxkY2FyZCA9IHJlcXVpcmUoJ3dpbGRjYXJkJyk7XG52YXIgcmVNaW1lUGFydFNwbGl0ID0gL1tcXC9cXCtcXC5dLztcblxuLyoqXG4gICMgbWltZS1tYXRjaFxuXG4gIEEgc2ltcGxlIGZ1bmN0aW9uIHRvIGNoZWNrZXIgd2hldGhlciBhIHRhcmdldCBtaW1lIHR5cGUgbWF0Y2hlcyBhIG1pbWUtdHlwZVxuICBwYXR0ZXJuIChlLmcuIGltYWdlL2pwZWcgbWF0Y2hlcyBpbWFnZS9qcGVnIE9SIGltYWdlLyopLlxuXG4gICMjIEV4YW1wbGUgVXNhZ2VcblxuICA8PDwgZXhhbXBsZS5qc1xuXG4qKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBwYXR0ZXJuKSB7XG4gIGZ1bmN0aW9uIHRlc3QocGF0dGVybikge1xuICAgIHZhciByZXN1bHQgPSB3aWxkY2FyZChwYXR0ZXJuLCB0YXJnZXQsIHJlTWltZVBhcnRTcGxpdCk7XG5cbiAgICAvLyBlbnN1cmUgdGhhdCB3ZSBoYXZlIGEgdmFsaWQgbWltZSB0eXBlIChzaG91bGQgaGF2ZSB0d28gcGFydHMpXG4gICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID49IDI7XG4gIH1cblxuICByZXR1cm4gcGF0dGVybiA/IHRlc3QocGF0dGVybi5zcGxpdCgnOycpWzBdKSA6IHRlc3Q7XG59O1xuIiwiLyoqXG4qIENyZWF0ZSBhbiBldmVudCBlbWl0dGVyIHdpdGggbmFtZXNwYWNlc1xuKiBAbmFtZSBjcmVhdGVOYW1lc3BhY2VFbWl0dGVyXG4qIEBleGFtcGxlXG4qIHZhciBlbWl0dGVyID0gcmVxdWlyZSgnLi9pbmRleCcpKClcbipcbiogZW1pdHRlci5vbignKicsIGZ1bmN0aW9uICgpIHtcbiogICBjb25zb2xlLmxvZygnYWxsIGV2ZW50cyBlbWl0dGVkJywgdGhpcy5ldmVudClcbiogfSlcbipcbiogZW1pdHRlci5vbignZXhhbXBsZScsIGZ1bmN0aW9uICgpIHtcbiogICBjb25zb2xlLmxvZygnZXhhbXBsZSBldmVudCBlbWl0dGVkJylcbiogfSlcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZU5hbWVzcGFjZUVtaXR0ZXIgKCkge1xuICB2YXIgZW1pdHRlciA9IHt9XG4gIHZhciBfZm5zID0gZW1pdHRlci5fZm5zID0ge31cblxuICAvKipcbiAgKiBFbWl0IGFuIGV2ZW50LiBPcHRpb25hbGx5IG5hbWVzcGFjZSB0aGUgZXZlbnQuIEhhbmRsZXJzIGFyZSBmaXJlZCBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIGFkZGVkIHdpdGggZXhhY3QgbWF0Y2hlcyB0YWtpbmcgcHJlY2VkZW5jZS4gU2VwYXJhdGUgdGhlIG5hbWVzcGFjZSBhbmQgZXZlbnQgd2l0aCBhIGA6YFxuICAqIEBuYW1lIGVtaXRcbiAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQg4oCTIHRoZSBuYW1lIG9mIHRoZSBldmVudCwgd2l0aCBvcHRpb25hbCBuYW1lc3BhY2VcbiAgKiBAcGFyYW0gey4uLip9IGRhdGEg4oCTIHVwIHRvIDYgYXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgKiBAZXhhbXBsZVxuICAqIGVtaXR0ZXIuZW1pdCgnZXhhbXBsZScpXG4gICogZW1pdHRlci5lbWl0KCdkZW1vOnRlc3QnKVxuICAqIGVtaXR0ZXIuZW1pdCgnZGF0YScsIHsgZXhhbXBsZTogdHJ1ZX0sICdhIHN0cmluZycsIDEpXG4gICovXG4gIGVtaXR0ZXIuZW1pdCA9IGZ1bmN0aW9uIGVtaXQgKGV2ZW50LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2KSB7XG4gICAgdmFyIHRvRW1pdCA9IGdldExpc3RlbmVycyhldmVudClcblxuICAgIGlmICh0b0VtaXQubGVuZ3RoKSB7XG4gICAgICBlbWl0QWxsKGV2ZW50LCB0b0VtaXQsIFthcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2XSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBDcmVhdGUgZW4gZXZlbnQgbGlzdGVuZXIuXG4gICogQG5hbWUgb25cbiAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAqIEBleGFtcGxlXG4gICogZW1pdHRlci5vbignZXhhbXBsZScsIGZ1bmN0aW9uICgpIHt9KVxuICAqIGVtaXR0ZXIub24oJ2RlbW8nLCBmdW5jdGlvbiAoKSB7fSlcbiAgKi9cbiAgZW1pdHRlci5vbiA9IGZ1bmN0aW9uIG9uIChldmVudCwgZm4pIHtcbiAgICBpZiAoIV9mbnNbZXZlbnRdKSB7XG4gICAgICBfZm5zW2V2ZW50XSA9IFtdXG4gICAgfVxuXG4gICAgX2Zuc1tldmVudF0ucHVzaChmbilcbiAgfVxuXG4gIC8qKlxuICAqIENyZWF0ZSBlbiBldmVudCBsaXN0ZW5lciB0aGF0IGZpcmVzIG9uY2UuXG4gICogQG5hbWUgb25jZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICogQGV4YW1wbGVcbiAgKiBlbWl0dGVyLm9uY2UoJ2V4YW1wbGUnLCBmdW5jdGlvbiAoKSB7fSlcbiAgKiBlbWl0dGVyLm9uY2UoJ2RlbW8nLCBmdW5jdGlvbiAoKSB7fSlcbiAgKi9cbiAgZW1pdHRlci5vbmNlID0gZnVuY3Rpb24gb25jZSAoZXZlbnQsIGZuKSB7XG4gICAgZnVuY3Rpb24gb25lICgpIHtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIGVtaXR0ZXIub2ZmKGV2ZW50LCBvbmUpXG4gICAgfVxuICAgIHRoaXMub24oZXZlbnQsIG9uZSlcbiAgfVxuXG4gIC8qKlxuICAqIFN0b3AgbGlzdGVuaW5nIHRvIGFuIGV2ZW50LiBTdG9wIGFsbCBsaXN0ZW5lcnMgb24gYW4gZXZlbnQgYnkgb25seSBwYXNzaW5nIHRoZSBldmVudCBuYW1lLiBTdG9wIGEgc2luZ2xlIGxpc3RlbmVyIGJ5IHBhc3NpbmcgdGhhdCBldmVudCBoYW5kbGVyIGFzIGEgY2FsbGJhY2suXG4gICogWW91IG11c3QgYmUgZXhwbGljaXQgYWJvdXQgd2hhdCB3aWxsIGJlIHVuc3Vic2NyaWJlZDogYGVtaXR0ZXIub2ZmKCdkZW1vJylgIHdpbGwgdW5zdWJzY3JpYmUgYW4gYGVtaXR0ZXIub24oJ2RlbW8nKWAgbGlzdGVuZXIsXG4gICogYGVtaXR0ZXIub2ZmKCdkZW1vOmV4YW1wbGUnKWAgd2lsbCB1bnN1YnNjcmliZSBhbiBgZW1pdHRlci5vbignZGVtbzpleGFtcGxlJylgIGxpc3RlbmVyXG4gICogQG5hbWUgb2ZmXG4gICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSDigJMgdGhlIHNwZWNpZmljIGhhbmRsZXJcbiAgKiBAZXhhbXBsZVxuICAqIGVtaXR0ZXIub2ZmKCdleGFtcGxlJylcbiAgKiBlbWl0dGVyLm9mZignZGVtbycsIGZ1bmN0aW9uICgpIHt9KVxuICAqL1xuICBlbWl0dGVyLm9mZiA9IGZ1bmN0aW9uIG9mZiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIGtlZXAgPSBbXVxuXG4gICAgaWYgKGV2ZW50ICYmIGZuKSB7XG4gICAgICB2YXIgZm5zID0gdGhpcy5fZm5zW2V2ZW50XVxuICAgICAgdmFyIGkgPSAwXG4gICAgICB2YXIgbCA9IGZucyA/IGZucy5sZW5ndGggOiAwXG5cbiAgICAgIGZvciAoaTsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoZm5zW2ldICE9PSBmbikge1xuICAgICAgICAgIGtlZXAucHVzaChmbnNbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBrZWVwLmxlbmd0aCA/IHRoaXMuX2Zuc1tldmVudF0gPSBrZWVwIDogZGVsZXRlIHRoaXMuX2Zuc1tldmVudF1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExpc3RlbmVycyAoZSkge1xuICAgIHZhciBvdXQgPSBfZm5zW2VdID8gX2Zuc1tlXSA6IFtdXG4gICAgdmFyIGlkeCA9IGUuaW5kZXhPZignOicpXG4gICAgdmFyIGFyZ3MgPSAoaWR4ID09PSAtMSkgPyBbZV0gOiBbZS5zdWJzdHJpbmcoMCwgaWR4KSwgZS5zdWJzdHJpbmcoaWR4ICsgMSldXG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKF9mbnMpXG4gICAgdmFyIGkgPSAwXG4gICAgdmFyIGwgPSBrZXlzLmxlbmd0aFxuXG4gICAgZm9yIChpOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgaWYgKGtleSA9PT0gJyonKSB7XG4gICAgICAgIG91dCA9IG91dC5jb25jYXQoX2Zuc1trZXldKVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDIgJiYgYXJnc1swXSA9PT0ga2V5KSB7XG4gICAgICAgIG91dCA9IG91dC5jb25jYXQoX2Zuc1trZXldKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRBbGwgKGUsIGZucywgYXJncykge1xuICAgIHZhciBpID0gMFxuICAgIHZhciBsID0gZm5zLmxlbmd0aFxuXG4gICAgZm9yIChpOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoIWZuc1tpXSkgYnJlYWtcbiAgICAgIGZuc1tpXS5ldmVudCA9IGVcbiAgICAgIGZuc1tpXS5hcHBseShmbnNbaV0sIGFyZ3MpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVtaXR0ZXJcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuXG4vKipcbiAqIFN0cmluZ2lmeSBhbiBvYmplY3QgZm9yIHVzZSBpbiBhIHF1ZXJ5IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggLSBXaGVuIG5lc3RpbmcsIHRoZSBwYXJlbnQga2V5LlxuICogICAgIGtleXMgaW4gYG9iamAgd2lsbCBiZSBzdHJpbmdpZmllZCBhcyBgcHJlZml4W2tleV1gLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHF1ZXJ5U3RyaW5naWZ5IChvYmosIHByZWZpeCkge1xuICB2YXIgcGFpcnMgPSBbXVxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gb2JqW2tleV1cbiAgICB2YXIgZW5rZXkgPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KVxuICAgIHZhciBwYWlyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHBhaXIgPSBxdWVyeVN0cmluZ2lmeSh2YWx1ZSwgcHJlZml4ID8gcHJlZml4ICsgJ1snICsgZW5rZXkgKyAnXScgOiBlbmtleSlcbiAgICB9IGVsc2Uge1xuICAgICAgcGFpciA9IChwcmVmaXggPyBwcmVmaXggKyAnWycgKyBlbmtleSArICddJyA6IGVua2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSlcbiAgICB9XG4gICAgcGFpcnMucHVzaChwYWlyKVxuICB9XG4gIHJldHVybiBwYWlycy5qb2luKCcmJylcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCB1bmRlZjtcblxuLyoqXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfE51bGx9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5jb2RlIGEgZ2l2ZW4gaW5wdXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBlbmNvZGVkLlxuICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8jJl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcbiAgICAgICwgdmFsdWUgPSBkZWNvZGUocGFydFsyXSk7XG5cbiAgICAvL1xuICAgIC8vIFByZXZlbnQgb3ZlcnJpZGluZyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgdGhhdCBidWlsZC1pblxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcbiAgICAvLyBxdWVyeXN0cmluZ3MuXG4gICAgLy9cbiAgICAvLyBJbiB0aGUgY2FzZSBpZiBmYWlsZWQgZGVjb2RpbmcsIHdlIHdhbnQgdG8gb21pdCB0aGUga2V5L3ZhbHVlIHBhaXJzXG4gICAgLy8gZnJvbSB0aGUgcmVzdWx0LlxuICAgIC8vXG4gICAgaWYgKGtleSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBrZXkgaW4gcmVzdWx0KSBjb250aW51ZTtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdXG4gICAgLCB2YWx1ZVxuICAgICwga2V5O1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIC8vXG4gICAgICAvLyBFZGdlIGNhc2VzIHdoZXJlIHdlIGFjdHVhbGx5IHdhbnQgdG8gZW5jb2RlIHRoZSB2YWx1ZSB0byBhbiBlbXB0eVxuICAgICAgLy8gc3RyaW5nIGluc3RlYWQgb2YgdGhlIHN0cmluZ2lmaWVkIHZhbHVlLlxuICAgICAgLy9cbiAgICAgIGlmICghdmFsdWUgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZiB8fCBpc05hTih2YWx1ZSkpKSB7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGtleSA9IGVuY29kZShrZXkpO1xuICAgICAgdmFsdWUgPSBlbmNvZGUodmFsdWUpO1xuXG4gICAgICAvL1xuICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGVuY29kZSB0aGUgc3RyaW5ncywgd2Ugc2hvdWxkIGJhaWwgb3V0IGFzIHdlIGRvbid0XG4gICAgICAvLyB3YW50IHRvIGFkZCBpbnZhbGlkIHN0cmluZ3MgdG8gdGhlIHF1ZXJ5LlxuICAgICAgLy9cbiAgICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgcGFpcnMucHVzaChrZXkgKyc9JysgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UncmUgcmVxdWlyZWQgdG8gYWRkIGEgcG9ydCBudW1iZXIuXG4gKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RlZmF1bHQtcG9ydFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBwb3J0IFBvcnQgbnVtYmVyIHdlIG5lZWQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSXMgaXQgYSBkZWZhdWx0IHBvcnQgZm9yIHRoZSBnaXZlbiBwcm90b2NvbFxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZWQocG9ydCwgcHJvdG9jb2wpIHtcbiAgcHJvdG9jb2wgPSBwcm90b2NvbC5zcGxpdCgnOicpWzBdO1xuICBwb3J0ID0gK3BvcnQ7XG5cbiAgaWYgKCFwb3J0KSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgIGNhc2UgJ2h0dHAnOlxuICAgIGNhc2UgJ3dzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gODA7XG5cbiAgICBjYXNlICdodHRwcyc6XG4gICAgY2FzZSAnd3NzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNDQzO1xuXG4gICAgY2FzZSAnZnRwJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gMjE7XG5cbiAgICBjYXNlICdnb3BoZXInOlxuICAgIHJldHVybiBwb3J0ICE9PSA3MDtcblxuICAgIGNhc2UgJ2ZpbGUnOlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwb3J0ICE9PSAwO1xufTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgKGdsb2JhbC5SZXNpemVPYnNlcnZlciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxyXG4gICAgICogQSBjb2xsZWN0aW9uIG9mIHNoaW1zIHRoYXQgcHJvdmlkZSBtaW5pbWFsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIEVTNiBjb2xsZWN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBUaGVzZSBpbXBsZW1lbnRhdGlvbnMgYXJlIG5vdCBtZWFudCB0byBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIFJlc2l6ZU9ic2VydmVyXHJcbiAgICAgKiBtb2R1bGVzIGFzIHRoZXkgY292ZXIgb25seSBhIGxpbWl0ZWQgcmFuZ2Ugb2YgdXNlIGNhc2VzLlxyXG4gICAgICovXHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jLCB2YWxpZC1qc2RvYyAqL1xyXG4gICAgdmFyIE1hcFNoaW0gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gTWFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGluZGV4IGluIHByb3ZpZGVkIGFycmF5IHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBhcnJcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0SW5kZXgoYXJyLCBrZXkpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IC0xO1xyXG4gICAgICAgICAgICBhcnIuc29tZShmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnlbMF0gPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2VudHJpZXNfXy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX19lbnRyaWVzX19baW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzFdO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX19baW5kZXhdWzFdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLl9fZW50cmllc19fO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgoZW50cmllcywga2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhIX5nZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18uc3BsaWNlKDApO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSBbY3R4PW51bGxdXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3R4ID09PSB2b2lkIDApIHsgY3R4ID0gbnVsbDsgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX19lbnRyaWVzX187IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlbnRyeVsxXSwgZW50cnlbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NfMTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgfSkoKTtcblxuICAgIC8qKlxyXG4gICAgICogRGV0ZWN0cyB3aGV0aGVyIHdpbmRvdyBhbmQgZG9jdW1lbnQgb2JqZWN0cyBhcmUgYXZhaWxhYmxlIGluIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbiAgICAgKi9cclxuICAgIHZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCA9PT0gZG9jdW1lbnQ7XG5cbiAgICAvLyBSZXR1cm5zIGdsb2JhbCBvYmplY3Qgb2YgYSBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gICAgdmFyIGdsb2JhbCQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcclxuICAgICAgICByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxuICAgIH0pKCk7XG5cbiAgICAvKipcclxuICAgICAqIEEgc2hpbSBmb3IgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aGljaCBmYWxscyBiYWNrIHRvIHRoZSBzZXRUaW1lb3V0IGlmXHJcbiAgICAgKiBmaXJzdCBvbmUgaXMgbm90IHN1cHBvcnRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXF1ZXN0cycgaWRlbnRpZmllci5cclxuICAgICAqL1xyXG4gICAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHVzZSBhIGJvdW5kZWQgZnVuY3Rpb24gYmVjYXVzZSBJRSBzb21ldGltZXMgdGhyb3dzXHJcbiAgICAgICAgICAgIC8vIGFuIFwiSW52YWxpZCBjYWxsaW5nIG9iamVjdFwiIGVycm9yIGlmIHJBRiBpcyBpbnZva2VkIHdpdGhvdXQgdGhlIGdsb2JhbFxyXG4gICAgICAgICAgICAvLyBvYmplY3Qgb24gdGhlIGxlZnQgaGFuZCBzaWRlLlxyXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQoZ2xvYmFsJDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKERhdGUubm93KCkpOyB9LCAxMDAwIC8gNjApOyB9O1xyXG4gICAgfSkoKTtcblxuICAgIC8vIERlZmluZXMgbWluaW11bSB0aW1lb3V0IGJlZm9yZSBhZGRpbmcgYSB0cmFpbGluZyBjYWxsLlxyXG4gICAgdmFyIHRyYWlsaW5nVGltZW91dCA9IDI7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIGVuc3VyZXMgdGhhdCBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlXHJcbiAgICAgKiBpbnZva2VkIG9ubHkgb25jZSBkdXJpbmcgdGhlIHNwZWNpZmllZCBkZWxheSBwZXJpb2QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBkZWxheSBwZXJpb2QuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSBEZWxheSBhZnRlciB3aGljaCB0byBpbnZva2UgY2FsbGJhY2suXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRocm90dGxlIChjYWxsYmFjaywgZGVsYXkpIHtcclxuICAgICAgICB2YXIgbGVhZGluZ0NhbGwgPSBmYWxzZSwgdHJhaWxpbmdDYWxsID0gZmFsc2UsIGxhc3RDYWxsVGltZSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW52b2tlcyB0aGUgb3JpZ2luYWwgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIHNjaGVkdWxlcyBuZXcgaW52b2NhdGlvbiBpZlxyXG4gICAgICAgICAqIHRoZSBcInByb3h5XCIgd2FzIGNhbGxlZCBkdXJpbmcgY3VycmVudCByZXF1ZXN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZVBlbmRpbmcoKSB7XHJcbiAgICAgICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRyYWlsaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICAgICAgcHJveHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsYmFjayBpbnZva2VkIGFmdGVyIHRoZSBzcGVjaWZpZWQgZGVsYXkuIEl0IHdpbGwgZnVydGhlciBwb3N0cG9uZVxyXG4gICAgICAgICAqIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGRlbGVnYXRpbmcgaXQgdG8gdGhlXHJcbiAgICAgICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gdGltZW91dENhbGxiYWNrKCkge1xyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMShyZXNvbHZlUGVuZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNjaGVkdWxlcyBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHByb3h5KCkge1xyXG4gICAgICAgICAgICB2YXIgdGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWplY3QgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGNhbGxzLlxyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVTdGFtcCAtIGxhc3RDYWxsVGltZSA8IHRyYWlsaW5nVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIG5ldyBjYWxsIHRvIGJlIGluIGludm9rZWQgd2hlbiB0aGUgcGVuZGluZyBvbmUgaXMgcmVzb2x2ZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgXCJ0cmFuc2l0aW9uc1wiIHdoaWNoIG5ldmVyIGFjdHVhbGx5IHN0YXJ0XHJcbiAgICAgICAgICAgICAgICAvLyBpbW1lZGlhdGVseSBzbyB0aGVyZSBpcyBhIGNoYW5jZSB0aGF0IHdlIG1pZ2h0IG1pc3Mgb25lIGlmIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgLy8gaGFwcGVucyBhbWlkcyB0aGUgcGVuZGluZyBpbnZvY2F0aW9uLlxyXG4gICAgICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lb3V0Q2FsbGJhY2ssIGRlbGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lU3RhbXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm94eTtcclxuICAgIH1cblxuICAgIC8vIE1pbmltdW0gZGVsYXkgYmVmb3JlIGludm9raW5nIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLlxyXG4gICAgdmFyIFJFRlJFU0hfREVMQVkgPSAyMDtcclxuICAgIC8vIEEgbGlzdCBvZiBzdWJzdHJpbmdzIG9mIENTUyBwcm9wZXJ0aWVzIHVzZWQgdG8gZmluZCB0cmFuc2l0aW9uIGV2ZW50cyB0aGF0XHJcbiAgICAvLyBtaWdodCBhZmZlY3QgZGltZW5zaW9ucyBvZiBvYnNlcnZlZCBlbGVtZW50cy5cclxuICAgIHZhciB0cmFuc2l0aW9uS2V5cyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgJ3dpZHRoJywgJ2hlaWdodCcsICdzaXplJywgJ3dlaWdodCddO1xyXG4gICAgLy8gQ2hlY2sgaWYgTXV0YXRpb25PYnNlcnZlciBpcyBhdmFpbGFibGUuXHJcbiAgICB2YXIgbXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCA9IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcclxuICAgIC8qKlxyXG4gICAgICogU2luZ2xldG9uIGNvbnRyb2xsZXIgY2xhc3Mgd2hpY2ggaGFuZGxlcyB1cGRhdGVzIG9mIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlcy5cclxuICAgICAqL1xyXG4gICAgdmFyIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgRE9NIGxpc3RlbmVycyBoYXZlIGJlZW4gYWRkZWQuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUZWxscyB0aGF0IGNvbnRyb2xsZXIgaGFzIHN1YnNjcmliZWQgZm9yIE11dGF0aW9uIEV2ZW50cy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBLZWVwcyByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9mIE11dGF0aW9uT2JzZXJ2ZXIuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlIHtNdXRhdGlvbk9ic2VydmVyfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBsaXN0IG9mIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZlclNQST59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyc18gPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmRfID0gdGhpcy5vblRyYW5zaXRpb25FbmRfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCA9IHRocm90dGxlKHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpLCBSRUZSRVNIX0RFTEFZKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBvYnNlcnZlciB0byBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgYWRkZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5hZGRPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICBpZiAoIX50aGlzLm9ic2VydmVyc18uaW5kZXhPZihvYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzXy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBZGQgbGlzdGVuZXJzIGlmIHRoZXkgaGF2ZW4ndCBiZWVuIGFkZGVkIHlldC5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSByZW1vdmVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXztcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgb2JzZXJ2ZXIgaWYgaXQncyBwcmVzZW50IGluIHJlZ2lzdHJ5LlxyXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgbGlzdGVuZXJzIGlmIGNvbnRyb2xsZXIgaGFzIG5vIGNvbm5lY3RlZCBvYnNlcnZlcnMuXHJcbiAgICAgICAgICAgIGlmICghb2JzZXJ2ZXJzLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW52b2tlcyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy4gSXQgd2lsbCBjb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaW5zb2ZhclxyXG4gICAgICAgICAqIGl0IGRldGVjdHMgY2hhbmdlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNoYW5nZXNEZXRlY3RlZCA9IHRoaXMudXBkYXRlT2JzZXJ2ZXJzXygpO1xyXG4gICAgICAgICAgICAvLyBDb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaWYgY2hhbmdlcyBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXMgdGhlcmUgbWlnaHRcclxuICAgICAgICAgICAgLy8gYmUgZnV0dXJlIG9uZXMgY2F1c2VkIGJ5IENTUyB0cmFuc2l0aW9ucy5cclxuICAgICAgICAgICAgaWYgKGNoYW5nZXNEZXRlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgZXZlcnkgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdCBhbmQgbm90aWZpZXMgdGhlbSBvZiBxdWV1ZWRcclxuICAgICAgICAgKiBlbnRyaWVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBcInRydWVcIiBpZiBhbnkgb2JzZXJ2ZXIgaGFzIGRldGVjdGVkIGNoYW5nZXMgaW5cclxuICAgICAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgaXQncyBlbGVtZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZU9ic2VydmVyc18gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIENvbGxlY3Qgb2JzZXJ2ZXJzIHRoYXQgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgICAgICB2YXIgYWN0aXZlT2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfLmZpbHRlcihmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5nYXRoZXJBY3RpdmUoKSwgb2JzZXJ2ZXIuaGFzQWN0aXZlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBEZWxpdmVyIG5vdGlmaWNhdGlvbnMgaW4gYSBzZXBhcmF0ZSBjeWNsZSBpbiBvcmRlciB0byBhdm9pZCBhbnlcclxuICAgICAgICAgICAgLy8gY29sbGlzaW9ucyBiZXR3ZWVuIG9ic2VydmVycywgZS5nLiB3aGVuIG11bHRpcGxlIGluc3RhbmNlcyBvZlxyXG4gICAgICAgICAgICAvLyBSZXNpemVPYnNlcnZlciBhcmUgdHJhY2tpbmcgdGhlIHNhbWUgZWxlbWVudCBhbmQgdGhlIGNhbGxiYWNrIG9mIG9uZVxyXG4gICAgICAgICAgICAvLyBvZiB0aGVtIGNoYW5nZXMgY29udGVudCBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCB0YXJnZXQuIFNvbWV0aW1lc1xyXG4gICAgICAgICAgICAvLyB0aGlzIG1heSByZXN1bHQgaW4gbm90aWZpY2F0aW9ucyBiZWluZyBibG9ja2VkIGZvciB0aGUgcmVzdCBvZiBvYnNlcnZlcnMuXHJcbiAgICAgICAgICAgIGFjdGl2ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikgeyByZXR1cm4gb2JzZXJ2ZXIuYnJvYWRjYXN0QWN0aXZlKCk7IH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlT2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBET00gbGlzdGVuZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmNvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgYWRkZWQuXHJcbiAgICAgICAgICAgIGlmICghaXNCcm93c2VyIHx8IHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFN1YnNjcmlwdGlvbiB0byB0aGUgXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaXMgdXNlZCBhcyBhIHdvcmthcm91bmQgZm9yXHJcbiAgICAgICAgICAgIC8vIGRlbGF5ZWQgdHJhbnNpdGlvbnMuIFRoaXMgd2F5IGl0J3MgcG9zc2libGUgdG8gY2FwdHVyZSBhdCBsZWFzdCB0aGVcclxuICAgICAgICAgICAgLy8gZmluYWwgc3RhdGUgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICBpZiAobXV0YXRpb25PYnNlcnZlclN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8ub2JzZXJ2ZShkb2N1bWVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5kaXNjb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IHJlbW92ZWQuXHJcbiAgICAgICAgICAgIGlmICghaXNCcm93c2VyIHx8ICF0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmRfKTtcclxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm11dGF0aW9uc09ic2VydmVyXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8uZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7VHJhbnNpdGlvbkV2ZW50fSBldmVudFxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUub25UcmFuc2l0aW9uRW5kXyA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgX2IgPSBfYS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xyXG4gICAgICAgICAgICAvLyBEZXRlY3Qgd2hldGhlciB0cmFuc2l0aW9uIG1heSBhZmZlY3QgZGltZW5zaW9ucyBvZiBhbiBlbGVtZW50LlxyXG4gICAgICAgICAgICB2YXIgaXNSZWZsb3dQcm9wZXJ0eSA9IHRyYW5zaXRpb25LZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhfnByb3BlcnR5TmFtZS5pbmRleE9mKGtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaXNSZWZsb3dQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgaW5zdGFuY2Ugb2YgdGhlIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlXyA9IG5ldyBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZV87XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb2xkcyByZWZlcmVuY2UgdG8gdGhlIGNvbnRyb2xsZXIncyBpbnN0YW5jZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmluc3RhbmNlXyA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcclxuICAgIH0oKSk7XG5cbiAgICAvKipcclxuICAgICAqIERlZmluZXMgbm9uLXdyaXRhYmxlL2VudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgcHJvdmlkZWQgdGFyZ2V0IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gT2JqZWN0IGZvciB3aGljaCB0byBkZWZpbmUgcHJvcGVydGllcy5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFByb3BlcnRpZXMgdG8gYmUgZGVmaW5lZC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRhcmdldCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHZhciBkZWZpbmVDb25maWd1cmFibGUgPSAoZnVuY3Rpb24gKHRhcmdldCwgcHJvcHMpIHtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMocHJvcHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9wc1trZXldLFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9KTtcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZ2xvYmFsIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB2YXIgZ2V0V2luZG93T2YgPSAoZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIE5vZGUsIHdoaWNoIG1lYW5zIHRoYXQgaXRcclxuICAgICAgICAvLyBoYXMgdGhlIFwib3duZXJEb2N1bWVudFwiIHByb3BlcnR5IGZyb20gd2hpY2ggd2UgY2FuIHJldHJpZXZlIGFcclxuICAgICAgICAvLyBjb3JyZXNwb25kaW5nIGdsb2JhbCBvYmplY3QuXHJcbiAgICAgICAgdmFyIG93bmVyR2xvYmFsID0gdGFyZ2V0ICYmIHRhcmdldC5vd25lckRvY3VtZW50ICYmIHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gICAgICAgIC8vIFJldHVybiB0aGUgbG9jYWwgZ2xvYmFsIG9iamVjdCBpZiBpdCdzIG5vdCBwb3NzaWJsZSBleHRyYWN0IG9uZSBmcm9tXHJcbiAgICAgICAgLy8gcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAgICByZXR1cm4gb3duZXJHbG9iYWwgfHwgZ2xvYmFsJDE7XHJcbiAgICB9KTtcblxuICAgIC8vIFBsYWNlaG9sZGVyIG9mIGFuIGVtcHR5IGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgdmFyIGVtcHR5UmVjdCA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBwcm92aWRlZCBzdHJpbmcgdG8gYSBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyYWN0cyBib3JkZXJzIHNpemUgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICAgICAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwb3NpdGlvbnMgLSBCb3JkZXJzIHBvc2l0aW9ucyAodG9wLCByaWdodCwgLi4uKVxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzKSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHNpemUsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1snYm9yZGVyLScgKyBwb3NpdGlvbiArICctd2lkdGgnXTtcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUgKyB0b0Zsb2F0KHZhbHVlKTtcclxuICAgICAgICB9LCAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0cmFjdHMgcGFkZGluZ3Mgc2l6ZXMgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFBhZGRpbmdzIGJveC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0UGFkZGluZ3Moc3R5bGVzKSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XHJcbiAgICAgICAgdmFyIHBhZGRpbmdzID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwb3NpdGlvbnNfMSA9IHBvc2l0aW9uczsgX2kgPCBwb3NpdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gcG9zaXRpb25zXzFbX2ldO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ3BhZGRpbmctJyArIHBvc2l0aW9uXTtcclxuICAgICAgICAgICAgcGFkZGluZ3NbcG9zaXRpb25dID0gdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYWRkaW5ncztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBTVkcgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1NWR0dyYXBoaWNzRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkc1xyXG4gICAgICogICAgICB0byBiZSBjYWxjdWxhdGVkLlxyXG4gICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgICAgICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KDAsIDAsIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBIVE1MRWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgICAgIC8vIENsaWVudCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGNhbid0IGJlXHJcbiAgICAgICAgLy8gdXNlZCBleGNsdXNpdmVseSBhcyB0aGV5IHByb3ZpZGUgcm91bmRlZCB2YWx1ZXMuXHJcbiAgICAgICAgdmFyIGNsaWVudFdpZHRoID0gdGFyZ2V0LmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIC8vIEJ5IHRoaXMgY29uZGl0aW9uIHdlIGNhbiBjYXRjaCBhbGwgbm9uLXJlcGxhY2VkIGlubGluZSwgaGlkZGVuIGFuZFxyXG4gICAgICAgIC8vIGRldGFjaGVkIGVsZW1lbnRzLiBUaG91Z2ggZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGxlc3NcclxuICAgICAgICAvLyB0aGFuIDAuNSB3aWxsIGJlIGRpc2NhcmRlZCBhcyB3ZWxsLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gV2l0aG91dCBpdCB3ZSB3b3VsZCBuZWVkIHRvIGltcGxlbWVudCBzZXBhcmF0ZSBtZXRob2RzIGZvciBlYWNoIG9mXHJcbiAgICAgICAgLy8gdGhvc2UgY2FzZXMgYW5kIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHBlcmZvcm0gYSBwcmVjaXNlIGFuZCBwZXJmb3JtYW5jZVxyXG4gICAgICAgIC8vIGVmZmVjdGl2ZSB0ZXN0IGZvciBoaWRkZW4gZWxlbWVudHMuIEUuZy4gZXZlbiBqUXVlcnkncyAnOnZpc2libGUnIGZpbHRlclxyXG4gICAgICAgIC8vIGdpdmVzIHdyb25nIHJlc3VsdHMgZm9yIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgbGVzcyB0aGFuIDAuNS5cclxuICAgICAgICBpZiAoIWNsaWVudFdpZHRoICYmICFjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0eWxlcyA9IGdldFdpbmRvd09mKHRhcmdldCkuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xyXG4gICAgICAgIHZhciBwYWRkaW5ncyA9IGdldFBhZGRpbmdzKHN0eWxlcyk7XHJcbiAgICAgICAgdmFyIGhvcml6UGFkID0gcGFkZGluZ3MubGVmdCArIHBhZGRpbmdzLnJpZ2h0O1xyXG4gICAgICAgIHZhciB2ZXJ0UGFkID0gcGFkZGluZ3MudG9wICsgcGFkZGluZ3MuYm90dG9tO1xyXG4gICAgICAgIC8vIENvbXB1dGVkIHN0eWxlcyBvZiB3aWR0aCAmIGhlaWdodCBhcmUgYmVpbmcgdXNlZCBiZWNhdXNlIHRoZXkgYXJlIHRoZVxyXG4gICAgICAgIC8vIG9ubHkgZGltZW5zaW9ucyBhdmFpbGFibGUgdG8gSlMgdGhhdCBjb250YWluIG5vbi1yb3VuZGVkIHZhbHVlcy4gSXQgY291bGRcclxuICAgICAgICAvLyBiZSBwb3NzaWJsZSB0byB1dGlsaXplIHRoZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaWYgb25seSBpdCdzIGRhdGEgd2Fzbid0XHJcbiAgICAgICAgLy8gYWZmZWN0ZWQgYnkgQ1NTIHRyYW5zZm9ybWF0aW9ucyBsZXQgYWxvbmUgcGFkZGluZ3MsIGJvcmRlcnMgYW5kIHNjcm9sbCBiYXJzLlxyXG4gICAgICAgIHZhciB3aWR0aCA9IHRvRmxvYXQoc3R5bGVzLndpZHRoKSwgaGVpZ2h0ID0gdG9GbG9hdChzdHlsZXMuaGVpZ2h0KTtcclxuICAgICAgICAvLyBXaWR0aCAmIGhlaWdodCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHdoZW4gdGhlICdib3JkZXItYm94JyBib3hcclxuICAgICAgICAvLyBtb2RlbCBpcyBhcHBsaWVkIChleGNlcHQgZm9yIElFKS5cclxuICAgICAgICBpZiAoc3R5bGVzLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XHJcbiAgICAgICAgICAgIC8vIEZvbGxvd2luZyBjb25kaXRpb25zIGFyZSByZXF1aXJlZCB0byBoYW5kbGUgSW50ZXJuZXQgRXhwbG9yZXIgd2hpY2hcclxuICAgICAgICAgICAgLy8gZG9lc24ndCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHRvIGNvbXB1dGVkIENTUyBkaW1lbnNpb25zLlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBXZSBjYW4gc2F5IHRoYXQgaWYgQ1NTIGRpbWVuc2lvbnMgKyBwYWRkaW5ncyBhcmUgZXF1YWwgdG8gdGhlIFwiY2xpZW50XCJcclxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyB0aGVuIGl0J3MgZWl0aGVyIElFLCBhbmQgdGh1cyB3ZSBkb24ndCBuZWVkIHRvIHN1YnRyYWN0XHJcbiAgICAgICAgICAgIC8vIGFueXRoaW5nLCBvciBhbiBlbGVtZW50IG1lcmVseSBkb2Vzbid0IGhhdmUgcGFkZGluZ3MvYm9yZGVycyBzdHlsZXMuXHJcbiAgICAgICAgICAgIGlmIChNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpICE9PSBjbGllbnRXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAnbGVmdCcsICdyaWdodCcpICsgaG9yaXpQYWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgIT09IGNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0IC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3RvcCcsICdib3R0b20nKSArIHZlcnRQYWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRm9sbG93aW5nIHN0ZXBzIGNhbid0IGJlIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50J3Mgcm9vdCBlbGVtZW50IGFzIGl0c1xyXG4gICAgICAgIC8vIGNsaWVudFtXaWR0aC9IZWlnaHRdIHByb3BlcnRpZXMgcmVwcmVzZW50IHZpZXdwb3J0IGFyZWEgb2YgdGhlIHdpbmRvdy5cclxuICAgICAgICAvLyBCZXNpZGVzLCBpdCdzIGFzIHdlbGwgbm90IG5lY2Vzc2FyeSBhcyB0aGUgPGh0bWw+IGl0c2VsZiBuZWl0aGVyIGhhc1xyXG4gICAgICAgIC8vIHJlbmRlcmVkIHNjcm9sbCBiYXJzIG5vciBpdCBjYW4gYmUgY2xpcHBlZC5cclxuICAgICAgICBpZiAoIWlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgLy8gSW4gc29tZSBicm93c2VycyAob25seSBpbiBGaXJlZm94LCBhY3R1YWxseSkgQ1NTIHdpZHRoICYgaGVpZ2h0XHJcbiAgICAgICAgICAgIC8vIGluY2x1ZGUgc2Nyb2xsIGJhcnMgc2l6ZSB3aGljaCBjYW4gYmUgcmVtb3ZlZCBhdCB0aGlzIHN0ZXAgYXMgc2Nyb2xsXHJcbiAgICAgICAgICAgIC8vIGJhcnMgYXJlIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiByb3VuZGVkIGRpbWVuc2lvbnMgKyBwYWRkaW5nc1xyXG4gICAgICAgICAgICAvLyBhbmQgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLCB0aG91Z2ggdGhhdCBpcyBub3QgYWx3YXlzIHRydWUgaW4gQ2hyb21lLlxyXG4gICAgICAgICAgICB2YXIgdmVydFNjcm9sbGJhciA9IE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgLSBjbGllbnRXaWR0aDtcclxuICAgICAgICAgICAgdmFyIGhvcml6U2Nyb2xsYmFyID0gTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAtIGNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgLy8gQ2hyb21lIGhhcyBhIHJhdGhlciB3ZWlyZCByb3VuZGluZyBvZiBcImNsaWVudFwiIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gZm9yIGFuIGVsZW1lbnQgd2l0aCBjb250ZW50IHdpZHRoIG9mIDMxNC4ycHggaXQgc29tZXRpbWVzIGdpdmVzXHJcbiAgICAgICAgICAgIC8vIHRoZSBjbGllbnQgd2lkdGggb2YgMzE1cHggYW5kIGZvciB0aGUgd2lkdGggb2YgMzE0LjdweCBpdCBtYXkgZ2l2ZVxyXG4gICAgICAgICAgICAvLyAzMTRweC4gQW5kIGl0IGRvZXNuJ3QgaGFwcGVuIGFsbCB0aGUgdGltZS4gU28ganVzdCBpZ25vcmUgdGhpcyBkZWx0YVxyXG4gICAgICAgICAgICAvLyBhcyBhIG5vbi1yZWxldmFudC5cclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHZlcnRTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCAtPSB2ZXJ0U2Nyb2xsYmFyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhob3JpelNjcm9sbGJhcikgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCAtPSBob3JpelNjcm9sbGJhcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQocGFkZGluZ3MubGVmdCwgcGFkZGluZ3MudG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHZhciBpc1NWR0dyYXBoaWNzRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gU29tZSBicm93c2VycywgbmFtZWx5IElFIGFuZCBFZGdlLCBkb24ndCBoYXZlIHRoZSBTVkdHcmFwaGljc0VsZW1lbnRcclxuICAgICAgICAvLyBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBTVkdHcmFwaGljc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0dyYXBoaWNzRWxlbWVudDsgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgaXQncyBzbywgdGhlbiBjaGVjayB0aGF0IGVsZW1lbnQgaXMgYXQgbGVhc3QgYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAgICAgLy8gU1ZHRWxlbWVudCBhbmQgdGhhdCBpdCBoYXMgdGhlIFwiZ2V0QkJveFwiIG1ldGhvZC5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuICh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0VsZW1lbnQgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHRhcmdldC5nZXRCQm94ID09PSAnZnVuY3Rpb24nKTsgfTtcclxuICAgIH0pKCk7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYSBkb2N1bWVudCBlbGVtZW50ICg8aHRtbD4pLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQgPT09IGdldFdpbmRvd09mKHRhcmdldCkuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIGFuIGFwcHJvcHJpYXRlIGNvbnRlbnQgcmVjdGFuZ2xlIGZvciBwcm92aWRlZCBodG1sIG9yIHN2ZyBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkcyB0byBiZSBjYWxjdWxhdGVkLlxyXG4gICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIWlzQnJvd3Nlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNTVkdHcmFwaGljc0VsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyByZWN0YW5nbGUgd2l0aCBhbiBpbnRlcmZhY2Ugb2YgdGhlIERPTVJlY3RSZWFkT25seS5cclxuICAgICAqIFNwZWM6IGh0dHBzOi8vZHJhZnRzLmZ4dGYub3JnL2dlb21ldHJ5LyNkb21yZWN0cmVhZG9ubHlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIE9iamVjdCB3aXRoIHJlY3RhbmdsZSdzIHgveSBjb29yZGluYXRlcyBhbmQgZGltZW5zaW9ucy5cclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0UmVhZE9ubHl9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlYWRPbmx5UmVjdChfYSkge1xyXG4gICAgICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICAvLyBJZiBET01SZWN0UmVhZE9ubHkgaXMgYXZhaWxhYmxlIHVzZSBpdCBhcyBhIHByb3RvdHlwZSBmb3IgdGhlIHJlY3RhbmdsZS5cclxuICAgICAgICB2YXIgQ29uc3RyID0gdHlwZW9mIERPTVJlY3RSZWFkT25seSAhPT0gJ3VuZGVmaW5lZCcgPyBET01SZWN0UmVhZE9ubHkgOiBPYmplY3Q7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBPYmplY3QuY3JlYXRlKENvbnN0ci5wcm90b3R5cGUpO1xyXG4gICAgICAgIC8vIFJlY3RhbmdsZSdzIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUuXHJcbiAgICAgICAgZGVmaW5lQ29uZmlndXJhYmxlKHJlY3QsIHtcclxuICAgICAgICAgICAgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgdG9wOiB5LFxyXG4gICAgICAgICAgICByaWdodDogeCArIHdpZHRoLFxyXG4gICAgICAgICAgICBib3R0b206IGhlaWdodCArIHksXHJcbiAgICAgICAgICAgIGxlZnQ6IHhcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVjdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBET01SZWN0SW5pdCBvYmplY3QgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGRpbWVuc2lvbnMgYW5kIHRoZSB4L3kgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZGljdGRlZi1kb21yZWN0aW5pdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBSZWN0YW5nbGUncyB3aWR0aC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBSZWN0YW5nbGUncyBoZWlnaHQuXHJcbiAgICAgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3RJbml0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIENsYXNzIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGF0aW9ucyBvZiB0aGUgY29udGVudCByZWN0YW5nbGUgb2ZcclxuICAgICAqIHByb3ZpZGVkIERPTSBlbGVtZW50IGFuZCBmb3Iga2VlcGluZyB0cmFjayBvZiBpdCdzIGNoYW5nZXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBSZXNpemVPYnNlcnZhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnJvYWRjYXN0ZWQgd2lkdGggb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJyb2FkY2FzdGVkIGhlaWdodCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHByaXZhdGUge0RPTVJlY3RJbml0fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgY29udGVudCByZWN0YW5nbGUgYW5kIHRlbGxzIHdoZXRoZXIgaXQncyB3aWR0aCBvciBoZWlnaHQgcHJvcGVydGllc1xyXG4gICAgICAgICAqIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBicm9hZGNhc3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gZ2V0Q29udGVudFJlY3QodGhpcy50YXJnZXQpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRSZWN0XyA9IHJlY3Q7XHJcbiAgICAgICAgICAgIHJldHVybiAocmVjdC53aWR0aCAhPT0gdGhpcy5icm9hZGNhc3RXaWR0aCB8fFxyXG4gICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgIT09IHRoaXMuYnJvYWRjYXN0SGVpZ2h0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgJ2Jyb2FkY2FzdFdpZHRoJyBhbmQgJ2Jyb2FkY2FzdEhlaWdodCcgcHJvcGVydGllcyB3aXRoIGEgZGF0YVxyXG4gICAgICAgICAqIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllcyBvZiB0aGUgbGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH0gTGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuYnJvYWRjYXN0UmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRlbnRSZWN0XztcclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFJlc2l6ZU9ic2VydmF0aW9uO1xyXG4gICAgfSgpKTtcblxuICAgIHZhciBSZXNpemVPYnNlcnZlckVudHJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0aGF0IGlzIGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gRGF0YSBvZiB0aGUgZWxlbWVudCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRW50cnkodGFyZ2V0LCByZWN0SW5pdCkge1xyXG4gICAgICAgICAgICB2YXIgY29udGVudFJlY3QgPSBjcmVhdGVSZWFkT25seVJlY3QocmVjdEluaXQpO1xyXG4gICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmljYXRpb24gZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZVxyXG4gICAgICAgICAgICAvLyBhbmQgYXJlIGFsc28gbm90IGVudW1lcmFibGUgaW4gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gUHJvcGVydHkgYWNjZXNzb3JzIGFyZSBub3QgYmVpbmcgdXNlZCBhcyB0aGV5J2QgcmVxdWlyZSB0byBkZWZpbmUgYVxyXG4gICAgICAgICAgICAvLyBwcml2YXRlIFdlYWtNYXAgc3RvcmFnZSB3aGljaCBtYXkgY2F1c2UgbWVtb3J5IGxlYWtzIGluIGJyb3dzZXJzIHRoYXRcclxuICAgICAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCB0aGlzIHR5cGUgb2YgY29sbGVjdGlvbnMuXHJcbiAgICAgICAgICAgIGRlZmluZUNvbmZpZ3VyYWJsZSh0aGlzLCB7IHRhcmdldDogdGFyZ2V0LCBjb250ZW50UmVjdDogY29udGVudFJlY3QgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xyXG4gICAgfSgpKTtcblxuICAgIHZhciBSZXNpemVPYnNlcnZlclNQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZFxyXG4gICAgICAgICAqICAgICAgd2hlbiBvbmUgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZXMgaXQncyBjb250ZW50IGRpbWVuc2lvbnMuXHJcbiAgICAgICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBDb250cm9sbGVyIGluc3RhbmNlIHdoaWNoXHJcbiAgICAgICAgICogICAgICBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHVwZGF0ZXMgb2Ygb2JzZXJ2ZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlcn0gY2FsbGJhY2tDdHggLSBSZWZlcmVuY2UgdG8gdGhlIHB1YmxpY1xyXG4gICAgICAgICAqICAgICAgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2Ugd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIGNhbGxiYWNrQ3R4KSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIHJlc2l6ZSBvYnNlcnZhdGlvbnMgdGhhdCBoYXZlIGRldGVjdGVkIGNoYW5nZXMgaW4gZGltZW5zaW9uc1xyXG4gICAgICAgICAgICAgKiBvZiBlbGVtZW50cy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVnaXN0cnkgb2YgdGhlIFJlc2l6ZU9ic2VydmF0aW9uIGluc3RhbmNlcy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHByaXZhdGUge01hcDxFbGVtZW50LCBSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18gPSBuZXcgTWFwU2hpbSgpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2FsbGJhY2sgcHJvdmlkZWQgYXMgcGFyYW1ldGVyIDEgaXMgbm90IGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyXyA9IGNvbnRyb2xsZXI7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tDdHhfID0gY2FsbGJhY2tDdHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0YXJ0cyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAgICBpZiAob2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JzZXJ2YXRpb25zLnNldCh0YXJnZXQsIG5ldyBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpKTtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyXy5hZGRPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICAgICAgLy8gRm9yY2UgdGhlIHVwZGF0ZSBvZiBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVmcmVzaCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gc3RvcCBvYnNlcnZpbmcuXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlIFwiRWxlbWVudFwiLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgZWxlbWVudCBpcyBub3QgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICAgIGlmICghb2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JzZXJ2YXRpb25zLmRlbGV0ZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdG9wcyBvYnNlcnZpbmcgYWxsIGVsZW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsZWN0cyBvYnNlcnZhdGlvbiBpbnN0YW5jZXMgdGhlIGFzc29jaWF0ZWQgZWxlbWVudCBvZiB3aGljaCBoYXMgY2hhbmdlZFxyXG4gICAgICAgICAqIGl0J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZ2F0aGVyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmF0aW9uLmlzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnB1c2gob2JzZXJ2YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludm9rZXMgaW5pdGlhbCBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGEgbGlzdCBvZiBSZXNpemVPYnNlcnZlckVudHJ5XHJcbiAgICAgICAgICogaW5zdGFuY2VzIGNvbGxlY3RlZCBmcm9tIGFjdGl2ZSByZXNpemUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmJyb2FkY2FzdEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBvYnNlcnZlciBkb2Vzbid0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY2FsbGJhY2tDdHhfO1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgUmVzaXplT2JzZXJ2ZXJFbnRyeSBpbnN0YW5jZSBmb3IgZXZlcnkgYWN0aXZlIG9ic2VydmF0aW9uLlxyXG4gICAgICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5tYXAoZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyRW50cnkob2JzZXJ2YXRpb24udGFyZ2V0LCBvYnNlcnZhdGlvbi5icm9hZGNhc3RSZWN0KCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFja18uY2FsbChjdHgsIGVudHJpZXMsIGN0eCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFycyB0aGUgY29sbGVjdGlvbiBvZiBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmNsZWFyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18uc3BsaWNlKDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVsbHMgd2hldGhlciBvYnNlcnZlciBoYXMgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5oYXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubGVuZ3RoID4gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSZXNpemVPYnNlcnZlclNQSTtcclxuICAgIH0oKSk7XG5cbiAgICAvLyBSZWdpc3RyeSBvZiBpbnRlcm5hbCBvYnNlcnZlcnMuIElmIFdlYWtNYXAgaXMgbm90IGF2YWlsYWJsZSB1c2UgY3VycmVudCBzaGltXHJcbiAgICAvLyBmb3IgdGhlIE1hcCBjb2xsZWN0aW9uIGFzIGl0IGhhcyBhbGwgcmVxdWlyZWQgbWV0aG9kcyBhbmQgYmVjYXVzZSBXZWFrTWFwXHJcbiAgICAvLyBjYW4ndCBiZSBmdWxseSBwb2x5ZmlsbGVkIGFueXdheS5cclxuICAgIHZhciBvYnNlcnZlcnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcFNoaW0oKTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplT2JzZXJ2ZXIgQVBJLiBFbmNhcHN1bGF0ZXMgdGhlIFJlc2l6ZU9ic2VydmVyIFNQSSBpbXBsZW1lbnRhdGlvblxyXG4gICAgICogZXhwb3Npbmcgb25seSB0aG9zZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGRlZmluZWQgaW4gdGhlIHNwZWMuXHJcbiAgICAgKi9cclxuICAgIHZhciBSZXNpemVPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuXHJcbiAgICAgICAgICogICAgICBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc2l6ZU9ic2VydmVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sbGVyID0gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgdGhpcyk7XHJcbiAgICAgICAgICAgIG9ic2VydmVycy5zZXQodGhpcywgb2JzZXJ2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XHJcbiAgICB9KCkpO1xyXG4gICAgLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzIG9mIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAgW1xyXG4gICAgICAgICdvYnNlcnZlJyxcclxuICAgICAgICAndW5vYnNlcnZlJyxcclxuICAgICAgICAnZGlzY29ubmVjdCdcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXIucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IG9ic2VydmVycy5nZXQodGhpcykpW21ldGhvZF0uYXBwbHkoX2EsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xuXG4gICAgdmFyIGluZGV4ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBFeHBvcnQgZXhpc3RpbmcgaW1wbGVtZW50YXRpb24gaWYgYXZhaWxhYmxlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG4gICAgfSkoKTtcblxuICAgIHJldHVybiBpbmRleDtcblxufSkpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2lzUmVhY3ROYXRpdmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzUmVhY3ROYXRpdmVcIikpO1xuXG52YXIgX3VyaVRvQmxvYiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXJpVG9CbG9iXCIpKTtcblxudmFyIF9pc0NvcmRvdmEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzQ29yZG92YVwiKSk7XG5cbnZhciBfcmVhZEFzQnl0ZUFycmF5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZWFkQXNCeXRlQXJyYXlcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbnZhciBGaWxlU291cmNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gTWFrZSB0aGlzLnNpemUgYSBtZXRob2RcbiAgZnVuY3Rpb24gRmlsZVNvdXJjZShmaWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbGVTb3VyY2UpO1xuXG4gICAgdGhpcy5fZmlsZSA9IGZpbGU7XG4gICAgdGhpcy5zaXplID0gZmlsZS5zaXplO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZpbGVTb3VyY2UsIFt7XG4gICAga2V5OiBcInNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8vIEluIEFwYWNoZSBDb3Jkb3ZhIGFwcGxpY2F0aW9ucywgYSBGaWxlIG11c3QgYmUgcmVzb2x2ZWQgdXNpbmdcbiAgICAgIC8vIEZpbGVSZWFkZXIgaW5zdGFuY2VzLCBzZWVcbiAgICAgIC8vIGh0dHBzOi8vY29yZG92YS5hcGFjaGUub3JnL2RvY3MvZW4vOC54L3JlZmVyZW5jZS9jb3Jkb3ZhLXBsdWdpbi1maWxlL2luZGV4Lmh0bWwjcmVhZC1hLWZpbGVcbiAgICAgIGlmICgoMCwgX2lzQ29yZG92YS5kZWZhdWx0KSgpKSB7XG4gICAgICAgIHJldHVybiAoMCwgX3JlYWRBc0J5dGVBcnJheS5kZWZhdWx0KSh0aGlzLl9maWxlLnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZmlsZS5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkgey8vIE5vdGhpbmcgdG8gZG8gaGVyZSBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIHJlbGVhc2UgYW55IHJlc291cmNlcy5cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsZVNvdXJjZTtcbn0oKTtcblxudmFyIFN0cmVhbVNvdXJjZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0cmVhbVNvdXJjZShyZWFkZXIsIGNodW5rU2l6ZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJlYW1Tb3VyY2UpO1xuXG4gICAgdGhpcy5fY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgIHRoaXMuX2J1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9idWZmZXJPZmZzZXQgPSAwO1xuICAgIHRoaXMuX3JlYWRlciA9IHJlYWRlcjtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3RyZWFtU291cmNlLCBbe1xuICAgIGtleTogXCJzbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoc3RhcnQgPCB0aGlzLl9idWZmZXJPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlJlcXVlc3RlZCBkYXRhIGlzIGJlZm9yZSB0aGUgcmVhZGVyJ3MgY3VycmVudCBvZmZzZXRcIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmVhZFVudGlsRW5vdWdoRGF0YU9yRG9uZShzdGFydCwgZW5kKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlYWRVbnRpbEVub3VnaERhdGFPckRvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlYWRVbnRpbEVub3VnaERhdGFPckRvbmUoc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGhhc0Vub3VnaERhdGEgPSBlbmQgPD0gdGhpcy5fYnVmZmVyT2Zmc2V0ICsgbGVuKHRoaXMuX2J1ZmZlcik7XG5cbiAgICAgIGlmICh0aGlzLl9kb25lIHx8IGhhc0Vub3VnaERhdGEpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0RGF0YUZyb21CdWZmZXIoc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgdmFyIGRvbmUgPSB2YWx1ZSA9PSBudWxsID8gdGhpcy5fZG9uZSA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgZG9uZTogZG9uZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlLFxuICAgICAgICAgICAgZG9uZSA9IF9yZWYuZG9uZTtcblxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIF90aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGhpcy5fYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpcy5fYnVmZmVyID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuX2J1ZmZlciA9IGNvbmNhdChfdGhpcy5fYnVmZmVyLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMuX3JlYWRVbnRpbEVub3VnaERhdGFPckRvbmUoc3RhcnQsIGVuZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERhdGFGcm9tQnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREYXRhRnJvbUJ1ZmZlcihzdGFydCwgZW5kKSB7XG4gICAgICAvLyBSZW1vdmUgZGF0YSBmcm9tIGJ1ZmZlciBiZWZvcmUgYHN0YXJ0YC5cbiAgICAgIC8vIERhdGEgbWlnaHQgYmUgcmVyZWFkIGZyb20gdGhlIGJ1ZmZlciBpZiBhbiB1cGxvYWQgZmFpbHMsIHNvIHdlIGNhbiBvbmx5XG4gICAgICAvLyBzYWZlbHkgZGVsZXRlIGRhdGEgd2hlbiBpdCBjb21lcyAqYmVmb3JlKiB3aGF0IGlzIGN1cnJlbnRseSBiZWluZyByZWFkLlxuICAgICAgaWYgKHN0YXJ0ID4gdGhpcy5fYnVmZmVyT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IHRoaXMuX2J1ZmZlci5zbGljZShzdGFydCAtIHRoaXMuX2J1ZmZlck9mZnNldCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlck9mZnNldCA9IHN0YXJ0O1xuICAgICAgfSAvLyBJZiB0aGUgYnVmZmVyIGlzIGVtcHR5IGFmdGVyIHJlbW92aW5nIG9sZCBkYXRhLCBhbGwgZGF0YSBoYXMgYmVlbiByZWFkLlxuXG5cbiAgICAgIHZhciBoYXNBbGxEYXRhQmVlblJlYWQgPSBsZW4odGhpcy5fYnVmZmVyKSA9PT0gMDtcblxuICAgICAgaWYgKHRoaXMuX2RvbmUgJiYgaGFzQWxsRGF0YUJlZW5SZWFkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBXZSBhbHJlYWR5IHJlbW92ZWQgZGF0YSBiZWZvcmUgYHN0YXJ0YCwgc28gd2UganVzdCByZXR1cm4gdGhlIGZpcnN0XG4gICAgICAvLyBjaHVuayBmcm9tIHRoZSBidWZmZXIuXG5cblxuICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5zbGljZSgwLCBlbmQgLSBzdGFydCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKHRoaXMuX3JlYWRlci5jYW5jZWwpIHtcbiAgICAgICAgdGhpcy5fcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHJlYW1Tb3VyY2U7XG59KCk7XG5cbmZ1bmN0aW9uIGxlbihibG9iT3JBcnJheSkge1xuICBpZiAoYmxvYk9yQXJyYXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIGlmIChibG9iT3JBcnJheS5zaXplICE9PSB1bmRlZmluZWQpIHJldHVybiBibG9iT3JBcnJheS5zaXplO1xuICByZXR1cm4gYmxvYk9yQXJyYXkubGVuZ3RoO1xufVxuLypcbiAgVHlwZWQgYXJyYXlzIGFuZCBibG9icyBkb24ndCBoYXZlIGEgY29uY2F0IG1ldGhvZC5cbiAgVGhpcyBmdW5jdGlvbiBoZWxwcyBTdHJlYW1Tb3VyY2UgYWNjdW11bGF0ZSBkYXRhIHRvIHJlYWNoIGNodW5rU2l6ZS5cbiovXG5cblxuZnVuY3Rpb24gY29uY2F0KGEsIGIpIHtcbiAgaWYgKGEuY29uY2F0KSB7XG4gICAgLy8gSXMgYGFgIGFuIEFycmF5P1xuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgfVxuXG4gIGlmIChhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiBuZXcgQmxvYihbYSwgYl0sIHtcbiAgICAgIHR5cGU6IGEudHlwZVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGEuc2V0KSB7XG4gICAgLy8gSXMgYGFgIGEgdHlwZWQgYXJyYXk/XG4gICAgdmFyIGMgPSBuZXcgYS5jb25zdHJ1Y3RvcihhLmxlbmd0aCArIGIubGVuZ3RoKTtcbiAgICBjLnNldChhKTtcbiAgICBjLnNldChiLCBhLmxlbmd0aCk7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZVwiKTtcbn1cblxudmFyIEZpbGVSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGaWxlUmVhZGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWxlUmVhZGVyKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGaWxlUmVhZGVyLCBbe1xuICAgIGtleTogXCJvcGVuRmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuRmlsZShpbnB1dCwgY2h1bmtTaXplKSB7XG4gICAgICAvLyBJbiBSZWFjdCBOYXRpdmUsIHdoZW4gdXNlciBzZWxlY3RzIGEgZmlsZSwgaW5zdGVhZCBvZiBhIEZpbGUgb3IgQmxvYixcbiAgICAgIC8vIHlvdSB1c3VhbGx5IGdldCBhIGZpbGUgb2JqZWN0IHt9IHdpdGggYSB1cmkgcHJvcGVydHkgdGhhdCBjb250YWluc1xuICAgICAgLy8gYSBsb2NhbCBwYXRoIHRvIHRoZSBmaWxlLiBXZSB1c2UgWE1MSHR0cFJlcXVlc3QgdG8gZmV0Y2hcbiAgICAgIC8vIHRoZSBmaWxlIGJsb2IsIGJlZm9yZSB1cGxvYWRpbmcgd2l0aCB0dXMuXG4gICAgICBpZiAoKDAsIF9pc1JlYWN0TmF0aXZlLmRlZmF1bHQpKCkgJiYgaW5wdXQgJiYgdHlwZW9mIGlucHV0LnVyaSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gKDAsIF91cmlUb0Jsb2IuZGVmYXVsdCkoaW5wdXQudXJpKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBGaWxlU291cmNlKGJsb2IpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCBmZXRjaCBgZmlsZS51cmlgIGFzIEJsb2IsIG1ha2Ugc3VyZSB0aGUgdXJpIGlzIGNvcnJlY3QgYW5kIGFjY2Vzc2libGUuIFwiICsgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFNpbmNlIHdlIGVtdWxhdGUgdGhlIEJsb2IgdHlwZSBpbiBvdXIgdGVzdHMgKG5vdCBhbGwgdGFyZ2V0IGJyb3dzZXJzXG4gICAgICAvLyBzdXBwb3J0IGl0KSwgd2UgY2Fubm90IHVzZSBgaW5zdGFuY2VvZmAgZm9yIHRlc3Rpbmcgd2hldGhlciB0aGUgaW5wdXQgdmFsdWVcbiAgICAgIC8vIGNhbiBiZSBoYW5kbGVkLiBJbnN0ZWFkLCB3ZSBzaW1wbHkgY2hlY2sgaXMgdGhlIHNsaWNlKCkgZnVuY3Rpb24gYW5kIHRoZVxuICAgICAgLy8gc2l6ZSBwcm9wZXJ0eSBhcmUgYXZhaWxhYmxlLlxuXG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQuc2xpY2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgaW5wdXQuc2l6ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBGaWxlU291cmNlKGlucHV0KSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQucmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNodW5rU2l6ZSA9ICtjaHVua1NpemU7XG5cbiAgICAgICAgaWYgKCFpc0Zpbml0ZShjaHVua1NpemUpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImNhbm5vdCBjcmVhdGUgc291cmNlIGZvciBzdHJlYW0gd2l0aG91dCBhIGZpbml0ZSB2YWx1ZSBmb3IgdGhlIGBjaHVua1NpemVgIG9wdGlvblwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBTdHJlYW1Tb3VyY2UoaW5wdXQsIGNodW5rU2l6ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwic291cmNlIG9iamVjdCBtYXkgb25seSBiZSBhbiBpbnN0YW5jZSBvZiBGaWxlLCBCbG9iLCBvciBSZWFkZXIgaW4gdGhpcyBlbnZpcm9ubWVudFwiKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpbGVSZWFkZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEZpbGVSZWFkZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmaW5nZXJwcmludDtcblxudmFyIF9pc1JlYWN0TmF0aXZlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc1JlYWN0TmF0aXZlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gVE9ETzogRGlmZmVyZW5jaWF0ZSBiZXR3ZWVuIGlucHV0IHR5cGVzXG5cbi8qKlxuICogR2VuZXJhdGUgYSBmaW5nZXJwcmludCBmb3IgYSBmaWxlIHdoaWNoIHdpbGwgYmUgdXNlZCB0aGUgc3RvcmUgdGhlIGVuZHBvaW50XG4gKlxuICogQHBhcmFtIHtGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZmluZ2VycHJpbnQoZmlsZSwgb3B0aW9ucykge1xuICBpZiAoKDAsIF9pc1JlYWN0TmF0aXZlLmRlZmF1bHQpKCkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWN0TmF0aXZlRmluZ2VycHJpbnQoZmlsZSwgb3B0aW9ucykpO1xuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXCJ0dXMtYnJcIiwgZmlsZS5uYW1lLCBmaWxlLnR5cGUsIGZpbGUuc2l6ZSwgZmlsZS5sYXN0TW9kaWZpZWQsIG9wdGlvbnMuZW5kcG9pbnRdLmpvaW4oXCItXCIpKTtcbn1cblxuZnVuY3Rpb24gcmVhY3ROYXRpdmVGaW5nZXJwcmludChmaWxlLCBvcHRpb25zKSB7XG4gIHZhciBleGlmSGFzaCA9IGZpbGUuZXhpZiA/IGhhc2hDb2RlKEpTT04uc3RyaW5naWZ5KGZpbGUuZXhpZikpIDogXCJub2V4aWZcIjtcbiAgcmV0dXJuIFtcInR1cy1yblwiLCBmaWxlLm5hbWUgfHwgXCJub25hbWVcIiwgZmlsZS5zaXplIHx8IFwibm9zaXplXCIsIGV4aWZIYXNoLCBvcHRpb25zLmVuZHBvaW50XS5qb2luKFwiL1wiKTtcbn1cblxuZnVuY3Rpb24gaGFzaENvZGUoc3RyKSB7XG4gIC8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg4MzE5MzcvMTUxNjY2XG4gIHZhciBoYXNoID0gMDtcblxuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBoYXNoO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2NoYXIgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBfY2hhcjtcbiAgICBoYXNoID0gaGFzaCAmIGhhc2g7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGhhc2g7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG52YXIgWEhSSHR0cFN0YWNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEhSSHR0cFN0YWNrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBYSFJIdHRwU3RhY2spO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFhIUkh0dHBTdGFjaywgW3tcbiAgICBrZXk6IFwiY3JlYXRlUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgICByZXR1cm4gbmV3IFJlcXVlc3QobWV0aG9kLCB1cmwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXROYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWUoKSB7XG4gICAgICByZXR1cm4gXCJYSFJIdHRwU3RhY2tcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gWEhSSHR0cFN0YWNrO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBYSFJIdHRwU3RhY2s7XG5cbnZhciBSZXF1ZXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXF1ZXN0KTtcblxuICAgIHRoaXMuX3hociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgdGhpcy5feGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kO1xuICAgIHRoaXMuX3VybCA9IHVybDtcbiAgICB0aGlzLl9oZWFkZXJzID0ge307XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVxdWVzdCwgW3tcbiAgICBrZXk6IFwiZ2V0TWV0aG9kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1ldGhvZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tZXRob2Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVSTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVUkwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXJsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SGVhZGVyKGhlYWRlciwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX3hoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xuXG4gICAgICB0aGlzLl9oZWFkZXJzW2hlYWRlcl0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SGVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlYWRlcihoZWFkZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzW2hlYWRlcl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFByb2dyZXNzSGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcm9ncmVzc0hhbmRsZXIocHJvZ3Jlc3NIYW5kbGVyKSB7XG4gICAgICAvLyBUZXN0IHN1cHBvcnQgZm9yIHByb2dyZXNzIGV2ZW50cyBiZWZvcmUgYXR0YWNoaW5nIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICBpZiAoIShcInVwbG9hZFwiIGluIHRoaXMuX3hocikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl94aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIWUubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2dyZXNzSGFuZGxlcihlLmxvYWRlZCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgYm9keSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzLl94aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKF90aGlzLl94aHIpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5feGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuX3hoci5zZW5kKGJvZHkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFib3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgdGhpcy5feGhyLmFib3J0KCk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VW5kZXJseWluZ09iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVbmRlcmx5aW5nT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hocjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVxdWVzdDtcbn0oKTtcblxudmFyIFJlc3BvbnNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVzcG9uc2UoeGhyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc3BvbnNlKTtcblxuICAgIHRoaXMuX3hociA9IHhocjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXNwb25zZSwgW3tcbiAgICBrZXk6IFwiZ2V0U3RhdHVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHIuc3RhdHVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZGVyKGhlYWRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX3hoci5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb2R5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VW5kZXJseWluZ09iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVbmRlcmx5aW5nT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hocjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVzcG9uc2U7XG59KCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmFibGVEZWJ1Z0xvZ1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfbG9nZ2VyLmVuYWJsZURlYnVnTG9nO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNhblN0b3JlVVJMc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXJsU3RvcmFnZS5jYW5TdG9yZVVSTHM7XG4gIH1cbn0pO1xuZXhwb3J0cy5pc1N1cHBvcnRlZCA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLlVwbG9hZCA9IHZvaWQgMDtcblxudmFyIF91cGxvYWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91cGxvYWRcIikpO1xuXG52YXIgX25vb3BVcmxTdG9yYWdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbm9vcFVybFN0b3JhZ2VcIikpO1xuXG52YXIgX2xvZ2dlciA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XG5cbnZhciBfdXJsU3RvcmFnZSA9IHJlcXVpcmUoXCIuL3VybFN0b3JhZ2VcIik7XG5cbnZhciBfaHR0cFN0YWNrID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9odHRwU3RhY2tcIikpO1xuXG52YXIgX2ZpbGVSZWFkZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ZpbGVSZWFkZXJcIikpO1xuXG52YXIgX2ZpbmdlcnByaW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9maW5nZXJwcmludFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cbi8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCBfdXBsb2FkLmRlZmF1bHQuZGVmYXVsdE9wdGlvbnMsIHtcbiAgaHR0cFN0YWNrOiBuZXcgX2h0dHBTdGFjay5kZWZhdWx0KCksXG4gIGZpbGVSZWFkZXI6IG5ldyBfZmlsZVJlYWRlci5kZWZhdWx0KCksXG4gIHVybFN0b3JhZ2U6IF91cmxTdG9yYWdlLmNhblN0b3JlVVJMcyA/IG5ldyBfdXJsU3RvcmFnZS5XZWJTdG9yYWdlVXJsU3RvcmFnZSgpIDogbmV3IF9ub29wVXJsU3RvcmFnZS5kZWZhdWx0KCksXG4gIGZpbmdlcnByaW50OiBfZmluZ2VycHJpbnQuZGVmYXVsdFxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcblxudmFyIFVwbG9hZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VVcGxvYWQpIHtcbiAgX2luaGVyaXRzKFVwbG9hZCwgX0Jhc2VVcGxvYWQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVXBsb2FkKTtcblxuICBmdW5jdGlvbiBVcGxvYWQoKSB7XG4gICAgdmFyIGZpbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFVwbG9hZCk7XG5cbiAgICBvcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMsIHt9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZmlsZSwgb3B0aW9ucyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVXBsb2FkLCBudWxsLCBbe1xuICAgIGtleTogXCJ0ZXJtaW5hdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVybWluYXRlKHVybCwgb3B0aW9ucywgY2IpIHtcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucywge30sIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIF91cGxvYWQuZGVmYXVsdC50ZXJtaW5hdGUodXJsLCBvcHRpb25zLCBjYik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFVwbG9hZDtcbn0oX3VwbG9hZC5kZWZhdWx0KTtcblxuZXhwb3J0cy5VcGxvYWQgPSBVcGxvYWQ7XG52YXIgX3dpbmRvdyA9IHdpbmRvdyxcbiAgICBYTUxIdHRwUmVxdWVzdCA9IF93aW5kb3cuWE1MSHR0cFJlcXVlc3QsXG4gICAgQmxvYiA9IF93aW5kb3cuQmxvYjtcbnZhciBpc1N1cHBvcnRlZCA9IFhNTEh0dHBSZXF1ZXN0ICYmIEJsb2IgJiYgdHlwZW9mIEJsb2IucHJvdG90eXBlLnNsaWNlID09PSBcImZ1bmN0aW9uXCI7XG5leHBvcnRzLmlzU3VwcG9ydGVkID0gaXNTdXBwb3J0ZWQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBpc0NvcmRvdmEgPSBmdW5jdGlvbiBpc0NvcmRvdmEoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgJiYgKHR5cGVvZiB3aW5kb3cuUGhvbmVHYXAgIT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygd2luZG93LkNvcmRvdmEgIT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygd2luZG93LmNvcmRvdmEgIT0gXCJ1bmRlZmluZWRcIik7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBpc0NvcmRvdmE7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIGlzUmVhY3ROYXRpdmUgPSBmdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwic3RyaW5nXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSA9PT0gXCJyZWFjdG5hdGl2ZVwiO1xufTtcblxudmFyIF9kZWZhdWx0ID0gaXNSZWFjdE5hdGl2ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVhZEFzQnl0ZUFycmF5O1xuXG4vKipcbiAqIHJlYWRBc0J5dGVBcnJheSBjb252ZXJ0cyBhIEZpbGUgb2JqZWN0IHRvIGEgVWludDhBcnJheS5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIG9uIHRoZSBBcGFjaGUgQ29yZG92YSBwbGF0Zm9ybS5cbiAqIFNlZSBodHRwczovL2NvcmRvdmEuYXBhY2hlLm9yZy9kb2NzL2VuL2xhdGVzdC9yZWZlcmVuY2UvY29yZG92YS1wbHVnaW4tZmlsZS9pbmRleC5odG1sI3JlYWQtYS1maWxlXG4gKi9cbmZ1bmN0aW9uIHJlYWRBc0J5dGVBcnJheShjaHVuaykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHJlYWRlci5yZXN1bHQpO1xuICAgICAgcmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfTtcblxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihjaHVuayk7XG4gIH0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdXJpVG9CbG9iO1xuXG4vKipcbiAqIHVyaVRvQmxvYiByZXNvbHZlcyBhIFVSSSB0byBhIEJsb2Igb2JqZWN0LiBUaGlzIGlzIHVzZWQgZm9yXG4gKiBSZWFjdCBOYXRpdmUgdG8gcmV0cmlldmUgYSBmaWxlIChpZGVudGlmaWVkIGJ5IGEgZmlsZTovL1xuICogVVJJKSBhcyBhIGJsb2IuXG4gKi9cbmZ1bmN0aW9uIHVyaVRvQmxvYih1cmkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYmxvYlwiO1xuXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBibG9iID0geGhyLnJlc3BvbnNlO1xuICAgICAgcmVzb2x2ZShibG9iKTtcbiAgICB9O1xuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9O1xuXG4gICAgeGhyLm9wZW4oXCJHRVRcIiwgdXJpKTtcbiAgICB4aHIuc2VuZCgpO1xuICB9KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuV2ViU3RvcmFnZVVybFN0b3JhZ2UgPSBleHBvcnRzLmNhblN0b3JlVVJMcyA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuLyogZ2xvYmFsIHdpbmRvdywgbG9jYWxTdG9yYWdlICovXG5cblxudmFyIGhhc1N0b3JhZ2UgPSBmYWxzZTtcblxudHJ5IHtcbiAgaGFzU3RvcmFnZSA9IFwibG9jYWxTdG9yYWdlXCIgaW4gd2luZG93OyAvLyBBdHRlbXB0IHRvIHN0b3JlIGFuZCByZWFkIGVudHJpZXMgZnJvbSB0aGUgbG9jYWwgc3RvcmFnZSB0byBkZXRlY3QgUHJpdmF0ZVxuICAvLyBNb2RlIG9uIFNhZmFyaSBvbiBpT1MgKHNlZSAjNDkpXG5cbiAgdmFyIGtleSA9IFwidHVzU3VwcG9ydFwiO1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSkpO1xufSBjYXRjaCAoZSkge1xuICAvLyBJZiB3ZSB0cnkgdG8gYWNjZXNzIGxvY2FsU3RvcmFnZSBpbnNpZGUgYSBzYW5kYm94ZWQgaWZyYW1lLCBhIFNlY3VyaXR5RXJyb3JcbiAgLy8gaXMgdGhyb3duLiBXaGVuIGluIHByaXZhdGUgbW9kZSBvbiBpT1MgU2FmYXJpLCBhIFF1b3RhRXhjZWVkZWRFcnJvciBpc1xuICAvLyB0aHJvd24gKHNlZSAjNDkpXG4gIGlmIChlLmNvZGUgPT09IGUuU0VDVVJJVFlfRVJSIHx8IGUuY29kZSA9PT0gZS5RVU9UQV9FWENFRURFRF9FUlIpIHtcbiAgICBoYXNTdG9yYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG52YXIgY2FuU3RvcmVVUkxzID0gaGFzU3RvcmFnZTtcbmV4cG9ydHMuY2FuU3RvcmVVUkxzID0gY2FuU3RvcmVVUkxzO1xuXG52YXIgV2ViU3RvcmFnZVVybFN0b3JhZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXZWJTdG9yYWdlVXJsU3RvcmFnZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViU3RvcmFnZVVybFN0b3JhZ2UpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFdlYlN0b3JhZ2VVcmxTdG9yYWdlLCBbe1xuICAgIGtleTogXCJmaW5kQWxsVXBsb2Fkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQWxsVXBsb2FkcygpIHtcbiAgICAgIHZhciByZXN1bHRzID0gdGhpcy5fZmluZEVudHJpZXMoXCJ0dXM6OlwiKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZFVwbG9hZHNCeUZpbmdlcnByaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRVcGxvYWRzQnlGaW5nZXJwcmludChmaW5nZXJwcmludCkge1xuICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLl9maW5kRW50cmllcyhcInR1czo6XCIuY29uY2F0KGZpbmdlcnByaW50LCBcIjo6XCIpKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVVwbG9hZCh1cmxTdG9yYWdlS2V5KSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh1cmxTdG9yYWdlS2V5KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFVwbG9hZChmaW5nZXJwcmludCwgdXBsb2FkKSB7XG4gICAgICB2YXIgaWQgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxZTEyKTtcbiAgICAgIHZhciBrZXkgPSBcInR1czo6XCIuY29uY2F0KGZpbmdlcnByaW50LCBcIjo6XCIpLmNvbmNhdChpZCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHVwbG9hZCkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEVudHJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRFbnRyaWVzKHByZWZpeCkge1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9rZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuXG4gICAgICAgIGlmIChfa2V5LmluZGV4T2YocHJlZml4KSAhPT0gMCkgY29udGludWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgdXBsb2FkID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShfa2V5KSk7XG4gICAgICAgICAgdXBsb2FkLnVybFN0b3JhZ2VLZXkgPSBfa2V5O1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh1cGxvYWQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7Ly8gVGhlIEpTT04gcGFyc2UgZXJyb3IgaXMgaW50ZW50aW9uYWxseSBpZ25vcmVkIGhlcmUsIHNvIGEgbWFsZm9ybWVkXG4gICAgICAgICAgLy8gZW50cnkgaW4gdGhlIHN0b3JhZ2UgY2Fubm90IHByZXZlbnQgYW4gdXBsb2FkLlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXZWJTdG9yYWdlVXJsU3RvcmFnZTtcbn0oKTtcblxuZXhwb3J0cy5XZWJTdG9yYWdlVXJsU3RvcmFnZSA9IFdlYlN0b3JhZ2VVcmxTdG9yYWdlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH07XG5cbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgfSBlbHNlIHtcbiAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxudmFyIERldGFpbGVkRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoRGV0YWlsZWRFcnJvciwgX0Vycm9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERldGFpbGVkRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIERldGFpbGVkRXJyb3IobWVzc2FnZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBjYXVzaW5nRXJyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIHZhciByZXEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZXRhaWxlZEVycm9yKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgX3RoaXMub3JpZ2luYWxSZXF1ZXN0ID0gcmVxO1xuICAgIF90aGlzLm9yaWdpbmFsUmVzcG9uc2UgPSByZXM7XG4gICAgX3RoaXMuY2F1c2luZ0Vycm9yID0gY2F1c2luZ0VycjtcblxuICAgIGlmIChjYXVzaW5nRXJyICE9IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UgKz0gXCIsIGNhdXNlZCBieSBcIi5jb25jYXQoY2F1c2luZ0Vyci50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICBpZiAocmVxICE9IG51bGwpIHtcbiAgICAgIHZhciByZXF1ZXN0SWQgPSByZXEuZ2V0SGVhZGVyKFwiWC1SZXF1ZXN0LUlEXCIpIHx8IFwibi9hXCI7XG4gICAgICB2YXIgbWV0aG9kID0gcmVxLmdldE1ldGhvZCgpO1xuICAgICAgdmFyIHVybCA9IHJlcS5nZXRVUkwoKTtcbiAgICAgIHZhciBzdGF0dXMgPSByZXMgPyByZXMuZ2V0U3RhdHVzKCkgOiBcIm4vYVwiO1xuICAgICAgdmFyIGJvZHkgPSByZXMgPyByZXMuZ2V0Qm9keSgpIHx8IFwiXCIgOiBcIm4vYVwiO1xuICAgICAgbWVzc2FnZSArPSBcIiwgb3JpZ2luYXRlZCBmcm9tIHJlcXVlc3QgKG1ldGhvZDogXCIuY29uY2F0KG1ldGhvZCwgXCIsIHVybDogXCIpLmNvbmNhdCh1cmwsIFwiLCByZXNwb25zZSBjb2RlOiBcIikuY29uY2F0KHN0YXR1cywgXCIsIHJlc3BvbnNlIHRleHQ6IFwiKS5jb25jYXQoYm9keSwgXCIsIHJlcXVlc3QgaWQ6IFwiKS5jb25jYXQocmVxdWVzdElkLCBcIilcIik7XG4gICAgfVxuXG4gICAgX3RoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIERldGFpbGVkRXJyb3I7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG52YXIgX2RlZmF1bHQgPSBEZXRhaWxlZEVycm9yO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmVuYWJsZURlYnVnTG9nID0gZW5hYmxlRGVidWdMb2c7XG5leHBvcnRzLmxvZyA9IGxvZztcblxuLyogZXNsaW50IG5vLWNvbnNvbGU6IFwib2ZmXCIgKi9cbnZhciBpc0VuYWJsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gZW5hYmxlRGVidWdMb2coKSB7XG4gIGlzRW5hYmxlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGxvZyhtc2cpIHtcbiAgaWYgKCFpc0VuYWJsZWQpIHJldHVybjtcbiAgY29uc29sZS5sb2cobXNnKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcIm9mZlwiICovXG5cblxudmFyIE5vb3BVcmxTdG9yYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9vcFVybFN0b3JhZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vb3BVcmxTdG9yYWdlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOb29wVXJsU3RvcmFnZSwgW3tcbiAgICBrZXk6IFwibGlzdEFsbFVwbG9hZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdEFsbFVwbG9hZHMoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZFVwbG9hZHNCeUZpbmdlcnByaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRVcGxvYWRzQnlGaW5nZXJwcmludChmaW5nZXJwcmludCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVVcGxvYWQodXJsU3RvcmFnZUtleSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVXBsb2FkKGZpbmdlcnByaW50LCB1cGxvYWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vb3BVcmxTdG9yYWdlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBOb29wVXJsU3RvcmFnZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9lcnJvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZXJyb3JcIikpO1xuXG52YXIgX3V1aWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V1aWRcIikpO1xuXG52YXIgX2pzQmFzZSA9IHJlcXVpcmUoXCJqcy1iYXNlNjRcIik7XG5cbnZhciBfdXJsUGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJ1cmwtcGFyc2VcIikpO1xuXG52YXIgX2xvZ2dlciA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZW5kcG9pbnQ6IG51bGwsXG4gIHVwbG9hZFVybDogbnVsbCxcbiAgbWV0YWRhdGE6IHt9LFxuICBmaW5nZXJwcmludDogbnVsbCxcbiAgdXBsb2FkU2l6ZTogbnVsbCxcbiAgb25Qcm9ncmVzczogbnVsbCxcbiAgb25DaHVua0NvbXBsZXRlOiBudWxsLFxuICBvblN1Y2Nlc3M6IG51bGwsXG4gIG9uRXJyb3I6IG51bGwsXG4gIF9vblVwbG9hZFVybEF2YWlsYWJsZTogbnVsbCxcbiAgb3ZlcnJpZGVQYXRjaE1ldGhvZDogZmFsc2UsXG4gIGhlYWRlcnM6IHt9LFxuICBhZGRSZXF1ZXN0SWQ6IGZhbHNlLFxuICBvbkJlZm9yZVJlcXVlc3Q6IG51bGwsXG4gIG9uQWZ0ZXJSZXNwb25zZTogbnVsbCxcbiAgY2h1bmtTaXplOiBJbmZpbml0eSxcbiAgcmV0cnlEZWxheXM6IFswLCAxMDAwLCAzMDAwLCA1MDAwXSxcbiAgcGFyYWxsZWxVcGxvYWRzOiAxLFxuICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IHRydWUsXG4gIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzOiBmYWxzZSxcbiAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IGZhbHNlLFxuICB1cGxvYWREYXRhRHVyaW5nQ3JlYXRpb246IGZhbHNlLFxuICB1cmxTdG9yYWdlOiBudWxsLFxuICBmaWxlUmVhZGVyOiBudWxsLFxuICBodHRwU3RhY2s6IG51bGxcbn07XG5cbnZhciBCYXNlVXBsb2FkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZVVwbG9hZChmaWxlLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VVcGxvYWQpOyAvLyBXYXJuIGFib3V0IHJlbW92ZWQgb3B0aW9ucyBmcm9tIHByZXZpb3VzIHZlcnNpb25zXG5cblxuICAgIGlmIChcInJlc3VtZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwidHVzOiBUaGUgYHJlc3VtZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQgaW4gdHVzLWpzLWNsaWVudCB2Mi4gUGxlYXNlIHVzZSB0aGUgVVJMIHN0b3JhZ2UgQVBJIGluc3RlYWQuXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9IC8vIFRoZSBkZWZhdWx0IG9wdGlvbnMgd2lsbCBhbHJlYWR5IGJlIGFkZGVkIGZyb20gdGhlIHdyYXBwZXIgY2xhc3Nlcy5cblxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsgLy8gVGhlIHN0b3JhZ2UgbW9kdWxlIHVzZWQgdG8gc3RvcmUgVVJMc1xuXG4gICAgdGhpcy5fdXJsU3RvcmFnZSA9IHRoaXMub3B0aW9ucy51cmxTdG9yYWdlOyAvLyBUaGUgdW5kZXJseWluZyBGaWxlL0Jsb2Igb2JqZWN0XG5cbiAgICB0aGlzLmZpbGUgPSBmaWxlOyAvLyBUaGUgVVJMIGFnYWluc3Qgd2hpY2ggdGhlIGZpbGUgd2lsbCBiZSB1cGxvYWRlZFxuXG4gICAgdGhpcy51cmwgPSBudWxsOyAvLyBUaGUgdW5kZXJseWluZyByZXF1ZXN0IG9iamVjdCBmb3IgdGhlIGN1cnJlbnQgUEFUQ0ggcmVxdWVzdFxuXG4gICAgdGhpcy5fcmVxID0gbnVsbDsgLy8gVGhlIGZpbmdlcnBpbnJ0IGZvciB0aGUgY3VycmVudCBmaWxlIChzZXQgYWZ0ZXIgc3RhcnQoKSlcblxuICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gbnVsbDsgLy8gVGhlIGtleSB0aGF0IHRoZSBVUkwgc3RvcmFnZSByZXR1cm5lZCB3aGVuIHNhdmluZyBhbiBVUkwgd2l0aCBhIGZpbmdlcnByaW50LFxuXG4gICAgdGhpcy5fdXJsU3RvcmFnZUtleSA9IG51bGw7IC8vIFRoZSBvZmZzZXQgdXNlZCBpbiB0aGUgY3VycmVudCBQQVRDSCByZXF1ZXN0XG5cbiAgICB0aGlzLl9vZmZzZXQgPSBudWxsOyAvLyBUcnVlIGlmIHRoZSBjdXJyZW50IFBBVENIIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZFxuXG4gICAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlOyAvLyBUaGUgZmlsZSdzIHNpemUgaW4gYnl0ZXNcblxuICAgIHRoaXMuX3NpemUgPSBudWxsOyAvLyBUaGUgU291cmNlIG9iamVjdCB3aGljaCB3aWxsIHdyYXAgYXJvdW5kIHRoZSBnaXZlbiBmaWxlIGFuZCBwcm92aWRlcyB1c1xuICAgIC8vIHdpdGggYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZ2V0dGluZyBpdHMgc2l6ZSBhbmQgc2xpY2UgY2h1bmtzIGZyb20gaXRzXG4gICAgLy8gY29udGVudCBhbGxvd2luZyB1cyB0byBlYXNpbHkgaGFuZGxlIEZpbGVzLCBCbG9icywgQnVmZmVycyBhbmQgU3RyZWFtcy5cblxuICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7IC8vIFRoZSBjdXJyZW50IGNvdW50IG9mIGF0dGVtcHRzIHdoaWNoIGhhdmUgYmVlbiBtYWRlLiBaZXJvIGluZGljYXRlcyBub25lLlxuXG4gICAgdGhpcy5fcmV0cnlBdHRlbXB0ID0gMDsgLy8gVGhlIHRpbWVvdXQncyBJRCB3aGljaCBpcyB1c2VkIHRvIGRlbGF5IHRoZSBuZXh0IHJldHJ5XG5cbiAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSBudWxsOyAvLyBUaGUgb2Zmc2V0IG9mIHRoZSByZW1vdGUgdXBsb2FkIGJlZm9yZSB0aGUgbGF0ZXN0IGF0dGVtcHQgd2FzIHN0YXJ0ZWQuXG5cbiAgICB0aGlzLl9vZmZzZXRCZWZvcmVSZXRyeSA9IDA7IC8vIEFuIGFycmF5IG9mIEJhc2VVcGxvYWQgaW5zdGFuY2VzIHdoaWNoIGFyZSB1c2VkIGZvciB1cGxvYWRpbmcgdGhlIGRpZmZlcmVudFxuICAgIC8vIHBhcnRzLCBpZiB0aGUgcGFyYWxsZWxVcGxvYWRzIG9wdGlvbiBpcyB1c2VkLlxuXG4gICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRzID0gbnVsbDsgLy8gQW4gYXJyYXkgb2YgdXBsb2FkIFVSTHMgd2hpY2ggYXJlIHVzZWQgZm9yIHVwbG9hZGluZyB0aGUgZGlmZmVyZW50XG4gICAgLy8gcGFydHMsIGlmIHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIGlzIHVzZWQuXG5cbiAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBVc2UgdGhlIFRlcm1pbmF0aW9uIGV4dGVuc2lvbiB0byBkZWxldGUgYW4gdXBsb2FkIGZyb20gdGhlIHNlcnZlciBieSBzZW5kaW5nIGEgREVMRVRFXG4gICAqIHJlcXVlc3QgdG8gdGhlIHNwZWNpZmllZCB1cGxvYWQgVVJMLiBUaGlzIGlzIG9ubHkgcG9zc2libGUgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyB0aGVcbiAgICogVGVybWluYXRpb24gZXh0ZW5zaW9uLiBJZiB0aGUgYG9wdGlvbnMucmV0cnlEZWxheXNgIHByb3BlcnR5IGlzIHNldCwgdGhlIG1ldGhvZCB3aWxsXG4gICAqIGFsc28gcmV0cnkgaWYgYW4gZXJyb3Igb2N1cnJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSB1cGxvYWQncyBVUkwgd2hpY2ggd2lsbCBiZSB0ZXJtaW5hdGVkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIGZvciBpbmZsdWVuY2luZyBIVFRQIHJlcXVlc3RzLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkL3JlamVjdGVkIHdoZW4gdGhlIHJlcXVlc3RzIGZpbmlzaC5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQmFzZVVwbG9hZCwgW3tcbiAgICBrZXk6IFwiZmluZFByZXZpb3VzVXBsb2Fkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kUHJldmlvdXNVcGxvYWRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maW5nZXJwcmludCh0aGlzLmZpbGUsIHRoaXMub3B0aW9ucykudGhlbihmdW5jdGlvbiAoZmluZ2VycHJpbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl91cmxTdG9yYWdlLmZpbmRVcGxvYWRzQnlGaW5nZXJwcmludChmaW5nZXJwcmludCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzdW1lRnJvbVByZXZpb3VzVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3VtZUZyb21QcmV2aW91c1VwbG9hZChwcmV2aW91c1VwbG9hZCkge1xuICAgICAgdGhpcy51cmwgPSBwcmV2aW91c1VwbG9hZC51cGxvYWRVcmwgfHwgbnVsbDtcbiAgICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyA9IHByZXZpb3VzVXBsb2FkLnBhcmFsbGVsVXBsb2FkVXJscyB8fCBudWxsO1xuICAgICAgdGhpcy5fdXJsU3RvcmFnZUtleSA9IHByZXZpb3VzVXBsb2FkLnVybFN0b3JhZ2VLZXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlO1xuXG4gICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogbm8gZmlsZSBvciBzdHJlYW0gdG8gdXBsb2FkIHByb3ZpZGVkXCIpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuZHBvaW50ICYmICF0aGlzLm9wdGlvbnMudXBsb2FkVXJsKSB7XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IG5laXRoZXIgYW4gZW5kcG9pbnQgb3IgYW4gdXBsb2FkIFVSTCBpcyBwcm92aWRlZFwiKSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0cnlEZWxheXMgPSB0aGlzLm9wdGlvbnMucmV0cnlEZWxheXM7XG5cbiAgICAgIGlmIChyZXRyeURlbGF5cyAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXRyeURlbGF5cykgIT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiB0aGUgYHJldHJ5RGVsYXlzYCBvcHRpb24gbXVzdCBlaXRoZXIgYmUgYW4gYXJyYXkgb3IgbnVsbFwiKSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmFsbGVsVXBsb2FkcyA+IDEpIHtcbiAgICAgICAgLy8gVGVzdCB3aGljaCBvcHRpb25zIGFyZSBpbmNvbXBhdGlibGUgd2l0aCBwYXJhbGxlbCB1cGxvYWRzLlxuICAgICAgICBbXCJ1cGxvYWRVcmxcIiwgXCJ1cGxvYWRTaXplXCIsIFwidXBsb2FkTGVuZ3RoRGVmZXJyZWRcIl0uZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uTmFtZSkge1xuICAgICAgICAgIGlmIChfdGhpczIub3B0aW9uc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgX3RoaXMyLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiBjYW5ub3QgdXNlIHRoZSBcIi5jb25jYXQob3B0aW9uTmFtZSwgXCIgb3B0aW9uIHdoZW4gcGFyYWxsZWxVcGxvYWRzIGlzIGVuYWJsZWRcIikpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wdGlvbnMuZmluZ2VycHJpbnQoZmlsZSwgdGhpcy5vcHRpb25zKS50aGVuKGZ1bmN0aW9uIChmaW5nZXJwcmludCkge1xuICAgICAgICBpZiAoZmluZ2VycHJpbnQgPT0gbnVsbCkge1xuICAgICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJObyBmaW5nZXJwcmludCB3YXMgY2FsY3VsYXRlZCBtZWFuaW5nIHRoYXQgdGhlIHVwbG9hZCBjYW5ub3QgYmUgc3RvcmVkIGluIHRoZSBVUkwgc3RvcmFnZS5cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIkNhbGN1bGF0ZWQgZmluZ2VycHJpbnQ6IFwiLmNvbmNhdChmaW5nZXJwcmludCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLl9maW5nZXJwcmludCA9IGZpbmdlcnByaW50O1xuXG4gICAgICAgIGlmIChfdGhpczIuX3NvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX3NvdXJjZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLm9wdGlvbnMuZmlsZVJlYWRlci5vcGVuRmlsZShmaWxlLCBfdGhpczIub3B0aW9ucy5jaHVua1NpemUpO1xuICAgICAgICB9XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgX3RoaXMyLl9zb3VyY2UgPSBzb3VyY2U7IC8vIElmIHRoZSB1cGxvYWQgd2FzIGNvbmZpZ3VyZWQgdG8gdXNlIG11bHRpcGxlIHJlcXVlc3RzIG9yIGlmIHdlIHJlc3VtZSBmcm9tXG4gICAgICAgIC8vIGFuIHVwbG9hZCB3aGljaCB1c2VkIG11bHRpcGxlIHJlcXVlc3RzLCB3ZSBzdGFydCBhIHBhcmFsbGVsIHVwbG9hZC5cblxuICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMucGFyYWxsZWxVcGxvYWRzID4gMSB8fCBfdGhpczIuX3BhcmFsbGVsVXBsb2FkVXJscyAhPSBudWxsKSB7XG4gICAgICAgICAgX3RoaXMyLl9zdGFydFBhcmFsbGVsVXBsb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMyLl9zdGFydFNpbmdsZVVwbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXMyLl9lbWl0RXJyb3IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSB0aGUgdXBsb2FkaW5nIHByb2NlZHVyZSBmb3IgYSBwYXJhbGxlbGl6ZWQgdXBsb2FkLCB3aGVyZSBvbmUgZmlsZSBpcyBzcGxpdCBpbnRvXG4gICAgICogbXVsdGlwbGUgcmVxdWVzdCB3aGljaCBhcmUgcnVuIGluIHBhcmFsbGVsLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RhcnRQYXJhbGxlbFVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRQYXJhbGxlbFVwbG9hZCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgdG90YWxTaXplID0gdGhpcy5fc2l6ZSA9IHRoaXMuX3NvdXJjZS5zaXplO1xuICAgICAgdmFyIHRvdGFsUHJvZ3Jlc3MgPSAwO1xuICAgICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRzID0gW107XG4gICAgICB2YXIgcGFydENvdW50ID0gdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzICE9IG51bGwgPyB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMubGVuZ3RoIDogdGhpcy5vcHRpb25zLnBhcmFsbGVsVXBsb2FkczsgLy8gVGhlIGlucHV0IGZpbGUgd2lsbCBiZSBzcGxpdCBpbnRvIG11bHRpcGxlIHNsaWNlcyB3aGljaCBhcmUgdXBsb2FkZWQgaW4gc2VwYXJhdGVcbiAgICAgIC8vIHJlcXVlc3RzLiBIZXJlIHdlIGdlbmVyYXRlIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uIGZvciB0aGUgc2xpY2VzLlxuXG4gICAgICB2YXIgcGFydHMgPSBzcGxpdFNpemVJbnRvUGFydHModGhpcy5fc291cmNlLnNpemUsIHBhcnRDb3VudCwgdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzKTsgLy8gQ3JlYXRlIGFuIGVtcHR5IGxpc3QgZm9yIHN0b3JpbmcgdGhlIHVwbG9hZCBVUkxzXG5cbiAgICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyA9IG5ldyBBcnJheShwYXJ0cy5sZW5ndGgpOyAvLyBHZW5lcmF0ZSBhIHByb21pc2UgZm9yIGVhY2ggc2xpY2UgdGhhdCB3aWxsIGJlIHJlc29sdmUgaWYgdGhlIHJlc3BlY3RpdmVcbiAgICAgIC8vIHVwbG9hZCBpcyBjb21wbGV0ZWQuXG5cbiAgICAgIHZhciB1cGxvYWRzID0gcGFydHMubWFwKGZ1bmN0aW9uIChwYXJ0LCBpbmRleCkge1xuICAgICAgICB2YXIgbGFzdFBhcnRQcm9ncmVzcyA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpczMuX3NvdXJjZS5zbGljZShwYXJ0LnN0YXJ0LCBwYXJ0LmVuZCkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vIE1lcmdlIHdpdGggdGhlIHVzZXIgc3VwcGxpZWQgb3B0aW9ucyBidXQgb3ZlcndyaXRlIHNvbWUgdmFsdWVzLlxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCBfdGhpczMub3B0aW9ucywge1xuICAgICAgICAgICAgICAvLyBJZiBhdmFpbGFibGUsIHRoZSBwYXJ0aWFsIHVwbG9hZCBzaG91bGQgYmUgcmVzdW1lZCBmcm9tIGEgcHJldmlvdXMgVVJMLlxuICAgICAgICAgICAgICB1cGxvYWRVcmw6IHBhcnQudXBsb2FkVXJsIHx8IG51bGwsXG4gICAgICAgICAgICAgIC8vIFdlIHRha2UgbWFudWFsbHkgY2FyZSBvZiByZXN1bWluZyBmb3IgcGFydGlhbCB1cGxvYWRzLCBzbyB0aGV5IHNob3VsZFxuICAgICAgICAgICAgICAvLyBub3QgYmUgc3RvcmVkIGluIHRoZSBVUkwgc3RvcmFnZS5cbiAgICAgICAgICAgICAgc3RvcmVGaW5nZXJwcmludEZvclJlc3VtaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgcmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyYWxsZWxVcGxvYWRzIG9wdGlvbiB0byBub3QgY2F1c2UgcmVjdXJzaW9uLlxuICAgICAgICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDEsXG4gICAgICAgICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgICAgICAgLy8gQWRkIHRoZSBoZWFkZXIgdG8gaW5kaWNhdGUgdGhlIHRoaXMgaXMgYSBwYXJ0aWFsIHVwbG9hZC5cbiAgICAgICAgICAgICAgaGVhZGVyczogX29iamVjdFNwcmVhZCh7fSwgX3RoaXMzLm9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgICAgICAgIFwiVXBsb2FkLUNvbmNhdFwiOiBcInBhcnRpYWxcIlxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgLy8gUmVqZWN0IG9yIHJlc29sdmUgdGhlIHByb21pc2UgaWYgdGhlIHVwbG9hZCBlcnJvcnMgb3IgY29tcGxldGVzLlxuICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHJlc29sdmUsXG4gICAgICAgICAgICAgIG9uRXJyb3I6IHJlamVjdCxcbiAgICAgICAgICAgICAgLy8gQmFzZWQgaW4gdGhlIHByb2dyZXNzIGZvciB0aGlzIHBhcnRpYWwgdXBsb2FkLCBjYWxjdWxhdGUgdGhlIHByb2dyZXNzXG4gICAgICAgICAgICAgIC8vIGZvciB0aGUgZW50aXJlIGZpbmFsIHVwbG9hZC5cbiAgICAgICAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gb25Qcm9ncmVzcyhuZXdQYXJ0UHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICB0b3RhbFByb2dyZXNzID0gdG90YWxQcm9ncmVzcyAtIGxhc3RQYXJ0UHJvZ3Jlc3MgKyBuZXdQYXJ0UHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgbGFzdFBhcnRQcm9ncmVzcyA9IG5ld1BhcnRQcm9ncmVzcztcblxuICAgICAgICAgICAgICAgIF90aGlzMy5fZW1pdFByb2dyZXNzKHRvdGFsUHJvZ3Jlc3MsIHRvdGFsU2l6ZSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgZXZlcnkgcGFydGlhbCB1cGxvYWQgaGFzIGFuIHVwbG9hZCBVUkwsIHNvIHdlIGNhbiBhZGRcbiAgICAgICAgICAgICAgLy8gdGhlbSB0byB0aGUgVVJMIHN0b3JhZ2UuXG4gICAgICAgICAgICAgIF9vblVwbG9hZFVybEF2YWlsYWJsZTogZnVuY3Rpb24gX29uVXBsb2FkVXJsQXZhaWxhYmxlKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMy5fcGFyYWxsZWxVcGxvYWRVcmxzW2luZGV4XSA9IHVwbG9hZC51cmw7IC8vIFRlc3QgaWYgYWxsIHVwbG9hZHMgaGF2ZSByZWNlaXZlZCBhbiBVUkxcblxuICAgICAgICAgICAgICAgIGlmIChfdGhpczMuX3BhcmFsbGVsVXBsb2FkVXJscy5maWx0ZXIoZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAhIXU7XG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoID09PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMy5fc2F2ZVVwbG9hZEluVXJsU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciB1cGxvYWQgPSBuZXcgQmFzZVVwbG9hZCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB1cGxvYWQuc3RhcnQoKTsgLy8gU3RvcmUgdGhlIHVwbG9hZCBpbiBhbiBhcnJheSwgc28gd2UgY2FuIGxhdGVyIGFib3J0IHRoZW0gaWYgbmVjZXNzYXJ5LlxuXG4gICAgICAgICAgICBfdGhpczMuX3BhcmFsbGVsVXBsb2Fkcy5wdXNoKHVwbG9hZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgcmVxOyAvLyBXYWl0IHVudGlsIGFsbCBwYXJ0aWFsIHVwbG9hZHMgYXJlIGZpbmlzaGVkIGFuZCB3ZSBjYW4gc2VuZCB0aGUgUE9TVCByZXF1ZXN0IGZvclxuICAgICAgLy8gY3JlYXRpbmcgdGhlIGZpbmFsIHVwbG9hZC5cblxuICAgICAgUHJvbWlzZS5hbGwodXBsb2FkcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlcSA9IF90aGlzMy5fb3BlblJlcXVlc3QoXCJQT1NUXCIsIF90aGlzMy5vcHRpb25zLmVuZHBvaW50KTtcbiAgICAgICAgcmVxLnNldEhlYWRlcihcIlVwbG9hZC1Db25jYXRcIiwgXCJmaW5hbDtcIi5jb25jYXQoX3RoaXMzLl9wYXJhbGxlbFVwbG9hZFVybHMuam9pbihcIiBcIikpKTsgLy8gQWRkIG1ldGFkYXRhIGlmIHZhbHVlcyBoYXZlIGJlZW4gYWRkZWRcblxuICAgICAgICB2YXIgbWV0YWRhdGEgPSBlbmNvZGVNZXRhZGF0YShfdGhpczMub3B0aW9ucy5tZXRhZGF0YSk7XG5cbiAgICAgICAgaWYgKG1ldGFkYXRhICE9PSBcIlwiKSB7XG4gICAgICAgICAgcmVxLnNldEhlYWRlcihcIlVwbG9hZC1NZXRhZGF0YVwiLCBtZXRhZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMzLl9zZW5kUmVxdWVzdChyZXEsIG51bGwpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGlmICghaW5TdGF0dXNDYXRlZ29yeShyZXMuZ2V0U3RhdHVzKCksIDIwMCkpIHtcbiAgICAgICAgICBfdGhpczMuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZFwiKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHJlcy5nZXRIZWFkZXIoXCJMb2NhdGlvblwiKTtcblxuICAgICAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzMy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IGludmFsaWQgb3IgbWlzc2luZyBMb2NhdGlvbiBoZWFkZXJcIik7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczMudXJsID0gcmVzb2x2ZVVybChfdGhpczMub3B0aW9ucy5lbmRwb2ludCwgbG9jYXRpb24pO1xuICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiQ3JlYXRlZCB1cGxvYWQgYXQgXCIuY29uY2F0KF90aGlzMy51cmwpKTtcblxuICAgICAgICBfdGhpczMuX2VtaXRTdWNjZXNzKCk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXMzLl9lbWl0RXJyb3IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSB0aGUgdXBsb2FkaW5nIHByb2NlZHVyZSBmb3IgYSBub24tcGFyYWxsZWwgdXBsb2FkLiBIZXJlIHRoZSBlbnRpcmUgZmlsZSBpc1xuICAgICAqIHVwbG9hZGVkIGluIGEgc2VxdWVudGlhbCBtYXR0ZXIuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydFNpbmdsZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRTaW5nbGVVcGxvYWQoKSB7XG4gICAgICAvLyBGaXJzdCwgd2UgbG9vayBhdCB0aGUgdXBsb2FkTGVuZ3RoRGVmZXJyZWQgb3B0aW9uLlxuICAgICAgLy8gTmV4dCwgd2UgY2hlY2sgaWYgdGhlIGNhbGxlciBoYXMgc3VwcGxpZWQgYSBtYW51YWwgdXBsb2FkIHNpemUuXG4gICAgICAvLyBGaW5hbGx5LCB3ZSB0cnkgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHNpemUgZnJvbSB0aGUgc291cmNlIG9iamVjdC5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRTaXplICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9ICt0aGlzLm9wdGlvbnMudXBsb2FkU2l6ZTtcblxuICAgICAgICBpZiAoaXNOYU4odGhpcy5fc2l6ZSkpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiBjYW5ub3QgY29udmVydCBgdXBsb2FkU2l6ZWAgb3B0aW9uIGludG8gYSBudW1iZXJcIikpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zaXplID0gdGhpcy5fc291cmNlLnNpemU7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NpemUgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCBhdXRvbWF0aWNhbGx5IGRlcml2ZSB1cGxvYWQncyBzaXplIGZyb20gaW5wdXQgYW5kIG11c3QgYmUgc3BlY2lmaWVkIG1hbnVhbGx5IHVzaW5nIHRoZSBgdXBsb2FkU2l6ZWAgb3B0aW9uXCIpKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZXNldCB0aGUgYWJvcnRlZCBmbGFnIHdoZW4gdGhlIHVwbG9hZCBpcyBzdGFydGVkIG9yIGVsc2UgdGhlXG4gICAgICAvLyBfcGVyZm9ybVVwbG9hZCB3aWxsIHN0b3AgYmVmb3JlIHNlbmRpbmcgYSByZXF1ZXN0IGlmIHRoZSB1cGxvYWQgaGFzIGJlZW5cbiAgICAgIC8vIGFib3J0ZWQgcHJldmlvdXNseS5cblxuXG4gICAgICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7IC8vIFRoZSB1cGxvYWQgaGFkIGJlZW4gc3RhcnRlZCBwcmV2aW91c2x5IGFuZCB3ZSBzaG91bGQgcmV1c2UgdGhpcyBVUkwuXG5cbiAgICAgIGlmICh0aGlzLnVybCAhPSBudWxsKSB7XG4gICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJSZXN1bWluZyB1cGxvYWQgZnJvbSBwcmV2aW91cyBVUkw6IFwiLmNvbmNhdCh0aGlzLnVybCkpO1xuXG4gICAgICAgIHRoaXMuX3Jlc3VtZVVwbG9hZCgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQSBVUkwgaGFzIG1hbnVhbGx5IGJlZW4gc3BlY2lmaWVkLCBzbyB3ZSB0cnkgdG8gcmVzdW1lXG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRVcmwgIT0gbnVsbCkge1xuICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiUmVzdW1pbmcgdXBsb2FkIGZyb20gcHJvdmlkZWQgVVJMOiBcIi5jb25jYXQodGhpcy5vcHRpb25zLnVybCkpO1xuICAgICAgICB0aGlzLnVybCA9IHRoaXMub3B0aW9ucy51cGxvYWRVcmw7XG5cbiAgICAgICAgdGhpcy5fcmVzdW1lVXBsb2FkKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBBbiB1cGxvYWQgaGFzIG5vdCBzdGFydGVkIGZvciB0aGUgZmlsZSB5ZXQsIHNvIHdlIHN0YXJ0IGEgbmV3IG9uZVxuXG5cbiAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJDcmVhdGluZyBhIG5ldyB1cGxvYWRcIik7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZVVwbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBYm9ydCBhbnkgcnVubmluZyByZXF1ZXN0IGFuZCBzdG9wIHRoZSBjdXJyZW50IHVwbG9hZC4gQWZ0ZXIgYWJvcnQgaXMgY2FsbGVkLCBubyBldmVudFxuICAgICAqIGhhbmRsZXIgd2lsbCBiZSBpbnZva2VkIGFueW1vcmUuIFlvdSBjYW4gdXNlIHRoZSBgc3RhcnRgIG1ldGhvZCB0byByZXN1bWUgdGhlIHVwbG9hZFxuICAgICAqIGFnYWluLlxuICAgICAqIElmIGBzaG91bGRUZXJtaW5hdGVgIGlzIHRydWUsIHRoZSBgdGVybWluYXRlYCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byByZW1vdmUgdGhlXG4gICAgICogY3VycmVudCB1cGxvYWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRUZXJtaW5hdGUgVHJ1ZSBpZiB0aGUgdXBsb2FkIHNob3VsZCBiZSBkZWxldGVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkL3JlamVjdGVkIHdoZW4gdGhlIHJlcXVlc3RzIGZpbmlzaC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFib3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KHNob3VsZFRlcm1pbmF0ZSwgY2IpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHVzOiB0aGUgYWJvcnQgZnVuY3Rpb24gZG9lcyBub3QgYWNjZXB0IGEgY2FsbGJhY2sgc2luY2UgdjIgYW55bW9yZTsgcGxlYXNlIHVzZSB0aGUgcmV0dXJuZWQgUHJvbWlzZSBpbnN0ZWFkXCIpO1xuICAgICAgfSAvLyBTdG9wIGFueSBwYXJhbGxlbCBwYXJ0aWFsIHVwbG9hZHMsIHRoYXQgaGF2ZSBiZWVuIHN0YXJ0ZWQgaW4gX3N0YXJ0UGFyYWxsZWxVcGxvYWRzLlxuXG5cbiAgICAgIGlmICh0aGlzLl9wYXJhbGxlbFVwbG9hZHMgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZHMuZm9yRWFjaChmdW5jdGlvbiAodXBsb2FkKSB7XG4gICAgICAgICAgdXBsb2FkLmFib3J0KHNob3VsZFRlcm1pbmF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBTdG9wIGFueSBjdXJyZW50IHJ1bm5pbmcgcmVxdWVzdC5cblxuXG4gICAgICBpZiAodGhpcy5fcmVxICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3JlcS5hYm9ydCgpO1xuXG4gICAgICAgIHRoaXMuX3NvdXJjZS5jbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTsgLy8gU3RvcCBhbnkgdGltZW91dCB1c2VkIGZvciBpbml0aWF0aW5nIGEgcmV0cnkuXG5cbiAgICAgIGlmICh0aGlzLl9yZXRyeVRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmV0cnlUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5fcmV0cnlUaW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzaG91bGRUZXJtaW5hdGUgfHwgdGhpcy51cmwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBCYXNlVXBsb2FkLnRlcm1pbmF0ZSh0aGlzLnVybCwgdGhpcy5vcHRpb25zKSAvLyBSZW1vdmUgZW50cnkgZnJvbSB0aGUgVVJMIHN0b3JhZ2Ugc2luY2UgdGhlIHVwbG9hZCBVUkwgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM0Ll9yZW1vdmVGcm9tVXJsU3RvcmFnZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0SHR0cEVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBtZXNzYWdlLCBjYXVzaW5nRXJyKSB7XG4gICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IF9lcnJvci5kZWZhdWx0KG1lc3NhZ2UsIGNhdXNpbmdFcnIsIHJlcSwgcmVzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0RXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRFcnJvcihlcnIpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzOyAvLyBEbyBub3QgZW1pdCBlcnJvcnMsIGUuZy4gZnJvbSBhYm9ydGVkIEhUVFAgcmVxdWVzdHMsIGlmIHRoZSB1cGxvYWQgaGFzIGJlZW4gc3RvcHBlZC5cblxuXG4gICAgICBpZiAodGhpcy5fYWJvcnRlZCkgcmV0dXJuOyAvLyBDaGVjayBpZiB3ZSBzaG91bGQgcmV0cnksIHdoZW4gZW5hYmxlZCwgYmVmb3JlIHNlbmRpbmcgdGhlIGVycm9yIHRvIHRoZSB1c2VyLlxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJldHJ5RGVsYXlzICE9IG51bGwpIHtcbiAgICAgICAgLy8gV2Ugd2lsbCByZXNldCB0aGUgYXR0ZW1wdCBjb3VudGVyIGlmXG4gICAgICAgIC8vIC0gd2Ugd2VyZSBhbHJlYWR5IGFibGUgdG8gY29ubmVjdCB0byB0aGUgc2VydmVyIChvZmZzZXQgIT0gbnVsbCkgYW5kXG4gICAgICAgIC8vIC0gd2Ugd2VyZSBhYmxlIHRvIHVwbG9hZCBhIHNtYWxsIGNodW5rIG9mIGRhdGEgdG8gdGhlIHNlcnZlclxuICAgICAgICB2YXIgc2hvdWxkUmVzZXREZWxheXMgPSB0aGlzLl9vZmZzZXQgIT0gbnVsbCAmJiB0aGlzLl9vZmZzZXQgPiB0aGlzLl9vZmZzZXRCZWZvcmVSZXRyeTtcblxuICAgICAgICBpZiAoc2hvdWxkUmVzZXREZWxheXMpIHtcbiAgICAgICAgICB0aGlzLl9yZXRyeUF0dGVtcHQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZFJldHJ5KGVyciwgdGhpcy5fcmV0cnlBdHRlbXB0LCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgICAgdmFyIGRlbGF5ID0gdGhpcy5vcHRpb25zLnJldHJ5RGVsYXlzW3RoaXMuX3JldHJ5QXR0ZW1wdCsrXTtcbiAgICAgICAgICB0aGlzLl9vZmZzZXRCZWZvcmVSZXRyeSA9IHRoaXMuX29mZnNldDtcbiAgICAgICAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNS5zdGFydCgpO1xuICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkVycm9yKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2hlcyBub3RpZmljYXRpb24gaWYgdGhlIHVwbG9hZCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdFN1Y2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRTdWNjZXNzKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVGaW5nZXJwcmludE9uU3VjY2Vzcykge1xuICAgICAgICAvLyBSZW1vdmUgc3RvcmVkIGZpbmdlcnByaW50IGFuZCBjb3JyZXNwb25kaW5nIGVuZHBvaW50LiBUaGlzIGNhdXNlc1xuICAgICAgICAvLyBuZXcgdXBsb2FkcyBvZiB0aGUgc2FtZSBmaWxlIHRvIGJlIHRyZWF0ZWQgYXMgYSBkaWZmZXJlbnQgZmlsZS5cbiAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbVVybFN0b3JhZ2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25TdWNjZXNzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uU3VjY2VzcygpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgbm90aWZpY2F0aW9uIHdoZW4gZGF0YSBoYXMgYmVlbiBzZW50IHRvIHRoZSBzZXJ2ZXIuIFRoaXNcbiAgICAgKiBkYXRhIG1heSBub3QgaGF2ZSBiZWVuIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIgeWV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzU2VudCAgTnVtYmVyIG9mIGJ5dGVzIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZXNUb3RhbCBUb3RhbCBudW1iZXIgb2YgYnl0ZXMgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRQcm9ncmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFByb2dyZXNzKGJ5dGVzU2VudCwgYnl0ZXNUb3RhbCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25Qcm9ncmVzcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vblByb2dyZXNzKGJ5dGVzU2VudCwgYnl0ZXNUb3RhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2hlcyBub3RpZmljYXRpb24gd2hlbiBhIGNodW5rIG9mIGRhdGEgaGFzIGJlZW4gc2VudCB0byB0aGUgc2VydmVyXG4gICAgICogYW5kIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNodW5rU2l6ZSAgU2l6ZSBvZiB0aGUgY2h1bmsgdGhhdCB3YXMgYWNjZXB0ZWQgYnkgdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZXNBY2NlcHRlZCBUb3RhbCBudW1iZXIgb2YgYnl0ZXMgdGhhdCBoYXZlIGJlZW5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0ZWQgYnkgdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZXNUb3RhbCBUb3RhbCBudW1iZXIgb2YgYnl0ZXMgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRDaHVua0NvbXBsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0Q2h1bmtDb21wbGV0ZShjaHVua1NpemUsIGJ5dGVzQWNjZXB0ZWQsIGJ5dGVzVG90YWwpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNodW5rQ29tcGxldGUoY2h1bmtTaXplLCBieXRlc0FjY2VwdGVkLCBieXRlc1RvdGFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHVwbG9hZCB1c2luZyB0aGUgY3JlYXRpb24gZXh0ZW5zaW9uIGJ5IHNlbmRpbmcgYSBQT1NUXG4gICAgICogcmVxdWVzdCB0byB0aGUgZW5kcG9pbnQuIEFmdGVyIHN1Y2Nlc3NmdWwgY3JlYXRpb24gdGhlIGZpbGUgd2lsbCBiZVxuICAgICAqIHVwbG9hZGVkXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVVwbG9hZCgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmRwb2ludCkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiB1bmFibGUgdG8gY3JlYXRlIHVwbG9hZCBiZWNhdXNlIG5vIGVuZHBvaW50IGlzIHByb3ZpZGVkXCIpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXEgPSB0aGlzLl9vcGVuUmVxdWVzdChcIlBPU1RcIiwgdGhpcy5vcHRpb25zLmVuZHBvaW50KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICByZXEuc2V0SGVhZGVyKFwiVXBsb2FkLURlZmVyLUxlbmd0aFwiLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoXCJVcGxvYWQtTGVuZ3RoXCIsIHRoaXMuX3NpemUpO1xuICAgICAgfSAvLyBBZGQgbWV0YWRhdGEgaWYgdmFsdWVzIGhhdmUgYmVlbiBhZGRlZFxuXG5cbiAgICAgIHZhciBtZXRhZGF0YSA9IGVuY29kZU1ldGFkYXRhKHRoaXMub3B0aW9ucy5tZXRhZGF0YSk7XG5cbiAgICAgIGlmIChtZXRhZGF0YSAhPT0gXCJcIikge1xuICAgICAgICByZXEuc2V0SGVhZGVyKFwiVXBsb2FkLU1ldGFkYXRhXCIsIG1ldGFkYXRhKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb21pc2U7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkRGF0YUR1cmluZ0NyZWF0aW9uICYmICF0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICAgICAgcHJvbWlzZSA9IHRoaXMuX2FkZENodW5rVG9SZXF1ZXN0KHJlcSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlID0gdGhpcy5fc2VuZFJlcXVlc3QocmVxLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKCFpblN0YXR1c0NhdGVnb3J5KHJlcy5nZXRTdGF0dXMoKSwgMjAwKSkge1xuICAgICAgICAgIF90aGlzNi5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgY3JlYXRpbmcgdXBsb2FkXCIpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmdldEhlYWRlcihcIkxvY2F0aW9uXCIpO1xuXG4gICAgICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgX3RoaXM2Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogaW52YWxpZCBvciBtaXNzaW5nIExvY2F0aW9uIGhlYWRlclwiKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNi51cmwgPSByZXNvbHZlVXJsKF90aGlzNi5vcHRpb25zLmVuZHBvaW50LCBsb2NhdGlvbik7XG4gICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJDcmVhdGVkIHVwbG9hZCBhdCBcIi5jb25jYXQoX3RoaXM2LnVybCkpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX3RoaXM2Lm9wdGlvbnMuX29uVXBsb2FkVXJsQXZhaWxhYmxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBfdGhpczYub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczYuX3NpemUgPT09IDApIHtcbiAgICAgICAgICAvLyBOb3RoaW5nIHRvIHVwbG9hZCBhbmQgZmlsZSB3YXMgc3VjY2Vzc2Z1bGx5IGNyZWF0ZWRcbiAgICAgICAgICBfdGhpczYuX2VtaXRTdWNjZXNzKCk7XG5cbiAgICAgICAgICBfdGhpczYuX3NvdXJjZS5jbG9zZSgpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM2Ll9zYXZlVXBsb2FkSW5VcmxTdG9yYWdlKCk7XG5cbiAgICAgICAgaWYgKF90aGlzNi5vcHRpb25zLnVwbG9hZERhdGFEdXJpbmdDcmVhdGlvbikge1xuICAgICAgICAgIF90aGlzNi5faGFuZGxlVXBsb2FkUmVzcG9uc2UocmVxLCByZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzNi5fb2Zmc2V0ID0gMDtcblxuICAgICAgICAgIF90aGlzNi5fcGVyZm9ybVVwbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXM2Ll9lbWl0SHR0cEVycm9yKHJlcSwgbnVsbCwgXCJ0dXM6IGZhaWxlZCB0byBjcmVhdGUgdXBsb2FkXCIsIGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBUcnkgdG8gcmVzdW1lIGFuIGV4aXN0aW5nIHVwbG9hZC4gRmlyc3QgYSBIRUFEIHJlcXVlc3Qgd2lsbCBiZSBzZW50XG4gICAgICogdG8gcmV0cmlldmUgdGhlIG9mZnNldC4gSWYgdGhlIHJlcXVlc3QgZmFpbHMgYSBuZXcgdXBsb2FkIHdpbGwgYmVcbiAgICAgKiBjcmVhdGVkLiBJbiB0aGUgY2FzZSBvZiBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgdGhlIGZpbGUgd2lsbCBiZSB1cGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc3VtZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzdW1lVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciByZXEgPSB0aGlzLl9vcGVuUmVxdWVzdChcIkhFQURcIiwgdGhpcy51cmwpO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3NlbmRSZXF1ZXN0KHJlcSwgbnVsbCk7XG5cbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSByZXMuZ2V0U3RhdHVzKCk7XG5cbiAgICAgICAgaWYgKCFpblN0YXR1c0NhdGVnb3J5KHN0YXR1cywgMjAwKSkge1xuICAgICAgICAgIGlmIChpblN0YXR1c0NhdGVnb3J5KHN0YXR1cywgNDAwKSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHN0b3JlZCBmaW5nZXJwcmludCBhbmQgY29ycmVzcG9uZGluZyBlbmRwb2ludCxcbiAgICAgICAgICAgIC8vIG9uIGNsaWVudCBlcnJvcnMgc2luY2UgdGhlIGZpbGUgY2FuIG5vdCBiZSBmb3VuZFxuICAgICAgICAgICAgX3RoaXM3Ll9yZW1vdmVGcm9tVXJsU3RvcmFnZSgpO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIHVwbG9hZCBpcyBsb2NrZWQgKGluZGljYXRlZCBieSB0aGUgNDIzIExvY2tlZCBzdGF0dXMgY29kZSksIHdlXG4gICAgICAgICAgLy8gZW1pdCBhbiBlcnJvciBpbnN0ZWFkIG9mIGRpcmVjdGx5IHN0YXJ0aW5nIGEgbmV3IHVwbG9hZC4gVGhpcyB3YXkgdGhlXG4gICAgICAgICAgLy8gcmV0cnkgbG9naWMgY2FuIGNhdGNoIHRoZSBlcnJvciBhbmQgd2lsbCByZXRyeSB0aGUgdXBsb2FkLiBBbiB1cGxvYWRcbiAgICAgICAgICAvLyBpcyB1c3VhbGx5IGxvY2tlZCBmb3IgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSBhbmQgd2lsbCBiZSBhdmFpbGFibGVcbiAgICAgICAgICAvLyBhZnRlcndhcmRzLlxuXG5cbiAgICAgICAgICBpZiAoc3RhdHVzID09PSA0MjMpIHtcbiAgICAgICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IHVwbG9hZCBpcyBjdXJyZW50bHkgbG9ja2VkOyByZXRyeSBsYXRlclwiKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghX3RoaXM3Lm9wdGlvbnMuZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGF0dGVtcHQgdG8gY3JlYXRlIGEgbmV3IHVwbG9hZCBpZiBubyBlbmRwb2ludCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IHVuYWJsZSB0byByZXN1bWUgdXBsb2FkIChuZXcgdXBsb2FkIGNhbm5vdCBiZSBjcmVhdGVkIHdpdGhvdXQgYW4gZW5kcG9pbnQpXCIpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBUcnkgdG8gY3JlYXRlIGEgbmV3IHVwbG9hZFxuXG5cbiAgICAgICAgICBfdGhpczcudXJsID0gbnVsbDtcblxuICAgICAgICAgIF90aGlzNy5fY3JlYXRlVXBsb2FkKCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQocmVzLmdldEhlYWRlcihcIlVwbG9hZC1PZmZzZXRcIiksIDEwKTtcblxuICAgICAgICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IGludmFsaWQgb3IgbWlzc2luZyBvZmZzZXQgdmFsdWVcIik7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQocmVzLmdldEhlYWRlcihcIlVwbG9hZC1MZW5ndGhcIiksIDEwKTtcblxuICAgICAgICBpZiAoaXNOYU4obGVuZ3RoKSAmJiAhX3RoaXM3Lm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiBpbnZhbGlkIG9yIG1pc3NpbmcgbGVuZ3RoIHZhbHVlXCIpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczcub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIF90aGlzNy5vcHRpb25zLl9vblVwbG9hZFVybEF2YWlsYWJsZSgpO1xuICAgICAgICB9IC8vIFVwbG9hZCBoYXMgYWxyZWFkeSBiZWVuIGNvbXBsZXRlZCBhbmQgd2UgZG8gbm90IG5lZWQgdG8gc2VuZCBhZGRpdGlvbmFsXG4gICAgICAgIC8vIGRhdGEgdG8gdGhlIHNlcnZlclxuXG5cbiAgICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgX3RoaXM3Ll9lbWl0UHJvZ3Jlc3MobGVuZ3RoLCBsZW5ndGgpO1xuXG4gICAgICAgICAgX3RoaXM3Ll9lbWl0U3VjY2VzcygpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM3Ll9vZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICAgICAgX3RoaXM3Ll9wZXJmb3JtVXBsb2FkKCk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgbnVsbCwgXCJ0dXM6IGZhaWxlZCB0byByZXN1bWUgdXBsb2FkXCIsIGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgdXBsb2FkaW5nIHRoZSBmaWxlIHVzaW5nIFBBVENIIHJlcXVlc3RzLiBUaGUgZmlsZSB3aWxsIGJlIGRpdmlkZWRcbiAgICAgKiBpbnRvIGNodW5rcyBhcyBzcGVjaWZpZWQgaW4gdGhlIGNodW5rU2l6ZSBvcHRpb24uIER1cmluZyB0aGUgdXBsb2FkXG4gICAgICogdGhlIG9uUHJvZ3Jlc3MgZXZlbnQgaGFuZGxlciBtYXkgYmUgaW52b2tlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BlcmZvcm1VcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BlcmZvcm1VcGxvYWQoKSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpczsgLy8gSWYgdGhlIHVwbG9hZCBoYXMgYmVlbiBhYm9ydGVkLCB3ZSB3aWxsIG5vdCBzZW5kIHRoZSBuZXh0IFBBVENIIHJlcXVlc3QuXG4gICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBpZiB0aGUgYWJvcnQgbWV0aG9kIHdhcyBjYWxsZWQgZHVyaW5nIGEgY2FsbGJhY2ssIHN1Y2hcbiAgICAgIC8vIGFzIG9uQ2h1bmtDb21wbGV0ZSBvciBvblByb2dyZXNzLlxuXG5cbiAgICAgIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcTsgLy8gU29tZSBicm93c2VyIGFuZCBzZXJ2ZXJzIG1heSBub3Qgc3VwcG9ydCB0aGUgUEFUQ0ggbWV0aG9kLiBGb3IgdGhvc2VcbiAgICAgIC8vIGNhc2VzLCB5b3UgY2FuIHRlbGwgdHVzLWpzLWNsaWVudCB0byB1c2UgYSBQT1NUIHJlcXVlc3Qgd2l0aCB0aGVcbiAgICAgIC8vIFgtSFRUUC1NZXRob2QtT3ZlcnJpZGUgaGVhZGVyIGZvciBzaW11bGF0aW5nIGEgUEFUQ0ggcmVxdWVzdC5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVycmlkZVBhdGNoTWV0aG9kKSB7XG4gICAgICAgIHJlcSA9IHRoaXMuX29wZW5SZXF1ZXN0KFwiUE9TVFwiLCB0aGlzLnVybCk7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoXCJYLUhUVFAtTWV0aG9kLU92ZXJyaWRlXCIsIFwiUEFUQ0hcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXEgPSB0aGlzLl9vcGVuUmVxdWVzdChcIlBBVENIXCIsIHRoaXMudXJsKTtcbiAgICAgIH1cblxuICAgICAgcmVxLnNldEhlYWRlcihcIlVwbG9hZC1PZmZzZXRcIiwgdGhpcy5fb2Zmc2V0KTtcblxuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9hZGRDaHVua1RvUmVxdWVzdChyZXEpO1xuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkocmVzLmdldFN0YXR1cygpLCAyMDApKSB7XG4gICAgICAgICAgX3RoaXM4Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSB1cGxvYWRpbmcgY2h1bmtcIik7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczguX2hhbmRsZVVwbG9hZFJlc3BvbnNlKHJlcSwgcmVzKTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvLyBEb24ndCBlbWl0IGFuIGVycm9yIGlmIHRoZSB1cGxvYWQgd2FzIGFib3J0ZWQgbWFudWFsbHlcbiAgICAgICAgaWYgKF90aGlzOC5fYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzOC5fZW1pdEh0dHBFcnJvcihyZXEsIG51bGwsIFwidHVzOiBmYWlsZWQgdG8gdXBsb2FkIGNodW5rIGF0IG9mZnNldCBcIiArIF90aGlzOC5fb2Zmc2V0LCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIF9hZGRDaHVua3RvUmVxdWVzdCByZWFkcyBhIGNodW5rIGZyb20gdGhlIHNvdXJjZSBhbmQgc2VuZHMgaXQgdXNpbmcgdGhlXG4gICAgICogc3VwcGxpZWQgcmVxdWVzdCBvYmplY3QuIEl0IHdpbGwgbm90IGhhbmRsZSB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRDaHVua1RvUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQ2h1bmtUb1JlcXVlc3QocmVxKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgdmFyIGVuZCA9IHRoaXMuX29mZnNldCArIHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gICAgICByZXEuc2V0UHJvZ3Jlc3NIYW5kbGVyKGZ1bmN0aW9uIChieXRlc1NlbnQpIHtcbiAgICAgICAgX3RoaXM5Ll9lbWl0UHJvZ3Jlc3Moc3RhcnQgKyBieXRlc1NlbnQsIF90aGlzOS5fc2l6ZSk7XG4gICAgICB9KTtcbiAgICAgIHJlcS5zZXRIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtXCIpOyAvLyBUaGUgc3BlY2lmaWVkIGNodW5rU2l6ZSBtYXkgYmUgSW5maW5pdHkgb3IgdGhlIGNhbGNsdWF0ZWQgZW5kIHBvc2l0aW9uXG4gICAgICAvLyBtYXkgZXhjZWVkIHRoZSBmaWxlJ3Mgc2l6ZS4gSW4gYm90aCBjYXNlcywgd2UgbGltaXQgdGhlIGVuZCBwb3NpdGlvbiB0b1xuICAgICAgLy8gdGhlIGlucHV0J3MgdG90YWwgc2l6ZSBmb3Igc2ltcGxlciBjYWxjdWxhdGlvbnMgYW5kIGNvcnJlY3RuZXNzLlxuXG4gICAgICBpZiAoKGVuZCA9PT0gSW5maW5pdHkgfHwgZW5kID4gdGhpcy5fc2l6ZSkgJiYgIXRoaXMub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICBlbmQgPSB0aGlzLl9zaXplO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlLnNsaWNlKHN0YXJ0LCBlbmQpLnRoZW4oZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgICAgICAgICAgZG9uZSA9IF9yZWYyLmRvbmU7IC8vIElmIHRoZSB1cGxvYWQgbGVuZ3RoIGlzIGRlZmVycmVkLCB0aGUgdXBsb2FkIHNpemUgd2FzIG5vdCBzcGVjaWZpZWQgZHVyaW5nXG4gICAgICAgIC8vIHVwbG9hZCBjcmVhdGlvbi4gU28sIGlmIHRoZSBmaWxlIHJlYWRlciBpcyBkb25lIHJlYWRpbmcsIHdlIGtub3cgdGhlIHRvdGFsXG4gICAgICAgIC8vIHVwbG9hZCBzaXplIGFuZCBjYW4gdGVsbCB0aGUgdHVzIHNlcnZlci5cblxuICAgICAgICBpZiAoX3RoaXM5Lm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQgJiYgZG9uZSkge1xuICAgICAgICAgIF90aGlzOS5fc2l6ZSA9IF90aGlzOS5fb2Zmc2V0ICsgKHZhbHVlICYmIHZhbHVlLnNpemUgPyB2YWx1ZS5zaXplIDogMCk7XG4gICAgICAgICAgcmVxLnNldEhlYWRlcihcIlVwbG9hZC1MZW5ndGhcIiwgX3RoaXM5Ll9zaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczkuX3NlbmRSZXF1ZXN0KHJlcSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXM5Ll9lbWl0UHJvZ3Jlc3MoX3RoaXM5Ll9vZmZzZXQsIF90aGlzOS5fc2l6ZSk7XG5cbiAgICAgICAgICByZXR1cm4gX3RoaXM5Ll9zZW5kUmVxdWVzdChyZXEsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIF9oYW5kbGVVcGxvYWRSZXNwb25zZSBpcyB1c2VkIGJ5IHJlcXVlc3RzIHRoYXQgaGF2ZW4gYmVlbiBzZW50IHVzaW5nIF9hZGRDaHVua1RvUmVxdWVzdFxuICAgICAqIGFuZCBhbHJlYWR5IGhhdmUgcmVjZWl2ZWQgYSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZVVwbG9hZFJlc3BvbnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVVcGxvYWRSZXNwb25zZShyZXEsIHJlcykge1xuICAgICAgdmFyIG9mZnNldCA9IHBhcnNlSW50KHJlcy5nZXRIZWFkZXIoXCJVcGxvYWQtT2Zmc2V0XCIpLCAxMCk7XG5cbiAgICAgIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgICAgIHRoaXMuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiBpbnZhbGlkIG9yIG1pc3Npbmcgb2Zmc2V0IHZhbHVlXCIpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZW1pdFByb2dyZXNzKG9mZnNldCwgdGhpcy5fc2l6ZSk7XG5cbiAgICAgIHRoaXMuX2VtaXRDaHVua0NvbXBsZXRlKG9mZnNldCAtIHRoaXMuX29mZnNldCwgb2Zmc2V0LCB0aGlzLl9zaXplKTtcblxuICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgICBpZiAob2Zmc2V0ID09IHRoaXMuX3NpemUpIHtcbiAgICAgICAgLy8gWWF5LCBmaW5hbGx5IGRvbmUgOilcbiAgICAgICAgdGhpcy5fZW1pdFN1Y2Nlc3MoKTtcblxuICAgICAgICB0aGlzLl9zb3VyY2UuY2xvc2UoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BlcmZvcm1VcGxvYWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEhUVFAgcmVxdWVzdCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gbWV0aG9kIGFuZCBVUkwuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9vcGVuUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlblJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgICAgIHZhciByZXEgPSBvcGVuUmVxdWVzdChtZXRob2QsIHVybCwgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuX3JlcSA9IHJlcTtcbiAgICAgIHJldHVybiByZXE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgZW50cnkgaW4gdGhlIFVSTCBzdG9yYWdlLCBpZiBpdCBoYXMgYmVlbiBzYXZlZCBiZWZvcmUuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVGcm9tVXJsU3RvcmFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRnJvbVVybFN0b3JhZ2UoKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5fdXJsU3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICB0aGlzLl91cmxTdG9yYWdlLnJlbW92ZVVwbG9hZCh0aGlzLl91cmxTdG9yYWdlS2V5KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXMxMC5fZW1pdEVycm9yKGVycik7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fdXJsU3RvcmFnZUtleSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgdXBsb2FkIFVSTCB0byB0aGUgVVJMIHN0b3JhZ2UsIGlmIHBvc3NpYmxlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2F2ZVVwbG9hZEluVXJsU3RvcmFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2F2ZVVwbG9hZEluVXJsU3RvcmFnZSgpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpczsgLy8gT25seSBpZiBhIGZpbmdlcnByaW50IHdhcyBjYWxjdWxhdGVkIGZvciB0aGUgaW5wdXQgKGkuZS4gbm90IGEgc3RyZWFtKSwgd2UgY2FuIHN0b3JlIHRoZSB1cGxvYWQgVVJMLlxuXG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZyB8fCAhdGhpcy5fZmluZ2VycHJpbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RvcmVkVXBsb2FkID0ge1xuICAgICAgICBzaXplOiB0aGlzLl9zaXplLFxuICAgICAgICBtZXRhZGF0YTogdGhpcy5vcHRpb25zLm1ldGFkYXRhLFxuICAgICAgICBjcmVhdGlvblRpbWU6IG5ldyBEYXRlKCkudG9TdHJpbmcoKVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX3BhcmFsbGVsVXBsb2Fkcykge1xuICAgICAgICAvLyBTYXZlIG11bHRpcGxlIFVSTHMgaWYgdGhlIHBhcmFsbGVsVXBsb2FkcyBvcHRpb24gaXMgdXNlZCAuLi5cbiAgICAgICAgc3RvcmVkVXBsb2FkLnBhcmFsbGVsVXBsb2FkVXJscyA9IHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIC4uLiBvdGhlcndpc2Ugd2UganVzdCBzYXZlIHRoZSBvbmUgYXZhaWxhYmxlIFVSTC5cbiAgICAgICAgc3RvcmVkVXBsb2FkLnVwbG9hZFVybCA9IHRoaXMudXJsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cmxTdG9yYWdlLmFkZFVwbG9hZCh0aGlzLl9maW5nZXJwcmludCwgc3RvcmVkVXBsb2FkKS50aGVuKGZ1bmN0aW9uICh1cmxTdG9yYWdlS2V5KSB7XG4gICAgICAgIHJldHVybiBfdGhpczExLl91cmxTdG9yYWdlS2V5ID0gdXJsU3RvcmFnZUtleTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczExLl9lbWl0RXJyb3IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgcmVxdWVzdCB3aXRoIHRoZSBwcm92aWRlZCBib2R5IHdoaWxlIGludm9raW5nIHRoZSBvbkJlZm9yZVJlcXVlc3RcbiAgICAgKiBhbmQgb25BZnRlclJlc3BvbnNlIGNhbGxiYWNrcy5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NlbmRSZXF1ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZW5kUmVxdWVzdChyZXEpIHtcbiAgICAgIHZhciBfdGhpczEyID0gdGhpcztcblxuICAgICAgdmFyIGJvZHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uQmVmb3JlUmVxdWVzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkJlZm9yZVJlcXVlc3QocmVxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcS5zZW5kKGJvZHkpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAodHlwZW9mIF90aGlzMTIub3B0aW9ucy5vbkFmdGVyUmVzcG9uc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIF90aGlzMTIub3B0aW9ucy5vbkFmdGVyUmVzcG9uc2UocmVxLCByZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInRlcm1pbmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXJtaW5hdGUodXJsKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgY2IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHVzOiB0aGUgdGVybWluYXRlIGZ1bmN0aW9uIGRvZXMgbm90IGFjY2VwdCBhIGNhbGxiYWNrIHNpbmNlIHYyIGFueW1vcmU7IHBsZWFzZSB1c2UgdGhlIHJldHVybmVkIFByb21pc2UgaW5zdGVhZFwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcSA9IG9wZW5SZXF1ZXN0KFwiREVMRVRFXCIsIHVybCwgb3B0aW9ucyk7XG4gICAgICB2YXIgcHJvbWlzZSA9IHJlcS5zZW5kKCk7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgLy8gQSAyMDQgcmVzcG9uc2UgaW5kaWNhdGVzIGEgc3VjY2Vzc2Z1bGwgcmVxdWVzdFxuICAgICAgICBpZiAocmVzLmdldFN0YXR1cygpID09PSAyMDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgX2Vycm9yLmRlZmF1bHQoXCJ0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgdGVybWluYXRpbmcgdXBsb2FkXCIsIG51bGwsIHJlcSwgcmVzKTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBfZXJyb3IuZGVmYXVsdCkpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgX2Vycm9yLmRlZmF1bHQoXCJ0dXM6IGZhaWxlZCB0byB0ZXJtaW5hdGUgdXBsb2FkXCIsIGVyciwgcmVxLCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2hvdWxkUmV0cnkoZXJyLCAwLCBvcHRpb25zKSkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSAvLyBJbnN0ZWFkIG9mIGtlZXBpbmcgdHJhY2sgb2YgdGhlIHJldHJ5IGF0dGVtcHRzLCB3ZSByZW1vdmUgdGhlIGZpcnN0IGVsZW1lbnQgZnJvbSB0aGUgZGVsYXlzXG4gICAgICAgIC8vIGFycmF5LiBJZiB0aGUgYXJyYXkgaXMgZW1wdHksIGFsbCByZXRyeSBhdHRlbXB0cyBhcmUgdXNlZCB1cCBhbmQgd2Ugd2lsbCBidWJibGUgdXAgdGhlIGVycm9yLlxuICAgICAgICAvLyBXZSByZWN1cnNpdmVseSBjYWxsIHRoZSB0ZXJtaW5hdGUgZnVuY3Rpb24gd2lsbCByZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSByZXRyeURlbGF5cyBhcnJheS5cblxuXG4gICAgICAgIHZhciBkZWxheSA9IG9wdGlvbnMucmV0cnlEZWxheXNbMF07XG4gICAgICAgIHZhciByZW1haW5pbmdEZWxheXMgPSBvcHRpb25zLnJldHJ5RGVsYXlzLnNsaWNlKDEpO1xuXG4gICAgICAgIHZhciBuZXdPcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgIHJldHJ5RGVsYXlzOiByZW1haW5pbmdEZWxheXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gQmFzZVVwbG9hZC50ZXJtaW5hdGUodXJsLCBuZXdPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZVVwbG9hZDtcbn0oKTtcblxuZnVuY3Rpb24gZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgdmFyIGVuY29kZWQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gbWV0YWRhdGEpIHtcbiAgICBlbmNvZGVkLnB1c2goa2V5ICsgXCIgXCIgKyBfanNCYXNlLkJhc2U2NC5lbmNvZGUobWV0YWRhdGFba2V5XSkpO1xuICB9XG5cbiAgcmV0dXJuIGVuY29kZWQuam9pbihcIixcIik7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gc3RhdHVzIGlzIGluIHRoZSByYW5nZSBvZiB0aGUgZXhwZWN0ZWQgY2F0ZWdvcnkuXG4gKiBGb3IgZXhhbXBsZSwgb25seSBhIHN0YXR1cyBiZXR3ZWVuIDIwMCBhbmQgMjk5IHdpbGwgc2F0aXNmeSB0aGUgY2F0ZWdvcnkgMjAwLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gaW5TdGF0dXNDYXRlZ29yeShzdGF0dXMsIGNhdGVnb3J5KSB7XG4gIHJldHVybiBzdGF0dXMgPj0gY2F0ZWdvcnkgJiYgc3RhdHVzIDwgY2F0ZWdvcnkgKyAxMDA7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBIVFRQIHJlcXVlc3Qgd2l0aCB0aGUgc3BlY2lmaWVkIG1ldGhvZCBhbmQgVVJMLlxuICogVGhlIG5lY2Vzc2FyeSBoZWFkZXJzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGV2ZXJ5IHJlcXVlc3RcbiAqIHdpbGwgYmUgYWRkZWQsIGluY2x1ZGluZyB0aGUgcmVxdWVzdCBJRC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIG9wZW5SZXF1ZXN0KG1ldGhvZCwgdXJsLCBvcHRpb25zKSB7XG4gIHZhciByZXEgPSBvcHRpb25zLmh0dHBTdGFjay5jcmVhdGVSZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbiAgcmVxLnNldEhlYWRlcihcIlR1cy1SZXN1bWFibGVcIiwgXCIxLjAuMFwiKTtcbiAgdmFyIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgcmVxLnNldEhlYWRlcihuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFkZFJlcXVlc3RJZCkge1xuICAgIHZhciByZXF1ZXN0SWQgPSAoMCwgX3V1aWQuZGVmYXVsdCkoKTtcbiAgICByZXEuc2V0SGVhZGVyKFwiWC1SZXF1ZXN0LUlEXCIsIHJlcXVlc3RJZCk7XG4gIH1cblxuICByZXR1cm4gcmVxO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgYnJvd3NlciBydW5uaW5nIHRoaXMgY29kZSBoYXMgaW50ZXJuZXQgYWNjZXNzLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFsd2F5cyByZXR1cm4gdHJ1ZSBpbiB0aGUgbm9kZS5qcyBlbnZpcm9ubWVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gaXNPbmxpbmUoKSB7XG4gIHZhciBvbmxpbmUgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIFwibmF2aWdhdG9yXCIgaW4gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lID09PSBmYWxzZSkge1xuICAgIG9ubGluZSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG9ubGluZTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IGl0IGlzIG9rIHRvIHJldHJ5IGEgcmVxdWVzdC5cbiAqIEBwYXJhbSB7RXJyb3J9IGVyciB0aGUgZXJyb3IgcmV0dXJuZWQgZnJvbSB0aGUgbGFzdCByZXF1ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cnlBdHRlbXB0IHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIHJlcXVlc3QgaGFzIGFscmVhZHkgYmVlbiByZXRyaWVkXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyB0dXMgVXBsb2FkIG9wdGlvbnNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNob3VsZFJldHJ5KGVyciwgcmV0cnlBdHRlbXB0LCBvcHRpb25zKSB7XG4gIC8vIFdlIG9ubHkgYXR0ZW1wdCBhIHJldHJ5IGlmXG4gIC8vIC0gcmV0cnlEZWxheXMgb3B0aW9uIGlzIHNldFxuICAvLyAtIHdlIGRpZG4ndCBleGNlZWQgdGhlIG1heGl1bSBudW1iZXIgb2YgcmV0cmllcywgeWV0LCBhbmRcbiAgLy8gLSB0aGlzIGVycm9yIHdhcyBjYXVzZWQgYnkgYSByZXF1ZXN0IG9yIGl0J3MgcmVzcG9uc2UgYW5kXG4gIC8vIC0gdGhlIGVycm9yIGlzIHNlcnZlciBlcnJvciAoaS5lLiBubyBhIHN0YXR1cyA0eHggb3IgYSA0MDkgb3IgNDIzKSBhbmRcbiAgLy8gLSB0aGUgYnJvd3NlciBkb2VzIG5vdCBpbmRpY2F0ZSB0aGF0IHdlIGFyZSBvZmZsaW5lXG4gIHZhciBzdGF0dXMgPSBlcnIub3JpZ2luYWxSZXNwb25zZSA/IGVyci5vcmlnaW5hbFJlc3BvbnNlLmdldFN0YXR1cygpIDogMDtcbiAgdmFyIGlzU2VydmVyRXJyb3IgPSAhaW5TdGF0dXNDYXRlZ29yeShzdGF0dXMsIDQwMCkgfHwgc3RhdHVzID09PSA0MDkgfHwgc3RhdHVzID09PSA0MjM7XG4gIHJldHVybiBvcHRpb25zLnJldHJ5RGVsYXlzICE9IG51bGwgJiYgcmV0cnlBdHRlbXB0IDwgb3B0aW9ucy5yZXRyeURlbGF5cy5sZW5ndGggJiYgZXJyLm9yaWdpbmFsUmVxdWVzdCAhPSBudWxsICYmIGlzU2VydmVyRXJyb3IgJiYgaXNPbmxpbmUoKTtcbn1cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIGxpbmsgZ2l2ZW4gdGhlIG9yaWdpbiBhcyBzb3VyY2UuIEZvciBleGFtcGxlLFxuICogaWYgYSBIVFRQIHJlcXVlc3QgdG8gaHR0cDovL2V4YW1wbGUuY29tL2ZpbGVzLyByZXR1cm5zIGEgTG9jYXRpb25cbiAqIGhlYWRlciB3aXRoIHRoZSB2YWx1ZSAvdXBsb2FkL2FiYywgdGhlIHJlc29sdmVkIFVSTCB3aWxsIGJlOlxuICogaHR0cDovL2V4YW1wbGUuY29tL3VwbG9hZC9hYmNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVVcmwob3JpZ2luLCBsaW5rKSB7XG4gIHJldHVybiBuZXcgX3VybFBhcnNlLmRlZmF1bHQobGluaywgb3JpZ2luKS50b1N0cmluZygpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIGZvciB0aGUgcGFydHMgaWYgYW4gdXBsb2FkXG4gKiBpcyBzcGxpdCBpbnRvIG11bHRpcGxlIHBhcmFsbGVsIHJlcXVlc3RzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbFNpemUgVGhlIGJ5dGUgc2l6ZSBvZiB0aGUgdXBsb2FkLCB3aGljaCB3aWxsIGJlIHNwbGl0LlxuICogQHBhcmFtIHtudW1iZXJ9IHBhcnRDb3VudCBUaGUgbnVtYmVyIGluIGhvdyBtYW55IHBhcnRzIHRoZSB1cGxvYWQgd2lsbCBiZSBzcGxpdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHByZXZpb3VzVXJscyBUaGUgdXBsb2FkIFVSTHMgZm9yIHByZXZpb3VzIHBhcnRzLlxuICogQHJldHVybiB7b2JqZWN0W119XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNwbGl0U2l6ZUludG9QYXJ0cyh0b3RhbFNpemUsIHBhcnRDb3VudCwgcHJldmlvdXNVcmxzKSB7XG4gIHZhciBwYXJ0U2l6ZSA9IE1hdGguZmxvb3IodG90YWxTaXplIC8gcGFydENvdW50KTtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0Q291bnQ7IGkrKykge1xuICAgIHBhcnRzLnB1c2goe1xuICAgICAgc3RhcnQ6IHBhcnRTaXplICogaSxcbiAgICAgIGVuZDogcGFydFNpemUgKiAoaSArIDEpXG4gICAgfSk7XG4gIH1cblxuICBwYXJ0c1twYXJ0Q291bnQgLSAxXS5lbmQgPSB0b3RhbFNpemU7IC8vIEF0dGFjaCBVUkxzIGZyb20gcHJldmlvdXMgdXBsb2FkcywgaWYgYXZhaWxhYmxlLlxuXG4gIGlmIChwcmV2aW91c1VybHMpIHtcbiAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0LCBpbmRleCkge1xuICAgICAgcGFydC51cGxvYWRVcmwgPSBwcmV2aW91c1VybHNbaW5kZXhdIHx8IG51bGw7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbkJhc2VVcGxvYWQuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbnZhciBfZGVmYXVsdCA9IEJhc2VVcGxvYWQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHV1aWQ7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBVVUlEIHY0IGJhc2VkIG9uIHJhbmRvbSBudW1iZXJzLiBXZSBpbnRlbnRpb2FubGx5IHVzZSB0aGUgbGVzc1xuICogc2VjdXJlIE1hdGgucmFuZG9tIGZ1bmN0aW9uIGhlcmUgc2luY2UgdGhlIG1vcmUgc2VjdXJlIGNyeXB0by5nZXRSYW5kb21OdW1iZXJzXG4gKiBpcyBub3QgYXZhaWxhYmxlIG9uIGFsbCBwbGF0Zm9ybXMuXG4gKiBUaGlzIGlzIG5vdCBhIHByb2JsZW0gZm9yIHVzIHNpbmNlIHdlIHVzZSB0aGUgVVVJRCBvbmx5IGZvciBnZW5lcmF0aW5nIGFcbiAqIHJlcXVlc3QgSUQsIHNvIHdlIGNhbiBjb3JyZWxhdGUgc2VydmVyIGxvZ3MgdG8gY2xpZW50IGVycm9ycy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHRha2VuIGZyb20gZm9sbG93aW5nIHNpdGU6XG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvY3JlYXRlLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0XG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZ2VuZXJhdGUgVVVJRFxuICovXG5mdW5jdGlvbiB1dWlkKCkge1xuICByZXR1cm4gXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIi5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLFxuICAgICAgICB2ID0gYyA9PSBcInhcIiA/IHIgOiByICYgMHgzIHwgMHg4O1xuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZWQgPSByZXF1aXJlKCdyZXF1aXJlcy1wb3J0JylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5naWZ5JylcbiAgLCBzbGFzaGVzID0gL15bQS1aYS16XVtBLVphLXowLTkrLS5dKjpbXFxcXC9dKy9cbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oW1xcXFwvXXsxLH0pPyhbXFxTXFxzXSopL2lcbiAgLCB3aGl0ZXNwYWNlID0gJ1tcXFxceDA5XFxcXHgwQVxcXFx4MEJcXFxceDBDXFxcXHgwRFxcXFx4MjBcXFxceEEwXFxcXHUxNjgwXFxcXHUxODBFXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBBXFxcXHUyMDJGXFxcXHUyMDVGXFxcXHUzMDAwXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHVGRUZGXSdcbiAgLCBsZWZ0ID0gbmV3IFJlZ0V4cCgnXicrIHdoaXRlc3BhY2UgKycrJyk7XG5cbi8qKlxuICogVHJpbSBhIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byB0cmltLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0cmltTGVmdChzdHIpIHtcbiAgcmV0dXJuIChzdHIgPyBzdHIgOiAnJykudG9TdHJpbmcoKS5yZXBsYWNlKGxlZnQsICcnKTtcbn1cblxuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIHBhcnNlIHJ1bGVzIGZvciB0aGUgVVJMIHBhcnNlciwgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXG4gKiBhYm91dDpcbiAqXG4gKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xuICogICAgaW5kZXhPZiwgUmVnRXhwIHVzaW5nIGV4ZWMgYW5kIE5hTiBtZWFucyBzZXQgYXMgY3VycmVudCB2YWx1ZS5cbiAqIDEuIFRoZSBwcm9wZXJ0eSB3ZSBzaG91bGQgc2V0IHdoZW4gcGFyc2luZyB0aGlzIHZhbHVlLlxuICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXG4gKiAgICB0aGUgdmFsdWUgb2YgZXh0cmEgY2hhcnMgdGhhdCBzaG91bGQgYmUgc3BsaXQgb2ZmLlxuICogMy4gSW5oZXJpdCBmcm9tIGxvY2F0aW9uIGlmIG5vbiBleGlzdGluZyBpbiB0aGUgcGFyc2VyLlxuICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICovXG52YXIgcnVsZXMgPSBbXG4gIFsnIycsICdoYXNoJ10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJz8nLCAncXVlcnknXSwgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgZnVuY3Rpb24gc2FuaXRpemUoYWRkcmVzcykgeyAgICAgICAgICAvLyBTYW5pdGl6ZSB3aGF0IGlzIGxlZnQgb2YgdGhlIGFkZHJlc3NcbiAgICByZXR1cm4gYWRkcmVzcy5yZXBsYWNlKCdcXFxcJywgJy8nKTtcbiAgfSxcbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbLzooXFxkKykkLywgJ3BvcnQnLCB1bmRlZmluZWQsIDFdLCAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9O1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIHZhciBnbG9iYWxWYXI7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSB3aW5kb3c7XG4gIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSBnbG9iYWw7XG4gIGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gc2VsZjtcbiAgZWxzZSBnbG9iYWxWYXIgPSB7fTtcblxuICB2YXIgbG9jYXRpb24gPSBnbG9iYWxWYXIubG9jYXRpb24gfHwge307XG4gIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MpIHtcbiAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuXG4gIHZhciBtYXRjaCA9IHByb3RvY29scmUuZXhlYyhhZGRyZXNzKVxuICAgICwgcHJvdG9jb2wgPSBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJ1xuICAgICwgc2xhc2hlcyA9ICEhKG1hdGNoWzJdICYmIG1hdGNoWzJdLmxlbmd0aCA+PSAyKVxuICAgICwgcmVzdCA9ICBtYXRjaFsyXSAmJiBtYXRjaFsyXS5sZW5ndGggPT09IDEgPyAnLycgKyBtYXRjaFszXSA6IG1hdGNoWzNdO1xuXG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IHByb3RvY29sLFxuICAgIHNsYXNoZXM6IHNsYXNoZXMsXG4gICAgcmVzdDogcmVzdFxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBVUkwgcGF0aG5hbWUgYWdhaW5zdCBhIGJhc2UgVVJMIHBhdGhuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGl2ZSBQYXRobmFtZSBvZiB0aGUgcmVsYXRpdmUgVVJMLlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2UgUGF0aG5hbWUgb2YgdGhlIGJhc2UgVVJMLlxuICogQHJldHVybiB7U3RyaW5nfSBSZXNvbHZlZCBwYXRobmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcbiAgaWYgKHJlbGF0aXZlID09PSAnJykgcmV0dXJuIGJhc2U7XG5cbiAgdmFyIHBhdGggPSAoYmFzZSB8fCAnLycpLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmNvbmNhdChyZWxhdGl2ZS5zcGxpdCgnLycpKVxuICAgICwgaSA9IHBhdGgubGVuZ3RoXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cbiAgICAsIHVuc2hpZnQgPSBmYWxzZVxuICAgICwgdXAgPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgdW5zaGlmdCA9IHRydWU7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHBhdGgudW5zaGlmdCgnJyk7XG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAqXG4gKiBJdCBpcyB3b3J0aCBub3RpbmcgdGhhdCB3ZSBzaG91bGQgbm90IHVzZSBgVVJMYCBhcyBjbGFzcyBuYW1lIHRvIHByZXZlbnRcbiAqIGNsYXNoZXMgd2l0aCB0aGUgZ2xvYmFsIFVSTCBpbnN0YW5jZSB0aGF0IGdvdCBpbnRyb2R1Y2VkIGluIGJyb3dzZXJzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gcGFyc2UuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtsb2NhdGlvbl0gTG9jYXRpb24gZGVmYXVsdHMgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBbcGFyc2VyXSBQYXJzZXIgZm9yIHRoZSBxdWVyeSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBhZGRyZXNzID0gdHJpbUxlZnQoYWRkcmVzcyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVybCkpIHtcbiAgICByZXR1cm4gbmV3IFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKTtcbiAgfVxuXG4gIHZhciByZWxhdGl2ZSwgZXh0cmFjdGVkLCBwYXJzZSwgaW5zdHJ1Y3Rpb24sIGluZGV4LCBrZXlcbiAgICAsIGluc3RydWN0aW9ucyA9IHJ1bGVzLnNsaWNlKClcbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jYXRpb25cbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIGkgPSAwO1xuXG4gIC8vXG4gIC8vIFRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50cyBhbGxvd3MgdGhpcyBtb2R1bGUgdHdvIGhhdmUgY29tcGF0aWJpbGl0eSB3aXRoXG4gIC8vIDIgZGlmZmVyZW50IEFQSTpcbiAgLy9cbiAgLy8gMS4gTm9kZS5qcydzIGB1cmwucGFyc2VgIGFwaSB3aGljaCBhY2NlcHRzIGEgVVJMLCBib29sZWFuIGFzIGFyZ3VtZW50c1xuICAvLyAgICB3aGVyZSB0aGUgYm9vbGVhbiBpbmRpY2F0ZXMgdGhhdCB0aGUgcXVlcnkgc3RyaW5nIHNob3VsZCBhbHNvIGJlIHBhcnNlZC5cbiAgLy9cbiAgLy8gMi4gVGhlIGBVUkxgIGludGVyZmFjZSBvZiB0aGUgYnJvd3NlciB3aGljaCBhY2NlcHRzIGEgVVJMLCBvYmplY3QgYXNcbiAgLy8gICAgYXJndW1lbnRzLiBUaGUgc3VwcGxpZWQgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHZhbHVlcyAvIGZhbGwtYmFja1xuICAvLyAgICBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gIC8vXG4gIGlmICgnb2JqZWN0JyAhPT0gdHlwZSAmJiAnc3RyaW5nJyAhPT0gdHlwZSkge1xuICAgIHBhcnNlciA9IGxvY2F0aW9uO1xuICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJzZXIgJiYgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHBhcnNlcikgcGFyc2VyID0gcXMucGFyc2U7XG5cbiAgbG9jYXRpb24gPSBsb2xjYXRpb24obG9jYXRpb24pO1xuXG4gIC8vXG4gIC8vIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gYmVmb3JlIHJ1bm5pbmcgdGhlIGluc3RydWN0aW9ucy5cbiAgLy9cbiAgZXh0cmFjdGVkID0gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MgfHwgJycpO1xuICByZWxhdGl2ZSA9ICFleHRyYWN0ZWQucHJvdG9jb2wgJiYgIWV4dHJhY3RlZC5zbGFzaGVzO1xuICB1cmwuc2xhc2hlcyA9IGV4dHJhY3RlZC5zbGFzaGVzIHx8IHJlbGF0aXZlICYmIGxvY2F0aW9uLnNsYXNoZXM7XG4gIHVybC5wcm90b2NvbCA9IGV4dHJhY3RlZC5wcm90b2NvbCB8fCBsb2NhdGlvbi5wcm90b2NvbCB8fCAnJztcbiAgYWRkcmVzcyA9IGV4dHJhY3RlZC5yZXN0O1xuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGF1dGhvcml0eSBjb21wb25lbnQgaXMgYWJzZW50IHRoZSBVUkwgc3RhcnRzIHdpdGggYSBwYXRoXG4gIC8vIGNvbXBvbmVudC5cbiAgLy9cbiAgaWYgKCFleHRyYWN0ZWQuc2xhc2hlcykgaW5zdHJ1Y3Rpb25zWzNdID0gWy8oLiopLywgJ3BhdGhuYW1lJ107XG5cbiAgZm9yICg7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcblxuICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFkZHJlc3MgPSBpbnN0cnVjdGlvbihhZGRyZXNzKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpZiAofihpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihwYXJzZSkpKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkpIHtcbiAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleC5pbmRleCk7XG4gICAgfVxuXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoXG4gICAgICByZWxhdGl2ZSAmJiBpbnN0cnVjdGlvblszXSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJ1xuICAgICk7XG5cbiAgICAvL1xuICAgIC8vIEhvc3RuYW1lLCBob3N0IGFuZCBwcm90b2NvbCBzaG91bGQgYmUgbG93ZXJjYXNlZCBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxuICAgIC8vXG4gICAgaWYgKGluc3RydWN0aW9uWzRdKSB1cmxba2V5XSA9IHVybFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvL1xuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXG4gIC8vIHBhcnNlci5cbiAgLy9cbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XG5cbiAgLy9cbiAgLy8gSWYgdGhlIFVSTCBpcyByZWxhdGl2ZSwgcmVzb2x2ZSB0aGUgcGF0aG5hbWUgYWdhaW5zdCB0aGUgYmFzZSBVUkwuXG4gIC8vXG4gIGlmIChcbiAgICAgIHJlbGF0aXZlXG4gICAgJiYgbG9jYXRpb24uc2xhc2hlc1xuICAgICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJ1xuICAgICYmICh1cmwucGF0aG5hbWUgIT09ICcnIHx8IGxvY2F0aW9uLnBhdGhuYW1lICE9PSAnJylcbiAgKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gcmVzb2x2ZSh1cmwucGF0aG5hbWUsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfVxuXG4gIC8vXG4gIC8vIERlZmF1bHQgdG8gYSAvIGZvciBwYXRobmFtZSBpZiBub25lIGV4aXN0cy4gVGhpcyBub3JtYWxpemVzIHRoZSBVUkxcbiAgLy8gdG8gYWx3YXlzIGhhdmUgYSAvXG4gIC8vXG4gIGlmICh1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycgJiYgdXJsLmhvc3RuYW1lKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gJy8nICsgdXJsLnBhdGhuYW1lO1xuICB9XG5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIG5vdCBhZGQgcG9ydCBudW1iZXJzIGlmIHRoZXkgYXJlIGFscmVhZHkgdGhlIGRlZmF1bHQgcG9ydCBudW1iZXJcbiAgLy8gZm9yIGEgZ2l2ZW4gcHJvdG9jb2wuIEFzIHRoZSBob3N0IGFsc28gY29udGFpbnMgdGhlIHBvcnQgbnVtYmVyIHdlJ3JlIGdvaW5nXG4gIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGhvc3RuYW1lIHdoaWNoIGNvbnRhaW5zIG5vIHBvcnQgbnVtYmVyLlxuICAvL1xuICBpZiAoIXJlcXVpcmVkKHVybC5wb3J0LCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgdXJsLnBvcnQgPSAnJztcbiAgfVxuXG4gIC8vXG4gIC8vIFBhcnNlIGRvd24gdGhlIGBhdXRoYCBmb3IgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cbiAgLy9cbiAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XG4gIGlmICh1cmwuYXV0aCkge1xuICAgIGluc3RydWN0aW9uID0gdXJsLmF1dGguc3BsaXQoJzonKTtcbiAgICB1cmwudXNlcm5hbWUgPSBpbnN0cnVjdGlvblswXSB8fCAnJztcbiAgICB1cmwucGFzc3dvcmQgPSBpbnN0cnVjdGlvblsxXSB8fCAnJztcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgLy9cbiAgLy8gVGhlIGhyZWYgaXMganVzdCB0aGUgY29tcGlsZWQgcmVzdWx0LlxuICAvL1xuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjaGFuZ2luZyBwcm9wZXJ0aWVzIGluIHRoZSBVUkwgaW5zdGFuY2UgdG9cbiAqIGluc3VyZSB0aGF0IHRoZXkgYWxsIHByb3BhZ2F0ZSBjb3JyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcnQgICAgICAgICAgUHJvcGVydHkgd2UgbmVlZCB0byBhZGp1c3QuXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAgICAgICAgICBUaGUgbmV3bHkgYXNzaWduZWQgdmFsdWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IGZuICBXaGVuIHNldHRpbmcgdGhlIHF1ZXJ5LCBpdCB3aWxsIGJlIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCB0byBwYXJzZSB0aGUgcXVlcnkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHNldHRpbmcgdGhlIHByb3RvY29sLCBkb3VibGUgc2xhc2ggd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCBmcm9tIHRoZSBmaW5hbCB1cmwgaWYgaXQgaXMgdHJ1ZS5cbiAqIEByZXR1cm5zIHtVUkx9IFVSTCBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNldChwYXJ0LCB2YWx1ZSwgZm4pIHtcbiAgdmFyIHVybCA9IHRoaXM7XG5cbiAgc3dpdGNoIChwYXJ0KSB7XG4gICAgY2FzZSAncXVlcnknOlxuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gKGZuIHx8IHFzLnBhcnNlKSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwb3J0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoIXJlcXVpcmVkKHZhbHVlLCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICB1cmxbcGFydF0gPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWUgKyc6JysgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdG5hbWUnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICh1cmwucG9ydCkgdmFsdWUgKz0gJzonKyB1cmwucG9ydDtcbiAgICAgIHVybC5ob3N0ID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3QnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICgvOlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgIHVybC5wb3J0ID0gdmFsdWUucG9wKCk7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlLmpvaW4oJzonKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlO1xuICAgICAgICB1cmwucG9ydCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Byb3RvY29sJzpcbiAgICAgIHVybC5wcm90b2NvbCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB1cmwuc2xhc2hlcyA9ICFmbjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncGF0aG5hbWUnOlxuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBjaGFyID0gcGFydCA9PT0gJ3BhdGhuYW1lJyA/ICcvJyA6ICcjJztcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWUuY2hhckF0KDApICE9PSBjaGFyID8gY2hhciArIHZhbHVlIDogdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnMgPSBydWxlc1tpXTtcblxuICAgIGlmIChpbnNbNF0pIHVybFtpbnNbMV1dID0gdXJsW2luc1sxXV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcblxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBiYWNrIGluIHRvIGEgdmFsaWQgYW5kIGZ1bGwgVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxuICogQHJldHVybnMge1N0cmluZ30gQ29tcGlsZWQgdmVyc2lvbiBvZiB0aGUgVVJMLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xuXG4gIHZhciBxdWVyeVxuICAgICwgdXJsID0gdGhpc1xuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgdmFyIHJlc3VsdCA9IHByb3RvY29sICsgKHVybC5zbGFzaGVzID8gJy8vJyA6ICcnKTtcblxuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgcmVzdWx0ICs9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwuaG9zdCArIHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblVybC5wcm90b3R5cGUgPSB7IHNldDogc2V0LCB0b1N0cmluZzogdG9TdHJpbmcgfTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgVVJMIHBhcnNlciBhbmQgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSB1c2VmdWwgZm9yXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cbi8vXG5VcmwuZXh0cmFjdFByb3RvY29sID0gZXh0cmFjdFByb3RvY29sO1xuVXJsLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuVXJsLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG5VcmwucXMgPSBxcztcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KChnbG9iYWwuV0hBVFdHRmV0Y2ggPSB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZ2xvYmFsID1cbiAgICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMpIHx8XG4gICAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmKSB8fFxuICAgICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwpO1xuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gZ2xvYmFsLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBnbG9iYWwgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjpcbiAgICAgICdGaWxlUmVhZGVyJyBpbiBnbG9iYWwgJiZcbiAgICAgICdCbG9iJyBpbiBnbG9iYWwgJiZcbiAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBnbG9iYWwsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gZ2xvYmFsXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgfVxuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXTtcblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9XG4gICAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgfHxcbiAgICAgIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5eX2B8fiFdL2kudGVzdChuYW1lKSB8fCBuYW1lID09PSAnJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWU6IFwiJyArIG5hbWUgKyAnXCInKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdO1xuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV07XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgaXRlbXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICAgIH1cbiAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICB9O1xuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcik7XG4gICAgICB9O1xuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpO1xuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIC8qXG4gICAgICAgIGZldGNoLW1vY2sgd3JhcHMgdGhlIFJlc3BvbnNlIG9iamVjdCBpbiBhbiBFUzYgUHJveHkgdG9cbiAgICAgICAgcHJvdmlkZSB1c2VmdWwgdGVzdCBoYXJuZXNzIGZlYXR1cmVzIHN1Y2ggYXMgZmx1c2guIEhvd2V2ZXIsIG9uXG4gICAgICAgIEVTNSBicm93c2VycyB3aXRob3V0IGZldGNoIG9yIFByb3h5IHN1cHBvcnQgcG9sbHlmaWxscyBtdXN0IGJlIHVzZWQ7XG4gICAgICAgIHRoZSBwcm94eS1wb2xseWZpbGwgaXMgdW5hYmxlIHRvIHByb3h5IGFuIGF0dHJpYnV0ZSB1bmxlc3MgaXQgZXhpc3RzXG4gICAgICAgIG9uIHRoZSBvYmplY3QgYmVmb3JlIHRoZSBQcm94eSBpcyBjcmVhdGVkLiBUaGlzIGNoYW5nZSBlbnN1cmVzXG4gICAgICAgIFJlc3BvbnNlLmJvZHlVc2VkIGV4aXN0cyBvbiB0aGUgaW5zdGFuY2UsIHdoaWxlIG1haW50YWluaW5nIHRoZVxuICAgICAgICBzZW1hbnRpYyBvZiBzZXR0aW5nIFJlcXVlc3QuYm9keVVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgICBfaW5pdEJvZHkgaXMgY2FsbGVkLlxuICAgICAgKi9cbiAgICAgIHRoaXMuYm9keVVzZWQgPSB0aGlzLmJvZHlVc2VkO1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5O1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpO1xuICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICB2YXIgaXNDb25zdW1lZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICAgIGlmIChpc0NvbnN1bWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNDb25zdW1lZFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5idWZmZXIuc2xpY2UoXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQgKyB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gbWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHk7XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsO1xuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzO1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycyk7XG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZDtcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGU7XG4gICAgICB0aGlzLnNpZ25hbCA9IGlucHV0LnNpZ25hbDtcbiAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0O1xuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbic7XG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJyk7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsO1xuICAgIHRoaXMuc2lnbmFsID0gb3B0aW9ucy5zaWduYWwgfHwgdGhpcy5zaWduYWw7XG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGw7XG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpO1xuXG4gICAgaWYgKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICBpZiAob3B0aW9ucy5jYWNoZSA9PT0gJ25vLXN0b3JlJyB8fCBvcHRpb25zLmNhY2hlID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYSAnXycgcGFyYW1ldGVyIGluIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgICAgdmFyIHJlUGFyYW1TZWFyY2ggPSAvKFs/Jl0pXz1bXiZdKi87XG4gICAgICAgIGlmIChyZVBhcmFtU2VhcmNoLnRlc3QodGhpcy51cmwpKSB7XG4gICAgICAgICAgLy8gSWYgaXQgYWxyZWFkeSBleGlzdHMgdGhlbiBzZXQgdGhlIHZhbHVlIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICAgIHRoaXMudXJsID0gdGhpcy51cmwucmVwbGFjZShyZVBhcmFtU2VhcmNoLCAnJDFfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBhIG5ldyAnXycgcGFyYW1ldGVyIHRvIHRoZSBlbmQgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgICAgdmFyIHJlUXVlcnlTdHJpbmcgPSAvXFw/LztcbiAgICAgICAgICB0aGlzLnVybCArPSAocmVRdWVyeVN0cmluZy50ZXN0KHRoaXMudXJsKSA/ICcmJyA6ICc/JykgKyAnXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoJyYnKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICAvLyBBdm9pZGluZyBzcGxpdCB2aWEgcmVnZXggdG8gd29yayBhcm91bmQgYSBjb21tb24gSUUxMSBidWcgd2l0aCB0aGUgY29yZS1qcyAzLjYuMCByZWdleCBwb2x5ZmlsbFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gvaXNzdWVzLzc0OFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy83NTFcbiAgICBwcmVQcm9jZXNzZWRIZWFkZXJzXG4gICAgICAuc3BsaXQoJ1xccicpXG4gICAgICAubWFwKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICByZXR1cm4gaGVhZGVyLmluZGV4T2YoJ1xcbicpID09PSAwID8gaGVhZGVyLnN1YnN0cigxLCBoZWFkZXIubGVuZ3RoKSA6IGhlYWRlclxuICAgICAgfSlcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpO1xuICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gb3B0aW9ucy5zdGF0dXNUZXh0ID09PSB1bmRlZmluZWQgPyAnJyA6ICcnICsgb3B0aW9ucy5zdGF0dXNUZXh0O1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJztcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7XG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9O1xuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH07XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH07XG5cbiAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBnbG9iYWwuRE9NRXhjZXB0aW9uO1xuICB0cnkge1xuICAgIG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgfTtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZXhwb3J0cy5ET01FeGNlcHRpb247XG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaChpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgZnVuY3Rpb24gYWJvcnRYaHIoKSB7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpO1xuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZWplY3QobmV3IGV4cG9ydHMuRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gZml4VXJsKHVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cmwgPT09ICcnICYmIGdsb2JhbC5sb2NhdGlvbi5ocmVmID8gZ2xvYmFsLmxvY2F0aW9uLmhyZWYgOiB1cmxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiB1cmxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgZml4VXJsKHJlcXVlc3QudXJsKSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgc3VwcG9ydC5hcnJheUJ1ZmZlciAmJlxuICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICYmXG4gICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykuaW5kZXhPZignYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykgIT09IC0xXG4gICAgICAgICkge1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbml0ICYmIHR5cGVvZiBpbml0LmhlYWRlcnMgPT09ICdvYmplY3QnICYmICEoaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykpIHtcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5pdC5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBub3JtYWxpemVWYWx1ZShpbml0LmhlYWRlcnNbbmFtZV0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKTtcblxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gRE9ORSAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KTtcbiAgICB9KVxuICB9XG5cbiAgZmV0Y2gucG9seWZpbGwgPSB0cnVlO1xuXG4gIGlmICghZ2xvYmFsLmZldGNoKSB7XG4gICAgZ2xvYmFsLmZldGNoID0gZmV0Y2g7XG4gICAgZ2xvYmFsLkhlYWRlcnMgPSBIZWFkZXJzO1xuICAgIGdsb2JhbC5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgICBnbG9iYWwuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgfVxuXG4gIGV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4gIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvKiBqc2hpbnQgbm9kZTogdHJ1ZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAgIyB3aWxkY2FyZFxuXG4gIFZlcnkgc2ltcGxlIHdpbGRjYXJkIG1hdGNoaW5nLCB3aGljaCBpcyBkZXNpZ25lZCB0byBwcm92aWRlIHRoZSBzYW1lXG4gIGZ1bmN0aW9uYWxpdHkgdGhhdCBpcyBmb3VuZCBpbiB0aGVcbiAgW2V2ZV0oaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlLXdlYnBsYXRmb3JtL2V2ZSkgZXZlbnRpbmcgbGlicmFyeS5cblxuICAjIyBVc2FnZVxuXG4gIEl0IHdvcmtzIHdpdGggc3RyaW5nczpcblxuICA8PDwgZXhhbXBsZXMvc3RyaW5ncy5qc1xuXG4gIEFycmF5czpcblxuICA8PDwgZXhhbXBsZXMvYXJyYXlzLmpzXG5cbiAgT2JqZWN0cyAobWF0Y2hpbmcgYWdhaW5zdCBrZXlzKTpcblxuICA8PDwgZXhhbXBsZXMvb2JqZWN0cy5qc1xuXG4gIFdoaWxlIHRoZSBsaWJyYXJ5IHdvcmtzIGluIE5vZGUsIGlmIHlvdSBhcmUgYXJlIGxvb2tpbmcgZm9yIGZpbGUtYmFzZWRcbiAgd2lsZGNhcmQgbWF0Y2hpbmcgdGhlbiB5b3Ugc2hvdWxkIGhhdmUgYSBsb29rIGF0OlxuXG4gIDxodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYj5cbioqL1xuXG5mdW5jdGlvbiBXaWxkY2FyZE1hdGNoZXIodGV4dCwgc2VwYXJhdG9yKSB7XG4gIHRoaXMudGV4dCA9IHRleHQgPSB0ZXh0IHx8ICcnO1xuICB0aGlzLmhhc1dpbGQgPSB+dGV4dC5pbmRleE9mKCcqJyk7XG4gIHRoaXMuc2VwYXJhdG9yID0gc2VwYXJhdG9yO1xuICB0aGlzLnBhcnRzID0gdGV4dC5zcGxpdChzZXBhcmF0b3IpO1xufVxuXG5XaWxkY2FyZE1hdGNoZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIG1hdGNoZXMgPSB0cnVlO1xuICB2YXIgcGFydHMgPSB0aGlzLnBhcnRzO1xuICB2YXIgaWk7XG4gIHZhciBwYXJ0c0NvdW50ID0gcGFydHMubGVuZ3RoO1xuICB2YXIgdGVzdFBhcnRzO1xuXG4gIGlmICh0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuaGFzV2lsZCAmJiB0aGlzLnRleHQgIT0gaW5wdXQpIHtcbiAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGVzdFBhcnRzID0gKGlucHV0IHx8ICcnKS5zcGxpdCh0aGlzLnNlcGFyYXRvcik7XG4gICAgICBmb3IgKGlpID0gMDsgbWF0Y2hlcyAmJiBpaSA8IHBhcnRzQ291bnQ7IGlpKyspIHtcbiAgICAgICAgaWYgKHBhcnRzW2lpXSA9PT0gJyonKSAge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlpIDwgdGVzdFBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgIG1hdGNoZXMgPSBwYXJ0c1tpaV0gPT09IHRlc3RQYXJ0c1tpaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG1hdGNoZXMsIHRoZW4gcmV0dXJuIHRoZSBjb21wb25lbnQgcGFydHNcbiAgICAgIG1hdGNoZXMgPSBtYXRjaGVzICYmIHRlc3RQYXJ0cztcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGlucHV0LnNwbGljZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgbWF0Y2hlcyA9IFtdO1xuXG4gICAgZm9yIChpaSA9IGlucHV0Lmxlbmd0aDsgaWktLTsgKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaChpbnB1dFtpaV0pKSB7XG4gICAgICAgIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGhdID0gaW5wdXRbaWldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT0gJ29iamVjdCcpIHtcbiAgICBtYXRjaGVzID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKGtleSkpIHtcbiAgICAgICAgbWF0Y2hlc1trZXldID0gaW5wdXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGV4dCwgdGVzdCwgc2VwYXJhdG9yKSB7XG4gIHZhciBtYXRjaGVyID0gbmV3IFdpbGRjYXJkTWF0Y2hlcih0ZXh0LCBzZXBhcmF0b3IgfHwgL1tcXC9cXC5dLyk7XG4gIGlmICh0eXBlb2YgdGVzdCAhPSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBtYXRjaGVyLm1hdGNoKHRlc3QpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXI7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJDbGllbnQgbGlicmFyeSBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIENvbXBhbmlvbi4gSW50ZW5kZWQgZm9yIHVzZSBpbiBVcHB5IHBsdWdpbnMuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuMTAuMlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcImNvbXBhbmlvblwiLFxuICAgIFwicHJvdmlkZXJcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwibmFtZXNwYWNlLWVtaXR0ZXJcIjogXCJeMi4wLjFcIixcbiAgICBcInFzLXN0cmluZ2lmeVwiOiBcIl4xLjEuMFwiLFxuICAgIFwidXJsLXBhcnNlXCI6IFwiXjEuNC43XCJcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIEF1dGhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKCdBdXRob3JpemF0aW9uIHJlcXVpcmVkJylcbiAgICB0aGlzLm5hbWUgPSAnQXV0aEVycm9yJ1xuICAgIHRoaXMuaXNBdXRoRXJyb3IgPSB0cnVlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBdXRoRXJyb3JcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBxc1N0cmluZ2lmeSA9IHJlcXVpcmUoJ3FzLXN0cmluZ2lmeScpXG5jb25zdCBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxuY29uc3QgUmVxdWVzdENsaWVudCA9IHJlcXVpcmUoJy4vUmVxdWVzdENsaWVudCcpXG5jb25zdCB0b2tlblN0b3JhZ2UgPSByZXF1aXJlKCcuL3Rva2VuU3RvcmFnZScpXG5cbmNvbnN0IF9nZXROYW1lID0gKGlkKSA9PiB7XG4gIHJldHVybiBpZC5zcGxpdCgnLScpLm1hcCgocykgPT4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSkpLmpvaW4oJyAnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFByb3ZpZGVyIGV4dGVuZHMgUmVxdWVzdENsaWVudCB7XG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0cy5wcm92aWRlclxuICAgIHRoaXMuaWQgPSB0aGlzLnByb3ZpZGVyXG4gICAgdGhpcy5uYW1lID0gdGhpcy5vcHRzLm5hbWUgfHwgX2dldE5hbWUodGhpcy5pZClcbiAgICB0aGlzLnBsdWdpbklkID0gdGhpcy5vcHRzLnBsdWdpbklkXG4gICAgdGhpcy50b2tlbktleSA9IGBjb21wYW5pb24tJHt0aGlzLnBsdWdpbklkfS1hdXRoLXRva2VuYFxuICAgIHRoaXMuY29tcGFuaW9uS2V5c1BhcmFtcyA9IHRoaXMub3B0cy5jb21wYW5pb25LZXlzUGFyYW1zXG4gICAgdGhpcy5wcmVBdXRoVG9rZW4gPSBudWxsXG4gIH1cblxuICBoZWFkZXJzICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3N1cGVyLmhlYWRlcnMoKSwgdGhpcy5nZXRBdXRoVG9rZW4oKV0pXG4gICAgICAudGhlbigoW2hlYWRlcnMsIHRva2VuXSkgPT4ge1xuICAgICAgICBjb25zdCBhdXRoSGVhZGVycyA9IHt9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIGF1dGhIZWFkZXJzWyd1cHB5LWF1dGgtdG9rZW4nXSA9IHRva2VuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb21wYW5pb25LZXlzUGFyYW1zKSB7XG4gICAgICAgICAgYXV0aEhlYWRlcnNbJ3VwcHktY3JlZGVudGlhbHMtcGFyYW1zJ10gPSBidG9hKFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyBwYXJhbXM6IHRoaXMuY29tcGFuaW9uS2V5c1BhcmFtcyB9KVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAuLi5oZWFkZXJzLCAuLi5hdXRoSGVhZGVycyB9XG4gICAgICB9KVxuICB9XG5cbiAgb25SZWNlaXZlUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgcmVzcG9uc2UgPSBzdXBlci5vblJlY2VpdmVSZXNwb25zZShyZXNwb25zZSlcbiAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMucGx1Z2luSWQpXG4gICAgY29uc3Qgb2xkQXV0aGVudGljYXRlZCA9IHBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpLmF1dGhlbnRpY2F0ZWRcbiAgICBjb25zdCBhdXRoZW50aWNhdGVkID0gb2xkQXV0aGVudGljYXRlZCA/IHJlc3BvbnNlLnN0YXR1cyAhPT0gNDAxIDogcmVzcG9uc2Uuc3RhdHVzIDwgNDAwXG4gICAgcGx1Z2luLnNldFBsdWdpblN0YXRlKHsgYXV0aGVudGljYXRlZCB9KVxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLy8gQHRvZG8oaS5vbGFyZXdhanUpIGNvbnNpZGVyIHdoZXRoZXIgb3Igbm90IHRoaXMgbWV0aG9kIHNob3VsZCBiZSBleHBvc2VkXG4gIHNldEF1dGhUb2tlbiAodG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy51cHB5LmdldFBsdWdpbih0aGlzLnBsdWdpbklkKS5zdG9yYWdlLnNldEl0ZW0odGhpcy50b2tlbktleSwgdG9rZW4pXG4gIH1cblxuICBnZXRBdXRoVG9rZW4gKCkge1xuICAgIHJldHVybiB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMucGx1Z2luSWQpLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnRva2VuS2V5KVxuICB9XG5cbiAgYXV0aFVybCAocXVlcmllcyA9IHt9KSB7XG4gICAgaWYgKHRoaXMucHJlQXV0aFRva2VuKSB7XG4gICAgICBxdWVyaWVzLnVwcHlQcmVBdXRoVG9rZW4gPSB0aGlzLnByZUF1dGhUb2tlblxuICAgIH1cblxuICAgIGxldCBzdHJpZ2lmaWVkUXVlcmllcyA9IHFzU3RyaW5naWZ5KHF1ZXJpZXMpXG4gICAgc3RyaWdpZmllZFF1ZXJpZXMgPSBzdHJpZ2lmaWVkUXVlcmllcyA/IGA/JHtzdHJpZ2lmaWVkUXVlcmllc31gIDogc3RyaWdpZmllZFF1ZXJpZXNcbiAgICByZXR1cm4gYCR7dGhpcy5ob3N0bmFtZX0vJHt0aGlzLmlkfS9jb25uZWN0JHtzdHJpZ2lmaWVkUXVlcmllc31gXG4gIH1cblxuICBmaWxlVXJsIChpZCkge1xuICAgIHJldHVybiBgJHt0aGlzLmhvc3RuYW1lfS8ke3RoaXMuaWR9L2dldC8ke2lkfWBcbiAgfVxuXG4gIGZldGNoUHJlQXV0aFRva2VuICgpIHtcbiAgICBpZiAoIXRoaXMuY29tcGFuaW9uS2V5c1BhcmFtcykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucG9zdChgJHt0aGlzLmlkfS9wcmVhdXRoL2AsIHsgcGFyYW1zOiB0aGlzLmNvbXBhbmlvbktleXNQYXJhbXMgfSlcbiAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgdGhpcy5wcmVBdXRoVG9rZW4gPSByZXMudG9rZW5cbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LmxvZyhgW0NvbXBhbmlvbkNsaWVudF0gdW5hYmxlIHRvIGZldGNoIHByZUF1dGhUb2tlbiAke2Vycn1gLCAnd2FybmluZycpXG4gICAgICB9KVxuICB9XG5cbiAgbGlzdCAoZGlyZWN0b3J5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAke3RoaXMuaWR9L2xpc3QvJHtkaXJlY3RvcnkgfHwgJyd9YClcbiAgfVxuXG4gIGxvZ291dCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAke3RoaXMuaWR9L2xvZ291dGApXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IFByb21pc2UuYWxsKFtcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHRoaXMudXBweS5nZXRQbHVnaW4odGhpcy5wbHVnaW5JZCkuc3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMudG9rZW5LZXkpLFxuICAgICAgXSkpLnRoZW4oKFtyZXNwb25zZV0pID0+IHJlc3BvbnNlKVxuICB9XG5cbiAgc3RhdGljIGluaXRQbHVnaW4gKHBsdWdpbiwgb3B0cywgZGVmYXVsdE9wdHMpIHtcbiAgICBwbHVnaW4udHlwZSA9ICdhY3F1aXJlcidcbiAgICBwbHVnaW4uZmlsZXMgPSBbXVxuICAgIGlmIChkZWZhdWx0T3B0cykge1xuICAgICAgcGx1Z2luLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRzLCAuLi5vcHRzIH1cbiAgICB9XG5cbiAgICBpZiAob3B0cy5zZXJ2ZXJVcmwgfHwgb3B0cy5zZXJ2ZXJQYXR0ZXJuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BzZXJ2ZXJVcmxgIGFuZCBgc2VydmVyUGF0dGVybmAgaGF2ZSBiZWVuIHJlbmFtZWQgdG8gYGNvbXBhbmlvblVybGAgYW5kIGBjb21wYW5pb25BbGxvd2VkSG9zdHNgIHJlc3BlY3RpdmVseSBpbiB0aGUgMC4zMC41IHJlbGVhc2UuIFBsZWFzZSBjb25zdWx0IHRoZSBkb2NzIChmb3IgZXhhbXBsZSwgaHR0cHM6Ly91cHB5LmlvL2RvY3MvaW5zdGFncmFtLyBmb3IgdGhlIEluc3RhZ3JhbSBwbHVnaW4pIGFuZCB1c2UgdGhlIHVwZGF0ZWQgb3B0aW9ucy5gJylcbiAgICB9XG5cbiAgICBpZiAob3B0cy5jb21wYW5pb25BbGxvd2VkSG9zdHMpIHtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBvcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0c1xuICAgICAgLy8gdmFsaWRhdGUgY29tcGFuaW9uQWxsb3dlZEhvc3RzIHBhcmFtXG4gICAgICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KHBhdHRlcm4pICYmICEocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtwbHVnaW4uaWR9OiB0aGUgb3B0aW9uIFwiY29tcGFuaW9uQWxsb3dlZEhvc3RzXCIgbXVzdCBiZSBvbmUgb2Ygc3RyaW5nLCBBcnJheSwgUmVnRXhwYClcbiAgICAgIH1cbiAgICAgIHBsdWdpbi5vcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0cyA9IHBhdHRlcm5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG9lcyBub3Qgc3RhcnQgd2l0aCBodHRwczovL1xuICAgICAgaWYgKC9eKD8haHR0cHM/OlxcL1xcLykuKiQvaS50ZXN0KG9wdHMuY29tcGFuaW9uVXJsKSkge1xuICAgICAgICBwbHVnaW4ub3B0cy5jb21wYW5pb25BbGxvd2VkSG9zdHMgPSBgaHR0cHM6Ly8ke29wdHMuY29tcGFuaW9uVXJsLnJlcGxhY2UoL15cXC9cXC8vLCAnJyl9YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGx1Z2luLm9wdHMuY29tcGFuaW9uQWxsb3dlZEhvc3RzID0gbmV3IFVSTChvcHRzLmNvbXBhbmlvblVybCkub3JpZ2luXG4gICAgICB9XG4gICAgfVxuXG4gICAgcGx1Z2luLnN0b3JhZ2UgPSBwbHVnaW4ub3B0cy5zdG9yYWdlIHx8IHRva2VuU3RvcmFnZVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQXV0aEVycm9yID0gcmVxdWlyZSgnLi9BdXRoRXJyb3InKVxuY29uc3QgZmV0Y2hXaXRoTmV0d29ya0Vycm9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2ZldGNoV2l0aE5ldHdvcmtFcnJvcicpXG5cbi8vIFJlbW92ZSB0aGUgdHJhaWxpbmcgc2xhc2ggc28gd2UgY2FuIGFsd2F5cyBzYWZlbHkgYXBwZW5kIC94eXouXG5mdW5jdGlvbiBzdHJpcFNsYXNoICh1cmwpIHtcbiAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmVxdWVzdENsaWVudCB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgdGhpcy51cHB5ID0gdXBweVxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLm9uUmVjZWl2ZVJlc3BvbnNlID0gdGhpcy5vblJlY2VpdmVSZXNwb25zZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5hbGxvd2VkSGVhZGVycyA9IFsnYWNjZXB0JywgJ2NvbnRlbnQtdHlwZScsICd1cHB5LWF1dGgtdG9rZW4nXVxuICAgIHRoaXMucHJlZmxpZ2h0RG9uZSA9IGZhbHNlXG4gIH1cblxuICBnZXQgaG9zdG5hbWUgKCkge1xuICAgIGNvbnN0IHsgY29tcGFuaW9uIH0gPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IGhvc3QgPSB0aGlzLm9wdHMuY29tcGFuaW9uVXJsXG4gICAgcmV0dXJuIHN0cmlwU2xhc2goY29tcGFuaW9uICYmIGNvbXBhbmlvbltob3N0XSA/IGNvbXBhbmlvbltob3N0XSA6IGhvc3QpXG4gIH1cblxuICBnZXQgZGVmYXVsdEhlYWRlcnMgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnVXBweS1WZXJzaW9ucyc6IGBAdXBweS9jb21wYW5pb24tY2xpZW50PSR7UmVxdWVzdENsaWVudC5WRVJTSU9OfWAsXG4gICAgfVxuICB9XG5cbiAgaGVhZGVycyAoKSB7XG4gICAgY29uc3QgdXNlckhlYWRlcnMgPSB0aGlzLm9wdHMuY29tcGFuaW9uSGVhZGVycyB8fCB0aGlzLm9wdHMuc2VydmVySGVhZGVycyB8fCB7fVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgLi4udGhpcy5kZWZhdWx0SGVhZGVycyxcbiAgICAgIC4uLnVzZXJIZWFkZXJzLFxuICAgIH0pXG4gIH1cblxuICBfZ2V0UG9zdFJlc3BvbnNlRnVuYyAoc2tpcCkge1xuICAgIHJldHVybiAocmVzcG9uc2UpID0+IHtcbiAgICAgIGlmICghc2tpcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vblJlY2VpdmVSZXNwb25zZShyZXNwb25zZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfVxuICB9XG5cbiAgb25SZWNlaXZlUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IGNvbXBhbmlvbiA9IHN0YXRlLmNvbXBhbmlvbiB8fCB7fVxuICAgIGNvbnN0IGhvc3QgPSB0aGlzLm9wdHMuY29tcGFuaW9uVXJsXG4gICAgY29uc3QgaGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAvLyBTdG9yZSB0aGUgc2VsZi1pZGVudGlmaWVkIGRvbWFpbiBuYW1lIGZvciB0aGUgQ29tcGFuaW9uIGluc3RhbmNlIHdlIGp1c3QgaGl0LlxuICAgIGlmIChoZWFkZXJzLmhhcygnaS1hbScpICYmIGhlYWRlcnMuZ2V0KCdpLWFtJykgIT09IGNvbXBhbmlvbltob3N0XSkge1xuICAgICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgICAgY29tcGFuaW9uOiB7IC4uLmNvbXBhbmlvbiwgW2hvc3RdOiBoZWFkZXJzLmdldCgnaS1hbScpIH0sXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIF9nZXRVcmwgKHVybCkge1xuICAgIGlmICgvXihodHRwcz86fClcXC9cXC8vLnRlc3QodXJsKSkge1xuICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgICByZXR1cm4gYCR7dGhpcy5ob3N0bmFtZX0vJHt1cmx9YFxuICB9XG5cbiAgX2pzb24gKHJlcykge1xuICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgIHRocm93IG5ldyBBdXRoRXJyb3IoKVxuICAgIH1cblxuICAgIGlmIChyZXMuc3RhdHVzIDwgMjAwIHx8IHJlcy5zdGF0dXMgPiAzMDApIHtcbiAgICAgIGxldCBlcnJNc2cgPSBgRmFpbGVkIHJlcXVlc3Qgd2l0aCBzdGF0dXM6ICR7cmVzLnN0YXR1c30uICR7cmVzLnN0YXR1c1RleHR9YFxuICAgICAgcmV0dXJuIHJlcy5qc29uKClcbiAgICAgICAgLnRoZW4oKGVyckRhdGEpID0+IHtcbiAgICAgICAgICBlcnJNc2cgPSBlcnJEYXRhLm1lc3NhZ2UgPyBgJHtlcnJNc2d9IG1lc3NhZ2U6ICR7ZXJyRGF0YS5tZXNzYWdlfWAgOiBlcnJNc2dcbiAgICAgICAgICBlcnJNc2cgPSBlcnJEYXRhLnJlcXVlc3RJZCA/IGAke2Vyck1zZ30gcmVxdWVzdC1JZDogJHtlcnJEYXRhLnJlcXVlc3RJZH1gIDogZXJyTXNnXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZylcbiAgICAgICAgfSkuY2F0Y2goKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKSB9KVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpzb24oKVxuICB9XG5cbiAgcHJlZmxpZ2h0IChwYXRoKSB7XG4gICAgaWYgKHRoaXMucHJlZmxpZ2h0RG9uZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFsbG93ZWRIZWFkZXJzLnNsaWNlKCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZldGNoKHRoaXMuX2dldFVybChwYXRoKSwge1xuICAgICAgbWV0aG9kOiAnT1BUSU9OUycsXG4gICAgfSlcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVycy5oYXMoJ2FjY2Vzcy1jb250cm9sLWFsbG93LWhlYWRlcnMnKSkge1xuICAgICAgICAgIHRoaXMuYWxsb3dlZEhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnYWNjZXNzLWNvbnRyb2wtYWxsb3ctaGVhZGVycycpXG4gICAgICAgICAgICAuc3BsaXQoJywnKS5tYXAoKGhlYWRlck5hbWUpID0+IGhlYWRlck5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVmbGlnaHREb25lID0gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcy5hbGxvd2VkSGVhZGVycy5zbGljZSgpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LmxvZyhgW0NvbXBhbmlvbkNsaWVudF0gdW5hYmxlIHRvIG1ha2UgcHJlZmxpZ2h0IHJlcXVlc3QgJHtlcnJ9YCwgJ3dhcm5pbmcnKVxuICAgICAgICB0aGlzLnByZWZsaWdodERvbmUgPSB0cnVlXG4gICAgICAgIHJldHVybiB0aGlzLmFsbG93ZWRIZWFkZXJzLnNsaWNlKClcbiAgICAgIH0pXG4gIH1cblxuICBwcmVmbGlnaHRBbmRIZWFkZXJzIChwYXRoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFt0aGlzLnByZWZsaWdodChwYXRoKSwgdGhpcy5oZWFkZXJzKCldKVxuICAgICAgLnRoZW4oKFthbGxvd2VkSGVhZGVycywgaGVhZGVyc10pID0+IHtcbiAgICAgICAgLy8gZmlsdGVyIHRvIGtlZXAgb25seSBhbGxvd2VkIEhlYWRlcnNcbiAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaCgoaGVhZGVyKSA9PiB7XG4gICAgICAgICAgaWYgKGFsbG93ZWRIZWFkZXJzLmluZGV4T2YoaGVhZGVyLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy51cHB5LmxvZyhgW0NvbXBhbmlvbkNsaWVudF0gZXhjbHVkaW5nIHVuYWxsb3dlZCBoZWFkZXIgJHtoZWFkZXJ9YClcbiAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzW2hlYWRlcl1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIGhlYWRlcnNcbiAgICAgIH0pXG4gIH1cblxuICBnZXQgKHBhdGgsIHNraXBQb3N0UmVzcG9uc2UpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVmbGlnaHRBbmRIZWFkZXJzKHBhdGgpXG4gICAgICAudGhlbigoaGVhZGVycykgPT5cbiAgICAgICAgZmV0Y2hXaXRoTmV0d29ya0Vycm9yKHRoaXMuX2dldFVybChwYXRoKSwge1xuICAgICAgICAgIG1ldGhvZDogJ2dldCcsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBjcmVkZW50aWFsczogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlIHx8ICdzYW1lLW9yaWdpbicsXG4gICAgICAgIH0pKVxuICAgICAgLnRoZW4odGhpcy5fZ2V0UG9zdFJlc3BvbnNlRnVuYyhza2lwUG9zdFJlc3BvbnNlKSlcbiAgICAgIC50aGVuKChyZXMpID0+IHRoaXMuX2pzb24ocmVzKSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGlmICghZXJyLmlzQXV0aEVycm9yKSB7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgQ291bGQgbm90IGdldCAke3RoaXMuX2dldFVybChwYXRoKX0uICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXG4gICAgICB9KVxuICB9XG5cbiAgcG9zdCAocGF0aCwgZGF0YSwgc2tpcFBvc3RSZXNwb25zZSkge1xuICAgIHJldHVybiB0aGlzLnByZWZsaWdodEFuZEhlYWRlcnMocGF0aClcbiAgICAgIC50aGVuKChoZWFkZXJzKSA9PlxuICAgICAgICBmZXRjaFdpdGhOZXR3b3JrRXJyb3IodGhpcy5fZ2V0VXJsKHBhdGgpLCB7XG4gICAgICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBjcmVkZW50aWFsczogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlIHx8ICdzYW1lLW9yaWdpbicsXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgIH0pKVxuICAgICAgLnRoZW4odGhpcy5fZ2V0UG9zdFJlc3BvbnNlRnVuYyhza2lwUG9zdFJlc3BvbnNlKSlcbiAgICAgIC50aGVuKChyZXMpID0+IHRoaXMuX2pzb24ocmVzKSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGlmICghZXJyLmlzQXV0aEVycm9yKSB7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgQ291bGQgbm90IHBvc3QgJHt0aGlzLl9nZXRVcmwocGF0aCl9LiAke2Vyci5tZXNzYWdlfWBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgICAgfSlcbiAgfVxuXG4gIGRlbGV0ZSAocGF0aCwgZGF0YSwgc2tpcFBvc3RSZXNwb25zZSkge1xuICAgIHJldHVybiB0aGlzLnByZWZsaWdodEFuZEhlYWRlcnMocGF0aClcbiAgICAgIC50aGVuKChoZWFkZXJzKSA9PlxuICAgICAgICBmZXRjaFdpdGhOZXR3b3JrRXJyb3IoYCR7dGhpcy5ob3N0bmFtZX0vJHtwYXRofWAsIHtcbiAgICAgICAgICBtZXRob2Q6ICdkZWxldGUnLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgY3JlZGVudGlhbHM6IHRoaXMub3B0cy5jb21wYW5pb25Db29raWVzUnVsZSB8fCAnc2FtZS1vcmlnaW4nLFxuICAgICAgICAgIGJvZHk6IGRhdGEgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IG51bGwsXG4gICAgICAgIH0pKVxuICAgICAgLnRoZW4odGhpcy5fZ2V0UG9zdFJlc3BvbnNlRnVuYyhza2lwUG9zdFJlc3BvbnNlKSlcbiAgICAgIC50aGVuKChyZXMpID0+IHRoaXMuX2pzb24ocmVzKSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGlmICghZXJyLmlzQXV0aEVycm9yKSB7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgQ291bGQgbm90IGRlbGV0ZSAke3RoaXMuX2dldFVybChwYXRoKX0uICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXG4gICAgICB9KVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgUmVxdWVzdENsaWVudCA9IHJlcXVpcmUoJy4vUmVxdWVzdENsaWVudCcpXG5cbmNvbnN0IF9nZXROYW1lID0gKGlkKSA9PiB7XG4gIHJldHVybiBpZC5zcGxpdCgnLScpLm1hcCgocykgPT4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSkpLmpvaW4oJyAnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNlYXJjaFByb3ZpZGVyIGV4dGVuZHMgUmVxdWVzdENsaWVudCB7XG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0cy5wcm92aWRlclxuICAgIHRoaXMuaWQgPSB0aGlzLnByb3ZpZGVyXG4gICAgdGhpcy5uYW1lID0gdGhpcy5vcHRzLm5hbWUgfHwgX2dldE5hbWUodGhpcy5pZClcbiAgICB0aGlzLnBsdWdpbklkID0gdGhpcy5vcHRzLnBsdWdpbklkXG4gIH1cblxuICBmaWxlVXJsIChpZCkge1xuICAgIHJldHVybiBgJHt0aGlzLmhvc3RuYW1lfS9zZWFyY2gvJHt0aGlzLmlkfS9nZXQvJHtpZH1gXG4gIH1cblxuICBzZWFyY2ggKHRleHQsIHF1ZXJpZXMpIHtcbiAgICBxdWVyaWVzID0gcXVlcmllcyA/IGAmJHtxdWVyaWVzfWAgOiAnJ1xuICAgIHJldHVybiB0aGlzLmdldChgc2VhcmNoLyR7dGhpcy5pZH0vbGlzdD9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRleHQpfSR7cXVlcmllc31gKVxuICB9XG59XG4iLCJjb25zdCBlZSA9IHJlcXVpcmUoJ25hbWVzcGFjZS1lbWl0dGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBVcHB5U29ja2V0IHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gICAgdGhpcy5fcXVldWVkID0gW11cbiAgICB0aGlzLmlzT3BlbiA9IGZhbHNlXG4gICAgdGhpcy5lbWl0dGVyID0gZWUoKVxuXG4gICAgdGhpcy5faGFuZGxlTWVzc2FnZSA9IHRoaXMuX2hhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKVxuICAgIHRoaXMuZW1pdCA9IHRoaXMuZW1pdC5iaW5kKHRoaXMpXG4gICAgdGhpcy5vbiA9IHRoaXMub24uYmluZCh0aGlzKVxuICAgIHRoaXMub25jZSA9IHRoaXMub25jZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5zZW5kID0gdGhpcy5zZW5kLmJpbmQodGhpcylcblxuICAgIGlmICghb3B0cyB8fCBvcHRzLmF1dG9PcGVuICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5vcGVuKClcbiAgICB9XG4gIH1cblxuICBvcGVuICgpIHtcbiAgICB0aGlzLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodGhpcy5vcHRzLnRhcmdldClcblxuICAgIHRoaXMuc29ja2V0Lm9ub3BlbiA9IChlKSA9PiB7XG4gICAgICB0aGlzLmlzT3BlbiA9IHRydWVcblxuICAgICAgd2hpbGUgKHRoaXMuX3F1ZXVlZC5sZW5ndGggPiAwICYmIHRoaXMuaXNPcGVuKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5fcXVldWVkWzBdXG4gICAgICAgIHRoaXMuc2VuZChmaXJzdC5hY3Rpb24sIGZpcnN0LnBheWxvYWQpXG4gICAgICAgIHRoaXMuX3F1ZXVlZCA9IHRoaXMuX3F1ZXVlZC5zbGljZSgxKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSAoZSkgPT4ge1xuICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IHRoaXMuX2hhbmRsZU1lc3NhZ2VcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgIHRoaXMuc29ja2V0LmNsb3NlKClcbiAgICB9XG4gIH1cblxuICBzZW5kIChhY3Rpb24sIHBheWxvYWQpIHtcbiAgICAvLyBhdHRhY2ggdXVpZFxuXG4gICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgdGhpcy5fcXVldWVkLnB1c2goeyBhY3Rpb24sIHBheWxvYWQgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgYWN0aW9uLFxuICAgICAgcGF5bG9hZCxcbiAgICB9KSlcbiAgfVxuXG4gIG9uIChhY3Rpb24sIGhhbmRsZXIpIHtcbiAgICB0aGlzLmVtaXR0ZXIub24oYWN0aW9uLCBoYW5kbGVyKVxuICB9XG5cbiAgZW1pdCAoYWN0aW9uLCBwYXlsb2FkKSB7XG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoYWN0aW9uLCBwYXlsb2FkKVxuICB9XG5cbiAgb25jZSAoYWN0aW9uLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9uY2UoYWN0aW9uLCBoYW5kbGVyKVxuICB9XG5cbiAgX2hhbmRsZU1lc3NhZ2UgKGUpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZS5kYXRhKVxuICAgICAgdGhpcy5lbWl0KG1lc3NhZ2UuYWN0aW9uLCBtZXNzYWdlLnBheWxvYWQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnIpXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNYW5hZ2VzIGNvbW11bmljYXRpb25zIHdpdGggQ29tcGFuaW9uXG4gKi9cblxuY29uc3QgUmVxdWVzdENsaWVudCA9IHJlcXVpcmUoJy4vUmVxdWVzdENsaWVudCcpXG5jb25zdCBQcm92aWRlciA9IHJlcXVpcmUoJy4vUHJvdmlkZXInKVxuY29uc3QgU2VhcmNoUHJvdmlkZXIgPSByZXF1aXJlKCcuL1NlYXJjaFByb3ZpZGVyJylcbmNvbnN0IFNvY2tldCA9IHJlcXVpcmUoJy4vU29ja2V0JylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlcXVlc3RDbGllbnQsXG4gIFByb3ZpZGVyLFxuICBTZWFyY2hQcm92aWRlcixcbiAgU29ja2V0LFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogVGhpcyBtb2R1bGUgc2VydmVzIGFzIGFuIEFzeW5jIHdyYXBwZXIgZm9yIExvY2FsU3RvcmFnZVxuICovXG5tb2R1bGUuZXhwb3J0cy5zZXRJdGVtID0gKGtleSwgdmFsdWUpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSlcbiAgICByZXNvbHZlKClcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMuZ2V0SXRlbSA9IChrZXkpID0+IHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5yZW1vdmVJdGVtID0gKGtleSkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG4gICAgcmVzb2x2ZSgpXG4gIH0pXG59XG4iLCIhZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGZ1bmN0aW9uIFZOb2RlKCkge31cbiAgICBmdW5jdGlvbiBoKG5vZGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBsYXN0U2ltcGxlLCBjaGlsZCwgc2ltcGxlLCBpLCBjaGlsZHJlbiA9IEVNUFRZX0NISUxEUkVOO1xuICAgICAgICBmb3IgKGkgPSBhcmd1bWVudHMubGVuZ3RoOyBpLS0gPiAyOyApIHN0YWNrLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMgJiYgbnVsbCAhPSBhdHRyaWJ1dGVzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCkgc3RhY2sucHVzaChhdHRyaWJ1dGVzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIGlmICgoY2hpbGQgPSBzdGFjay5wb3AoKSkgJiYgdm9pZCAwICE9PSBjaGlsZC5wb3ApIGZvciAoaSA9IGNoaWxkLmxlbmd0aDsgaS0tOyApIHN0YWNrLnB1c2goY2hpbGRbaV0pOyBlbHNlIHtcbiAgICAgICAgICAgIGlmICgnYm9vbGVhbicgPT0gdHlwZW9mIGNoaWxkKSBjaGlsZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoc2ltcGxlID0gJ2Z1bmN0aW9uJyAhPSB0eXBlb2Ygbm9kZU5hbWUpIGlmIChudWxsID09IGNoaWxkKSBjaGlsZCA9ICcnOyBlbHNlIGlmICgnbnVtYmVyJyA9PSB0eXBlb2YgY2hpbGQpIGNoaWxkID0gU3RyaW5nKGNoaWxkKTsgZWxzZSBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGNoaWxkKSBzaW1wbGUgPSAhMTtcbiAgICAgICAgICAgIGlmIChzaW1wbGUgJiYgbGFzdFNpbXBsZSkgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gKz0gY2hpbGQ7IGVsc2UgaWYgKGNoaWxkcmVuID09PSBFTVBUWV9DSElMRFJFTikgY2hpbGRyZW4gPSBbIGNoaWxkIF07IGVsc2UgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICBsYXN0U2ltcGxlID0gc2ltcGxlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gbmV3IFZOb2RlKCk7XG4gICAgICAgIHAubm9kZU5hbWUgPSBub2RlTmFtZTtcbiAgICAgICAgcC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICBwLmF0dHJpYnV0ZXMgPSBudWxsID09IGF0dHJpYnV0ZXMgPyB2b2lkIDAgOiBhdHRyaWJ1dGVzO1xuICAgICAgICBwLmtleSA9IG51bGwgPT0gYXR0cmlidXRlcyA/IHZvaWQgMCA6IGF0dHJpYnV0ZXMua2V5O1xuICAgICAgICBpZiAodm9pZCAwICE9PSBvcHRpb25zLnZub2RlKSBvcHRpb25zLnZub2RlKHApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0ZW5kKG9iaiwgcHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBwcm9wcykgb2JqW2ldID0gcHJvcHNbaV07XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lRWxlbWVudCh2bm9kZSwgcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGgodm5vZGUubm9kZU5hbWUsIGV4dGVuZChleHRlbmQoe30sIHZub2RlLmF0dHJpYnV0ZXMpLCBwcm9wcyksIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogdm5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5fX2QgJiYgKGNvbXBvbmVudC5fX2QgPSAhMCkgJiYgMSA9PSBpdGVtcy5wdXNoKGNvbXBvbmVudCkpIChvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nIHx8IGRlZmVyKShyZXJlbmRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyKCkge1xuICAgICAgICB2YXIgcCwgbGlzdCA9IGl0ZW1zO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICB3aGlsZSAocCA9IGxpc3QucG9wKCkpIGlmIChwLl9fZCkgcmVuZGVyQ29tcG9uZW50KHApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1NhbWVOb2RlVHlwZShub2RlLCB2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygdm5vZGUgfHwgJ251bWJlcicgPT0gdHlwZW9mIHZub2RlKSByZXR1cm4gdm9pZCAwICE9PSBub2RlLnNwbGl0VGV4dDtcbiAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2bm9kZS5ub2RlTmFtZSkgcmV0dXJuICFub2RlLl9jb21wb25lbnRDb25zdHJ1Y3RvciAmJiBpc05hbWVkTm9kZShub2RlLCB2bm9kZS5ub2RlTmFtZSk7IGVsc2UgcmV0dXJuIGh5ZHJhdGluZyB8fCBub2RlLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9PT0gdm5vZGUubm9kZU5hbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTmFtZWROb2RlKG5vZGUsIG5vZGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBub2RlLl9fbiA9PT0gbm9kZU5hbWUgfHwgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROb2RlUHJvcHModm5vZGUpIHtcbiAgICAgICAgdmFyIHByb3BzID0gZXh0ZW5kKHt9LCB2bm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHZub2RlLm5vZGVOYW1lLmRlZmF1bHRQcm9wcztcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gZGVmYXVsdFByb3BzKSBmb3IgKHZhciBpIGluIGRlZmF1bHRQcm9wcykgaWYgKHZvaWQgMCA9PT0gcHJvcHNbaV0pIHByb3BzW2ldID0gZGVmYXVsdFByb3BzW2ldO1xuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vZGUobm9kZU5hbWUsIGlzU3ZnKSB7XG4gICAgICAgIHZhciBub2RlID0gaXNTdmcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbm9kZU5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgICAgIG5vZGUuX19uID0gbm9kZU5hbWU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRBY2Nlc3Nvcihub2RlLCBuYW1lLCBvbGQsIHZhbHVlLCBpc1N2Zykge1xuICAgICAgICBpZiAoJ2NsYXNzTmFtZScgPT09IG5hbWUpIG5hbWUgPSAnY2xhc3MnO1xuICAgICAgICBpZiAoJ2tleScgPT09IG5hbWUpIDsgZWxzZSBpZiAoJ3JlZicgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChvbGQpIG9sZChudWxsKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkgdmFsdWUobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2NsYXNzJyA9PT0gbmFtZSAmJiAhaXNTdmcpIG5vZGUuY2xhc3NOYW1lID0gdmFsdWUgfHwgJyc7IGVsc2UgaWYgKCdzdHlsZScgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUgfHwgJ3N0cmluZycgPT0gdHlwZW9mIHZhbHVlIHx8ICdzdHJpbmcnID09IHR5cGVvZiBvbGQpIG5vZGUuc3R5bGUuY3NzVGV4dCA9IHZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmICdvYmplY3QnID09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgnc3RyaW5nJyAhPSB0eXBlb2Ygb2xkKSBmb3IgKHZhciBpIGluIG9sZCkgaWYgKCEoaSBpbiB2YWx1ZSkpIG5vZGUuc3R5bGVbaV0gPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHZhbHVlKSBub2RlLnN0eWxlW2ldID0gJ251bWJlcicgPT0gdHlwZW9mIHZhbHVlW2ldICYmICExID09PSBJU19OT05fRElNRU5TSU9OQUwudGVzdChpKSA/IHZhbHVlW2ldICsgJ3B4JyA6IHZhbHVlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCdkYW5nZXJvdXNseVNldElubmVySFRNTCcgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkgbm9kZS5pbm5lckhUTUwgPSB2YWx1ZS5fX2h0bWwgfHwgJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoJ28nID09IG5hbWVbMF0gJiYgJ24nID09IG5hbWVbMV0pIHtcbiAgICAgICAgICAgIHZhciB1c2VDYXB0dXJlID0gbmFtZSAhPT0gKG5hbWUgPSBuYW1lLnJlcGxhY2UoL0NhcHR1cmUkLywgJycpKTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbGQpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudFByb3h5LCB1c2VDYXB0dXJlKTtcbiAgICAgICAgICAgIH0gZWxzZSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgZXZlbnRQcm94eSwgdXNlQ2FwdHVyZSk7XG4gICAgICAgICAgICAobm9kZS5fX2wgfHwgKG5vZGUuX19sID0ge30pKVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCdsaXN0JyAhPT0gbmFtZSAmJiAndHlwZScgIT09IG5hbWUgJiYgIWlzU3ZnICYmIG5hbWUgaW4gbm9kZSkge1xuICAgICAgICAgICAgc2V0UHJvcGVydHkobm9kZSwgbmFtZSwgbnVsbCA9PSB2YWx1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgICAgICAgaWYgKG51bGwgPT0gdmFsdWUgfHwgITEgPT09IHZhbHVlKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBucyA9IGlzU3ZnICYmIG5hbWUgIT09IChuYW1lID0gbmFtZS5yZXBsYWNlKC9eeGxpbms6Py8sICcnKSk7XG4gICAgICAgICAgICBpZiAobnVsbCA9PSB2YWx1ZSB8fCAhMSA9PT0gdmFsdWUpIGlmIChucykgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIG5hbWUudG9Mb3dlckNhc2UoKSk7IGVsc2Ugbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7IGVsc2UgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIHZhbHVlKSBpZiAobnMpIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBuYW1lLnRvTG93ZXJDYXNlKCksIHZhbHVlKTsgZWxzZSBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0UHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5vZGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgZnVuY3Rpb24gZXZlbnRQcm94eShlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbFtlLnR5cGVdKG9wdGlvbnMuZXZlbnQgJiYgb3B0aW9ucy5ldmVudChlKSB8fCBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hNb3VudHMoKSB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICB3aGlsZSAoYyA9IG1vdW50cy5wb3AoKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWZ0ZXJNb3VudCkgb3B0aW9ucy5hZnRlck1vdW50KGMpO1xuICAgICAgICAgICAgaWYgKGMuY29tcG9uZW50RGlkTW91bnQpIGMuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaWZmKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsLCBwYXJlbnQsIGNvbXBvbmVudFJvb3QpIHtcbiAgICAgICAgaWYgKCFkaWZmTGV2ZWwrKykge1xuICAgICAgICAgICAgaXNTdmdNb2RlID0gbnVsbCAhPSBwYXJlbnQgJiYgdm9pZCAwICE9PSBwYXJlbnQub3duZXJTVkdFbGVtZW50O1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gbnVsbCAhPSBkb20gJiYgISgnX19wcmVhY3RhdHRyXycgaW4gZG9tKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0ID0gaWRpZmYoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwsIGNvbXBvbmVudFJvb3QpO1xuICAgICAgICBpZiAocGFyZW50ICYmIHJldC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHBhcmVudC5hcHBlbmRDaGlsZChyZXQpO1xuICAgICAgICBpZiAoIS0tZGlmZkxldmVsKSB7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSAhMTtcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50Um9vdCkgZmx1c2hNb3VudHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpZGlmZihkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCwgY29tcG9uZW50Um9vdCkge1xuICAgICAgICB2YXIgb3V0ID0gZG9tLCBwcmV2U3ZnTW9kZSA9IGlzU3ZnTW9kZTtcbiAgICAgICAgaWYgKG51bGwgPT0gdm5vZGUgfHwgJ2Jvb2xlYW4nID09IHR5cGVvZiB2bm9kZSkgdm5vZGUgPSAnJztcbiAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2bm9kZSB8fCAnbnVtYmVyJyA9PSB0eXBlb2Ygdm5vZGUpIHtcbiAgICAgICAgICAgIGlmIChkb20gJiYgdm9pZCAwICE9PSBkb20uc3BsaXRUZXh0ICYmIGRvbS5wYXJlbnROb2RlICYmICghZG9tLl9jb21wb25lbnQgfHwgY29tcG9uZW50Um9vdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVWYWx1ZSAhPSB2bm9kZSkgZG9tLm5vZGVWYWx1ZSA9IHZub2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2bm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tLnBhcmVudE5vZGUpIGRvbS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChvdXQsIGRvbSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY29sbGVjdE5vZGVUcmVlKGRvbSwgITApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5fX3ByZWFjdGF0dHJfID0gITA7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciB2bm9kZU5hbWUgPSB2bm9kZS5ub2RlTmFtZTtcbiAgICAgICAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHZub2RlTmFtZSkgcmV0dXJuIGJ1aWxkQ29tcG9uZW50RnJvbVZOb2RlKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsKTtcbiAgICAgICAgaXNTdmdNb2RlID0gJ3N2ZycgPT09IHZub2RlTmFtZSA/ICEwIDogJ2ZvcmVpZ25PYmplY3QnID09PSB2bm9kZU5hbWUgPyAhMSA6IGlzU3ZnTW9kZTtcbiAgICAgICAgdm5vZGVOYW1lID0gU3RyaW5nKHZub2RlTmFtZSk7XG4gICAgICAgIGlmICghZG9tIHx8ICFpc05hbWVkTm9kZShkb20sIHZub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIG91dCA9IGNyZWF0ZU5vZGUodm5vZGVOYW1lLCBpc1N2Z01vZGUpO1xuICAgICAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChkb20uZmlyc3RDaGlsZCkgb3V0LmFwcGVuZENoaWxkKGRvbS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLnBhcmVudE5vZGUpIGRvbS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChvdXQsIGRvbSk7XG4gICAgICAgICAgICAgICAgcmVjb2xsZWN0Tm9kZVRyZWUoZG9tLCAhMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZjID0gb3V0LmZpcnN0Q2hpbGQsIHByb3BzID0gb3V0Ll9fcHJlYWN0YXR0cl8sIHZjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAobnVsbCA9PSBwcm9wcykge1xuICAgICAgICAgICAgcHJvcHMgPSBvdXQuX19wcmVhY3RhdHRyXyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgYSA9IG91dC5hdHRyaWJ1dGVzLCBpID0gYS5sZW5ndGg7IGktLTsgKSBwcm9wc1thW2ldLm5hbWVdID0gYVtpXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWh5ZHJhdGluZyAmJiB2Y2hpbGRyZW4gJiYgMSA9PT0gdmNoaWxkcmVuLmxlbmd0aCAmJiAnc3RyaW5nJyA9PSB0eXBlb2YgdmNoaWxkcmVuWzBdICYmIG51bGwgIT0gZmMgJiYgdm9pZCAwICE9PSBmYy5zcGxpdFRleHQgJiYgbnVsbCA9PSBmYy5uZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKGZjLm5vZGVWYWx1ZSAhPSB2Y2hpbGRyZW5bMF0pIGZjLm5vZGVWYWx1ZSA9IHZjaGlsZHJlblswXTtcbiAgICAgICAgfSBlbHNlIGlmICh2Y2hpbGRyZW4gJiYgdmNoaWxkcmVuLmxlbmd0aCB8fCBudWxsICE9IGZjKSBpbm5lckRpZmZOb2RlKG91dCwgdmNoaWxkcmVuLCBjb250ZXh0LCBtb3VudEFsbCwgaHlkcmF0aW5nIHx8IG51bGwgIT0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpO1xuICAgICAgICBkaWZmQXR0cmlidXRlcyhvdXQsIHZub2RlLmF0dHJpYnV0ZXMsIHByb3BzKTtcbiAgICAgICAgaXNTdmdNb2RlID0gcHJldlN2Z01vZGU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlubmVyRGlmZk5vZGUoZG9tLCB2Y2hpbGRyZW4sIGNvbnRleHQsIG1vdW50QWxsLCBpc0h5ZHJhdGluZykge1xuICAgICAgICB2YXIgaiwgYywgZiwgdmNoaWxkLCBjaGlsZCwgb3JpZ2luYWxDaGlsZHJlbiA9IGRvbS5jaGlsZE5vZGVzLCBjaGlsZHJlbiA9IFtdLCBrZXllZCA9IHt9LCBrZXllZExlbiA9IDAsIG1pbiA9IDAsIGxlbiA9IG9yaWdpbmFsQ2hpbGRyZW4ubGVuZ3RoLCBjaGlsZHJlbkxlbiA9IDAsIHZsZW4gPSB2Y2hpbGRyZW4gPyB2Y2hpbGRyZW4ubGVuZ3RoIDogMDtcbiAgICAgICAgaWYgKDAgIT09IGxlbikgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIF9jaGlsZCA9IG9yaWdpbmFsQ2hpbGRyZW5baV0sIHByb3BzID0gX2NoaWxkLl9fcHJlYWN0YXR0cl8sIGtleSA9IHZsZW4gJiYgcHJvcHMgPyBfY2hpbGQuX2NvbXBvbmVudCA/IF9jaGlsZC5fY29tcG9uZW50Ll9fayA6IHByb3BzLmtleSA6IG51bGw7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBrZXkpIHtcbiAgICAgICAgICAgICAgICBrZXllZExlbisrO1xuICAgICAgICAgICAgICAgIGtleWVkW2tleV0gPSBfY2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BzIHx8ICh2b2lkIDAgIT09IF9jaGlsZC5zcGxpdFRleHQgPyBpc0h5ZHJhdGluZyA/IF9jaGlsZC5ub2RlVmFsdWUudHJpbSgpIDogITAgOiBpc0h5ZHJhdGluZykpIGNoaWxkcmVuW2NoaWxkcmVuTGVuKytdID0gX2NoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwICE9PSB2bGVuKSBmb3IgKHZhciBpID0gMDsgaSA8IHZsZW47IGkrKykge1xuICAgICAgICAgICAgdmNoaWxkID0gdmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgY2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGtleSA9IHZjaGlsZC5rZXk7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ZWRMZW4gJiYgdm9pZCAwICE9PSBrZXllZFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0ga2V5ZWRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAga2V5ZWRba2V5XSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAga2V5ZWRMZW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjaGlsZCAmJiBtaW4gPCBjaGlsZHJlbkxlbikgZm9yIChqID0gbWluOyBqIDwgY2hpbGRyZW5MZW47IGorKykgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW5bal0gJiYgaXNTYW1lTm9kZVR5cGUoYyA9IGNoaWxkcmVuW2pdLCB2Y2hpbGQsIGlzSHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gYztcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltqXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gY2hpbGRyZW5MZW4gLSAxKSBjaGlsZHJlbkxlbi0tO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSBtaW4pIG1pbisrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSBpZGlmZihjaGlsZCwgdmNoaWxkLCBjb250ZXh0LCBtb3VudEFsbCk7XG4gICAgICAgICAgICBmID0gb3JpZ2luYWxDaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gZG9tICYmIGNoaWxkICE9PSBmKSBpZiAobnVsbCA9PSBmKSBkb20uYXBwZW5kQ2hpbGQoY2hpbGQpOyBlbHNlIGlmIChjaGlsZCA9PT0gZi5uZXh0U2libGluZykgcmVtb3ZlTm9kZShmKTsgZWxzZSBkb20uaW5zZXJ0QmVmb3JlKGNoaWxkLCBmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ZWRMZW4pIGZvciAodmFyIGkgaW4ga2V5ZWQpIGlmICh2b2lkIDAgIT09IGtleWVkW2ldKSByZWNvbGxlY3ROb2RlVHJlZShrZXllZFtpXSwgITEpO1xuICAgICAgICB3aGlsZSAobWluIDw9IGNoaWxkcmVuTGVuKSBpZiAodm9pZCAwICE9PSAoY2hpbGQgPSBjaGlsZHJlbltjaGlsZHJlbkxlbi0tXSkpIHJlY29sbGVjdE5vZGVUcmVlKGNoaWxkLCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY29sbGVjdE5vZGVUcmVlKG5vZGUsIHVubW91bnRPbmx5KSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBub2RlLl9jb21wb25lbnQ7XG4gICAgICAgIGlmIChjb21wb25lbnQpIHVubW91bnRDb21wb25lbnQoY29tcG9uZW50KTsgZWxzZSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBub2RlLl9fcHJlYWN0YXR0cl8gJiYgbm9kZS5fX3ByZWFjdGF0dHJfLnJlZikgbm9kZS5fX3ByZWFjdGF0dHJfLnJlZihudWxsKTtcbiAgICAgICAgICAgIGlmICghMSA9PT0gdW5tb3VudE9ubHkgfHwgbnVsbCA9PSBub2RlLl9fcHJlYWN0YXR0cl8pIHJlbW92ZU5vZGUobm9kZSk7XG4gICAgICAgICAgICByZW1vdmVDaGlsZHJlbihub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbihub2RlKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICByZWNvbGxlY3ROb2RlVHJlZShub2RlLCAhMCk7XG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaWZmQXR0cmlidXRlcyhkb20sIGF0dHJzLCBvbGQpIHtcbiAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgIGZvciAobmFtZSBpbiBvbGQpIGlmICgoIWF0dHJzIHx8IG51bGwgPT0gYXR0cnNbbmFtZV0pICYmIG51bGwgIT0gb2xkW25hbWVdKSBzZXRBY2Nlc3Nvcihkb20sIG5hbWUsIG9sZFtuYW1lXSwgb2xkW25hbWVdID0gdm9pZCAwLCBpc1N2Z01vZGUpO1xuICAgICAgICBmb3IgKG5hbWUgaW4gYXR0cnMpIGlmICghKCdjaGlsZHJlbicgPT09IG5hbWUgfHwgJ2lubmVySFRNTCcgPT09IG5hbWUgfHwgbmFtZSBpbiBvbGQgJiYgYXR0cnNbbmFtZV0gPT09ICgndmFsdWUnID09PSBuYW1lIHx8ICdjaGVja2VkJyA9PT0gbmFtZSA/IGRvbVtuYW1lXSA6IG9sZFtuYW1lXSkpKSBzZXRBY2Nlc3Nvcihkb20sIG5hbWUsIG9sZFtuYW1lXSwgb2xkW25hbWVdID0gYXR0cnNbbmFtZV0sIGlzU3ZnTW9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbGxlY3RDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBuYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIChjb21wb25lbnRzW25hbWVdIHx8IChjb21wb25lbnRzW25hbWVdID0gW10pKS5wdXNoKGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChDdG9yLCBwcm9wcywgY29udGV4dCkge1xuICAgICAgICB2YXIgaW5zdCwgbGlzdCA9IGNvbXBvbmVudHNbQ3Rvci5uYW1lXTtcbiAgICAgICAgaWYgKEN0b3IucHJvdG90eXBlICYmIEN0b3IucHJvdG90eXBlLnJlbmRlcikge1xuICAgICAgICAgICAgaW5zdCA9IG5ldyBDdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIENvbXBvbmVudC5jYWxsKGluc3QsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc3QgPSBuZXcgQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGluc3QuY29uc3RydWN0b3IgPSBDdG9yO1xuICAgICAgICAgICAgaW5zdC5yZW5kZXIgPSBkb1JlbmRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdCkgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoOyBpLS07ICkgaWYgKGxpc3RbaV0uY29uc3RydWN0b3IgPT09IEN0b3IpIHtcbiAgICAgICAgICAgIGluc3QuX19iID0gbGlzdFtpXS5fX2I7XG4gICAgICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkb1JlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRDb21wb25lbnRQcm9wcyhjb21wb25lbnQsIHByb3BzLCBvcHRzLCBjb250ZXh0LCBtb3VudEFsbCkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5fX3gpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5fX3ggPSAhMDtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuX19yID0gcHJvcHMucmVmKSBkZWxldGUgcHJvcHMucmVmO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5fX2sgPSBwcm9wcy5rZXkpIGRlbGV0ZSBwcm9wcy5rZXk7XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5iYXNlIHx8IG1vdW50QWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsTW91bnQpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQgIT09IGNvbXBvbmVudC5jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQuX19jKSBjb21wb25lbnQuX19jID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQuX19wKSBjb21wb25lbnQuX19wID0gY29tcG9uZW50LnByb3BzO1xuICAgICAgICAgICAgY29tcG9uZW50LnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICBjb21wb25lbnQuX194ID0gITE7XG4gICAgICAgICAgICBpZiAoMCAhPT0gb3B0cykgaWYgKDEgPT09IG9wdHMgfHwgITEgIT09IG9wdGlvbnMuc3luY0NvbXBvbmVudFVwZGF0ZXMgfHwgIWNvbXBvbmVudC5iYXNlKSByZW5kZXJDb21wb25lbnQoY29tcG9uZW50LCAxLCBtb3VudEFsbCk7IGVsc2UgZW5xdWV1ZVJlbmRlcihjb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5fX3IpIGNvbXBvbmVudC5fX3IoY29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50LCBvcHRzLCBtb3VudEFsbCwgaXNDaGlsZCkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5fX3gpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZCwgaW5zdCwgY2Jhc2UsIHByb3BzID0gY29tcG9uZW50LnByb3BzLCBzdGF0ZSA9IGNvbXBvbmVudC5zdGF0ZSwgY29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0LCBwcmV2aW91c1Byb3BzID0gY29tcG9uZW50Ll9fcCB8fCBwcm9wcywgcHJldmlvdXNTdGF0ZSA9IGNvbXBvbmVudC5fX3MgfHwgc3RhdGUsIHByZXZpb3VzQ29udGV4dCA9IGNvbXBvbmVudC5fX2MgfHwgY29udGV4dCwgaXNVcGRhdGUgPSBjb21wb25lbnQuYmFzZSwgbmV4dEJhc2UgPSBjb21wb25lbnQuX19iLCBpbml0aWFsQmFzZSA9IGlzVXBkYXRlIHx8IG5leHRCYXNlLCBpbml0aWFsQ2hpbGRDb21wb25lbnQgPSBjb21wb25lbnQuX2NvbXBvbmVudCwgc2tpcCA9ICExO1xuICAgICAgICAgICAgaWYgKGlzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnByb3BzID0gcHJldmlvdXNQcm9wcztcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc3RhdGUgPSBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmICgyICE9PSBvcHRzICYmIGNvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGUgJiYgITEgPT09IGNvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGUocHJvcHMsIHN0YXRlLCBjb250ZXh0KSkgc2tpcCA9ICEwOyBlbHNlIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZSkgY29tcG9uZW50LmNvbXBvbmVudFdpbGxVcGRhdGUocHJvcHMsIHN0YXRlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuX19wID0gY29tcG9uZW50Ll9fcyA9IGNvbXBvbmVudC5fX2MgPSBjb21wb25lbnQuX19iID0gbnVsbDtcbiAgICAgICAgICAgIGNvbXBvbmVudC5fX2QgPSAhMTtcbiAgICAgICAgICAgIGlmICghc2tpcCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkID0gY29tcG9uZW50LnJlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuZ2V0Q2hpbGRDb250ZXh0KSBjb250ZXh0ID0gZXh0ZW5kKGV4dGVuZCh7fSwgY29udGV4dCksIGNvbXBvbmVudC5nZXRDaGlsZENvbnRleHQoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHRvVW5tb3VudCwgYmFzZSwgY2hpbGRDb21wb25lbnQgPSByZW5kZXJlZCAmJiByZW5kZXJlZC5ub2RlTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgY2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkUHJvcHMgPSBnZXROb2RlUHJvcHMocmVuZGVyZWQpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0ID0gaW5pdGlhbENoaWxkQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdCAmJiBpbnN0LmNvbnN0cnVjdG9yID09PSBjaGlsZENvbXBvbmVudCAmJiBjaGlsZFByb3BzLmtleSA9PSBpbnN0Ll9faykgc2V0Q29tcG9uZW50UHJvcHMoaW5zdCwgY2hpbGRQcm9wcywgMSwgY29udGV4dCwgITEpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvVW5tb3VudCA9IGluc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuX2NvbXBvbmVudCA9IGluc3QgPSBjcmVhdGVDb21wb25lbnQoY2hpbGRDb21wb25lbnQsIGNoaWxkUHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdC5fX2IgPSBpbnN0Ll9fYiB8fCBuZXh0QmFzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3QuX191ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29tcG9uZW50UHJvcHMoaW5zdCwgY2hpbGRQcm9wcywgMCwgY29udGV4dCwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyQ29tcG9uZW50KGluc3QsIDEsIG1vdW50QWxsLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGluc3QuYmFzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYmFzZSA9IGluaXRpYWxCYXNlO1xuICAgICAgICAgICAgICAgICAgICB0b1VubW91bnQgPSBpbml0aWFsQ2hpbGRDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b1VubW91bnQpIGNiYXNlID0gY29tcG9uZW50Ll9jb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbEJhc2UgfHwgMSA9PT0gb3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNiYXNlKSBjYmFzZS5fY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSBkaWZmKGNiYXNlLCByZW5kZXJlZCwgY29udGV4dCwgbW91bnRBbGwgfHwgIWlzVXBkYXRlLCBpbml0aWFsQmFzZSAmJiBpbml0aWFsQmFzZS5wYXJlbnROb2RlLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxCYXNlICYmIGJhc2UgIT09IGluaXRpYWxCYXNlICYmIGluc3QgIT09IGluaXRpYWxDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVBhcmVudCA9IGluaXRpYWxCYXNlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlUGFyZW50ICYmIGJhc2UgIT09IGJhc2VQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VQYXJlbnQucmVwbGFjZUNoaWxkKGJhc2UsIGluaXRpYWxCYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdG9Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbEJhc2UuX2NvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb2xsZWN0Tm9kZVRyZWUoaW5pdGlhbEJhc2UsICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9Vbm1vdW50KSB1bm1vdW50Q29tcG9uZW50KHRvVW5tb3VudCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlICYmICFpc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRSZWYgPSBjb21wb25lbnQsIHQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0ID0gdC5fX3UpIChjb21wb25lbnRSZWYgPSB0KS5iYXNlID0gYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZS5fY29tcG9uZW50ID0gY29tcG9uZW50UmVmO1xuICAgICAgICAgICAgICAgICAgICBiYXNlLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9IGNvbXBvbmVudFJlZi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzVXBkYXRlIHx8IG1vdW50QWxsKSBtb3VudHMudW5zaGlmdChjb21wb25lbnQpOyBlbHNlIGlmICghc2tpcCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50RGlkVXBkYXRlKSBjb21wb25lbnQuY29tcG9uZW50RGlkVXBkYXRlKHByZXZpb3VzUHJvcHMsIHByZXZpb3VzU3RhdGUsIHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWZ0ZXJVcGRhdGUpIG9wdGlvbnMuYWZ0ZXJVcGRhdGUoY29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudWxsICE9IGNvbXBvbmVudC5fX2gpIHdoaWxlIChjb21wb25lbnQuX19oLmxlbmd0aCkgY29tcG9uZW50Ll9faC5wb3AoKS5jYWxsKGNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoIWRpZmZMZXZlbCAmJiAhaXNDaGlsZCkgZmx1c2hNb3VudHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZENvbXBvbmVudEZyb21WTm9kZShkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCkge1xuICAgICAgICB2YXIgYyA9IGRvbSAmJiBkb20uX2NvbXBvbmVudCwgb3JpZ2luYWxDb21wb25lbnQgPSBjLCBvbGREb20gPSBkb20sIGlzRGlyZWN0T3duZXIgPSBjICYmIGRvbS5fY29tcG9uZW50Q29uc3RydWN0b3IgPT09IHZub2RlLm5vZGVOYW1lLCBpc093bmVyID0gaXNEaXJlY3RPd25lciwgcHJvcHMgPSBnZXROb2RlUHJvcHModm5vZGUpO1xuICAgICAgICB3aGlsZSAoYyAmJiAhaXNPd25lciAmJiAoYyA9IGMuX191KSkgaXNPd25lciA9IGMuY29uc3RydWN0b3IgPT09IHZub2RlLm5vZGVOYW1lO1xuICAgICAgICBpZiAoYyAmJiBpc093bmVyICYmICghbW91bnRBbGwgfHwgYy5fY29tcG9uZW50KSkge1xuICAgICAgICAgICAgc2V0Q29tcG9uZW50UHJvcHMoYywgcHJvcHMsIDMsIGNvbnRleHQsIG1vdW50QWxsKTtcbiAgICAgICAgICAgIGRvbSA9IGMuYmFzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbENvbXBvbmVudCAmJiAhaXNEaXJlY3RPd25lcikge1xuICAgICAgICAgICAgICAgIHVubW91bnRDb21wb25lbnQob3JpZ2luYWxDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIGRvbSA9IG9sZERvbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjID0gY3JlYXRlQ29tcG9uZW50KHZub2RlLm5vZGVOYW1lLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoZG9tICYmICFjLl9fYikge1xuICAgICAgICAgICAgICAgIGMuX19iID0gZG9tO1xuICAgICAgICAgICAgICAgIG9sZERvbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDb21wb25lbnRQcm9wcyhjLCBwcm9wcywgMSwgY29udGV4dCwgbW91bnRBbGwpO1xuICAgICAgICAgICAgZG9tID0gYy5iYXNlO1xuICAgICAgICAgICAgaWYgKG9sZERvbSAmJiBkb20gIT09IG9sZERvbSkge1xuICAgICAgICAgICAgICAgIG9sZERvbS5fY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZWNvbGxlY3ROb2RlVHJlZShvbGREb20sICExKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBpZiAob3B0aW9ucy5iZWZvcmVVbm1vdW50KSBvcHRpb25zLmJlZm9yZVVubW91bnQoY29tcG9uZW50KTtcbiAgICAgICAgdmFyIGJhc2UgPSBjb21wb25lbnQuYmFzZTtcbiAgICAgICAgY29tcG9uZW50Ll9feCA9ICEwO1xuICAgICAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxVbm1vdW50KSBjb21wb25lbnQuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgICAgY29tcG9uZW50LmJhc2UgPSBudWxsO1xuICAgICAgICB2YXIgaW5uZXIgPSBjb21wb25lbnQuX2NvbXBvbmVudDtcbiAgICAgICAgaWYgKGlubmVyKSB1bm1vdW50Q29tcG9uZW50KGlubmVyKTsgZWxzZSBpZiAoYmFzZSkge1xuICAgICAgICAgICAgaWYgKGJhc2UuX19wcmVhY3RhdHRyXyAmJiBiYXNlLl9fcHJlYWN0YXR0cl8ucmVmKSBiYXNlLl9fcHJlYWN0YXR0cl8ucmVmKG51bGwpO1xuICAgICAgICAgICAgY29tcG9uZW50Ll9fYiA9IGJhc2U7XG4gICAgICAgICAgICByZW1vdmVOb2RlKGJhc2UpO1xuICAgICAgICAgICAgY29sbGVjdENvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudC5fX3IpIGNvbXBvbmVudC5fX3IobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuICAgICAgICB0aGlzLl9fZCA9ICEwO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlIHx8IHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudCwgbWVyZ2UpIHtcbiAgICAgICAgcmV0dXJuIGRpZmYobWVyZ2UsIHZub2RlLCB7fSwgITEsIHBhcmVudCwgITEpO1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBFTVBUWV9DSElMRFJFTiA9IFtdO1xuICAgIHZhciBkZWZlciA9ICdmdW5jdGlvbicgPT0gdHlwZW9mIFByb21pc2UgPyBQcm9taXNlLnJlc29sdmUoKS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpIDogc2V0VGltZW91dDtcbiAgICB2YXIgSVNfTk9OX0RJTUVOU0lPTkFMID0gL2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkL2k7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdmFyIG1vdW50cyA9IFtdO1xuICAgIHZhciBkaWZmTGV2ZWwgPSAwO1xuICAgIHZhciBpc1N2Z01vZGUgPSAhMTtcbiAgICB2YXIgaHlkcmF0aW5nID0gITE7XG4gICAgdmFyIGNvbXBvbmVudHMgPSB7fTtcbiAgICBleHRlbmQoQ29tcG9uZW50LnByb3RvdHlwZSwge1xuICAgICAgICBzZXRTdGF0ZTogZnVuY3Rpb24oc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX19zKSB0aGlzLl9fcyA9IGV4dGVuZCh7fSwgcyk7XG4gICAgICAgICAgICBleHRlbmQocywgJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3RhdGUgPyBzdGF0ZShzLCB0aGlzLnByb3BzKSA6IHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgKHRoaXMuX19oID0gdGhpcy5fX2ggfHwgW10pLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgZW5xdWV1ZVJlbmRlcih0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spICh0aGlzLl9faCA9IHRoaXMuX19oIHx8IFtdKS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJlbmRlckNvbXBvbmVudCh0aGlzLCAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHt9XG4gICAgfSk7XG4gICAgdmFyIHByZWFjdCA9IHtcbiAgICAgICAgaDogaCxcbiAgICAgICAgY3JlYXRlRWxlbWVudDogaCxcbiAgICAgICAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gICAgICAgIENvbXBvbmVudDogQ29tcG9uZW50LFxuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgcmVyZW5kZXI6IHJlcmVuZGVyLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfTtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG1vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBwcmVhY3Q7IGVsc2Ugc2VsZi5wcmVhY3QgPSBwcmVhY3Q7XG59KCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVhY3QuanMubWFwIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9jb3JlXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJDb3JlIG1vZHVsZSBmb3IgdGhlIGV4dGVuc2libGUgSmF2YVNjcmlwdCBmaWxlIHVwbG9hZCB3aWRnZXQgd2l0aCBzdXBwb3J0IGZvciBkcmFnJmRyb3AsIHJlc3VtYWJsZSB1cGxvYWRzLCBwcmV2aWV3cywgcmVzdHJpY3Rpb25zLCBmaWxlIHByb2Nlc3NpbmcvZW5jb2RpbmcsIHJlbW90ZSBwcm92aWRlcnMgbGlrZSBJbnN0YWdyYW0sIERyb3Bib3gsIEdvb2dsZSBEcml2ZSwgUzMgYW5kIG1vcmUgOmRvZzpcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4xOS4yXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJzdHlsZVwiOiBcImRpc3Qvc3R5bGUubWluLmNzc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdHJhbnNsb2FkaXQvcHJldHRpZXItYnl0ZXNcIjogXCIwLjAuN1wiLFxuICAgIFwiQHVwcHkvc3RvcmUtZGVmYXVsdFwiOiBcImZpbGU6Li4vc3RvcmUtZGVmYXVsdFwiLFxuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJjdWlkXCI6IFwiXjIuMS4xXCIsXG4gICAgXCJsb2Rhc2gudGhyb3R0bGVcIjogXCJeNC4xLjFcIixcbiAgICBcIm1pbWUtbWF0Y2hcIjogXCJeMS4wLjJcIixcbiAgICBcIm5hbWVzcGFjZS1lbWl0dGVyXCI6IFwiXjIuMC4xXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH1cbn1cbiIsImNvbnN0IHByZWFjdCA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBmaW5kRE9NRWxlbWVudCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9maW5kRE9NRWxlbWVudCcpXG5cbi8qKlxuICogRGVmZXIgYSBmcmVxdWVudCBjYWxsIHRvIHRoZSBtaWNyb3Rhc2sgcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlIChmbikge1xuICBsZXQgY2FsbGluZyA9IG51bGxcbiAgbGV0IGxhdGVzdEFyZ3MgPSBudWxsXG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGxhdGVzdEFyZ3MgPSBhcmdzXG4gICAgaWYgKCFjYWxsaW5nKSB7XG4gICAgICBjYWxsaW5nID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGNhbGxpbmcgPSBudWxsXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgYGFyZ3NgIG1heSBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgbW9zdFxuICAgICAgICAvLyByZWNlbnQgc3RhdGUsIGlmIG11bHRpcGxlIGNhbGxzIGhhcHBlbmVkIHNpbmNlIHRoaXMgdGFza1xuICAgICAgICAvLyB3YXMgcXVldWVkLiBTbyB3ZSB1c2UgdGhlIGBsYXRlc3RBcmdzYCwgd2hpY2ggZGVmaW5pdGVseVxuICAgICAgICAvLyBpcyB0aGUgbW9zdCByZWNlbnQgY2FsbC5cbiAgICAgICAgcmV0dXJuIGZuKC4uLmxhdGVzdEFyZ3MpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gY2FsbGluZ1xuICB9XG59XG5cbi8qKlxuICogQm9pbGVycGxhdGUgdGhhdCBhbGwgUGx1Z2lucyBzaGFyZSAtIGFuZCBzaG91bGQgbm90IGJlIHVzZWRcbiAqIGRpcmVjdGx5LiBJdCBhbHNvIHNob3dzIHdoaWNoIG1ldGhvZHMgZmluYWwgcGx1Z2lucyBzaG91bGQgaW1wbGVtZW50L292ZXJyaWRlLFxuICogdGhpcyBkZWNpZGluZyBvbiBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG1haW4gVXBweSBjb3JlIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCB3aXRoIHBsdWdpbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXl8c3RyaW5nfSBmaWxlcyBvciBzdWNjZXNzL2ZhaWwgbWVzc2FnZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBsdWdpbiB7XG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgdGhpcy51cHB5ID0gdXBweVxuICAgIHRoaXMub3B0cyA9IG9wdHMgfHwge31cblxuICAgIHRoaXMudXBkYXRlID0gdGhpcy51cGRhdGUuYmluZCh0aGlzKVxuICAgIHRoaXMubW91bnQgPSB0aGlzLm1vdW50LmJpbmQodGhpcylcbiAgICB0aGlzLmluc3RhbGwgPSB0aGlzLmluc3RhbGwuYmluZCh0aGlzKVxuICAgIHRoaXMudW5pbnN0YWxsID0gdGhpcy51bmluc3RhbGwuYmluZCh0aGlzKVxuICB9XG5cbiAgZ2V0UGx1Z2luU3RhdGUgKCkge1xuICAgIGNvbnN0IHsgcGx1Z2lucyB9ID0gdGhpcy51cHB5LmdldFN0YXRlKClcbiAgICByZXR1cm4gcGx1Z2luc1t0aGlzLmlkXSB8fCB7fVxuICB9XG5cbiAgc2V0UGx1Z2luU3RhdGUgKHVwZGF0ZSkge1xuICAgIGNvbnN0IHsgcGx1Z2lucyB9ID0gdGhpcy51cHB5LmdldFN0YXRlKClcblxuICAgIHRoaXMudXBweS5zZXRTdGF0ZSh7XG4gICAgICBwbHVnaW5zOiB7XG4gICAgICAgIC4uLnBsdWdpbnMsXG4gICAgICAgIFt0aGlzLmlkXToge1xuICAgICAgICAgIC4uLnBsdWdpbnNbdGhpcy5pZF0sXG4gICAgICAgICAgLi4udXBkYXRlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgc2V0T3B0aW9ucyAobmV3T3B0cykge1xuICAgIHRoaXMub3B0cyA9IHsgLi4udGhpcy5vcHRzLCAuLi5uZXdPcHRzIH1cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKCkgLy8gc28gdGhhdCBVSSByZS1yZW5kZXJzIHdpdGggbmV3IG9wdGlvbnNcbiAgfVxuXG4gIHVwZGF0ZSAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdXBkYXRlVUkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVVJKHN0YXRlKVxuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBhZnRlciBldmVyeSBzdGF0ZSB1cGRhdGUsIGFmdGVyIGV2ZXJ5dGhpbmcncyBtb3VudGVkLiBEZWJvdW5jZWQuXG4gIGFmdGVyVXBkYXRlICgpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHBsdWdpbiBpcyBtb3VudGVkLCB3aGV0aGVyIGluIERPTSBvciBpbnRvIGFub3RoZXIgcGx1Z2luLlxuICAgKiBOZWVkZWQgYmVjYXVzZSBzb21ldGltZXMgcGx1Z2lucyBhcmUgbW91bnRlZCBzZXBhcmF0ZWx5L2FmdGVyIGBpbnN0YWxsYCxcbiAgICogc28gdGhpcy5lbCBhbmQgdGhpcy5wYXJlbnQgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpbiBgaW5zdGFsbGAuXG4gICAqIFRoaXMgaXMgdGhlIGNhc2Ugd2l0aCBAdXBweS9yZWFjdCBwbHVnaW5zLCBmb3IgZXhhbXBsZS5cbiAgICovXG4gIG9uTW91bnQgKCkge1xuXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgc3VwcGxpZWQgYHRhcmdldGAgaXMgYSBET00gZWxlbWVudCBvciBhbiBgb2JqZWN0YC5cbiAgICogSWYgaXTigJlzIGFuIG9iamVjdCDigJQgdGFyZ2V0IGlzIGEgcGx1Z2luLCBhbmQgd2Ugc2VhcmNoIGBwbHVnaW5zYFxuICAgKiBmb3IgYSBwbHVnaW4gd2l0aCBzYW1lIG5hbWUgYW5kIHJldHVybiBpdHMgdGFyZ2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHRhcmdldFxuICAgKlxuICAgKi9cbiAgbW91bnQgKHRhcmdldCwgcGx1Z2luKSB7XG4gICAgY29uc3QgY2FsbGVyUGx1Z2luTmFtZSA9IHBsdWdpbi5pZFxuXG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGZpbmRET01FbGVtZW50KHRhcmdldClcblxuICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XG4gICAgICB0aGlzLmlzVGFyZ2V0RE9NRWwgPSB0cnVlXG5cbiAgICAgIC8vIEFQSSBmb3IgcGx1Z2lucyB0aGF0IHJlcXVpcmUgYSBzeW5jaHJvbm91cyByZXJlbmRlci5cbiAgICAgIHRoaXMucmVyZW5kZXIgPSAoc3RhdGUpID0+IHtcbiAgICAgICAgLy8gcGx1Z2luIGNvdWxkIGJlIHJlbW92ZWQsIGJ1dCB0aGlzLnJlcmVuZGVyIGlzIGRlYm91bmNlZCBiZWxvdyxcbiAgICAgICAgLy8gc28gaXQgY291bGQgc3RpbGwgYmUgY2FsbGVkIGV2ZW4gYWZ0ZXIgdXBweS5yZW1vdmVQbHVnaW4gb3IgdXBweS5jbG9zZVxuICAgICAgICAvLyBoZW5jZSB0aGUgY2hlY2tcbiAgICAgICAgaWYgKCF0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMuaWQpKSByZXR1cm5cbiAgICAgICAgdGhpcy5lbCA9IHByZWFjdC5yZW5kZXIodGhpcy5yZW5kZXIoc3RhdGUpLCB0YXJnZXRFbGVtZW50LCB0aGlzLmVsKVxuICAgICAgICB0aGlzLmFmdGVyVXBkYXRlKClcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZVVJID0gZGVib3VuY2UodGhpcy5yZXJlbmRlcilcblxuICAgICAgdGhpcy51cHB5LmxvZyhgSW5zdGFsbGluZyAke2NhbGxlclBsdWdpbk5hbWV9IHRvIGEgRE9NIGVsZW1lbnQgJyR7dGFyZ2V0fSdgKVxuXG4gICAgICAvLyBjbGVhciBldmVyeXRoaW5nIGluc2lkZSB0aGUgdGFyZ2V0IGNvbnRhaW5lclxuICAgICAgaWYgKHRoaXMub3B0cy5yZXBsYWNlVGFyZ2V0Q29udGVudCkge1xuICAgICAgICB0YXJnZXRFbGVtZW50LmlubmVySFRNTCA9ICcnXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwgPSBwcmVhY3QucmVuZGVyKHRoaXMucmVuZGVyKHRoaXMudXBweS5nZXRTdGF0ZSgpKSwgdGFyZ2V0RWxlbWVudClcblxuICAgICAgdGhpcy5vbk1vdW50KClcbiAgICAgIHJldHVybiB0aGlzLmVsXG4gICAgfVxuXG4gICAgbGV0IHRhcmdldFBsdWdpblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0YXJnZXQgaW5zdGFuY2VvZiBQbHVnaW4pIHtcbiAgICAgIC8vIFRhcmdldGluZyBhIHBsdWdpbiAqaW5zdGFuY2UqXG4gICAgICB0YXJnZXRQbHVnaW4gPSB0YXJnZXRcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRhcmdldGluZyBhIHBsdWdpbiB0eXBlXG4gICAgICBjb25zdCBUYXJnZXQgPSB0YXJnZXRcbiAgICAgIC8vIEZpbmQgdGhlIHRhcmdldCBwbHVnaW4gaW5zdGFuY2UuXG4gICAgICB0aGlzLnVwcHkuaXRlcmF0ZVBsdWdpbnMoKHBsdWdpbikgPT4ge1xuICAgICAgICBpZiAocGx1Z2luIGluc3RhbmNlb2YgVGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0UGx1Z2luID0gcGx1Z2luXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHRhcmdldFBsdWdpbikge1xuICAgICAgdGhpcy51cHB5LmxvZyhgSW5zdGFsbGluZyAke2NhbGxlclBsdWdpbk5hbWV9IHRvICR7dGFyZ2V0UGx1Z2luLmlkfWApXG4gICAgICB0aGlzLnBhcmVudCA9IHRhcmdldFBsdWdpblxuICAgICAgdGhpcy5lbCA9IHRhcmdldFBsdWdpbi5hZGRUYXJnZXQocGx1Z2luKVxuXG4gICAgICB0aGlzLm9uTW91bnQoKVxuICAgICAgcmV0dXJuIHRoaXMuZWxcbiAgICB9XG5cbiAgICB0aGlzLnVwcHkubG9nKGBOb3QgaW5zdGFsbGluZyAke2NhbGxlclBsdWdpbk5hbWV9YClcblxuICAgIGxldCBtZXNzYWdlID0gYEludmFsaWQgdGFyZ2V0IG9wdGlvbiBnaXZlbiB0byAke2NhbGxlclBsdWdpbk5hbWV9LmBcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbWVzc2FnZSArPSAnIFRoZSBnaXZlbiB0YXJnZXQgaXMgbm90IGEgUGx1Z2luIGNsYXNzLiAnXG4gICAgICAgICsgJ1BsZWFzZSBjaGVjayB0aGF0IHlvdVxcJ3JlIG5vdCBzcGVjaWZ5aW5nIGEgUmVhY3QgQ29tcG9uZW50IGluc3RlYWQgb2YgYSBwbHVnaW4uICdcbiAgICAgICAgKyAnSWYgeW91IGFyZSB1c2luZyBAdXBweS8qIHBhY2thZ2VzIGRpcmVjdGx5LCBtYWtlIHN1cmUgeW91IGhhdmUgb25seSAxIHZlcnNpb24gb2YgQHVwcHkvY29yZSBpbnN0YWxsZWQ6ICdcbiAgICAgICAgKyAncnVuIGBucG0gbHMgQHVwcHkvY29yZWAgb24gdGhlIGNvbW1hbmQgbGluZSBhbmQgdmVyaWZ5IHRoYXQgYWxsIHRoZSB2ZXJzaW9ucyBtYXRjaCBhbmQgYXJlIGRlZHVwZWQgY29ycmVjdGx5LidcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZSArPSAnSWYgeW91IG1lYW50IHRvIHRhcmdldCBhbiBIVE1MIGVsZW1lbnQsIHBsZWFzZSBtYWtlIHN1cmUgdGhhdCB0aGUgZWxlbWVudCBleGlzdHMuICdcbiAgICAgICAgKyAnQ2hlY2sgdGhhdCB0aGUgPHNjcmlwdD4gdGFnIGluaXRpYWxpemluZyBVcHB5IGlzIHJpZ2h0IGJlZm9yZSB0aGUgY2xvc2luZyA8L2JvZHk+IHRhZyBhdCB0aGUgZW5kIG9mIHRoZSBwYWdlLiAnXG4gICAgICAgICsgJyhzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzLzEwNDIpXFxuXFxuJ1xuICAgICAgICArICdJZiB5b3UgbWVhbnQgdG8gdGFyZ2V0IGEgcGx1Z2luLCBwbGVhc2UgY29uZmlybSB0aGF0IHlvdXIgYGltcG9ydGAgc3RhdGVtZW50cyBvciBgcmVxdWlyZWAgY2FsbHMgYXJlIGNvcnJlY3QuJ1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUpIHtcbiAgICB0aHJvdyAobmV3IEVycm9yKCdFeHRlbmQgdGhlIHJlbmRlciBtZXRob2QgdG8gYWRkIHlvdXIgcGx1Z2luIHRvIGEgRE9NIGVsZW1lbnQnKSlcbiAgfVxuXG4gIGFkZFRhcmdldCAocGx1Z2luKSB7XG4gICAgdGhyb3cgKG5ldyBFcnJvcignRXh0ZW5kIHRoZSBhZGRUYXJnZXQgbWV0aG9kIHRvIGFkZCB5b3VyIHBsdWdpbiB0byBhbm90aGVyIHBsdWdpblxcJ3MgdGFyZ2V0JykpXG4gIH1cblxuICB1bm1vdW50ICgpIHtcbiAgICBpZiAodGhpcy5pc1RhcmdldERPTUVsICYmIHRoaXMuZWwgJiYgdGhpcy5lbC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbClcbiAgICB9XG4gIH1cblxuICBpbnN0YWxsICgpIHtcblxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG59XG4iLCIvKiBnbG9iYWwgQWdncmVnYXRlRXJyb3IgKi9cbmNvbnN0IFRyYW5zbGF0b3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvVHJhbnNsYXRvcicpXG5jb25zdCBlZSA9IHJlcXVpcmUoJ25hbWVzcGFjZS1lbWl0dGVyJylcbmNvbnN0IGN1aWQgPSByZXF1aXJlKCdjdWlkJylcbmNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgnbG9kYXNoLnRocm90dGxlJylcbmNvbnN0IHByZXR0aWVyQnl0ZXMgPSByZXF1aXJlKCdAdHJhbnNsb2FkaXQvcHJldHRpZXItYnl0ZXMnKVxuY29uc3QgbWF0Y2ggPSByZXF1aXJlKCdtaW1lLW1hdGNoJylcbmNvbnN0IERlZmF1bHRTdG9yZSA9IHJlcXVpcmUoJ0B1cHB5L3N0b3JlLWRlZmF1bHQnKVxuY29uc3QgZ2V0RmlsZVR5cGUgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0RmlsZVR5cGUnKVxuY29uc3QgZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24gPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24nKVxuY29uc3QgZ2VuZXJhdGVGaWxlSUQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2VuZXJhdGVGaWxlSUQnKVxuY29uc3QgZmluZEluZGV4ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2ZpbmRJbmRleCcpXG5jb25zdCBzdXBwb3J0c1VwbG9hZFByb2dyZXNzID0gcmVxdWlyZSgnLi9zdXBwb3J0c1VwbG9hZFByb2dyZXNzJylcbmNvbnN0IHsganVzdEVycm9yc0xvZ2dlciwgZGVidWdMb2dnZXIgfSA9IHJlcXVpcmUoJy4vbG9nZ2VycycpXG5jb25zdCBQbHVnaW4gPSByZXF1aXJlKCcuL1BsdWdpbicpXG5jb25zdCB7IHZlcnNpb24gfSA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpXG5cbi8vIEV4cG9ydGVkIGZyb20gaGVyZS5cbmNsYXNzIFJlc3RyaWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLmlzUmVzdHJpY3Rpb24gPSB0cnVlXG4gIH1cbn1cblxuLyoqXG4gKiBVcHB5IENvcmUgbW9kdWxlLlxuICogTWFuYWdlcyBwbHVnaW5zLCBzdGF0ZSB1cGRhdGVzLCBhY3RzIGFzIGFuIGV2ZW50IGJ1cyxcbiAqIGFkZHMvcmVtb3ZlcyBmaWxlcyBhbmQgbWV0YWRhdGEuXG4gKi9cbmNsYXNzIFVwcHkge1xuICBzdGF0aWMgVkVSU0lPTiA9IHZlcnNpb25cblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgVXBweVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyDigJQgVXBweSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IHtcbiAgICAgIHN0cmluZ3M6IHtcbiAgICAgICAgYWRkQnVsa0ZpbGVzRmFpbGVkOiB7XG4gICAgICAgICAgMDogJ0ZhaWxlZCB0byBhZGQgJXtzbWFydF9jb3VudH0gZmlsZSBkdWUgdG8gYW4gaW50ZXJuYWwgZXJyb3InLFxuICAgICAgICAgIDE6ICdGYWlsZWQgdG8gYWRkICV7c21hcnRfY291bnR9IGZpbGVzIGR1ZSB0byBpbnRlcm5hbCBlcnJvcnMnLFxuICAgICAgICB9LFxuICAgICAgICB5b3VDYW5Pbmx5VXBsb2FkWDoge1xuICAgICAgICAgIDA6ICdZb3UgY2FuIG9ubHkgdXBsb2FkICV7c21hcnRfY291bnR9IGZpbGUnLFxuICAgICAgICAgIDE6ICdZb3UgY2FuIG9ubHkgdXBsb2FkICV7c21hcnRfY291bnR9IGZpbGVzJyxcbiAgICAgICAgfSxcbiAgICAgICAgeW91SGF2ZVRvQXRMZWFzdFNlbGVjdFg6IHtcbiAgICAgICAgICAwOiAnWW91IGhhdmUgdG8gc2VsZWN0IGF0IGxlYXN0ICV7c21hcnRfY291bnR9IGZpbGUnLFxuICAgICAgICAgIDE6ICdZb3UgaGF2ZSB0byBzZWxlY3QgYXQgbGVhc3QgJXtzbWFydF9jb3VudH0gZmlsZXMnLFxuICAgICAgICB9LFxuICAgICAgICAvLyBUaGUgZGVmYXVsdCBgZXhjZWVkc1NpemUyYCBzdHJpbmcgb25seSBjb21iaW5lcyB0aGUgYGV4Y2VlZHNTaXplYCBzdHJpbmcgKCV7YmFja3dhcmRzQ29tcGF0fSkgd2l0aCB0aGUgc2l6ZS5cbiAgICAgICAgLy8gTG9jYWxlcyBjYW4gb3ZlcnJpZGUgYGV4Y2VlZHNTaXplMmAgdG8gc3BlY2lmeSBhIGRpZmZlcmVudCB3b3JkIG9yZGVyLiBUaGlzIGlzIGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGhcbiAgICAgICAgLy8gVXBweSAxLjkueCBhbmQgYmVsb3cgd2hpY2ggZGlkIGEgbmFpdmUgY29uY2F0ZW5hdGlvbiBvZiBgZXhjZWVkc1NpemUyICsgc2l6ZWAgaW5zdGVhZCBvZiB1c2luZyBhIGxvY2FsZS1zcGVjaWZpY1xuICAgICAgICAvLyBzdWJzdGl0dXRpb24uXG4gICAgICAgIC8vIFRPRE86IEluIDIuMCBgZXhjZWVkc1NpemUyYCBzaG91bGQgYmUgcmVtb3ZlZCBpbiBhbmQgYGV4Y2VlZHNTaXplYCB1cGRhdGVkIHRvIHVzZSBzdWJzdGl0dXRpb24uXG4gICAgICAgIGV4Y2VlZHNTaXplMjogJyV7YmFja3dhcmRzQ29tcGF0fSAle3NpemV9JyxcbiAgICAgICAgZXhjZWVkc1NpemU6ICcle2ZpbGV9IGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHNpemUgb2YnLFxuICAgICAgICBpbmZlcmlvclNpemU6ICdUaGlzIGZpbGUgaXMgc21hbGxlciB0aGFuIHRoZSBhbGxvd2VkIHNpemUgb2YgJXtzaXplfScsXG4gICAgICAgIHlvdUNhbk9ubHlVcGxvYWRGaWxlVHlwZXM6ICdZb3UgY2FuIG9ubHkgdXBsb2FkOiAle3R5cGVzfScsXG4gICAgICAgIG5vTmV3QWxyZWFkeVVwbG9hZGluZzogJ0Nhbm5vdCBhZGQgbmV3IGZpbGVzOiBhbHJlYWR5IHVwbG9hZGluZycsXG4gICAgICAgIG5vRHVwbGljYXRlczogJ0Nhbm5vdCBhZGQgdGhlIGR1cGxpY2F0ZSBmaWxlIFxcJyV7ZmlsZU5hbWV9XFwnLCBpdCBhbHJlYWR5IGV4aXN0cycsXG4gICAgICAgIGNvbXBhbmlvbkVycm9yOiAnQ29ubmVjdGlvbiB3aXRoIENvbXBhbmlvbiBmYWlsZWQnLFxuICAgICAgICBjb21wYW5pb25VbmF1dGhvcml6ZUhpbnQ6ICdUbyB1bmF1dGhvcml6ZSB0byB5b3VyICV7cHJvdmlkZXJ9IGFjY291bnQsIHBsZWFzZSBnbyB0byAle3VybH0nLFxuICAgICAgICBmYWlsZWRUb1VwbG9hZDogJ0ZhaWxlZCB0byB1cGxvYWQgJXtmaWxlfScsXG4gICAgICAgIG5vSW50ZXJuZXRDb25uZWN0aW9uOiAnTm8gSW50ZXJuZXQgY29ubmVjdGlvbicsXG4gICAgICAgIGNvbm5lY3RlZFRvSW50ZXJuZXQ6ICdDb25uZWN0ZWQgdG8gdGhlIEludGVybmV0JyxcbiAgICAgICAgLy8gU3RyaW5ncyBmb3IgcmVtb3RlIHByb3ZpZGVyc1xuICAgICAgICBub0ZpbGVzRm91bmQ6ICdZb3UgaGF2ZSBubyBmaWxlcyBvciBmb2xkZXJzIGhlcmUnLFxuICAgICAgICBzZWxlY3RYOiB7XG4gICAgICAgICAgMDogJ1NlbGVjdCAle3NtYXJ0X2NvdW50fScsXG4gICAgICAgICAgMTogJ1NlbGVjdCAle3NtYXJ0X2NvdW50fScsXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdEFsbEZpbGVzRnJvbUZvbGRlck5hbWVkOiAnU2VsZWN0IGFsbCBmaWxlcyBmcm9tIGZvbGRlciAle25hbWV9JyxcbiAgICAgICAgdW5zZWxlY3RBbGxGaWxlc0Zyb21Gb2xkZXJOYW1lZDogJ1Vuc2VsZWN0IGFsbCBmaWxlcyBmcm9tIGZvbGRlciAle25hbWV9JyxcbiAgICAgICAgc2VsZWN0RmlsZU5hbWVkOiAnU2VsZWN0IGZpbGUgJXtuYW1lfScsXG4gICAgICAgIHVuc2VsZWN0RmlsZU5hbWVkOiAnVW5zZWxlY3QgZmlsZSAle25hbWV9JyxcbiAgICAgICAgb3BlbkZvbGRlck5hbWVkOiAnT3BlbiBmb2xkZXIgJXtuYW1lfScsXG4gICAgICAgIGNhbmNlbDogJ0NhbmNlbCcsXG4gICAgICAgIGxvZ091dDogJ0xvZyBvdXQnLFxuICAgICAgICBmaWx0ZXI6ICdGaWx0ZXInLFxuICAgICAgICByZXNldEZpbHRlcjogJ1Jlc2V0IGZpbHRlcicsXG4gICAgICAgIGxvYWRpbmc6ICdMb2FkaW5nLi4uJyxcbiAgICAgICAgYXV0aGVudGljYXRlV2l0aFRpdGxlOiAnUGxlYXNlIGF1dGhlbnRpY2F0ZSB3aXRoICV7cGx1Z2luTmFtZX0gdG8gc2VsZWN0IGZpbGVzJyxcbiAgICAgICAgYXV0aGVudGljYXRlV2l0aDogJ0Nvbm5lY3QgdG8gJXtwbHVnaW5OYW1lfScsXG4gICAgICAgIHNlYXJjaEltYWdlczogJ1NlYXJjaCBmb3IgaW1hZ2VzJyxcbiAgICAgICAgZW50ZXJUZXh0VG9TZWFyY2g6ICdFbnRlciB0ZXh0IHRvIHNlYXJjaCBmb3IgaW1hZ2VzJyxcbiAgICAgICAgYmFja1RvU2VhcmNoOiAnQmFjayB0byBTZWFyY2gnLFxuICAgICAgICBlbXB0eUZvbGRlckFkZGVkOiAnTm8gZmlsZXMgd2VyZSBhZGRlZCBmcm9tIGVtcHR5IGZvbGRlcicsXG4gICAgICAgIGZvbGRlckFkZGVkOiB7XG4gICAgICAgICAgMDogJ0FkZGVkICV7c21hcnRfY291bnR9IGZpbGUgZnJvbSAle2ZvbGRlcn0nLFxuICAgICAgICAgIDE6ICdBZGRlZCAle3NtYXJ0X2NvdW50fSBmaWxlcyBmcm9tICV7Zm9sZGVyfScsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgaWQ6ICd1cHB5JyxcbiAgICAgIGF1dG9Qcm9jZWVkOiBmYWxzZSxcbiAgICAgIGFsbG93TXVsdGlwbGVVcGxvYWRzOiB0cnVlLFxuICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgcmVzdHJpY3Rpb25zOiB7XG4gICAgICAgIG1heEZpbGVTaXplOiBudWxsLFxuICAgICAgICBtaW5GaWxlU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4VG90YWxGaWxlU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4TnVtYmVyT2ZGaWxlczogbnVsbCxcbiAgICAgICAgbWluTnVtYmVyT2ZGaWxlczogbnVsbCxcbiAgICAgICAgYWxsb3dlZEZpbGVUeXBlczogbnVsbCxcbiAgICAgIH0sXG4gICAgICBtZXRhOiB7fSxcbiAgICAgIG9uQmVmb3JlRmlsZUFkZGVkOiAoY3VycmVudEZpbGUpID0+IGN1cnJlbnRGaWxlLFxuICAgICAgb25CZWZvcmVVcGxvYWQ6IChmaWxlcykgPT4gZmlsZXMsXG4gICAgICBzdG9yZTogRGVmYXVsdFN0b3JlKCksXG4gICAgICBsb2dnZXI6IGp1c3RFcnJvcnNMb2dnZXIsXG4gICAgICBpbmZvVGltZW91dDogNTAwMCxcbiAgICB9XG5cbiAgICAvLyBNZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlcixcbiAgICAvLyBtYWtpbmcgc3VyZSB0byBtZXJnZSByZXN0cmljdGlvbnMgdG9vXG4gICAgdGhpcy5vcHRzID0ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRzLFxuICAgICAgcmVzdHJpY3Rpb25zOiB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLnJlc3RyaWN0aW9ucyxcbiAgICAgICAgLi4uKG9wdHMgJiYgb3B0cy5yZXN0cmljdGlvbnMpLFxuICAgICAgfSxcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IGRlYnVnOiB0cnVlIGZvciBiYWNrd2FyZHMtY29tcGF0YWJpbGl0eSwgdW5sZXNzIGxvZ2dlciBpcyBzZXQgaW4gb3B0c1xuICAgIC8vIG9wdHMgaW5zdGVhZCBvZiB0aGlzLm9wdHMgdG8gYXZvaWQgY29tcGFyaW5nIG9iamVjdHMg4oCUIHdlIHNldCBsb2dnZXI6IGp1c3RFcnJvcnNMb2dnZXIgaW4gZGVmYXVsdE9wdGlvbnNcbiAgICBpZiAob3B0cyAmJiBvcHRzLmxvZ2dlciAmJiBvcHRzLmRlYnVnKSB7XG4gICAgICB0aGlzLmxvZygnWW91IGFyZSB1c2luZyBhIGN1c3RvbSBgbG9nZ2VyYCwgYnV0IGFsc28gc2V0IGBkZWJ1ZzogdHJ1ZWAsIHdoaWNoIHVzZXMgYnVpbHQtaW4gbG9nZ2VyIHRvIG91dHB1dCBsb2dzIHRvIGNvbnNvbGUuIElnbm9yaW5nIGBkZWJ1ZzogdHJ1ZWAgYW5kIHVzaW5nIHlvdXIgY3VzdG9tIGBsb2dnZXJgLicsICd3YXJuaW5nJylcbiAgICB9IGVsc2UgaWYgKG9wdHMgJiYgb3B0cy5kZWJ1Zykge1xuICAgICAgdGhpcy5vcHRzLmxvZ2dlciA9IGRlYnVnTG9nZ2VyXG4gICAgfVxuXG4gICAgdGhpcy5sb2coYFVzaW5nIENvcmUgdiR7dGhpcy5jb25zdHJ1Y3Rvci5WRVJTSU9OfWApXG5cbiAgICBpZiAodGhpcy5vcHRzLnJlc3RyaWN0aW9ucy5hbGxvd2VkRmlsZVR5cGVzXG4gICAgICAgICYmIHRoaXMub3B0cy5yZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcyAhPT0gbnVsbFxuICAgICAgICAmJiAhQXJyYXkuaXNBcnJheSh0aGlzLm9wdHMucmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgcmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXNgIG11c3QgYmUgYW4gYXJyYXknKVxuICAgIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuXG4gICAgLy8gQ29udGFpbmVyIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgcGx1Z2luc1xuICAgIHRoaXMucGx1Z2lucyA9IHt9XG5cbiAgICB0aGlzLmdldFN0YXRlID0gdGhpcy5nZXRTdGF0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5nZXRQbHVnaW4gPSB0aGlzLmdldFBsdWdpbi5iaW5kKHRoaXMpXG4gICAgdGhpcy5zZXRGaWxlTWV0YSA9IHRoaXMuc2V0RmlsZU1ldGEuYmluZCh0aGlzKVxuICAgIHRoaXMuc2V0RmlsZVN0YXRlID0gdGhpcy5zZXRGaWxlU3RhdGUuYmluZCh0aGlzKVxuICAgIHRoaXMubG9nID0gdGhpcy5sb2cuYmluZCh0aGlzKVxuICAgIHRoaXMuaW5mbyA9IHRoaXMuaW5mby5iaW5kKHRoaXMpXG4gICAgdGhpcy5oaWRlSW5mbyA9IHRoaXMuaGlkZUluZm8uYmluZCh0aGlzKVxuICAgIHRoaXMuYWRkRmlsZSA9IHRoaXMuYWRkRmlsZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW1vdmVGaWxlID0gdGhpcy5yZW1vdmVGaWxlLmJpbmQodGhpcylcbiAgICB0aGlzLnBhdXNlUmVzdW1lID0gdGhpcy5wYXVzZVJlc3VtZS5iaW5kKHRoaXMpXG4gICAgdGhpcy52YWxpZGF0ZVJlc3RyaWN0aW9ucyA9IHRoaXMudmFsaWRhdGVSZXN0cmljdGlvbnMuYmluZCh0aGlzKVxuXG4gICAgLy8gX19fV2h5IHRocm90dGxlIGF0IDUwMG1zP1xuICAgIC8vICAgIC0gV2UgbXVzdCB0aHJvdHRsZSBhdCA+MjUwbXMgZm9yIHN1cGVyZm9jdXMgaW4gRGFzaGJvYXJkIHRvIHdvcmsgd2VsbFxuICAgIC8vICAgIChiZWNhdXNlIGFuaW1hdGlvbiB0YWtlcyAwLjI1cywgYW5kIHdlIHdhbnQgdG8gd2FpdCBmb3IgYWxsIGFuaW1hdGlvbnMgdG8gYmUgb3ZlciBiZWZvcmUgcmVmb2N1c2luZykuXG4gICAgLy8gICAgW1ByYWN0aWNhbCBDaGVja106IGlmIHRob3R0bGUgaXMgYXQgMTAwbXMsIHRoZW4gaWYgeW91IGFyZSB1cGxvYWRpbmcgYSBmaWxlLFxuICAgIC8vICAgIGFuZCBjbGljayAnQUREIE1PUkUgRklMRVMnLCAtIGZvY3VzIHdvbid0IGFjdGl2YXRlIGluIEZpcmVmb3guXG4gICAgLy8gICAgLSBXZSBtdXN0IHRocm90dGxlIGF0IGFyb3VuZCA+NTAwbXMgdG8gYXZvaWQgcGVyZm9ybWFuY2UgbGFncy5cbiAgICAvLyAgICBbUHJhY3RpY2FsIENoZWNrXSBGaXJlZm94LCB0cnkgdG8gdXBsb2FkIGEgYmlnIGZpbGUgZm9yIGEgcHJvbG9uZ2VkIHBlcmlvZCBvZiB0aW1lLiBMYXB0b3Agd2lsbCBzdGFydCB0byBoZWF0IHVwLlxuICAgIHRoaXMuY2FsY3VsYXRlUHJvZ3Jlc3MgPSB0aHJvdHRsZSh0aGlzLmNhbGN1bGF0ZVByb2dyZXNzLmJpbmQodGhpcyksIDUwMCwgeyBsZWFkaW5nOiB0cnVlLCB0cmFpbGluZzogdHJ1ZSB9KVxuXG4gICAgdGhpcy51cGRhdGVPbmxpbmVTdGF0dXMgPSB0aGlzLnVwZGF0ZU9ubGluZVN0YXR1cy5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZXNldFByb2dyZXNzID0gdGhpcy5yZXNldFByb2dyZXNzLmJpbmQodGhpcylcblxuICAgIHRoaXMucGF1c2VBbGwgPSB0aGlzLnBhdXNlQWxsLmJpbmQodGhpcylcbiAgICB0aGlzLnJlc3VtZUFsbCA9IHRoaXMucmVzdW1lQWxsLmJpbmQodGhpcylcbiAgICB0aGlzLnJldHJ5QWxsID0gdGhpcy5yZXRyeUFsbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5jYW5jZWxBbGwgPSB0aGlzLmNhbmNlbEFsbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZXRyeVVwbG9hZCA9IHRoaXMucmV0cnlVcGxvYWQuYmluZCh0aGlzKVxuICAgIHRoaXMudXBsb2FkID0gdGhpcy51cGxvYWQuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5lbWl0dGVyID0gZWUoKVxuICAgIHRoaXMub24gPSB0aGlzLm9uLmJpbmQodGhpcylcbiAgICB0aGlzLm9mZiA9IHRoaXMub2ZmLmJpbmQodGhpcylcbiAgICB0aGlzLm9uY2UgPSB0aGlzLmVtaXR0ZXIub25jZS5iaW5kKHRoaXMuZW1pdHRlcilcbiAgICB0aGlzLmVtaXQgPSB0aGlzLmVtaXR0ZXIuZW1pdC5iaW5kKHRoaXMuZW1pdHRlcilcblxuICAgIHRoaXMucHJlUHJvY2Vzc29ycyA9IFtdXG4gICAgdGhpcy51cGxvYWRlcnMgPSBbXVxuICAgIHRoaXMucG9zdFByb2Nlc3NvcnMgPSBbXVxuXG4gICAgdGhpcy5zdG9yZSA9IHRoaXMub3B0cy5zdG9yZVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgcGx1Z2luczoge30sXG4gICAgICBmaWxlczoge30sXG4gICAgICBjdXJyZW50VXBsb2Fkczoge30sXG4gICAgICBhbGxvd05ld1VwbG9hZDogdHJ1ZSxcbiAgICAgIGNhcGFiaWxpdGllczoge1xuICAgICAgICB1cGxvYWRQcm9ncmVzczogc3VwcG9ydHNVcGxvYWRQcm9ncmVzcygpLFxuICAgICAgICBpbmRpdmlkdWFsQ2FuY2VsbGF0aW9uOiB0cnVlLFxuICAgICAgICByZXN1bWFibGVVcGxvYWRzOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICB0b3RhbFByb2dyZXNzOiAwLFxuICAgICAgbWV0YTogeyAuLi50aGlzLm9wdHMubWV0YSB9LFxuICAgICAgaW5mbzoge1xuICAgICAgICBpc0hpZGRlbjogdHJ1ZSxcbiAgICAgICAgdHlwZTogJ2luZm8nLFxuICAgICAgICBtZXNzYWdlOiAnJyxcbiAgICAgIH0sXG4gICAgICByZWNvdmVyZWRTdGF0ZTogbnVsbCxcbiAgICB9KVxuXG4gICAgdGhpcy5zdG9yZVVuc3Vic2NyaWJlID0gdGhpcy5zdG9yZS5zdWJzY3JpYmUoKHByZXZTdGF0ZSwgbmV4dFN0YXRlLCBwYXRjaCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdzdGF0ZS11cGRhdGUnLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSwgcGF0Y2gpXG4gICAgICB0aGlzLnVwZGF0ZUFsbChuZXh0U3RhdGUpXG4gICAgfSlcblxuICAgIC8vIEV4cG9zaW5nIHVwcHkgb2JqZWN0IG9uIHdpbmRvdyBmb3IgZGVidWdnaW5nIGFuZCB0ZXN0aW5nXG4gICAgaWYgKHRoaXMub3B0cy5kZWJ1ZyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93W3RoaXMub3B0cy5pZF0gPSB0aGlzXG4gICAgfVxuXG4gICAgdGhpcy5hZGRMaXN0ZW5lcnMoKVxuXG4gICAgLy8gUmUtZW5hYmxlIGlmIHdl4oCZbGwgbmVlZCBzb21lIGNhcGFiaWxpdGllcyBvbiBib290LCBsaWtlIGlzTW9iaWxlRGV2aWNlXG4gICAgLy8gdGhpcy5fc2V0Q2FwYWJpbGl0aWVzKClcbiAgfVxuXG4gIC8vIF9zZXRDYXBhYmlsaXRpZXMgPSAoKSA9PiB7XG4gIC8vICAgY29uc3QgY2FwYWJpbGl0aWVzID0ge1xuICAvLyAgICAgaXNNb2JpbGVEZXZpY2U6IGlzTW9iaWxlRGV2aWNlKClcbiAgLy8gICB9XG5cbiAgLy8gICB0aGlzLnNldFN0YXRlKHtcbiAgLy8gICAgIC4uLnRoaXMuZ2V0U3RhdGUoKS5jYXBhYmlsaXRpZXMsXG4gIC8vICAgICBjYXBhYmlsaXRpZXNcbiAgLy8gICB9KVxuICAvLyB9XG5cbiAgb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlci5vbihldmVudCwgY2FsbGJhY2spXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG9mZiAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9mZihldmVudCwgY2FsbGJhY2spXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG9uIGFsbCBwbHVnaW5zIGFuZCBydW4gYHVwZGF0ZWAgb24gdGhlbS5cbiAgICogQ2FsbGVkIGVhY2ggdGltZSBzdGF0ZSBjaGFuZ2VzLlxuICAgKlxuICAgKi9cbiAgdXBkYXRlQWxsIChzdGF0ZSkge1xuICAgIHRoaXMuaXRlcmF0ZVBsdWdpbnMocGx1Z2luID0+IHtcbiAgICAgIHBsdWdpbi51cGRhdGUoc3RhdGUpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHN0YXRlIHdpdGggYSBwYXRjaFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGF0Y2gge2ZvbzogJ2Jhcid9XG4gICAqL1xuICBzZXRTdGF0ZSAocGF0Y2gpIHtcbiAgICB0aGlzLnN0b3JlLnNldFN0YXRlKHBhdGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY3VycmVudCBzdGF0ZS5cbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGdldFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogQmFjayBjb21wYXQgZm9yIHdoZW4gdXBweS5zdGF0ZSBpcyB1c2VkIGluc3RlYWQgb2YgdXBweS5nZXRTdGF0ZSgpLlxuICAgKi9cbiAgZ2V0IHN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpXG4gIH1cblxuICAvKipcbiAgICogU2hvcnRoYW5kIHRvIHNldCBzdGF0ZSBmb3IgYSBzcGVjaWZpYyBmaWxlLlxuICAgKi9cbiAgc2V0RmlsZVN0YXRlIChmaWxlSUQsIHN0YXRlKSB7XG4gICAgaWYgKCF0aGlzLmdldFN0YXRlKCkuZmlsZXNbZmlsZUlEXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW7igJl0IHNldCBzdGF0ZSBmb3IgJHtmaWxlSUR9ICh0aGUgZmlsZSBjb3VsZCBoYXZlIGJlZW4gcmVtb3ZlZClgKVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZmlsZXM6IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzLCBbZmlsZUlEXTogeyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXNbZmlsZUlEXSwgLi4uc3RhdGUgfSB9LFxuICAgIH0pXG4gIH1cblxuICBpMThuSW5pdCAoKSB7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoW3RoaXMuZGVmYXVsdExvY2FsZSwgdGhpcy5vcHRzLmxvY2FsZV0pXG4gICAgdGhpcy5sb2NhbGUgPSB0aGlzLnRyYW5zbGF0b3IubG9jYWxlXG4gICAgdGhpcy5pMThuID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLmkxOG5BcnJheSA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGVBcnJheS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgfVxuXG4gIHNldE9wdGlvbnMgKG5ld09wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSB7XG4gICAgICAuLi50aGlzLm9wdHMsXG4gICAgICAuLi5uZXdPcHRzLFxuICAgICAgcmVzdHJpY3Rpb25zOiB7XG4gICAgICAgIC4uLnRoaXMub3B0cy5yZXN0cmljdGlvbnMsXG4gICAgICAgIC4uLihuZXdPcHRzICYmIG5ld09wdHMucmVzdHJpY3Rpb25zKSxcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgaWYgKG5ld09wdHMubWV0YSkge1xuICAgICAgdGhpcy5zZXRNZXRhKG5ld09wdHMubWV0YSlcbiAgICB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcblxuICAgIGlmIChuZXdPcHRzLmxvY2FsZSkge1xuICAgICAgdGhpcy5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICAgIHBsdWdpbi5zZXRPcHRpb25zKClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gTm90ZTogdGhpcyBpcyBub3QgdGhlIHByZWFjdCBgc2V0U3RhdGVgLCBpdCdzIGFuIGludGVybmFsIGZ1bmN0aW9uIHRoYXQgaGFzIHRoZSBzYW1lIG5hbWUuXG4gICAgdGhpcy5zZXRTdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyB3aXRoIG5ldyBvcHRpb25zXG4gIH1cblxuICByZXNldFByb2dyZXNzICgpIHtcbiAgICBjb25zdCBkZWZhdWx0UHJvZ3Jlc3MgPSB7XG4gICAgICBwZXJjZW50YWdlOiAwLFxuICAgICAgYnl0ZXNVcGxvYWRlZDogMCxcbiAgICAgIHVwbG9hZENvbXBsZXRlOiBmYWxzZSxcbiAgICAgIHVwbG9hZFN0YXJ0ZWQ6IG51bGwsXG4gICAgfVxuICAgIGNvbnN0IGZpbGVzID0geyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMgfVxuICAgIGNvbnN0IHVwZGF0ZWRGaWxlcyA9IHt9XG4gICAgT2JqZWN0LmtleXMoZmlsZXMpLmZvckVhY2goZmlsZUlEID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRGaWxlID0geyAuLi5maWxlc1tmaWxlSURdIH1cbiAgICAgIHVwZGF0ZWRGaWxlLnByb2dyZXNzID0geyAuLi51cGRhdGVkRmlsZS5wcm9ncmVzcywgLi4uZGVmYXVsdFByb2dyZXNzIH1cbiAgICAgIHVwZGF0ZWRGaWxlc1tmaWxlSURdID0gdXBkYXRlZEZpbGVcbiAgICB9KVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBmaWxlczogdXBkYXRlZEZpbGVzLFxuICAgICAgdG90YWxQcm9ncmVzczogMCxcbiAgICB9KVxuXG4gICAgdGhpcy5lbWl0KCdyZXNldC1wcm9ncmVzcycpXG4gIH1cblxuICBhZGRQcmVQcm9jZXNzb3IgKGZuKSB7XG4gICAgdGhpcy5wcmVQcm9jZXNzb3JzLnB1c2goZm4pXG4gIH1cblxuICByZW1vdmVQcmVQcm9jZXNzb3IgKGZuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMucHJlUHJvY2Vzc29ycy5pbmRleE9mKGZuKVxuICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgdGhpcy5wcmVQcm9jZXNzb3JzLnNwbGljZShpLCAxKVxuICAgIH1cbiAgfVxuXG4gIGFkZFBvc3RQcm9jZXNzb3IgKGZuKSB7XG4gICAgdGhpcy5wb3N0UHJvY2Vzc29ycy5wdXNoKGZuKVxuICB9XG5cbiAgcmVtb3ZlUG9zdFByb2Nlc3NvciAoZm4pIHtcbiAgICBjb25zdCBpID0gdGhpcy5wb3N0UHJvY2Vzc29ycy5pbmRleE9mKGZuKVxuICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgdGhpcy5wb3N0UHJvY2Vzc29ycy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gIH1cblxuICBhZGRVcGxvYWRlciAoZm4pIHtcbiAgICB0aGlzLnVwbG9hZGVycy5wdXNoKGZuKVxuICB9XG5cbiAgcmVtb3ZlVXBsb2FkZXIgKGZuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMudXBsb2FkZXJzLmluZGV4T2YoZm4pXG4gICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICB0aGlzLnVwbG9hZGVycy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gIH1cblxuICBzZXRNZXRhIChkYXRhKSB7XG4gICAgY29uc3QgdXBkYXRlZE1ldGEgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5tZXRhLCAuLi5kYXRhIH1cbiAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcyB9XG5cbiAgICBPYmplY3Qua2V5cyh1cGRhdGVkRmlsZXMpLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgdXBkYXRlZEZpbGVzW2ZpbGVJRF0gPSB7IC4uLnVwZGF0ZWRGaWxlc1tmaWxlSURdLCBtZXRhOiB7IC4uLnVwZGF0ZWRGaWxlc1tmaWxlSURdLm1ldGEsIC4uLmRhdGEgfSB9XG4gICAgfSlcblxuICAgIHRoaXMubG9nKCdBZGRpbmcgbWV0YWRhdGE6JylcbiAgICB0aGlzLmxvZyhkYXRhKVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtZXRhOiB1cGRhdGVkTWV0YSxcbiAgICAgIGZpbGVzOiB1cGRhdGVkRmlsZXMsXG4gICAgfSlcbiAgfVxuXG4gIHNldEZpbGVNZXRhIChmaWxlSUQsIGRhdGEpIHtcbiAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlcyB9XG4gICAgaWYgKCF1cGRhdGVkRmlsZXNbZmlsZUlEXSkge1xuICAgICAgdGhpcy5sb2coJ1dhcyB0cnlpbmcgdG8gc2V0IG1ldGFkYXRhIGZvciBhIGZpbGUgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAnLCBmaWxlSUQpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgbmV3TWV0YSA9IHsgLi4udXBkYXRlZEZpbGVzW2ZpbGVJRF0ubWV0YSwgLi4uZGF0YSB9XG4gICAgdXBkYXRlZEZpbGVzW2ZpbGVJRF0gPSB7IC4uLnVwZGF0ZWRGaWxlc1tmaWxlSURdLCBtZXRhOiBuZXdNZXRhIH1cbiAgICB0aGlzLnNldFN0YXRlKHsgZmlsZXM6IHVwZGF0ZWRGaWxlcyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGZpbGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIFRoZSBJRCBvZiB0aGUgZmlsZSBvYmplY3QgdG8gcmV0dXJuLlxuICAgKi9cbiAgZ2V0RmlsZSAoZmlsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKS5maWxlc1tmaWxlSURdXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBmaWxlcyBpbiBhbiBhcnJheS5cbiAgICovXG4gIGdldEZpbGVzICgpIHtcbiAgICBjb25zdCB7IGZpbGVzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZmlsZXMpLm1hcCgoZmlsZUlEKSA9PiBmaWxlc1tmaWxlSURdKVxuICB9XG5cbiAgLyoqXG4gICAqIEEgcHVibGljIHdyYXBwZXIgZm9yIF9jaGVja1Jlc3RyaWN0aW9ucyDigJQgY2hlY2tzIGlmIGEgZmlsZSBwYXNzZXMgYSBzZXQgb2YgcmVzdHJpY3Rpb25zLlxuICAgKiBGb3IgdXNlIGluIFVJIHBsdWlnaW5zIChsaWtlIFByb3ZpZGVycyksIHRvIGRpc2FsbG93IHNlbGVjdGluZyBmaWxlcyB0aGF0IHdvbuKAmXQgcGFzcyByZXN0cmljdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlIG9iamVjdCB0byBjaGVja1xuICAgKiBAcGFyYW0ge0FycmF5fSBbZmlsZXNdIGFycmF5IHRvIGNoZWNrIG1heE51bWJlck9mRmlsZXMgYW5kIG1heFRvdGFsRmlsZVNpemVcbiAgICogQHJldHVybnMge29iamVjdH0geyByZXN1bHQ6IHRydWUvZmFsc2UsIHJlYXNvbjogd2h5IGZpbGUgZGlkbuKAmXQgcGFzcyByZXN0cmljdGlvbnMgfVxuICAgKi9cbiAgdmFsaWRhdGVSZXN0cmljdGlvbnMgKGZpbGUsIGZpbGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY2hlY2tSZXN0cmljdGlvbnMoZmlsZSwgZmlsZXMpXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICByZWFzb246IGVyci5tZXNzYWdlLFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBmaWxlIHBhc3NlcyBhIHNldCBvZiByZXN0cmljdGlvbnMgc2V0IGluIG9wdGlvbnM6IG1heEZpbGVTaXplLCBtaW5GaWxlU2l6ZSxcbiAgICogbWF4TnVtYmVyT2ZGaWxlcyBhbmQgYWxsb3dlZEZpbGVUeXBlcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGZpbGUgb2JqZWN0IHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtmaWxlc10gYXJyYXkgdG8gY2hlY2sgbWF4TnVtYmVyT2ZGaWxlcyBhbmQgbWF4VG90YWxGaWxlU2l6ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2hlY2tSZXN0cmljdGlvbnMgKGZpbGUsIGZpbGVzID0gdGhpcy5nZXRGaWxlcygpKSB7XG4gICAgY29uc3QgeyBtYXhGaWxlU2l6ZSwgbWluRmlsZVNpemUsIG1heFRvdGFsRmlsZVNpemUsIG1heE51bWJlck9mRmlsZXMsIGFsbG93ZWRGaWxlVHlwZXMgfSA9IHRoaXMub3B0cy5yZXN0cmljdGlvbnNcblxuICAgIGlmIChtYXhOdW1iZXJPZkZpbGVzKSB7XG4gICAgICBpZiAoZmlsZXMubGVuZ3RoICsgMSA+IG1heE51bWJlck9mRmlsZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlc3RyaWN0aW9uRXJyb3IoYCR7dGhpcy5pMThuKCd5b3VDYW5Pbmx5VXBsb2FkWCcsIHsgc21hcnRfY291bnQ6IG1heE51bWJlck9mRmlsZXMgfSl9YClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWxsb3dlZEZpbGVUeXBlcykge1xuICAgICAgY29uc3QgaXNDb3JyZWN0RmlsZVR5cGUgPSBhbGxvd2VkRmlsZVR5cGVzLnNvbWUoKHR5cGUpID0+IHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIG1pbWUtdHlwZVxuICAgICAgICBpZiAodHlwZS5pbmRleE9mKCcvJykgPiAtMSkge1xuICAgICAgICAgIGlmICghZmlsZS50eXBlKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICByZXR1cm4gbWF0Y2goZmlsZS50eXBlLnJlcGxhY2UoLzsuKj8kLywgJycpLCB0eXBlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoaXMgaXMgbGlrZWx5IGFuIGV4dGVuc2lvblxuICAgICAgICBpZiAodHlwZVswXSA9PT0gJy4nICYmIGZpbGUuZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbGUuZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkgPT09IHR5cGUuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0pXG5cbiAgICAgIGlmICghaXNDb3JyZWN0RmlsZVR5cGUpIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZEZpbGVUeXBlc1N0cmluZyA9IGFsbG93ZWRGaWxlVHlwZXMuam9pbignLCAnKVxuICAgICAgICB0aHJvdyBuZXcgUmVzdHJpY3Rpb25FcnJvcih0aGlzLmkxOG4oJ3lvdUNhbk9ubHlVcGxvYWRGaWxlVHlwZXMnLCB7IHR5cGVzOiBhbGxvd2VkRmlsZVR5cGVzU3RyaW5nIH0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IGNoZWNrIG1heFRvdGFsRmlsZVNpemUgaWYgdGhlIHNpemUgaXMgdW5rbm93bi5cbiAgICBpZiAobWF4VG90YWxGaWxlU2l6ZSAmJiBmaWxlLnNpemUgIT0gbnVsbCkge1xuICAgICAgbGV0IHRvdGFsRmlsZXNTaXplID0gMFxuICAgICAgdG90YWxGaWxlc1NpemUgKz0gZmlsZS5zaXplXG4gICAgICBmaWxlcy5mb3JFYWNoKChmKSA9PiB7XG4gICAgICAgIHRvdGFsRmlsZXNTaXplICs9IGYuc2l6ZVxuICAgICAgfSlcbiAgICAgIGlmICh0b3RhbEZpbGVzU2l6ZSA+IG1heFRvdGFsRmlsZVNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlc3RyaWN0aW9uRXJyb3IodGhpcy5pMThuKCdleGNlZWRzU2l6ZTInLCB7XG4gICAgICAgICAgYmFja3dhcmRzQ29tcGF0OiB0aGlzLmkxOG4oJ2V4Y2VlZHNTaXplJyksXG4gICAgICAgICAgc2l6ZTogcHJldHRpZXJCeXRlcyhtYXhUb3RhbEZpbGVTaXplKSxcbiAgICAgICAgICBmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IGNoZWNrIG1heEZpbGVTaXplIGlmIHRoZSBzaXplIGlzIHVua25vd24uXG4gICAgaWYgKG1heEZpbGVTaXplICYmIGZpbGUuc2l6ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoZmlsZS5zaXplID4gbWF4RmlsZVNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlc3RyaWN0aW9uRXJyb3IodGhpcy5pMThuKCdleGNlZWRzU2l6ZTInLCB7XG4gICAgICAgICAgYmFja3dhcmRzQ29tcGF0OiB0aGlzLmkxOG4oJ2V4Y2VlZHNTaXplJyksXG4gICAgICAgICAgc2l6ZTogcHJldHRpZXJCeXRlcyhtYXhGaWxlU2l6ZSksXG4gICAgICAgICAgZmlsZTogZmlsZS5uYW1lLFxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBjYW4ndCBjaGVjayBtaW5GaWxlU2l6ZSBpZiB0aGUgc2l6ZSBpcyB1bmtub3duLlxuICAgIGlmIChtaW5GaWxlU2l6ZSAmJiBmaWxlLnNpemUgIT0gbnVsbCkge1xuICAgICAgaWYgKGZpbGUuc2l6ZSA8IG1pbkZpbGVTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXN0cmljdGlvbkVycm9yKHRoaXMuaTE4bignaW5mZXJpb3JTaXplJywge1xuICAgICAgICAgIHNpemU6IHByZXR0aWVyQnl0ZXMobWluRmlsZVNpemUpLFxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgbWluTnVtYmVyT2ZGaWxlcyByZXN0cmljdGlvbiBpcyByZWFjaGVkIGJlZm9yZSB1cGxvYWRpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjaGVja01pbk51bWJlck9mRmlsZXMgKGZpbGVzKSB7XG4gICAgY29uc3QgeyBtaW5OdW1iZXJPZkZpbGVzIH0gPSB0aGlzLm9wdHMucmVzdHJpY3Rpb25zXG4gICAgaWYgKE9iamVjdC5rZXlzKGZpbGVzKS5sZW5ndGggPCBtaW5OdW1iZXJPZkZpbGVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmVzdHJpY3Rpb25FcnJvcihgJHt0aGlzLmkxOG4oJ3lvdUhhdmVUb0F0TGVhc3RTZWxlY3RYJywgeyBzbWFydF9jb3VudDogbWluTnVtYmVyT2ZGaWxlcyB9KX1gKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGFuIGVycm9yLCBzZXRzIEluZm9ybWVyIG1lc3NhZ2UsIHRoZW4gdGhyb3dzIHRoZSBlcnJvci5cbiAgICogRW1pdHMgYSAncmVzdHJpY3Rpb24tZmFpbGVkJyBldmVudCBpZiBpdOKAmXMgYSByZXN0cmljdGlvbiBlcnJvclxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdCB8IHN0cmluZ30gZXJyIOKAlCBFcnJvciBvYmplY3Qgb3IgcGxhaW4gc3RyaW5nIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNob3dJbmZvcm1lcj10cnVlXSDigJQgU29tZXRpbWVzIGRldmVsb3BlciBtaWdodCB3YW50IHRvIHNob3cgSW5mb3JtZXIgbWFudWFsbHlcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmZpbGU9bnVsbF0g4oCUIEZpbGUgb2JqZWN0IHVzZWQgdG8gZW1pdCB0aGUgcmVzdHJpY3Rpb24gZXJyb3JcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50aHJvd0Vycj10cnVlXSDigJQgRXJyb3JzIHNob3VsZG7igJl0IGJlIHRocm93biwgZm9yIGV4YW1wbGUsIGluIGB1cGxvYWQtZXJyb3JgIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzaG93T3JMb2dFcnJvckFuZFRocm93IChlcnIsIHsgc2hvd0luZm9ybWVyID0gdHJ1ZSwgZmlsZSA9IG51bGwsIHRocm93RXJyID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdHlwZW9mIGVyciA9PT0gJ29iamVjdCcgPyBlcnIubWVzc2FnZSA6IGVyclxuICAgIGNvbnN0IGRldGFpbHMgPSAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgZXJyLmRldGFpbHMpID8gZXJyLmRldGFpbHMgOiAnJ1xuXG4gICAgLy8gUmVzdHJpY3Rpb24gZXJyb3JzIHNob3VsZCBiZSBsb2dnZWQsIGJ1dCBub3QgYXMgZXJyb3JzLFxuICAgIC8vIGFzIHRoZXkgYXJlIGV4cGVjdGVkIGFuZCBzaG93biBpbiB0aGUgVUkuXG4gICAgbGV0IGxvZ01lc3NhZ2VXaXRoRGV0YWlscyA9IG1lc3NhZ2VcbiAgICBpZiAoZGV0YWlscykge1xuICAgICAgbG9nTWVzc2FnZVdpdGhEZXRhaWxzICs9IGAgJHtkZXRhaWxzfWBcbiAgICB9XG4gICAgaWYgKGVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICB0aGlzLmxvZyhsb2dNZXNzYWdlV2l0aERldGFpbHMpXG4gICAgICB0aGlzLmVtaXQoJ3Jlc3RyaWN0aW9uLWZhaWxlZCcsIGZpbGUsIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2cobG9nTWVzc2FnZVdpdGhEZXRhaWxzLCAnZXJyb3InKVxuICAgIH1cblxuICAgIC8vIFNvbWV0aW1lcyBpbmZvcm1lciBoYXMgdG8gYmUgc2hvd24gbWFudWFsbHkgYnkgdGhlIGRldmVsb3BlcixcbiAgICAvLyBmb3IgZXhhbXBsZSwgaW4gYG9uQmVmb3JlRmlsZUFkZGVkYC5cbiAgICBpZiAoc2hvd0luZm9ybWVyKSB7XG4gICAgICB0aGlzLmluZm8oeyBtZXNzYWdlLCBkZXRhaWxzIH0sICdlcnJvcicsIHRoaXMub3B0cy5pbmZvVGltZW91dClcbiAgICB9XG5cbiAgICBpZiAodGhyb3dFcnIpIHtcbiAgICAgIHRocm93ICh0eXBlb2YgZXJyID09PSAnb2JqZWN0JyA/IGVyciA6IG5ldyBFcnJvcihlcnIpKVxuICAgIH1cbiAgfVxuXG4gIGFzc2VydE5ld1VwbG9hZEFsbG93ZWQgKGZpbGUpIHtcbiAgICBjb25zdCB7IGFsbG93TmV3VXBsb2FkIH0gPSB0aGlzLmdldFN0YXRlKClcblxuICAgIGlmIChhbGxvd05ld1VwbG9hZCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhuZXcgUmVzdHJpY3Rpb25FcnJvcih0aGlzLmkxOG4oJ25vTmV3QWxyZWFkeVVwbG9hZGluZycpKSwgeyBmaWxlIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZpbGUgc3RhdGUgb2JqZWN0IGJhc2VkIG9uIHVzZXItcHJvdmlkZWQgYGFkZEZpbGUoKWAgb3B0aW9ucy5cbiAgICpcbiAgICogTm90ZSB0aGlzIGlzIGV4dHJlbWVseSBzaWRlLWVmZmVjdGZ1bCBhbmQgc2hvdWxkIG9ubHkgYmUgZG9uZSB3aGVuIGEgZmlsZSBzdGF0ZSBvYmplY3Qgd2lsbCBiZSBhZGRlZCB0byBzdGF0ZSBpbW1lZGlhdGVseSBhZnRlcndhcmQhXG4gICAqXG4gICAqIFRoZSBgZmlsZXNgIHZhbHVlIGlzIHBhc3NlZCBpbiBiZWNhdXNlIGl0IG1heSBiZSB1cGRhdGVkIGJ5IHRoZSBjYWxsZXIgd2l0aG91dCB1cGRhdGluZyB0aGUgc3RvcmUuXG4gICAqL1xuICBjaGVja0FuZENyZWF0ZUZpbGVTdGF0ZU9iamVjdCAoZmlsZXMsIGYpIHtcbiAgICBjb25zdCBmaWxlVHlwZSA9IGdldEZpbGVUeXBlKGYpXG4gICAgbGV0IGZpbGUgPSBmXG4gICAgZmlsZS50eXBlID0gZmlsZVR5cGVcblxuICAgIGNvbnN0IG9uQmVmb3JlRmlsZUFkZGVkUmVzdWx0ID0gdGhpcy5vcHRzLm9uQmVmb3JlRmlsZUFkZGVkKGZpbGUsIGZpbGVzKVxuXG4gICAgaWYgKG9uQmVmb3JlRmlsZUFkZGVkUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgLy8gRG9u4oCZdCBzaG93IFVJIGluZm8gZm9yIHRoaXMgZXJyb3IsIGFzIGl0IHNob3VsZCBiZSBkb25lIGJ5IHRoZSBkZXZlbG9wZXJcbiAgICAgIHRoaXMuc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhuZXcgUmVzdHJpY3Rpb25FcnJvcignQ2Fubm90IGFkZCB0aGUgZmlsZSBiZWNhdXNlIG9uQmVmb3JlRmlsZUFkZGVkIHJldHVybmVkIGZhbHNlLicpLCB7IHNob3dJbmZvcm1lcjogZmFsc2UsIGZpbGUgfSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9uQmVmb3JlRmlsZUFkZGVkUmVzdWx0ID09PSAnb2JqZWN0JyAmJiBvbkJlZm9yZUZpbGVBZGRlZFJlc3VsdCkge1xuICAgICAgZmlsZSA9IG9uQmVmb3JlRmlsZUFkZGVkUmVzdWx0XG4gICAgfVxuXG4gICAgbGV0IGZpbGVOYW1lXG4gICAgaWYgKGZpbGUubmFtZSkge1xuICAgICAgZmlsZU5hbWUgPSBmaWxlLm5hbWVcbiAgICB9IGVsc2UgaWYgKGZpbGVUeXBlLnNwbGl0KCcvJylbMF0gPT09ICdpbWFnZScpIHtcbiAgICAgIGZpbGVOYW1lID0gYCR7ZmlsZVR5cGUuc3BsaXQoJy8nKVswXX0uJHtmaWxlVHlwZS5zcGxpdCgnLycpWzFdfWBcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsZU5hbWUgPSAnbm9uYW1lJ1xuICAgIH1cbiAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24oZmlsZU5hbWUpLmV4dGVuc2lvblxuICAgIGNvbnN0IGlzUmVtb3RlID0gZmlsZS5pc1JlbW90ZSB8fCBmYWxzZVxuXG4gICAgY29uc3QgZmlsZUlEID0gZ2VuZXJhdGVGaWxlSUQoZmlsZSlcblxuICAgIGlmIChmaWxlc1tmaWxlSURdICYmICFmaWxlc1tmaWxlSURdLmlzR2hvc3QpIHtcbiAgICAgIHRoaXMuc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhuZXcgUmVzdHJpY3Rpb25FcnJvcih0aGlzLmkxOG4oJ25vRHVwbGljYXRlcycsIHsgZmlsZU5hbWUgfSkpLCB7IGZpbGUgfSlcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhID0gZmlsZS5tZXRhIHx8IHt9XG4gICAgbWV0YS5uYW1lID0gZmlsZU5hbWVcbiAgICBtZXRhLnR5cGUgPSBmaWxlVHlwZVxuXG4gICAgLy8gYG51bGxgIG1lYW5zIHRoZSBzaXplIGlzIHVua25vd24uXG4gICAgY29uc3Qgc2l6ZSA9IE51bWJlci5pc0Zpbml0ZShmaWxlLmRhdGEuc2l6ZSkgPyBmaWxlLmRhdGEuc2l6ZSA6IG51bGxcbiAgICBjb25zdCBuZXdGaWxlID0ge1xuICAgICAgc291cmNlOiBmaWxlLnNvdXJjZSB8fCAnJyxcbiAgICAgIGlkOiBmaWxlSUQsXG4gICAgICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgIGV4dGVuc2lvbjogZmlsZUV4dGVuc2lvbiB8fCAnJyxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4udGhpcy5nZXRTdGF0ZSgpLm1ldGEsXG4gICAgICAgIC4uLm1ldGEsXG4gICAgICB9LFxuICAgICAgdHlwZTogZmlsZVR5cGUsXG4gICAgICBkYXRhOiBmaWxlLmRhdGEsXG4gICAgICBwcm9ncmVzczoge1xuICAgICAgICBwZXJjZW50YWdlOiAwLFxuICAgICAgICBieXRlc1VwbG9hZGVkOiAwLFxuICAgICAgICBieXRlc1RvdGFsOiBzaXplLFxuICAgICAgICB1cGxvYWRDb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIHVwbG9hZFN0YXJ0ZWQ6IG51bGwsXG4gICAgICB9LFxuICAgICAgc2l6ZSxcbiAgICAgIGlzUmVtb3RlLFxuICAgICAgcmVtb3RlOiBmaWxlLnJlbW90ZSB8fCAnJyxcbiAgICAgIHByZXZpZXc6IGZpbGUucHJldmlldyxcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZmlsZXNBcnJheSA9IE9iamVjdC5rZXlzKGZpbGVzKS5tYXAoaSA9PiBmaWxlc1tpXSlcbiAgICAgIHRoaXMuY2hlY2tSZXN0cmljdGlvbnMobmV3RmlsZSwgZmlsZXNBcnJheSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhlcnIsIHsgZmlsZTogbmV3RmlsZSB9KVxuICAgIH1cblxuICAgIHJldHVybiBuZXdGaWxlXG4gIH1cblxuICAvLyBTY2hlZHVsZSBhbiB1cGxvYWQgaWYgYGF1dG9Qcm9jZWVkYCBpcyBlbmFibGVkLlxuICBzdGFydElmQXV0b1Byb2NlZWQgKCkge1xuICAgIGlmICh0aGlzLm9wdHMuYXV0b1Byb2NlZWQgJiYgIXRoaXMuc2NoZWR1bGVkQXV0b1Byb2NlZWQpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVkQXV0b1Byb2NlZWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWRBdXRvUHJvY2VlZCA9IG51bGxcbiAgICAgICAgdGhpcy51cGxvYWQoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICAgICAgdGhpcy5sb2coZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlIHx8IGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9LCA0KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgZmlsZSB0byBgc3RhdGUuZmlsZXNgLiBUaGlzIHdpbGwgcnVuIGBvbkJlZm9yZUZpbGVBZGRlZGAsXG4gICAqIHRyeSB0byBndWVzcyBmaWxlIHR5cGUgaW4gYSBjbGV2ZXIgd2F5LCBjaGVjayBmaWxlIGFnYWluc3QgcmVzdHJpY3Rpb25zLFxuICAgKiBhbmQgc3RhcnQgYW4gdXBsb2FkIGlmIGBhdXRvUHJvY2VlZCA9PT0gdHJ1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlIG9iamVjdCB0byBhZGRcbiAgICogQHJldHVybnMge3N0cmluZ30gaWQgZm9yIHRoZSBhZGRlZCBmaWxlXG4gICAqL1xuICBhZGRGaWxlIChmaWxlKSB7XG4gICAgdGhpcy5hc3NlcnROZXdVcGxvYWRBbGxvd2VkKGZpbGUpXG5cbiAgICBjb25zdCB7IGZpbGVzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICBsZXQgbmV3RmlsZSA9IHRoaXMuY2hlY2tBbmRDcmVhdGVGaWxlU3RhdGVPYmplY3QoZmlsZXMsIGZpbGUpXG5cbiAgICAvLyBVc2VycyBhcmUgYXNrZWQgdG8gcmUtc2VsZWN0IHJlY292ZXJlZCBmaWxlcyB3aXRob3V0IGRhdGEsXG4gICAgLy8gYW5kIHRvIGtlZXAgdGhlIHByb2dyZXNzLCBtZXRhIGFuZCBldmVydGhpbmcgZWxzZSwgd2Ugb25seSByZXBsYWNlIHNhaWQgZGF0YVxuICAgIGlmIChmaWxlc1tuZXdGaWxlLmlkXSAmJiBmaWxlc1tuZXdGaWxlLmlkXS5pc0dob3N0KSB7XG4gICAgICBuZXdGaWxlID0ge1xuICAgICAgICAuLi5maWxlc1tuZXdGaWxlLmlkXSxcbiAgICAgICAgZGF0YTogZmlsZS5kYXRhLFxuICAgICAgICBpc0dob3N0OiBmYWxzZSxcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKGBSZXBsYWNlZCB0aGUgYmxvYiBpbiB0aGUgcmVzdG9yZWQgZ2hvc3QgZmlsZTogJHtuZXdGaWxlLm5hbWV9LCAke25ld0ZpbGUuaWR9YClcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZpbGVzOiB7XG4gICAgICAgIC4uLmZpbGVzLFxuICAgICAgICBbbmV3RmlsZS5pZF06IG5ld0ZpbGUsXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICB0aGlzLmVtaXQoJ2ZpbGUtYWRkZWQnLCBuZXdGaWxlKVxuICAgIHRoaXMuZW1pdCgnZmlsZXMtYWRkZWQnLCBbbmV3RmlsZV0pXG4gICAgdGhpcy5sb2coYEFkZGVkIGZpbGU6ICR7bmV3RmlsZS5uYW1lfSwgJHtuZXdGaWxlLmlkfSwgbWltZSB0eXBlOiAke25ld0ZpbGUudHlwZX1gKVxuXG4gICAgdGhpcy5zdGFydElmQXV0b1Byb2NlZWQoKVxuXG4gICAgcmV0dXJuIG5ld0ZpbGUuaWRcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbXVsdGlwbGUgZmlsZXMgdG8gYHN0YXRlLmZpbGVzYC4gU2VlIHRoZSBgYWRkRmlsZSgpYCBkb2N1bWVudGF0aW9uLlxuICAgKlxuICAgKiBJZiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgYWRkaW5nIGEgZmlsZSwgaXQgaXMgbG9nZ2VkIGFuZCB0aGUgdXNlciBpcyBub3RpZmllZC5cbiAgICogVGhpcyBpcyBnb29kIGZvciBVSSBwbHVnaW5zLCBidXQgbm90IGZvciBwcm9ncmFtbWF0aWMgdXNlLlxuICAgKiBQcm9ncmFtbWF0aWMgdXNlcnMgc2hvdWxkIHVzdWFsbHkgc3RpbGwgdXNlIGBhZGRGaWxlKClgIG9uIGluZGl2aWR1YWwgZmlsZXMuXG4gICAqL1xuICBhZGRGaWxlcyAoZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgdGhpcy5hc3NlcnROZXdVcGxvYWRBbGxvd2VkKClcblxuICAgIC8vIGNyZWF0ZSBhIGNvcHkgb2YgdGhlIGZpbGVzIG9iamVjdCBvbmx5IG9uY2VcbiAgICBjb25zdCBmaWxlcyA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzIH1cbiAgICBjb25zdCBuZXdGaWxlcyA9IFtdXG4gICAgY29uc3QgZXJyb3JzID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVEZXNjcmlwdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IG5ld0ZpbGUgPSB0aGlzLmNoZWNrQW5kQ3JlYXRlRmlsZVN0YXRlT2JqZWN0KGZpbGVzLCBmaWxlRGVzY3JpcHRvcnNbaV0pXG4gICAgICAgIC8vIFVzZXJzIGFyZSBhc2tlZCB0byByZS1zZWxlY3QgcmVjb3ZlcmVkIGZpbGVzIHdpdGhvdXQgZGF0YSxcbiAgICAgICAgLy8gYW5kIHRvIGtlZXAgdGhlIHByb2dyZXNzLCBtZXRhIGFuZCBldmVydGhpbmcgZWxzZSwgd2Ugb25seSByZXBsYWNlIHNhaWQgZGF0YVxuICAgICAgICBpZiAoZmlsZXNbbmV3RmlsZS5pZF0gJiYgZmlsZXNbbmV3RmlsZS5pZF0uaXNHaG9zdCkge1xuICAgICAgICAgIG5ld0ZpbGUgPSB7XG4gICAgICAgICAgICAuLi5maWxlc1tuZXdGaWxlLmlkXSxcbiAgICAgICAgICAgIGRhdGE6IGZpbGVEZXNjcmlwdG9yc1tpXS5kYXRhLFxuICAgICAgICAgICAgaXNHaG9zdDogZmFsc2UsXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubG9nKGBSZXBsYWNlZCBibG9iIGluIGEgZ2hvc3QgZmlsZTogJHtuZXdGaWxlLm5hbWV9LCAke25ld0ZpbGUuaWR9YClcbiAgICAgICAgfVxuICAgICAgICBmaWxlc1tuZXdGaWxlLmlkXSA9IG5ld0ZpbGVcbiAgICAgICAgbmV3RmlsZXMucHVzaChuZXdGaWxlKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghZXJyLmlzUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgZmlsZXMgfSlcblxuICAgIG5ld0ZpbGVzLmZvckVhY2goKG5ld0ZpbGUpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnZmlsZS1hZGRlZCcsIG5ld0ZpbGUpXG4gICAgfSlcblxuICAgIHRoaXMuZW1pdCgnZmlsZXMtYWRkZWQnLCBuZXdGaWxlcylcblxuICAgIGlmIChuZXdGaWxlcy5sZW5ndGggPiA1KSB7XG4gICAgICB0aGlzLmxvZyhgQWRkZWQgYmF0Y2ggb2YgJHtuZXdGaWxlcy5sZW5ndGh9IGZpbGVzYClcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmtleXMobmV3RmlsZXMpLmZvckVhY2goZmlsZUlEID0+IHtcbiAgICAgICAgdGhpcy5sb2coYEFkZGVkIGZpbGU6ICR7bmV3RmlsZXNbZmlsZUlEXS5uYW1lfVxcbiBpZDogJHtuZXdGaWxlc1tmaWxlSURdLmlkfVxcbiB0eXBlOiAke25ld0ZpbGVzW2ZpbGVJRF0udHlwZX1gKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAobmV3RmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zdGFydElmQXV0b1Byb2NlZWQoKVxuICAgIH1cblxuICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IG1lc3NhZ2UgPSAnTXVsdGlwbGUgZXJyb3JzIG9jY3VycmVkIHdoaWxlIGFkZGluZyBmaWxlczpcXG4nXG4gICAgICBlcnJvcnMuZm9yRWFjaCgoc3ViRXJyb3IpID0+IHtcbiAgICAgICAgbWVzc2FnZSArPSBgXFxuICogJHtzdWJFcnJvci5tZXNzYWdlfWBcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuaW5mbyh7XG4gICAgICAgIG1lc3NhZ2U6IHRoaXMuaTE4bignYWRkQnVsa0ZpbGVzRmFpbGVkJywgeyBzbWFydF9jb3VudDogZXJyb3JzLmxlbmd0aCB9KSxcbiAgICAgICAgZGV0YWlsczogbWVzc2FnZSxcbiAgICAgIH0sICdlcnJvcicsIHRoaXMub3B0cy5pbmZvVGltZW91dClcblxuICAgICAgaWYgKHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3IoZXJyb3JzLCBtZXNzYWdlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgICAgIGVyci5lcnJvcnMgPSBlcnJvcnNcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlRmlsZXMgKGZpbGVJRHMsIHJlYXNvbikge1xuICAgIGNvbnN0IHsgZmlsZXMsIGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSB7IC4uLmZpbGVzIH1cbiAgICBjb25zdCB1cGRhdGVkVXBsb2FkcyA9IHsgLi4uY3VycmVudFVwbG9hZHMgfVxuXG4gICAgY29uc3QgcmVtb3ZlZEZpbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIGZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICBpZiAoZmlsZXNbZmlsZUlEXSkge1xuICAgICAgICByZW1vdmVkRmlsZXNbZmlsZUlEXSA9IGZpbGVzW2ZpbGVJRF1cbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRGaWxlc1tmaWxlSURdXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFJlbW92ZSBmaWxlcyBmcm9tIHRoZSBgZmlsZUlEc2AgbGlzdCBpbiBlYWNoIHVwbG9hZC5cbiAgICBmdW5jdGlvbiBmaWxlSXNOb3RSZW1vdmVkICh1cGxvYWRGaWxlSUQpIHtcbiAgICAgIHJldHVybiByZW1vdmVkRmlsZXNbdXBsb2FkRmlsZUlEXSA9PT0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXModXBkYXRlZFVwbG9hZHMpLmZvckVhY2goKHVwbG9hZElEKSA9PiB7XG4gICAgICBjb25zdCBuZXdGaWxlSURzID0gY3VycmVudFVwbG9hZHNbdXBsb2FkSURdLmZpbGVJRHMuZmlsdGVyKGZpbGVJc05vdFJlbW92ZWQpXG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgdXBsb2FkIGlmIG5vIGZpbGVzIGFyZSBhc3NvY2lhdGVkIHdpdGggaXQgYW55bW9yZS5cbiAgICAgIGlmIChuZXdGaWxlSURzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdXBkYXRlZFVwbG9hZHNbdXBsb2FkSURdXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB1cGRhdGVkVXBsb2Fkc1t1cGxvYWRJRF0gPSB7XG4gICAgICAgIC4uLmN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXSxcbiAgICAgICAgZmlsZUlEczogbmV3RmlsZUlEcyxcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3Qgc3RhdGVVcGRhdGUgPSB7XG4gICAgICBjdXJyZW50VXBsb2FkczogdXBkYXRlZFVwbG9hZHMsXG4gICAgICBmaWxlczogdXBkYXRlZEZpbGVzLFxuICAgIH1cblxuICAgIC8vIElmIGFsbCBmaWxlcyB3ZXJlIHJlbW92ZWQgLSBhbGxvdyBuZXcgdXBsb2FkcyxcbiAgICAvLyBhbmQgY2xlYXIgcmVjb3ZlcmVkU3RhdGVcbiAgICBpZiAoT2JqZWN0LmtleXModXBkYXRlZEZpbGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHN0YXRlVXBkYXRlLmFsbG93TmV3VXBsb2FkID0gdHJ1ZVxuICAgICAgc3RhdGVVcGRhdGUuZXJyb3IgPSBudWxsXG4gICAgICBzdGF0ZVVwZGF0ZS5yZWNvdmVyZWRTdGF0ZSA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHN0YXRlVXBkYXRlKVxuICAgIHRoaXMuY2FsY3VsYXRlVG90YWxQcm9ncmVzcygpXG5cbiAgICBjb25zdCByZW1vdmVkRmlsZUlEcyA9IE9iamVjdC5rZXlzKHJlbW92ZWRGaWxlcylcbiAgICByZW1vdmVkRmlsZUlEcy5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnZmlsZS1yZW1vdmVkJywgcmVtb3ZlZEZpbGVzW2ZpbGVJRF0sIHJlYXNvbilcbiAgICB9KVxuXG4gICAgaWYgKHJlbW92ZWRGaWxlSURzLmxlbmd0aCA+IDUpIHtcbiAgICAgIHRoaXMubG9nKGBSZW1vdmVkICR7cmVtb3ZlZEZpbGVJRHMubGVuZ3RofSBmaWxlc2ApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKGBSZW1vdmVkIGZpbGVzOiAke3JlbW92ZWRGaWxlSURzLmpvaW4oJywgJyl9YClcbiAgICB9XG4gIH1cblxuICByZW1vdmVGaWxlIChmaWxlSUQsIHJlYXNvbiA9IG51bGwpIHtcbiAgICB0aGlzLnJlbW92ZUZpbGVzKFtmaWxlSURdLCByZWFzb24pXG4gIH1cblxuICBwYXVzZVJlc3VtZSAoZmlsZUlEKSB7XG4gICAgaWYgKCF0aGlzLmdldFN0YXRlKCkuY2FwYWJpbGl0aWVzLnJlc3VtYWJsZVVwbG9hZHNcbiAgICAgICAgIHx8IHRoaXMuZ2V0RmlsZShmaWxlSUQpLnVwbG9hZENvbXBsZXRlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgY29uc3Qgd2FzUGF1c2VkID0gdGhpcy5nZXRGaWxlKGZpbGVJRCkuaXNQYXVzZWQgfHwgZmFsc2VcbiAgICBjb25zdCBpc1BhdXNlZCA9ICF3YXNQYXVzZWRcblxuICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGVJRCwge1xuICAgICAgaXNQYXVzZWQsXG4gICAgfSlcblxuICAgIHRoaXMuZW1pdCgndXBsb2FkLXBhdXNlJywgZmlsZUlELCBpc1BhdXNlZClcblxuICAgIHJldHVybiBpc1BhdXNlZFxuICB9XG5cbiAgcGF1c2VBbGwgKCkge1xuICAgIGNvbnN0IHVwZGF0ZWRGaWxlcyA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmZpbGVzIH1cbiAgICBjb25zdCBpblByb2dyZXNzVXBkYXRlZEZpbGVzID0gT2JqZWN0LmtleXModXBkYXRlZEZpbGVzKS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiAhdXBkYXRlZEZpbGVzW2ZpbGVdLnByb2dyZXNzLnVwbG9hZENvbXBsZXRlXG4gICAgICAgICAgICAgJiYgdXBkYXRlZEZpbGVzW2ZpbGVdLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgICB9KVxuXG4gICAgaW5Qcm9ncmVzc1VwZGF0ZWRGaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkRmlsZSA9IHsgLi4udXBkYXRlZEZpbGVzW2ZpbGVdLCBpc1BhdXNlZDogdHJ1ZSB9XG4gICAgICB1cGRhdGVkRmlsZXNbZmlsZV0gPSB1cGRhdGVkRmlsZVxuICAgIH0pXG5cbiAgICB0aGlzLnNldFN0YXRlKHsgZmlsZXM6IHVwZGF0ZWRGaWxlcyB9KVxuICAgIHRoaXMuZW1pdCgncGF1c2UtYWxsJylcbiAgfVxuXG4gIHJlc3VtZUFsbCAoKSB7XG4gICAgY29uc3QgdXBkYXRlZEZpbGVzID0geyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMgfVxuICAgIGNvbnN0IGluUHJvZ3Jlc3NVcGRhdGVkRmlsZXMgPSBPYmplY3Qua2V5cyh1cGRhdGVkRmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuICF1cGRhdGVkRmlsZXNbZmlsZV0ucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGVcbiAgICAgICAgICAgICAmJiB1cGRhdGVkRmlsZXNbZmlsZV0ucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZFxuICAgIH0pXG5cbiAgICBpblByb2dyZXNzVXBkYXRlZEZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRGaWxlID0ge1xuICAgICAgICAuLi51cGRhdGVkRmlsZXNbZmlsZV0sXG4gICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9XG4gICAgICB1cGRhdGVkRmlsZXNbZmlsZV0gPSB1cGRhdGVkRmlsZVxuICAgIH0pXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVzOiB1cGRhdGVkRmlsZXMgfSlcblxuICAgIHRoaXMuZW1pdCgncmVzdW1lLWFsbCcpXG4gIH1cblxuICByZXRyeUFsbCAoKSB7XG4gICAgY29uc3QgdXBkYXRlZEZpbGVzID0geyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMgfVxuICAgIGNvbnN0IGZpbGVzVG9SZXRyeSA9IE9iamVjdC5rZXlzKHVwZGF0ZWRGaWxlcykuZmlsdGVyKGZpbGUgPT4ge1xuICAgICAgcmV0dXJuIHVwZGF0ZWRGaWxlc1tmaWxlXS5lcnJvclxuICAgIH0pXG5cbiAgICBmaWxlc1RvUmV0cnkuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEZpbGUgPSB7XG4gICAgICAgIC4uLnVwZGF0ZWRGaWxlc1tmaWxlXSxcbiAgICAgICAgaXNQYXVzZWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH1cbiAgICAgIHVwZGF0ZWRGaWxlc1tmaWxlXSA9IHVwZGF0ZWRGaWxlXG4gICAgfSlcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZpbGVzOiB1cGRhdGVkRmlsZXMsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICB9KVxuXG4gICAgdGhpcy5lbWl0KCdyZXRyeS1hbGwnLCBmaWxlc1RvUmV0cnkpXG5cbiAgICBpZiAoZmlsZXNUb1JldHJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHN1Y2Nlc3NmdWw6IFtdLFxuICAgICAgICBmYWlsZWQ6IFtdLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCB1cGxvYWRJRCA9IHRoaXMuY3JlYXRlVXBsb2FkKGZpbGVzVG9SZXRyeSwge1xuICAgICAgZm9yY2VBbGxvd05ld1VwbG9hZDogdHJ1ZSwgLy8gY3JlYXRlIG5ldyB1cGxvYWQgZXZlbiBpZiBhbGxvd05ld1VwbG9hZDogZmFsc2VcbiAgICB9KVxuICAgIHJldHVybiB0aGlzLnJ1blVwbG9hZCh1cGxvYWRJRClcbiAgfVxuXG4gIGNhbmNlbEFsbCAoKSB7XG4gICAgdGhpcy5lbWl0KCdjYW5jZWwtYWxsJylcblxuICAgIGNvbnN0IHsgZmlsZXMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuXG4gICAgY29uc3QgZmlsZUlEcyA9IE9iamVjdC5rZXlzKGZpbGVzKVxuICAgIGlmIChmaWxlSURzLmxlbmd0aCkge1xuICAgICAgdGhpcy5yZW1vdmVGaWxlcyhmaWxlSURzLCAnY2FuY2VsLWFsbCcpXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB0b3RhbFByb2dyZXNzOiAwLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICByZWNvdmVyZWRTdGF0ZTogbnVsbCxcbiAgICB9KVxuICB9XG5cbiAgcmV0cnlVcGxvYWQgKGZpbGVJRCkge1xuICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGVJRCwge1xuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBpc1BhdXNlZDogZmFsc2UsXG4gICAgfSlcblxuICAgIHRoaXMuZW1pdCgndXBsb2FkLXJldHJ5JywgZmlsZUlEKVxuXG4gICAgY29uc3QgdXBsb2FkSUQgPSB0aGlzLmNyZWF0ZVVwbG9hZChbZmlsZUlEXSwge1xuICAgICAgZm9yY2VBbGxvd05ld1VwbG9hZDogdHJ1ZSwgLy8gY3JlYXRlIG5ldyB1cGxvYWQgZXZlbiBpZiBhbGxvd05ld1VwbG9hZDogZmFsc2VcbiAgICB9KVxuICAgIHJldHVybiB0aGlzLnJ1blVwbG9hZCh1cGxvYWRJRClcbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICB0aGlzLmNhbmNlbEFsbCgpXG4gIH1cblxuICBsb2dvdXQgKCkge1xuICAgIHRoaXMuaXRlcmF0ZVBsdWdpbnMocGx1Z2luID0+IHtcbiAgICAgIGlmIChwbHVnaW4ucHJvdmlkZXIgJiYgcGx1Z2luLnByb3ZpZGVyLmxvZ291dCkge1xuICAgICAgICBwbHVnaW4ucHJvdmlkZXIubG9nb3V0KClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY2FsY3VsYXRlUHJvZ3Jlc3MgKGZpbGUsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgdGhpcy5sb2coYE5vdCBzZXR0aW5nIHByb2dyZXNzIGZvciBhIGZpbGUgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAke2ZpbGUuaWR9YClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGJ5dGVzVG90YWwgbWF5IGJlIG51bGwgb3IgemVybzsgaW4gdGhhdCBjYXNlIHdlIGNhbid0IGRpdmlkZSBieSBpdFxuICAgIGNvbnN0IGNhbkhhdmVQZXJjZW50YWdlID0gTnVtYmVyLmlzRmluaXRlKGRhdGEuYnl0ZXNUb3RhbCkgJiYgZGF0YS5ieXRlc1RvdGFsID4gMFxuICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgIC4uLnRoaXMuZ2V0RmlsZShmaWxlLmlkKS5wcm9ncmVzcyxcbiAgICAgICAgYnl0ZXNVcGxvYWRlZDogZGF0YS5ieXRlc1VwbG9hZGVkLFxuICAgICAgICBieXRlc1RvdGFsOiBkYXRhLmJ5dGVzVG90YWwsXG4gICAgICAgIHBlcmNlbnRhZ2U6IGNhbkhhdmVQZXJjZW50YWdlXG4gICAgICAgICAgLy8gVE9ETyhnb3RvLWJ1cy1zdG9wKSBmbG9vcmluZyB0aGlzIHNob3VsZCBwcm9iYWJseSBiZSB0aGUgY2hvaWNlIG9mIHRoZSBVST9cbiAgICAgICAgICAvLyB3ZSBnZXQgbW9yZSBhY2N1cmF0ZSBjYWxjdWxhdGlvbnMgaWYgd2UgZG9uJ3Qgcm91bmQgdGhpcyBhdCBhbGwuXG4gICAgICAgICAgPyBNYXRoLnJvdW5kKChkYXRhLmJ5dGVzVXBsb2FkZWQgLyBkYXRhLmJ5dGVzVG90YWwpICogMTAwKVxuICAgICAgICAgIDogMCxcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIHRoaXMuY2FsY3VsYXRlVG90YWxQcm9ncmVzcygpXG4gIH1cblxuICBjYWxjdWxhdGVUb3RhbFByb2dyZXNzICgpIHtcbiAgICAvLyBjYWxjdWxhdGUgdG90YWwgcHJvZ3Jlc3MsIHVzaW5nIHRoZSBudW1iZXIgb2YgZmlsZXMgY3VycmVudGx5IHVwbG9hZGluZyxcbiAgICAvLyBtdWx0aXBsaWVkIGJ5IDEwMCBhbmQgdGhlIHN1bW0gb2YgaW5kaXZpZHVhbCBwcm9ncmVzcyBvZiBlYWNoIGZpbGVcbiAgICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0RmlsZXMoKVxuXG4gICAgY29uc3QgaW5Qcm9ncmVzcyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZFxuICAgICAgICB8fCBmaWxlLnByb2dyZXNzLnByZXByb2Nlc3NcbiAgICAgICAgfHwgZmlsZS5wcm9ncmVzcy5wb3N0cHJvY2Vzc1xuICAgIH0pXG5cbiAgICBpZiAoaW5Qcm9ncmVzcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCAwKVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRvdGFsUHJvZ3Jlc3M6IDAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHNpemVkRmlsZXMgPSBpblByb2dyZXNzLmZpbHRlcigoZmlsZSkgPT4gZmlsZS5wcm9ncmVzcy5ieXRlc1RvdGFsICE9IG51bGwpXG4gICAgY29uc3QgdW5zaXplZEZpbGVzID0gaW5Qcm9ncmVzcy5maWx0ZXIoKGZpbGUpID0+IGZpbGUucHJvZ3Jlc3MuYnl0ZXNUb3RhbCA9PSBudWxsKVxuXG4gICAgaWYgKHNpemVkRmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBwcm9ncmVzc01heCA9IGluUHJvZ3Jlc3MubGVuZ3RoICogMTAwXG4gICAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSB1bnNpemVkRmlsZXMucmVkdWNlKChhY2MsIGZpbGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGFjYyArIGZpbGUucHJvZ3Jlc3MucGVyY2VudGFnZVxuICAgICAgfSwgMClcbiAgICAgIGNvbnN0IHRvdGFsUHJvZ3Jlc3MgPSBNYXRoLnJvdW5kKChjdXJyZW50UHJvZ3Jlc3MgLyBwcm9ncmVzc01heCkgKiAxMDApXG4gICAgICB0aGlzLnNldFN0YXRlKHsgdG90YWxQcm9ncmVzcyB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHRvdGFsU2l6ZSA9IHNpemVkRmlsZXMucmVkdWNlKChhY2MsIGZpbGUpID0+IHtcbiAgICAgIHJldHVybiBhY2MgKyBmaWxlLnByb2dyZXNzLmJ5dGVzVG90YWxcbiAgICB9LCAwKVxuICAgIGNvbnN0IGF2ZXJhZ2VTaXplID0gdG90YWxTaXplIC8gc2l6ZWRGaWxlcy5sZW5ndGhcbiAgICB0b3RhbFNpemUgKz0gYXZlcmFnZVNpemUgKiB1bnNpemVkRmlsZXMubGVuZ3RoXG5cbiAgICBsZXQgdXBsb2FkZWRTaXplID0gMFxuICAgIHNpemVkRmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgdXBsb2FkZWRTaXplICs9IGZpbGUucHJvZ3Jlc3MuYnl0ZXNVcGxvYWRlZFxuICAgIH0pXG4gICAgdW5zaXplZEZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIHVwbG9hZGVkU2l6ZSArPSAoYXZlcmFnZVNpemUgKiAoZmlsZS5wcm9ncmVzcy5wZXJjZW50YWdlIHx8IDApKSAvIDEwMFxuICAgIH0pXG5cbiAgICBsZXQgdG90YWxQcm9ncmVzcyA9IHRvdGFsU2l6ZSA9PT0gMFxuICAgICAgPyAwXG4gICAgICA6IE1hdGgucm91bmQoKHVwbG9hZGVkU2l6ZSAvIHRvdGFsU2l6ZSkgKiAxMDApXG5cbiAgICAvLyBob3QgZml4LCBiZWNhdXNlOlxuICAgIC8vIHVwbG9hZGVkU2l6ZSBlbmRlZCB1cCBsYXJnZXIgdGhhbiB0b3RhbFNpemUsIHJlc3VsdGluZyBpbiAxMzI1JSB0b3RhbFxuICAgIGlmICh0b3RhbFByb2dyZXNzID4gMTAwKSB7XG4gICAgICB0b3RhbFByb2dyZXNzID0gMTAwXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IHRvdGFsUHJvZ3Jlc3MgfSlcbiAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgdG90YWxQcm9ncmVzcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgbGlzdGVuZXJzIGZvciBhbGwgZ2xvYmFsIGFjdGlvbnMsIGxpa2U6XG4gICAqIGBlcnJvcmAsIGBmaWxlLXJlbW92ZWRgLCBgdXBsb2FkLXByb2dyZXNzYFxuICAgKi9cbiAgYWRkTGlzdGVuZXJzICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZmlsZV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3Jlc3BvbnNlXVxuICAgICAqL1xuICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IChlcnJvciwgZmlsZSwgcmVzcG9uc2UpID0+IHtcbiAgICAgIGxldCBlcnJvck1zZyA9IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InXG4gICAgICBpZiAoZXJyb3IuZGV0YWlscykge1xuICAgICAgICBlcnJvck1zZyArPSBgICR7ZXJyb3IuZGV0YWlsc31gXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogZXJyb3JNc2cgfSlcblxuICAgICAgLy8gV2hlbiBhIGZpbGUgaXMgYWxzbyBnaXZlbiwgd2Ugc3RvcmUgdGhlIGVycm9yIG9uIHRoZSBmaWxlIG9iamVjdC5cbiAgICAgIGlmIChmaWxlICE9IG51bGwgJiYgdHlwZW9mIGZpbGUuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgICAgICBlcnJvcjogZXJyb3JNc2csXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vbignZXJyb3InLCBlcnJvckhhbmRsZXIpXG5cbiAgICB0aGlzLm9uKCd1cGxvYWQtZXJyb3InLCAoZmlsZSwgZXJyb3IsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBlcnJvckhhbmRsZXIoZXJyb3IsIGZpbGUsIHJlc3BvbnNlKVxuXG4gICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG5ld0Vycm9yID0gbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpXG4gICAgICAgIG5ld0Vycm9yLmRldGFpbHMgPSBlcnJvci5tZXNzYWdlXG4gICAgICAgIGlmIChlcnJvci5kZXRhaWxzKSB7XG4gICAgICAgICAgbmV3RXJyb3IuZGV0YWlscyArPSBgICR7ZXJyb3IuZGV0YWlsc31gXG4gICAgICAgIH1cbiAgICAgICAgbmV3RXJyb3IubWVzc2FnZSA9IHRoaXMuaTE4bignZmFpbGVkVG9VcGxvYWQnLCB7IGZpbGU6IGZpbGUubmFtZSB9KVxuICAgICAgICB0aGlzLnNob3dPckxvZ0Vycm9yQW5kVGhyb3cobmV3RXJyb3IsIHtcbiAgICAgICAgICB0aHJvd0VycjogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dPckxvZ0Vycm9yQW5kVGhyb3coZXJyb3IsIHtcbiAgICAgICAgICB0aHJvd0VycjogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMub24oJ3VwbG9hZCcsICgpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogbnVsbCB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCd1cGxvYWQtc3RhcnRlZCcsIChmaWxlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcHJvZ3Jlc3MgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7ZmlsZS5pZH1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICB1cGxvYWRTdGFydGVkOiBEYXRlLm5vdygpLFxuICAgICAgICAgIHVwbG9hZENvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgICBwZXJjZW50YWdlOiAwLFxuICAgICAgICAgIGJ5dGVzVXBsb2FkZWQ6IDAsXG4gICAgICAgICAgYnl0ZXNUb3RhbDogZmlsZS5zaXplLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5vbigndXBsb2FkLXByb2dyZXNzJywgdGhpcy5jYWxjdWxhdGVQcm9ncmVzcylcblxuICAgIHRoaXMub24oJ3VwbG9hZC1zdWNjZXNzJywgKGZpbGUsIHVwbG9hZFJlc3ApID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRGaWxlKGZpbGUuaWQpKSB7XG4gICAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyBwcm9ncmVzcyBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHtmaWxlLmlkfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSB0aGlzLmdldEZpbGUoZmlsZS5pZCkucHJvZ3Jlc3NcbiAgICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICAuLi5jdXJyZW50UHJvZ3Jlc3MsXG4gICAgICAgICAgcG9zdHByb2Nlc3M6IHRoaXMucG9zdFByb2Nlc3NvcnMubGVuZ3RoID4gMCA/IHtcbiAgICAgICAgICAgIG1vZGU6ICdpbmRldGVybWluYXRlJyxcbiAgICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgICB1cGxvYWRDb21wbGV0ZTogdHJ1ZSxcbiAgICAgICAgICBwZXJjZW50YWdlOiAxMDAsXG4gICAgICAgICAgYnl0ZXNVcGxvYWRlZDogY3VycmVudFByb2dyZXNzLmJ5dGVzVG90YWwsXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3BvbnNlOiB1cGxvYWRSZXNwLFxuICAgICAgICB1cGxvYWRVUkw6IHVwbG9hZFJlc3AudXBsb2FkVVJMLFxuICAgICAgICBpc1BhdXNlZDogZmFsc2UsXG4gICAgICB9KVxuXG4gICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsUHJvZ3Jlc3MoKVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCdwcmVwcm9jZXNzLXByb2dyZXNzJywgKGZpbGUsIHByb2dyZXNzKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcHJvZ3Jlc3MgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7ZmlsZS5pZH1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgICAgcHJvZ3Jlc3M6IHsgLi4udGhpcy5nZXRGaWxlKGZpbGUuaWQpLnByb2dyZXNzLCBwcmVwcm9jZXNzOiBwcm9ncmVzcyB9LFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5vbigncHJlcHJvY2Vzcy1jb21wbGV0ZScsIChmaWxlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcHJvZ3Jlc3MgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7ZmlsZS5pZH1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVzID0geyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMgfVxuICAgICAgZmlsZXNbZmlsZS5pZF0gPSB7IC4uLmZpbGVzW2ZpbGUuaWRdLCBwcm9ncmVzczogeyAuLi5maWxlc1tmaWxlLmlkXS5wcm9ncmVzcyB9IH1cbiAgICAgIGRlbGV0ZSBmaWxlc1tmaWxlLmlkXS5wcm9ncmVzcy5wcmVwcm9jZXNzXG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBmaWxlcyB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCdwb3N0cHJvY2Vzcy1wcm9ncmVzcycsIChmaWxlLCBwcm9ncmVzcykgPT4ge1xuICAgICAgaWYgKCF0aGlzLmdldEZpbGUoZmlsZS5pZCkpIHtcbiAgICAgICAgdGhpcy5sb2coYE5vdCBzZXR0aW5nIHByb2dyZXNzIGZvciBhIGZpbGUgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAke2ZpbGUuaWR9YClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLnNldEZpbGVTdGF0ZShmaWxlLmlkLCB7XG4gICAgICAgIHByb2dyZXNzOiB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5maWxlc1tmaWxlLmlkXS5wcm9ncmVzcywgcG9zdHByb2Nlc3M6IHByb2dyZXNzIH0sXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCdwb3N0cHJvY2Vzcy1jb21wbGV0ZScsIChmaWxlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcHJvZ3Jlc3MgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7ZmlsZS5pZH1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVzID0ge1xuICAgICAgICAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMsXG4gICAgICB9XG4gICAgICBmaWxlc1tmaWxlLmlkXSA9IHtcbiAgICAgICAgLi4uZmlsZXNbZmlsZS5pZF0sXG4gICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgLi4uZmlsZXNbZmlsZS5pZF0ucHJvZ3Jlc3MsXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgICBkZWxldGUgZmlsZXNbZmlsZS5pZF0ucHJvZ3Jlc3MucG9zdHByb2Nlc3NcbiAgICAgIC8vIFRPRE8gc2hvdWxkIHdlIHNldCBzb21lIGtpbmQgb2YgYGZ1bGx5Q29tcGxldGVgIHByb3BlcnR5IG9uIHRoZSBmaWxlIG9iamVjdFxuICAgICAgLy8gc28gaXQncyBlYXNpZXIgdG8gc2VlIHRoYXQgdGhlIGZpbGUgaXMgdXBsb2Fk4oCmZnVsbHkgY29tcGxldGXigKZyYXRoZXIgdGhhblxuICAgICAgLy8gd2hhdCB3ZSBoYXZlIHRvIGRvIG5vdyAoYHVwbG9hZENvbXBsZXRlICYmICFwb3N0cHJvY2Vzc2ApXG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBmaWxlcyB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCdyZXN0b3JlZCcsICgpID0+IHtcbiAgICAgIC8vIEZpbGVzIG1heSBoYXZlIGNoYW5nZWQtLWVuc3VyZSBwcm9ncmVzcyBpcyBzdGlsbCBhY2N1cmF0ZS5cbiAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxQcm9ncmVzcygpXG4gICAgfSlcblxuICAgIC8vIHNob3cgaW5mb3JtZXIgaWYgb2ZmbGluZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsICgpID0+IHRoaXMudXBkYXRlT25saW5lU3RhdHVzKCkpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsICgpID0+IHRoaXMudXBkYXRlT25saW5lU3RhdHVzKCkpXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlT25saW5lU3RhdHVzKCksIDMwMDApXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlT25saW5lU3RhdHVzICgpIHtcbiAgICBjb25zdCBvbmxpbmVcbiAgICAgID0gdHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lXG4gICAgICAgIDogdHJ1ZVxuICAgIGlmICghb25saW5lKSB7XG4gICAgICB0aGlzLmVtaXQoJ2lzLW9mZmxpbmUnKVxuICAgICAgdGhpcy5pbmZvKHRoaXMuaTE4bignbm9JbnRlcm5ldENvbm5lY3Rpb24nKSwgJ2Vycm9yJywgMClcbiAgICAgIHRoaXMud2FzT2ZmbGluZSA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdpcy1vbmxpbmUnKVxuICAgICAgaWYgKHRoaXMud2FzT2ZmbGluZSkge1xuICAgICAgICB0aGlzLmVtaXQoJ2JhY2stb25saW5lJylcbiAgICAgICAgdGhpcy5pbmZvKHRoaXMuaTE4bignY29ubmVjdGVkVG9JbnRlcm5ldCcpLCAnc3VjY2VzcycsIDMwMDApXG4gICAgICAgIHRoaXMud2FzT2ZmbGluZSA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0SUQgKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHMuaWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBwbHVnaW4gd2l0aCBDb3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luIG9iamVjdFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdHNdIG9iamVjdCB3aXRoIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIFBsdWdpblxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBzZWxmIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICB1c2UgKFBsdWdpbiwgb3B0cykge1xuICAgIGlmICh0eXBlb2YgUGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgYSBwbHVnaW4gY2xhc3MsIGJ1dCBnb3QgJHtQbHVnaW4gPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgUGx1Z2lufS5gXG4gICAgICAgICsgJyBQbGVhc2UgdmVyaWZ5IHRoYXQgdGhlIHBsdWdpbiB3YXMgaW1wb3J0ZWQgYW5kIHNwZWxsZWQgY29ycmVjdGx5LidcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobXNnKVxuICAgIH1cblxuICAgIC8vIEluc3RhbnRpYXRlXG4gICAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIGNvbnN0IHBsdWdpbklkID0gcGx1Z2luLmlkXG4gICAgdGhpcy5wbHVnaW5zW3BsdWdpbi50eXBlXSA9IHRoaXMucGx1Z2luc1twbHVnaW4udHlwZV0gfHwgW11cblxuICAgIGlmICghcGx1Z2luSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBwbHVnaW4gbXVzdCBoYXZlIGFuIGlkJylcbiAgICB9XG5cbiAgICBpZiAoIXBsdWdpbi50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgcGx1Z2luIG11c3QgaGF2ZSBhIHR5cGUnKVxuICAgIH1cblxuICAgIGNvbnN0IGV4aXN0c1BsdWdpbkFscmVhZHkgPSB0aGlzLmdldFBsdWdpbihwbHVnaW5JZClcbiAgICBpZiAoZXhpc3RzUGx1Z2luQWxyZWFkeSkge1xuICAgICAgY29uc3QgbXNnID0gYEFscmVhZHkgZm91bmQgYSBwbHVnaW4gbmFtZWQgJyR7ZXhpc3RzUGx1Z2luQWxyZWFkeS5pZH0nLiBgXG4gICAgICAgICsgYFRyaWVkIHRvIHVzZTogJyR7cGx1Z2luSWR9Jy5cXG5gXG4gICAgICAgICsgJ1VwcHkgcGx1Z2lucyBtdXN0IGhhdmUgdW5pcXVlIGBpZGAgb3B0aW9ucy4gU2VlIGh0dHBzOi8vdXBweS5pby9kb2NzL3BsdWdpbnMvI2lkLidcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpXG4gICAgfVxuXG4gICAgaWYgKFBsdWdpbi5WRVJTSU9OKSB7XG4gICAgICB0aGlzLmxvZyhgVXNpbmcgJHtwbHVnaW5JZH0gdiR7UGx1Z2luLlZFUlNJT059YClcbiAgICB9XG5cbiAgICB0aGlzLnBsdWdpbnNbcGx1Z2luLnR5cGVdLnB1c2gocGx1Z2luKVxuICAgIHBsdWdpbi5pbnN0YWxsKClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogRmluZCBvbmUgUGx1Z2luIGJ5IG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBwbHVnaW4gaWRcbiAgICogQHJldHVybnMge29iamVjdHxib29sZWFufVxuICAgKi9cbiAgZ2V0UGx1Z2luIChpZCkge1xuICAgIGxldCBmb3VuZFBsdWdpbiA9IG51bGxcbiAgICB0aGlzLml0ZXJhdGVQbHVnaW5zKChwbHVnaW4pID0+IHtcbiAgICAgIGlmIChwbHVnaW4uaWQgPT09IGlkKSB7XG4gICAgICAgIGZvdW5kUGx1Z2luID0gcGx1Z2luXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvdW5kUGx1Z2luXG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBgdXNlYGQgcGx1Z2lucy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIHRoYXQgd2lsbCBiZSBydW4gb24gZWFjaCBwbHVnaW5cbiAgICovXG4gIGl0ZXJhdGVQbHVnaW5zIChtZXRob2QpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLnBsdWdpbnMpLmZvckVhY2gocGx1Z2luVHlwZSA9PiB7XG4gICAgICB0aGlzLnBsdWdpbnNbcGx1Z2luVHlwZV0uZm9yRWFjaChtZXRob2QpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmluc3RhbGwgYW5kIHJlbW92ZSBhIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3RhbmNlIFRoZSBwbHVnaW4gaW5zdGFuY2UgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlUGx1Z2luIChpbnN0YW5jZSkge1xuICAgIHRoaXMubG9nKGBSZW1vdmluZyBwbHVnaW4gJHtpbnN0YW5jZS5pZH1gKVxuICAgIHRoaXMuZW1pdCgncGx1Z2luLXJlbW92ZScsIGluc3RhbmNlKVxuXG4gICAgaWYgKGluc3RhbmNlLnVuaW5zdGFsbCkge1xuICAgICAgaW5zdGFuY2UudW5pbnN0YWxsKClcbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ID0gdGhpcy5wbHVnaW5zW2luc3RhbmNlLnR5cGVdLnNsaWNlKClcbiAgICAvLyBsaXN0LmluZGV4T2YgZmFpbGVkIGhlcmUsIGJlY2F1c2UgVnVlMyBjb252ZXJ0ZWQgdGhlIHBsdWdpbiBpbnN0YW5jZVxuICAgIC8vIHRvIGEgUHJveHkgb2JqZWN0LCB3aGljaCBmYWlsZWQgdGhlIHN0cmljdCBjb21wYXJpc29uIHRlc3Q6XG4gICAgLy8gb2JqICE9PSBvYmpQcm94eVxuICAgIGNvbnN0IGluZGV4ID0gZmluZEluZGV4KGxpc3QsIGl0ZW0gPT4gaXRlbS5pZCA9PT0gaW5zdGFuY2UuaWQpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICB0aGlzLnBsdWdpbnNbaW5zdGFuY2UudHlwZV0gPSBsaXN0XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKClcbiAgICBjb25zdCB1cGRhdGVkU3RhdGUgPSB7XG4gICAgICBwbHVnaW5zOiB7XG4gICAgICAgIC4uLnN0YXRlLnBsdWdpbnMsXG4gICAgICAgIFtpbnN0YW5jZS5pZF06IHVuZGVmaW5lZCxcbiAgICAgIH0sXG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUodXBkYXRlZFN0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFVuaW5zdGFsbCBhbGwgcGx1Z2lucyBhbmQgY2xvc2UgZG93biB0aGlzIFVwcHkgaW5zdGFuY2UuXG4gICAqL1xuICBjbG9zZSAoKSB7XG4gICAgdGhpcy5sb2coYENsb3NpbmcgVXBweSBpbnN0YW5jZSAke3RoaXMub3B0cy5pZH06IHJlbW92aW5nIGFsbCBmaWxlcyBhbmQgdW5pbnN0YWxsaW5nIHBsdWdpbnNgKVxuXG4gICAgdGhpcy5yZXNldCgpXG5cbiAgICB0aGlzLnN0b3JlVW5zdWJzY3JpYmUoKVxuXG4gICAgdGhpcy5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZVBsdWdpbihwbHVnaW4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgaW5mbyBtZXNzYWdlIGluIGBzdGF0ZS5pbmZvYCwgc28gdGhhdCBVSSBwbHVnaW5zIGxpa2UgYEluZm9ybWVyYFxuICAgKiBjYW4gZGlzcGxheSB0aGUgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBvYmplY3R9IG1lc3NhZ2UgTWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQgYnkgdGhlIGluZm9ybWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbl1cbiAgICovXG5cbiAgaW5mbyAobWVzc2FnZSwgdHlwZSA9ICdpbmZvJywgZHVyYXRpb24gPSAzMDAwKSB7XG4gICAgY29uc3QgaXNDb21wbGV4TWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0J1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBpbmZvOiB7XG4gICAgICAgIGlzSGlkZGVuOiBmYWxzZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbWVzc2FnZTogaXNDb21wbGV4TWVzc2FnZSA/IG1lc3NhZ2UubWVzc2FnZSA6IG1lc3NhZ2UsXG4gICAgICAgIGRldGFpbHM6IGlzQ29tcGxleE1lc3NhZ2UgPyBtZXNzYWdlLmRldGFpbHMgOiBudWxsLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgdGhpcy5lbWl0KCdpbmZvLXZpc2libGUnKVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaW5mb1RpbWVvdXRJRClcbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIHRoaXMuaW5mb1RpbWVvdXRJRCA9IHVuZGVmaW5lZFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaGlkZSB0aGUgaW5mb3JtZXIgYWZ0ZXIgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHNcbiAgICB0aGlzLmluZm9UaW1lb3V0SUQgPSBzZXRUaW1lb3V0KHRoaXMuaGlkZUluZm8sIGR1cmF0aW9uKVxuICB9XG5cbiAgaGlkZUluZm8gKCkge1xuICAgIGNvbnN0IG5ld0luZm8gPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5pbmZvLCBpc0hpZGRlbjogdHJ1ZSB9XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBpbmZvOiBuZXdJbmZvLFxuICAgIH0pXG4gICAgdGhpcy5lbWl0KCdpbmZvLWhpZGRlbicpXG4gIH1cblxuICAvKipcbiAgICogUGFzc2VzIG1lc3NhZ2VzIHRvIGEgZnVuY3Rpb24sIHByb3ZpZGVkIGluIGBvcHRzLmxvZ2dlcmAuXG4gICAqIElmIGBvcHRzLmxvZ2dlcjogVXBweS5kZWJ1Z0xvZ2dlcmAgb3IgYG9wdHMuZGVidWc6IHRydWVgLCBsb2dzIHRvIHRoZSBicm93c2VyIGNvbnNvbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gbWVzc2FnZSB0byBsb2dcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBvcHRpb25hbCBgZXJyb3JgIG9yIGB3YXJuaW5nYFxuICAgKi9cbiAgbG9nIChtZXNzYWdlLCB0eXBlKSB7XG4gICAgY29uc3QgeyBsb2dnZXIgfSA9IHRoaXMub3B0c1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnZXJyb3InOiBsb2dnZXIuZXJyb3IobWVzc2FnZSk7IGJyZWFrXG4gICAgICBjYXNlICd3YXJuaW5nJzogbG9nZ2VyLndhcm4obWVzc2FnZSk7IGJyZWFrXG4gICAgICBkZWZhdWx0OiBsb2dnZXIuZGVidWcobWVzc2FnZSk7IGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ic29sZXRlLCBldmVudCBsaXN0ZW5lcnMgYXJlIG5vdyBhZGRlZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAqL1xuICBydW4gKCkge1xuICAgIHRoaXMubG9nKCdDYWxsaW5nIHJ1bigpIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkuJywgJ3dhcm5pbmcnKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSBhbiB1cGxvYWQgYnkgaXRzIElELlxuICAgKi9cbiAgcmVzdG9yZSAodXBsb2FkSUQpIHtcbiAgICB0aGlzLmxvZyhgQ29yZTogYXR0ZW1wdGluZyB0byByZXN0b3JlIHVwbG9hZCBcIiR7dXBsb2FkSUR9XCJgKVxuXG4gICAgaWYgKCF0aGlzLmdldFN0YXRlKCkuY3VycmVudFVwbG9hZHNbdXBsb2FkSURdKSB7XG4gICAgICB0aGlzLnJlbW92ZVVwbG9hZCh1cGxvYWRJRClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vbmV4aXN0ZW50IHVwbG9hZCcpKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJ1blVwbG9hZCh1cGxvYWRJRClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gdXBsb2FkIGZvciBhIGJ1bmNoIG9mIGZpbGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGZpbGVJRHMgRmlsZSBJRHMgdG8gaW5jbHVkZSBpbiB0aGlzIHVwbG9hZC5cbiAgICogQHJldHVybnMge3N0cmluZ30gSUQgb2YgdGhpcyB1cGxvYWQuXG4gICAqL1xuICBjcmVhdGVVcGxvYWQgKGZpbGVJRHMsIG9wdHMgPSB7fSkge1xuICAgIC8vIHVwcHkucmV0cnlBbGwgc2V0cyB0aGlzIHRvIHRydWUg4oCUIHdoZW4gcmV0cnlpbmcgd2Ugd2FudCB0byBpZ25vcmUgYGFsbG93TmV3VXBsb2FkOiBmYWxzZWBcbiAgICBjb25zdCB7IGZvcmNlQWxsb3dOZXdVcGxvYWQgPSBmYWxzZSB9ID0gb3B0c1xuXG4gICAgY29uc3QgeyBhbGxvd05ld1VwbG9hZCwgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgIGlmICghYWxsb3dOZXdVcGxvYWQgJiYgIWZvcmNlQWxsb3dOZXdVcGxvYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBhIG5ldyB1cGxvYWQ6IGFscmVhZHkgdXBsb2FkaW5nLicpXG4gICAgfVxuXG4gICAgY29uc3QgdXBsb2FkSUQgPSBjdWlkKClcblxuICAgIHRoaXMuZW1pdCgndXBsb2FkJywge1xuICAgICAgaWQ6IHVwbG9hZElELFxuICAgICAgZmlsZUlEcyxcbiAgICB9KVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBhbGxvd05ld1VwbG9hZDogdGhpcy5vcHRzLmFsbG93TXVsdGlwbGVVcGxvYWRzICE9PSBmYWxzZSxcblxuICAgICAgY3VycmVudFVwbG9hZHM6IHtcbiAgICAgICAgLi4uY3VycmVudFVwbG9hZHMsXG4gICAgICAgIFt1cGxvYWRJRF06IHtcbiAgICAgICAgICBmaWxlSURzLFxuICAgICAgICAgIHN0ZXA6IDAsXG4gICAgICAgICAgcmVzdWx0OiB7fSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIHJldHVybiB1cGxvYWRJRFxuICB9XG5cbiAgZ2V0VXBsb2FkICh1cGxvYWRJRCkge1xuICAgIGNvbnN0IHsgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuXG4gICAgcmV0dXJuIGN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBkYXRhIHRvIGFuIHVwbG9hZCdzIHJlc3VsdCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cGxvYWRJRCBUaGUgSUQgb2YgdGhlIHVwbG9hZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YSBwcm9wZXJ0aWVzIHRvIGFkZCB0byB0aGUgcmVzdWx0IG9iamVjdC5cbiAgICovXG4gIGFkZFJlc3VsdERhdGEgKHVwbG9hZElELCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmdldFVwbG9hZCh1cGxvYWRJRCkpIHtcbiAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyByZXN1bHQgZm9yIGFuIHVwbG9hZCB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7dXBsb2FkSUR9YClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICBjb25zdCBjdXJyZW50VXBsb2FkID0geyAuLi5jdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0sIHJlc3VsdDogeyAuLi5jdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0ucmVzdWx0LCAuLi5kYXRhIH0gfVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY3VycmVudFVwbG9hZHM6IHsgLi4uY3VycmVudFVwbG9hZHMsIFt1cGxvYWRJRF06IGN1cnJlbnRVcGxvYWQgfSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiB1cGxvYWQsIGVnLiBpZiBpdCBoYXMgYmVlbiBjYW5jZWxlZCBvciBjb21wbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cGxvYWRJRCBUaGUgSUQgb2YgdGhlIHVwbG9hZC5cbiAgICovXG4gIHJlbW92ZVVwbG9hZCAodXBsb2FkSUQpIHtcbiAgICBjb25zdCBjdXJyZW50VXBsb2FkcyA9IHsgLi4udGhpcy5nZXRTdGF0ZSgpLmN1cnJlbnRVcGxvYWRzIH1cbiAgICBkZWxldGUgY3VycmVudFVwbG9hZHNbdXBsb2FkSURdXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGN1cnJlbnRVcGxvYWRzLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUnVuIGFuIHVwbG9hZC4gVGhpcyBwaWNrcyB1cCB3aGVyZSBpdCBsZWZ0IG9mZiBpbiBjYXNlIHRoZSB1cGxvYWQgaXMgYmVpbmcgcmVzdG9yZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBydW5VcGxvYWQgKHVwbG9hZElEKSB7XG4gICAgY29uc3QgdXBsb2FkRGF0YSA9IHRoaXMuZ2V0U3RhdGUoKS5jdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF1cbiAgICBjb25zdCByZXN0b3JlU3RlcCA9IHVwbG9hZERhdGEuc3RlcFxuXG4gICAgY29uc3Qgc3RlcHMgPSBbXG4gICAgICAuLi50aGlzLnByZVByb2Nlc3NvcnMsXG4gICAgICAuLi50aGlzLnVwbG9hZGVycyxcbiAgICAgIC4uLnRoaXMucG9zdFByb2Nlc3NvcnMsXG4gICAgXVxuICAgIGxldCBsYXN0U3RlcCA9IFByb21pc2UucmVzb2x2ZSgpXG4gICAgc3RlcHMuZm9yRWFjaCgoZm4sIHN0ZXApID0+IHtcbiAgICAgIC8vIFNraXAgdGhpcyBzdGVwIGlmIHdlIGFyZSByZXN0b3JpbmcgYW5kIGhhdmUgYWxyZWFkeSBjb21wbGV0ZWQgdGhpcyBzdGVwIGJlZm9yZS5cbiAgICAgIGlmIChzdGVwIDwgcmVzdG9yZVN0ZXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxhc3RTdGVwID0gbGFzdFN0ZXAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgICAgICBjb25zdCBjdXJyZW50VXBsb2FkID0gY3VycmVudFVwbG9hZHNbdXBsb2FkSURdXG4gICAgICAgIGlmICghY3VycmVudFVwbG9hZCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXBkYXRlZFVwbG9hZCA9IHtcbiAgICAgICAgICAuLi5jdXJyZW50VXBsb2FkLFxuICAgICAgICAgIHN0ZXAsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjdXJyZW50VXBsb2Fkczoge1xuICAgICAgICAgICAgLi4uY3VycmVudFVwbG9hZHMsXG4gICAgICAgICAgICBbdXBsb2FkSURdOiB1cGRhdGVkVXBsb2FkLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gVE9ETyBnaXZlIHRoaXMgdGhlIGB1cGRhdGVkVXBsb2FkYCBvYmplY3QgYXMgaXRzIG9ubHkgcGFyYW1ldGVyIG1heWJlP1xuICAgICAgICAvLyBPdGhlcndpc2Ugd2hlbiBtb3JlIG1ldGFkYXRhIG1heSBiZSBhZGRlZCB0byB0aGUgdXBsb2FkIHRoaXMgd291bGQga2VlcCBnZXR0aW5nIG1vcmUgcGFyYW1ldGVyc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgcmV0dXJuIGZuKHVwZGF0ZWRVcGxvYWQuZmlsZUlEcywgdXBsb2FkSUQpXG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIC8vIE5vdCByZXR1cm5pbmcgdGhlIGBjYXRjaGBlZCBwcm9taXNlLCBiZWNhdXNlIHdlIHN0aWxsIHdhbnQgdG8gcmV0dXJuIGEgcmVqZWN0ZWRcbiAgICAvLyBwcm9taXNlIGZyb20gdGhpcyBtZXRob2QgaWYgdGhlIHVwbG9hZCBmYWlsZWQuXG4gICAgbGFzdFN0ZXAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIHRoaXMucmVtb3ZlVXBsb2FkKHVwbG9hZElEKVxuICAgIH0pXG5cbiAgICByZXR1cm4gbGFzdFN0ZXAudGhlbigoKSA9PiB7XG4gICAgICAvLyBTZXQgcmVzdWx0IGRhdGEuXG4gICAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICAgIGNvbnN0IGN1cnJlbnRVcGxvYWQgPSBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF1cbiAgICAgIGlmICghY3VycmVudFVwbG9hZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gTWFyayBwb3N0cHJvY2Vzc2luZyBzdGVwIGFzIGNvbXBsZXRlIGlmIG5lY2Vzc2FyeTsgdGhpcyBhZGRyZXNzZXMgYSBjYXNlIHdoZXJlIHdlIG1pZ2h0IGdldFxuICAgICAgLy8gc3R1Y2sgaW4gdGhlIHBvc3Rwcm9jZXNzaW5nIFVJIHdoaWxlIHRoZSB1cGxvYWQgaXMgZnVsbHkgY29tcGxldGUuXG4gICAgICAvLyBJZiB0aGUgcG9zdHByb2Nlc3Npbmcgc3RlcHMgZG8gbm90IGRvIGFueSB3b3JrLCB0aGV5IG1heSBub3QgZW1pdCBwb3N0cHJvY2Vzc2luZyBldmVudHMgYXRcbiAgICAgIC8vIGFsbCwgYW5kIG5ldmVyIG1hcmsgdGhlIHBvc3Rwcm9jZXNzaW5nIGFzIGNvbXBsZXRlLiBUaGlzIGlzIGZpbmUgb24gaXRzIG93biBidXQgd2VcbiAgICAgIC8vIGludHJvZHVjZWQgY29kZSBpbiB0aGUgQHVwcHkvY29yZSB1cGxvYWQtc3VjY2VzcyBoYW5kbGVyIHRvIHByZXBhcmUgcG9zdHByb2Nlc3NpbmcgcHJvZ3Jlc3NcbiAgICAgIC8vIHN0YXRlIGlmIGFueSBwb3N0cHJvY2Vzc29ycyBhcmUgcmVnaXN0ZXJlZC4gVGhhdCBpcyB0byBhdm9pZCBhIFwiZmxhc2ggb2YgY29tcGxldGVkIHN0YXRlXCJcbiAgICAgIC8vIGJlZm9yZSB0aGUgcG9zdHByb2Nlc3NpbmcgcGx1Z2lucyBjYW4gZW1pdCBldmVudHMuXG4gICAgICAvL1xuICAgICAgLy8gU28sIGp1c3QgaW4gY2FzZSBhbiB1cGxvYWQgd2l0aCBwb3N0cHJvY2Vzc2luZyBwbHVnaW5zICpoYXMqIGNvbXBsZXRlZCAqd2l0aG91dCogZW1pdHRpbmdcbiAgICAgIC8vIHBvc3Rwcm9jZXNzaW5nIGNvbXBsZXRpb24sIHdlIGRvIGl0IGluc3RlYWQuXG4gICAgICBjdXJyZW50VXBsb2FkLmZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGUoZmlsZUlEKVxuICAgICAgICBpZiAoZmlsZSAmJiBmaWxlLnByb2dyZXNzLnBvc3Rwcm9jZXNzKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdwb3N0cHJvY2Vzcy1jb21wbGV0ZScsIGZpbGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGZpbGVzID0gY3VycmVudFVwbG9hZC5maWxlSURzLm1hcCgoZmlsZUlEKSA9PiB0aGlzLmdldEZpbGUoZmlsZUlEKSlcbiAgICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+ICFmaWxlLmVycm9yKVxuICAgICAgY29uc3QgZmFpbGVkID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiBmaWxlLmVycm9yKVxuICAgICAgdGhpcy5hZGRSZXN1bHREYXRhKHVwbG9hZElELCB7IHN1Y2Nlc3NmdWwsIGZhaWxlZCwgdXBsb2FkSUQgfSlcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIC8vIEVtaXQgY29tcGxldGlvbiBldmVudHMuXG4gICAgICAvLyBUaGlzIGlzIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24gc28gdGhhdCB0aGUgYGN1cnJlbnRVcGxvYWRzYCB2YXJpYWJsZVxuICAgICAgLy8gYWx3YXlzIHJlZmVycyB0byB0aGUgbGF0ZXN0IHN0YXRlLiBJbiB0aGUgaGFuZGxlciByaWdodCBhYm92ZSBpdCByZWZlcnNcbiAgICAgIC8vIHRvIGFuIG91dGRhdGVkIG9iamVjdCB3aXRob3V0IHRoZSBgLnJlc3VsdGAgcHJvcGVydHkuXG4gICAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICAgIGlmICghY3VycmVudFVwbG9hZHNbdXBsb2FkSURdKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudFVwbG9hZCA9IGN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXVxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGN1cnJlbnRVcGxvYWRcbiAgICAgIHRoaXMuZW1pdCgnY29tcGxldGUnLCByZXN1bHQpXG5cbiAgICAgIHRoaXMucmVtb3ZlVXBsb2FkKHVwbG9hZElEKVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcmVzdWx0IGZvciBhbiB1cGxvYWQgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAke3VwbG9hZElEfWApXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhbiB1cGxvYWQgZm9yIGFsbCB0aGUgZmlsZXMgdGhhdCBhcmUgbm90IGN1cnJlbnRseSBiZWluZyB1cGxvYWRlZC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICB1cGxvYWQgKCkge1xuICAgIGlmICghdGhpcy5wbHVnaW5zLnVwbG9hZGVyKSB7XG4gICAgICB0aGlzLmxvZygnTm8gdXBsb2FkZXIgdHlwZSBwbHVnaW5zIGFyZSB1c2VkJywgJ3dhcm5pbmcnKVxuICAgIH1cblxuICAgIGxldCB7IGZpbGVzIH0gPSB0aGlzLmdldFN0YXRlKClcblxuICAgIGNvbnN0IG9uQmVmb3JlVXBsb2FkUmVzdWx0ID0gdGhpcy5vcHRzLm9uQmVmb3JlVXBsb2FkKGZpbGVzKVxuXG4gICAgaWYgKG9uQmVmb3JlVXBsb2FkUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm90IHN0YXJ0aW5nIHRoZSB1cGxvYWQgYmVjYXVzZSBvbkJlZm9yZVVwbG9hZCByZXR1cm5lZCBmYWxzZScpKVxuICAgIH1cblxuICAgIGlmIChvbkJlZm9yZVVwbG9hZFJlc3VsdCAmJiB0eXBlb2Ygb25CZWZvcmVVcGxvYWRSZXN1bHQgPT09ICdvYmplY3QnKSB7XG4gICAgICBmaWxlcyA9IG9uQmVmb3JlVXBsb2FkUmVzdWx0XG4gICAgICAvLyBVcGRhdGluZyBmaWxlcyBpbiBzdGF0ZSwgYmVjYXVzZSB1cGxvYWRlciBwbHVnaW5zIHJlY2VpdmUgZmlsZSBJRHMsXG4gICAgICAvLyBhbmQgdGhlbiBmZXRjaCB0aGUgYWN0dWFsIGZpbGUgb2JqZWN0IGZyb20gc3RhdGVcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBmaWxlcyxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmNoZWNrTWluTnVtYmVyT2ZGaWxlcyhmaWxlcykpXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnNob3dPckxvZ0Vycm9yQW5kVGhyb3coZXJyKVxuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VXBsb2FkcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgICAgIC8vIGdldCBhIGxpc3Qgb2YgZmlsZXMgdGhhdCBhcmUgY3VycmVudGx5IGFzc2lnbmVkIHRvIHVwbG9hZHNcbiAgICAgICAgY29uc3QgY3VycmVudGx5VXBsb2FkaW5nRmlsZXMgPSBPYmplY3Qua2V5cyhjdXJyZW50VXBsb2FkcylcbiAgICAgICAgICAucmVkdWNlKChwcmV2LCBjdXJyKSA9PiBwcmV2LmNvbmNhdChjdXJyZW50VXBsb2Fkc1tjdXJyXS5maWxlSURzKSwgW10pXG5cbiAgICAgICAgY29uc3Qgd2FpdGluZ0ZpbGVJRHMgPSBbXVxuICAgICAgICBPYmplY3Qua2V5cyhmaWxlcykuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZShmaWxlSUQpXG4gICAgICAgICAgLy8gaWYgdGhlIGZpbGUgaGFzbid0IHN0YXJ0ZWQgdXBsb2FkaW5nIGFuZCBoYXNuJ3QgYWxyZWFkeSBiZWVuIGFzc2lnbmVkIHRvIGFuIHVwbG9hZC4uXG4gICAgICAgICAgaWYgKCghZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkKSAmJiAoY3VycmVudGx5VXBsb2FkaW5nRmlsZXMuaW5kZXhPZihmaWxlSUQpID09PSAtMSkpIHtcbiAgICAgICAgICAgIHdhaXRpbmdGaWxlSURzLnB1c2goZmlsZS5pZClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgdXBsb2FkSUQgPSB0aGlzLmNyZWF0ZVVwbG9hZCh3YWl0aW5nRmlsZUlEcylcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuVXBsb2FkKHVwbG9hZElEKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuc2hvd09yTG9nRXJyb3JBbmRUaHJvdyhlcnIsIHtcbiAgICAgICAgICBzaG93SW5mb3JtZXI6IGZhbHNlLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvcmUgKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBVcHB5KG9wdHMpXG59XG5cbi8vIEV4cG9zZSBjbGFzcyBjb25zdHJ1Y3Rvci5cbm1vZHVsZS5leHBvcnRzLlVwcHkgPSBVcHB5XG5tb2R1bGUuZXhwb3J0cy5QbHVnaW4gPSBQbHVnaW5cbm1vZHVsZS5leHBvcnRzLmRlYnVnTG9nZ2VyID0gZGVidWdMb2dnZXJcbiIsImNvbnN0IGdldFRpbWVTdGFtcCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRUaW1lU3RhbXAnKVxuXG4vLyBTd2FsbG93IGFsbCBsb2dzLCBleGNlcHQgZXJyb3JzLlxuLy8gZGVmYXVsdCBpZiBsb2dnZXIgaXMgbm90IHNldCBvciBkZWJ1ZzogZmFsc2VcbmNvbnN0IGp1c3RFcnJvcnNMb2dnZXIgPSB7XG4gIGRlYnVnOiAoLi4uYXJncykgPT4ge30sXG4gIHdhcm46ICguLi5hcmdzKSA9PiB7fSxcbiAgZXJyb3I6ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKGBbVXBweV0gWyR7Z2V0VGltZVN0YW1wKCl9XWAsIC4uLmFyZ3MpLFxufVxuXG4vLyBQcmludCBsb2dzIHRvIGNvbnNvbGUgd2l0aCBuYW1lc3BhY2UgKyB0aW1lc3RhbXAsXG4vLyBzZXQgYnkgbG9nZ2VyOiBVcHB5LmRlYnVnTG9nZ2VyIG9yIGRlYnVnOiB0cnVlXG5jb25zdCBkZWJ1Z0xvZ2dlciA9IHtcbiAgZGVidWc6ICguLi5hcmdzKSA9PiB7XG4gICAgLy8gSUUgMTAgZG9lc27igJl0IHN1cHBvcnQgY29uc29sZS5kZWJ1Z1xuICAgIGNvbnN0IGRlYnVnID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZ1xuICAgIGRlYnVnLmNhbGwoY29uc29sZSwgYFtVcHB5XSBbJHtnZXRUaW1lU3RhbXAoKX1dYCwgLi4uYXJncylcbiAgfSxcbiAgd2FybjogKC4uLmFyZ3MpID0+IGNvbnNvbGUud2FybihgW1VwcHldIFske2dldFRpbWVTdGFtcCgpfV1gLCAuLi5hcmdzKSxcbiAgZXJyb3I6ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKGBbVXBweV0gWyR7Z2V0VGltZVN0YW1wKCl9XWAsIC4uLmFyZ3MpLFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAganVzdEVycm9yc0xvZ2dlcixcbiAgZGVidWdMb2dnZXIsXG59XG4iLCIvLyBFZGdlIDE1LnggZG9lcyBub3QgZmlyZSAncHJvZ3Jlc3MnIGV2ZW50cyBvbiB1cGxvYWRzLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlcy85NDVcbi8vIEFuZCBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMjIyNDUxMC9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyAodXNlckFnZW50KSB7XG4gIC8vIEFsbG93IHBhc3NpbmcgaW4gdXNlckFnZW50IGZvciB0ZXN0c1xuICBpZiAodXNlckFnZW50ID09IG51bGwpIHtcbiAgICB1c2VyQWdlbnQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci51c2VyQWdlbnQgOiBudWxsXG4gIH1cbiAgLy8gQXNzdW1lIGl0IHdvcmtzIGJlY2F1c2UgYmFzaWNhbGx5IGV2ZXJ5dGhpbmcgc3VwcG9ydHMgcHJvZ3Jlc3MgZXZlbnRzLlxuICBpZiAoIXVzZXJBZ2VudCkgcmV0dXJuIHRydWVcblxuICBjb25zdCBtID0gL0VkZ2VcXC8oXFxkK1xcLlxcZCspLy5leGVjKHVzZXJBZ2VudClcbiAgaWYgKCFtKSByZXR1cm4gdHJ1ZVxuXG4gIGNvbnN0IGVkZ2VWZXJzaW9uID0gbVsxXVxuICBsZXQgW21ham9yLCBtaW5vcl0gPSBlZGdlVmVyc2lvbi5zcGxpdCgnLicpXG4gIG1ham9yID0gcGFyc2VJbnQobWFqb3IsIDEwKVxuICBtaW5vciA9IHBhcnNlSW50KG1pbm9yLCAxMClcblxuICAvLyBXb3JrZWQgYmVmb3JlOlxuICAvLyBFZGdlIDQwLjE1MDYzLjAuMFxuICAvLyBNaWNyb3NvZnQgRWRnZUhUTUwgMTUuMTUwNjNcbiAgaWYgKG1ham9yIDwgMTUgfHwgKG1ham9yID09PSAxNSAmJiBtaW5vciA8IDE1MDYzKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBGaXhlZCBpbjpcbiAgLy8gTWljcm9zb2Z0IEVkZ2VIVE1MIDE4LjE4MjE4XG4gIGlmIChtYWpvciA+IDE4IHx8IChtYWpvciA9PT0gMTggJiYgbWlub3IgPj0gMTgyMTgpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIG90aGVyIHZlcnNpb25zIGRvbid0IHdvcmsuXG4gIHJldHVybiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9kYXNoYm9hcmRcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlVuaXZlcnNhbCBVSSBwbHVnaW4gZm9yIFVwcHkuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuMjAuMlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwic3R5bGVcIjogXCJkaXN0L3N0eWxlLm1pbi5jc3NcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwiZGFzaGJvYXJkXCIsXG4gICAgXCJ1aVwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzXCI6IFwiMC4wLjdcIixcbiAgICBcIkB1cHB5L2luZm9ybWVyXCI6IFwiZmlsZTouLi9pbmZvcm1lclwiLFxuICAgIFwiQHVwcHkvcHJvdmlkZXItdmlld3NcIjogXCJmaWxlOi4uL3Byb3ZpZGVyLXZpZXdzXCIsXG4gICAgXCJAdXBweS9zdGF0dXMtYmFyXCI6IFwiZmlsZTouLi9zdGF0dXMtYmFyXCIsXG4gICAgXCJAdXBweS90aHVtYm5haWwtZ2VuZXJhdG9yXCI6IFwiZmlsZTouLi90aHVtYm5haWwtZ2VuZXJhdG9yXCIsXG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIixcbiAgICBcImNsYXNzbmFtZXNcIjogXCJeMi4yLjZcIixcbiAgICBcImN1aWRcIjogXCJeMi4xLjFcIixcbiAgICBcImlzLXNoYWxsb3ctZXF1YWxcIjogXCJeMS4wLjFcIixcbiAgICBcImxvZGFzaC5kZWJvdW5jZVwiOiBcIl40LjAuOFwiLFxuICAgIFwibG9kYXNoLnRocm90dGxlXCI6IFwiXjQuMS4xXCIsXG4gICAgXCJtZW1vaXplLW9uZVwiOiBcIl41LjAuNFwiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIixcbiAgICBcInJlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbFwiOiBcIl4xLjUuMFwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNsYXNzIEFkZEZpbGVzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgdHJpZ2dlckZpbGVJbnB1dENsaWNrID0gKCkgPT4ge1xuICAgIHRoaXMuZmlsZUlucHV0LmNsaWNrKClcbiAgfVxuXG4gIHRyaWdnZXJGb2xkZXJJbnB1dENsaWNrID0gKCkgPT4ge1xuICAgIHRoaXMuZm9sZGVySW5wdXQuY2xpY2soKVxuICB9XG5cbiAgb25GaWxlSW5wdXRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICB0aGlzLnByb3BzLmhhbmRsZUlucHV0Q2hhbmdlKGV2ZW50KVxuXG4gICAgLy8gV2UgY2xlYXIgdGhlIGlucHV0IGFmdGVyIGEgZmlsZSBpcyBzZWxlY3RlZCwgYmVjYXVzZSBvdGhlcndpc2VcbiAgICAvLyBjaGFuZ2UgZXZlbnQgaXMgbm90IGZpcmVkIGluIENocm9tZSBhbmQgU2FmYXJpIHdoZW4gYSBmaWxlXG4gICAgLy8gd2l0aCB0aGUgc2FtZSBuYW1lIGlzIHNlbGVjdGVkLlxuICAgIC8vIF9fX1doeSBub3QgdXNlIHZhbHVlPVwiXCIgb24gPGlucHV0Lz4gaW5zdGVhZD9cbiAgICAvLyAgICBCZWNhdXNlIGlmIHdlIHVzZSB0aGF0IG1ldGhvZCBvZiBjbGVhcmluZyB0aGUgaW5wdXQsXG4gICAgLy8gICAgQ2hyb21lIHdpbGwgbm90IHRyaWdnZXIgY2hhbmdlIGlmIHdlIGRyb3AgdGhlIHNhbWUgZmlsZSB0d2ljZSAoSXNzdWUgIzc2OCkuXG4gICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gbnVsbFxuICB9XG5cbiAgcmVuZGVyUG93ZXJlZEJ5VXBweSAoKSB7XG4gICAgY29uc3QgdXBweUJyYW5kaW5nID0gKFxuICAgICAgPHNwYW4+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvbiB1cHB5LURhc2hib2FyZC1wb3dlcmVkQnlJY29uXCIgd2lkdGg9XCIxMVwiIGhlaWdodD1cIjExXCIgdmlld0JveD1cIjAgMCAxMSAxMVwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNNy4zNjUgMTAuNWwtLjAxLTQuMDQ1aDIuNjEyTDUuNS44MDZsLTQuNDY3IDUuNjVoMi42MDRsLjAxIDQuMDQ0aDMuNzE4elwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1wb3dlcmVkQnlVcHB5XCI+VXBweTwvc3Bhbj5cbiAgICAgIDwvc3Bhbj5cbiAgICApXG5cbiAgICAvLyBTdXBwb3J0IGJvdGggdGhlIG9sZCB3b3JkLW9yZGVyLWluc2Vuc2l0aXZlIHN0cmluZyBgcG93ZXJlZEJ5YCBhbmQgdGhlIG5ldyB3b3JkLW9yZGVyLXNlbnNpdGl2ZSBzdHJpbmcgYHBvd2VyZWRCeTJgXG4gICAgY29uc3QgbGlua1RleHQgPSB0aGlzLnByb3BzLmkxOG5BcnJheSgncG93ZXJlZEJ5MicsIHtcbiAgICAgIGJhY2t3YXJkc0NvbXBhdDogdGhpcy5wcm9wcy5pMThuKCdwb3dlcmVkQnknKSxcbiAgICAgIHVwcHk6IHVwcHlCcmFuZGluZyxcbiAgICB9KVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxhXG4gICAgICAgIHRhYkluZGV4PVwiLTFcIlxuICAgICAgICBocmVmPVwiaHR0cHM6Ly91cHB5LmlvXCJcbiAgICAgICAgcmVsPVwibm9yZWZlcnJlciBub29wZW5lclwiXG4gICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLXBvd2VyZWRCeVwiXG4gICAgICA+XG4gICAgICAgIHtsaW5rVGV4dH1cbiAgICAgIDwvYT5cbiAgICApXG4gIH1cblxuICByZW5kZXJIaWRkZW5JbnB1dCA9IChpc0ZvbGRlciwgcmVmQ2FsbGJhY2spID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPGlucHV0XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLWlucHV0XCJcbiAgICAgICAgaGlkZGVuXG4gICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgIHRhYkluZGV4PXstMX1cbiAgICAgICAgd2Via2l0ZGlyZWN0b3J5PXtpc0ZvbGRlcn1cbiAgICAgICAgdHlwZT1cImZpbGVcIlxuICAgICAgICBuYW1lPVwiZmlsZXNbXVwiXG4gICAgICAgIG11bHRpcGxlPXt0aGlzLnByb3BzLm1heE51bWJlck9mRmlsZXMgIT09IDF9XG4gICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uRmlsZUlucHV0Q2hhbmdlfVxuICAgICAgICBhY2NlcHQ9e3RoaXMucHJvcHMuYWxsb3dlZEZpbGVUeXBlc31cbiAgICAgICAgcmVmPXtyZWZDYWxsYmFja31cbiAgICAgIC8+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyTXlEZXZpY2VBY3F1aXJlciA9ICgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZFRhYlwiXG4gICAgICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgICAgICBkYXRhLXVwcHktYWNxdWlyZXItaWQ9XCJNeURldmljZVwiXG4gICAgICA+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LURhc2hib2FyZFRhYi1idG5cIlxuICAgICAgICAgIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgIHRhYkluZGV4PXswfVxuICAgICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLnRyaWdnZXJGaWxlSW5wdXRDbGlja31cbiAgICAgICAgPlxuICAgICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIGZpbGw9XCIjMjI3NUQ3XCIgLz5cbiAgICAgICAgICAgICAgPHBhdGggZD1cIk0yMS45NzMgMjEuMTUySDkuODYzbC0xLjEwOC01LjA4N2gxNC40NjRsLTEuMjQ2IDUuMDg3ek05LjkzNSAxMS4zN2gzLjk1OGwuODg2IDEuNDQ0YS42NzMuNjczIDAgMCAwIC41ODUuMzE2aDYuNTA2djEuMzdIOS45MzV2LTMuMTN6bTE0Ljg5OCAzLjQ0YS43OTMuNzkzIDAgMCAwLS42MTYtLjMxaC0uOTc4di0yLjEyNmMwLS4zNzktLjI3NS0uNjEzLS42NTMtLjYxM0gxNS43NWwtLjg4Ni0xLjQ0NWEuNjczLjY3MyAwIDAgMC0uNTg1LS4zMTZIOS4yMzJjLS4zNzggMC0uNjY3LjIwOS0uNjY3LjU4N1YxNC41aC0uNzgyYS43OTMuNzkzIDAgMCAwLS42MS4zMDMuNzk1Ljc5NSAwIDAgMC0uMTU1LjY2M2wxLjQ1IDYuNjMzYy4wNzguMzYuMzk2LjYxOC43NjQuNjE4aDEzLjM1NGMuMzYgMCAuNjc0LS4yNDYuNzYtLjU5NWwxLjYzMS02LjYzNmEuNzk1Ljc5NSAwIDAgMC0uMTQ0LS42NzV6XCIgZmlsbD1cIiNGRkZcIiAvPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRUYWItbmFtZVwiPnt0aGlzLnByb3BzLmkxOG4oJ215RGV2aWNlJyl9PC9kaXY+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyQnJvd3NlQnV0dG9uID0gKHRleHQsIG9uQ2xpY2tGbikgPT4ge1xuICAgIGNvbnN0IG51bWJlck9mQWNxdWlyZXJzID0gdGhpcy5wcm9wcy5hY3F1aXJlcnMubGVuZ3RoXG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LURhc2hib2FyZC1icm93c2VcIlxuICAgICAgICBvbkNsaWNrPXtvbkNsaWNrRm59XG4gICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGU9e251bWJlck9mQWNxdWlyZXJzID09PSAwfVxuICAgICAgPlxuICAgICAgICB7dGV4dH1cbiAgICAgIDwvYnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIC8vIFRPRE8oMi54KSByZW1vdmUgYWxsIHRoZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBnYXJiYWdlIGhlcmVcbiAgcmVuZGVyRHJvcFBhc3RlQnJvd3NlVGFnbGluZSA9ICgpID0+IHtcbiAgICBjb25zdCBudW1iZXJPZkFjcXVpcmVycyA9IHRoaXMucHJvcHMuYWNxdWlyZXJzLmxlbmd0aFxuICAgIC8vIGluIG9yZGVyIHRvIGtlZXAgdGhlIGkxOG4gQ2FtZWxDYXNlIGFuZCBvcHRpb25zIGxvd2VyIChhcyBhcmUgZGVmYXVsdHMpIHdlIHdpbGwgd2FudCB0byB0cmFuc2Zvcm0gYSBsb3dlclxuICAgIC8vIHRvIENhbWVsXG4gICAgY29uc3QgbG93ZXJGTVNlbGVjdGlvblR5cGUgPSB0aGlzLnByb3BzLmZpbGVNYW5hZ2VyU2VsZWN0aW9uVHlwZVxuICAgIGNvbnN0IGNhbWVsRk1TZWxlY3Rpb25UeXBlID0gbG93ZXJGTVNlbGVjdGlvblR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBsb3dlckZNU2VsZWN0aW9uVHlwZS5zbGljZSgxKVxuXG4gICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3ZSBuZWVkIHRvIHN1cHBvcnQgYm90aCAnYnJvd3NlJyBhbmQgJ2Jyb3dzZUZpbGVzJy8nYnJvd3NlRm9sZGVycycgYXMgc3RyaW5ncyBoZXJlLlxuICAgIGxldCBicm93c2VUZXh0ID0gJ2Jyb3dzZSdcbiAgICBsZXQgYnJvd3NlRmlsZXNUZXh0ID0gJ2Jyb3dzZSdcbiAgICBsZXQgYnJvd3NlRm9sZGVyc1RleHQgPSAnYnJvd3NlJ1xuICAgIGlmIChsb3dlckZNU2VsZWN0aW9uVHlwZSA9PT0gJ2ZpbGVzJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYnJvd3NlVGV4dCA9IHRoaXMucHJvcHMuaTE4bignYnJvd3NlJylcbiAgICAgICAgYnJvd3NlRmlsZXNUZXh0ID0gdGhpcy5wcm9wcy5pMThuKCdicm93c2UnKVxuICAgICAgICBicm93c2VGb2xkZXJzVGV4dCA9IHRoaXMucHJvcHMuaTE4bignYnJvd3NlJylcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBJZ25vcmUsIGhvcGVmdWxseSB3ZSBjYW4gdXNlIHRoZSAnYnJvd3NlRmlsZXMnIC8gJ2Jyb3dzZUZvbGRlcnMnIHN0cmluZ3NcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGJyb3dzZUZpbGVzVGV4dCA9IHRoaXMucHJvcHMuaTE4bignYnJvd3NlRmlsZXMnKVxuICAgICAgYnJvd3NlRm9sZGVyc1RleHQgPSB0aGlzLnByb3BzLmkxOG4oJ2Jyb3dzZUZvbGRlcnMnKVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gSWdub3JlLCB1c2UgdGhlICdicm93c2UnIHN0cmluZ1xuICAgIH1cblxuICAgIGNvbnN0IGJyb3dzZSA9IHRoaXMucmVuZGVyQnJvd3NlQnV0dG9uKGJyb3dzZVRleHQsIHRoaXMudHJpZ2dlckZpbGVJbnB1dENsaWNrKVxuICAgIGNvbnN0IGJyb3dzZUZpbGVzID0gdGhpcy5yZW5kZXJCcm93c2VCdXR0b24oYnJvd3NlRmlsZXNUZXh0LCB0aGlzLnRyaWdnZXJGaWxlSW5wdXRDbGljaylcbiAgICBjb25zdCBicm93c2VGb2xkZXJzID0gdGhpcy5yZW5kZXJCcm93c2VCdXR0b24oYnJvd3NlRm9sZGVyc1RleHQsIHRoaXMudHJpZ2dlckZvbGRlcklucHV0Q2xpY2spXG5cbiAgICAvLyBCZWZvcmUgdGhlIGBmaWxlTWFuYWdlclNlbGVjdGlvblR5cGVgIGZlYXR1cmUgZXhpc3RlZCwgd2UgaGFkIHR3byBwb3NzaWJsZVxuICAgIC8vIHN0cmluZ3MgaGVyZSwgYnV0IG5vdyB3ZSBoYXZlIHNpeC4gV2UgdXNlIHRoZSBuZXctc3R5bGUgc3RyaW5ncyBieSBkZWZhdWx0OlxuICAgIGxldCB0aXRsZVRleHRcbiAgICBpZiAobnVtYmVyT2ZBY3F1aXJlcnMgPiAwKSB7XG4gICAgICB0aXRsZVRleHQgPSB0aGlzLnByb3BzLmkxOG5BcnJheShgZHJvcFBhc3RlSW1wb3J0JHtjYW1lbEZNU2VsZWN0aW9uVHlwZX1gLCB7IGJyb3dzZUZpbGVzLCBicm93c2VGb2xkZXJzLCBicm93c2UgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVUZXh0ID0gdGhpcy5wcm9wcy5pMThuQXJyYXkoYGRyb3BQYXN0ZSR7Y2FtZWxGTVNlbGVjdGlvblR5cGV9YCwgeyBicm93c2VGaWxlcywgYnJvd3NlRm9sZGVycywgYnJvd3NlIH0pXG4gICAgfVxuXG4gICAgLy8gV2UgdXNlIHRoZSBvbGQtc3R5bGUgc3RyaW5ncyBpZiBhdmFpbGFibGU6IHRoaXMgaW1wbGllcyB0aGF0IHRoZSB1c2VyIGhhc1xuICAgIC8vIG1hbnVhbGx5IHNwZWNpZmllZCB0aGVtLCBzbyB0aGV5IHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGUgbmV3LXN0eWxlXG4gICAgLy8gZGVmYXVsdHMuXG4gICAgaWYgKGxvd2VyRk1TZWxlY3Rpb25UeXBlID09PSAnZmlsZXMnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAobnVtYmVyT2ZBY3F1aXJlcnMgPiAwKSB7XG4gICAgICAgICAgdGl0bGVUZXh0ID0gdGhpcy5wcm9wcy5pMThuQXJyYXkoJ2Ryb3BQYXN0ZUltcG9ydCcsIHsgYnJvd3NlIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGl0bGVUZXh0ID0gdGhpcy5wcm9wcy5pMThuQXJyYXkoJ2Ryb3BQYXN0ZScsIHsgYnJvd3NlIH0pXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBJZ25vcmUsIHRoZSBuZXctc3R5bGUgc3RyaW5ncyB3aWxsIGJlIHVzZWQuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZUxvY2FsRmlsZXMpIHtcbiAgICAgIHRpdGxlVGV4dCA9IHRoaXMucHJvcHMuaTE4bignaW1wb3J0RmlsZXMnKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUFkZEZpbGVzLXRpdGxlXCI+XG4gICAgICAgIHt0aXRsZVRleHR9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZW5kZXJBY3F1aXJlciA9IChhY3F1aXJlcikgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkVGFiXCJcbiAgICAgICAgcm9sZT1cInByZXNlbnRhdGlvblwiXG4gICAgICAgIGRhdGEtdXBweS1hY3F1aXJlci1pZD17YWNxdWlyZXIuaWR9XG4gICAgICA+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LURhc2hib2FyZFRhYi1idG5cIlxuICAgICAgICAgIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgIHRhYkluZGV4PXswfVxuICAgICAgICAgIGFyaWEtY29udHJvbHM9e2B1cHB5LURhc2hib2FyZENvbnRlbnQtcGFuZWwtLSR7YWNxdWlyZXIuaWR9YH1cbiAgICAgICAgICBhcmlhLXNlbGVjdGVkPXt0aGlzLnByb3BzLmFjdGl2ZVBpY2tlclBhbmVsLmlkID09PSBhY3F1aXJlci5pZH1cbiAgICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gdGhpcy5wcm9wcy5zaG93UGFuZWwoYWNxdWlyZXIuaWQpfVxuICAgICAgICA+XG4gICAgICAgICAge2FjcXVpcmVyLmljb24oKX1cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkVGFiLW5hbWVcIj57YWNxdWlyZXIubmFtZX08L2Rpdj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZW5kZXJBY3F1aXJlcnMgPSAoYWNxdWlyZXJzLCBkaXNhYmxlTG9jYWxGaWxlcykgPT4ge1xuICAgIC8vIEdyb3VwIGxhc3QgdHdvIGJ1dHRvbnMsIHNvIHdlIGRvbuKAmXQgZW5kIHVwIHdpdGhcbiAgICAvLyBqdXN0IG9uZSBidXR0b24gb24gYSBuZXcgbGluZVxuICAgIGNvbnN0IGFjcXVpcmVyc1dpdGhvdXRMYXN0VHdvID0gWy4uLmFjcXVpcmVyc11cbiAgICBjb25zdCBsYXN0VHdvQWNxdWlyZXJzID0gYWNxdWlyZXJzV2l0aG91dExhc3RUd28uc3BsaWNlKGFjcXVpcmVycy5sZW5ndGggLSAyLCBhY3F1aXJlcnMubGVuZ3RoKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtQWRkRmlsZXMtbGlzdFwiIHJvbGU9XCJ0YWJsaXN0XCI+XG4gICAgICAgIHshZGlzYWJsZUxvY2FsRmlsZXMgJiYgdGhpcy5yZW5kZXJNeURldmljZUFjcXVpcmVyKCl9XG4gICAgICAgIHthY3F1aXJlcnNXaXRob3V0TGFzdFR3by5tYXAoKGFjcXVpcmVyKSA9PiB0aGlzLnJlbmRlckFjcXVpcmVyKGFjcXVpcmVyKSl9XG4gICAgICAgIDxzcGFuIHJvbGU9XCJwcmVzZW50YXRpb25cIiBzdHlsZT1cIndoaXRlLXNwYWNlOiBub3dyYXA7XCI+XG4gICAgICAgICAge2xhc3RUd29BY3F1aXJlcnMubWFwKChhY3F1aXJlcikgPT4gdGhpcy5yZW5kZXJBY3F1aXJlcihhY3F1aXJlcikpfVxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUFkZEZpbGVzXCI+XG4gICAgICAgIHt0aGlzLnJlbmRlckhpZGRlbklucHV0KGZhbHNlLCAocmVmKSA9PiB7IHRoaXMuZmlsZUlucHV0ID0gcmVmIH0pfVxuICAgICAgICB7dGhpcy5yZW5kZXJIaWRkZW5JbnB1dCh0cnVlLCAocmVmKSA9PiB7IHRoaXMuZm9sZGVySW5wdXQgPSByZWYgfSl9XG4gICAgICAgIHt0aGlzLnJlbmRlckRyb3BQYXN0ZUJyb3dzZVRhZ2xpbmUoKX1cbiAgICAgICAge3RoaXMucHJvcHMuYWNxdWlyZXJzLmxlbmd0aCA+IDAgJiYgdGhpcy5yZW5kZXJBY3F1aXJlcnModGhpcy5wcm9wcy5hY3F1aXJlcnMsIHRoaXMucHJvcHMuZGlzYWJsZUxvY2FsRmlsZXMpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUFkZEZpbGVzLWluZm9cIj5cbiAgICAgICAgICB7dGhpcy5wcm9wcy5ub3RlICYmIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtbm90ZVwiPnt0aGlzLnByb3BzLm5vdGV9PC9kaXY+fVxuICAgICAgICAgIHt0aGlzLnByb3BzLnByb3VkbHlEaXNwbGF5UG93ZXJlZEJ5VXBweSAmJiB0aGlzLnJlbmRlclBvd2VyZWRCeVVwcHkodGhpcy5wcm9wcyl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWRkRmlsZXNcbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IEFkZEZpbGVzID0gcmVxdWlyZSgnLi9BZGRGaWxlcycpXG5cbmNvbnN0IEFkZEZpbGVzUGFuZWwgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3VwcHktRGFzaGJvYXJkLUFkZEZpbGVzUGFuZWwnLCBwcm9wcy5jbGFzc05hbWUpfVxuICAgICAgZGF0YS11cHB5LXBhbmVsVHlwZT1cIkFkZEZpbGVzXCJcbiAgICAgIGFyaWEtaGlkZGVuPXtwcm9wcy5zaG93QWRkRmlsZXNQYW5lbH1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC1iYXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtdGl0bGVcIiByb2xlPVwiaGVhZGluZ1wiIGFyaWEtbGV2ZWw9XCIxXCI+XG4gICAgICAgICAge3Byb3BzLmkxOG4oJ2FkZGluZ01vcmVGaWxlcycpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC1iYWNrXCJcbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBvbkNsaWNrPXsoZXYpID0+IHByb3BzLnRvZ2dsZUFkZEZpbGVzUGFuZWwoZmFsc2UpfVxuICAgICAgICA+XG4gICAgICAgICAge3Byb3BzLmkxOG4oJ2JhY2snKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxBZGRGaWxlcyB7Li4ucHJvcHN9IC8+XG4gICAgPC9kaXY+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBZGRGaWxlc1BhbmVsXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBGaWxlTGlzdCA9IHJlcXVpcmUoJy4vRmlsZUxpc3QnKVxuY29uc3QgQWRkRmlsZXMgPSByZXF1aXJlKCcuL0FkZEZpbGVzJylcbmNvbnN0IEFkZEZpbGVzUGFuZWwgPSByZXF1aXJlKCcuL0FkZEZpbGVzUGFuZWwnKVxuY29uc3QgUGlja2VyUGFuZWxDb250ZW50ID0gcmVxdWlyZSgnLi9QaWNrZXJQYW5lbENvbnRlbnQnKVxuY29uc3QgRWRpdG9yUGFuZWwgPSByZXF1aXJlKCcuL0VkaXRvclBhbmVsJylcbmNvbnN0IFBhbmVsVG9wQmFyID0gcmVxdWlyZSgnLi9QaWNrZXJQYW5lbFRvcEJhcicpXG5jb25zdCBGaWxlQ2FyZCA9IHJlcXVpcmUoJy4vRmlsZUNhcmQnKVxuY29uc3QgU2xpZGUgPSByZXF1aXJlKCcuL1NsaWRlJylcbmNvbnN0IGlzRHJhZ0Ryb3BTdXBwb3J0ZWQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaXNEcmFnRHJvcFN1cHBvcnRlZCcpXG5cbi8vIGh0dHA6Ly9kZXYuZWRlbnNwaWVrZXJtYW5uLmNvbS8yMDE2LzAyLzExL2ludHJvZHVjaW5nLWFjY2Vzc2libGUtbW9kYWwtZGlhbG9nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2hvc2gvbWljcm9tb2RhbFxuXG5jb25zdCBXSURUSF9YTCA9IDkwMFxuY29uc3QgV0lEVEhfTEcgPSA3MDBcbmNvbnN0IFdJRFRIX01EID0gNTc2XG5jb25zdCBIRUlHSFRfTUQgPSA0MDBcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBEYXNoYm9hcmQgKHByb3BzKSB7XG4gIGNvbnN0IG5vRmlsZXMgPSBwcm9wcy50b3RhbEZpbGVDb3VudCA9PT0gMFxuICBjb25zdCBpc1NpemVNRCA9IHByb3BzLmNvbnRhaW5lcldpZHRoID4gV0lEVEhfTURcblxuICBjb25zdCB3cmFwcGVyQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyh7XG4gICAgJ3VwcHktUm9vdCc6IHByb3BzLmlzVGFyZ2V0RE9NRWwsXG4gIH0pXG5cbiAgY29uc3QgZGFzaGJvYXJkQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyh7XG4gICAgJ3VwcHktRGFzaGJvYXJkJzogdHJ1ZSxcbiAgICAndXBweS1EYXNoYm9hcmQtLWlzRGlzYWJsZWQnOiBwcm9wcy5kaXNhYmxlZCxcbiAgICAndXBweS1EYXNoYm9hcmQtLWFuaW1hdGVPcGVuQ2xvc2UnOiBwcm9wcy5hbmltYXRlT3BlbkNsb3NlLFxuICAgICd1cHB5LURhc2hib2FyZC0taXNDbG9zaW5nJzogcHJvcHMuaXNDbG9zaW5nLFxuICAgICd1cHB5LURhc2hib2FyZC0taXNEcmFnZ2luZ092ZXInOiBwcm9wcy5pc0RyYWdnaW5nT3ZlcixcbiAgICAndXBweS1EYXNoYm9hcmQtLW1vZGFsJzogIXByb3BzLmlubGluZSxcbiAgICAndXBweS1zaXplLS1tZCc6IHByb3BzLmNvbnRhaW5lcldpZHRoID4gV0lEVEhfTUQsXG4gICAgJ3VwcHktc2l6ZS0tbGcnOiBwcm9wcy5jb250YWluZXJXaWR0aCA+IFdJRFRIX0xHLFxuICAgICd1cHB5LXNpemUtLXhsJzogcHJvcHMuY29udGFpbmVyV2lkdGggPiBXSURUSF9YTCxcbiAgICAndXBweS1zaXplLS1oZWlnaHQtbWQnOiBwcm9wcy5jb250YWluZXJIZWlnaHQgPiBIRUlHSFRfTUQsXG4gICAgJ3VwcHktRGFzaGJvYXJkLS1pc0FkZEZpbGVzUGFuZWxWaXNpYmxlJzogcHJvcHMuc2hvd0FkZEZpbGVzUGFuZWwsXG4gICAgJ3VwcHktRGFzaGJvYXJkLS1pc0lubmVyV3JhcFZpc2libGUnOiBwcm9wcy5hcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZSxcbiAgfSlcblxuICAvLyBJbXBvcnRhbnQ6IGtlZXAgdGhlc2UgaW4gc3luYyB3aXRoIHRoZSBwZXJjZW50IHdpZHRoIHZhbHVlcyBpbiBgc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vaW5kZXguc2Nzc2AuXG4gIGxldCBpdGVtc1BlclJvdyA9IDEgLy8gbW9iaWxlXG4gIGlmIChwcm9wcy5jb250YWluZXJXaWR0aCA+IFdJRFRIX1hMKSB7XG4gICAgaXRlbXNQZXJSb3cgPSA1XG4gIH0gZWxzZSBpZiAocHJvcHMuY29udGFpbmVyV2lkdGggPiBXSURUSF9MRykge1xuICAgIGl0ZW1zUGVyUm93ID0gNFxuICB9IGVsc2UgaWYgKHByb3BzLmNvbnRhaW5lcldpZHRoID4gV0lEVEhfTUQpIHtcbiAgICBpdGVtc1BlclJvdyA9IDNcbiAgfVxuXG4gIGNvbnN0IHNob3dGaWxlTGlzdCA9IHByb3BzLnNob3dTZWxlY3RlZEZpbGVzICYmICFub0ZpbGVzXG5cbiAgY29uc3QgbnVtYmVyT2ZGaWxlc0ZvclJlY292ZXJ5ID0gcHJvcHMucmVjb3ZlcmVkU3RhdGUgPyBPYmplY3Qua2V5cyhwcm9wcy5yZWNvdmVyZWRTdGF0ZS5maWxlcykubGVuZ3RoIDogbnVsbFxuICBjb25zdCBudW1iZXJPZkdob3N0cyA9IHByb3BzLmZpbGVzID8gT2JqZWN0LmtleXMocHJvcHMuZmlsZXMpLmZpbHRlcigoZmlsZUlEKSA9PiBwcm9wcy5maWxlc1tmaWxlSURdLmlzR2hvc3QpLmxlbmd0aCA6IG51bGxcblxuICBjb25zdCByZW5kZXJSZXN0b3JlZFRleHQgPSAoKSA9PiB7XG4gICAgaWYgKG51bWJlck9mR2hvc3RzID4gMCkge1xuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3JlY292ZXJlZFhGaWxlcycsIHtcbiAgICAgICAgc21hcnRfY291bnQ6IG51bWJlck9mR2hvc3RzLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHMuaTE4bigncmVjb3ZlcmVkQWxsRmlsZXMnKVxuICB9XG5cbiAgY29uc3QgZGFzaGJvYXJkID0gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17ZGFzaGJvYXJkQ2xhc3NOYW1lfVxuICAgICAgZGF0YS11cHB5LXRoZW1lPXtwcm9wcy50aGVtZX1cbiAgICAgIGRhdGEtdXBweS1udW0tYWNxdWlyZXJzPXtwcm9wcy5hY3F1aXJlcnMubGVuZ3RofVxuICAgICAgZGF0YS11cHB5LWRyYWctZHJvcC1zdXBwb3J0ZWQ9eyFwcm9wcy5kaXNhYmxlTG9jYWxGaWxlcyAmJiBpc0RyYWdEcm9wU3VwcG9ydGVkKCl9XG4gICAgICBhcmlhLWhpZGRlbj17cHJvcHMuaW5saW5lID8gJ2ZhbHNlJyA6IHByb3BzLmlzSGlkZGVufVxuICAgICAgYXJpYS1kaXNhYmxlZD17cHJvcHMuZGlzYWJsZWR9XG4gICAgICBhcmlhLWxhYmVsPXshcHJvcHMuaW5saW5lID8gcHJvcHMuaTE4bignZGFzaGJvYXJkV2luZG93VGl0bGUnKSA6IHByb3BzLmkxOG4oJ2Rhc2hib2FyZFRpdGxlJyl9XG4gICAgICBvblBhc3RlPXtwcm9wcy5oYW5kbGVQYXN0ZX1cbiAgICAgIG9uRHJhZ092ZXI9e3Byb3BzLmhhbmRsZURyYWdPdmVyfVxuICAgICAgb25EcmFnTGVhdmU9e3Byb3BzLmhhbmRsZURyYWdMZWF2ZX1cbiAgICAgIG9uRHJvcD17cHJvcHMuaGFuZGxlRHJvcH1cbiAgICA+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLW92ZXJsYXlcIlxuICAgICAgICB0YWJJbmRleD17LTF9XG4gICAgICAgIG9uQ2xpY2s9e3Byb3BzLmhhbmRsZUNsaWNrT3V0c2lkZX1cbiAgICAgIC8+XG5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtaW5uZXJcIlxuICAgICAgICBhcmlhLW1vZGFsPXshcHJvcHMuaW5saW5lICYmICd0cnVlJ31cbiAgICAgICAgcm9sZT17IXByb3BzLmlubGluZSAmJiAnZGlhbG9nJ31cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICB3aWR0aDogcHJvcHMuaW5saW5lICYmIHByb3BzLndpZHRoID8gcHJvcHMud2lkdGggOiAnJyxcbiAgICAgICAgICBoZWlnaHQ6IHByb3BzLmlubGluZSAmJiBwcm9wcy5oZWlnaHQgPyBwcm9wcy5oZWlnaHQgOiAnJyxcbiAgICAgICAgfX1cbiAgICAgID5cblxuICAgICAgICB7IXByb3BzLmlubGluZSA/IChcbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1EYXNoYm9hcmQtY2xvc2VcIlxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBhcmlhLWxhYmVsPXtwcm9wcy5pMThuKCdjbG9zZU1vZGFsJyl9XG4gICAgICAgICAgICB0aXRsZT17cHJvcHMuaTE4bignY2xvc2VNb2RhbCcpfVxuICAgICAgICAgICAgb25DbGljaz17cHJvcHMuY2xvc2VNb2RhbH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApIDogbnVsbH1cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLWlubmVyV3JhcFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtZHJvcEZpbGVzSGVyZUhpbnRcIj5cbiAgICAgICAgICAgIHtwcm9wcy5pMThuKCdkcm9wSGludCcpfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAge3Nob3dGaWxlTGlzdCAmJiA8UGFuZWxUb3BCYXIgey4uLnByb3BzfSAvPn1cblxuICAgICAgICAgIHtudW1iZXJPZkZpbGVzRm9yUmVjb3ZlcnkgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1zZXJ2aWNlTXNnXCI+XG4gICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtc2VydmljZU1zZy1pY29uXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjIxXCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDE5XCI+XG4gICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAgLTEpXCIgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTIuODU3IDEuNDNsMTAuMjM0IDE3LjA1NkExIDEgMCAwMTIyLjIzNCAyMEgxLjc2NmExIDEgMCAwMS0uODU3LTEuNTE0TDExLjE0MyAxLjQyOWExIDEgMCAwMTEuNzE0IDB6XCIgZmlsbD1cIiNGRkQzMDBcIiAvPlxuICAgICAgICAgICAgICAgICAgPHBhdGggZmlsbD1cIiMwMDBcIiBkPVwiTTExIDZoMmwtLjMgOGgtMS40elwiIC8+XG4gICAgICAgICAgICAgICAgICA8Y2lyY2xlIGZpbGw9XCIjMDAwXCIgY3g9XCIxMlwiIGN5PVwiMTdcIiByPVwiMVwiIC8+XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgPHN0cm9uZyBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1zZXJ2aWNlTXNnLXRpdGxlXCI+XG4gICAgICAgICAgICAgICAge3Byb3BzLmkxOG4oJ3Nlc3Npb25SZXN0b3JlZCcpfVxuICAgICAgICAgICAgICA8L3N0cm9uZz5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkLXNlcnZpY2VNc2ctdGV4dFwiPlxuICAgICAgICAgICAgICAgIHtyZW5kZXJSZXN0b3JlZFRleHQoKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuXG4gICAgICAgICAge3Nob3dGaWxlTGlzdCA/IChcbiAgICAgICAgICAgIDxGaWxlTGlzdFxuICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICAgIGl0ZW1zUGVyUm93PXtpdGVtc1BlclJvd31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxBZGRGaWxlcyB7Li4ucHJvcHN9IGlzU2l6ZU1EPXtpc1NpemVNRH0gLz5cbiAgICAgICAgICApfVxuXG4gICAgICAgICAgPFNsaWRlPlxuICAgICAgICAgICAge3Byb3BzLnNob3dBZGRGaWxlc1BhbmVsID8gPEFkZEZpbGVzUGFuZWwga2V5PVwiQWRkRmlsZXNcIiB7Li4ucHJvcHN9IGlzU2l6ZU1EPXtpc1NpemVNRH0gLz4gOiBudWxsfVxuICAgICAgICAgIDwvU2xpZGU+XG5cbiAgICAgICAgICA8U2xpZGU+XG4gICAgICAgICAgICB7cHJvcHMuZmlsZUNhcmRGb3IgPyA8RmlsZUNhcmQga2V5PVwiRmlsZUNhcmRcIiB7Li4ucHJvcHN9IC8+IDogbnVsbH1cbiAgICAgICAgICA8L1NsaWRlPlxuXG4gICAgICAgICAgPFNsaWRlPlxuICAgICAgICAgICAge3Byb3BzLmFjdGl2ZVBpY2tlclBhbmVsID8gPFBpY2tlclBhbmVsQ29udGVudCBrZXk9XCJQaWNrZXJcIiB7Li4ucHJvcHN9IC8+IDogbnVsbH1cbiAgICAgICAgICA8L1NsaWRlPlxuXG4gICAgICAgICAgPFNsaWRlPlxuICAgICAgICAgICAge3Byb3BzLnNob3dGaWxlRWRpdG9yID8gPEVkaXRvclBhbmVsIGtleT1cIkVkaXRvclwiIHsuLi5wcm9wc30gLz4gOiBudWxsfVxuICAgICAgICAgIDwvU2xpZGU+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLXByb2dyZXNzaW5kaWNhdG9yc1wiPlxuICAgICAgICAgICAge3Byb3BzLnByb2dyZXNzaW5kaWNhdG9ycy5tYXAoKHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuZ2V0UGx1Z2luKHRhcmdldC5pZCkucmVuZGVyKHByb3BzLnN0YXRlKVxuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcblxuICByZXR1cm4gKFxuICAgIC8vIFdyYXAgaXQgZm9yIFJUTCBsYW5ndWFnZSBzdXBwb3J0XG4gICAgPGRpdiBjbGFzc05hbWU9e3dyYXBwZXJDbGFzc05hbWV9IGRpcj17cHJvcHMuZGlyZWN0aW9ufT5cbiAgICAgIHtkYXNoYm9hcmR9XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcblxuZnVuY3Rpb24gRWRpdG9yUGFuZWwgKHByb3BzKSB7XG4gIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVzW3RoaXMucHJvcHMuZmlsZUNhcmRGb3JdXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3VwcHktRGFzaGJvYXJkQ29udGVudC1wYW5lbCcsIHByb3BzLmNsYXNzTmFtZSl9XG4gICAgICByb2xlPVwidGFicGFuZWxcIlxuICAgICAgZGF0YS11cHB5LXBhbmVsVHlwZT1cIkZpbGVFZGl0b3JcIlxuICAgICAgaWQ9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtcGFuZWwtLWVkaXRvclwiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXRpdGxlXCIgcm9sZT1cImhlYWRpbmdcIiBhcmlhLWxldmVsPVwiMVwiPlxuICAgICAgICAgIHtwcm9wcy5pMThuQXJyYXkoJ2VkaXRpbmcnLCB7XG4gICAgICAgICAgICBmaWxlOiA8c3BhbiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtdGl0bGVGaWxlXCI+e2ZpbGUubWV0YSA/IGZpbGUubWV0YS5uYW1lIDogZmlsZS5uYW1lfTwvc3Bhbj4sXG4gICAgICAgICAgfSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhY2tcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9e3Byb3BzLmhpZGVBbGxQYW5lbHN9XG4gICAgICAgID5cbiAgICAgICAgICB7cHJvcHMuaTE4bignY2FuY2VsJyl9XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXNhdmVcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9e3Byb3BzLnNhdmVGaWxlRWRpdG9yfVxuICAgICAgICA+XG4gICAgICAgICAge3Byb3BzLmkxOG4oJ3NhdmUnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXBhbmVsQm9keVwiPlxuICAgICAgICB7cHJvcHMuZWRpdG9ycy5tYXAoKHRhcmdldCkgPT4ge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5nZXRQbHVnaW4odGFyZ2V0LmlkKS5yZW5kZXIocHJvcHMuc3RhdGUpXG4gICAgICAgIH0pfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFZGl0b3JQYW5lbFxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBnZXRGaWxlVHlwZUljb24gPSByZXF1aXJlKCcuLi8uLi91dGlscy9nZXRGaWxlVHlwZUljb24nKVxuY29uc3QgaWdub3JlRXZlbnQgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZ25vcmVFdmVudC5qcycpXG5jb25zdCBGaWxlUHJldmlldyA9IHJlcXVpcmUoJy4uL0ZpbGVQcmV2aWV3JylcblxuY2xhc3MgRmlsZUNhcmQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcblxuICAgIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVzW3RoaXMucHJvcHMuZmlsZUNhcmRGb3JdXG4gICAgY29uc3QgbWV0YUZpZWxkcyA9IHRoaXMuZ2V0TWV0YUZpZWxkcygpIHx8IFtdXG5cbiAgICBjb25zdCBzdG9yZWRNZXRhRGF0YSA9IHt9XG4gICAgbWV0YUZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgc3RvcmVkTWV0YURhdGFbZmllbGQuaWRdID0gZmlsZS5tZXRhW2ZpZWxkLmlkXSB8fCAnJ1xuICAgIH0pXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZm9ybVN0YXRlOiBzdG9yZWRNZXRhRGF0YSxcbiAgICB9XG4gIH1cblxuICBzYXZlT25FbnRlciA9IChldikgPT4ge1xuICAgIGlmIChldi5rZXlDb2RlID09PSAxMykge1xuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVzW3RoaXMucHJvcHMuZmlsZUNhcmRGb3JdXG4gICAgICB0aGlzLnByb3BzLnNhdmVGaWxlQ2FyZCh0aGlzLnN0YXRlLmZvcm1TdGF0ZSwgZmlsZS5pZClcbiAgICB9XG4gIH1cblxuICB1cGRhdGVNZXRhID0gKG5ld1ZhbCwgbmFtZSkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZm9ybVN0YXRlOiB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUuZm9ybVN0YXRlLFxuICAgICAgICBbbmFtZV06IG5ld1ZhbCxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZVNhdmUgPSAoKSA9PiB7XG4gICAgY29uc3QgZmlsZUlEID0gdGhpcy5wcm9wcy5maWxlQ2FyZEZvclxuICAgIHRoaXMucHJvcHMuc2F2ZUZpbGVDYXJkKHRoaXMuc3RhdGUuZm9ybVN0YXRlLCBmaWxlSUQpXG4gIH1cblxuICBoYW5kbGVDYW5jZWwgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy50b2dnbGVGaWxlQ2FyZChmYWxzZSlcbiAgfVxuXG4gIHJlbmRlck1ldGFGaWVsZHMgPSAoKSA9PiB7XG4gICAgY29uc3QgbWV0YUZpZWxkcyA9IHRoaXMuZ2V0TWV0YUZpZWxkcygpIHx8IFtdXG4gICAgY29uc3QgZmllbGRDU1NDbGFzc2VzID0ge1xuICAgICAgdGV4dDogJ3VwcHktdS1yZXNldCB1cHB5LWMtdGV4dElucHV0IHVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWlucHV0JyxcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YUZpZWxkcy5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICBjb25zdCBpZCA9IGB1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1pbnB1dC0ke2ZpZWxkLmlkfWBcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxmaWVsZHNldCBrZXk9e2ZpZWxkLmlkfSBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1maWVsZHNldFwiPlxuICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1sYWJlbFwiIGh0bWxGb3I9e2lkfT57ZmllbGQubmFtZX08L2xhYmVsPlxuICAgICAgICAgIHtmaWVsZC5yZW5kZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBmaWVsZC5yZW5kZXIoe1xuICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5mb3JtU3RhdGVbZmllbGQuaWRdLFxuICAgICAgICAgICAgICBvbkNoYW5nZTogKG5ld1ZhbCkgPT4gdGhpcy51cGRhdGVNZXRhKG5ld1ZhbCwgZmllbGQuaWQpLFxuICAgICAgICAgICAgICBmaWVsZENTU0NsYXNzZXMsXG4gICAgICAgICAgICB9LCBoKVxuICAgICAgICAgICAgOiAoXG4gICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17ZmllbGRDU1NDbGFzc2VzLnRleHR9XG4gICAgICAgICAgICAgICAgaWQ9e2lkfVxuICAgICAgICAgICAgICAgIHR5cGU9e2ZpZWxkLnR5cGUgfHwgJ3RleHQnfVxuICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmZvcm1TdGF0ZVtmaWVsZC5pZF19XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2ZpZWxkLnBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgIG9uS2V5VXA9e3RoaXMuc2F2ZU9uRW50ZXJ9XG4gICAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLnNhdmVPbkVudGVyfVxuICAgICAgICAgICAgICAgIG9uS2V5UHJlc3M9e3RoaXMuc2F2ZU9uRW50ZXJ9XG4gICAgICAgICAgICAgICAgb25JbnB1dD17ZXYgPT4gdGhpcy51cGRhdGVNZXRhKGV2LnRhcmdldC52YWx1ZSwgZmllbGQuaWQpfVxuICAgICAgICAgICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICl9XG4gICAgICAgIDwvZmllbGRzZXQ+XG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIGdldE1ldGFGaWVsZHMgKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5wcm9wcy5tZXRhRmllbGRzID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHRoaXMucHJvcHMubWV0YUZpZWxkcyh0aGlzLnByb3BzLmZpbGVzW3RoaXMucHJvcHMuZmlsZUNhcmRGb3JdKVxuICAgICAgOiB0aGlzLnByb3BzLm1ldGFGaWVsZHNcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMucHJvcHMuZmlsZXNbdGhpcy5wcm9wcy5maWxlQ2FyZEZvcl1cbiAgICBjb25zdCBzaG93RWRpdEJ1dHRvbiA9IHRoaXMucHJvcHMuY2FuRWRpdEZpbGUoZmlsZSlcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcygndXBweS1EYXNoYm9hcmQtRmlsZUNhcmQnLCB0aGlzLnByb3BzLmNsYXNzTmFtZSl9XG4gICAgICAgIGRhdGEtdXBweS1wYW5lbFR5cGU9XCJGaWxlQ2FyZFwiXG4gICAgICAgIG9uRHJhZ092ZXI9e2lnbm9yZUV2ZW50fVxuICAgICAgICBvbkRyYWdMZWF2ZT17aWdub3JlRXZlbnR9XG4gICAgICAgIG9uRHJvcD17aWdub3JlRXZlbnR9XG4gICAgICAgIG9uUGFzdGU9e2lnbm9yZUV2ZW50fVxuICAgICAgPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC1iYXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC10aXRsZVwiIHJvbGU9XCJoZWFkaW5nXCIgYXJpYS1sZXZlbD1cIjFcIj5cbiAgICAgICAgICAgIHt0aGlzLnByb3BzLmkxOG5BcnJheSgnZWRpdGluZycsIHtcbiAgICAgICAgICAgICAgZmlsZTogPHNwYW4gY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXRpdGxlRmlsZVwiPntmaWxlLm1ldGEgPyBmaWxlLm1ldGEubmFtZSA6IGZpbGUubmFtZX08L3NwYW4+LFxuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhY2tcIlxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICB0aXRsZT17dGhpcy5wcm9wcy5pMThuKCdmaW5pc2hFZGl0aW5nRmlsZScpfVxuICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDYW5jZWx9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge3RoaXMucHJvcHMuaTE4bignY2FuY2VsJyl9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtaW5uZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLXByZXZpZXdcIiBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6IGdldEZpbGVUeXBlSWNvbihmaWxlLnR5cGUpLmNvbG9yIH19PlxuICAgICAgICAgICAgPEZpbGVQcmV2aWV3IGZpbGU9e2ZpbGV9IC8+XG4gICAgICAgICAgICB7c2hvd0VkaXRCdXR0b25cbiAgICAgICAgICAgICAgJiYgKFxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtZWRpdFwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gdGhpcy5wcm9wcy5vcGVuRmlsZUVkaXRvcihmaWxlKX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmkxOG4oJ2VkaXRGaWxlJyl9XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1pbmZvXCI+XG4gICAgICAgICAgICB7dGhpcy5yZW5kZXJNZXRhRmllbGRzKCl9XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWFjdGlvbnNcIj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1jLWJ0bi1wcmltYXJ5IHVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWFjdGlvbnNCdG5cIlxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVTYXZlfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5pMThuKCdzYXZlQ2hhbmdlcycpfVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tbGluayB1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1hY3Rpb25zQnRuXCJcbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2FuY2VsfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGVDYXJkXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjb3B5VG9DbGlwYm9hcmQgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy9jb3B5VG9DbGlwYm9hcmQnKVxuXG5mdW5jdGlvbiBFZGl0QnV0dG9uICh7XG4gIGZpbGUsXG4gIHVwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlLFxuICBtZXRhRmllbGRzLFxuICBjYW5FZGl0RmlsZSxcbiAgaTE4bixcbiAgb25DbGljayxcbn0pIHtcbiAgaWYgKFxuICAgICghdXBsb2FkSW5Qcm9ncmVzc09yQ29tcGxldGUgJiYgbWV0YUZpZWxkcyAmJiBtZXRhRmllbGRzLmxlbmd0aCA+IDApXG4gICAgfHwgKCF1cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZSAmJiBjYW5FZGl0RmlsZShmaWxlKSlcbiAgKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uIHVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uLS1lZGl0XCJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGFyaWEtbGFiZWw9e2Ake2kxOG4oJ2VkaXRGaWxlJyl9ICR7ZmlsZS5tZXRhLm5hbWV9YH1cbiAgICAgICAgdGl0bGU9e2kxOG4oJ2VkaXRGaWxlJyl9XG4gICAgICAgIG9uQ2xpY2s9eygpID0+IG9uQ2xpY2soKX1cbiAgICAgID5cbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCIgdmlld0JveD1cIjAgMCAxNCAxNFwiPlxuICAgICAgICAgIDxnIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk0xLjUgMTAuNzkzaDIuNzkzQTEgMSAwIDAgMCA1IDEwLjVMMTEuNSA0YTEgMSAwIDAgMCAwLTEuNDE0TDkuNzA3Ljc5M2ExIDEgMCAwIDAtMS40MTQgMGwtNi41IDYuNUExIDEgMCAwIDAgMS41IDh2Mi43OTN6bTEtMVY4TDkgMS41bDEuNzkzIDEuNzkzLTYuNSA2LjVIMi41elwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICAgICAgICA8cmVjdCB4PVwiMVwiIHk9XCIxMi4yOTNcIiB3aWR0aD1cIjExXCIgaGVpZ2h0PVwiMVwiIHJ4PVwiLjVcIiAvPlxuICAgICAgICAgICAgPHBhdGggZmlsbFJ1bGU9XCJub256ZXJvXCIgZD1cIk02Ljc5MyAyLjVMOS41IDUuMjA3bC43MDctLjcwN0w3LjUgMS43OTN6XCIgLz5cbiAgICAgICAgICA8L2c+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9idXR0b24+XG4gICAgKVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIFJlbW92ZUJ1dHRvbiAoeyBpMThuLCBvbkNsaWNrIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1EYXNoYm9hcmQtSXRlbS1hY3Rpb24gdXBweS1EYXNoYm9hcmQtSXRlbS1hY3Rpb24tLXJlbW92ZVwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3JlbW92ZUZpbGUnKX1cbiAgICAgIHRpdGxlPXtpMThuKCdyZW1vdmVGaWxlJyl9XG4gICAgICBvbkNsaWNrPXsoKSA9PiBvbkNsaWNrKCl9XG4gICAgPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxOFwiIGhlaWdodD1cIjE4XCIgdmlld0JveD1cIjAgMCAxOCAxOFwiPlxuICAgICAgICA8cGF0aCBkPVwiTTkgMEM0LjAzNCAwIDAgNC4wMzQgMCA5czQuMDM0IDkgOSA5IDktNC4wMzQgOS05LTQuMDM0LTktOS05elwiIC8+XG4gICAgICAgIDxwYXRoIGZpbGw9XCIjRkZGXCIgZD1cIk0xMyAxMi4yMjJsLS43NzguNzc4TDkgOS43NzggNS43NzggMTMgNSAxMi4yMjIgOC4yMjIgOSA1IDUuNzc4IDUuNzc4IDUgOSA4LjIyMiAxMi4yMjIgNWwuNzc4Ljc3OEw5Ljc3OCA5elwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5jb25zdCBjb3B5TGlua1RvQ2xpcGJvYXJkID0gKGV2ZW50LCBwcm9wcykgPT4ge1xuICBjb3B5VG9DbGlwYm9hcmQocHJvcHMuZmlsZS51cGxvYWRVUkwsIHByb3BzLmkxOG4oJ2NvcHlMaW5rVG9DbGlwYm9hcmRGYWxsYmFjaycpKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHByb3BzLmxvZygnTGluayBjb3BpZWQgdG8gY2xpcGJvYXJkLicpXG4gICAgICBwcm9wcy5pbmZvKHByb3BzLmkxOG4oJ2NvcHlMaW5rVG9DbGlwYm9hcmRTdWNjZXNzJyksICdpbmZvJywgMzAwMClcbiAgICB9KVxuICAgIC5jYXRjaChwcm9wcy5sb2cpXG4gICAgLy8gYXZvaWQgbG9zaW5nIGZvY3VzXG4gICAgLnRoZW4oKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KSlcbn1cblxuZnVuY3Rpb24gQ29weUxpbmtCdXR0b24gKHByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uIHVwcHktRGFzaGJvYXJkLUl0ZW0tYWN0aW9uLS1jb3B5TGlua1wiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ2NvcHlMaW5rJyl9XG4gICAgICB0aXRsZT17cHJvcHMuaTE4bignY29weUxpbmsnKX1cbiAgICAgIG9uQ2xpY2s9eyhldmVudCkgPT4gY29weUxpbmtUb0NsaXBib2FyZChldmVudCwgcHJvcHMpfVxuICAgID5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHZpZXdCb3g9XCIwIDAgMTQgMTJcIj5cbiAgICAgICAgPHBhdGggZD1cIk03Ljk0IDcuNzAzYTIuNjEzIDIuNjEzIDAgMCAxLS42MjYgMi42ODFsLS44NTIuODUxYTIuNTk3IDIuNTk3IDAgMCAxLTEuODQ5Ljc2NkEyLjYxNiAyLjYxNiAwIDAgMSAyLjc2NCA3LjU0bC44NTItLjg1MmEyLjU5NiAyLjU5NiAwIDAgMSAyLjY5LS42MjVMNS4yNjcgNy4wOTlhMS40NCAxLjQ0IDAgMCAwLS44MzMuNDA3bC0uODUyLjg1MWExLjQ1OCAxLjQ1OCAwIDAgMCAxLjAzIDIuNDg2Yy4zOSAwIC43NTUtLjE1MiAxLjAzLS40MjZsLjg1Mi0uODUyYy4yMzEtLjIzMS4zNjMtLjUyMi40MDYtLjgyNGwxLjA0LTEuMDM4em00LjI5NS01LjkzN0EyLjU5NiAyLjU5NiAwIDAgMCAxMC4zODcgMWMtLjY5OCAwLTEuMzU1LjI3Mi0xLjg0OS43NjZsLS44NTIuODUxYTIuNjE0IDIuNjE0IDAgMCAwLS42MjQgMi42ODhsMS4wMzYtMS4wMzZjLjA0MS0uMzA0LjE3My0uNi40MDctLjgzM2wuODUyLS44NTJjLjI3NS0uMjc1LjY0LS40MjYgMS4wMy0uNDI2YTEuNDU4IDEuNDU4IDAgMCAxIDEuMDMgMi40ODZsLS44NTIuODUxYTEuNDQyIDEuNDQyIDAgMCAxLS44MjQuNDA2bC0xLjA0IDEuMDRhMi41OTYgMi41OTYgMCAwIDAgMi42ODMtLjYyOGwuODUxLS44NWEyLjYxNiAyLjYxNiAwIDAgMCAwLTMuNjk3em0tNi44OCA2Ljg4M2EuNTc3LjU3NyAwIDAgMCAuODIgMGwzLjQ3NC0zLjQ3NGEuNTc5LjU3OSAwIDEgMC0uODE5LS44Mkw1LjM1NSA3LjgzYS41NzkuNTc5IDAgMCAwIDAgLjgxOXpcIiAvPlxuICAgICAgPC9zdmc+XG4gICAgPC9idXR0b24+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBCdXR0b25zIChwcm9wcykge1xuICBjb25zdCB7XG4gICAgZmlsZSxcbiAgICB1cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZSxcbiAgICBjYW5FZGl0RmlsZSxcbiAgICBtZXRhRmllbGRzLFxuICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0LFxuICAgIHNob3dSZW1vdmVCdXR0b24sXG4gICAgaTE4bixcbiAgICByZW1vdmVGaWxlLFxuICAgIHRvZ2dsZUZpbGVDYXJkLFxuICAgIG9wZW5GaWxlRWRpdG9yLFxuICAgIGxvZyxcbiAgICBpbmZvLFxuICB9ID0gcHJvcHNcblxuICBjb25zdCBlZGl0QWN0aW9uID0gKCkgPT4ge1xuICAgIGlmIChtZXRhRmllbGRzICYmIG1ldGFGaWVsZHMubGVuZ3RoID4gMCkge1xuICAgICAgdG9nZ2xlRmlsZUNhcmQodHJ1ZSwgZmlsZS5pZClcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlbkZpbGVFZGl0b3IoZmlsZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1hY3Rpb25XcmFwcGVyXCI+XG4gICAgICA8RWRpdEJ1dHRvblxuICAgICAgICBpMThuPXtpMThufVxuICAgICAgICBmaWxlPXtmaWxlfVxuICAgICAgICB1cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZT17dXBsb2FkSW5Qcm9ncmVzc09yQ29tcGxldGV9XG4gICAgICAgIGNhbkVkaXRGaWxlPXtjYW5FZGl0RmlsZX1cbiAgICAgICAgbWV0YUZpZWxkcz17bWV0YUZpZWxkc31cbiAgICAgICAgb25DbGljaz17ZWRpdEFjdGlvbn1cbiAgICAgIC8+XG4gICAgICB7c2hvd0xpbmtUb0ZpbGVVcGxvYWRSZXN1bHQgJiYgZmlsZS51cGxvYWRVUkwgPyAoXG4gICAgICAgIDxDb3B5TGlua0J1dHRvblxuICAgICAgICAgIGZpbGU9e2ZpbGV9XG4gICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICBpbmZvPXtpbmZvfVxuICAgICAgICAgIGxvZz17bG9nfVxuICAgICAgICAvPlxuICAgICAgKSA6IG51bGx9XG4gICAgICB7c2hvd1JlbW92ZUJ1dHRvbiA/IChcbiAgICAgICAgPFJlbW92ZUJ1dHRvblxuICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgaW5mbz17cHJvcHMuaW5mb31cbiAgICAgICAgICBsb2c9e3Byb3BzLmxvZ31cbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiByZW1vdmVGaWxlKGZpbGUuaWQsICdyZW1vdmVkLWJ5LXVzZXInKX1cbiAgICAgICAgLz5cbiAgICAgICkgOiBudWxsfVxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBwcmV0dGllckJ5dGVzID0gcmVxdWlyZSgnQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzJylcbmNvbnN0IHRydW5jYXRlU3RyaW5nID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3RydW5jYXRlU3RyaW5nJylcblxuY29uc3QgcmVuZGVyQWNxdWlyZXJJY29uID0gKGFjcXVpcmVyLCBwcm9wcykgPT4gKFxuICA8c3BhbiB0aXRsZT17cHJvcHMuaTE4bignZmlsZVNvdXJjZScsIHsgbmFtZTogYWNxdWlyZXIubmFtZSB9KX0+XG4gICAge2FjcXVpcmVyLmljb24oKX1cbiAgPC9zcGFuPlxuKVxuXG5jb25zdCByZW5kZXJGaWxlTmFtZSA9IChwcm9wcykgPT4ge1xuICAvLyBUYWtlIHVwIGF0IG1vc3QgMiBsaW5lcyBvbiBhbnkgc2NyZWVuXG4gIGxldCBtYXhOYW1lTGVuZ3RoXG4gIC8vIEZvciB2ZXJ5IHNtYWxsIG1vYmlsZSBzY3JlZW5zXG4gIGlmIChwcm9wcy5jb250YWluZXJXaWR0aCA8PSAzNTIpIHtcbiAgICBtYXhOYW1lTGVuZ3RoID0gMzVcbiAgLy8gRm9yIHJlZ3VsYXIgbW9iaWxlIHNjcmVlbnNcbiAgfSBlbHNlIGlmIChwcm9wcy5jb250YWluZXJXaWR0aCA8PSA1NzYpIHtcbiAgICBtYXhOYW1lTGVuZ3RoID0gNjBcbiAgLy8gRm9yIGRlc2t0b3BzXG4gIH0gZWxzZSB7XG4gICAgbWF4TmFtZUxlbmd0aCA9IDMwXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1uYW1lXCIgdGl0bGU9e3Byb3BzLmZpbGUubWV0YS5uYW1lfT5cbiAgICAgIHt0cnVuY2F0ZVN0cmluZyhwcm9wcy5maWxlLm1ldGEubmFtZSwgbWF4TmFtZUxlbmd0aCl9XG4gICAgPC9kaXY+XG4gIClcbn1cblxuY29uc3QgcmVuZGVyRmlsZVNpemUgPSAocHJvcHMpID0+IChcbiAgcHJvcHMuZmlsZS5zaXplXG4gICAgJiYgKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1zdGF0dXNTaXplXCI+XG4gICAgICB7cHJldHRpZXJCeXRlcyhwcm9wcy5maWxlLnNpemUpfVxuICAgIDwvZGl2PlxuICAgIClcbilcblxuY29uc3QgUmVTZWxlY3RCdXR0b24gPSAocHJvcHMpID0+IChcbiAgcHJvcHMuZmlsZS5pc0dob3N0XG4gICAgJiYgKFxuICAgICAgPHNwYW4+XG4gICAgICAgIHsnIFxcdTIwMjIgJ31cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktRGFzaGJvYXJkLUl0ZW0tcmVTZWxlY3RcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9e3Byb3BzLnRvZ2dsZUFkZEZpbGVzUGFuZWx9XG4gICAgICAgID5cbiAgICAgICAgICB7cHJvcHMuaTE4bigncmVTZWxlY3QnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L3NwYW4+XG4gICAgKVxuKVxuXG5jb25zdCBFcnJvckJ1dHRvbiA9ICh7IGZpbGUsIG9uQ2xpY2sgfSkgPT4ge1xuICBpZiAoZmlsZS5lcnJvcikge1xuICAgIHJldHVybiAoXG4gICAgICA8c3BhblxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLWVycm9yRGV0YWlsc1wiXG4gICAgICAgIGFyaWEtbGFiZWw9e2ZpbGUuZXJyb3J9XG4gICAgICAgIGRhdGEtbWljcm90aXAtcG9zaXRpb249XCJib3R0b21cIlxuICAgICAgICBkYXRhLW1pY3JvdGlwLXNpemU9XCJtZWRpdW1cIlxuICAgICAgICByb2xlPVwidG9vbHRpcFwiXG4gICAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICA+XG4gICAgICAgID9cbiAgICAgIDwvc3Bhbj5cbiAgICApXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGaWxlSW5mbyAocHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tZmlsZUluZm9cIiBkYXRhLXVwcHktZmlsZS1zb3VyY2U9e3Byb3BzLmZpbGUuc291cmNlfT5cbiAgICAgIHtyZW5kZXJGaWxlTmFtZShwcm9wcyl9XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tc3RhdHVzXCI+XG4gICAgICAgIHtyZW5kZXJGaWxlU2l6ZShwcm9wcyl9XG4gICAgICAgIHtSZVNlbGVjdEJ1dHRvbihwcm9wcyl9XG4gICAgICAgIDxFcnJvckJ1dHRvblxuICAgICAgICAgIGZpbGU9e3Byb3BzLmZpbGV9XG4gICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgYWxlcnQocHJvcHMuZmlsZS5lcnJvcilcbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IEZpbGVQcmV2aWV3ID0gcmVxdWlyZSgnLi4vLi4vRmlsZVByZXZpZXcnKVxuY29uc3QgZ2V0RmlsZVR5cGVJY29uID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvZ2V0RmlsZVR5cGVJY29uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGaWxlUHJldmlld0FuZExpbmsgKHByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3SW5uZXJXcmFwXCJcbiAgICAgIHN0eWxlPXt7IGJhY2tncm91bmRDb2xvcjogZ2V0RmlsZVR5cGVJY29uKHByb3BzLmZpbGUudHlwZSkuY29sb3IgfX1cbiAgICA+XG4gICAgICB7XG4gICAgICAgIHByb3BzLnNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0XG4gICAgICAgICYmIHByb3BzLmZpbGUudXBsb2FkVVJMXG4gICAgICAgICAgJiYgKFxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByZXZpZXdMaW5rXCJcbiAgICAgICAgICAgIGhyZWY9e3Byb3BzLmZpbGUudXBsb2FkVVJMfVxuICAgICAgICAgICAgcmVsPVwibm9yZWZlcnJlciBub29wZW5lclwiXG4gICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgYXJpYS1sYWJlbD17cHJvcHMuZmlsZS5tZXRhLm5hbWV9XG4gICAgICAgICAgLz5cbiAgICAgICAgICApXG4gICAgICB9XG4gICAgICA8RmlsZVByZXZpZXcgZmlsZT17cHJvcHMuZmlsZX0gLz5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5mdW5jdGlvbiBvblBhdXNlUmVzdW1lQ2FuY2VsUmV0cnkgKHByb3BzKSB7XG4gIGlmIChwcm9wcy5pc1VwbG9hZGVkKSByZXR1cm5cblxuICBpZiAocHJvcHMuZXJyb3IgJiYgIXByb3BzLmhpZGVSZXRyeUJ1dHRvbikge1xuICAgIHByb3BzLnJldHJ5VXBsb2FkKHByb3BzLmZpbGUuaWQpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocHJvcHMucmVzdW1hYmxlVXBsb2FkcyAmJiAhcHJvcHMuaGlkZVBhdXNlUmVzdW1lQnV0dG9uKSB7XG4gICAgcHJvcHMucGF1c2VVcGxvYWQocHJvcHMuZmlsZS5pZClcbiAgfSBlbHNlIGlmIChwcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uICYmICFwcm9wcy5oaWRlQ2FuY2VsQnV0dG9uKSB7XG4gICAgcHJvcHMuY2FuY2VsVXBsb2FkKHByb3BzLmZpbGUuaWQpXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvZ3Jlc3NJbmRpY2F0b3JUaXRsZSAocHJvcHMpIHtcbiAgaWYgKHByb3BzLmlzVXBsb2FkZWQpIHtcbiAgICByZXR1cm4gcHJvcHMuaTE4bigndXBsb2FkQ29tcGxldGUnKVxuICB9XG5cbiAgaWYgKHByb3BzLmVycm9yKSB7XG4gICAgcmV0dXJuIHByb3BzLmkxOG4oJ3JldHJ5VXBsb2FkJylcbiAgfVxuXG4gIGlmIChwcm9wcy5yZXN1bWFibGVVcGxvYWRzKSB7XG4gICAgaWYgKHByb3BzLmZpbGUuaXNQYXVzZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcy5pMThuKCdyZXN1bWVVcGxvYWQnKVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHMuaTE4bigncGF1c2VVcGxvYWQnKVxuICB9IGlmIChwcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uKSB7XG4gICAgcmV0dXJuIHByb3BzLmkxOG4oJ2NhbmNlbFVwbG9hZCcpXG4gIH1cblxuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gUHJvZ3Jlc3NJbmRpY2F0b3JCdXR0b24gKHByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzXCI+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSW5kaWNhdG9yXCJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGFyaWEtbGFiZWw9e3Byb2dyZXNzSW5kaWNhdG9yVGl0bGUocHJvcHMpfVxuICAgICAgICB0aXRsZT17cHJvZ3Jlc3NJbmRpY2F0b3JUaXRsZShwcm9wcyl9XG4gICAgICAgIG9uQ2xpY2s9eygpID0+IG9uUGF1c2VSZXN1bWVDYW5jZWxSZXRyeShwcm9wcyl9XG4gICAgICA+XG4gICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICApXG59XG5cbmZ1bmN0aW9uIFByb2dyZXNzQ2lyY2xlQ29udGFpbmVyICh7IGNoaWxkcmVuIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgd2lkdGg9XCI3MFwiXG4gICAgICBoZWlnaHQ9XCI3MFwiXG4gICAgICB2aWV3Qm94PVwiMCAwIDM2IDM2XCJcbiAgICAgIGNsYXNzTmFtZT1cInVwcHktYy1pY29uIHVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJY29uLS1jaXJjbGVcIlxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBQcm9ncmVzc0NpcmNsZSAoeyBwcm9ncmVzcyB9KSB7XG4gIC8vIGNpcmNsZSBsZW5ndGggZXF1YWxzIDIgKiBQSSAqIFJcbiAgY29uc3QgY2lyY2xlTGVuZ3RoID0gMiAqIE1hdGguUEkgKiAxNVxuXG4gIHJldHVybiAoXG4gICAgPGc+XG4gICAgICA8Y2lyY2xlXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJY29uLS1iZ1wiXG4gICAgICAgIHI9XCIxNVwiXG4gICAgICAgIGN4PVwiMThcIlxuICAgICAgICBjeT1cIjE4XCJcbiAgICAgICAgc3Ryb2tlLXdpZHRoPVwiMlwiXG4gICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgIC8+XG4gICAgICA8Y2lyY2xlXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJY29uLS1wcm9ncmVzc1wiXG4gICAgICAgIHI9XCIxNVwiXG4gICAgICAgIGN4PVwiMThcIlxuICAgICAgICBjeT1cIjE4XCJcbiAgICAgICAgdHJhbnNmb3JtPVwicm90YXRlKC05MCwgMTgsIDE4KVwiXG4gICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgc3Ryb2tlLXdpZHRoPVwiMlwiXG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk9e2NpcmNsZUxlbmd0aH1cbiAgICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ9e2NpcmNsZUxlbmd0aCAtICgoY2lyY2xlTGVuZ3RoIC8gMTAwKSAqIHByb2dyZXNzKX1cbiAgICAgIC8+XG4gICAgPC9nPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRmlsZVByb2dyZXNzIChwcm9wcykge1xuICAvLyBOb3RoaW5nIGlmIHVwbG9hZCBoYXMgbm90IHN0YXJ0ZWRcbiAgaWYgKCFwcm9wcy5maWxlLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gR3JlZW4gY2hlY2ttYXJrIHdoZW4gY29tcGxldGVcbiAgaWYgKHByb3BzLmlzVXBsb2FkZWQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc0luZGljYXRvclwiPlxuICAgICAgICAgIDxQcm9ncmVzc0NpcmNsZUNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxjaXJjbGUgcj1cIjE1XCIgY3g9XCIxOFwiIGN5PVwiMThcIiBmaWxsPVwiIzFiYjI0MFwiIC8+XG4gICAgICAgICAgICA8cG9seWdvbiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSWNvbi0tY2hlY2tcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMiwgMylcIiBwb2ludHM9XCIxNCAyMi41IDcgMTUuMjQ1NzA2NSA4Ljk5OTg1ODU3IDEzLjE3MzI4MTUgMTQgMTguMzU0NzEwNCAyMi45NzI5ODgzIDkgMjUgMTEuMTAwNTYzNFwiIC8+XG4gICAgICAgICAgPC9Qcm9ncmVzc0NpcmNsZUNvbnRhaW5lcj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICBpZiAocHJvcHMucmVjb3ZlcmVkU3RhdGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIFJldHJ5IGJ1dHRvbiBmb3IgZXJyb3JcbiAgaWYgKHByb3BzLmVycm9yICYmICFwcm9wcy5oaWRlUmV0cnlCdXR0b24pIHtcbiAgICByZXR1cm4gKFxuICAgICAgPFByb2dyZXNzSW5kaWNhdG9yQnV0dG9uIHsuLi5wcm9wc30+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvbiB1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSWNvbi0tcmV0cnlcIiB3aWR0aD1cIjI4XCIgaGVpZ2h0PVwiMzFcIiB2aWV3Qm94PVwiMCAwIDE2IDE5XCI+XG4gICAgICAgICAgPHBhdGggZD1cIk0xNiAxMWE4IDggMCAxIDEtOC04djJhNiA2IDAgMSAwIDYgNmgyelwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk03LjkgM0gxMHYySDcuOXpcIiAvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNOC41MzYuNWwzLjUzNSAzLjUzNi0xLjQxNCAxLjQxNEw3LjEyIDEuOTE0elwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMC42NTcgMi42MjFsMS40MTQgMS40MTVMOC41MzYgNy41NyA3LjEyIDYuMTU3elwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9Qcm9ncmVzc0luZGljYXRvckJ1dHRvbj5cbiAgICApXG4gIH1cblxuICAvLyBQYXVzZS9yZXN1bWUgYnV0dG9uIGZvciByZXN1bWFibGUgdXBsb2Fkc1xuICBpZiAocHJvcHMucmVzdW1hYmxlVXBsb2FkcyAmJiAhcHJvcHMuaGlkZVBhdXNlUmVzdW1lQnV0dG9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxQcm9ncmVzc0luZGljYXRvckJ1dHRvbiB7Li4ucHJvcHN9PlxuICAgICAgICA8UHJvZ3Jlc3NDaXJjbGVDb250YWluZXI+XG4gICAgICAgICAgPFByb2dyZXNzQ2lyY2xlIHByb2dyZXNzPXtwcm9wcy5maWxlLnByb2dyZXNzLnBlcmNlbnRhZ2V9IC8+XG4gICAgICAgICAge1xuICAgICAgICAgICAgcHJvcHMuZmlsZS5pc1BhdXNlZFxuICAgICAgICAgICAgICA/IDxwb2x5Z29uIGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tcHJvZ3Jlc3NJY29uLS1wbGF5XCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDMsIDMpXCIgcG9pbnRzPVwiMTIgMjAgMTIgMTAgMjAgMTVcIiAvPlxuICAgICAgICAgICAgICA6IChcbiAgICAgICAgICAgICAgICA8ZyBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSWNvbi0tcGF1c2VcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTQuNSwgMTMpXCI+XG4gICAgICAgICAgICAgICAgICA8cmVjdCB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCIyXCIgaGVpZ2h0PVwiMTBcIiByeD1cIjBcIiAvPlxuICAgICAgICAgICAgICAgICAgPHJlY3QgeD1cIjVcIiB5PVwiMFwiIHdpZHRoPVwiMlwiIGhlaWdodD1cIjEwXCIgcng9XCIwXCIgLz5cbiAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIDwvUHJvZ3Jlc3NDaXJjbGVDb250YWluZXI+XG4gICAgICA8L1Byb2dyZXNzSW5kaWNhdG9yQnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIC8vIENhbmNlbCBidXR0b24gZm9yIG5vbi1yZXN1bWFibGUgdXBsb2FkcyBpZiBpbmRpdmlkdWFsQ2FuY2VsbGF0aW9uIGlzIHN1cHBvcnRlZCAobm90IGJ1bmRsZWQpXG4gIGlmICghcHJvcHMucmVzdW1hYmxlVXBsb2FkcyAmJiBwcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uICYmICFwcm9wcy5oaWRlQ2FuY2VsQnV0dG9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxQcm9ncmVzc0luZGljYXRvckJ1dHRvbiB7Li4ucHJvcHN9PlxuICAgICAgICA8UHJvZ3Jlc3NDaXJjbGVDb250YWluZXI+XG4gICAgICAgICAgPFByb2dyZXNzQ2lyY2xlIHByb2dyZXNzPXtwcm9wcy5maWxlLnByb2dyZXNzLnBlcmNlbnRhZ2V9IC8+XG4gICAgICAgICAgPHBvbHlnb24gY2xhc3NOYW1lPVwiY2FuY2VsXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIsIDIpXCIgcG9pbnRzPVwiMTkuODg1NjUxNiAxMS4wNjI1IDE2IDE0Ljk0ODE1MTYgMTIuMTAxOTczNyAxMS4wNjI1IDExLjA2MjUgMTIuMTE0MzQ4NCAxNC45NDgxNTE2IDE2IDExLjA2MjUgMTkuODk4MDI2MyAxMi4xMDE5NzM3IDIwLjkzNzUgMTYgMTcuMDUxODQ4NCAxOS44ODU2NTE2IDIwLjkzNzUgMjAuOTM3NSAxOS44OTgwMjYzIDE3LjA1MTg0ODQgMTYgMjAuOTM3NSAxMlwiIC8+XG4gICAgICAgIDwvUHJvZ3Jlc3NDaXJjbGVDb250YWluZXI+XG4gICAgICA8L1Byb2dyZXNzSW5kaWNhdG9yQnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIC8vIEp1c3QgcHJvZ3Jlc3Mgd2hlbiBidXR0b25zIGFyZSBkaXNhYmxlZFxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcm9ncmVzc1wiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByb2dyZXNzSW5kaWNhdG9yXCI+XG4gICAgICAgIDxQcm9ncmVzc0NpcmNsZUNvbnRhaW5lcj5cbiAgICAgICAgICA8UHJvZ3Jlc3NDaXJjbGUgcHJvZ3Jlc3M9e3Byb3BzLmZpbGUucHJvZ3Jlc3MucGVyY2VudGFnZX0gLz5cbiAgICAgICAgPC9Qcm9ncmVzc0NpcmNsZUNvbnRhaW5lcj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2lzLXNoYWxsb3ctZXF1YWwnKVxuY29uc3QgRmlsZVByZXZpZXdBbmRMaW5rID0gcmVxdWlyZSgnLi9GaWxlUHJldmlld0FuZExpbmsnKVxuY29uc3QgRmlsZVByb2dyZXNzID0gcmVxdWlyZSgnLi9GaWxlUHJvZ3Jlc3MnKVxuY29uc3QgRmlsZUluZm8gPSByZXF1aXJlKCcuL0ZpbGVJbmZvJylcbmNvbnN0IEJ1dHRvbnMgPSByZXF1aXJlKCcuL0J1dHRvbnMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEZpbGVJdGVtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlIChuZXh0UHJvcHMpIHtcbiAgICByZXR1cm4gIXNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMucHJvcHMuZmlsZVxuICAgIGlmICghZmlsZS5wcmV2aWV3KSB7XG4gICAgICB0aGlzLnByb3BzLmhhbmRsZVJlcXVlc3RUaHVtYm5haWwoZmlsZSlcbiAgICB9XG4gIH1cblxuICAvLyBWaXJ0dWFsTGlzdCBtb3VudHMgRmlsZUl0ZW1zIGFnYWluIGFuZCB0aGV5IGVtaXQgYHRodW1ibmFpbDpyZXF1ZXN0YFxuICAvLyBPdGhlcndpc2UgdGh1bWJuYWlscyBhcmUgYnJva2VuIG9yIG1pc3NpbmcgYWZ0ZXIgR29sZGVuIFJldHJpZXZlciByZXN0b3JlcyBmaWxlc1xuICBjb21wb25lbnREaWRVcGRhdGUgKCkge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVcbiAgICBpZiAoIWZpbGUucHJldmlldykge1xuICAgICAgdGhpcy5wcm9wcy5oYW5kbGVSZXF1ZXN0VGh1bWJuYWlsKGZpbGUpXG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVcbiAgICBpZiAoIWZpbGUucHJldmlldykge1xuICAgICAgdGhpcy5wcm9wcy5oYW5kbGVDYW5jZWxUaHVtYm5haWwoZmlsZSlcbiAgICB9XG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLnByb3BzLmZpbGVcblxuICAgIGNvbnN0IGlzUHJvY2Vzc2luZyA9IGZpbGUucHJvZ3Jlc3MucHJlcHJvY2VzcyB8fCBmaWxlLnByb2dyZXNzLnBvc3Rwcm9jZXNzXG4gICAgY29uc3QgaXNVcGxvYWRlZCA9IGZpbGUucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGUgJiYgIWlzUHJvY2Vzc2luZyAmJiAhZmlsZS5lcnJvclxuICAgIGNvbnN0IHVwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlID0gZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkIHx8IGlzUHJvY2Vzc2luZ1xuICAgIGNvbnN0IHVwbG9hZEluUHJvZ3Jlc3MgPSAoZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkICYmICFmaWxlLnByb2dyZXNzLnVwbG9hZENvbXBsZXRlKSB8fCBpc1Byb2Nlc3NpbmdcbiAgICBjb25zdCBlcnJvciA9IGZpbGUuZXJyb3IgfHwgZmFsc2VcblxuICAgIC8vIEZpbGUgdGhhdCBHb2xkZW4gUmV0cmlldmVyIHdhcyBhYmxlIHRvIHBhcnRseSByZXN0b3JlIChvbmx5IG1ldGEsIG5vdCBibG9iKSxcbiAgICAvLyB1c2VycyBzdGlsbCBuZWVkIHRvIHJlLWFkZCBpdCwgc28gaXTigJlzIGEgZ2hvc3RcbiAgICBjb25zdCBpc0dob3N0ID0gZmlsZS5pc0dob3N0XG5cbiAgICBsZXQgc2hvd1JlbW92ZUJ1dHRvbiA9IHRoaXMucHJvcHMuaW5kaXZpZHVhbENhbmNlbGxhdGlvblxuICAgICAgPyAhaXNVcGxvYWRlZFxuICAgICAgOiAhdXBsb2FkSW5Qcm9ncmVzcyAmJiAhaXNVcGxvYWRlZFxuXG4gICAgaWYgKGlzVXBsb2FkZWQgJiYgdGhpcy5wcm9wcy5zaG93UmVtb3ZlQnV0dG9uQWZ0ZXJDb21wbGV0ZSkge1xuICAgICAgc2hvd1JlbW92ZUJ1dHRvbiA9IHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBkYXNoYm9hcmRJdGVtQ2xhc3MgPSBjbGFzc05hbWVzKHtcbiAgICAgICd1cHB5LURhc2hib2FyZC1JdGVtJzogdHJ1ZSxcbiAgICAgICdpcy1pbnByb2dyZXNzJzogdXBsb2FkSW5Qcm9ncmVzcyAmJiAhdGhpcy5wcm9wcy5yZWNvdmVyZWRTdGF0ZSxcbiAgICAgICdpcy1wcm9jZXNzaW5nJzogaXNQcm9jZXNzaW5nLFxuICAgICAgJ2lzLWNvbXBsZXRlJzogaXNVcGxvYWRlZCxcbiAgICAgICdpcy1lcnJvcic6ICEhZXJyb3IsXG4gICAgICAnaXMtcmVzdW1hYmxlJzogdGhpcy5wcm9wcy5yZXN1bWFibGVVcGxvYWRzLFxuICAgICAgJ2lzLW5vSW5kaXZpZHVhbENhbmNlbGxhdGlvbic6ICF0aGlzLnByb3BzLmluZGl2aWR1YWxDYW5jZWxsYXRpb24sXG4gICAgICAnaXMtZ2hvc3QnOiBpc0dob3N0LFxuICAgIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2Rhc2hib2FyZEl0ZW1DbGFzc31cbiAgICAgICAgaWQ9e2B1cHB5XyR7ZmlsZS5pZH1gfVxuICAgICAgICByb2xlPXt0aGlzLnByb3BzLnJvbGV9XG4gICAgICA+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3XCI+XG4gICAgICAgICAgPEZpbGVQcmV2aWV3QW5kTGlua1xuICAgICAgICAgICAgZmlsZT17ZmlsZX1cbiAgICAgICAgICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0PXt0aGlzLnByb3BzLnNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0fVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEZpbGVQcm9ncmVzc1xuICAgICAgICAgICAgZmlsZT17ZmlsZX1cbiAgICAgICAgICAgIGVycm9yPXtlcnJvcn1cbiAgICAgICAgICAgIGlzVXBsb2FkZWQ9e2lzVXBsb2FkZWR9XG4gICAgICAgICAgICBoaWRlUmV0cnlCdXR0b249e3RoaXMucHJvcHMuaGlkZVJldHJ5QnV0dG9ufVxuICAgICAgICAgICAgaGlkZUNhbmNlbEJ1dHRvbj17dGhpcy5wcm9wcy5oaWRlQ2FuY2VsQnV0dG9ufVxuICAgICAgICAgICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uPXt0aGlzLnByb3BzLmhpZGVQYXVzZVJlc3VtZUJ1dHRvbn1cbiAgICAgICAgICAgIHJlY292ZXJlZFN0YXRlPXt0aGlzLnByb3BzLnJlY292ZXJlZFN0YXRlfVxuICAgICAgICAgICAgc2hvd1JlbW92ZUJ1dHRvbkFmdGVyQ29tcGxldGU9e3RoaXMucHJvcHMuc2hvd1JlbW92ZUJ1dHRvbkFmdGVyQ29tcGxldGV9XG4gICAgICAgICAgICByZXN1bWFibGVVcGxvYWRzPXt0aGlzLnByb3BzLnJlc3VtYWJsZVVwbG9hZHN9XG4gICAgICAgICAgICBpbmRpdmlkdWFsQ2FuY2VsbGF0aW9uPXt0aGlzLnByb3BzLmluZGl2aWR1YWxDYW5jZWxsYXRpb259XG4gICAgICAgICAgICBwYXVzZVVwbG9hZD17dGhpcy5wcm9wcy5wYXVzZVVwbG9hZH1cbiAgICAgICAgICAgIGNhbmNlbFVwbG9hZD17dGhpcy5wcm9wcy5jYW5jZWxVcGxvYWR9XG4gICAgICAgICAgICByZXRyeVVwbG9hZD17dGhpcy5wcm9wcy5yZXRyeVVwbG9hZH1cbiAgICAgICAgICAgIGkxOG49e3RoaXMucHJvcHMuaTE4bn1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkLUl0ZW0tZmlsZUluZm9BbmRCdXR0b25zXCI+XG4gICAgICAgICAgPEZpbGVJbmZvXG4gICAgICAgICAgICBmaWxlPXtmaWxlfVxuICAgICAgICAgICAgaWQ9e3RoaXMucHJvcHMuaWR9XG4gICAgICAgICAgICBhY3F1aXJlcnM9e3RoaXMucHJvcHMuYWNxdWlyZXJzfVxuICAgICAgICAgICAgY29udGFpbmVyV2lkdGg9e3RoaXMucHJvcHMuY29udGFpbmVyV2lkdGh9XG4gICAgICAgICAgICBpMThuPXt0aGlzLnByb3BzLmkxOG59XG4gICAgICAgICAgICB0b2dnbGVBZGRGaWxlc1BhbmVsPXt0aGlzLnByb3BzLnRvZ2dsZUFkZEZpbGVzUGFuZWx9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8QnV0dG9uc1xuICAgICAgICAgICAgZmlsZT17ZmlsZX1cbiAgICAgICAgICAgIG1ldGFGaWVsZHM9e3RoaXMucHJvcHMubWV0YUZpZWxkc31cbiAgICAgICAgICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0PXt0aGlzLnByb3BzLnNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0fVxuICAgICAgICAgICAgc2hvd1JlbW92ZUJ1dHRvbj17c2hvd1JlbW92ZUJ1dHRvbn1cbiAgICAgICAgICAgIGNhbkVkaXRGaWxlPXt0aGlzLnByb3BzLmNhbkVkaXRGaWxlfVxuICAgICAgICAgICAgdXBsb2FkSW5Qcm9ncmVzc09yQ29tcGxldGU9e3VwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlfVxuICAgICAgICAgICAgcmVtb3ZlRmlsZT17dGhpcy5wcm9wcy5yZW1vdmVGaWxlfVxuICAgICAgICAgICAgdG9nZ2xlRmlsZUNhcmQ9e3RoaXMucHJvcHMudG9nZ2xlRmlsZUNhcmR9XG4gICAgICAgICAgICBvcGVuRmlsZUVkaXRvcj17dGhpcy5wcm9wcy5vcGVuRmlsZUVkaXRvcn1cbiAgICAgICAgICAgIGkxOG49e3RoaXMucHJvcHMuaTE4bn1cbiAgICAgICAgICAgIGxvZz17dGhpcy5wcm9wcy5sb2d9XG4gICAgICAgICAgICBpbmZvPXt0aGlzLnByb3BzLmluZm99XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cbiIsImNvbnN0IEZpbGVJdGVtID0gcmVxdWlyZSgnLi9GaWxlSXRlbS9pbmRleC5qcycpXG5jb25zdCBWaXJ0dWFsTGlzdCA9IHJlcXVpcmUoJy4vVmlydHVhbExpc3QnKVxuY29uc3QgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKVxuY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5mdW5jdGlvbiBjaHVua3MgKGxpc3QsIHNpemUpIHtcbiAgY29uc3QgY2h1bmtlZCA9IFtdXG4gIGxldCBjdXJyZW50Q2h1bmsgPSBbXVxuICBsaXN0LmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICBpZiAoY3VycmVudENodW5rLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIGN1cnJlbnRDaHVuay5wdXNoKGl0ZW0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNodW5rZWQucHVzaChjdXJyZW50Q2h1bmspXG4gICAgICBjdXJyZW50Q2h1bmsgPSBbaXRlbV1cbiAgICB9XG4gIH0pXG4gIGlmIChjdXJyZW50Q2h1bmsubGVuZ3RoKSBjaHVua2VkLnB1c2goY3VycmVudENodW5rKVxuICByZXR1cm4gY2h1bmtlZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBjb25zdCBub0ZpbGVzID0gcHJvcHMudG90YWxGaWxlQ291bnQgPT09IDBcbiAgY29uc3QgZGFzaGJvYXJkRmlsZXNDbGFzcyA9IGNsYXNzTmFtZXMoXG4gICAgJ3VwcHktRGFzaGJvYXJkLWZpbGVzJyxcbiAgICB7ICd1cHB5LURhc2hib2FyZC1maWxlcy0tbm9GaWxlcyc6IG5vRmlsZXMgfVxuICApXG5cbiAgLy8gSXQncyBub3QgZ3JlYXQgdGhhdCB0aGlzIGlzIGhhcmRjb2RlZCFcbiAgLy8gSXQncyBFU1BFQ0lBTExZIG5vdCBncmVhdCB0aGF0IHRoaXMgaXMgY2hlY2tpbmcgYWdhaW5zdCBgaXRlbXNQZXJSb3dgIVxuICBjb25zdCByb3dIZWlnaHQgPSBwcm9wcy5pdGVtc1BlclJvdyA9PT0gMVxuICAgIC8vIE1vYmlsZVxuICAgID8gNzFcbiAgICAvLyAxOTBweCBoZWlnaHQgKyAyICogNXB4IG1hcmdpblxuICAgIDogMjAwXG5cbiAgY29uc3QgZmlsZVByb3BzID0ge1xuICAgIC8vIEZJWE1FIFRoaXMgaXMgY29uZnVzaW5nLCBpdCdzIGFjdHVhbGx5IHRoZSBEYXNoYm9hcmQncyBwbHVnaW4gSURcbiAgICBpZDogcHJvcHMuaWQsXG4gICAgZXJyb3I6IHByb3BzLmVycm9yLFxuICAgIC8vIFRPRE8gbW92ZSB0aGlzIHRvIGNvbnRleHRcbiAgICBpMThuOiBwcm9wcy5pMThuLFxuICAgIGxvZzogcHJvcHMubG9nLFxuICAgIGluZm86IHByb3BzLmluZm8sXG4gICAgLy8gZmVhdHVyZXNcbiAgICBhY3F1aXJlcnM6IHByb3BzLmFjcXVpcmVycyxcbiAgICByZXN1bWFibGVVcGxvYWRzOiBwcm9wcy5yZXN1bWFibGVVcGxvYWRzLFxuICAgIGluZGl2aWR1YWxDYW5jZWxsYXRpb246IHByb3BzLmluZGl2aWR1YWxDYW5jZWxsYXRpb24sXG4gICAgLy8gdmlzdWFsIG9wdGlvbnNcbiAgICBoaWRlUmV0cnlCdXR0b246IHByb3BzLmhpZGVSZXRyeUJ1dHRvbixcbiAgICBoaWRlUGF1c2VSZXN1bWVCdXR0b246IHByb3BzLmhpZGVQYXVzZVJlc3VtZUJ1dHRvbixcbiAgICBoaWRlQ2FuY2VsQnV0dG9uOiBwcm9wcy5oaWRlQ2FuY2VsQnV0dG9uLFxuICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0OiBwcm9wcy5zaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdCxcbiAgICBzaG93UmVtb3ZlQnV0dG9uQWZ0ZXJDb21wbGV0ZTogcHJvcHMuc2hvd1JlbW92ZUJ1dHRvbkFmdGVyQ29tcGxldGUsXG4gICAgaXNXaWRlOiBwcm9wcy5pc1dpZGUsXG4gICAgbWV0YUZpZWxkczogcHJvcHMubWV0YUZpZWxkcyxcbiAgICByZWNvdmVyZWRTdGF0ZTogcHJvcHMucmVjb3ZlcmVkU3RhdGUsXG4gICAgLy8gY2FsbGJhY2tzXG4gICAgcmV0cnlVcGxvYWQ6IHByb3BzLnJldHJ5VXBsb2FkLFxuICAgIHBhdXNlVXBsb2FkOiBwcm9wcy5wYXVzZVVwbG9hZCxcbiAgICBjYW5jZWxVcGxvYWQ6IHByb3BzLmNhbmNlbFVwbG9hZCxcbiAgICB0b2dnbGVGaWxlQ2FyZDogcHJvcHMudG9nZ2xlRmlsZUNhcmQsXG4gICAgcmVtb3ZlRmlsZTogcHJvcHMucmVtb3ZlRmlsZSxcbiAgICBoYW5kbGVSZXF1ZXN0VGh1bWJuYWlsOiBwcm9wcy5oYW5kbGVSZXF1ZXN0VGh1bWJuYWlsLFxuICAgIGhhbmRsZUNhbmNlbFRodW1ibmFpbDogcHJvcHMuaGFuZGxlQ2FuY2VsVGh1bWJuYWlsLFxuICB9XG5cbiAgY29uc3Qgc29ydEJ5R2hvc3RDb21lc0ZpcnN0ID0gKGZpbGUxLCBmaWxlMikgPT4ge1xuICAgIHJldHVybiBwcm9wcy5maWxlc1tmaWxlMl0uaXNHaG9zdCAtIHByb3BzLmZpbGVzW2ZpbGUxXS5pc0dob3N0XG4gIH1cblxuICAvLyBTb3J0IGZpbGVzIGJ5IGZpbGUuaXNHaG9zdCwgZ2hvc3QgZmlsZXMgZmlyc3QsIG9ubHkgaWYgcmVjb3ZlcmVkU3RhdGUgaXMgcHJlc2VudFxuICBjb25zdCBmaWxlcyA9IE9iamVjdC5rZXlzKHByb3BzLmZpbGVzKVxuICBpZiAocHJvcHMucmVjb3ZlcmVkU3RhdGUpIGZpbGVzLnNvcnQoc29ydEJ5R2hvc3RDb21lc0ZpcnN0KVxuICBjb25zdCByb3dzID0gY2h1bmtzKGZpbGVzLCBwcm9wcy5pdGVtc1BlclJvdylcblxuICBmdW5jdGlvbiByZW5kZXJSb3cgKHJvdykge1xuICAgIHJldHVybiAoXG4gICAgICAvLyBUaGUgYHJvbGU9XCJwcmVzZW50YXRpb25gIGF0dHJpYnV0ZSBlbnN1cmVzIHRoYXQgdGhlIGxpc3QgaXRlbXMgYXJlIHByb3Blcmx5IGFzc29jaWF0ZWQgd2l0aCB0aGUgYFZpcnR1YWxMaXN0YCBlbGVtZW50XG4gICAgICAvLyBXZSB1c2UgdGhlIGZpcnN0IGZpbGUgSUQgYXMgdGhlIGtleeKAlHRoaXMgc2hvdWxkIG5vdCBjaGFuZ2UgYWNyb3NzIHNjcm9sbCByZXJlbmRlcnNcbiAgICAgIDxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGtleT17cm93WzBdfT5cbiAgICAgICAge3Jvdy5tYXAoKGZpbGVJRCkgPT4gKFxuICAgICAgICAgIDxGaWxlSXRlbVxuICAgICAgICAgICAga2V5PXtmaWxlSUR9XG4gICAgICAgICAgICB7Li4uZmlsZVByb3BzfVxuICAgICAgICAgICAgcm9sZT1cImxpc3RpdGVtXCJcbiAgICAgICAgICAgIG9wZW5GaWxlRWRpdG9yPXtwcm9wcy5vcGVuRmlsZUVkaXRvcn1cbiAgICAgICAgICAgIGNhbkVkaXRGaWxlPXtwcm9wcy5jYW5FZGl0RmlsZX1cbiAgICAgICAgICAgIHRvZ2dsZUFkZEZpbGVzUGFuZWw9e3Byb3BzLnRvZ2dsZUFkZEZpbGVzUGFuZWx9XG4gICAgICAgICAgICBmaWxlPXtwcm9wcy5maWxlc1tmaWxlSURdfVxuICAgICAgICAgIC8+XG4gICAgICAgICkpfVxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8VmlydHVhbExpc3RcbiAgICAgIGNsYXNzPXtkYXNoYm9hcmRGaWxlc0NsYXNzfVxuICAgICAgcm9sZT1cImxpc3RcIlxuICAgICAgZGF0YT17cm93c31cbiAgICAgIHJlbmRlclJvdz17cmVuZGVyUm93fVxuICAgICAgcm93SGVpZ2h0PXtyb3dIZWlnaHR9XG4gICAgLz5cbiAgKVxufVxuIiwiY29uc3QgZ2V0RmlsZVR5cGVJY29uID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2V0RmlsZVR5cGVJY29uJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGaWxlUHJldmlldyAocHJvcHMpIHtcbiAgY29uc3QgZmlsZSA9IHByb3BzLmZpbGVcblxuICBpZiAoZmlsZS5wcmV2aWV3KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxpbWdcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3SW1nXCJcbiAgICAgICAgYWx0PXtmaWxlLm5hbWV9XG4gICAgICAgIHNyYz17ZmlsZS5wcmV2aWV3fVxuICAgICAgLz5cbiAgICApXG4gIH1cblxuICBjb25zdCB7IGNvbG9yLCBpY29uIH0gPSBnZXRGaWxlVHlwZUljb24oZmlsZS50eXBlKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByZXZpZXdJY29uV3JhcFwiPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmQtSXRlbS1wcmV2aWV3SWNvblwiIHN0eWxlPXt7IGNvbG9yIH19PntpY29ufTwvc3Bhbj5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZC1JdGVtLXByZXZpZXdJY29uQmdcIiB3aWR0aD1cIjU4XCIgaGVpZ2h0PVwiNzZcIiB2aWV3Qm94PVwiMCAwIDU4IDc2XCI+XG4gICAgICAgIDxyZWN0IGZpbGw9XCIjRkZGXCIgd2lkdGg9XCI1OFwiIGhlaWdodD1cIjc2XCIgcng9XCIzXCIgZmlsbFJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBpZ25vcmVFdmVudCA9IHJlcXVpcmUoJy4uL3V0aWxzL2lnbm9yZUV2ZW50LmpzJylcblxuZnVuY3Rpb24gUGlja2VyUGFuZWxDb250ZW50IChwcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcygndXBweS1EYXNoYm9hcmRDb250ZW50LXBhbmVsJywgcHJvcHMuY2xhc3NOYW1lKX1cbiAgICAgIHJvbGU9XCJ0YWJwYW5lbFwiXG4gICAgICBkYXRhLXVwcHktcGFuZWxUeXBlPVwiUGlja2VyUGFuZWxcIlxuICAgICAgaWQ9e2B1cHB5LURhc2hib2FyZENvbnRlbnQtcGFuZWwtLSR7cHJvcHMuYWN0aXZlUGlja2VyUGFuZWwuaWR9YH1cbiAgICAgIG9uRHJhZ092ZXI9e2lnbm9yZUV2ZW50fVxuICAgICAgb25EcmFnTGVhdmU9e2lnbm9yZUV2ZW50fVxuICAgICAgb25Ecm9wPXtpZ25vcmVFdmVudH1cbiAgICAgIG9uUGFzdGU9e2lnbm9yZUV2ZW50fVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC10aXRsZVwiIHJvbGU9XCJoZWFkaW5nXCIgYXJpYS1sZXZlbD1cIjFcIj5cbiAgICAgICAgICB7cHJvcHMuaTE4bignaW1wb3J0RnJvbScsIHsgbmFtZTogcHJvcHMuYWN0aXZlUGlja2VyUGFuZWwubmFtZSB9KX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFja1wiXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgb25DbGljaz17cHJvcHMuaGlkZUFsbFBhbmVsc31cbiAgICAgICAgPlxuICAgICAgICAgIHtwcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXBhbmVsQm9keVwiPlxuICAgICAgICB7cHJvcHMuZ2V0UGx1Z2luKHByb3BzLmFjdGl2ZVBpY2tlclBhbmVsLmlkKS5yZW5kZXIocHJvcHMuc3RhdGUpfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQaWNrZXJQYW5lbENvbnRlbnRcbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuY29uc3QgdXBsb2FkU3RhdGVzID0ge1xuICBTVEFURV9FUlJPUjogJ2Vycm9yJyxcbiAgU1RBVEVfV0FJVElORzogJ3dhaXRpbmcnLFxuICBTVEFURV9QUkVQUk9DRVNTSU5HOiAncHJlcHJvY2Vzc2luZycsXG4gIFNUQVRFX1VQTE9BRElORzogJ3VwbG9hZGluZycsXG4gIFNUQVRFX1BPU1RQUk9DRVNTSU5HOiAncG9zdHByb2Nlc3NpbmcnLFxuICBTVEFURV9DT01QTEVURTogJ2NvbXBsZXRlJyxcbiAgU1RBVEVfUEFVU0VEOiAncGF1c2VkJyxcbn1cblxuZnVuY3Rpb24gZ2V0VXBsb2FkaW5nU3RhdGUgKGlzQWxsRXJyb3JlZCwgaXNBbGxDb21wbGV0ZSwgaXNBbGxQYXVzZWQsIGZpbGVzID0ge30pIHtcbiAgaWYgKGlzQWxsRXJyb3JlZCkge1xuICAgIHJldHVybiB1cGxvYWRTdGF0ZXMuU1RBVEVfRVJST1JcbiAgfVxuXG4gIGlmIChpc0FsbENvbXBsZXRlKSB7XG4gICAgcmV0dXJuIHVwbG9hZFN0YXRlcy5TVEFURV9DT01QTEVURVxuICB9XG5cbiAgaWYgKGlzQWxsUGF1c2VkKSB7XG4gICAgcmV0dXJuIHVwbG9hZFN0YXRlcy5TVEFURV9QQVVTRURcbiAgfVxuXG4gIGxldCBzdGF0ZSA9IHVwbG9hZFN0YXRlcy5TVEFURV9XQUlUSU5HXG4gIGNvbnN0IGZpbGVJRHMgPSBPYmplY3Qua2V5cyhmaWxlcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBmaWxlc1tmaWxlSURzW2ldXS5wcm9ncmVzc1xuICAgIC8vIElmIEFOWSBmaWxlcyBhcmUgYmVpbmcgdXBsb2FkZWQgcmlnaHQgbm93LCBzaG93IHRoZSB1cGxvYWRpbmcgc3RhdGUuXG4gICAgaWYgKHByb2dyZXNzLnVwbG9hZFN0YXJ0ZWQgJiYgIXByb2dyZXNzLnVwbG9hZENvbXBsZXRlKSB7XG4gICAgICByZXR1cm4gdXBsb2FkU3RhdGVzLlNUQVRFX1VQTE9BRElOR1xuICAgIH1cbiAgICAvLyBJZiBmaWxlcyBhcmUgYmVpbmcgcHJlcHJvY2Vzc2VkIEFORCBwb3N0cHJvY2Vzc2VkIGF0IHRoaXMgdGltZSwgd2Ugc2hvdyB0aGVcbiAgICAvLyBwcmVwcm9jZXNzIHN0YXRlLiBJZiBhbnkgZmlsZXMgYXJlIGJlaW5nIHVwbG9hZGVkIHdlIHNob3cgdXBsb2FkaW5nLlxuICAgIGlmIChwcm9ncmVzcy5wcmVwcm9jZXNzICYmIHN0YXRlICE9PSB1cGxvYWRTdGF0ZXMuU1RBVEVfVVBMT0FESU5HKSB7XG4gICAgICBzdGF0ZSA9IHVwbG9hZFN0YXRlcy5TVEFURV9QUkVQUk9DRVNTSU5HXG4gICAgfVxuICAgIC8vIElmIE5PIGZpbGVzIGFyZSBiZWluZyBwcmVwcm9jZXNzZWQgb3IgdXBsb2FkZWQgcmlnaHQgbm93LCBidXQgc29tZSBmaWxlcyBhcmVcbiAgICAvLyBiZWluZyBwb3N0cHJvY2Vzc2VkLCBzaG93IHRoZSBwb3N0cHJvY2VzcyBzdGF0ZS5cbiAgICBpZiAocHJvZ3Jlc3MucG9zdHByb2Nlc3MgJiYgc3RhdGUgIT09IHVwbG9hZFN0YXRlcy5TVEFURV9VUExPQURJTkcgJiYgc3RhdGUgIT09IHVwbG9hZFN0YXRlcy5TVEFURV9QUkVQUk9DRVNTSU5HKSB7XG4gICAgICBzdGF0ZSA9IHVwbG9hZFN0YXRlcy5TVEFURV9QT1NUUFJPQ0VTU0lOR1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGVcbn1cblxuZnVuY3Rpb24gVXBsb2FkU3RhdHVzIChwcm9wcykge1xuICBjb25zdCB1cGxvYWRpbmdTdGF0ZSA9IGdldFVwbG9hZGluZ1N0YXRlKFxuICAgIHByb3BzLmlzQWxsRXJyb3JlZCxcbiAgICBwcm9wcy5pc0FsbENvbXBsZXRlLFxuICAgIHByb3BzLmlzQWxsUGF1c2VkLFxuICAgIHByb3BzLmZpbGVzXG4gIClcblxuICBzd2l0Y2ggKHVwbG9hZGluZ1N0YXRlKSB7XG4gICAgY2FzZSAndXBsb2FkaW5nJzpcbiAgICAgIHJldHVybiBwcm9wcy5pMThuKCd1cGxvYWRpbmdYRmlsZXMnLCB7IHNtYXJ0X2NvdW50OiBwcm9wcy5pblByb2dyZXNzTm90UGF1c2VkRmlsZXMubGVuZ3RoIH0pXG4gICAgY2FzZSAncHJlcHJvY2Vzc2luZyc6XG4gICAgY2FzZSAncG9zdHByb2Nlc3NpbmcnOlxuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3Byb2Nlc3NpbmdYRmlsZXMnLCB7IHNtYXJ0X2NvdW50OiBwcm9wcy5wcm9jZXNzaW5nRmlsZXMubGVuZ3RoIH0pXG4gICAgY2FzZSAncGF1c2VkJzpcbiAgICAgIHJldHVybiBwcm9wcy5pMThuKCd1cGxvYWRQYXVzZWQnKVxuICAgIGNhc2UgJ3dhaXRpbmcnOlxuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3hGaWxlc1NlbGVjdGVkJywgeyBzbWFydF9jb3VudDogcHJvcHMubmV3RmlsZXMubGVuZ3RoIH0pXG4gICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3VwbG9hZENvbXBsZXRlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBQYW5lbFRvcEJhciAocHJvcHMpIHtcbiAgbGV0IGFsbG93TmV3VXBsb2FkID0gcHJvcHMuYWxsb3dOZXdVcGxvYWRcbiAgLy8gVE9ETyBtYXliZSB0aGlzIHNob3VsZCBiZSBkb25lIGluIC4uL2luZGV4LmpzLCB0aGVuIGp1c3QgcGFzcyB0aGF0IGRvd24gYXMgYGFsbG93TmV3VXBsb2FkYFxuICBpZiAoYWxsb3dOZXdVcGxvYWQgJiYgcHJvcHMubWF4TnVtYmVyT2ZGaWxlcykge1xuICAgIGFsbG93TmV3VXBsb2FkID0gcHJvcHMudG90YWxGaWxlQ291bnQgPCBwcm9wcy5tYXhOdW1iZXJPZkZpbGVzXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhclwiPlxuICAgICAgeyFwcm9wcy5pc0FsbENvbXBsZXRlICYmICFwcm9wcy5oaWRlQ2FuY2VsQnV0dG9uID8gKFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhY2tcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uQ2xpY2s9e3Byb3BzLmNhbmNlbEFsbH1cbiAgICAgICAgPlxuICAgICAgICAgIHtwcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICApIDogKFxuICAgICAgICA8ZGl2IC8+XG4gICAgICApfVxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktRGFzaGJvYXJkQ29udGVudC10aXRsZVwiIHJvbGU9XCJoZWFkaW5nXCIgYXJpYS1sZXZlbD1cIjFcIj5cbiAgICAgICAgPFVwbG9hZFN0YXR1cyB7Li4ucHJvcHN9IC8+XG4gICAgICA8L2Rpdj5cblxuICAgICAge2FsbG93TmV3VXBsb2FkID8gKFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWFkZE1vcmVcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ2FkZE1vcmVGaWxlcycpfVxuICAgICAgICAgIHRpdGxlPXtwcm9wcy5pMThuKCdhZGRNb3JlRmlsZXMnKX1cbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBwcm9wcy50b2dnbGVBZGRGaWxlc1BhbmVsKHRydWUpfVxuICAgICAgICA+XG4gICAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxNVwiIGhlaWdodD1cIjE1XCIgdmlld0JveD1cIjAgMCAxNSAxNVwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk04IDYuNWg2YS41LjUgMCAwIDEgLjUuNXYuNWEuNS41IDAgMCAxLS41LjVIOHY2YS41LjUgMCAwIDEtLjUuNUg3YS41LjUgMCAwIDEtLjUtLjVWOGgtNmEuNS41IDAgMCAxLS41LS41VjdhLjUuNSAwIDAgMSAuNS0uNWg2di02QS41LjUgMCAwIDEgNyAwaC41YS41LjUgMCAwIDEgLjUuNXY2elwiIC8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWFkZE1vcmVDYXB0aW9uXCI+e3Byb3BzLmkxOG4oJ2FkZE1vcmUnKX08L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgKSA6IChcbiAgICAgICAgPGRpdiAvPlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhbmVsVG9wQmFyXG4iLCJjb25zdCB7IGNsb25lRWxlbWVudCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKVxuXG5jb25zdCB0cmFuc2l0aW9uTmFtZSA9ICd1cHB5LXRyYW5zaXRpb24tc2xpZGVEb3duVXAnXG5jb25zdCBkdXJhdGlvbiA9IDI1MFxuXG4vKipcbiAqIFZlcnRpY2FsIHNsaWRlIHRyYW5zaXRpb24uXG4gKlxuICogVGhpcyBjYW4gdGFrZSBhIF9zaW5nbGVfIGNoaWxkIGNvbXBvbmVudCwgd2hpY2ggX211c3RfIGFjY2VwdCBhIGBjbGFzc05hbWVgIHByb3AuXG4gKlxuICogQ3VycmVudGx5IHRoaXMgaXMgc3BlY2lmaWMgdG8gdGhlIGB1cHB5LXRyYW5zaXRpb24tc2xpZGVEb3duVXBgIHRyYW5zaXRpb24sXG4gKiBidXQgaXQgc2hvdWxkIGJlIHNpbXBsZSB0byBleHRlbmQgdGhpcyBmb3IgYW55IHR5cGUgb2Ygc2luZ2xlLWVsZW1lbnRcbiAqIHRyYW5zaXRpb24gYnkgc2V0dGluZyB0aGUgQ1NTIG5hbWUgYW5kIGR1cmF0aW9uIGFzIHByb3BzLlxuICovXG5jbGFzcyBTbGlkZSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGNhY2hlZENoaWxkcmVuOiBudWxsLFxuICAgICAgY2xhc3NOYW1lOiAnJyxcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVXBkYXRlIChuZXh0UHJvcHMpIHtcbiAgICBjb25zdCB7IGNhY2hlZENoaWxkcmVuIH0gPSB0aGlzLnN0YXRlXG4gICAgY29uc3QgY2hpbGQgPSBuZXh0UHJvcHMuY2hpbGRyZW5bMF1cblxuICAgIGlmIChjYWNoZWRDaGlsZHJlbiA9PT0gY2hpbGQpIHJldHVyblxuXG4gICAgY29uc3QgcGF0Y2ggPSB7XG4gICAgICBjYWNoZWRDaGlsZHJlbjogY2hpbGQsXG4gICAgfVxuXG4gICAgLy8gRW50ZXIgdHJhbnNpdGlvblxuICAgIGlmIChjaGlsZCAmJiAhY2FjaGVkQ2hpbGRyZW4pIHtcbiAgICAgIHBhdGNoLmNsYXNzTmFtZSA9IGAke3RyYW5zaXRpb25OYW1lfS1lbnRlcmBcblxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZSlcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmxlYXZlVGltZW91dClcbiAgICAgIHRoaXMubGVhdmVUaW1lb3V0ID0gdW5kZWZpbmVkXG5cbiAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAvLyBGb3JjZSBpdCB0byByZW5kZXIgYmVmb3JlIHdlIGFkZCB0aGUgYWN0aXZlIGNsYXNzXG4gICAgICAgIHRoaXMuYmFzZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGNsYXNzTmFtZTogYCR7dHJhbnNpdGlvbk5hbWV9LWVudGVyICR7dHJhbnNpdGlvbk5hbWV9LWVudGVyLWFjdGl2ZWAsXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5lbnRlclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgY2xhc3NOYW1lOiAnJyB9KVxuICAgICAgICB9LCBkdXJhdGlvbilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gTGVhdmUgdHJhbnNpdGlvblxuICAgIGlmIChjYWNoZWRDaGlsZHJlbiAmJiAhY2hpbGQgJiYgdGhpcy5sZWF2ZVRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGF0Y2guY2FjaGVkQ2hpbGRyZW4gPSBjYWNoZWRDaGlsZHJlblxuICAgICAgcGF0Y2guY2xhc3NOYW1lID0gYCR7dHJhbnNpdGlvbk5hbWV9LWxlYXZlYFxuXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lKVxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZW50ZXJUaW1lb3V0KVxuICAgICAgdGhpcy5lbnRlclRpbWVvdXQgPSB1bmRlZmluZWRcbiAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjbGFzc05hbWU6IGAke3RyYW5zaXRpb25OYW1lfS1sZWF2ZSAke3RyYW5zaXRpb25OYW1lfS1sZWF2ZS1hY3RpdmVgLFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMubGVhdmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjYWNoZWRDaGlsZHJlbjogbnVsbCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJycsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSwgZHVyYXRpb24pXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUocGF0Y2gpXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHsgY2FjaGVkQ2hpbGRyZW4sIGNsYXNzTmFtZSB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgaWYgKCFjYWNoZWRDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmVFbGVtZW50KGNhY2hlZENoaWxkcmVuLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoY2xhc3NOYW1lLCBjYWNoZWRDaGlsZHJlbi5hdHRyaWJ1dGVzLmNsYXNzTmFtZSksXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNsaWRlXG4iLCIvKipcbiAqIEFkYXB0ZWQgZnJvbSBwcmVhY3QtdmlydHVhbC1saXN0OiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC12aXJ0dWFsLWxpc3RcbiAqXG4gKiDCqSAyMDE2IEphc29uIE1pbGxlclxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKlxuICogQWRhcHRhdGlvbnM6XG4gKiAtIEFkZGVkIHJvbGU9cHJlc2VudGF0aW9uIHRvIGhlbHBlciBlbGVtZW50c1xuICogLSBUd2Vha2VkIHN0eWxlcyBmb3IgVXBweSdzIERhc2hib2FyZCB1c2UgY2FzZVxuICovXG5cbmNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5jb25zdCBTVFlMRV9JTk5FUiA9IHtcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gIC8vIERpc2FibGVkIGZvciBvdXIgdXNlIGNhc2U6IHRoZSB3cmFwcGVyIGVsZW1lbnRzIGFyb3VuZCBGaWxlTGlzdCBhbHJlYWR5IGRlYWwgd2l0aCBvdmVyZmxvdyxcbiAgLy8gYW5kIHRoaXMgYWRkaXRpb25hbCBwcm9wZXJ0eSB3b3VsZCBoaWRlIHRoaW5ncyB0aGF0IHdlIHdhbnQgdG8gc2hvdy5cbiAgLy9cbiAgLy8gb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICB3aWR0aDogJzEwMCUnLFxuICBtaW5IZWlnaHQ6ICcxMDAlJyxcbn1cblxuY29uc3QgU1RZTEVfQ09OVEVOVCA9IHtcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHRvcDogMCxcbiAgbGVmdDogMCxcbiAgLy8gQmVjYXVzZSB0aGUgYHRvcGAgdmFsdWUgZ2V0cyBzZXQgdG8gc29tZSBvZmZzZXQsIHRoaXMgYGhlaWdodGAgYmVpbmcgMTAwJSB3b3VsZCBtYWtlIHRoZSBzY3JvbGxiYXJcbiAgLy8gc3RyZXRjaCBmYXIgYmV5b25kIHRoZSBjb250ZW50LiBGb3Igb3VyIHVzZSBjYXNlLCB0aGUgY29udGVudCBkaXYgYWN0dWFsbHkgY2FuIGdldCBpdHMgaGVpZ2h0IGZyb21cbiAgLy8gdGhlIGVsZW1lbnRzIGluc2lkZSBpdCwgc28gd2UgZG9uJ3QgbmVlZCB0byBzcGVjaWZ5IGEgYGhlaWdodGAgcHJvcGVydHkgYXQgYWxsLlxuICAvL1xuICAvLyBoZWlnaHQ6ICcxMDAlJyxcbiAgd2lkdGg6ICcxMDAlJyxcbiAgb3ZlcmZsb3c6ICd2aXNpYmxlJyxcbn1cblxuY2xhc3MgVmlydHVhbExpc3QgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcblxuICAgIC8vIFRoZSBjdXJyZW50bHkgZm9jdXNlZCBub2RlLCB1c2VkIHRvIHJldGFpbiBmb2N1cyB3aGVuIHRoZSB2aXNpYmxlIHJvd3MgY2hhbmdlLlxuICAgIC8vIFRvIGF2b2lkIHVwZGF0ZSBsb29wcywgdGhpcyBzaG91bGQgbm90IGNhdXNlIHN0YXRlIHVwZGF0ZXMsIHNvIGl0J3Mga2VwdCBhcyBhIHBsYWluIHByb3BlcnR5LlxuICAgIHRoaXMuZm9jdXNFbGVtZW50ID0gbnVsbFxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICB9XG4gIH1cblxuICByZXNpemUgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmhlaWdodCAhPT0gdGhpcy5iYXNlLm9mZnNldEhlaWdodCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGhlaWdodDogdGhpcy5iYXNlLm9mZnNldEhlaWdodCxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgIHRoaXMucmVzaXplKClcbiAgfVxuXG4gIGhhbmRsZVNjcm9sbCA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG9mZnNldDogdGhpcy5iYXNlLnNjcm9sbFRvcCxcbiAgICB9KVxuICAgIGlmICh0aGlzLnByb3BzLnN5bmMpIHtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVcGRhdGUgKCkge1xuICAgIGlmICh0aGlzLmJhc2UuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHRoaXMuZm9jdXNFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSAoKSB7XG4gICAgLy8gTWFpbnRhaW4gZm9jdXMgd2hlbiByb3dzIGFyZSBhZGRlZCBhbmQgcmVtb3ZlZC5cbiAgICBpZiAodGhpcy5mb2N1c0VsZW1lbnQgJiYgdGhpcy5mb2N1c0VsZW1lbnQucGFyZW50Tm9kZVxuICAgICAgICAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0aGlzLmZvY3VzRWxlbWVudCkge1xuICAgICAgdGhpcy5mb2N1c0VsZW1lbnQuZm9jdXMoKVxuICAgIH1cbiAgICB0aGlzLmZvY3VzRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLnJlc2l6ZSgpXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgdGhpcy5yZXNpemUoKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSlcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpXG4gIH1cblxuICByZW5kZXIgKHtcbiAgICBkYXRhLFxuICAgIHJvd0hlaWdodCxcbiAgICByZW5kZXJSb3csXG4gICAgb3ZlcnNjYW5Db3VudCA9IDEwLFxuICAgIHN5bmMsXG4gICAgLi4ucHJvcHNcbiAgfSkge1xuICAgIGNvbnN0IHsgb2Zmc2V0LCBoZWlnaHQgfSA9IHRoaXMuc3RhdGVcbiAgICAvLyBmaXJzdCB2aXNpYmxlIHJvdyBpbmRleFxuICAgIGxldCBzdGFydCA9IE1hdGguZmxvb3Iob2Zmc2V0IC8gcm93SGVpZ2h0KVxuXG4gICAgLy8gYWN0dWFsIG51bWJlciBvZiB2aXNpYmxlIHJvd3MgKHdpdGhvdXQgb3ZlcnNjYW4pXG4gICAgbGV0IHZpc2libGVSb3dDb3VudCA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gcm93SGVpZ2h0KVxuXG4gICAgLy8gT3ZlcnNjYW46IHJlbmRlciBibG9ja3Mgb2Ygcm93cyBtb2R1bG8gYW4gb3ZlcnNjYW4gcm93IGNvdW50XG4gICAgLy8gVGhpcyBkcmFtYXRpY2FsbHkgcmVkdWNlcyBET00gd3JpdGVzIGR1cmluZyBzY3JvbGxpbmdcbiAgICBpZiAob3ZlcnNjYW5Db3VudCkge1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCAtIChzdGFydCAlIG92ZXJzY2FuQ291bnQpKVxuICAgICAgdmlzaWJsZVJvd0NvdW50ICs9IG92ZXJzY2FuQ291bnRcbiAgICB9XG5cbiAgICAvLyBsYXN0IHZpc2libGUgKyBvdmVyc2NhbiByb3cgaW5kZXggKyBwYWRkaW5nIHRvIGFsbG93IGtleWJvYXJkIGZvY3VzIHRvIHRyYXZlbCBwYXN0IHRoZSB2aXNpYmxlIGFyZWFcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIHZpc2libGVSb3dDb3VudCArIDRcblxuICAgIC8vIGRhdGEgc2xpY2UgY3VycmVudGx5IGluIHZpZXdwb3J0IHBsdXMgb3ZlcnNjYW4gaXRlbXNcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgICBjb25zdCBzdHlsZUlubmVyID0geyAuLi5TVFlMRV9JTk5FUiwgaGVpZ2h0OiBkYXRhLmxlbmd0aCAqIHJvd0hlaWdodCB9XG4gICAgY29uc3Qgc3R5bGVDb250ZW50ID0geyAuLi5TVFlMRV9DT05URU5ULCB0b3A6IHN0YXJ0ICogcm93SGVpZ2h0IH1cblxuICAgIC8vIFRoZSBgcm9sZT1cInByZXNlbnRhdGlvblwiYCBhdHRyaWJ1dGVzIGVuc3VyZSB0aGF0IHRoZXNlIHdyYXBwZXIgZWxlbWVudHMgYXJlIG5vdCB0cmVhdGVkIGFzIGxpc3RcbiAgICAvLyBpdGVtcyBieSBhY2Nlc3NpYmlsaXR5IGFuZCBvdXRsaW5lIHRvb2xzLlxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IG9uU2Nyb2xsPXt0aGlzLmhhbmRsZVNjcm9sbH0gey4uLnByb3BzfT5cbiAgICAgICAgPGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgc3R5bGU9e3N0eWxlSW5uZXJ9PlxuICAgICAgICAgIDxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIHN0eWxlPXtzdHlsZUNvbnRlbnR9PlxuICAgICAgICAgICAge3NlbGVjdGlvbi5tYXAocmVuZGVyUm93KX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWaXJ0dWFsTGlzdFxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9UcmFuc2xhdG9yJylcbmNvbnN0IERhc2hib2FyZFVJID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0Rhc2hib2FyZCcpXG5jb25zdCBTdGF0dXNCYXIgPSByZXF1aXJlKCdAdXBweS9zdGF0dXMtYmFyJylcbmNvbnN0IEluZm9ybWVyID0gcmVxdWlyZSgnQHVwcHkvaW5mb3JtZXInKVxuY29uc3QgVGh1bWJuYWlsR2VuZXJhdG9yID0gcmVxdWlyZSgnQHVwcHkvdGh1bWJuYWlsLWdlbmVyYXRvcicpXG5jb25zdCBmaW5kQWxsRE9NRWxlbWVudHMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZmluZEFsbERPTUVsZW1lbnRzJylcbmNvbnN0IHRvQXJyYXkgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvdG9BcnJheScpXG5jb25zdCBnZXREcm9wcGVkRmlsZXMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0RHJvcHBlZEZpbGVzJylcbmNvbnN0IGdldFRleHREaXJlY3Rpb24gPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0VGV4dERpcmVjdGlvbicpXG5jb25zdCB0cmFwRm9jdXMgPSByZXF1aXJlKCcuL3V0aWxzL3RyYXBGb2N1cycpXG5jb25zdCBjdWlkID0gcmVxdWlyZSgnY3VpZCcpXG5jb25zdCBSZXNpemVPYnNlcnZlciA9IHJlcXVpcmUoJ3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbCcpLmRlZmF1bHQgfHwgcmVxdWlyZSgncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJylcbmNvbnN0IGNyZWF0ZVN1cGVyRm9jdXMgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZVN1cGVyRm9jdXMnKVxuY29uc3QgbWVtb2l6ZSA9IHJlcXVpcmUoJ21lbW9pemUtb25lJykuZGVmYXVsdCB8fCByZXF1aXJlKCdtZW1vaXplLW9uZScpXG5jb25zdCBGT0NVU0FCTEVfRUxFTUVOVFMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvRk9DVVNBQkxFX0VMRU1FTlRTJylcblxuY29uc3QgVEFCX0tFWSA9IDlcbmNvbnN0IEVTQ19LRVkgPSAyN1xuXG5mdW5jdGlvbiBjcmVhdGVQcm9taXNlICgpIHtcbiAgY29uc3QgbyA9IHt9XG4gIG8ucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBvLnJlc29sdmUgPSByZXNvbHZlXG4gICAgby5yZWplY3QgPSByZWplY3RcbiAgfSlcbiAgcmV0dXJuIG9cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFBpY2tlckljb24gKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMwXCIgaGVpZ2h0PVwiMzBcIiB2aWV3Qm94PVwiMCAwIDMwIDMwXCI+XG4gICAgICA8cGF0aCBkPVwiTTE1IDMwYzguMjg0IDAgMTUtNi43MTYgMTUtMTUgMC04LjI4NC02LjcxNi0xNS0xNS0xNUM2LjcxNiAwIDAgNi43MTYgMCAxNWMwIDguMjg0IDYuNzE2IDE1IDE1IDE1em00LjI1OC0xMi42NzZ2Ni44NDZoLTguNDI2di02Ljg0Nkg1LjIwNGw5LjgyLTEyLjM2NCA5LjgyIDEyLjM2NEgxOS4yNnpcIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbi8qKlxuICogRGFzaGJvYXJkIFVJIHdpdGggcHJldmlld3MsIG1ldGFkYXRhIGVkaXRpbmcsIHRhYnMgZm9yIHZhcmlvdXMgc2VydmljZXMgYW5kIG1vcmVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEYXNoYm9hcmQgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnRGFzaGJvYXJkJ1xuICAgIHRoaXMudGl0bGUgPSAnRGFzaGJvYXJkJ1xuICAgIHRoaXMudHlwZSA9ICdvcmNoZXN0cmF0b3InXG4gICAgdGhpcy5tb2RhbE5hbWUgPSBgdXBweS1EYXNoYm9hcmQtJHtjdWlkKCl9YFxuXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0ge1xuICAgICAgc3RyaW5nczoge1xuICAgICAgICBjbG9zZU1vZGFsOiAnQ2xvc2UgTW9kYWwnLFxuICAgICAgICBpbXBvcnRGcm9tOiAnSW1wb3J0IGZyb20gJXtuYW1lfScsXG4gICAgICAgIGFkZGluZ01vcmVGaWxlczogJ0FkZGluZyBtb3JlIGZpbGVzJyxcbiAgICAgICAgYWRkTW9yZUZpbGVzOiAnQWRkIG1vcmUgZmlsZXMnLFxuICAgICAgICBkYXNoYm9hcmRXaW5kb3dUaXRsZTogJ0ZpbGUgVXBsb2FkZXIgV2luZG93IChQcmVzcyBlc2NhcGUgdG8gY2xvc2UpJyxcbiAgICAgICAgZGFzaGJvYXJkVGl0bGU6ICdGaWxlIFVwbG9hZGVyJyxcbiAgICAgICAgY29weUxpbmtUb0NsaXBib2FyZFN1Y2Nlc3M6ICdMaW5rIGNvcGllZCB0byBjbGlwYm9hcmQnLFxuICAgICAgICBjb3B5TGlua1RvQ2xpcGJvYXJkRmFsbGJhY2s6ICdDb3B5IHRoZSBVUkwgYmVsb3cnLFxuICAgICAgICBjb3B5TGluazogJ0NvcHkgbGluaycsXG4gICAgICAgIGZpbGVTb3VyY2U6ICdGaWxlIHNvdXJjZTogJXtuYW1lfScsXG4gICAgICAgIGJhY2s6ICdCYWNrJyxcbiAgICAgICAgYWRkTW9yZTogJ0FkZCBtb3JlJyxcbiAgICAgICAgcmVtb3ZlRmlsZTogJ1JlbW92ZSBmaWxlJyxcbiAgICAgICAgZWRpdEZpbGU6ICdFZGl0IGZpbGUnLFxuICAgICAgICBlZGl0aW5nOiAnRWRpdGluZyAle2ZpbGV9JyxcbiAgICAgICAgZmluaXNoRWRpdGluZ0ZpbGU6ICdGaW5pc2ggZWRpdGluZyBmaWxlJyxcbiAgICAgICAgc2F2ZTogJ1NhdmUnLFxuICAgICAgICBzYXZlQ2hhbmdlczogJ1NhdmUgY2hhbmdlcycsXG4gICAgICAgIGNhbmNlbDogJ0NhbmNlbCcsXG4gICAgICAgIG15RGV2aWNlOiAnTXkgRGV2aWNlJyxcbiAgICAgICAgZHJvcFBhc3RlRmlsZXM6ICdEcm9wIGZpbGVzIGhlcmUgb3IgJXticm93c2VGaWxlc30nLFxuICAgICAgICBkcm9wUGFzdGVGb2xkZXJzOiAnRHJvcCBmaWxlcyBoZXJlIG9yICV7YnJvd3NlRm9sZGVyc30nLFxuICAgICAgICBkcm9wUGFzdGVCb3RoOiAnRHJvcCBmaWxlcyBoZXJlLCAle2Jyb3dzZUZpbGVzfSBvciAle2Jyb3dzZUZvbGRlcnN9JyxcbiAgICAgICAgZHJvcFBhc3RlSW1wb3J0RmlsZXM6ICdEcm9wIGZpbGVzIGhlcmUsICV7YnJvd3NlRmlsZXN9IG9yIGltcG9ydCBmcm9tOicsXG4gICAgICAgIGRyb3BQYXN0ZUltcG9ydEZvbGRlcnM6ICdEcm9wIGZpbGVzIGhlcmUsICV7YnJvd3NlRm9sZGVyc30gb3IgaW1wb3J0IGZyb206JyxcbiAgICAgICAgZHJvcFBhc3RlSW1wb3J0Qm90aDogJ0Ryb3AgZmlsZXMgaGVyZSwgJXticm93c2VGaWxlc30sICV7YnJvd3NlRm9sZGVyc30gb3IgaW1wb3J0IGZyb206JyxcbiAgICAgICAgaW1wb3J0RmlsZXM6ICdJbXBvcnQgZmlsZXMgZnJvbTonLFxuICAgICAgICBkcm9wSGludDogJ0Ryb3AgeW91ciBmaWxlcyBoZXJlJyxcbiAgICAgICAgYnJvd3NlRmlsZXM6ICdicm93c2UgZmlsZXMnLFxuICAgICAgICBicm93c2VGb2xkZXJzOiAnYnJvd3NlIGZvbGRlcnMnLFxuICAgICAgICB1cGxvYWRDb21wbGV0ZTogJ1VwbG9hZCBjb21wbGV0ZScsXG4gICAgICAgIHVwbG9hZFBhdXNlZDogJ1VwbG9hZCBwYXVzZWQnLFxuICAgICAgICByZXN1bWVVcGxvYWQ6ICdSZXN1bWUgdXBsb2FkJyxcbiAgICAgICAgcGF1c2VVcGxvYWQ6ICdQYXVzZSB1cGxvYWQnLFxuICAgICAgICByZXRyeVVwbG9hZDogJ1JldHJ5IHVwbG9hZCcsXG4gICAgICAgIGNhbmNlbFVwbG9hZDogJ0NhbmNlbCB1cGxvYWQnLFxuICAgICAgICB4RmlsZXNTZWxlY3RlZDoge1xuICAgICAgICAgIDA6ICcle3NtYXJ0X2NvdW50fSBmaWxlIHNlbGVjdGVkJyxcbiAgICAgICAgICAxOiAnJXtzbWFydF9jb3VudH0gZmlsZXMgc2VsZWN0ZWQnLFxuICAgICAgICB9LFxuICAgICAgICB1cGxvYWRpbmdYRmlsZXM6IHtcbiAgICAgICAgICAwOiAnVXBsb2FkaW5nICV7c21hcnRfY291bnR9IGZpbGUnLFxuICAgICAgICAgIDE6ICdVcGxvYWRpbmcgJXtzbWFydF9jb3VudH0gZmlsZXMnLFxuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzaW5nWEZpbGVzOiB7XG4gICAgICAgICAgMDogJ1Byb2Nlc3NpbmcgJXtzbWFydF9jb3VudH0gZmlsZScsXG4gICAgICAgICAgMTogJ1Byb2Nlc3NpbmcgJXtzbWFydF9jb3VudH0gZmlsZXMnLFxuICAgICAgICB9LFxuICAgICAgICByZWNvdmVyZWRYRmlsZXM6IHtcbiAgICAgICAgICAwOiAnV2UgY291bGQgbm90IGZ1bGx5IHJlY292ZXIgMSBmaWxlLiBQbGVhc2UgcmUtc2VsZWN0IGl0IGFuZCByZXN1bWUgdGhlIHVwbG9hZC4nLFxuICAgICAgICAgIDE6ICdXZSBjb3VsZCBub3QgZnVsbHkgcmVjb3ZlciAle3NtYXJ0X2NvdW50fSBmaWxlcy4gUGxlYXNlIHJlLXNlbGVjdCB0aGVtIGFuZCByZXN1bWUgdGhlIHVwbG9hZC4nLFxuICAgICAgICB9LFxuICAgICAgICByZWNvdmVyZWRBbGxGaWxlczogJ1dlIHJlc3RvcmVkIGFsbCBmaWxlcy4gWW91IGNhbiBub3cgcmVzdW1lIHRoZSB1cGxvYWQuJyxcbiAgICAgICAgc2Vzc2lvblJlc3RvcmVkOiAnU2Vzc2lvbiByZXN0b3JlZCcsXG4gICAgICAgIHJlU2VsZWN0OiAnUmUtc2VsZWN0JyxcbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgYHBvd2VyZWRCeTJgIHN0cmluZyBvbmx5IGNvbWJpbmVzIHRoZSBgcG93ZXJlZEJ5YCBzdHJpbmcgKCV7YmFja3dhcmRzQ29tcGF0fSkgd2l0aCB0aGUgc2l6ZS5cbiAgICAgICAgLy8gTG9jYWxlcyBjYW4gb3ZlcnJpZGUgYHBvd2VyZWRCeTJgIHRvIHNwZWNpZnkgYSBkaWZmZXJlbnQgd29yZCBvcmRlci4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoXG4gICAgICAgIC8vIFVwcHkgMS45LnggYW5kIGJlbG93IHdoaWNoIGRpZCBhIG5haXZlIGNvbmNhdGVuYXRpb24gb2YgYHBvd2VyZWRCeTIgKyBzaXplYCBpbnN0ZWFkIG9mIHVzaW5nIGEgbG9jYWxlLXNwZWNpZmljXG4gICAgICAgIC8vIHN1YnN0aXR1dGlvbi5cbiAgICAgICAgLy8gVE9ETzogSW4gMi4wIGBwb3dlcmVkQnkyYCBzaG91bGQgYmUgcmVtb3ZlZCBpbiBhbmQgYHBvd2VyZWRCeWAgdXBkYXRlZCB0byB1c2Ugc3Vic3RpdHV0aW9uLlxuICAgICAgICBwb3dlcmVkQnkyOiAnJXtiYWNrd2FyZHNDb21wYXR9ICV7dXBweX0nLFxuICAgICAgICBwb3dlcmVkQnk6ICdQb3dlcmVkIGJ5JyxcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdGFyZ2V0OiAnYm9keScsXG4gICAgICBtZXRhRmllbGRzOiBbXSxcbiAgICAgIHRyaWdnZXI6ICcjdXBweS1zZWxlY3QtZmlsZXMnLFxuICAgICAgaW5saW5lOiBmYWxzZSxcbiAgICAgIHdpZHRoOiA3NTAsXG4gICAgICBoZWlnaHQ6IDU1MCxcbiAgICAgIHRodW1ibmFpbFdpZHRoOiAyODAsXG4gICAgICB0aHVtYm5haWxUeXBlOiAnaW1hZ2UvanBlZycsXG4gICAgICB3YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZDogZmFsc2UsXG4gICAgICBkZWZhdWx0UGlja2VySWNvbixcbiAgICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0OiB0cnVlLFxuICAgICAgc2hvd1Byb2dyZXNzRGV0YWlsczogZmFsc2UsXG4gICAgICBoaWRlVXBsb2FkQnV0dG9uOiBmYWxzZSxcbiAgICAgIGhpZGVDYW5jZWxCdXR0b246IGZhbHNlLFxuICAgICAgaGlkZVJldHJ5QnV0dG9uOiBmYWxzZSxcbiAgICAgIGhpZGVQYXVzZVJlc3VtZUJ1dHRvbjogZmFsc2UsXG4gICAgICBoaWRlUHJvZ3Jlc3NBZnRlckZpbmlzaDogZmFsc2UsXG4gICAgICBkb25lQnV0dG9uSGFuZGxlcjogKCkgPT4ge1xuICAgICAgICB0aGlzLnVwcHkucmVzZXQoKVxuICAgICAgICB0aGlzLnJlcXVlc3RDbG9zZU1vZGFsKClcbiAgICAgIH0sXG4gICAgICBub3RlOiBudWxsLFxuICAgICAgY2xvc2VNb2RhbE9uQ2xpY2tPdXRzaWRlOiBmYWxzZSxcbiAgICAgIGNsb3NlQWZ0ZXJGaW5pc2g6IGZhbHNlLFxuICAgICAgZGlzYWJsZVN0YXR1c0JhcjogZmFsc2UsXG4gICAgICBkaXNhYmxlSW5mb3JtZXI6IGZhbHNlLFxuICAgICAgZGlzYWJsZVRodW1ibmFpbEdlbmVyYXRvcjogZmFsc2UsXG4gICAgICBkaXNhYmxlUGFnZVNjcm9sbFdoZW5Nb2RhbE9wZW46IHRydWUsXG4gICAgICBhbmltYXRlT3BlbkNsb3NlOiB0cnVlLFxuICAgICAgZmlsZU1hbmFnZXJTZWxlY3Rpb25UeXBlOiAnZmlsZXMnLFxuICAgICAgcHJvdWRseURpc3BsYXlQb3dlcmVkQnlVcHB5OiB0cnVlLFxuICAgICAgb25SZXF1ZXN0Q2xvc2VNb2RhbDogKCkgPT4gdGhpcy5jbG9zZU1vZGFsKCksXG4gICAgICBzaG93U2VsZWN0ZWRGaWxlczogdHJ1ZSxcbiAgICAgIHNob3dSZW1vdmVCdXR0b25BZnRlckNvbXBsZXRlOiBmYWxzZSxcbiAgICAgIGJyb3dzZXJCYWNrQnV0dG9uQ2xvc2U6IGZhbHNlLFxuICAgICAgdGhlbWU6ICdsaWdodCcsXG4gICAgICBhdXRvT3BlbkZpbGVFZGl0b3I6IGZhbHNlLFxuICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgZGlzYWJsZUxvY2FsRmlsZXM6IGZhbHNlLFxuICAgIH1cblxuICAgIC8vIG1lcmdlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBvbmVzIHNldCBieSB1c2VyXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcblxuICAgIHRoaXMuc3VwZXJGb2N1cyA9IGNyZWF0ZVN1cGVyRm9jdXMoKVxuICAgIHRoaXMuaWZGb2N1c2VkT25VcHB5UmVjZW50bHkgPSBmYWxzZVxuXG4gICAgLy8gVGltZW91dHNcbiAgICB0aGlzLm1ha2VEYXNoYm9hcmRJbnNpZGVzVmlzaWJsZUFueXdheVRpbWVvdXQgPSBudWxsXG4gICAgdGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dCA9IG51bGxcbiAgfVxuXG4gIHNldE9wdGlvbnMgPSAobmV3T3B0cykgPT4ge1xuICAgIHN1cGVyLnNldE9wdGlvbnMobmV3T3B0cylcbiAgICB0aGlzLmkxOG5Jbml0KClcbiAgfVxuXG4gIGkxOG5Jbml0ID0gKCkgPT4ge1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKFt0aGlzLmRlZmF1bHRMb2NhbGUsIHRoaXMudXBweS5sb2NhbGUsIHRoaXMub3B0cy5sb2NhbGVdKVxuICAgIHRoaXMuaTE4biA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5pMThuQXJyYXkgPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlQXJyYXkuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyBhbmQgd2Ugc2VlIHRoZSB1cGRhdGVkIGxvY2FsZVxuICB9XG5cbiAgcmVtb3ZlVGFyZ2V0ID0gKHBsdWdpbikgPT4ge1xuICAgIGNvbnN0IHBsdWdpblN0YXRlID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgLy8gZmlsdGVyIG91dCB0aGUgb25lIHdlIHdhbnQgdG8gcmVtb3ZlXG4gICAgY29uc3QgbmV3VGFyZ2V0cyA9IHBsdWdpblN0YXRlLnRhcmdldHMuZmlsdGVyKHRhcmdldCA9PiB0YXJnZXQuaWQgIT09IHBsdWdpbi5pZClcblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgdGFyZ2V0czogbmV3VGFyZ2V0cyxcbiAgICB9KVxuICB9XG5cbiAgYWRkVGFyZ2V0ID0gKHBsdWdpbikgPT4ge1xuICAgIGNvbnN0IGNhbGxlclBsdWdpbklkID0gcGx1Z2luLmlkIHx8IHBsdWdpbi5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgY29uc3QgY2FsbGVyUGx1Z2luTmFtZSA9IHBsdWdpbi50aXRsZSB8fCBjYWxsZXJQbHVnaW5JZFxuICAgIGNvbnN0IGNhbGxlclBsdWdpblR5cGUgPSBwbHVnaW4udHlwZVxuXG4gICAgaWYgKGNhbGxlclBsdWdpblR5cGUgIT09ICdhY3F1aXJlcidcbiAgICAgICAgJiYgY2FsbGVyUGx1Z2luVHlwZSAhPT0gJ3Byb2dyZXNzaW5kaWNhdG9yJ1xuICAgICAgICAmJiBjYWxsZXJQbHVnaW5UeXBlICE9PSAnZWRpdG9yJykge1xuICAgICAgY29uc3QgbXNnID0gJ0Rhc2hib2FyZDogY2FuIG9ubHkgYmUgdGFyZ2V0ZWQgYnkgcGx1Z2lucyBvZiB0eXBlczogYWNxdWlyZXIsIHByb2dyZXNzaW5kaWNhdG9yLCBlZGl0b3InXG4gICAgICB0aGlzLnVwcHkubG9nKG1zZywgJ2Vycm9yJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IHtcbiAgICAgIGlkOiBjYWxsZXJQbHVnaW5JZCxcbiAgICAgIG5hbWU6IGNhbGxlclBsdWdpbk5hbWUsXG4gICAgICB0eXBlOiBjYWxsZXJQbHVnaW5UeXBlLFxuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgbmV3VGFyZ2V0cyA9IHN0YXRlLnRhcmdldHMuc2xpY2UoKVxuICAgIG5ld1RhcmdldHMucHVzaCh0YXJnZXQpXG5cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIHRhcmdldHM6IG5ld1RhcmdldHMsXG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzLmVsXG4gIH1cblxuICBoaWRlQWxsUGFuZWxzID0gKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHtcbiAgICAgIGFjdGl2ZVBpY2tlclBhbmVsOiBmYWxzZSxcbiAgICAgIHNob3dBZGRGaWxlc1BhbmVsOiBmYWxzZSxcbiAgICAgIGFjdGl2ZU92ZXJsYXlUeXBlOiBudWxsLFxuICAgICAgZmlsZUNhcmRGb3I6IG51bGwsXG4gICAgICBzaG93RmlsZUVkaXRvcjogZmFsc2UsXG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGlmIChjdXJyZW50LmFjdGl2ZVBpY2tlclBhbmVsID09PSB1cGRhdGUuYWN0aXZlUGlja2VyUGFuZWxcbiAgICAgICAgJiYgY3VycmVudC5zaG93QWRkRmlsZXNQYW5lbCA9PT0gdXBkYXRlLnNob3dBZGRGaWxlc1BhbmVsXG4gICAgICAgICYmIGN1cnJlbnQuc2hvd0ZpbGVFZGl0b3IgPT09IHVwZGF0ZS5zaG93RmlsZUVkaXRvclxuICAgICAgICAmJiBjdXJyZW50LmFjdGl2ZU92ZXJsYXlUeXBlID09PSB1cGRhdGUuYWN0aXZlT3ZlcmxheVR5cGUpIHtcbiAgICAgIC8vIGF2b2lkIGRvaW5nIGEgc3RhdGUgdXBkYXRlIGlmIG5vdGhpbmcgY2hhbmdlZFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh1cGRhdGUpXG4gIH1cblxuICBzaG93UGFuZWwgPSAoaWQpID0+IHtcbiAgICBjb25zdCB7IHRhcmdldHMgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgY29uc3QgYWN0aXZlUGlja2VyUGFuZWwgPSB0YXJnZXRzLmZpbHRlcigodGFyZ2V0KSA9PiB7XG4gICAgICByZXR1cm4gdGFyZ2V0LnR5cGUgPT09ICdhY3F1aXJlcicgJiYgdGFyZ2V0LmlkID09PSBpZFxuICAgIH0pWzBdXG5cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGFjdGl2ZVBpY2tlclBhbmVsLFxuICAgICAgYWN0aXZlT3ZlcmxheVR5cGU6ICdQaWNrZXJQYW5lbCcsXG4gICAgfSlcbiAgfVxuXG4gIGNhbkVkaXRGaWxlID0gKGZpbGUpID0+IHtcbiAgICBjb25zdCB7IHRhcmdldHMgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IGVkaXRvcnMgPSB0aGlzLl9nZXRFZGl0b3JzKHRhcmdldHMpXG5cbiAgICByZXR1cm4gZWRpdG9ycy5zb21lKCh0YXJnZXQpID0+IChcbiAgICAgIHRoaXMudXBweS5nZXRQbHVnaW4odGFyZ2V0LmlkKS5jYW5FZGl0RmlsZShmaWxlKVxuICAgICkpXG4gIH1cblxuICBvcGVuRmlsZUVkaXRvciA9IChmaWxlKSA9PiB7XG4gICAgY29uc3QgeyB0YXJnZXRzIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBlZGl0b3JzID0gdGhpcy5fZ2V0RWRpdG9ycyh0YXJnZXRzKVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBzaG93RmlsZUVkaXRvcjogdHJ1ZSxcbiAgICAgIGZpbGVDYXJkRm9yOiBmaWxlLmlkIHx8IG51bGwsXG4gICAgICBhY3RpdmVPdmVybGF5VHlwZTogJ0ZpbGVFZGl0b3InLFxuICAgIH0pXG5cbiAgICBlZGl0b3JzLmZvckVhY2goKGVkaXRvcikgPT4ge1xuICAgICAgdGhpcy51cHB5LmdldFBsdWdpbihlZGl0b3IuaWQpLnNlbGVjdEZpbGUoZmlsZSlcbiAgICB9KVxuICB9XG5cbiAgc2F2ZUZpbGVFZGl0b3IgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB0YXJnZXRzIH0gPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBlZGl0b3JzID0gdGhpcy5fZ2V0RWRpdG9ycyh0YXJnZXRzKVxuXG4gICAgZWRpdG9ycy5mb3JFYWNoKChlZGl0b3IpID0+IHtcbiAgICAgIHRoaXMudXBweS5nZXRQbHVnaW4oZWRpdG9yLmlkKS5zYXZlKClcbiAgICB9KVxuXG4gICAgdGhpcy5oaWRlQWxsUGFuZWxzKClcbiAgfVxuXG4gIG9wZW5Nb2RhbCA9ICgpID0+IHtcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZVByb21pc2UoKVxuICAgIC8vIHNhdmUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgdGhpcy5zYXZlZFNjcm9sbFBvc2l0aW9uID0gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgLy8gc2F2ZSBhY3RpdmUgZWxlbWVudCwgc28gd2UgY2FuIHJlc3RvcmUgZm9jdXMgd2hlbiBtb2RhbCBpcyBjbG9zZWRcbiAgICB0aGlzLnNhdmVkQWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcblxuICAgIGlmICh0aGlzLm9wdHMuZGlzYWJsZVBhZ2VTY3JvbGxXaGVuTW9kYWxPcGVuKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ3VwcHktRGFzaGJvYXJkLWlzRml4ZWQnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdHMuYW5pbWF0ZU9wZW5DbG9zZSAmJiB0aGlzLmdldFBsdWdpblN0YXRlKCkuaXNDbG9zaW5nKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICBpc0hpZGRlbjogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgaGFuZGxlciwgZmFsc2UpXG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfVxuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCBoYW5kbGVyLCBmYWxzZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGlzSGlkZGVuOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgICByZXNvbHZlKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmJyb3dzZXJCYWNrQnV0dG9uQ2xvc2UpIHtcbiAgICAgIHRoaXMudXBkYXRlQnJvd3Nlckhpc3RvcnkoKVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSBFU0MgYW5kIFRBQiBrZXlzIGluIG1vZGFsIGRpYWxvZ1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd25Jbk1vZGFsKVxuXG4gICAgdGhpcy51cHB5LmVtaXQoJ2Rhc2hib2FyZDptb2RhbC1vcGVuJylcblxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBjbG9zZU1vZGFsID0gKG9wdHMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG1hbnVhbENsb3NlID0gdHJ1ZSwgLy8gV2hldGhlciB0aGUgbW9kYWwgaXMgYmVpbmcgY2xvc2VkIGJ5IHRoZSB1c2VyIChgdHJ1ZWApIG9yIGJ5IG90aGVyIG1lYW5zIChlLmcuIGJyb3dzZXIgYmFjayBidXR0b24pXG4gICAgfSA9IG9wdHNcblxuICAgIGNvbnN0IHsgaXNIaWRkZW4sIGlzQ2xvc2luZyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgaWYgKGlzSGlkZGVuIHx8IGlzQ2xvc2luZykge1xuICAgICAgLy8gc2hvcnQtY2lyY3VpdCBpZiBhbmltYXRpb24gaXMgb25nb2luZ1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBjcmVhdGVQcm9taXNlKClcblxuICAgIGlmICh0aGlzLm9wdHMuZGlzYWJsZVBhZ2VTY3JvbGxXaGVuTW9kYWxPcGVuKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ3VwcHktRGFzaGJvYXJkLWlzRml4ZWQnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdHMuYW5pbWF0ZU9wZW5DbG9zZSkge1xuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGlzQ2xvc2luZzogdHJ1ZSxcbiAgICAgIH0pXG4gICAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICBpc0hpZGRlbjogdHJ1ZSxcbiAgICAgICAgICBpc0Nsb3Npbmc6IGZhbHNlLFxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuc3VwZXJGb2N1cy5jYW5jZWwoKVxuICAgICAgICB0aGlzLnNhdmVkQWN0aXZlRWxlbWVudC5mb2N1cygpXG5cbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCBoYW5kbGVyLCBmYWxzZSlcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIGhhbmRsZXIsIGZhbHNlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgaXNIaWRkZW46IHRydWUsXG4gICAgICB9KVxuXG4gICAgICB0aGlzLnN1cGVyRm9jdXMuY2FuY2VsKClcbiAgICAgIHRoaXMuc2F2ZWRBY3RpdmVFbGVtZW50LmZvY3VzKClcblxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIEVTQyBhbmQgVEFCIGtleXMgaW4gbW9kYWwgZGlhbG9nXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bkluTW9kYWwpXG5cbiAgICBpZiAobWFudWFsQ2xvc2UpIHtcbiAgICAgIGlmICh0aGlzLm9wdHMuYnJvd3NlckJhY2tCdXR0b25DbG9zZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgbGF0ZXN0IGVudHJ5IGluIHRoZSBoaXN0b3J5IHN0YXRlIGlzIG91ciBtb2RhbCBuYW1lXG4gICAgICAgIGlmIChoaXN0b3J5LnN0YXRlICYmIGhpc3Rvcnkuc3RhdGVbdGhpcy5tb2RhbE5hbWVdKSB7XG4gICAgICAgICAgLy8gR28gYmFjayBpbiBoaXN0b3J5IHRvIGNsZWFyIG91dCB0aGUgZW50cnkgd2UgY3JlYXRlZCAodWx0aW1hdGVseSBjbG9zaW5nIHRoZSBtb2RhbClcbiAgICAgICAgICBoaXN0b3J5LmdvKC0xKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cHB5LmVtaXQoJ2Rhc2hib2FyZDptb2RhbC1jbG9zZWQnKVxuXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGlzTW9kYWxPcGVuID0gKCkgPT4ge1xuICAgIHJldHVybiAhdGhpcy5nZXRQbHVnaW5TdGF0ZSgpLmlzSGlkZGVuIHx8IGZhbHNlXG4gIH1cblxuICByZXF1ZXN0Q2xvc2VNb2RhbCA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5vcHRzLm9uUmVxdWVzdENsb3NlTW9kYWwpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdHMub25SZXF1ZXN0Q2xvc2VNb2RhbCgpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb3NlTW9kYWwoKVxuICB9XG5cbiAgc2V0RGFya01vZGVDYXBhYmlsaXR5ID0gKGlzRGFya01vZGVPbikgPT4ge1xuICAgIGNvbnN0IHsgY2FwYWJpbGl0aWVzIH0gPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuICAgIHRoaXMudXBweS5zZXRTdGF0ZSh7XG4gICAgICBjYXBhYmlsaXRpZXM6IHtcbiAgICAgICAgLi4uY2FwYWJpbGl0aWVzLFxuICAgICAgICBkYXJrTW9kZTogaXNEYXJrTW9kZU9uLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlU3lzdGVtRGFya01vZGVDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBpc0RhcmtNb2RlT25Ob3cgPSBldmVudC5tYXRjaGVzXG4gICAgdGhpcy51cHB5LmxvZyhgW0Rhc2hib2FyZF0gRGFyayBtb2RlIGlzICR7aXNEYXJrTW9kZU9uTm93ID8gJ29uJyA6ICdvZmYnfWApXG4gICAgdGhpcy5zZXREYXJrTW9kZUNhcGFiaWxpdHkoaXNEYXJrTW9kZU9uTm93KVxuICB9XG5cbiAgdG9nZ2xlRmlsZUNhcmQgPSAoc2hvdywgZmlsZUlEKSA9PiB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRClcbiAgICBpZiAoc2hvdykge1xuICAgICAgdGhpcy51cHB5LmVtaXQoJ2Rhc2hib2FyZDpmaWxlLWVkaXQtc3RhcnQnLCBmaWxlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwcHkuZW1pdCgnZGFzaGJvYXJkOmZpbGUtZWRpdC1jb21wbGV0ZScsIGZpbGUpXG4gICAgfVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBmaWxlQ2FyZEZvcjogc2hvdyA/IGZpbGVJRCA6IG51bGwsXG4gICAgICBhY3RpdmVPdmVybGF5VHlwZTogc2hvdyA/ICdGaWxlQ2FyZCcgOiBudWxsLFxuICAgIH0pXG4gIH1cblxuICB0b2dnbGVBZGRGaWxlc1BhbmVsID0gKHNob3cpID0+IHtcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIHNob3dBZGRGaWxlc1BhbmVsOiBzaG93LFxuICAgICAgYWN0aXZlT3ZlcmxheVR5cGU6IHNob3cgPyAnQWRkRmlsZXMnIDogbnVsbCxcbiAgICB9KVxuICB9XG5cbiAgYWRkRmlsZXMgPSAoZmlsZXMpID0+IHtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IGZpbGVzLm1hcCgoZmlsZSkgPT4gKHtcbiAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgIGRhdGE6IGZpbGUsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC8vIHBhdGggb2YgdGhlIGZpbGUgcmVsYXRpdmUgdG8gdGhlIGFuY2VzdG9yIGRpcmVjdG9yeSB0aGUgdXNlciBzZWxlY3RlZC5cbiAgICAgICAgLy8gZS5nLiAnZG9jcy9PbGQgUHJhZ3VlL2FpcmJuYi5wZGYnXG4gICAgICAgIHJlbGF0aXZlUGF0aDogZmlsZS5yZWxhdGl2ZVBhdGggfHwgbnVsbCxcbiAgICAgIH0sXG4gICAgfSkpXG5cbiAgICB0cnkge1xuICAgICAgdGhpcy51cHB5LmFkZEZpbGVzKGRlc2NyaXB0b3JzKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgfVxuICB9XG5cbiAgLy8gX19fV2h5IG1ha2UgaW5zaWRlcyBvZiBEYXNoYm9hcmQgaW52aXNpYmxlIHVudGlsIGZpcnN0IFJlc2l6ZU9ic2VydmVyIGV2ZW50IGlzIGVtaXR0ZWQ/XG4gIC8vICAgIFJlc2l6ZU9iZXJzZXJ2ZXIgZG9lc24ndCBlbWl0IHRoZSBmaXJzdCByZXNpemUgZXZlbnQgZmFzdCBlbm91Z2gsIHVzZXJzIGNhbiBzZWUgdGhlIGp1bXAgZnJvbSBvbmUgLnVwcHktc2l6ZS0tIHRvIGFub3RoZXIgKGUuZy4gaW4gU2FmYXJpKVxuICAvLyBfX19XaHkgbm90IGFwcGx5IHZpc2liaWxpdHkgcHJvcGVydHkgdG8gLnVwcHktRGFzaGJvYXJkLWlubmVyP1xuICAvLyAgICBCZWNhdXNlIGlkZWFsbHksIGFjYyB0byBzcGVjcywgUmVzaXplT2JzZXJ2ZXIgc2hvdWxkIHNlZSBpbnZpc2libGUgZWxlbWVudHMgYXMgb2Ygd2lkdGggMC4gU28gZXZlbiB0aG91Z2ggYXBwbHlpbmcgaW52aXNpYmlsaXR5IHRvIC51cHB5LURhc2hib2FyZC1pbm5lciB3b3JrcyBub3csIGl0IG1heSBub3Qgd29yayBpbiB0aGUgZnV0dXJlLlxuICBzdGFydExpc3RlbmluZ1RvUmVzaXplID0gKCkgPT4ge1xuICAgIC8vIFdhdGNoIGZvciBEYXNoYm9hcmQgY29udGFpbmVyIChgLnVwcHktRGFzaGJvYXJkLWlubmVyYCkgcmVzaXplXG4gICAgLy8gYW5kIHVwZGF0ZSBjb250YWluZXJXaWR0aC9jb250YWluZXJIZWlnaHQgaW4gcGx1Z2luIHN0YXRlIGFjY29yZGluZ2x5LlxuICAgIC8vIEVtaXRzIGZpcnN0IGV2ZW50IG9uIGluaXRpYWxpemF0aW9uLlxuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICBjb25zdCB1cHB5RGFzaGJvYXJkSW5uZXJFbCA9IGVudHJpZXNbMF1cblxuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB1cHB5RGFzaGJvYXJkSW5uZXJFbC5jb250ZW50UmVjdFxuXG4gICAgICB0aGlzLnVwcHkubG9nKGBbRGFzaGJvYXJkXSByZXNpemVkOiAke3dpZHRofSAvICR7aGVpZ2h0fWAsICdkZWJ1ZycpXG5cbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBjb250YWluZXJXaWR0aDogd2lkdGgsXG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogaGVpZ2h0LFxuICAgICAgICBhcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZTogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcudXBweS1EYXNoYm9hcmQtaW5uZXInKSlcblxuICAgIC8vIElmIFJlc2l6ZU9ic2VydmVyIGZhaWxzIHRvIGVtaXQgYW4gZXZlbnQgdGVsbGluZyB1cyB3aGF0IHNpemUgdG8gdXNlIC0gZGVmYXVsdCB0byB0aGUgbW9iaWxlIHZpZXdcbiAgICB0aGlzLm1ha2VEYXNoYm9hcmRJbnNpZGVzVmlzaWJsZUFueXdheVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IHBsdWdpblN0YXRlID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgICBjb25zdCBpc01vZGFsQW5kQ2xvc2VkID0gIXRoaXMub3B0cy5pbmxpbmUgJiYgcGx1Z2luU3RhdGUuaXNIaWRkZW5cbiAgICAgIGlmIChcbiAgICAgICAgLy8gaWYgUmVzaXplT2JzZXJ2ZXIgaGFzbid0IHlldCBmaXJlZCxcbiAgICAgICAgIXBsdWdpblN0YXRlLmFyZUluc2lkZXNSZWFkeVRvQmVWaXNpYmxlXG4gICAgICAgIC8vIGFuZCBpdCdzIG5vdCBkdWUgdG8gdGhlIG1vZGFsIGJlaW5nIGNsb3NlZFxuICAgICAgICAmJiAhaXNNb2RhbEFuZENsb3NlZFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMudXBweS5sb2coXCJbRGFzaGJvYXJkXSByZXNpemUgZXZlbnQgZGlkbid0IGZpcmUgb24gdGltZTogZGVmYXVsdGVkIHRvIG1vYmlsZSBsYXlvdXRcIiwgJ2RlYnVnJylcblxuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICBhcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LCAxMDAwKVxuICB9XG5cbiAgc3RvcExpc3RlbmluZ1RvUmVzaXplID0gKCkgPT4ge1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5tYWtlRGFzaGJvYXJkSW5zaWRlc1Zpc2libGVBbnl3YXlUaW1lb3V0KVxuICB9XG5cbiAgLy8gUmVjb3JkcyB3aGV0aGVyIHdlIGhhdmUgYmVlbiBpbnRlcmFjdGluZyB3aXRoIHVwcHkgcmlnaHQgbm93LCB3aGljaCBpcyB0aGVuIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgc3RhdGUgdXBkYXRlcyBzaG91bGQgdHJpZ2dlciBhIHJlZm9jdXNpbmcuXG4gIHJlY29yZElmRm9jdXNlZE9uVXBweVJlY2VudGx5ID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKHRoaXMuZWwuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseSA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseSA9IGZhbHNlXG4gICAgICAvLyBfX19XaHkgcnVuIHRoaXMuc3VwZXJGb2N1cy5jYW5jZWwgaGVyZSB3aGVuIGl0IGFscmVhZHkgcnVucyBpbiBzdXBlckZvY3VzT25FYWNoVXBkYXRlP1xuICAgICAgLy8gICAgQmVjYXVzZSBzdXBlckZvY3VzIGlzIGRlYm91bmNlZCwgd2hlbiB3ZSBtb3ZlIGZyb20gVXBweSB0byBzb21lIG90aGVyIGVsZW1lbnQgb24gdGhlIHBhZ2UsXG4gICAgICAvLyAgICBwcmV2aW91c2x5IHJ1biBzdXBlckZvY3VzIHNvbWV0aW1lcyBoaXRzIGFuZCBtb3ZlcyBmb2N1cyBiYWNrIHRvIFVwcHkuXG4gICAgICB0aGlzLnN1cGVyRm9jdXMuY2FuY2VsKClcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlQWxsRm9jdXNhYmxlRWxlbWVudHMgPSAoZGlzYWJsZSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzYWJsZU5vZGVzID0gdG9BcnJheSh0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoRk9DVVNBQkxFX0VMRU1FTlRTKSlcbiAgICBpZiAoZGlzYWJsZSkge1xuICAgICAgZm9jdXNhYmxlTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAvLyBzYXZlIHByZXZpb3VzIHRhYmluZGV4IGluIGEgZGF0YS1hdHRyaWJ1dGUsIHRvIHJlc3RvcmUgd2hlbiBlbmFibGluZ1xuICAgICAgICBjb25zdCBjdXJyZW50VGFiSW5kZXggPSBub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKVxuICAgICAgICBpZiAoY3VycmVudFRhYkluZGV4KSB7XG4gICAgICAgICAgbm9kZS5kYXRhc2V0LmluZXJ0VGFiaW5kZXggPSBjdXJyZW50VGFiSW5kZXhcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZm9jdXNhYmxlTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAoJ2luZXJ0VGFiaW5kZXgnIGluIG5vZGUuZGF0YXNldCkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIG5vZGUuZGF0YXNldC5pbmVydFRhYmluZGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMuZGFzaGJvYXJkSXNEaXNhYmxlZCA9IGRpc2FibGVcbiAgfVxuXG4gIHVwZGF0ZUJyb3dzZXJIaXN0b3J5ID0gKCkgPT4ge1xuICAgIC8vIEVuc3VyZSBoaXN0b3J5IHN0YXRlIGRvZXMgbm90IGFscmVhZHkgY29udGFpbiBvdXIgbW9kYWwgbmFtZSB0byBhdm9pZCBkb3VibGUtcHVzaGluZ1xuICAgIGlmICghaGlzdG9yeS5zdGF0ZSB8fCAhaGlzdG9yeS5zdGF0ZVt0aGlzLm1vZGFsTmFtZV0pIHtcbiAgICAgIC8vIFB1c2ggdG8gaGlzdG9yeSBzbyB0aGF0IHRoZSBwYWdlIGlzIG5vdCBsb3N0IG9uIGJyb3dzZXIgYmFjayBidXR0b24gcHJlc3NcbiAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHtcbiAgICAgICAgLi4uaGlzdG9yeS5zdGF0ZSxcbiAgICAgICAgW3RoaXMubW9kYWxOYW1lXTogdHJ1ZSxcbiAgICAgIH0sICcnKVxuICAgIH1cblxuICAgIC8vIExpc3RlbiBmb3IgYmFjayBidXR0b24gcHJlc3Nlc1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuaGFuZGxlUG9wU3RhdGUsIGZhbHNlKVxuICB9XG5cbiAgaGFuZGxlUG9wU3RhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAvLyBDbG9zZSB0aGUgbW9kYWwgaWYgdGhlIGhpc3Rvcnkgc3RhdGUgbm8gbG9uZ2VyIGNvbnRhaW5zIG91ciBtb2RhbCBuYW1lXG4gICAgaWYgKHRoaXMuaXNNb2RhbE9wZW4oKSAmJiAoIWV2ZW50LnN0YXRlIHx8ICFldmVudC5zdGF0ZVt0aGlzLm1vZGFsTmFtZV0pKSB7XG4gICAgICB0aGlzLmNsb3NlTW9kYWwoeyBtYW51YWxDbG9zZTogZmFsc2UgfSlcbiAgICB9XG5cbiAgICAvLyBXaGVuIHRoZSBicm93c2VyIGJhY2sgYnV0dG9uIGlzIHByZXNzZWQgYW5kIHVwcHkgaXMgbm93IHRoZSBsYXRlc3QgZW50cnkgaW4gdGhlIGhpc3RvcnkgYnV0IHRoZSBtb2RhbCBpcyBjbG9zZWQsIGZpeCB0aGUgaGlzdG9yeSBieSByZW1vdmluZyB0aGUgdXBweSBoaXN0b3J5IGVudHJ5XG4gICAgLy8gVGhpcyBvY2N1cnMgd2hlbiBhbm90aGVyIGVudHJ5IGlzIGFkZGVkIGludG8gdGhlIGhpc3Rvcnkgc3RhdGUgd2hpbGUgdGhlIG1vZGFsIGlzIG9wZW4sIGFuZCB0aGVuIHRoZSBtb2RhbCBnZXRzIG1hbnVhbGx5IGNsb3NlZFxuICAgIC8vIFNvbHZlcyBQUiAjNTc1IChodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9wdWxsLzU3NSlcbiAgICBpZiAoIXRoaXMuaXNNb2RhbE9wZW4oKSAmJiBldmVudC5zdGF0ZSAmJiBldmVudC5zdGF0ZVt0aGlzLm1vZGFsTmFtZV0pIHtcbiAgICAgIGhpc3RvcnkuZ28oLTEpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlS2V5RG93bkluTW9kYWwgPSAoZXZlbnQpID0+IHtcbiAgICAvLyBjbG9zZSBtb2RhbCBvbiBlc2Mga2V5IHByZXNzXG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ19LRVkpIHRoaXMucmVxdWVzdENsb3NlTW9kYWwoZXZlbnQpXG4gICAgLy8gdHJhcCBmb2N1cyBvbiB0YWIga2V5IHByZXNzXG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IFRBQl9LRVkpIHRyYXBGb2N1cy5mb3JNb2RhbChldmVudCwgdGhpcy5nZXRQbHVnaW5TdGF0ZSgpLmFjdGl2ZU92ZXJsYXlUeXBlLCB0aGlzLmVsKVxuICB9XG5cbiAgaGFuZGxlQ2xpY2tPdXRzaWRlID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLm9wdHMuY2xvc2VNb2RhbE9uQ2xpY2tPdXRzaWRlKSB0aGlzLnJlcXVlc3RDbG9zZU1vZGFsKClcbiAgfVxuXG4gIGhhbmRsZVBhc3RlID0gKGV2ZW50KSA9PiB7XG4gICAgLy8gMS4gTGV0IGFueSBhY3F1aXJlciBwbHVnaW4gKFVybC9XZWJjYW0vZXRjLikgaGFuZGxlIHBhc3RlcyB0byB0aGUgcm9vdFxuICAgIHRoaXMudXBweS5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICBpZiAocGx1Z2luLnR5cGUgPT09ICdhY3F1aXJlcicpIHtcbiAgICAgICAgLy8gRXZlcnkgUGx1Z2luIHdpdGggLnR5cGUgYWNxdWlyZXIgY2FuIGRlZmluZSBoYW5kbGVSb290UGFzdGUoZXZlbnQpXG4gICAgICAgIHBsdWdpbi5oYW5kbGVSb290UGFzdGUgJiYgcGx1Z2luLmhhbmRsZVJvb3RQYXN0ZShldmVudClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gMi4gQWRkIGFsbCBkcm9wcGVkIGZpbGVzXG4gICAgY29uc3QgZmlsZXMgPSB0b0FycmF5KGV2ZW50LmNsaXBib2FyZERhdGEuZmlsZXMpXG4gICAgdGhpcy5hZGRGaWxlcyhmaWxlcylcbiAgfVxuXG4gIGhhbmRsZUlucHV0Q2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGNvbnN0IGZpbGVzID0gdG9BcnJheShldmVudC50YXJnZXQuZmlsZXMpXG4gICAgdGhpcy5hZGRGaWxlcyhmaWxlcylcbiAgfVxuXG4gIGhhbmRsZURyYWdPdmVyID0gKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBpZiAodGhpcy5vcHRzLmRpc2FibGVkIHx8IHRoaXMub3B0cy5kaXNhYmxlTG9jYWxGaWxlcykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMS4gQWRkIGEgc21hbGwgKCspIGljb24gb24gZHJvcFxuICAgIC8vIChhbmQgcHJldmVudCBicm93c2VycyBmcm9tIGludGVycHJldGluZyB0aGlzIGFzIGZpbGVzIGJlaW5nIF9tb3ZlZF8gaW50byB0aGUgYnJvd3NlciwgaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzLzE5NzgpXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSdcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0KVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyBpc0RyYWdnaW5nT3ZlcjogdHJ1ZSB9KVxuICB9XG5cbiAgaGFuZGxlRHJhZ0xlYXZlID0gKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBpZiAodGhpcy5vcHRzLmRpc2FibGVkIHx8IHRoaXMub3B0cy5kaXNhYmxlTG9jYWxGaWxlcykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVtb3ZlRHJhZ092ZXJDbGFzc1RpbWVvdXQpXG4gICAgLy8gVGltZW91dCBhZ2FpbnN0IGZsaWNrZXJpbmcsIHRoaXMgc29sdXRpb24gaXMgdGFrZW4gZnJvbSBkcmFnLWRyb3AgbGlicmFyeS4gU29sdXRpb24gd2l0aCAncG9pbnRlci1ldmVudHM6IG5vbmUnIGRpZG4ndCB3b3JrIGFjcm9zcyBicm93c2Vycy5cbiAgICB0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgaXNEcmFnZ2luZ092ZXI6IGZhbHNlIH0pXG4gICAgfSwgNTApXG4gIH1cblxuICBoYW5kbGVEcm9wID0gKGV2ZW50LCBkcm9wQ2F0ZWdvcnkpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGlmICh0aGlzLm9wdHMuZGlzYWJsZWQgfHwgdGhpcy5vcHRzLmRpc2FibGVMb2NhbEZpbGVzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dClcblxuICAgIC8vIDIuIFJlbW92ZSBkcmFnb3ZlciBjbGFzc1xuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyBpc0RyYWdnaW5nT3ZlcjogZmFsc2UgfSlcblxuICAgIC8vIDMuIExldCBhbnkgYWNxdWlyZXIgcGx1Z2luIChVcmwvV2ViY2FtL2V0Yy4pIGhhbmRsZSBkcm9wcyB0byB0aGUgcm9vdFxuICAgIHRoaXMudXBweS5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICBpZiAocGx1Z2luLnR5cGUgPT09ICdhY3F1aXJlcicpIHtcbiAgICAgICAgLy8gRXZlcnkgUGx1Z2luIHdpdGggLnR5cGUgYWNxdWlyZXIgY2FuIGRlZmluZSBoYW5kbGVSb290RHJvcChldmVudClcbiAgICAgICAgcGx1Z2luLmhhbmRsZVJvb3REcm9wICYmIHBsdWdpbi5oYW5kbGVSb290RHJvcChldmVudClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gNC4gQWRkIGFsbCBkcm9wcGVkIGZpbGVzXG4gICAgbGV0IGV4ZWN1dGVkRHJvcEVycm9yT25jZSA9IGZhbHNlXG4gICAgY29uc3QgbG9nRHJvcEVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKGVycm9yLCAnZXJyb3InKVxuXG4gICAgICAvLyBJbiBwcmFjdGljZSBhbGwgZHJvcCBlcnJvcnMgYXJlIG1vc3QgbGlrZWx5IHRoZSBzYW1lLCBzbyBsZXQncyBqdXN0IHNob3cgb25lIHRvIGF2b2lkIG92ZXJ3aGVsbWluZyB0aGUgdXNlclxuICAgICAgaWYgKCFleGVjdXRlZERyb3BFcnJvck9uY2UpIHtcbiAgICAgICAgdGhpcy51cHB5LmluZm8oZXJyb3IubWVzc2FnZSwgJ2Vycm9yJylcbiAgICAgICAgZXhlY3V0ZWREcm9wRXJyb3JPbmNlID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGdldERyb3BwZWRGaWxlcyhldmVudC5kYXRhVHJhbnNmZXIsIHsgbG9nRHJvcEVycm9yIH0pXG4gICAgICAudGhlbigoZmlsZXMpID0+IHtcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKCdbRGFzaGJvYXJkXSBGaWxlcyB3ZXJlIGRyb3BwZWQnKVxuICAgICAgICAgIHRoaXMuYWRkRmlsZXMoZmlsZXMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICBoYW5kbGVSZXF1ZXN0VGh1bWJuYWlsID0gKGZpbGUpID0+IHtcbiAgICBpZiAoIXRoaXMub3B0cy53YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZCkge1xuICAgICAgdGhpcy51cHB5LmVtaXQoJ3RodW1ibmFpbDpyZXF1ZXN0JywgZmlsZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2UgY2FuY2VsIHRodW1ibmFpbCByZXF1ZXN0cyB3aGVuIGEgZmlsZSBpdGVtIGNvbXBvbmVudCB1bm1vdW50cyB0byBhdm9pZCBjbG9nZ2luZyB1cCB0aGUgcXVldWUgd2hlbiB0aGUgdXNlciBzY3JvbGxzIHBhc3QgbWFueSBlbGVtZW50cy5cbiAgICovXG4gIGhhbmRsZUNhbmNlbFRodW1ibmFpbCA9IChmaWxlKSA9PiB7XG4gICAgaWYgKCF0aGlzLm9wdHMud2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQpIHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCd0aHVtYm5haWw6Y2FuY2VsJywgZmlsZSlcbiAgICB9XG4gIH1cblxuICBoYW5kbGVLZXlEb3duSW5JbmxpbmUgPSAoZXZlbnQpID0+IHtcbiAgICAvLyBUcmFwIGZvY3VzIG9uIHRhYiBrZXkgcHJlc3MuXG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IFRBQl9LRVkpIHRyYXBGb2N1cy5mb3JJbmxpbmUoZXZlbnQsIHRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5hY3RpdmVPdmVybGF5VHlwZSwgdGhpcy5lbClcbiAgfVxuXG4gIC8vIF9fX1doeSBkbyB3ZSBsaXN0ZW4gdG8gdGhlICdwYXN0ZScgZXZlbnQgb24gYSBkb2N1bWVudCBpbnN0ZWFkIG9mIG9uUGFzdGU9e3Byb3BzLmhhbmRsZVBhc3RlfSBwcm9wLCBvciB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJyk/XG4gIC8vICAgIEJlY2F1c2UgKGF0IGxlYXN0KSBDaHJvbWUgZG9lc24ndCBoYW5kbGUgcGFzdGUgaWYgZm9jdXMgaXMgb24gc29tZSBidXR0b24sIGUuZy4gJ015IERldmljZScuXG4gIC8vICAgID0+IFRoZXJlZm9yZSwgdGhlIGJlc3Qgb3B0aW9uIGlzIHRvIGxpc3RlbiB0byBhbGwgJ3Bhc3RlJyBldmVudHMsIGFuZCBvbmx5IHJlYWN0IHRvIHRoZW0gd2hlbiB3ZSBhcmUgZm9jdXNlZCBvbiBvdXIgcGFydGljdWxhciBVcHB5IGluc3RhbmNlLlxuICAvLyBfX19XaHkgZG8gd2Ugc3RpbGwgbmVlZCBvblBhc3RlPXtwcm9wcy5oYW5kbGVQYXN0ZX0gZm9yIHRoZSBEYXNoYm9hcmRVaT9cbiAgLy8gICAgQmVjYXVzZSBpZiB3ZSBjbGljayBvbiB0aGUgJ0Ryb3AgZmlsZXMgaGVyZScgY2FwdGlvbiBlLmcuLCBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgd2lsbCBiZSAnYm9keScuIFdoaWNoIG1lYW5zIG91ciBzdGFuZGFyZCBkZXRlcm1pbmF0aW9uIG9mIHdoZXRoZXIgd2UncmUgcGFzdGluZyBpbnRvIG91ciBVcHB5IGluc3RhbmNlIHdvbid0IHdvcmsuXG4gIC8vICAgID0+IFRoZXJlZm9yZSwgd2UgbmVlZCBhIHRyYWRpdGlvbmFsIG9uUGFzdGU9e3Byb3BzLmhhbmRsZVBhc3RlfSBoYW5kbGVyIHRvby5cbiAgaGFuZGxlUGFzdGVPbkJvZHkgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBpc0ZvY3VzSW5PdmVybGF5ID0gdGhpcy5lbC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgIGlmIChpc0ZvY3VzSW5PdmVybGF5KSB7XG4gICAgICB0aGlzLmhhbmRsZVBhc3RlKGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNvbXBsZXRlID0gKHsgZmFpbGVkIH0pID0+IHtcbiAgICBpZiAodGhpcy5vcHRzLmNsb3NlQWZ0ZXJGaW5pc2ggJiYgZmFpbGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gQWxsIHVwbG9hZHMgYXJlIGRvbmVcbiAgICAgIHRoaXMucmVxdWVzdENsb3NlTW9kYWwoKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNhbmNlbFJlc3RvcmUgPSAoKSA9PiB7XG4gICAgdGhpcy51cHB5LmVtaXQoJ3Jlc3RvcmUtY2FuY2VsZWQnKVxuICB9XG5cbiAgX29wZW5GaWxlRWRpdG9yV2hlbkZpbGVzQWRkZWQgPSAoZmlsZXMpID0+IHtcbiAgICBjb25zdCBmaXJzdEZpbGUgPSBmaWxlc1swXVxuICAgIGlmICh0aGlzLmNhbkVkaXRGaWxlKGZpcnN0RmlsZSkpIHtcbiAgICAgIHRoaXMub3BlbkZpbGVFZGl0b3IoZmlyc3RGaWxlKVxuICAgIH1cbiAgfVxuXG4gIGluaXRFdmVudHMgPSAoKSA9PiB7XG4gICAgLy8gTW9kYWwgb3BlbiBidXR0b25cbiAgICBpZiAodGhpcy5vcHRzLnRyaWdnZXIgJiYgIXRoaXMub3B0cy5pbmxpbmUpIHtcbiAgICAgIGNvbnN0IHNob3dNb2RhbFRyaWdnZXIgPSBmaW5kQWxsRE9NRWxlbWVudHModGhpcy5vcHRzLnRyaWdnZXIpXG4gICAgICBpZiAoc2hvd01vZGFsVHJpZ2dlcikge1xuICAgICAgICBzaG93TW9kYWxUcmlnZ2VyLmZvckVhY2godHJpZ2dlciA9PiB0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vcGVuTW9kYWwpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cHB5LmxvZygnRGFzaGJvYXJkIG1vZGFsIHRyaWdnZXIgbm90IGZvdW5kLiBNYWtlIHN1cmUgYHRyaWdnZXJgIGlzIHNldCBpbiBEYXNoYm9hcmQgb3B0aW9ucywgdW5sZXNzIHlvdSBhcmUgcGxhbm5pbmcgdG8gY2FsbCBgZGFzaGJvYXJkLm9wZW5Nb2RhbCgpYCBtZXRob2QgeW91cnNlbGYnLCAnd2FybmluZycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydExpc3RlbmluZ1RvUmVzaXplKClcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIHRoaXMuaGFuZGxlUGFzdGVPbkJvZHkpXG5cbiAgICB0aGlzLnVwcHkub24oJ3BsdWdpbi1yZW1vdmUnLCB0aGlzLnJlbW92ZVRhcmdldClcbiAgICB0aGlzLnVwcHkub24oJ2ZpbGUtYWRkZWQnLCB0aGlzLmhpZGVBbGxQYW5lbHMpXG4gICAgdGhpcy51cHB5Lm9uKCdkYXNoYm9hcmQ6bW9kYWwtY2xvc2VkJywgdGhpcy5oaWRlQWxsUGFuZWxzKVxuICAgIHRoaXMudXBweS5vbignZmlsZS1lZGl0b3I6Y29tcGxldGUnLCB0aGlzLmhpZGVBbGxQYW5lbHMpXG4gICAgdGhpcy51cHB5Lm9uKCdjb21wbGV0ZScsIHRoaXMuaGFuZGxlQ29tcGxldGUpXG5cbiAgICAvLyBfX19XaHkgZmlyZSBvbiBjYXB0dXJlP1xuICAgIC8vICAgIEJlY2F1c2UgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseSBuZWVkcyB0byBjaGFuZ2UgYmVmb3JlIG9uVXBkYXRlKCkgZmlyZXMuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlY29yZElmRm9jdXNlZE9uVXBweVJlY2VudGx5LCB0cnVlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5yZWNvcmRJZkZvY3VzZWRPblVwcHlSZWNlbnRseSwgdHJ1ZSlcblxuICAgIGlmICh0aGlzLm9wdHMuaW5saW5lKSB7XG4gICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd25JbklubGluZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmF1dG9PcGVuRmlsZUVkaXRvcikge1xuICAgICAgdGhpcy51cHB5Lm9uKCdmaWxlcy1hZGRlZCcsIHRoaXMuX29wZW5GaWxlRWRpdG9yV2hlbkZpbGVzQWRkZWQpXG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlRXZlbnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IHNob3dNb2RhbFRyaWdnZXIgPSBmaW5kQWxsRE9NRWxlbWVudHModGhpcy5vcHRzLnRyaWdnZXIpXG4gICAgaWYgKCF0aGlzLm9wdHMuaW5saW5lICYmIHNob3dNb2RhbFRyaWdnZXIpIHtcbiAgICAgIHNob3dNb2RhbFRyaWdnZXIuZm9yRWFjaCh0cmlnZ2VyID0+IHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9wZW5Nb2RhbCkpXG4gICAgfVxuXG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nVG9SZXNpemUoKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgdGhpcy5oYW5kbGVQYXN0ZU9uQm9keSlcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuaGFuZGxlUG9wU3RhdGUsIGZhbHNlKVxuICAgIHRoaXMudXBweS5vZmYoJ3BsdWdpbi1yZW1vdmUnLCB0aGlzLnJlbW92ZVRhcmdldClcbiAgICB0aGlzLnVwcHkub2ZmKCdmaWxlLWFkZGVkJywgdGhpcy5oaWRlQWxsUGFuZWxzKVxuICAgIHRoaXMudXBweS5vZmYoJ2Rhc2hib2FyZDptb2RhbC1jbG9zZWQnLCB0aGlzLmhpZGVBbGxQYW5lbHMpXG4gICAgdGhpcy51cHB5Lm9mZignZmlsZS1lZGl0b3I6Y29tcGxldGUnLCB0aGlzLmhpZGVBbGxQYW5lbHMpXG4gICAgdGhpcy51cHB5Lm9mZignY29tcGxldGUnLCB0aGlzLmhhbmRsZUNvbXBsZXRlKVxuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnJlY29yZElmRm9jdXNlZE9uVXBweVJlY2VudGx5KVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5yZWNvcmRJZkZvY3VzZWRPblVwcHlSZWNlbnRseSlcblxuICAgIGlmICh0aGlzLm9wdHMuaW5saW5lKSB7XG4gICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd25JbklubGluZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmF1dG9PcGVuRmlsZUVkaXRvcikge1xuICAgICAgdGhpcy51cHB5Lm9mZignZmlsZXMtYWRkZWQnLCB0aGlzLl9vcGVuRmlsZUVkaXRvcldoZW5GaWxlc0FkZGVkKVxuICAgIH1cbiAgfVxuXG4gIHN1cGVyRm9jdXNPbkVhY2hVcGRhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgaXNGb2N1c0luVXBweSA9IHRoaXMuZWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICAvLyBXaGVuIGZvY3VzIGlzIGxvc3Qgb24gdGhlIHBhZ2UgKD09IGZvY3VzIGlzIG9uIGJvZHkgZm9yIG1vc3QgYnJvd3NlcnMsIG9yIGZvY3VzIGlzIG51bGwgZm9yIElFMTEpXG4gICAgY29uc3QgaXNGb2N1c05vd2hlcmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IG51bGxcbiAgICBjb25zdCBpc0luZm9ybWVySGlkZGVuID0gdGhpcy51cHB5LmdldFN0YXRlKCkuaW5mby5pc0hpZGRlblxuICAgIGNvbnN0IGlzTW9kYWwgPSAhdGhpcy5vcHRzLmlubGluZVxuXG4gICAgaWYgKFxuICAgICAgLy8gSWYgdXBkYXRlIGlzIGNvbm5lY3RlZCB0byBzaG93aW5nIHRoZSBJbmZvcm1lciAtIGxldCB0aGUgc2NyZWVuIHJlYWRlciBjYWxtbHkgcmVhZCBpdC5cbiAgICAgIGlzSW5mb3JtZXJIaWRkZW5cbiAgICAgICYmIChcbiAgICAgICAgLy8gSWYgd2UgYXJlIGluIGEgbW9kYWwgLSBhbHdheXMgc3VwZXJmb2N1cyB3aXRob3V0IGNvbmNlcm4gZm9yIG90aGVyIGVsZW1lbnRzIG9uIHRoZSBwYWdlICh1c2VyIGlzIHVubGlrZWx5IHRvIHdhbnQgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgcmVzdCBvZiB0aGUgcGFnZSlcbiAgICAgICAgaXNNb2RhbFxuICAgICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBpbnNpZGUgb2YgVXBweSwgb3JcbiAgICAgICAgfHwgaXNGb2N1c0luVXBweVxuICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGZvY3VzZWQgb24gYW55dGhpbmcgQlVUIHdlIGhhdmUgYWxyZWFkeSwgYXQgbGVhc3Qgb25jZSwgZm9jdXNlZCBvbiB1cHB5XG4gICAgICAgIC8vICAgMS4gV2UgZm9jdXMgd2hlbiBpc0ZvY3VzTm93aGVyZSwgYmVjYXVzZSB3aGVuIHRoZSBlbGVtZW50IHdlIHdlcmUgZm9jdXNlZCBvbiBkaXNhcHBlYXJzIChlLmcuIGFuIG92ZXJsYXkpLCAtIGZvY3VzIGdldHMgbG9zdC4gSWYgdXNlciBpcyB0eXBpbmcgc29tZXRoaW5nIHNvbWV3aGVyZSBlbHNlIG9uIHRoZSBwYWdlLCAtIGZvY3VzIHdvbid0IGJlICdub3doZXJlJy5cbiAgICAgICAgLy8gICAyLiBXZSBvbmx5IGZvY3VzIHdoZW4gZm9jdXMgaXMgbm93aGVyZSBBTkQgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseSwgdG8gYXZvaWQgZm9jdXMganVtcHMgaWYgd2UgZG8gc29tZXRoaW5nIGVsc2Ugb24gdGhlIHBhZ2UuXG4gICAgICAgIC8vICAgW1ByYWN0aWNhbCBjaGVja10gV2l0aG91dCAnJiYgdGhpcy5pZkZvY3VzZWRPblVwcHlSZWNlbnRseScsIGluIFNhZmFyaSwgaW4gaW5saW5lIG1vZGUsIHdoZW4gZmlsZSBpcyB1cGxvYWRpbmcsIC0gbmF2aWdhdGUgdmlhIHRhYiB0byB0aGUgY2hlY2tib3gsIHRyeSB0byBwcmVzcyBzcGFjZSBtdWx0aXBsZSB0aW1lcy4gRm9jdXMgd2lsbCBqdW1wIHRvIFVwcHkuXG4gICAgICAgIHx8IChpc0ZvY3VzTm93aGVyZSAmJiB0aGlzLmlmRm9jdXNlZE9uVXBweVJlY2VudGx5KVxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhpcy5zdXBlckZvY3VzKHRoaXMuZWwsIHRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5hY3RpdmVPdmVybGF5VHlwZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdXBlckZvY3VzLmNhbmNlbCgpXG4gICAgfVxuICB9XG5cbiAgYWZ0ZXJVcGRhdGUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMub3B0cy5kaXNhYmxlZCAmJiAhdGhpcy5kYXNoYm9hcmRJc0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLmRpc2FibGVBbGxGb2N1c2FibGVFbGVtZW50cyh0cnVlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZWQgJiYgdGhpcy5kYXNoYm9hcmRJc0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLmRpc2FibGVBbGxGb2N1c2FibGVFbGVtZW50cyhmYWxzZSlcbiAgICB9XG5cbiAgICB0aGlzLnN1cGVyRm9jdXNPbkVhY2hVcGRhdGUoKVxuICB9XG5cbiAgY2FuY2VsVXBsb2FkID0gKGZpbGVJRCkgPT4ge1xuICAgIHRoaXMudXBweS5yZW1vdmVGaWxlKGZpbGVJRClcbiAgfVxuXG4gIHNhdmVGaWxlQ2FyZCA9IChtZXRhLCBmaWxlSUQpID0+IHtcbiAgICB0aGlzLnVwcHkuc2V0RmlsZU1ldGEoZmlsZUlELCBtZXRhKVxuICAgIHRoaXMudG9nZ2xlRmlsZUNhcmQoZmFsc2UsIGZpbGVJRClcbiAgfVxuXG4gIF9hdHRhY2hSZW5kZXJGdW5jdGlvblRvVGFyZ2V0ID0gKHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMudXBweS5nZXRQbHVnaW4odGFyZ2V0LmlkKVxuICAgIHJldHVybiB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBpY29uOiBwbHVnaW4uaWNvbiB8fCB0aGlzLm9wdHMuZGVmYXVsdFBpY2tlckljb24sXG4gICAgICByZW5kZXI6IHBsdWdpbi5yZW5kZXIsXG4gICAgfVxuICB9XG5cbiAgX2lzVGFyZ2V0U3VwcG9ydGVkID0gKHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMudXBweS5nZXRQbHVnaW4odGFyZ2V0LmlkKVxuICAgIC8vIElmIHRoZSBwbHVnaW4gZG9lcyBub3QgcHJvdmlkZSBhIGBzdXBwb3J0ZWRgIGNoZWNrLCBhc3N1bWUgdGhlIHBsdWdpbiB3b3JrcyBldmVyeXdoZXJlLlxuICAgIGlmICh0eXBlb2YgcGx1Z2luLmlzU3VwcG9ydGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gcGx1Z2luLmlzU3VwcG9ydGVkKClcbiAgfVxuXG4gIF9nZXRBY3F1aXJlcnMgPSBtZW1vaXplKCh0YXJnZXRzKSA9PiB7XG4gICAgcmV0dXJuIHRhcmdldHNcbiAgICAgIC5maWx0ZXIodGFyZ2V0ID0+IHRhcmdldC50eXBlID09PSAnYWNxdWlyZXInICYmIHRoaXMuX2lzVGFyZ2V0U3VwcG9ydGVkKHRhcmdldCkpXG4gICAgICAubWFwKHRoaXMuX2F0dGFjaFJlbmRlckZ1bmN0aW9uVG9UYXJnZXQpXG4gIH0pXG5cbiAgX2dldFByb2dyZXNzSW5kaWNhdG9ycyA9IG1lbW9pemUoKHRhcmdldHMpID0+IHtcbiAgICByZXR1cm4gdGFyZ2V0c1xuICAgICAgLmZpbHRlcih0YXJnZXQgPT4gdGFyZ2V0LnR5cGUgPT09ICdwcm9ncmVzc2luZGljYXRvcicpXG4gICAgICAubWFwKHRoaXMuX2F0dGFjaFJlbmRlckZ1bmN0aW9uVG9UYXJnZXQpXG4gIH0pXG5cbiAgX2dldEVkaXRvcnMgPSBtZW1vaXplKCh0YXJnZXRzKSA9PiB7XG4gICAgcmV0dXJuIHRhcmdldHNcbiAgICAgIC5maWx0ZXIodGFyZ2V0ID0+IHRhcmdldC50eXBlID09PSAnZWRpdG9yJylcbiAgICAgIC5tYXAodGhpcy5fYXR0YWNoUmVuZGVyRnVuY3Rpb25Ub1RhcmdldClcbiAgfSlcblxuICByZW5kZXIgPSAoc3RhdGUpID0+IHtcbiAgICBjb25zdCBwbHVnaW5TdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IHsgZmlsZXMsIGNhcGFiaWxpdGllcywgYWxsb3dOZXdVcGxvYWQgfSA9IHN0YXRlXG5cbiAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgdG8gQ29yZSwgdG8gc2hhcmUgYmV0d2VlbiBTdGF0dXMgQmFyIGFuZCBEYXNoYm9hcmRcbiAgICAvLyAoYW5kIGFueSBvdGhlciBwbHVnaW4gdGhhdCBtaWdodCBuZWVkIGl0LCB0b28pXG4gICAgY29uc3QgbmV3RmlsZXMgPSBPYmplY3Qua2V5cyhmaWxlcykuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gIWZpbGVzW2ZpbGVdLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgICB9KVxuXG4gICAgY29uc3QgdXBsb2FkU3RhcnRlZEZpbGVzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGVzW2ZpbGVdLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgICB9KVxuXG4gICAgY29uc3QgcGF1c2VkRmlsZXMgPSBPYmplY3Qua2V5cyhmaWxlcykuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gZmlsZXNbZmlsZV0uaXNQYXVzZWRcbiAgICB9KVxuXG4gICAgY29uc3QgY29tcGxldGVGaWxlcyA9IE9iamVjdC5rZXlzKGZpbGVzKS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiBmaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZVxuICAgIH0pXG5cbiAgICBjb25zdCBlcnJvcmVkRmlsZXMgPSBPYmplY3Qua2V5cyhmaWxlcykuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gZmlsZXNbZmlsZV0uZXJyb3JcbiAgICB9KVxuXG4gICAgY29uc3QgaW5Qcm9ncmVzc0ZpbGVzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuICFmaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZVxuICAgICAgICAgICAgICYmIGZpbGVzW2ZpbGVdLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWRcbiAgICB9KVxuXG4gICAgY29uc3QgaW5Qcm9ncmVzc05vdFBhdXNlZEZpbGVzID0gaW5Qcm9ncmVzc0ZpbGVzLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuICFmaWxlc1tmaWxlXS5pc1BhdXNlZFxuICAgIH0pXG5cbiAgICBjb25zdCBwcm9jZXNzaW5nRmlsZXMgPSBPYmplY3Qua2V5cyhmaWxlcykuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gZmlsZXNbZmlsZV0ucHJvZ3Jlc3MucHJlcHJvY2VzcyB8fCBmaWxlc1tmaWxlXS5wcm9ncmVzcy5wb3N0cHJvY2Vzc1xuICAgIH0pXG5cbiAgICBjb25zdCBpc1VwbG9hZFN0YXJ0ZWQgPSB1cGxvYWRTdGFydGVkRmlsZXMubGVuZ3RoID4gMFxuXG4gICAgY29uc3QgaXNBbGxDb21wbGV0ZSA9IHN0YXRlLnRvdGFsUHJvZ3Jlc3MgPT09IDEwMFxuICAgICAgJiYgY29tcGxldGVGaWxlcy5sZW5ndGggPT09IE9iamVjdC5rZXlzKGZpbGVzKS5sZW5ndGhcbiAgICAgICYmIHByb2Nlc3NpbmdGaWxlcy5sZW5ndGggPT09IDBcblxuICAgIGNvbnN0IGlzQWxsRXJyb3JlZCA9IGlzVXBsb2FkU3RhcnRlZFxuICAgICAgJiYgZXJyb3JlZEZpbGVzLmxlbmd0aCA9PT0gdXBsb2FkU3RhcnRlZEZpbGVzLmxlbmd0aFxuXG4gICAgY29uc3QgaXNBbGxQYXVzZWQgPSBpblByb2dyZXNzRmlsZXMubGVuZ3RoICE9PSAwXG4gICAgICAmJiBwYXVzZWRGaWxlcy5sZW5ndGggPT09IGluUHJvZ3Jlc3NGaWxlcy5sZW5ndGhcblxuICAgIGNvbnN0IGFjcXVpcmVycyA9IHRoaXMuX2dldEFjcXVpcmVycyhwbHVnaW5TdGF0ZS50YXJnZXRzKVxuICAgIGNvbnN0IHByb2dyZXNzaW5kaWNhdG9ycyA9IHRoaXMuX2dldFByb2dyZXNzSW5kaWNhdG9ycyhwbHVnaW5TdGF0ZS50YXJnZXRzKVxuICAgIGNvbnN0IGVkaXRvcnMgPSB0aGlzLl9nZXRFZGl0b3JzKHBsdWdpblN0YXRlLnRhcmdldHMpXG5cbiAgICBsZXQgdGhlbWVcbiAgICBpZiAodGhpcy5vcHRzLnRoZW1lID09PSAnYXV0bycpIHtcbiAgICAgIHRoZW1lID0gY2FwYWJpbGl0aWVzLmRhcmtNb2RlID8gJ2RhcmsnIDogJ2xpZ2h0J1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGVtZSA9IHRoaXMub3B0cy50aGVtZVxuICAgIH1cblxuICAgIGlmIChbJ2ZpbGVzJywgJ2ZvbGRlcnMnLCAnYm90aCddLmluZGV4T2YodGhpcy5vcHRzLmZpbGVNYW5hZ2VyU2VsZWN0aW9uVHlwZSkgPCAwKSB7XG4gICAgICB0aGlzLm9wdHMuZmlsZU1hbmFnZXJTZWxlY3Rpb25UeXBlID0gJ2ZpbGVzJ1xuICAgICAgY29uc29sZS5lcnJvcihgVW5zdXBwb3J0ZWQgb3B0aW9uIGZvciBcImZpbGVNYW5hZ2VyU2VsZWN0aW9uVHlwZVwiLiBVc2luZyBkZWZhdWx0IG9mIFwiJHt0aGlzLm9wdHMuZmlsZU1hbmFnZXJTZWxlY3Rpb25UeXBlfVwiLmApXG4gICAgfVxuXG4gICAgcmV0dXJuIERhc2hib2FyZFVJKHtcbiAgICAgIHN0YXRlLFxuICAgICAgaXNIaWRkZW46IHBsdWdpblN0YXRlLmlzSGlkZGVuLFxuICAgICAgZmlsZXMsXG4gICAgICBuZXdGaWxlcyxcbiAgICAgIHVwbG9hZFN0YXJ0ZWRGaWxlcyxcbiAgICAgIGNvbXBsZXRlRmlsZXMsXG4gICAgICBlcnJvcmVkRmlsZXMsXG4gICAgICBpblByb2dyZXNzRmlsZXMsXG4gICAgICBpblByb2dyZXNzTm90UGF1c2VkRmlsZXMsXG4gICAgICBwcm9jZXNzaW5nRmlsZXMsXG4gICAgICBpc1VwbG9hZFN0YXJ0ZWQsXG4gICAgICBpc0FsbENvbXBsZXRlLFxuICAgICAgaXNBbGxFcnJvcmVkLFxuICAgICAgaXNBbGxQYXVzZWQsXG4gICAgICB0b3RhbEZpbGVDb3VudDogT2JqZWN0LmtleXMoZmlsZXMpLmxlbmd0aCxcbiAgICAgIHRvdGFsUHJvZ3Jlc3M6IHN0YXRlLnRvdGFsUHJvZ3Jlc3MsXG4gICAgICBhbGxvd05ld1VwbG9hZCxcbiAgICAgIGFjcXVpcmVycyxcbiAgICAgIHRoZW1lLFxuICAgICAgZGlzYWJsZWQ6IHRoaXMub3B0cy5kaXNhYmxlZCxcbiAgICAgIGRpc2FibGVMb2NhbEZpbGVzOiB0aGlzLm9wdHMuZGlzYWJsZUxvY2FsRmlsZXMsXG4gICAgICBkaXJlY3Rpb246IHRoaXMub3B0cy5kaXJlY3Rpb24sXG4gICAgICBhY3RpdmVQaWNrZXJQYW5lbDogcGx1Z2luU3RhdGUuYWN0aXZlUGlja2VyUGFuZWwsXG4gICAgICBzaG93RmlsZUVkaXRvcjogcGx1Z2luU3RhdGUuc2hvd0ZpbGVFZGl0b3IsXG4gICAgICBzYXZlRmlsZUVkaXRvcjogdGhpcy5zYXZlRmlsZUVkaXRvcixcbiAgICAgIGRpc2FibGVBbGxGb2N1c2FibGVFbGVtZW50czogdGhpcy5kaXNhYmxlQWxsRm9jdXNhYmxlRWxlbWVudHMsXG4gICAgICBhbmltYXRlT3BlbkNsb3NlOiB0aGlzLm9wdHMuYW5pbWF0ZU9wZW5DbG9zZSxcbiAgICAgIGlzQ2xvc2luZzogcGx1Z2luU3RhdGUuaXNDbG9zaW5nLFxuICAgICAgZ2V0UGx1Z2luOiB0aGlzLnVwcHkuZ2V0UGx1Z2luLFxuICAgICAgcHJvZ3Jlc3NpbmRpY2F0b3JzLFxuICAgICAgZWRpdG9ycyxcbiAgICAgIGF1dG9Qcm9jZWVkOiB0aGlzLnVwcHkub3B0cy5hdXRvUHJvY2VlZCxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgY2xvc2VNb2RhbDogdGhpcy5yZXF1ZXN0Q2xvc2VNb2RhbCxcbiAgICAgIGhhbmRsZUNsaWNrT3V0c2lkZTogdGhpcy5oYW5kbGVDbGlja091dHNpZGUsXG4gICAgICBoYW5kbGVJbnB1dENoYW5nZTogdGhpcy5oYW5kbGVJbnB1dENoYW5nZSxcbiAgICAgIGhhbmRsZVBhc3RlOiB0aGlzLmhhbmRsZVBhc3RlLFxuICAgICAgaW5saW5lOiB0aGlzLm9wdHMuaW5saW5lLFxuICAgICAgc2hvd1BhbmVsOiB0aGlzLnNob3dQYW5lbCxcbiAgICAgIGhpZGVBbGxQYW5lbHM6IHRoaXMuaGlkZUFsbFBhbmVscyxcbiAgICAgIGxvZzogdGhpcy51cHB5LmxvZyxcbiAgICAgIGkxOG46IHRoaXMuaTE4bixcbiAgICAgIGkxOG5BcnJheTogdGhpcy5pMThuQXJyYXksXG4gICAgICByZW1vdmVGaWxlOiB0aGlzLnVwcHkucmVtb3ZlRmlsZSxcbiAgICAgIHVwcHk6IHRoaXMudXBweSxcbiAgICAgIGluZm86IHRoaXMudXBweS5pbmZvLFxuICAgICAgbm90ZTogdGhpcy5vcHRzLm5vdGUsXG4gICAgICByZWNvdmVyZWRTdGF0ZTogc3RhdGUucmVjb3ZlcmVkU3RhdGUsXG4gICAgICBtZXRhRmllbGRzOiBwbHVnaW5TdGF0ZS5tZXRhRmllbGRzLFxuICAgICAgcmVzdW1hYmxlVXBsb2FkczogY2FwYWJpbGl0aWVzLnJlc3VtYWJsZVVwbG9hZHMgfHwgZmFsc2UsXG4gICAgICBpbmRpdmlkdWFsQ2FuY2VsbGF0aW9uOiBjYXBhYmlsaXRpZXMuaW5kaXZpZHVhbENhbmNlbGxhdGlvbixcbiAgICAgIGlzTW9iaWxlRGV2aWNlOiBjYXBhYmlsaXRpZXMuaXNNb2JpbGVEZXZpY2UsXG4gICAgICBwYXVzZVVwbG9hZDogdGhpcy51cHB5LnBhdXNlUmVzdW1lLFxuICAgICAgcmV0cnlVcGxvYWQ6IHRoaXMudXBweS5yZXRyeVVwbG9hZCxcbiAgICAgIGNhbmNlbFVwbG9hZDogdGhpcy5jYW5jZWxVcGxvYWQsXG4gICAgICBjYW5jZWxBbGw6IHRoaXMudXBweS5jYW5jZWxBbGwsXG4gICAgICBmaWxlQ2FyZEZvcjogcGx1Z2luU3RhdGUuZmlsZUNhcmRGb3IsXG4gICAgICB0b2dnbGVGaWxlQ2FyZDogdGhpcy50b2dnbGVGaWxlQ2FyZCxcbiAgICAgIHRvZ2dsZUFkZEZpbGVzUGFuZWw6IHRoaXMudG9nZ2xlQWRkRmlsZXNQYW5lbCxcbiAgICAgIHNob3dBZGRGaWxlc1BhbmVsOiBwbHVnaW5TdGF0ZS5zaG93QWRkRmlsZXNQYW5lbCxcbiAgICAgIHNhdmVGaWxlQ2FyZDogdGhpcy5zYXZlRmlsZUNhcmQsXG4gICAgICBvcGVuRmlsZUVkaXRvcjogdGhpcy5vcGVuRmlsZUVkaXRvcixcbiAgICAgIGNhbkVkaXRGaWxlOiB0aGlzLmNhbkVkaXRGaWxlLFxuICAgICAgd2lkdGg6IHRoaXMub3B0cy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5vcHRzLmhlaWdodCxcbiAgICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0OiB0aGlzLm9wdHMuc2hvd0xpbmtUb0ZpbGVVcGxvYWRSZXN1bHQsXG4gICAgICBmaWxlTWFuYWdlclNlbGVjdGlvblR5cGU6IHRoaXMub3B0cy5maWxlTWFuYWdlclNlbGVjdGlvblR5cGUsXG4gICAgICBwcm91ZGx5RGlzcGxheVBvd2VyZWRCeVVwcHk6IHRoaXMub3B0cy5wcm91ZGx5RGlzcGxheVBvd2VyZWRCeVVwcHksXG4gICAgICBoaWRlQ2FuY2VsQnV0dG9uOiB0aGlzLm9wdHMuaGlkZUNhbmNlbEJ1dHRvbixcbiAgICAgIGhpZGVSZXRyeUJ1dHRvbjogdGhpcy5vcHRzLmhpZGVSZXRyeUJ1dHRvbixcbiAgICAgIGhpZGVQYXVzZVJlc3VtZUJ1dHRvbjogdGhpcy5vcHRzLmhpZGVQYXVzZVJlc3VtZUJ1dHRvbixcbiAgICAgIHNob3dSZW1vdmVCdXR0b25BZnRlckNvbXBsZXRlOiB0aGlzLm9wdHMuc2hvd1JlbW92ZUJ1dHRvbkFmdGVyQ29tcGxldGUsXG4gICAgICBjb250YWluZXJXaWR0aDogcGx1Z2luU3RhdGUuY29udGFpbmVyV2lkdGgsXG4gICAgICBjb250YWluZXJIZWlnaHQ6IHBsdWdpblN0YXRlLmNvbnRhaW5lckhlaWdodCxcbiAgICAgIGFyZUluc2lkZXNSZWFkeVRvQmVWaXNpYmxlOiBwbHVnaW5TdGF0ZS5hcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZSxcbiAgICAgIGlzVGFyZ2V0RE9NRWw6IHRoaXMuaXNUYXJnZXRET01FbCxcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHRoaXMuZWwsXG4gICAgICBhbGxvd2VkRmlsZVR5cGVzOiB0aGlzLnVwcHkub3B0cy5yZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcyxcbiAgICAgIG1heE51bWJlck9mRmlsZXM6IHRoaXMudXBweS5vcHRzLnJlc3RyaWN0aW9ucy5tYXhOdW1iZXJPZkZpbGVzLFxuICAgICAgc2hvd1NlbGVjdGVkRmlsZXM6IHRoaXMub3B0cy5zaG93U2VsZWN0ZWRGaWxlcyxcbiAgICAgIGhhbmRsZUNhbmNlbFJlc3RvcmU6IHRoaXMuaGFuZGxlQ2FuY2VsUmVzdG9yZSxcbiAgICAgIGhhbmRsZVJlcXVlc3RUaHVtYm5haWw6IHRoaXMuaGFuZGxlUmVxdWVzdFRodW1ibmFpbCxcbiAgICAgIGhhbmRsZUNhbmNlbFRodW1ibmFpbDogdGhpcy5oYW5kbGVDYW5jZWxUaHVtYm5haWwsXG4gICAgICAvLyBkcmFnIHByb3BzXG4gICAgICBpc0RyYWdnaW5nT3ZlcjogcGx1Z2luU3RhdGUuaXNEcmFnZ2luZ092ZXIsXG4gICAgICBoYW5kbGVEcmFnT3ZlcjogdGhpcy5oYW5kbGVEcmFnT3ZlcixcbiAgICAgIGhhbmRsZURyYWdMZWF2ZTogdGhpcy5oYW5kbGVEcmFnTGVhdmUsXG4gICAgICBoYW5kbGVEcm9wOiB0aGlzLmhhbmRsZURyb3AsXG4gICAgfSlcbiAgfVxuXG4gIGRpc2NvdmVyUHJvdmlkZXJQbHVnaW5zID0gKCkgPT4ge1xuICAgIHRoaXMudXBweS5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICBpZiAocGx1Z2luICYmICFwbHVnaW4udGFyZ2V0ICYmIHBsdWdpbi5vcHRzICYmIHBsdWdpbi5vcHRzLnRhcmdldCA9PT0gdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLmFkZFRhcmdldChwbHVnaW4pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIC8vIFNldCB0aGUgdGV4dCBkaXJlY3Rpb24gaWYgdGhlIHBhZ2UgaGFzIG5vdCBkZWZpbmVkIG9uZS5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbFxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGdldFRleHREaXJlY3Rpb24oZWxlbWVudClcbiAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgZWxlbWVudC5kaXIgPSAnbHRyJ1xuICAgIH1cbiAgfVxuXG4gIGluc3RhbGwgPSAoKSA9PiB7XG4gICAgLy8gU2V0IGRlZmF1bHQgc3RhdGUgZm9yIERhc2hib2FyZFxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgaXNIaWRkZW46IHRydWUsXG4gICAgICBmaWxlQ2FyZEZvcjogbnVsbCxcbiAgICAgIGFjdGl2ZU92ZXJsYXlUeXBlOiBudWxsLFxuICAgICAgc2hvd0FkZEZpbGVzUGFuZWw6IGZhbHNlLFxuICAgICAgYWN0aXZlUGlja2VyUGFuZWw6IGZhbHNlLFxuICAgICAgc2hvd0ZpbGVFZGl0b3I6IGZhbHNlLFxuICAgICAgbWV0YUZpZWxkczogdGhpcy5vcHRzLm1ldGFGaWVsZHMsXG4gICAgICB0YXJnZXRzOiBbXSxcbiAgICAgIC8vIFdlJ2xsIG1ha2UgdGhlbSB2aXNpYmxlIG9uY2UgLmNvbnRhaW5lcldpZHRoIGlzIGRldGVybWluZWRcbiAgICAgIGFyZUluc2lkZXNSZWFkeVRvQmVWaXNpYmxlOiBmYWxzZSxcbiAgICAgIGlzRHJhZ2dpbmdPdmVyOiBmYWxzZSxcbiAgICB9KVxuXG4gICAgY29uc3QgeyBpbmxpbmUsIGNsb3NlQWZ0ZXJGaW5pc2ggfSA9IHRoaXMub3B0c1xuICAgIGlmIChpbmxpbmUgJiYgY2xvc2VBZnRlckZpbmlzaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbRGFzaGJvYXJkXSBgY2xvc2VBZnRlckZpbmlzaDogdHJ1ZWAgY2Fubm90IGJlIHVzZWQgb24gYW4gaW5saW5lIERhc2hib2FyZCwgYmVjYXVzZSBhbiBpbmxpbmUgRGFzaGJvYXJkIGNhbm5vdCBiZSBjbG9zZWQgYXQgYWxsLiBFaXRoZXIgc2V0IGBpbmxpbmU6IGZhbHNlYCwgb3IgZGlzYWJsZSB0aGUgYGNsb3NlQWZ0ZXJGaW5pc2hgIG9wdGlvbi4nKVxuICAgIH1cblxuICAgIGNvbnN0IHsgYWxsb3dNdWx0aXBsZVVwbG9hZHMgfSA9IHRoaXMudXBweS5vcHRzXG4gICAgaWYgKGFsbG93TXVsdGlwbGVVcGxvYWRzICYmIGNsb3NlQWZ0ZXJGaW5pc2gpIHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tEYXNoYm9hcmRdIFdoZW4gdXNpbmcgYGNsb3NlQWZ0ZXJGaW5pc2hgLCB3ZSByZWNvbW1lbmRlZCBzZXR0aW5nIHRoZSBgYWxsb3dNdWx0aXBsZVVwbG9hZHNgIG9wdGlvbiB0byBgZmFsc2VgIGluIHRoZSBVcHB5IGNvbnN0cnVjdG9yLiBTZWUgaHR0cHM6Ly91cHB5LmlvL2RvY3MvdXBweS8jYWxsb3dNdWx0aXBsZVVwbG9hZHMtdHJ1ZScsICd3YXJuaW5nJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuXG4gICAgY29uc3QgcGx1Z2lucyA9IHRoaXMub3B0cy5wbHVnaW5zIHx8IFtdXG4gICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW5JRCkgPT4ge1xuICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy51cHB5LmdldFBsdWdpbihwbHVnaW5JRClcbiAgICAgIGlmIChwbHVnaW4pIHtcbiAgICAgICAgcGx1Z2luLm1vdW50KHRoaXMsIHBsdWdpbilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZVN0YXR1c0Jhcikge1xuICAgICAgdGhpcy51cHB5LnVzZShTdGF0dXNCYXIsIHtcbiAgICAgICAgaWQ6IGAke3RoaXMuaWR9OlN0YXR1c0JhcmAsXG4gICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgaGlkZVVwbG9hZEJ1dHRvbjogdGhpcy5vcHRzLmhpZGVVcGxvYWRCdXR0b24sXG4gICAgICAgIGhpZGVSZXRyeUJ1dHRvbjogdGhpcy5vcHRzLmhpZGVSZXRyeUJ1dHRvbixcbiAgICAgICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uOiB0aGlzLm9wdHMuaGlkZVBhdXNlUmVzdW1lQnV0dG9uLFxuICAgICAgICBoaWRlQ2FuY2VsQnV0dG9uOiB0aGlzLm9wdHMuaGlkZUNhbmNlbEJ1dHRvbixcbiAgICAgICAgc2hvd1Byb2dyZXNzRGV0YWlsczogdGhpcy5vcHRzLnNob3dQcm9ncmVzc0RldGFpbHMsXG4gICAgICAgIGhpZGVBZnRlckZpbmlzaDogdGhpcy5vcHRzLmhpZGVQcm9ncmVzc0FmdGVyRmluaXNoLFxuICAgICAgICBsb2NhbGU6IHRoaXMub3B0cy5sb2NhbGUsXG4gICAgICAgIGRvbmVCdXR0b25IYW5kbGVyOiB0aGlzLm9wdHMuZG9uZUJ1dHRvbkhhbmRsZXIsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRzLmRpc2FibGVJbmZvcm1lcikge1xuICAgICAgdGhpcy51cHB5LnVzZShJbmZvcm1lciwge1xuICAgICAgICBpZDogYCR7dGhpcy5pZH06SW5mb3JtZXJgLFxuICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRzLmRpc2FibGVUaHVtYm5haWxHZW5lcmF0b3IpIHtcbiAgICAgIHRoaXMudXBweS51c2UoVGh1bWJuYWlsR2VuZXJhdG9yLCB7XG4gICAgICAgIGlkOiBgJHt0aGlzLmlkfTpUaHVtYm5haWxHZW5lcmF0b3JgLFxuICAgICAgICB0aHVtYm5haWxXaWR0aDogdGhpcy5vcHRzLnRodW1ibmFpbFdpZHRoLFxuICAgICAgICB0aHVtYm5haWxUeXBlOiB0aGlzLm9wdHMudGh1bWJuYWlsVHlwZSxcbiAgICAgICAgd2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQ6IHRoaXMub3B0cy53YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZCxcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgYmxvY2sgb24gdGh1bWJuYWlscywgd2UgY2FuIGxhemlseSBnZW5lcmF0ZSB0aGVtXG4gICAgICAgIGxhenk6ICF0aGlzLm9wdHMud2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQsXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIERhcmsgTW9kZSAvIHRoZW1lXG4gICAgdGhpcy5kYXJrTW9kZU1lZGlhUXVlcnkgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm1hdGNoTWVkaWEpXG4gICAgICA/IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJylcbiAgICAgIDogbnVsbFxuXG4gICAgY29uc3QgaXNEYXJrTW9kZU9uRnJvbVRoZVN0YXJ0ID0gdGhpcy5kYXJrTW9kZU1lZGlhUXVlcnkgPyB0aGlzLmRhcmtNb2RlTWVkaWFRdWVyeS5tYXRjaGVzIDogZmFsc2VcbiAgICB0aGlzLnVwcHkubG9nKGBbRGFzaGJvYXJkXSBEYXJrIG1vZGUgaXMgJHtpc0RhcmtNb2RlT25Gcm9tVGhlU3RhcnQgPyAnb24nIDogJ29mZid9YClcbiAgICB0aGlzLnNldERhcmtNb2RlQ2FwYWJpbGl0eShpc0RhcmtNb2RlT25Gcm9tVGhlU3RhcnQpXG5cbiAgICBpZiAodGhpcy5vcHRzLnRoZW1lID09PSAnYXV0bycpIHtcbiAgICAgIHRoaXMuZGFya01vZGVNZWRpYVF1ZXJ5LmFkZExpc3RlbmVyKHRoaXMuaGFuZGxlU3lzdGVtRGFya01vZGVDaGFuZ2UpXG4gICAgfVxuXG4gICAgdGhpcy5kaXNjb3ZlclByb3ZpZGVyUGx1Z2lucygpXG4gICAgdGhpcy5pbml0RXZlbnRzKClcbiAgfVxuXG4gIHVuaW5zdGFsbCA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMub3B0cy5kaXNhYmxlSW5mb3JtZXIpIHtcbiAgICAgIGNvbnN0IGluZm9ybWVyID0gdGhpcy51cHB5LmdldFBsdWdpbihgJHt0aGlzLmlkfTpJbmZvcm1lcmApXG4gICAgICAvLyBDaGVja2luZyBpZiB0aGlzIHBsdWdpbiBleGlzdHMsIGluIGNhc2UgaXQgd2FzIHJlbW92ZWQgYnkgdXBweS1jb3JlXG4gICAgICAvLyBiZWZvcmUgdGhlIERhc2hib2FyZCB3YXMuXG4gICAgICBpZiAoaW5mb3JtZXIpIHRoaXMudXBweS5yZW1vdmVQbHVnaW4oaW5mb3JtZXIpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZVN0YXR1c0Jhcikge1xuICAgICAgY29uc3Qgc3RhdHVzQmFyID0gdGhpcy51cHB5LmdldFBsdWdpbihgJHt0aGlzLmlkfTpTdGF0dXNCYXJgKVxuICAgICAgaWYgKHN0YXR1c0JhcikgdGhpcy51cHB5LnJlbW92ZVBsdWdpbihzdGF0dXNCYXIpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZVRodW1ibmFpbEdlbmVyYXRvcikge1xuICAgICAgY29uc3QgdGh1bWJuYWlsID0gdGhpcy51cHB5LmdldFBsdWdpbihgJHt0aGlzLmlkfTpUaHVtYm5haWxHZW5lcmF0b3JgKVxuICAgICAgaWYgKHRodW1ibmFpbCkgdGhpcy51cHB5LnJlbW92ZVBsdWdpbih0aHVtYm5haWwpXG4gICAgfVxuXG4gICAgY29uc3QgcGx1Z2lucyA9IHRoaXMub3B0cy5wbHVnaW5zIHx8IFtdXG4gICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW5JRCkgPT4ge1xuICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy51cHB5LmdldFBsdWdpbihwbHVnaW5JRClcbiAgICAgIGlmIChwbHVnaW4pIHBsdWdpbi51bm1vdW50KClcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMub3B0cy50aGVtZSA9PT0gJ2F1dG8nKSB7XG4gICAgICB0aGlzLmRhcmtNb2RlTWVkaWFRdWVyeS5yZW1vdmVMaXN0ZW5lcih0aGlzLmhhbmRsZVN5c3RlbURhcmtNb2RlQ2hhbmdlKVxuICAgIH1cblxuICAgIHRoaXMudW5tb3VudCgpXG4gICAgdGhpcy5yZW1vdmVFdmVudHMoKVxuICB9XG59XG4iLCIvKipcbiAqIENvcGllcyB0ZXh0IHRvIGNsaXBib2FyZCBieSBjcmVhdGluZyBhbiBhbG1vc3QgaW52aXNpYmxlIHRleHRhcmVhLFxuICogYWRkaW5nIHRleHQgdGhlcmUsIHRoZW4gcnVubmluZyBleGVjQ29tbWFuZCgnY29weScpLlxuICogRmFsbHMgYmFjayB0byBwcm9tcHQoKSB3aGVuIHRoZSBlYXN5IHdheSBmYWlscyAoaGVsbG8sIFNhZmFyaSEpXG4gKiBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMwODEwMzIyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRUb0NvcHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBmYWxsYmFja1N0cmluZ1xuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29weVRvQ2xpcGJvYXJkICh0ZXh0VG9Db3B5LCBmYWxsYmFja1N0cmluZykge1xuICBmYWxsYmFja1N0cmluZyA9IGZhbGxiYWNrU3RyaW5nIHx8ICdDb3B5IHRoZSBVUkwgYmVsb3cnXG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgdGV4dEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpXG4gICAgdGV4dEFyZWEuc2V0QXR0cmlidXRlKCdzdHlsZScsIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHdpZHRoOiAnMmVtJyxcbiAgICAgIGhlaWdodDogJzJlbScsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICBib3hTaGFkb3c6ICdub25lJyxcbiAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsXG4gICAgfSlcblxuICAgIHRleHRBcmVhLnZhbHVlID0gdGV4dFRvQ29weVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGV4dEFyZWEpXG4gICAgdGV4dEFyZWEuc2VsZWN0KClcblxuICAgIGNvbnN0IG1hZ2ljQ29weUZhaWxlZCA9ICgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGV4dEFyZWEpXG4gICAgICB3aW5kb3cucHJvbXB0KGZhbGxiYWNrU3RyaW5nLCB0ZXh0VG9Db3B5KVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpXG4gICAgICBpZiAoIXN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgcmV0dXJuIG1hZ2ljQ29weUZhaWxlZCgnY29weSBjb21tYW5kIHVuYXZhaWxhYmxlJylcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGV4dEFyZWEpXG4gICAgICByZXR1cm4gcmVzb2x2ZSgpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRleHRBcmVhKVxuICAgICAgcmV0dXJuIG1hZ2ljQ29weUZhaWxlZChlcnIpXG4gICAgfVxuICB9KVxufVxuIiwiY29uc3QgZGVib3VuY2UgPSByZXF1aXJlKCdsb2Rhc2guZGVib3VuY2UnKVxuY29uc3QgRk9DVVNBQkxFX0VMRU1FTlRTID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL0ZPQ1VTQUJMRV9FTEVNRU5UUycpXG5jb25zdCBnZXRBY3RpdmVPdmVybGF5RWwgPSByZXF1aXJlKCcuL2dldEFjdGl2ZU92ZXJsYXlFbCcpXG5cbi8qXG4gIEZvY3VzZXMgb24gc29tZSBlbGVtZW50IGluIHRoZSBjdXJyZW50bHkgdG9wbW9zdCBvdmVybGF5LlxuXG4gIDEuIElmIHRoZXJlIGFyZSBzb21lIFtkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXSBlbGVtZW50cyByZW5kZXJlZCBhbHJlYWR5IC0gZm9jdXNlcyBvbiB0aGUgZmlyc3Qgc3VwZXJmb2N1c2FibGUgZWxlbWVudCwgYW5kIGxlYXZlcyBmb2N1cyB1cCB0byB0aGUgY29udHJvbCBvZiBhIHVzZXIgKHVudGlsIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQgZGlzYXBwZWFycyBmcm9tIHRoZSBzY3JlZW4gW3doaWNoIGNhbiBoYXBwZW4gd2hlbiBvdmVybGF5IGNoYW5nZXMsIG9yLCBlLmcuLCB3aGVuIHdlIGNsaWNrIG9uIGEgZm9sZGVyIGluIGdvb2dsZWRyaXZlXSkuXG4gIDIuIElmIHRoZXJlIGFyZSBubyBbZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZV0gZWxlbWVudHMgeWV0IChvciBldmVyKSAtIGZvY3VzZXMgb24gdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50LCBidXQgc3dpdGNoZXMgZm9jdXMgaWYgc3VwZXJmb2N1c2FibGUgZWxlbWVudHMgYXBwZWFyIG9uIG5leHQgcmVuZGVyLlxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlU3VwZXJGb2N1cyAoKSB7XG4gIGxldCBsYXN0Rm9jdXNXYXNPblN1cGVyRm9jdXNhYmxlRWwgPSBmYWxzZVxuXG4gIGNvbnN0IHN1cGVyRm9jdXMgPSAoZGFzaGJvYXJkRWwsIGFjdGl2ZU92ZXJsYXlUeXBlKSA9PiB7XG4gICAgY29uc3Qgb3ZlcmxheUVsID0gZ2V0QWN0aXZlT3ZlcmxheUVsKGRhc2hib2FyZEVsLCBhY3RpdmVPdmVybGF5VHlwZSlcblxuICAgIGNvbnN0IGlzRm9jdXNJbk92ZXJsYXkgPSBvdmVybGF5RWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICAvLyBJZiBmb2N1cyBpcyBhbHJlYWR5IGluIHRoZSB0b3Btb3N0IG92ZXJsYXksIEFORCBvbiBsYXN0IHVwZGF0ZSB3ZSBmb2N1c2VkIG9uIHRoZSBzdXBlcmZvY3VzYWJsZSBlbGVtZW50IC0gdGhlbiBsZWF2ZSBmb2N1cyB1cCB0byB0aGUgdXNlci5cbiAgICAvLyBbUHJhY3RpY2FsIGNoZWNrXSB3aXRob3V0IHRoaXMgbGluZSwgdHlwaW5nIGluIHRoZSBzZWFyY2ggaW5wdXQgaW4gZ29vZ2xlZHJpdmUgb3ZlcmxheSB3b24ndCB3b3JrLlxuICAgIGlmIChpc0ZvY3VzSW5PdmVybGF5ICYmIGxhc3RGb2N1c1dhc09uU3VwZXJGb2N1c2FibGVFbCkgcmV0dXJuXG5cbiAgICBjb25zdCBzdXBlckZvY3VzYWJsZUVsID0gb3ZlcmxheUVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXScpXG4gICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgaW4gdGhlIHRvcG1vc3Qgb3ZlcmxheSwgQU5EIHRoZXJlIGFyZSBubyBzdXBlciBmb2N1c2FibGUgZWxlbWVudHMgeWV0LCAtIGxlYXZlIGZvY3VzIHVwIHRvIHRoZSB1c2VyLlxuICAgIC8vIFtQcmFjdGljYWwgY2hlY2tdIHdpdGhvdXQgdGhpcyBsaW5lLCBpZiB5b3UgYXJlIGluIGFuIGVtcHR5IGZvbGRlciBpbiBnb29nbGUgZHJpdmUsIGFuZCBzb21ldGhpbmcncyB1cGxvYWRpbmcgaW4gdGhlIGJnLCAtIGZvY3VzIHdpbGwgYmUganVtcGluZyB0byBEb25lIGFsbCB0aGUgdGltZS5cbiAgICBpZiAoaXNGb2N1c0luT3ZlcmxheSAmJiAhc3VwZXJGb2N1c2FibGVFbCkgcmV0dXJuXG5cbiAgICBpZiAoc3VwZXJGb2N1c2FibGVFbCkge1xuICAgICAgc3VwZXJGb2N1c2FibGVFbC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSlcbiAgICAgIGxhc3RGb2N1c1dhc09uU3VwZXJGb2N1c2FibGVFbCA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZmlyc3RFbCA9IG92ZXJsYXlFbC5xdWVyeVNlbGVjdG9yKEZPQ1VTQUJMRV9FTEVNRU5UUylcbiAgICAgIGZpcnN0RWwgJiYgZmlyc3RFbC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSlcbiAgICAgIGxhc3RGb2N1c1dhc09uU3VwZXJGb2N1c2FibGVFbCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gX19fV2h5IGRvIHdlIG5lZWQgdG8gZGVib3VuY2U/XG4gIC8vICAgIDEuIFRvIGRlYWwgd2l0aCBhbmltYXRpb25zOiBvdmVybGF5IGNoYW5nZXMgdmlhIGFuaW1hdGlvbnMsIHdoaWNoIHJlc3VsdHMgaW4gdGhlIERPTSB1cGRhdGluZyBBRlRFUiBwbHVnaW4udXBkYXRlKCkgYWxyZWFkeSBleGVjdXRlZC5cbiAgLy8gICAgW1ByYWN0aWNhbCBjaGVja10gd2l0aG91dCBkZWJvdW5jZSwgaWYgd2Ugb3BlbiB0aGUgVXJsIG92ZXJsYXksIGFuZCBjbGljayAnRG9uZScsIERhc2hib2FyZCB3b24ndCBnZXQgZm9jdXNlZCBhZ2Fpbi5cbiAgLy8gICAgW1ByYWN0aWNhbCBjaGVja10gaWYgd2UgZGVsYXkgMjUwbXMgaW5zdGVhZCBvZiAyNjBtcyAtIElFMTEgd29uJ3QgZ2V0IGZvY3VzZWQgaW4gc2FtZSBzaXR1YXRpb24uXG4gIC8vICAgIDIuIFBlcmZvcm1hbmNlOiB0aGVyZSBjYW4gYmUgbWFueSBzdGF0ZSB1cGRhdGUoKXMgaW4gYSBzZWNvbmQsIGFuZCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBldmVyeSB0aW1lLlxuICByZXR1cm4gZGVib3VuY2Uoc3VwZXJGb2N1cywgMjYwKVxufVxuIiwiLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IC0gZWl0aGVyIGRhc2hib2FyZCBlbGVtZW50LCBvciB0aGUgb3ZlcmxheSB0aGF0J3MgbW9zdCBvbiB0b3BcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRBY3RpdmVPdmVybGF5RWwgKGRhc2hib2FyZEVsLCBhY3RpdmVPdmVybGF5VHlwZSkge1xuICBpZiAoYWN0aXZlT3ZlcmxheVR5cGUpIHtcbiAgICBjb25zdCBvdmVybGF5RWwgPSBkYXNoYm9hcmRFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS11cHB5LXBhbmVsdHlwZT1cIiR7YWN0aXZlT3ZlcmxheVR5cGV9XCJdYClcbiAgICAvLyBpZiBhbiBvdmVybGF5IGlzIGFscmVhZHkgbW91bnRlZFxuICAgIGlmIChvdmVybGF5RWwpIHJldHVybiBvdmVybGF5RWxcbiAgfVxuICByZXR1cm4gZGFzaGJvYXJkRWxcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuZnVuY3Rpb24gaWNvbkltYWdlICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPGcgZmlsbD1cIiM2ODZERTBcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgPHBhdGggZD1cIk01IDd2MTBoMTVWN0g1em0wLTFoMTVhMSAxIDAgMCAxIDEgMXYxMGExIDEgMCAwIDEtMSAxSDVhMSAxIDAgMCAxLTEtMVY3YTEgMSAwIDAgMSAxLTF6XCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk02LjM1IDE3LjE3Mmw0Ljk5NC01LjAyNmEuNS41IDAgMCAxIC43MDcgMGwyLjE2IDIuMTYgMy41MDUtMy41MDVhLjUuNSAwIDAgMSAuNzA3IDBsMi4zMzYgMi4zMS0uNzA3LjcyLTEuOTgzLTEuOTctMy41MDUgMy41MDVhLjUuNSAwIDAgMS0uNzA3IDBsLTIuMTYtMi4xNTktMy45MzggMy45MzktMS40MDkuMDI2elwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICAgIDxjaXJjbGUgY3g9XCI3LjVcIiBjeT1cIjkuNVwiIHI9XCIxLjVcIiAvPlxuICAgICAgPC9nPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIGljb25BdWRpbyAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPHBhdGggZD1cIk05LjUgMTguNjRjMCAxLjE0LTEuMTQ1IDItMi41IDJzLTIuNS0uODYtMi41LTJjMC0xLjE0IDEuMTQ1LTIgMi41LTIgLjU1NyAwIDEuMDc5LjE0NSAxLjUuMzk2VjcuMjVhLjUuNSAwIDAgMSAuMzc5LS40ODVsOS0yLjI1QS41LjUgMCAwIDEgMTguNSA1djExLjY0YzAgMS4xNC0xLjE0NSAyLTIuNSAycy0yLjUtLjg2LTIuNS0yYzAtMS4xNCAxLjE0NS0yIDIuNS0yIC41NTcgMCAxLjA3OS4xNDUgMS41LjM5NlY4LjY3bC04IDJ2Ny45N3ptOC0xMXYtMmwtOCAydjJsOC0yek03IDE5LjY0Yy44NTUgMCAxLjUtLjQ4NCAxLjUtMXMtLjY0NS0xLTEuNS0xLTEuNS40ODQtMS41IDEgLjY0NSAxIDEuNSAxem05LTJjLjg1NSAwIDEuNS0uNDg0IDEuNS0xcy0uNjQ1LTEtMS41LTEtMS41LjQ4NC0xLjUgMSAuNjQ1IDEgMS41IDF6XCIgZmlsbD1cIiMwNDlCQ0ZcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIGljb25WaWRlbyAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPHBhdGggZD1cIk0xNiAxMS44MzRsNC40ODYtMi42OTFBMSAxIDAgMCAxIDIyIDEwdjZhMSAxIDAgMCAxLTEuNTE0Ljg1N0wxNiAxNC4xNjdWMTdhMSAxIDAgMCAxLTEgMUg1YTEgMSAwIDAgMS0xLTFWOWExIDEgMCAwIDEgMS0xaDEwYTEgMSAwIDAgMSAxIDF2Mi44MzR6TTE1IDlINXY4aDEwVjl6bTEgNGw1IDN2LTZsLTUgM3pcIiBmaWxsPVwiIzE5QUY2N1wiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvblBERiAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNVwiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxuICAgICAgPHBhdGggZD1cIk05Ljc2NiA4LjI5NWMtLjY5MS0xLjg0My0uNTM5LTMuNDAxLjc0Ny0zLjcyNiAxLjY0My0uNDE0IDIuNTA1LjkzOCAyLjM5IDMuMjk5LS4wMzkuNzktLjE5NCAxLjY2Mi0uNTM3IDMuMTQ4LjMyNC40OS42Ni45NjcgMS4wNTUgMS41MS4xNy4yMzEuMzgyLjQ4OC42MjkuNzU3IDEuODY2LS4xMjggMy42NTMuMTE0IDQuOTE4LjY1NSAxLjQ4Ny42MzUgMi4xOTIgMS42ODUgMS42MTQgMi44NC0uNTY2IDEuMTMzLTEuODM5IDEuMDg0LTMuNDE2LjI0OS0xLjE0MS0uNjA0LTIuNDU3LTEuNjM0LTMuNTEtMi43MDdhMTMuNDY3IDEzLjQ2NyAwIDAgMC0yLjIzOC40MjZjLTEuMzkyIDQuMDUxLTQuNTM0IDYuNDUzLTUuNzA3IDQuNTcyLS45ODYtMS41OCAxLjM4LTQuMjA2IDQuOTE0LTUuMzc1LjA5Ny0uMzIyLjE4NS0uNjU2LjI2NC0xLjAwMS4wOC0uMzUzLjMwNi0xLjMxLjQwNy0xLjczNy0uNjc4LTEuMDU5LTEuMi0yLjAzMS0xLjUzLTIuOTF6bTIuMDk4IDQuODdjLS4wMzMuMTQ0LS4wNjguMjg3LS4xMDQuNDI3bC4wMzMtLjAxLS4wMTIuMDM4YTE0LjA2NSAxNC4wNjUgMCAwIDEgMS4wMi0uMTk3bC0uMDMyLS4wMzMuMDUyLS4wMDRhNy45MDIgNy45MDIgMCAwIDEtLjIwOC0uMjcxYy0uMTk3LS4yNy0uMzgtLjUyNi0uNTU1LS43NzVsLS4wMDYuMDI4LS4wMDItLjAwM2MtLjA3Ni4zMjMtLjE0OC42MzItLjE4Ni44em01Ljc3IDIuOTc4YzEuMTQzLjYwNSAxLjgzMi42MzIgMi4wNTQuMTg3LjI2LS41MTktLjA4Ny0xLjAzNC0xLjExMy0xLjQ3My0uOTExLS4zOS0yLjE3NS0uNjA4LTMuNTUtLjYwOC44NDUuNzY2IDEuNzg3IDEuNDU5IDIuNjA5IDEuODk0ek02LjU1OSAxOC43ODljLjE0LjIyMy42OTMuMTYgMS40MjUtLjQxMy44MjctLjY0OCAxLjYxLTEuNzQ3IDIuMjA4LTMuMjA2LTIuNTYzIDEuMDY0LTQuMTAyIDIuODY3LTMuNjMzIDMuNjJ6bTUuMzQ1LTEwLjk3Yy4wODgtMS43OTMtLjM1MS0yLjQ4LTEuMTQ2LTIuMjgtLjQ3My4xMTktLjU2NCAxLjA1LS4wNTYgMi40MDUuMjEzLjU2Ni41MiAxLjE4OC45MDggMS44NTkuMTgtLjg1OC4yNjgtMS40NTMuMjk0LTEuOTg0elwiIGZpbGw9XCIjRTI1MTRBXCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBpY29uQXJjaGl2ZSAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMTAuNDUgMi4wNWgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI0YS41LjUgMCAwIDEtLjUuNWgtMS4wNWEuNS41IDAgMCAxLS41LS41VjIuNTVhLjUuNSAwIDAgMSAuNS0uNXptMi4wNSAxLjAyNGgxLjA1YS41LjUgMCAwIDEgLjUuNVYzLjZhLjUuNSAwIDAgMS0uNS41SDEyLjVhLjUuNSAwIDAgMS0uNS0uNXYtLjAyNWEuNS41IDAgMCAxIC41LS41di0uMDAxek0xMC40NSAwaDEuMDVhLjUuNSAwIDAgMSAuNS41di4wMjVhLjUuNSAwIDAgMS0uNS41aC0xLjA1YS41LjUgMCAwIDEtLjUtLjVWLjVhLjUuNSAwIDAgMSAuNS0uNXptMi4wNSAxLjAyNWgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI0YS41LjUgMCAwIDEtLjUuNUgxMi41YS41LjUgMCAwIDEtLjUtLjV2LS4wMjRhLjUuNSAwIDAgMSAuNS0uNXptLTIuMDUgMy4wNzRoMS4wNWEuNS41IDAgMCAxIC41LjV2LjAyNWEuNS41IDAgMCAxLS41LjVoLTEuMDVhLjUuNSAwIDAgMS0uNS0uNXYtLjAyNWEuNS41IDAgMCAxIC41LS41em0yLjA1IDEuMDI1aDEuMDVhLjUuNSAwIDAgMSAuNS41di4wMjRhLjUuNSAwIDAgMS0uNS41SDEyLjVhLjUuNSAwIDAgMS0uNS0uNXYtLjAyNGEuNS41IDAgMCAxIC41LS41em0tMi4wNSAxLjAyNGgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI1YS41LjUgMCAwIDEtLjUuNWgtMS4wNWEuNS41IDAgMCAxLS41LS41di0uMDI1YS41LjUgMCAwIDEgLjUtLjV6bTIuMDUgMS4wMjVoMS4wNWEuNS41IDAgMCAxIC41LjV2LjAyNWEuNS41IDAgMCAxLS41LjVIMTIuNWEuNS41IDAgMCAxLS41LS41di0uMDI1YS41LjUgMCAwIDEgLjUtLjV6bS0yLjA1IDEuMDI1aDEuMDVhLjUuNSAwIDAgMSAuNS41di4wMjVhLjUuNSAwIDAgMS0uNS41aC0xLjA1YS41LjUgMCAwIDEtLjUtLjV2LS4wMjVhLjUuNSAwIDAgMSAuNS0uNXptMi4wNSAxLjAyNWgxLjA1YS41LjUgMCAwIDEgLjUuNXYuMDI0YS41LjUgMCAwIDEtLjUuNUgxMi41YS41LjUgMCAwIDEtLjUtLjV2LS4wMjRhLjUuNSAwIDAgMSAuNS0uNXptLTEuNjU2IDMuMDc0bC0uODIgNS45NDZjLjUyLjMwMiAxLjE3NC40NTggMS45NzYuNDU4LjgwMyAwIDEuNDU1LS4xNTYgMS45NzUtLjQ1OGwtLjgyLTUuOTQ2aC0yLjMxMXptMC0xLjAyNWgyLjMxMmMuNTEyIDAgLjk0Ni4zNzggMS4wMTUuODg1bC44MiA1Ljk0NmMuMDU2LjQxMi0uMTQyLjgxNy0uNTAxIDEuMDI2LS42ODYuMzk4LTEuNTE1LjU5Ny0yLjQ5LjU5Ny0uOTc0IDAtMS44MDQtLjE5OS0yLjQ5LS41OTdhMS4wMjUgMS4wMjUgMCAwIDEtLjUtMS4wMjZsLjgxOS01Ljk0NmMuMDctLjUwNy41MDMtLjg4NSAxLjAxNS0uODg1em0uNTQ1IDYuNmEuNS41IDAgMCAxLS4zOTctLjU2MWwuMTQzLS45OTlhLjUuNSAwIDAgMSAuNDk1LS40MjloLjc0YS41LjUgMCAwIDEgLjQ5NS40M2wuMTQzLjk5OGEuNS41IDAgMCAxLS4zOTcuNTYxYy0uNDA0LjA4LS44MTkuMDgtMS4yMjIgMHpcIiBmaWxsPVwiIzAwQzQ2OVwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvbkZpbGUgKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxnIGZpbGw9XCIjQTdBRkI3XCIgZmlsbFJ1bGU9XCJub256ZXJvXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNNS41IDIyYS41LjUgMCAwIDEtLjUtLjV2LTE4YS41LjUgMCAwIDEgLjUtLjVoMTAuNzE5YS41LjUgMCAwIDEgLjM2Ny4xNmwzLjI4MSAzLjU1NmEuNS41IDAgMCAxIC4xMzMuMzM5VjIxLjVhLjUuNSAwIDAgMS0uNS41aC0xNHptLjUtMWgxM1Y3LjI1TDE2IDRINnYxN3pcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTE1IDR2M2ExIDEgMCAwIDAgMSAxaDNWN2gtM1Y0aC0xelwiIC8+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvblRleHQgKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxwYXRoIGQ9XCJNNC41IDdoMTNhLjUuNSAwIDEgMSAwIDFoLTEzYS41LjUgMCAwIDEgMC0xem0wIDNoMTVhLjUuNSAwIDEgMSAwIDFoLTE1YS41LjUgMCAxIDEgMC0xem0wIDNoMTVhLjUuNSAwIDEgMSAwIDFoLTE1YS41LjUgMCAxIDEgMC0xem0wIDNoMTBhLjUuNSAwIDEgMSAwIDFoLTEwYS41LjUgMCAxIDEgMC0xelwiIGZpbGw9XCIjNUE1RTY5XCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEljb25CeU1pbWUgKGZpbGVUeXBlKSB7XG4gIGNvbnN0IGRlZmF1bHRDaG9pY2UgPSB7XG4gICAgY29sb3I6ICcjODM4OTk5JyxcbiAgICBpY29uOiBpY29uRmlsZSgpLFxuICB9XG5cbiAgaWYgKCFmaWxlVHlwZSkgcmV0dXJuIGRlZmF1bHRDaG9pY2VcblxuICBjb25zdCBmaWxlVHlwZUdlbmVyYWwgPSBmaWxlVHlwZS5zcGxpdCgnLycpWzBdXG4gIGNvbnN0IGZpbGVUeXBlU3BlY2lmaWMgPSBmaWxlVHlwZS5zcGxpdCgnLycpWzFdXG5cbiAgLy8gVGV4dFxuICBpZiAoZmlsZVR5cGVHZW5lcmFsID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6ICcjNWE1ZTY5JyxcbiAgICAgIGljb246IGljb25UZXh0KCksXG4gICAgfVxuICB9XG5cbiAgLy8gSW1hZ2VcbiAgaWYgKGZpbGVUeXBlR2VuZXJhbCA9PT0gJ2ltYWdlJykge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyM2ODZkZTAnLFxuICAgICAgaWNvbjogaWNvbkltYWdlKCksXG4gICAgfVxuICB9XG5cbiAgLy8gQXVkaW9cbiAgaWYgKGZpbGVUeXBlR2VuZXJhbCA9PT0gJ2F1ZGlvJykge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyMwNjhkYmInLFxuICAgICAgaWNvbjogaWNvbkF1ZGlvKCksXG4gICAgfVxuICB9XG5cbiAgLy8gVmlkZW9cbiAgaWYgKGZpbGVUeXBlR2VuZXJhbCA9PT0gJ3ZpZGVvJykge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyMxOWFmNjcnLFxuICAgICAgaWNvbjogaWNvblZpZGVvKCksXG4gICAgfVxuICB9XG5cbiAgLy8gUERGXG4gIGlmIChmaWxlVHlwZUdlbmVyYWwgPT09ICdhcHBsaWNhdGlvbicgJiYgZmlsZVR5cGVTcGVjaWZpYyA9PT0gJ3BkZicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6ICcjZTI1MTQ5JyxcbiAgICAgIGljb246IGljb25QREYoKSxcbiAgICB9XG4gIH1cblxuICAvLyBBcmNoaXZlXG4gIGNvbnN0IGFyY2hpdmVUeXBlcyA9IFsnemlwJywgJ3gtN3otY29tcHJlc3NlZCcsICd4LXJhci1jb21wcmVzc2VkJywgJ3gtdGFyJywgJ3gtZ3ppcCcsICd4LWFwcGxlLWRpc2tpbWFnZSddXG4gIGlmIChmaWxlVHlwZUdlbmVyYWwgPT09ICdhcHBsaWNhdGlvbicgJiYgYXJjaGl2ZVR5cGVzLmluZGV4T2YoZmlsZVR5cGVTcGVjaWZpYykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiAnIzAwQzQ2OScsXG4gICAgICBpY29uOiBpY29uQXJjaGl2ZSgpLFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0Q2hvaWNlXG59XG4iLCIvLyBpZ25vcmUgZHJvcC9wYXN0ZSBldmVudHMgaWYgdGhleSBhcmUgbm90IGluIGlucHV0IG9yIHRleHRhcmVhIOKAlFxuLy8gb3RoZXJ3aXNlIHdoZW4gVXJsIHBsdWdpbiBhZGRzIGRyb3AvcGFzdGUgbGlzdGVuZXJzIHRvIHRoaXMuZWwsXG4vLyBkcmFnaW5nIFVJIGVsZW1lbnRzIG9yIHBhc3RpbmcgYW55dGhpbmcgaW50byBhbnkgZmllbGQgdHJpZ2dlcnMgdGhvc2UgZXZlbnRzIOKAlFxuLy8gVXJsIHRyZWF0cyB0aGVtIGFzIFVSTHMgdGhhdCBuZWVkIHRvIGJlIGltcG9ydGVkXG5cbmZ1bmN0aW9uIGlnbm9yZUV2ZW50IChldikge1xuICBjb25zdCB0YWdOYW1lID0gZXYudGFyZ2V0LnRhZ05hbWVcbiAgaWYgKHRhZ05hbWUgPT09ICdJTlBVVCdcbiAgICAgIHx8IHRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICBldi5zdG9wUHJvcGFnYXRpb24oKVxuICAgIHJldHVyblxuICB9XG4gIGV2LnByZXZlbnREZWZhdWx0KClcbiAgZXYuc3RvcFByb3BhZ2F0aW9uKClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZ25vcmVFdmVudFxuIiwiY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi90b0FycmF5JylcbmNvbnN0IGdldEFjdGl2ZU92ZXJsYXlFbCA9IHJlcXVpcmUoJy4vZ2V0QWN0aXZlT3ZlcmxheUVsJylcbmNvbnN0IEZPQ1VTQUJMRV9FTEVNRU5UUyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9GT0NVU0FCTEVfRUxFTUVOVFMnKVxuXG5mdW5jdGlvbiBmb2N1c09uRmlyc3ROb2RlIChldmVudCwgbm9kZXMpIHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVzWzBdXG4gIGlmIChub2RlKSB7XG4gICAgbm9kZS5mb2N1cygpXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZvY3VzT25MYXN0Tm9kZSAoZXZlbnQsIG5vZGVzKSB7XG4gIGNvbnN0IG5vZGUgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXVxuICBpZiAobm9kZSkge1xuICAgIG5vZGUuZm9jdXMoKVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgfVxufVxuXG4vLyBfX19XaHkgbm90IGp1c3QgdXNlIChmb2N1c2VkSXRlbUluZGV4ID09PSAtMSk/XG4vLyAgICBGaXJlZm94IHRoaW5rcyA8dWw+IGlzIGZvY3VzYWJsZSwgYnV0IHdlIGRvbid0IGhhdmUgPHVsPnMgaW4gb3VyIEZPQ1VTQUJMRV9FTEVNRU5UUy4gV2hpY2ggbWVhbnMgdGhhdCBpZiB3ZSB0YWIgaW50byB0aGUgPHVsPiwgY29kZSB3aWxsIHRoaW5rIHRoYXQgd2UgYXJlIG5vdCBpbiB0aGUgYWN0aXZlIG92ZXJsYXksIGFuZCB3ZSBzaG91bGQgZm9jdXNPbkZpcnN0Tm9kZSgpIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIG92ZXJsYXkhXG4vLyAgICBbUHJhY3RpY2FsIGNoZWNrXSBpZiB3ZSB1c2UgKGZvY3VzZWRJdGVtSW5kZXggPT09IC0xKSwgaW5zdGFncmFtIHByb3ZpZGVyIGluIGZpcmVmb3ggd2lsbCBuZXZlciBnZXQgZm9jdXMgb24gaXRzIHBpY3MgaW4gdGhlIDx1bD4uXG5mdW5jdGlvbiBpc0ZvY3VzSW5PdmVybGF5IChhY3RpdmVPdmVybGF5RWwpIHtcbiAgcmV0dXJuIGFjdGl2ZU92ZXJsYXlFbC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxufVxuXG5mdW5jdGlvbiB0cmFwRm9jdXMgKGV2ZW50LCBhY3RpdmVPdmVybGF5VHlwZSwgZGFzaGJvYXJkRWwpIHtcbiAgY29uc3QgYWN0aXZlT3ZlcmxheUVsID0gZ2V0QWN0aXZlT3ZlcmxheUVsKGRhc2hib2FyZEVsLCBhY3RpdmVPdmVybGF5VHlwZSlcbiAgY29uc3QgZm9jdXNhYmxlTm9kZXMgPSB0b0FycmF5KGFjdGl2ZU92ZXJsYXlFbC5xdWVyeVNlbGVjdG9yQWxsKEZPQ1VTQUJMRV9FTEVNRU5UUykpXG5cbiAgY29uc3QgZm9jdXNlZEl0ZW1JbmRleCA9IGZvY3VzYWJsZU5vZGVzLmluZGV4T2YoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcblxuICAvLyBJZiB3ZSBwcmVzc2VkIHRhYiwgYW5kIGZvY3VzIGlzIG5vdCB5ZXQgd2l0aGluIHRoZSBjdXJyZW50IG92ZXJsYXkgLSBmb2N1cyBvbiB0aGUgZmlyc3QgZWxlbWVudCB3aXRoaW4gdGhlIGN1cnJlbnQgb3ZlcmxheS5cbiAgLy8gVGhpcyBpcyBhIHNhZmV0eSBtZWFzdXJlIChmb3Igd2hlbiB1c2VyIHJldHVybnMgZnJvbSBhbm90aGVyIHRhYiBlLmcuKSwgbW9zdCBwbHVnaW5zIHdpbGwgdHJ5IHRvIGZvY3VzIG9uIHNvbWUgaW1wb3J0YW50IGVsZW1lbnQgYXMgaXQgbG9hZHMuXG4gIGlmICghaXNGb2N1c0luT3ZlcmxheShhY3RpdmVPdmVybGF5RWwpKSB7XG4gICAgZm9jdXNPbkZpcnN0Tm9kZShldmVudCwgZm9jdXNhYmxlTm9kZXMpXG4gIC8vIElmIHdlIHByZXNzZWQgc2hpZnQgKyB0YWIsIGFuZCB3ZSdyZSBvbiB0aGUgZmlyc3QgZWxlbWVudCBvZiBhIG1vZGFsXG4gIH0gZWxzZSBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgZm9jdXNlZEl0ZW1JbmRleCA9PT0gMCkge1xuICAgIGZvY3VzT25MYXN0Tm9kZShldmVudCwgZm9jdXNhYmxlTm9kZXMpXG4gIC8vIElmIHdlIHByZXNzZWQgdGFiLCBhbmQgd2UncmUgb24gdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbW9kYWxcbiAgfSBlbHNlIGlmICghZXZlbnQuc2hpZnRLZXkgJiYgZm9jdXNlZEl0ZW1JbmRleCA9PT0gZm9jdXNhYmxlTm9kZXMubGVuZ3RoIC0gMSkge1xuICAgIGZvY3VzT25GaXJzdE5vZGUoZXZlbnQsIGZvY3VzYWJsZU5vZGVzKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBUcmFwcyBmb2N1cyBpbnNpZGUgb2YgdGhlIGN1cnJlbnRseSBvcGVuIG92ZXJsYXkgKGUuZy4gRGFzaGJvYXJkLCBvciBlLmcuIEluc3RhZ3JhbSksIG5ldmVyIGxldHMgZm9jdXMgZGlzYXBwZWFyIGZyb20gdGhlIG1vZGFsLlxuICBmb3JNb2RhbDogKGV2ZW50LCBhY3RpdmVPdmVybGF5VHlwZSwgZGFzaGJvYXJkRWwpID0+IHtcbiAgICB0cmFwRm9jdXMoZXZlbnQsIGFjdGl2ZU92ZXJsYXlUeXBlLCBkYXNoYm9hcmRFbClcbiAgfSxcblxuICAvLyBUcmFwcyBmb2N1cyBpbnNpZGUgb2YgdGhlIGN1cnJlbnRseSBvcGVuIG92ZXJsYXksIHVubGVzcyBvdmVybGF5IGlzIG51bGwgLSB0aGVuIGxldCB0aGUgdXNlciB0YWIgYXdheS5cbiAgZm9ySW5saW5lOiAoZXZlbnQsIGFjdGl2ZU92ZXJsYXlUeXBlLCBkYXNoYm9hcmRFbCkgPT4ge1xuICAgIC8vIF9fX1doZW4gd2UncmUgaW4gdGhlIGJhcmUgJ0Ryb3AgZmlsZXMgaGVyZSwgcGFzdGUsIGJyb3dzZSBvciBpbXBvcnQgZnJvbScgc2NyZWVuXG4gICAgaWYgKGFjdGl2ZU92ZXJsYXlUeXBlID09PSBudWxsKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGFuZCBsZXQgdGhlIGJyb3dzZXIgaGFuZGxlIGl0LCB1c2VyIGNhbiB0YWIgYXdheSBmcm9tIFVwcHkgdG8gb3RoZXIgZWxlbWVudHMgb24gdGhlIHBhZ2VcbiAgICAvLyBfX19XaGVuIHRoZXJlIGlzIHNvbWUgb3ZlcmxheSB3aXRoICdEb25lJyBidXR0b25cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhcCB0aGUgZm9jdXMgaW5zaWRlIHRoaXMgb3ZlcmxheSFcbiAgICAgIC8vIFVzZXIgY2FuIGNsb3NlIHRoZSBvdmVybGF5IChjbGljayAnRG9uZScpIGlmIHRoZXkgd2FudCB0byB0cmF2ZWwgYXdheSBmcm9tIFVwcHkuXG4gICAgICB0cmFwRm9jdXMoZXZlbnQsIGFjdGl2ZU92ZXJsYXlUeXBlLCBkYXNoYm9hcmRFbClcbiAgICB9XG4gIH0sXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L2Ryb3AtdGFyZ2V0XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJMZXRzIHlvdXIgdXNlcnMgZHJhZyBhbmQgZHJvcCBmaWxlcyBvbiBhIERPTSBlbGVtZW50XCIsXG4gIFwidmVyc2lvblwiOiBcIjAuMi40XCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwiZHJhZy1kcm9wXCIsXG4gICAgXCJkcmFnXCIsXG4gICAgXCJkcm9wXCIsXG4gICAgXCJkcm9wem9uZVwiLFxuICAgIFwidXBsb2FkXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH0sXG4gIFwicHVibGlzaENvbmZpZ1wiOiB7XG4gICAgXCJhY2Nlc3NcIjogXCJwdWJsaWNcIlxuICB9XG59XG4iLCJjb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCBnZXREcm9wcGVkRmlsZXMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0RHJvcHBlZEZpbGVzJylcbmNvbnN0IHRvQXJyYXkgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvdG9BcnJheScpXG5cbi8qKlxuICogRHJvcCBUYXJnZXQgcGx1Z2luXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIERyb3BUYXJnZXQgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy50eXBlID0gJ2FjcXVpcmVyJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0Ryb3BUYXJnZXQnXG4gICAgdGhpcy50aXRsZSA9ICdEcm9wIFRhcmdldCdcblxuICAgIC8vIERlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRzID0ge1xuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgIH1cblxuICAgIC8vIE1lcmdlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBvbmVzIHNldCBieSB1c2VyXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0cywgLi4ub3B0cyB9XG4gICAgdGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dCA9IG51bGxcbiAgfVxuXG4gIGFkZEZpbGVzID0gKGZpbGVzKSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBmaWxlcy5tYXAoKGZpbGUpID0+ICh7XG4gICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICB0eXBlOiBmaWxlLnR5cGUsXG4gICAgICBkYXRhOiBmaWxlLFxuICAgICAgbWV0YToge1xuICAgICAgICAvLyBwYXRoIG9mIHRoZSBmaWxlIHJlbGF0aXZlIHRvIHRoZSBhbmNlc3RvciBkaXJlY3RvcnkgdGhlIHVzZXIgc2VsZWN0ZWQuXG4gICAgICAgIC8vIGUuZy4gJ2RvY3MvT2xkIFByYWd1ZS9haXJibmIucGRmJ1xuICAgICAgICByZWxhdGl2ZVBhdGg6IGZpbGUucmVsYXRpdmVQYXRoIHx8IG51bGwsXG4gICAgICB9LFxuICAgIH0pKVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudXBweS5hZGRGaWxlcyhkZXNjcmlwdG9ycylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZURyb3AgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dClcblxuICAgIC8vIDIuIFJlbW92ZSBkcmFnb3ZlciBjbGFzc1xuICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgndXBweS1pcy1kcmFnLW92ZXInKVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyBpc0RyYWdnaW5nT3ZlcjogZmFsc2UgfSlcblxuICAgIC8vIDMuIEFkZCBhbGwgZHJvcHBlZCBmaWxlc1xuICAgIHRoaXMudXBweS5sb2coJ1tEcm9wVGFyZ2V0XSBGaWxlcyB3ZXJlIGRyb3BwZWQnKVxuICAgIGNvbnN0IGxvZ0Ryb3BFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZyhlcnJvciwgJ2Vycm9yJylcbiAgICB9XG4gICAgZ2V0RHJvcHBlZEZpbGVzKGV2ZW50LmRhdGFUcmFuc2ZlciwgeyBsb2dEcm9wRXJyb3IgfSlcbiAgICAgIC50aGVuKChmaWxlcykgPT4gdGhpcy5hZGRGaWxlcyhmaWxlcykpXG4gIH1cblxuICBoYW5kbGVEcmFnT3ZlciA9IChldmVudCkgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgLy8gMS4gQWRkIGEgc21hbGwgKCspIGljb24gb24gZHJvcFxuICAgIC8vIChhbmQgcHJldmVudCBicm93c2VycyBmcm9tIGludGVycHJldGluZyB0aGlzIGFzIGZpbGVzIGJlaW5nIF9tb3ZlZF8gaW50byB0aGUgYnJvd3NlcixcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXMvMTk3OClcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdjb3B5J1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVtb3ZlRHJhZ092ZXJDbGFzc1RpbWVvdXQpXG4gICAgZXZlbnQuY3VycmVudFRhcmdldC5jbGFzc0xpc3QuYWRkKCd1cHB5LWlzLWRyYWctb3ZlcicpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7IGlzRHJhZ2dpbmdPdmVyOiB0cnVlIH0pXG4gIH1cblxuICBoYW5kbGVEcmFnTGVhdmUgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGNvbnN0IHsgY3VycmVudFRhcmdldCB9ID0gZXZlbnRcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0KVxuICAgIC8vIFRpbWVvdXQgYWdhaW5zdCBmbGlja2VyaW5nLCB0aGlzIHNvbHV0aW9uIGlzIHRha2VuIGZyb20gZHJhZy1kcm9wIGxpYnJhcnkuXG4gICAgLy8gU29sdXRpb24gd2l0aCAncG9pbnRlci1ldmVudHM6IG5vbmUnIGRpZG4ndCB3b3JrIGFjcm9zcyBicm93c2Vycy5cbiAgICB0aGlzLnJlbW92ZURyYWdPdmVyQ2xhc3NUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjdXJyZW50VGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3VwcHktaXMtZHJhZy1vdmVyJylcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyBpc0RyYWdnaW5nT3ZlcjogZmFsc2UgfSlcbiAgICB9LCA1MClcbiAgfVxuXG4gIGFkZExpc3RlbmVycyA9ICgpID0+IHtcbiAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5vcHRzXG5cbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgdGhpcy5ub2RlcyA9IFt0YXJnZXRdXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5ub2RlcyA9IHRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQpKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5ub2RlcyAmJiAhdGhpcy5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt0YXJnZXR9XCIgZG9lcyBub3QgbWF0Y2ggYW55IEhUTUwgZWxlbWVudHNgKVxuICAgIH1cblxuICAgIHRoaXMubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMuaGFuZGxlRHJhZ092ZXIsIGZhbHNlKVxuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCB0aGlzLmhhbmRsZURyYWdMZWF2ZSwgZmFsc2UpXG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLmhhbmRsZURyb3AsIGZhbHNlKVxuICAgIH0pXG4gIH1cblxuICByZW1vdmVMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMubm9kZXMpIHtcbiAgICAgIHRoaXMubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpcy5oYW5kbGVEcmFnT3ZlciwgZmFsc2UpXG4gICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgdGhpcy5oYW5kbGVEcmFnTGVhdmUsIGZhbHNlKVxuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLmhhbmRsZURyb3AsIGZhbHNlKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgaXNEcmFnZ2luZ092ZXI6IGZhbHNlIH0pXG4gICAgdGhpcy5hZGRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvZHJvcGJveFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiSW1wb3J0IGZpbGVzIGZyb20gRHJvcGJveCwgaW50byBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIxLjUuMlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcImRyb3Bib3hcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvbXBhbmlvbi1jbGllbnRcIjogXCJmaWxlOi4uL2NvbXBhbmlvbi1jbGllbnRcIixcbiAgICBcIkB1cHB5L3Byb3ZpZGVyLXZpZXdzXCI6IFwiZmlsZTouLi9wcm92aWRlci12aWV3c1wiLFxuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgeyBQcm92aWRlciB9ID0gcmVxdWlyZSgnQHVwcHkvY29tcGFuaW9uLWNsaWVudCcpXG5jb25zdCB7IFByb3ZpZGVyVmlld3MgfSA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEcm9wYm94IGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0Ryb3Bib3gnXG4gICAgUHJvdmlkZXIuaW5pdFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ0Ryb3Bib3gnXG4gICAgdGhpcy5pY29uID0gKCkgPT4gKFxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIj5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgZmlsbD1cIiMwRDI0ODFcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiByeD1cIjE2XCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTExIDhsNSAzLjE4NS01IDMuMTg2LTUtMy4xODZMMTEgOHptMTAgMGw1IDMuMTg1LTUgMy4xODYtNS0zLjE4NkwyMSA4ek02IDE3LjU1Nmw1LTMuMTg1IDUgMy4xODUtNSAzLjE4Ni01LTMuMTg2em0xNS0zLjE4NWw1IDMuMTg1LTUgMy4xODYtNS0zLjE4NiA1LTMuMTg1em0tMTAgNy40MzJsNS0zLjE4NSA1IDMuMTg1LTUgMy4xODYtNS0zLjE4NnpcIiBmaWxsPVwiI0ZGRlwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMgfHwgdGhpcy5vcHRzLnNlcnZlckhlYWRlcnMsXG4gICAgICBjb21wYW5pb25LZXlzUGFyYW1zOiB0aGlzLm9wdHMuY29tcGFuaW9uS2V5c1BhcmFtcyxcbiAgICAgIGNvbXBhbmlvbkNvb2tpZXNSdWxlOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUsXG4gICAgICBwcm92aWRlcjogJ2Ryb3Bib3gnLFxuICAgICAgcGx1Z2luSWQ6IHRoaXMuaWQsXG4gICAgfSlcblxuICAgIHRoaXMub25GaXJzdFJlbmRlciA9IHRoaXMub25GaXJzdFJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcgPSBuZXcgUHJvdmlkZXJWaWV3cyh0aGlzLCB7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICB9KVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3LnRlYXJEb3duKClcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgb25GaXJzdFJlbmRlciAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMucHJvdmlkZXIuZmV0Y2hQcmVBdXRoVG9rZW4oKSxcbiAgICAgIHRoaXMudmlldy5nZXRGb2xkZXIoKSxcbiAgICBdKVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyKHN0YXRlKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L2ZhY2Vib29rXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJJbXBvcnQgZmlsZXMgZnJvbSBGYWNlYm9vaywgaW50byBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIxLjIuMlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcImZhY2Vib29rXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgeyBQcm92aWRlclZpZXdzIH0gPSByZXF1aXJlKCdAdXBweS9wcm92aWRlci12aWV3cycpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRmFjZWJvb2sgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnRmFjZWJvb2snXG4gICAgUHJvdmlkZXIuaW5pdFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ0ZhY2Vib29rJ1xuICAgIHRoaXMuaWNvbiA9ICgpID0+IChcbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHJ4PVwiMTZcIiBmaWxsPVwiIzNDNUE5OVwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xNy44NDIgMjZ2LTguNjY3aDIuNjUzbC4zOTgtMy4zNzdoLTMuMDUxdi0yLjE1N2MwLS45NzguMjQ4LTEuNjQ0IDEuNTI3LTEuNjQ0SDIxVjcuMTMyQTE5LjkxNCAxOS45MTQgMCAwIDAgMTguNjIzIDdjLTIuMzUyIDAtMy45NjMgMS41NzQtMy45NjMgNC40NjV2Mi40OUgxMnYzLjM3OGgyLjY2VjI2aDMuMTgyelwiIGZpbGw9XCIjRkZGXCIgZmlsbFJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgKVxuXG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyBQcm92aWRlcih1cHB5LCB7XG4gICAgICBjb21wYW5pb25Vcmw6IHRoaXMub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICBjb21wYW5pb25IZWFkZXJzOiB0aGlzLm9wdHMuY29tcGFuaW9uSGVhZGVycyB8fCB0aGlzLm9wdHMuc2VydmVySGVhZGVycyxcbiAgICAgIGNvbXBhbmlvbktleXNQYXJhbXM6IHRoaXMub3B0cy5jb21wYW5pb25LZXlzUGFyYW1zLFxuICAgICAgY29tcGFuaW9uQ29va2llc1J1bGU6IHRoaXMub3B0cy5jb21wYW5pb25Db29raWVzUnVsZSxcbiAgICAgIHByb3ZpZGVyOiAnZmFjZWJvb2snLFxuICAgICAgcGx1Z2luSWQ6IHRoaXMuaWQsXG4gICAgfSlcblxuICAgIHRoaXMub25GaXJzdFJlbmRlciA9IHRoaXMub25GaXJzdFJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcgPSBuZXcgUHJvdmlkZXJWaWV3cyh0aGlzLCB7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICB9KVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3LnRlYXJEb3duKClcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgb25GaXJzdFJlbmRlciAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMucHJvdmlkZXIuZmV0Y2hQcmVBdXRoVG9rZW4oKSxcbiAgICAgIHRoaXMudmlldy5nZXRGb2xkZXIoKSxcbiAgICBdKVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIGNvbnN0IHZpZXdPcHRpb25zID0ge31cbiAgICBpZiAodGhpcy5nZXRQbHVnaW5TdGF0ZSgpLmZpbGVzLmxlbmd0aCAmJiAhdGhpcy5nZXRQbHVnaW5TdGF0ZSgpLmZvbGRlcnMubGVuZ3RoKSB7XG4gICAgICB2aWV3T3B0aW9ucy52aWV3VHlwZSA9ICdncmlkJ1xuICAgICAgdmlld09wdGlvbnMuc2hvd0ZpbHRlciA9IGZhbHNlXG4gICAgICB2aWV3T3B0aW9ucy5zaG93VGl0bGVzID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmlldy5yZW5kZXIoc3RhdGUsIHZpZXdPcHRpb25zKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L2dvbGRlbi1yZXRyaWV2ZXJcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBHb2xkZW5SZXRyaWV2ZXIgVXBweSBwbHVnaW4gc2F2ZXMgc2VsZWN0ZWQgZmlsZXMgaW4gYnJvd3NlciBjYWNoZSB0byBzZWFtbGVzc2x5IHJlc3VtZSB1cGxvZGluZyBhZnRlciBicm93c2VyIGNyYXNoIG9yIGFjY2lkZW50YWxseSBjbG9zZWQgdGFiXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuNC4yXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJyZXN0b3JlIGZpbGVzXCIsXG4gICAgXCJjcmFzaCByZWNvdmVyeVwiLFxuICAgIFwiZ29sZGVuIHJldHJpZXZlclwiLFxuICAgIFwicmVzdW1hYmxlIHVwbG9hZHNcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdHJhbnNsb2FkaXQvcHJldHRpZXItYnl0ZXNcIjogXCIwLjAuN1wiLFxuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJsb2Rhc2gudGhyb3R0bGVcIjogXCJeNC4xLjFcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHByZXR0aWVyQnl0ZXMgPSByZXF1aXJlKCdAdHJhbnNsb2FkaXQvcHJldHRpZXItYnl0ZXMnKVxuXG5jb25zdCBpbmRleGVkREIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAmJiAod2luZG93LmluZGV4ZWREQiB8fCB3aW5kb3cud2Via2l0SW5kZXhlZERCIHx8IHdpbmRvdy5tb3pJbmRleGVkREIgfHwgd2luZG93Lk9JbmRleGVkREIgfHwgd2luZG93Lm1zSW5kZXhlZERCKVxuXG5jb25zdCBpc1N1cHBvcnRlZCA9ICEhaW5kZXhlZERCXG5cbmNvbnN0IERCX05BTUUgPSAndXBweS1ibG9icydcbmNvbnN0IFNUT1JFX05BTUUgPSAnZmlsZXMnIC8vIG1heWJlIGhhdmUgYSB0aHVtYm5haWwgc3RvcmUgaW4gdGhlIGZ1dHVyZVxuY29uc3QgREVGQVVMVF9FWFBJUlkgPSAyNCAqIDYwICogNjAgKiAxMDAwIC8vIDI0IGhvdXJzXG5jb25zdCBEQl9WRVJTSU9OID0gM1xuXG4vLyBTZXQgZGVmYXVsdCBgZXhwaXJlc2AgZGF0ZXMgb24gZXhpc3Rpbmcgc3RvcmVkIGJsb2JzLlxuZnVuY3Rpb24gbWlncmF0ZUV4cGlyYXRpb24gKHN0b3JlKSB7XG4gIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5vcGVuQ3Vyc29yKClcbiAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0XG4gICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBlbnRyeSA9IGN1cnNvci52YWx1ZVxuICAgIGVudHJ5LmV4cGlyZXMgPSBEYXRlLm5vdygpICsgREVGQVVMVF9FWFBJUllcbiAgICBjdXJzb3IudXBkYXRlKGVudHJ5KVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbm5lY3QgKGRiTmFtZSkge1xuICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oZGJOYW1lLCBEQl9WRVJTSU9OKVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHRcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZXZlbnQuY3VycmVudFRhcmdldC50cmFuc2FjdGlvblxuXG4gICAgICBpZiAoZXZlbnQub2xkVmVyc2lvbiA8IDIpIHtcbiAgICAgICAgLy8gQWRkZWQgaW4gdjI6IERCIHN0cnVjdHVyZSBjaGFuZ2VkIHRvIGEgc2luZ2xlIHNoYXJlZCBvYmplY3Qgc3RvcmVcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShTVE9SRV9OQU1FLCB7IGtleVBhdGg6ICdpZCcgfSlcbiAgICAgICAgc3RvcmUuY3JlYXRlSW5kZXgoJ3N0b3JlJywgJ3N0b3JlJywgeyB1bmlxdWU6IGZhbHNlIH0pXG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5vbGRWZXJzaW9uIDwgMykge1xuICAgICAgICAvLyBBZGRlZCBpbiB2M1xuICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKFNUT1JFX05BTUUpXG4gICAgICAgIHN0b3JlLmNyZWF0ZUluZGV4KCdleHBpcmVzJywgJ2V4cGlyZXMnLCB7IHVuaXF1ZTogZmFsc2UgfSlcblxuICAgICAgICBtaWdyYXRlRXhwaXJhdGlvbihzdG9yZSlcbiAgICAgIH1cblxuICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShkYilcbiAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgIHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdClcbiAgICB9XG4gICAgcmVxdWVzdC5vbmVycm9yID0gcmVqZWN0XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JSZXF1ZXN0IChyZXF1ZXN0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgIHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdClcbiAgICB9XG4gICAgcmVxdWVzdC5vbmVycm9yID0gcmVqZWN0XG4gIH0pXG59XG5cbmxldCBjbGVhbmVkVXAgPSBmYWxzZVxuY2xhc3MgSW5kZXhlZERCU3RvcmUge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHRoaXMub3B0cyA9IHtcbiAgICAgIGRiTmFtZTogREJfTkFNRSxcbiAgICAgIHN0b3JlTmFtZTogJ2RlZmF1bHQnLFxuICAgICAgZXhwaXJlczogREVGQVVMVF9FWFBJUlksIC8vIDI0IGhvdXJzXG4gICAgICBtYXhGaWxlU2l6ZTogMTAgKiAxMDI0ICogMTAyNCwgLy8gMTAgTUJcbiAgICAgIG1heFRvdGFsU2l6ZTogMzAwICogMTAyNCAqIDEwMjQsIC8vIDMwMCBNQlxuICAgICAgLi4ub3B0cyxcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLm9wdHMuc3RvcmVOYW1lXG5cbiAgICBjb25zdCBjcmVhdGVDb25uZWN0aW9uID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGNvbm5lY3QodGhpcy5vcHRzLmRiTmFtZSlcbiAgICB9XG5cbiAgICBpZiAoIWNsZWFuZWRVcCkge1xuICAgICAgY2xlYW5lZFVwID0gdHJ1ZVxuICAgICAgdGhpcy5yZWFkeSA9IEluZGV4ZWREQlN0b3JlLmNsZWFudXAoKVxuICAgICAgICAudGhlbihjcmVhdGVDb25uZWN0aW9uLCBjcmVhdGVDb25uZWN0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlYWR5ID0gY3JlYXRlQ29ubmVjdGlvbigpXG4gICAgfVxuICB9XG5cbiAga2V5IChmaWxlSUQpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSEke2ZpbGVJRH1gXG4gIH1cblxuICAvKipcbiAgICogTGlzdCBhbGwgZmlsZSBibG9icyBjdXJyZW50bHkgaW4gdGhlIHN0b3JlLlxuICAgKi9cbiAgbGlzdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZHkudGhlbigoZGIpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW1NUT1JFX05BTUVdLCAncmVhZG9ubHknKVxuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKVxuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmluZGV4KCdzdG9yZScpXG4gICAgICAgIC5nZXRBbGwoSURCS2V5UmFuZ2Uub25seSh0aGlzLm5hbWUpKVxuICAgICAgcmV0dXJuIHdhaXRGb3JSZXF1ZXN0KHJlcXVlc3QpXG4gICAgfSkudGhlbigoZmlsZXMpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9XG4gICAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICAgIHJlc3VsdFtmaWxlLmZpbGVJRF0gPSBmaWxlLmRhdGFcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb25lIGZpbGUgYmxvYiBmcm9tIHRoZSBzdG9yZS5cbiAgICovXG4gIGdldCAoZmlsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZHkudGhlbigoZGIpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW1NUT1JFX05BTUVdLCAncmVhZG9ubHknKVxuICAgICAgY29uc3QgcmVxdWVzdCA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKFNUT1JFX05BTUUpXG4gICAgICAgIC5nZXQodGhpcy5rZXkoZmlsZUlEKSlcbiAgICAgIHJldHVybiB3YWl0Rm9yUmVxdWVzdChyZXF1ZXN0KVxuICAgIH0pLnRoZW4oKHJlc3VsdCkgPT4gKHtcbiAgICAgIGlkOiByZXN1bHQuZGF0YS5maWxlSUQsXG4gICAgICBkYXRhOiByZXN1bHQuZGF0YS5kYXRhLFxuICAgIH0pKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdG90YWwgc2l6ZSBvZiBhbGwgc3RvcmVkIGZpbGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZHkudGhlbigoZGIpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW1NUT1JFX05BTUVdLCAncmVhZG9ubHknKVxuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKVxuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmluZGV4KCdzdG9yZScpXG4gICAgICAgIC5vcGVuQ3Vyc29yKElEQktleVJhbmdlLm9ubHkodGhpcy5uYW1lKSlcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBzaXplID0gMFxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHRcbiAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICBzaXplICs9IGN1cnNvci52YWx1ZS5kYXRhLnNpemVcbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoc2l6ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZXRyaWV2ZSBzdG9yZWQgYmxvYnMgc2l6ZScpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2F2ZSBhIGZpbGUgaW4gdGhlIHN0b3JlLlxuICAgKi9cbiAgcHV0IChmaWxlKSB7XG4gICAgaWYgKGZpbGUuZGF0YS5zaXplID4gdGhpcy5vcHRzLm1heEZpbGVTaXplKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdGaWxlIGlzIHRvbyBiaWcgdG8gc3RvcmUuJykpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFNpemUoKS50aGVuKChzaXplKSA9PiB7XG4gICAgICBpZiAoc2l6ZSA+IHRoaXMub3B0cy5tYXhUb3RhbFNpemUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm8gc3BhY2UgbGVmdCcpKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVhZHlcbiAgICB9KS50aGVuKChkYikgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbU1RPUkVfTkFNRV0sICdyZWFkd3JpdGUnKVxuICAgICAgY29uc3QgcmVxdWVzdCA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKFNUT1JFX05BTUUpLmFkZCh7XG4gICAgICAgIGlkOiB0aGlzLmtleShmaWxlLmlkKSxcbiAgICAgICAgZmlsZUlEOiBmaWxlLmlkLFxuICAgICAgICBzdG9yZTogdGhpcy5uYW1lLFxuICAgICAgICBleHBpcmVzOiBEYXRlLm5vdygpICsgdGhpcy5vcHRzLmV4cGlyZXMsXG4gICAgICAgIGRhdGE6IGZpbGUuZGF0YSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gd2FpdEZvclJlcXVlc3QocmVxdWVzdClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGZpbGUgYmxvYiBmcm9tIHRoZSBzdG9yZS5cbiAgICovXG4gIGRlbGV0ZSAoZmlsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZHkudGhlbigoZGIpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW1NUT1JFX05BTUVdLCAncmVhZHdyaXRlJylcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShTVE9SRV9OQU1FKVxuICAgICAgICAuZGVsZXRlKHRoaXMua2V5KGZpbGVJRCkpXG4gICAgICByZXR1cm4gd2FpdEZvclJlcXVlc3QocmVxdWVzdClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbGwgc3RvcmVkIGJsb2JzIHRoYXQgaGF2ZSBhbiBleHBpcnkgZGF0ZSB0aGF0IGlzIGJlZm9yZSBEYXRlLm5vdygpLlxuICAgKiBUaGlzIGlzIGEgc3RhdGljIG1ldGhvZCBiZWNhdXNlIGl0IGRlbGV0ZXMgZXhwaXJlZCBibG9icyBmcm9tIF9hbGxfIFVwcHkgaW5zdGFuY2VzLlxuICAgKi9cbiAgc3RhdGljIGNsZWFudXAgKCkge1xuICAgIHJldHVybiBjb25uZWN0KERCX05BTUUpLnRoZW4oKGRiKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtTVE9SRV9OQU1FXSwgJ3JlYWR3cml0ZScpXG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKFNUT1JFX05BTUUpXG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuaW5kZXgoJ2V4cGlyZXMnKVxuICAgICAgICAub3BlbkN1cnNvcihJREJLZXlSYW5nZS51cHBlckJvdW5kKERhdGUubm93KCkpKVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0XG4gICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBjdXJzb3IudmFsdWVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAnW0luZGV4ZWREQlN0b3JlXSBEZWxldGluZyByZWNvcmQnLCBlbnRyeS5maWxlSUQsXG4gICAgICAgICAgICAgICdvZiBzaXplJywgcHJldHRpZXJCeXRlcyhlbnRyeS5kYXRhLnNpemUpLFxuICAgICAgICAgICAgICAnLSBleHBpcmVkIG9uJywgbmV3IERhdGUoZW50cnkuZXhwaXJlcylcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGN1cnNvci5kZWxldGUoKSAvLyBJZ25vcmluZyByZXR1cm4gdmFsdWUg4oCmIGl0J3Mgbm90IHRlcnJpYmxlIGlmIHRoaXMgZ29lcyB3cm9uZy5cbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZGIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHJlamVjdFxuICAgICAgfSlcbiAgICB9KS50aGVuKChkYikgPT4ge1xuICAgICAgZGIuY2xvc2UoKVxuICAgIH0pXG4gIH1cbn1cblxuSW5kZXhlZERCU3RvcmUuaXNTdXBwb3J0ZWQgPSBpc1N1cHBvcnRlZFxuXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4ZWREQlN0b3JlXG4iLCIvKipcbiAqIEdldCB1cHB5IGluc3RhbmNlIElEcyBmb3Igd2hpY2ggc3RhdGUgaXMgc3RvcmVkLlxuICovXG5mdW5jdGlvbiBmaW5kVXBweUluc3RhbmNlcyAoKSB7XG4gIGNvbnN0IGluc3RhbmNlcyA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKVxuICAgIGlmICgvXnVwcHlTdGF0ZTovLnRlc3Qoa2V5KSkge1xuICAgICAgaW5zdGFuY2VzLnB1c2goa2V5LnNsaWNlKCd1cHB5U3RhdGU6Jy5sZW5ndGgpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5zdGFuY2VzXG59XG5cbi8qKlxuICogVHJ5IHRvIEpTT04tcGFyc2UgYSBzdHJpbmcsIHJldHVybiBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbmZ1bmN0aW9uIG1heWJlUGFyc2UgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5sZXQgY2xlYW5lZFVwID0gZmFsc2Vcbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTWV0YURhdGFTdG9yZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0ge1xuICAgICAgZXhwaXJlczogMjQgKiA2MCAqIDYwICogMTAwMCwgLy8gMjQgaG91cnNcbiAgICAgIC4uLm9wdHMsXG4gICAgfVxuICAgIHRoaXMubmFtZSA9IGB1cHB5U3RhdGU6JHtvcHRzLnN0b3JlTmFtZX1gXG5cbiAgICBpZiAoIWNsZWFuZWRVcCkge1xuICAgICAgY2xlYW5lZFVwID0gdHJ1ZVxuICAgICAgTWV0YURhdGFTdG9yZS5jbGVhbnVwKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIGxvYWQgKCkge1xuICAgIGNvbnN0IHNhdmVkU3RhdGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLm5hbWUpXG4gICAgaWYgKCFzYXZlZFN0YXRlKSByZXR1cm4gbnVsbFxuICAgIGNvbnN0IGRhdGEgPSBtYXliZVBhcnNlKHNhdmVkU3RhdGUpXG4gICAgaWYgKCFkYXRhKSByZXR1cm4gbnVsbFxuXG4gICAgLy8gVXBncmFkZSBwcmUtMC4yMC4wIHVwcHlTdGF0ZTogaXQgdXNlZCB0byBiZSBqdXN0IGEgZmxhdCBvYmplY3QsXG4gICAgLy8gd2l0aG91dCBgZXhwaXJlc2AuXG4gICAgaWYgKCFkYXRhLm1ldGFkYXRhKSB7XG4gICAgICB0aGlzLnNhdmUoZGF0YSlcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEubWV0YWRhdGFcbiAgfVxuXG4gIHNhdmUgKG1ldGFkYXRhKSB7XG4gICAgY29uc3QgZXhwaXJlcyA9IERhdGUubm93KCkgKyB0aGlzLm9wdHMuZXhwaXJlc1xuICAgIGNvbnN0IHN0YXRlID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgbWV0YWRhdGEsXG4gICAgICBleHBpcmVzLFxuICAgIH0pXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5uYW1lLCBzdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGV4cGlyZWQgc3RhdGUuXG4gICAqL1xuICBzdGF0aWMgY2xlYW51cCAoaW5zdGFuY2VJRCkge1xuICAgIGlmIChpbnN0YW5jZUlEKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShgdXBweVN0YXRlOiR7aW5zdGFuY2VJRH1gKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2VJRHMgPSBmaW5kVXBweUluc3RhbmNlcygpXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIGluc3RhbmNlSURzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oYHVwcHlTdGF0ZToke2lkfWApXG4gICAgICBpZiAoIWRhdGEpIHJldHVybiBudWxsXG4gICAgICBjb25zdCBvYmogPSBtYXliZVBhcnNlKGRhdGEpXG4gICAgICBpZiAoIW9iaikgcmV0dXJuIG51bGxcblxuICAgICAgaWYgKG9iai5leHBpcmVzICYmIG9iai5leHBpcmVzIDwgbm93KSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGB1cHB5U3RhdGU6JHtpZH1gKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cbiIsIi8qZXNsaW50LWRpc2FibGUgKi9cblxuY29uc3QgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yXG5cbmZ1bmN0aW9uIHdhaXRGb3JTZXJ2aWNlV29ya2VyICgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdVbnN1cHBvcnRlZCcpKVxuICAgIH0gZWxzZSBpZiAobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcikge1xuICAgICAgLy8gQSBzZXJ2aWNlV29ya2VyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBhbmQgYWN0aXZlLlxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRyb2xsZXJjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59XG5cbmNsYXNzIFNlcnZpY2VXb3JrZXJTdG9yZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgdGhpcy5yZWFkeSA9IHdhaXRGb3JTZXJ2aWNlV29ya2VyKClcbiAgICB0aGlzLm5hbWUgPSBvcHRzLnN0b3JlTmFtZVxuICB9XG5cbiAgbGlzdCAoKSB7XG4gICAgY29uc3QgZGVmZXIgPSB7fVxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBkZWZlci5yZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgZGVmZXIucmVqZWN0ID0gcmVqZWN0XG4gICAgfSlcblxuICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIHN0b3JlZCBibG9icyBmcm9tIFNlcnZpY2UgV29ya2VyJylcbiAgICBjb25zdCBvbk1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kYXRhLnN0b3JlICE9PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGV2ZW50LmRhdGEudHlwZSkge1xuICAgICAgICBjYXNlICd1cHB5L0FMTF9GSUxFUyc6XG4gICAgICAgICAgZGVmZXIucmVzb2x2ZShldmVudC5kYXRhLmZpbGVzKVxuICAgICAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlYWR5LnRoZW4oKCkgPT4ge1xuICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uTWVzc2FnZSlcblxuICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICd1cHB5L0dFVF9GSUxFUycsXG4gICAgICAgIHN0b3JlOiB0aGlzLm5hbWVcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBwdXQgKGZpbGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkeS50aGVuKCgpID0+IHtcbiAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiAndXBweS9BRERfRklMRScsXG4gICAgICAgIHN0b3JlOiB0aGlzLm5hbWUsXG4gICAgICAgIGZpbGU6IGZpbGVcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGRlbGV0ZSAoZmlsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZHkudGhlbigoKSA9PiB7XG4gICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ3VwcHkvUkVNT1ZFX0ZJTEUnLFxuICAgICAgICBzdG9yZTogdGhpcy5uYW1lLFxuICAgICAgICBmaWxlSUQ6IGZpbGVJRFxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5cblNlcnZpY2VXb3JrZXJTdG9yZS5pc1N1cHBvcnRlZCA9IGlzU3VwcG9ydGVkXG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmljZVdvcmtlclN0b3JlXG4iLCJjb25zdCB0aHJvdHRsZSA9IHJlcXVpcmUoJ2xvZGFzaC50aHJvdHRsZScpXG5jb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCBTZXJ2aWNlV29ya2VyU3RvcmUgPSByZXF1aXJlKCcuL1NlcnZpY2VXb3JrZXJTdG9yZScpXG5jb25zdCBJbmRleGVkREJTdG9yZSA9IHJlcXVpcmUoJy4vSW5kZXhlZERCU3RvcmUnKVxuY29uc3QgTWV0YURhdGFTdG9yZSA9IHJlcXVpcmUoJy4vTWV0YURhdGFTdG9yZScpXG5cbi8qKlxuICogVGhlIEdvbGRlblJldHJpZXZlciBwbHVnaW4g4oCUIHJlc3RvcmVzIHNlbGVjdGVkIGZpbGVzIGFuZCByZXN1bWVzIHVwbG9hZHNcbiAqIGFmdGVyIGEgY2xvc2VkIHRhYiBvciBhIGJyb3dzZXIgY3Jhc2ghXG4gKlxuICogVXNlcyBsb2NhbFN0b3JhZ2UsIEluZGV4ZWREQiBhbmQgU2VydmljZVdvcmtlciB0byBkbyBpdHMgbWFnaWMsIHJlYWQgbW9yZTpcbiAqIGh0dHBzOi8vdXBweS5pby9ibG9nLzIwMTcvMDcvZ29sZGVuLXJldHJpZXZlci9cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBHb2xkZW5SZXRyaWV2ZXIgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy50eXBlID0gJ2RlYnVnZ2VyJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0dvbGRlblJldHJpZXZlcidcbiAgICB0aGlzLnRpdGxlID0gJ0dvbGRlbiBSZXRyaWV2ZXInXG5cbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGV4cGlyZXM6IDI0ICogNjAgKiA2MCAqIDEwMDAsIC8vIDI0IGhvdXJzXG4gICAgICBzZXJ2aWNlV29ya2VyOiBmYWxzZSxcbiAgICB9XG5cbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIHRoaXMuTWV0YURhdGFTdG9yZSA9IG5ldyBNZXRhRGF0YVN0b3JlKHtcbiAgICAgIGV4cGlyZXM6IHRoaXMub3B0cy5leHBpcmVzLFxuICAgICAgc3RvcmVOYW1lOiB1cHB5LmdldElEKCksXG4gICAgfSlcbiAgICB0aGlzLlNlcnZpY2VXb3JrZXJTdG9yZSA9IG51bGxcbiAgICBpZiAodGhpcy5vcHRzLnNlcnZpY2VXb3JrZXIpIHtcbiAgICAgIHRoaXMuU2VydmljZVdvcmtlclN0b3JlID0gbmV3IFNlcnZpY2VXb3JrZXJTdG9yZSh7IHN0b3JlTmFtZTogdXBweS5nZXRJRCgpIH0pXG4gICAgfVxuICAgIHRoaXMuSW5kZXhlZERCU3RvcmUgPSBuZXcgSW5kZXhlZERCU3RvcmUoe1xuICAgICAgZXhwaXJlczogdGhpcy5vcHRzLmV4cGlyZXMsXG4gICAgICAuLi50aGlzLm9wdHMuaW5kZXhlZERCIHx8IHt9LFxuICAgICAgc3RvcmVOYW1lOiB1cHB5LmdldElEKCksXG4gICAgfSlcblxuICAgIHRoaXMuc2F2ZUZpbGVzU3RhdGVUb0xvY2FsU3RvcmFnZSA9IHRocm90dGxlKFxuICAgICAgdGhpcy5zYXZlRmlsZXNTdGF0ZVRvTG9jYWxTdG9yYWdlLmJpbmQodGhpcyksXG4gICAgICA1MDAsXG4gICAgICB7IGxlYWRpbmc6IHRydWUsIHRyYWlsaW5nOiB0cnVlIH1cbiAgICApXG4gICAgdGhpcy5yZXN0b3JlU3RhdGUgPSB0aGlzLnJlc3RvcmVTdGF0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5sb2FkRmlsZUJsb2JzRnJvbVNlcnZpY2VXb3JrZXIgPSB0aGlzLmxvYWRGaWxlQmxvYnNGcm9tU2VydmljZVdvcmtlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5sb2FkRmlsZUJsb2JzRnJvbUluZGV4ZWREQiA9IHRoaXMubG9hZEZpbGVCbG9ic0Zyb21JbmRleGVkREIuYmluZCh0aGlzKVxuICAgIHRoaXMub25CbG9ic0xvYWRlZCA9IHRoaXMub25CbG9ic0xvYWRlZC5iaW5kKHRoaXMpXG4gIH1cblxuICByZXN0b3JlU3RhdGUgKCkge1xuICAgIGNvbnN0IHNhdmVkU3RhdGUgPSB0aGlzLk1ldGFEYXRhU3RvcmUubG9hZCgpXG4gICAgaWYgKHNhdmVkU3RhdGUpIHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tHb2xkZW5SZXRyaWV2ZXJdIFJlY292ZXJlZCBzb21lIHN0YXRlIGZyb20gTG9jYWwgU3RvcmFnZScpXG4gICAgICB0aGlzLnVwcHkuc2V0U3RhdGUoe1xuICAgICAgICBjdXJyZW50VXBsb2Fkczogc2F2ZWRTdGF0ZS5jdXJyZW50VXBsb2FkcyB8fCB7fSxcbiAgICAgICAgZmlsZXM6IHNhdmVkU3RhdGUuZmlsZXMgfHwge30sXG4gICAgICAgIHJlY292ZXJlZFN0YXRlOiBzYXZlZFN0YXRlLFxuICAgICAgfSlcbiAgICAgIHRoaXMuc2F2ZWRQbHVnaW5EYXRhID0gc2F2ZWRTdGF0ZS5wbHVnaW5EYXRhXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmaWxlIG9iamVjdHMgdGhhdCBhcmUgY3VycmVudGx5IHdhaXRpbmc6IHRoZXkndmUgYmVlbiBzZWxlY3RlZCxcbiAgICogYnV0IGFyZW4ndCB5ZXQgYmVpbmcgdXBsb2FkZWQuXG4gICAqL1xuICBnZXRXYWl0aW5nRmlsZXMgKCkge1xuICAgIGNvbnN0IHdhaXRpbmdGaWxlcyA9IHt9XG5cbiAgICB0aGlzLnVwcHkuZ2V0RmlsZXMoKS5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICBpZiAoIWZpbGUucHJvZ3Jlc3MgfHwgIWZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZCkge1xuICAgICAgICB3YWl0aW5nRmlsZXNbZmlsZS5pZF0gPSBmaWxlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiB3YWl0aW5nRmlsZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZmlsZSBvYmplY3RzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyB1cGxvYWRlZC4gSWYgYSBmaWxlIGhhcyBmaW5pc2hlZFxuICAgKiB1cGxvYWRpbmcsIGJ1dCB0aGUgb3RoZXIgZmlsZXMgaW4gdGhlIHNhbWUgYmF0Y2ggaGF2ZSBub3QsIHRoZSBmaW5pc2hlZFxuICAgKiBmaWxlIGlzIGFsc28gcmV0dXJuZWQuXG4gICAqL1xuICBnZXRVcGxvYWRpbmdGaWxlcyAoKSB7XG4gICAgY29uc3QgdXBsb2FkaW5nRmlsZXMgPSB7fVxuXG4gICAgY29uc3QgeyBjdXJyZW50VXBsb2FkcyB9ID0gdGhpcy51cHB5LmdldFN0YXRlKClcbiAgICBpZiAoY3VycmVudFVwbG9hZHMpIHtcbiAgICAgIGNvbnN0IHVwbG9hZElEcyA9IE9iamVjdC5rZXlzKGN1cnJlbnRVcGxvYWRzKVxuICAgICAgdXBsb2FkSURzLmZvckVhY2goKHVwbG9hZElEKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVzSW5VcGxvYWQgPSBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0uZmlsZUlEc1xuICAgICAgICBmaWxlc0luVXBsb2FkLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgICAgIHVwbG9hZGluZ0ZpbGVzW2ZpbGVJRF0gPSB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB1cGxvYWRpbmdGaWxlc1xuICB9XG5cbiAgc2F2ZUZpbGVzU3RhdGVUb0xvY2FsU3RvcmFnZSAoKSB7XG4gICAgY29uc3QgZmlsZXNUb1NhdmUgPSB7XG4gICAgICAuLi50aGlzLmdldFdhaXRpbmdGaWxlcygpLFxuICAgICAgLi4udGhpcy5nZXRVcGxvYWRpbmdGaWxlcygpLFxuICAgIH1cblxuICAgIC8vIElmIGFsbCBmaWxlcyBoYXZlIGJlZW4gcmVtb3ZlZCBieSB0aGUgdXNlciwgY2xlYXIgcmVjb3Zlcnkgc3RhdGVcbiAgICBpZiAoT2JqZWN0LmtleXMoZmlsZXNUb1NhdmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy51cHB5LnNldFN0YXRlKHsgcmVjb3ZlcmVkU3RhdGU6IG51bGwgfSlcbiAgICAgIE1ldGFEYXRhU3RvcmUuY2xlYW51cCh0aGlzLnVwcHkub3B0cy5pZClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFdlIGRvbnTigJl0IG5lZWQgdG8gc3RvcmUgZmlsZS5kYXRhIG9uIGxvY2FsIGZpbGVzLCBiZWNhdXNlIHRoZSBhY3R1YWwgYmxvYiB3aWxsIGJlIHJlc3RvcmVkIGxhdGVyLFxuICAgIC8vIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGhhdmluZyB3ZWlyZCBwcm9wZXJ0aWVzIGluIHRoZSBzZXJpYWxpemVkIG9iamVjdC5cbiAgICAvLyBBbHNvIGFkZGluZyBmaWxlLmlzUmVzdG9yZWQgdG8gYWxsIGZpbGVzLCBzaW5jZSB0aGV5IHdpbGwgYmUgcmVzdG9yZWQgZnJvbSBsb2NhbCBzdG9yYWdlXG4gICAgY29uc3QgZmlsZXNUb1NhdmVXaXRob3V0RGF0YSA9IHt9XG4gICAgT2JqZWN0LmtleXMoZmlsZXNUb1NhdmUpLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGlmIChmaWxlc1RvU2F2ZVtmaWxlXS5pc1JlbW90ZSkge1xuICAgICAgICBmaWxlc1RvU2F2ZVdpdGhvdXREYXRhW2ZpbGVdID0ge1xuICAgICAgICAgIC4uLmZpbGVzVG9TYXZlW2ZpbGVdLFxuICAgICAgICAgIGlzUmVzdG9yZWQ6IHRydWUsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbGVzVG9TYXZlV2l0aG91dERhdGFbZmlsZV0gPSB7XG4gICAgICAgICAgLi4uZmlsZXNUb1NhdmVbZmlsZV0sXG4gICAgICAgICAgaXNSZXN0b3JlZDogdHJ1ZSxcbiAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgIHByZXZpZXc6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgcGx1Z2luRGF0YSA9IHt9XG4gICAgLy8gVE9ETyBGaW5kIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzP1xuICAgIC8vIE90aGVyIHBsdWdpbnMgY2FuIGF0dGFjaCBhIHJlc3RvcmU6Z2V0LWRhdGEgbGlzdGVuZXIgdGhhdCByZWNlaXZlcyB0aGlzIGNhbGxiYWNrLlxuICAgIC8vIFBsdWdpbnMgY2FuIHRoZW4gdXNlIHRoaXMgY2FsbGJhY2sgKHN5bmMpIHRvIHByb3ZpZGUgZGF0YSB0byBiZSBzdG9yZWQuXG4gICAgdGhpcy51cHB5LmVtaXQoJ3Jlc3RvcmU6Z2V0LWRhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgT2JqZWN0LmFzc2lnbihwbHVnaW5EYXRhLCBkYXRhKVxuICAgIH0pXG5cbiAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuXG4gICAgdGhpcy5NZXRhRGF0YVN0b3JlLnNhdmUoe1xuICAgICAgY3VycmVudFVwbG9hZHMsXG4gICAgICBmaWxlczogZmlsZXNUb1NhdmVXaXRob3V0RGF0YSxcbiAgICAgIHBsdWdpbkRhdGEsXG4gICAgfSlcbiAgfVxuXG4gIGxvYWRGaWxlQmxvYnNGcm9tU2VydmljZVdvcmtlciAoKSB7XG4gICAgaWYgKCF0aGlzLlNlcnZpY2VXb3JrZXJTdG9yZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5TZXJ2aWNlV29ya2VyU3RvcmUubGlzdCgpLnRoZW4oKGJsb2JzKSA9PiB7XG4gICAgICBjb25zdCBmaWxlcyA9IHRoaXMudXBweS5nZXRGaWxlcygpXG4gICAgICBjb25zdCBsb2NhbEZpbGVzT25seSA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgICAvLyBtYXliZSAmJiAhZmlsZS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZVxuICAgICAgICByZXR1cm4gIWZpbGUuaXNSZW1vdGVcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IG51bWJlck9mRmlsZXNSZWNvdmVyZWQgPSBPYmplY3Qua2V5cyhibG9icykubGVuZ3RoXG4gICAgICBjb25zdCBudW1iZXJPZkZpbGVzVHJ5aW5nVG9SZWNvdmVyID0gbG9jYWxGaWxlc09ubHkubGVuZ3RoXG5cbiAgICAgIGlmIChudW1iZXJPZkZpbGVzUmVjb3ZlcmVkID09PSBudW1iZXJPZkZpbGVzVHJ5aW5nVG9SZWNvdmVyKSB7XG4gICAgICAgIHRoaXMudXBweS5sb2coYFtHb2xkZW5SZXRyaWV2ZXJdIFN1Y2Nlc3NmdWxseSByZWNvdmVyZWQgJHtudW1iZXJPZkZpbGVzUmVjb3ZlcmVkfSBibG9icyBmcm9tIFNlcnZpY2UgV29ya2VyIWApXG4gICAgICAgIHJldHVybiBibG9ic1xuICAgICAgfVxuICAgICAgdGhpcy51cHB5LmxvZygnW0dvbGRlblJldHJpZXZlcl0gTm8gYmxvYnMgZm91bmQgaW4gU2VydmljZSBXb3JrZXIsIHRyeWluZyBJbmRleGVkREIgbm93Li4uJylcbiAgICAgIHJldHVybiB7fVxuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tHb2xkZW5SZXRyaWV2ZXJdIEZhaWxlZCB0byByZWNvdmVyIGJsb2JzIGZyb20gU2VydmljZSBXb3JrZXInLCAnd2FybmluZycpXG4gICAgICB0aGlzLnVwcHkubG9nKGVycilcbiAgICAgIHJldHVybiB7fVxuICAgIH0pXG4gIH1cblxuICBsb2FkRmlsZUJsb2JzRnJvbUluZGV4ZWREQiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuSW5kZXhlZERCU3RvcmUubGlzdCgpLnRoZW4oKGJsb2JzKSA9PiB7XG4gICAgICBjb25zdCBudW1iZXJPZkZpbGVzUmVjb3ZlcmVkID0gT2JqZWN0LmtleXMoYmxvYnMpLmxlbmd0aFxuXG4gICAgICBpZiAobnVtYmVyT2ZGaWxlc1JlY292ZXJlZCA+IDApIHtcbiAgICAgICAgdGhpcy51cHB5LmxvZyhgW0dvbGRlblJldHJpZXZlcl0gU3VjY2Vzc2Z1bGx5IHJlY292ZXJlZCAke251bWJlck9mRmlsZXNSZWNvdmVyZWR9IGJsb2JzIGZyb20gSW5kZXhlZERCIWApXG4gICAgICAgIHJldHVybiBibG9ic1xuICAgICAgfVxuICAgICAgdGhpcy51cHB5LmxvZygnW0dvbGRlblJldHJpZXZlcl0gTm8gYmxvYnMgZm91bmQgaW4gSW5kZXhlZERCJylcbiAgICAgIHJldHVybiB7fVxuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tHb2xkZW5SZXRyaWV2ZXJdIEZhaWxlZCB0byByZWNvdmVyIGJsb2JzIGZyb20gSW5kZXhlZERCJywgJ3dhcm5pbmcnKVxuICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgICByZXR1cm4ge31cbiAgICB9KVxuICB9XG5cbiAgb25CbG9ic0xvYWRlZCAoYmxvYnMpIHtcbiAgICBjb25zdCBvYnNvbGV0ZUJsb2JzID0gW11cbiAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSB7IC4uLnRoaXMudXBweS5nZXRTdGF0ZSgpLmZpbGVzIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBibG9icyB0aGF0IHdlIGNhbiByZXN0b3JlLCBhZGQgYmxvYnMgdG8gZmlsZSBvYmplY3RzXG4gICAgT2JqZWN0LmtleXMoYmxvYnMpLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxGaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKVxuICAgICAgaWYgKCFvcmlnaW5hbEZpbGUpIHtcbiAgICAgICAgb2Jzb2xldGVCbG9icy5wdXNoKGZpbGVJRClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSBibG9ic1tmaWxlSURdXG5cbiAgICAgIGNvbnN0IHVwZGF0ZWRGaWxlRGF0YSA9IHtcbiAgICAgICAgZGF0YTogY2FjaGVkRGF0YSxcbiAgICAgICAgaXNSZXN0b3JlZDogdHJ1ZSxcbiAgICAgICAgaXNHaG9zdDogZmFsc2UsXG4gICAgICB9XG4gICAgICB1cGRhdGVkRmlsZXNbZmlsZUlEXSA9IHsgLi4ub3JpZ2luYWxGaWxlLCAuLi51cGRhdGVkRmlsZURhdGEgfVxuICAgIH0pXG5cbiAgICAvLyBMb29wIHRocm91Z2ggZmlsZXMgdGhhdCB3ZSBjYW7igJl0IHJlc3RvcmUgZnVsbHkg4oCUIHdlIG9ubHkgaGF2ZSBtZXRhLCBub3QgYmxvYnMsXG4gICAgLy8gc2V0IC5pc0dob3N0IG9uIHRoZW0sIGFsc28gc2V0IGlzUmVzdG9yZWQgdG8gYWxsIGZpbGVzXG4gICAgT2JqZWN0LmtleXModXBkYXRlZEZpbGVzKS5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgIGlmICh1cGRhdGVkRmlsZXNbZmlsZUlEXS5kYXRhID09PSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZWRGaWxlc1tmaWxlSURdID0ge1xuICAgICAgICAgIC4uLnVwZGF0ZWRGaWxlc1tmaWxlSURdLFxuICAgICAgICAgIGlzR2hvc3Q6IHRydWUsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgIGZpbGVzOiB1cGRhdGVkRmlsZXMsXG4gICAgfSlcblxuICAgIHRoaXMudXBweS5lbWl0KCdyZXN0b3JlZCcsIHRoaXMuc2F2ZWRQbHVnaW5EYXRhKVxuXG4gICAgaWYgKG9ic29sZXRlQmxvYnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmRlbGV0ZUJsb2JzKG9ic29sZXRlQmxvYnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKGBbR29sZGVuUmV0cmlldmVyXSBDbGVhbmVkIHVwICR7b2Jzb2xldGVCbG9icy5sZW5ndGh9IG9sZCBmaWxlc2ApXG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMudXBweS5sb2coYFtHb2xkZW5SZXRyaWV2ZXJdIENvdWxkIG5vdCBjbGVhbiB1cCAke29ic29sZXRlQmxvYnMubGVuZ3RofSBvbGQgZmlsZXNgLCAnd2FybmluZycpXG4gICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBkZWxldGVCbG9icyAoZmlsZUlEcykge1xuICAgIGNvbnN0IHByb21pc2VzID0gW11cbiAgICBmaWxlSURzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICBpZiAodGhpcy5TZXJ2aWNlV29ya2VyU3RvcmUpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLlNlcnZpY2VXb3JrZXJTdG9yZS5kZWxldGUoaWQpKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuSW5kZXhlZERCU3RvcmUpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLkluZGV4ZWREQlN0b3JlLmRlbGV0ZShpZCkpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gIH1cblxuICBhZGRCbG9iVG9TdG9yZXMgPSAoZmlsZSkgPT4ge1xuICAgIGlmIChmaWxlLmlzUmVtb3RlKSByZXR1cm5cblxuICAgIGlmICh0aGlzLlNlcnZpY2VXb3JrZXJTdG9yZSkge1xuICAgICAgdGhpcy5TZXJ2aWNlV29ya2VyU3RvcmUucHV0KGZpbGUpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LmxvZygnW0dvbGRlblJldHJpZXZlcl0gQ291bGQgbm90IHN0b3JlIGZpbGUnLCAnd2FybmluZycpXG4gICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLkluZGV4ZWREQlN0b3JlLnB1dChmaWxlKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKCdbR29sZGVuUmV0cmlldmVyXSBDb3VsZCBub3Qgc3RvcmUgZmlsZScsICd3YXJuaW5nJylcbiAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgIH0pXG4gIH1cblxuICByZW1vdmVCbG9iRnJvbVN0b3JlcyA9IChmaWxlKSA9PiB7XG4gICAgaWYgKHRoaXMuU2VydmljZVdvcmtlclN0b3JlKSB7XG4gICAgICB0aGlzLlNlcnZpY2VXb3JrZXJTdG9yZS5kZWxldGUoZmlsZS5pZCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKCdbR29sZGVuUmV0cmlldmVyXSBGYWlsZWQgdG8gcmVtb3ZlIGZpbGUnLCAnd2FybmluZycpXG4gICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5JbmRleGVkREJTdG9yZS5kZWxldGUoZmlsZS5pZCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZygnW0dvbGRlblJldHJpZXZlcl0gRmFpbGVkIHRvIHJlbW92ZSBmaWxlJywgJ3dhcm5pbmcnKVxuICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgfSlcbiAgfVxuXG4gIHJlcGxhY2VCbG9iSW5TdG9yZXMgPSAoZmlsZSkgPT4ge1xuICAgIHRoaXMucmVtb3ZlQmxvYkZyb21TdG9yZXMoZmlsZSlcbiAgICB0aGlzLmFkZEJsb2JUb1N0b3JlcyhmaWxlKVxuICB9XG5cbiAgaGFuZGxlUmVzdG9yZUNvbmZpcm1lZCA9ICgpID0+IHtcbiAgICB0aGlzLnVwcHkubG9nKCdbR29sZGVuUmV0cmlldmVyXSBSZXN0b3JlIGNvbmZpcm1lZCwgcHJvY2VlZGluZy4uLicpXG4gICAgLy8gc3RhcnQgYWxsIHVwbG9hZHMgYWdhaW4gd2hlbiBmaWxlIGJsb2JzIGFyZSByZXN0b3JlZFxuICAgIGNvbnN0IHsgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG4gICAgaWYgKGN1cnJlbnRVcGxvYWRzKSB7XG4gICAgICBPYmplY3Qua2V5cyhjdXJyZW50VXBsb2FkcykuZm9yRWFjaCgodXBsb2FkSWQpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LnJlc3RvcmUodXBsb2FkSWQsIGN1cnJlbnRVcGxvYWRzW3VwbG9hZElkXSlcbiAgICAgIH0pXG4gICAgICB0aGlzLnVwcHkucmVzdW1lQWxsKClcbiAgICB9XG4gICAgdGhpcy51cHB5LnVwbG9hZCgpXG4gICAgdGhpcy51cHB5LnNldFN0YXRlKHsgcmVjb3ZlcmVkU3RhdGU6IG51bGwgfSlcbiAgfVxuXG4gIGFib3J0UmVzdG9yZSA9ICgpID0+IHtcbiAgICB0aGlzLnVwcHkubG9nKCdbR29sZGVuUmV0cmlldmVyXSBBYm9ydGluZyByZXN0b3JlLi4uJylcblxuICAgIGNvbnN0IGZpbGVJRHMgPSBPYmplY3Qua2V5cyh0aGlzLnVwcHkuZ2V0U3RhdGUoKS5maWxlcylcbiAgICB0aGlzLmRlbGV0ZUJsb2JzKGZpbGVJRHMpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZyhgW0dvbGRlblJldHJpZXZlcl0gUmVtb3ZlZCAke2ZpbGVJRHMubGVuZ3RofSBmaWxlc2ApXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZyhgW0dvbGRlblJldHJpZXZlcl0gQ291bGQgbm90IHJlbW92ZSAke2ZpbGVJRHMubGVuZ3RofSBmaWxlc2AsICd3YXJuaW5nJylcbiAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgIH0pXG5cbiAgICB0aGlzLnVwcHkuY2FuY2VsQWxsKClcbiAgICB0aGlzLnVwcHkuc2V0U3RhdGUoeyByZWNvdmVyZWRTdGF0ZTogbnVsbCB9KVxuICAgIE1ldGFEYXRhU3RvcmUuY2xlYW51cCh0aGlzLnVwcHkub3B0cy5pZClcbiAgfVxuXG4gIGhhbmRsZUNvbXBsZXRlID0gKHsgc3VjY2Vzc2Z1bCB9KSA9PiB7XG4gICAgY29uc3QgZmlsZUlEcyA9IHN1Y2Nlc3NmdWwubWFwKChmaWxlKSA9PiBmaWxlLmlkKVxuICAgIHRoaXMuZGVsZXRlQmxvYnMoZmlsZUlEcykudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKGBbR29sZGVuUmV0cmlldmVyXSBSZW1vdmVkICR7c3VjY2Vzc2Z1bC5sZW5ndGh9IGZpbGVzIHRoYXQgZmluaXNoZWQgdXBsb2FkaW5nYClcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKGBbR29sZGVuUmV0cmlldmVyXSBDb3VsZCBub3QgcmVtb3ZlICR7c3VjY2Vzc2Z1bC5sZW5ndGh9IGZpbGVzIHRoYXQgZmluaXNoZWQgdXBsb2FkaW5nYCwgJ3dhcm5pbmcnKVxuICAgICAgdGhpcy51cHB5LmxvZyhlcnIpXG4gICAgfSlcblxuICAgIHRoaXMudXBweS5zZXRTdGF0ZSh7IHJlY292ZXJlZFN0YXRlOiBudWxsIH0pXG4gICAgTWV0YURhdGFTdG9yZS5jbGVhbnVwKHRoaXMudXBweS5vcHRzLmlkKVxuICB9XG5cbiAgcmVzdG9yZUJsb2JzID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnVwcHkuZ2V0RmlsZXMoKS5sZW5ndGggPiAwKSB7XG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMubG9hZEZpbGVCbG9ic0Zyb21TZXJ2aWNlV29ya2VyKCksXG4gICAgICAgIHRoaXMubG9hZEZpbGVCbG9ic0Zyb21JbmRleGVkREIoKSxcbiAgICAgIF0pLnRoZW4oKHJlc3VsdGluZ0FycmF5T2ZPYmplY3RzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJsb2JzID0geyAuLi5yZXN1bHRpbmdBcnJheU9mT2JqZWN0c1swXSwgLi4ucmVzdWx0aW5nQXJyYXlPZk9iamVjdHNbMV0gfVxuICAgICAgICB0aGlzLm9uQmxvYnNMb2FkZWQoYmxvYnMpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwcHkubG9nKCdbR29sZGVuUmV0cmlldmVyXSBObyBmaWxlcyBuZWVkIHRvIGJlIGxvYWRlZCwgb25seSByZXN0b3JpbmcgcHJvY2Vzc2luZyBzdGF0ZS4uLicpXG4gICAgICB0aGlzLm9uQmxvYnNMb2FkZWQoW10pXG4gICAgfVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy5yZXN0b3JlU3RhdGUoKVxuICAgIHRoaXMucmVzdG9yZUJsb2JzKClcblxuICAgIHRoaXMudXBweS5vbignZmlsZS1hZGRlZCcsIHRoaXMuYWRkQmxvYlRvU3RvcmVzKVxuICAgIHRoaXMudXBweS5vbignZmlsZS1lZGl0b3I6Y29tcGxldGUnLCB0aGlzLnJlcGxhY2VCbG9iSW5TdG9yZXMpXG4gICAgdGhpcy51cHB5Lm9uKCdmaWxlLXJlbW92ZWQnLCB0aGlzLnJlbW92ZUJsb2JGcm9tU3RvcmVzKVxuICAgIHRoaXMudXBweS5vbignc3RhdGUtdXBkYXRlJywgdGhpcy5zYXZlRmlsZXNTdGF0ZVRvTG9jYWxTdG9yYWdlKVxuICAgIHRoaXMudXBweS5vbigncmVzdG9yZS1jb25maXJtZWQnLCB0aGlzLmhhbmRsZVJlc3RvcmVDb25maXJtZWQpXG4gICAgdGhpcy51cHB5Lm9uKCdyZXN0b3JlLWNhbmNlbGVkJywgdGhpcy5hYm9ydFJlc3RvcmUpXG4gICAgdGhpcy51cHB5Lm9uKCdjb21wbGV0ZScsIHRoaXMuaGFuZGxlQ29tcGxldGUpXG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudXBweS5vZmYoJ2ZpbGUtYWRkZWQnLCB0aGlzLmFkZEJsb2JUb1N0b3JlcylcbiAgICB0aGlzLnVwcHkub2ZmKCdmaWxlLWVkaXRvcjpjb21wbGV0ZScsIHRoaXMucmVwbGFjZUJsb2JJblN0b3JlcylcbiAgICB0aGlzLnVwcHkub2ZmKCdmaWxlLXJlbW92ZWQnLCB0aGlzLnJlbW92ZUJsb2JGcm9tU3RvcmVzKVxuICAgIHRoaXMudXBweS5vZmYoJ3N0YXRlLXVwZGF0ZScsIHRoaXMuc2F2ZUZpbGVzU3RhdGVUb0xvY2FsU3RvcmFnZSlcbiAgICB0aGlzLnVwcHkub2ZmKCdyZXN0b3JlLWNvbmZpcm1lZCcsIHRoaXMuaGFuZGxlUmVzdG9yZUNvbmZpcm1lZClcbiAgICB0aGlzLnVwcHkub2ZmKCdyZXN0b3JlLWNhbmNlbGVkJywgdGhpcy5hYm9ydFJlc3RvcmUpXG4gICAgdGhpcy51cHB5Lm9mZignY29tcGxldGUnLCB0aGlzLmhhbmRsZUNvbXBsZXRlKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L2dvb2dsZS1kcml2ZVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIEdvb2dsZSBEcml2ZSBwbHVnaW4gZm9yIFVwcHkgbGV0cyB1c2VycyBpbXBvcnQgZmlsZXMgZnJvbSB0aGVpciBHb29nbGUgRHJpdmUgYWNjb3VudFwiLFxuICBcInZlcnNpb25cIjogXCIxLjcuMlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwiZ29vZ2xlIGRyaXZlXCIsXG4gICAgXCJjbG91ZCBzdG9yYWdlXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29tcGFuaW9uLWNsaWVudFwiOiBcImZpbGU6Li4vY29tcGFuaW9uLWNsaWVudFwiLFxuICAgIFwiQHVwcHkvcHJvdmlkZXItdmlld3NcIjogXCJmaWxlOi4uL3Byb3ZpZGVyLXZpZXdzXCIsXG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIixcbiAgICBcInByZWFjdFwiOiBcIjguMi45XCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvcmVcIjogXCJeMS4wLjBcIlxuICB9XG59XG4iLCJjb25zdCB7IFByb3ZpZGVyVmlld3MgfSA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEcml2ZVByb3ZpZGVyVmlld3MgZXh0ZW5kcyBQcm92aWRlclZpZXdzIHtcbiAgdG9nZ2xlQ2hlY2tib3ggKGUsIGZpbGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAvLyBTaGFyZWQgRHJpdmVzIGFyZW4ndCBzZWxlY3RhYmxlOyBmb3IgYWxsIGVsc2UsIGRlZmVyIHRvIHRoZSBiYXNlIFByb3ZpZGVyVmlldy5cbiAgICAvLyBAdG9kbyBpc1RlYW1Ecml2ZSBpcyBsZWZ0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBXZSBzaG91bGQgcmVtb3ZlIGl0IGluIHRoZSBuZXh0XG4gICAgLy8gbWFqb3IgcmVsZWFzZS5cbiAgICBpZiAoIWZpbGUuY3VzdG9tLmlzVGVhbURyaXZlICYmICFmaWxlLmN1c3RvbS5pc1NoYXJlZERyaXZlKSB7XG4gICAgICBzdXBlci50b2dnbGVDaGVja2JveChlLCBmaWxlKVxuICAgIH1cbiAgfVxufVxuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgeyBQcm92aWRlciB9ID0gcmVxdWlyZSgnQHVwcHkvY29tcGFuaW9uLWNsaWVudCcpXG5jb25zdCBEcml2ZVByb3ZpZGVyVmlld3MgPSByZXF1aXJlKCcuL0RyaXZlUHJvdmlkZXJWaWV3cycpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgR29vZ2xlRHJpdmUgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnR29vZ2xlRHJpdmUnXG4gICAgdGhpcy50aXRsZSA9IHRoaXMub3B0cy50aXRsZSB8fCAnR29vZ2xlIERyaXZlJ1xuICAgIFByb3ZpZGVyLmluaXRQbHVnaW4odGhpcywgb3B0cylcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdHb29nbGUgRHJpdmUnXG4gICAgdGhpcy5pY29uID0gKCkgPT4gKFxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIj5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgZmlsbD1cIiM0Mjg1RjRcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiByeD1cIjE2XCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTEwLjMyNCAyMy4zbDMtNS4xSDI1bC0zIDUuMUgxMC4zMjR6TTEzIDE4LjJsLTMgNS4xLTMtNS4xIDUuODM5LTkuOTI0IDIuOTk5IDUuMUwxMyAxOC4yem0xMS44MzgtLjI3NmgtNkwxMyA4aDZsNS44NCA5LjkyNGgtLjAwMnpcIiBmaWxsPVwiI0ZGRlwiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMgfHwgdGhpcy5vcHRzLnNlcnZlckhlYWRlcnMsXG4gICAgICBjb21wYW5pb25LZXlzUGFyYW1zOiB0aGlzLm9wdHMuY29tcGFuaW9uS2V5c1BhcmFtcyxcbiAgICAgIGNvbXBhbmlvbkNvb2tpZXNSdWxlOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUsXG4gICAgICBwcm92aWRlcjogJ2RyaXZlJyxcbiAgICAgIHBsdWdpbklkOiB0aGlzLmlkLFxuICAgIH0pXG5cbiAgICB0aGlzLm9uRmlyc3RSZW5kZXIgPSB0aGlzLm9uRmlyc3RSZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3ID0gbmV3IERyaXZlUHJvdmlkZXJWaWV3cyh0aGlzLCB7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICB9KVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3LnRlYXJEb3duKClcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgb25GaXJzdFJlbmRlciAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMucHJvdmlkZXIuZmV0Y2hQcmVBdXRoVG9rZW4oKSxcbiAgICAgIHRoaXMudmlldy5nZXRGb2xkZXIoJ3Jvb3QnLCAnLycpLFxuICAgIF0pXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5yZW5kZXIoc3RhdGUpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvaW1hZ2UtZWRpdG9yXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJJbWFnZSBlZGl0b3IgYW5kIGNyb3BwaW5nIFVJXCIsXG4gIFwidmVyc2lvblwiOiBcIjAuMy4wXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJzdHlsZVwiOiBcImRpc3Qvc3R5bGUubWluLmNzc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwbG9hZFwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcImltYWdlIGVkaXRvclwiLFxuICAgIFwiY3JvcHBlclwiLFxuICAgIFwiY3JvcFwiLFxuICAgIFwicm90YXRlXCIsXG4gICAgXCJyZXNpemVcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwiY3JvcHBlcmpzXCI6IFwiMS41LjdcIixcbiAgICBcInByZWFjdFwiOiBcIjguMi45XCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvcmVcIjogXCJeMS4wLjBcIlxuICB9LFxuICBcInB1Ymxpc2hDb25maWdcIjoge1xuICAgIFwiYWNjZXNzXCI6IFwicHVibGljXCJcbiAgfVxufVxuIiwiY29uc3QgQ3JvcHBlciA9IHJlcXVpcmUoJ2Nyb3BwZXJqcycpXG5jb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFZGl0b3IgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLnN0YXRlID0geyByb3RhdGlvbkFuZ2xlOiAwLCByb3RhdGlvbkRlbHRhOiAwIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBjb25zdCB7IG9wdHMsIHN0b3JlQ3JvcHBlckluc3RhbmNlIH0gPSB0aGlzLnByb3BzXG4gICAgdGhpcy5jcm9wcGVyID0gbmV3IENyb3BwZXIoXG4gICAgICB0aGlzLmltZ0VsZW1lbnQsXG4gICAgICBvcHRzLmNyb3BwZXJPcHRpb25zXG4gICAgKVxuICAgIHN0b3JlQ3JvcHBlckluc3RhbmNlKHRoaXMuY3JvcHBlcilcblxuICAgIGlmIChvcHRzLmFjdGlvbnMuZ3JhbnVsYXJSb3RhdGUpIHtcbiAgICAgIHRoaXMuaW1nRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjcm9wJywgKGV2KSA9PiB7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uQW5nbGUgPSBldi5kZXRhaWwucm90YXRlXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHJvdGF0aW9uQW5nbGUsXG4gICAgICAgICAgLy8gNDA1ID09IDM2MCArIDQ1XG4gICAgICAgICAgcm90YXRpb25EZWx0YTogKChyb3RhdGlvbkFuZ2xlICsgNDA1KSAlIDkwKSAtIDQ1LFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgdGhpcy5jcm9wcGVyLmRlc3Ryb3koKVxuICB9XG5cbiAgcmVuZGVyUmV2ZXJ0ICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG5cIlxuICAgICAgICBhcmlhLWxhYmVsPXt0aGlzLnByb3BzLmkxOG4oJ3JldmVydCcpfVxuICAgICAgICBkYXRhLW1pY3JvdGlwLXBvc2l0aW9uPVwidG9wXCJcbiAgICAgICAgcm9sZT1cInRvb2x0aXBcIlxuICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jcm9wcGVyLnJlc2V0KClcbiAgICAgICAgICB0aGlzLmNyb3BwZXIuc2V0QXNwZWN0UmF0aW8oMClcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTEzIDNjLTQuOTcgMC05IDQuMDMtOSA5SDFsMy44OSAzLjg5LjA3LjE0TDkgMTJINmMwLTMuODcgMy4xMy03IDctN3M3IDMuMTMgNyA3LTMuMTMgNy03IDdjLTEuOTMgMC0zLjY4LS43OS00Ljk0LTIuMDZsLTEuNDIgMS40MkM4LjI3IDE5Ljk5IDEwLjUxIDIxIDEzIDIxYzQuOTcgMCA5LTQuMDMgOS05cy00LjAzLTktOS05em0tMSA1djVsNC4yOCAyLjU0LjcyLTEuMjEtMy41LTIuMDhWOEgxMnpcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvYnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIHJlbmRlclJvdGF0ZSAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuXCJcbiAgICAgICAgb25DbGljaz17KCkgPT4gdGhpcy5jcm9wcGVyLnJvdGF0ZSgtOTApfVxuICAgICAgICBhcmlhLWxhYmVsPXt0aGlzLnByb3BzLmkxOG4oJ3JvdGF0ZScpfVxuICAgICAgICBkYXRhLW1pY3JvdGlwLXBvc2l0aW9uPVwidG9wXCJcbiAgICAgICAgcm9sZT1cInRvb2x0aXBcIlxuICAgICAgPlxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMCAwaDI0djI0SDBWMHptMCAwaDI0djI0SDBWMHpcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xNCAxMGEyIDIgMCAwMTIgMnY3YTIgMiAwIDAxLTIgMkg2YTIgMiAwIDAxLTItMnYtN2EyIDIgMCAwMTItMmg4em0wIDEuNzVINmEuMjUuMjUgMCAwMC0uMjQzLjE5M0w1Ljc1IDEydjdhLjI1LjI1IDAgMDAuMTkzLjI0M0w2IDE5LjI1aDhhLjI1LjI1IDAgMDAuMjQzLS4xOTNMMTQuMjUgMTl2LTdhLjI1LjI1IDAgMDAtLjE5My0uMjQzTDE0IDExLjc1ek0xMiAuNzZWNGMyLjMgMCA0LjYxLjg4IDYuMzYgMi42NGE4Ljk1IDguOTUgMCAwMTIuNjM0IDYuMDI1TDIxIDEzYTEgMSAwIDAxLTEuOTkzLjExN0wxOSAxM2gtLjAwM2E2Ljk3OSA2Ljk3OSAwIDAwLTIuMDQ3LTQuOTUgNi45NyA2Ljk3IDAgMDAtNC42NTItMi4wNDRMMTIgNnYzLjI0TDcuNzYgNSAxMiAuNzZ6XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cblxuICBncmFudWxhclJvdGF0ZU9uQ2hhbmdlID0gKGV2KSA9PiB7XG4gICAgY29uc3QgeyByb3RhdGlvbkFuZ2xlLCByb3RhdGlvbkRlbHRhIH0gPSB0aGlzLnN0YXRlXG4gICAgY29uc3QgcGVuZGluZ1JvdGF0aW9uRGVsdGEgPSBOdW1iZXIoZXYudGFyZ2V0LnZhbHVlKSAtIHJvdGF0aW9uRGVsdGFcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmdyYW51bGFyUm90YXRlT25JbnB1dE5leHRGcmFtZSlcbiAgICBpZiAocGVuZGluZ1JvdGF0aW9uRGVsdGEgIT09IDApIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdSb3RhdGlvbkFuZ2xlID0gcm90YXRpb25BbmdsZSArIHBlbmRpbmdSb3RhdGlvbkRlbHRhXG4gICAgICB0aGlzLmdyYW51bGFyUm90YXRlT25JbnB1dE5leHRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuY3JvcHBlci5yb3RhdGVUbyhwZW5kaW5nUm90YXRpb25BbmdsZSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmVuZGVyR3JhbnVsYXJSb3RhdGUgKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8bGFiZWxcbiAgICAgICAgZGF0YS1taWNyb3RpcC1wb3NpdGlvbj1cInRvcFwiXG4gICAgICAgIHJvbGU9XCJ0b29sdGlwXCJcbiAgICAgICAgYXJpYS1sYWJlbD17YCR7dGhpcy5zdGF0ZS5yb3RhdGlvbkFuZ2xlfcK6YH1cbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1JbWFnZUNyb3BwZXItcmFuZ2VXcmFwcGVyIHVwcHktdS1yZXNldFwiXG4gICAgICA+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktSW1hZ2VDcm9wcGVyLXJhbmdlIHVwcHktdS1yZXNldFwiXG4gICAgICAgICAgdHlwZT1cInJhbmdlXCJcbiAgICAgICAgICBvbklucHV0PXt0aGlzLmdyYW51bGFyUm90YXRlT25DaGFuZ2V9XG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuZ3JhbnVsYXJSb3RhdGVPbkNoYW5nZX1cbiAgICAgICAgICB2YWx1ZT17dGhpcy5zdGF0ZS5yb3RhdGlvbkRlbHRhfVxuICAgICAgICAgIG1pbj1cIi00NVwiXG4gICAgICAgICAgbWF4PVwiNDRcIlxuICAgICAgICAgIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuaTE4bigncm90YXRlJyl9XG4gICAgICAgIC8+XG4gICAgICA8L2xhYmVsPlxuICAgIClcbiAgfVxuXG4gIHJlbmRlckZsaXAgKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0blwiXG4gICAgICAgIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuaTE4bignZmxpcEhvcml6b250YWwnKX1cbiAgICAgICAgZGF0YS1taWNyb3RpcC1wb3NpdGlvbj1cInRvcFwiXG4gICAgICAgIHJvbGU9XCJ0b29sdGlwXCJcbiAgICAgICAgb25DbGljaz17KCkgPT4gdGhpcy5jcm9wcGVyLnNjYWxlWCgtdGhpcy5jcm9wcGVyLmdldERhdGEoKS5zY2FsZVggfHwgLTEpfVxuICAgICAgPlxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIiAvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTUgMjFoMnYtMmgtMnYyem00LTEyaDJWN2gtMnYyek0zIDV2MTRjMCAxLjEuOSAyIDIgMmg0di0ySDVWNWg0VjNINWMtMS4xIDAtMiAuOS0yIDJ6bTE2LTJ2MmgyYzAtMS4xLS45LTItMi0yem0tOCAyMGgyVjFoLTJ2MjJ6bTgtNmgydi0yaC0ydjJ6TTE1IDVoMlYzaC0ydjJ6bTQgOGgydi0yaC0ydjJ6bTAgOGMxLjEgMCAyLS45IDItMmgtMnYyelwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9idXR0b24+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyWm9vbUluICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG5cIlxuICAgICAgICBhcmlhLWxhYmVsPXt0aGlzLnByb3BzLmkxOG4oJ3pvb21JbicpfVxuICAgICAgICBkYXRhLW1pY3JvdGlwLXBvc2l0aW9uPVwidG9wXCJcbiAgICAgICAgcm9sZT1cInRvb2x0aXBcIlxuICAgICAgICBvbkNsaWNrPXsoKSA9PiB0aGlzLmNyb3BwZXIuem9vbSgwLjEpfVxuICAgICAgPlxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgd2lkdGg9XCIyNFwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMCAwaDI0djI0SDBWMHpcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xNS41IDE0aC0uNzlsLS4yOC0uMjdDMTUuNDEgMTIuNTkgMTYgMTEuMTEgMTYgOS41IDE2IDUuOTEgMTMuMDkgMyA5LjUgM1MzIDUuOTEgMyA5LjUgNS45MSAxNiA5LjUgMTZjMS42MSAwIDMuMDktLjU5IDQuMjMtMS41N2wuMjcuMjh2Ljc5bDUgNC45OUwyMC40OSAxOWwtNC45OS01em0tNiAwQzcuMDEgMTQgNSAxMS45OSA1IDkuNVM3LjAxIDUgOS41IDUgMTQgNy4wMSAxNCA5LjUgMTEuOTkgMTQgOS41IDE0elwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMiAxMGgtMnYySDl2LTJIN1Y5aDJWN2gxdjJoMnYxelwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9idXR0b24+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyWm9vbU91dCAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuXCJcbiAgICAgICAgYXJpYS1sYWJlbD17dGhpcy5wcm9wcy5pMThuKCd6b29tT3V0Jyl9XG4gICAgICAgIGRhdGEtbWljcm90aXAtcG9zaXRpb249XCJ0b3BcIlxuICAgICAgICByb2xlPVwidG9vbHRpcFwiXG4gICAgICAgIG9uQ2xpY2s9eygpID0+IHRoaXMuY3JvcHBlci56b29tKC0wLjEpfVxuICAgICAgPlxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMCAwaDI0djI0SDBWMHpcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xNS41IDE0aC0uNzlsLS4yOC0uMjdDMTUuNDEgMTIuNTkgMTYgMTEuMTEgMTYgOS41IDE2IDUuOTEgMTMuMDkgMyA5LjUgM1MzIDUuOTEgMyA5LjUgNS45MSAxNiA5LjUgMTZjMS42MSAwIDMuMDktLjU5IDQuMjMtMS41N2wuMjcuMjh2Ljc5bDUgNC45OUwyMC40OSAxOWwtNC45OS01em0tNiAwQzcuMDEgMTQgNSAxMS45OSA1IDkuNVM3LjAxIDUgOS41IDUgMTQgNy4wMSAxNCA5LjUgMTEuOTkgMTQgOS41IDE0ek03IDloNXYxSDd6XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cblxuICByZW5kZXJDcm9wU3F1YXJlICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG5cIlxuICAgICAgICBhcmlhLWxhYmVsPXt0aGlzLnByb3BzLmkxOG4oJ2FzcGVjdFJhdGlvU3F1YXJlJyl9XG4gICAgICAgIGRhdGEtbWljcm90aXAtcG9zaXRpb249XCJ0b3BcIlxuICAgICAgICByb2xlPVwidG9vbHRpcFwiXG4gICAgICAgIG9uQ2xpY2s9eygpID0+IHRoaXMuY3JvcHBlci5zZXRBc3BlY3RSYXRpbygxKX1cbiAgICAgID5cbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTTAgMGgyNHYyNEgwelwiIGZpbGw9XCJub25lXCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTE5IDV2MTRINVY1aDE0bTAtMkg1Yy0xLjEgMC0yIC45LTIgMnYxNGMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cblxuICByZW5kZXJDcm9wV2lkZXNjcmVlbiAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuXCJcbiAgICAgICAgYXJpYS1sYWJlbD17dGhpcy5wcm9wcy5pMThuKCdhc3BlY3RSYXRpb0xhbmRzY2FwZScpfVxuICAgICAgICBkYXRhLW1pY3JvdGlwLXBvc2l0aW9uPVwidG9wXCJcbiAgICAgICAgcm9sZT1cInRvb2x0aXBcIlxuICAgICAgICBvbkNsaWNrPXsoKSA9PiB0aGlzLmNyb3BwZXIuc2V0QXNwZWN0UmF0aW8oMTYgLyA5KX1cbiAgICAgID5cbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTSAxOSw0Ljk5OTk5OTIgViAxNy4wMDAwMDEgSCA0Ljk5OTk5OTggViA2Ljk5OTk5OTIgSCAxOSBtIDAsLTIgSCA0Ljk5OTk5OTggYyAtMS4wOTk5OTk5LDAgLTEuOTk5OTk5OSwwLjkwMDAwMDEgLTEuOTk5OTk5OSwyIFYgMTcuMDAwMDAxIGMgMCwxLjEgMC45LDIgMS45OTk5OTk5LDIgSCAxOSBjIDEuMSwwIDIsLTAuOSAyLC0yIFYgNi45OTk5OTkyIGMgMCwtMS4wOTk5OTk5IC0wLjksLTIgLTIsLTIgelwiIC8+XG4gICAgICAgICAgPHBhdGggZmlsbD1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9idXR0b24+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyQ3JvcFdpZGVzY3JlZW5WZXJ0aWNhbCAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuXCJcbiAgICAgICAgYXJpYS1sYWJlbD17dGhpcy5wcm9wcy5pMThuKCdhc3BlY3RSYXRpb1BvcnRyYWl0Jyl9XG4gICAgICAgIGRhdGEtbWljcm90aXAtcG9zaXRpb249XCJ0b3BcIlxuICAgICAgICByb2xlPVwidG9vbHRpcFwiXG4gICAgICAgIG9uQ2xpY2s9eygpID0+IHRoaXMuY3JvcHBlci5zZXRBc3BlY3RSYXRpbyg5IC8gMTYpfVxuICAgICAgPlxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNIDE5LjAwMDAwMSwxOSBIIDYuOTk5OTk5IFYgNSBoIDEwLjAwMDAwMiB2IDE0IG0gMiwwIFYgNSBjIDAsLTEuMDk5OTk5OSAtMC45LC0xLjk5OTk5OTkgLTIsLTEuOTk5OTk5OSBIIDYuOTk5OTk5IGMgLTEuMSwwIC0yLDAuOSAtMiwxLjk5OTk5OTkgdiAxNCBjIDAsMS4xIDAuOSwyIDIsMiBoIDEwLjAwMDAwMiBjIDEuMSwwIDIsLTAuOSAyLC0yIHpcIiAvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvYnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3QgeyBjdXJyZW50SW1hZ2UsIGkxOG4sIG9wdHMgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB7IGFjdGlvbnMgfSA9IG9wdHNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICAgIGNvbnN0IGltYWdlVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChjdXJyZW50SW1hZ2UuZGF0YSlcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktSW1hZ2VDcm9wcGVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1JbWFnZUNyb3BwZXItY29udGFpbmVyXCI+XG4gICAgICAgICAgPGltZ1xuICAgICAgICAgICAgY2xhc3NOYW1lPVwidXBweS1JbWFnZUNyb3BwZXItaW1hZ2VcIlxuICAgICAgICAgICAgYWx0PXtjdXJyZW50SW1hZ2UubmFtZX1cbiAgICAgICAgICAgIHNyYz17aW1hZ2VVUkx9XG4gICAgICAgICAgICByZWY9e3JlZiA9PiB7IHRoaXMuaW1nRWxlbWVudCA9IHJlZiB9fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1JbWFnZUNyb3BwZXItY29udHJvbHNcIj5cbiAgICAgICAgICB7YWN0aW9ucy5yZXZlcnQgJiYgdGhpcy5yZW5kZXJSZXZlcnQoKX1cbiAgICAgICAgICB7YWN0aW9ucy5yb3RhdGUgJiYgdGhpcy5yZW5kZXJSb3RhdGUoKX1cbiAgICAgICAgICB7YWN0aW9ucy5ncmFudWxhclJvdGF0ZSAmJiB0aGlzLnJlbmRlckdyYW51bGFyUm90YXRlKCl9XG4gICAgICAgICAge2FjdGlvbnMuZmxpcCAmJiB0aGlzLnJlbmRlckZsaXAoKX1cbiAgICAgICAgICB7YWN0aW9ucy56b29tSW4gJiYgdGhpcy5yZW5kZXJab29tSW4oKX1cbiAgICAgICAgICB7YWN0aW9ucy56b29tT3V0ICYmIHRoaXMucmVuZGVyWm9vbU91dCgpfVxuICAgICAgICAgIHthY3Rpb25zLmNyb3BTcXVhcmUgJiYgdGhpcy5yZW5kZXJDcm9wU3F1YXJlKCl9XG4gICAgICAgICAge2FjdGlvbnMuY3JvcFdpZGVzY3JlZW4gJiYgdGhpcy5yZW5kZXJDcm9wV2lkZXNjcmVlbigpfVxuICAgICAgICAgIHthY3Rpb25zLmNyb3BXaWRlc2NyZWVuVmVydGljYWwgJiYgdGhpcy5yZW5kZXJDcm9wV2lkZXNjcmVlblZlcnRpY2FsKCl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG4iLCJjb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCBFZGl0b3IgPSByZXF1aXJlKCcuL0VkaXRvcicpXG5jb25zdCBUcmFuc2xhdG9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL1RyYW5zbGF0b3InKVxuY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEltYWdlRWRpdG9yIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0ltYWdlRWRpdG9yJ1xuICAgIHRoaXMudGl0bGUgPSAnSW1hZ2UgRWRpdG9yJ1xuICAgIHRoaXMudHlwZSA9ICdlZGl0b3InXG5cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSB7XG4gICAgICBzdHJpbmdzOiB7XG4gICAgICAgIHJldmVydDogJ1JldmVydCcsXG4gICAgICAgIHJvdGF0ZTogJ1JvdGF0ZScsXG4gICAgICAgIHpvb21JbjogJ1pvb20gaW4nLFxuICAgICAgICB6b29tT3V0OiAnWm9vbSBvdXQnLFxuICAgICAgICBmbGlwSG9yaXpvbnRhbDogJ0ZsaXAgaG9yaXpvbnRhbCcsXG4gICAgICAgIGFzcGVjdFJhdGlvU3F1YXJlOiAnQ3JvcCBzcXVhcmUnLFxuICAgICAgICBhc3BlY3RSYXRpb0xhbmRzY2FwZTogJ0Nyb3AgbGFuZHNjYXBlICgxNjo5KScsXG4gICAgICAgIGFzcGVjdFJhdGlvUG9ydHJhaXQ6ICdDcm9wIHBvcnRyYWl0ICg5OjE2KScsXG4gICAgICB9LFxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRDcm9wcGVyT3B0aW9ucyA9IHtcbiAgICAgIHZpZXdNb2RlOiAxLFxuICAgICAgYmFja2dyb3VuZDogZmFsc2UsXG4gICAgICBhdXRvQ3JvcEFyZWE6IDEsXG4gICAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRBY3Rpb25zID0ge1xuICAgICAgcmV2ZXJ0OiB0cnVlLFxuICAgICAgcm90YXRlOiB0cnVlLFxuICAgICAgZ3JhbnVsYXJSb3RhdGU6IHRydWUsXG4gICAgICBmbGlwOiB0cnVlLFxuICAgICAgem9vbUluOiB0cnVlLFxuICAgICAgem9vbU91dDogdHJ1ZSxcbiAgICAgIGNyb3BTcXVhcmU6IHRydWUsXG4gICAgICBjcm9wV2lkZXNjcmVlbjogdHJ1ZSxcbiAgICAgIGNyb3BXaWRlc2NyZWVuVmVydGljYWw6IHRydWUsXG4gICAgfVxuXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBxdWFsaXR5OiAwLjgsXG4gICAgfVxuXG4gICAgdGhpcy5vcHRzID0ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRzLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAuLi5kZWZhdWx0QWN0aW9ucyxcbiAgICAgICAgLi4ub3B0cy5hY3Rpb25zLFxuICAgICAgfSxcbiAgICAgIGNyb3BwZXJPcHRpb25zOiB7XG4gICAgICAgIC4uLmRlZmF1bHRDcm9wcGVyT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0cy5jcm9wcGVyT3B0aW9ucyxcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgdGhpcy5pMThuSW5pdCgpXG4gIH1cblxuICBzZXRPcHRpb25zIChuZXdPcHRzKSB7XG4gICAgc3VwZXIuc2V0T3B0aW9ucyhuZXdPcHRzKVxuICAgIHRoaXMuaTE4bkluaXQoKVxuICB9XG5cbiAgaTE4bkluaXQgKCkge1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKFt0aGlzLmRlZmF1bHRMb2NhbGUsIHRoaXMudXBweS5sb2NhbGUsIHRoaXMub3B0cy5sb2NhbGVdKVxuICAgIHRoaXMuaTE4biA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgLy8gdGhpcy5pMThuQXJyYXkgPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlQXJyYXkuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyBhbmQgd2Ugc2VlIHRoZSB1cGRhdGVkIGxvY2FsZVxuICB9XG5cbiAgY2FuRWRpdEZpbGUgKGZpbGUpIHtcbiAgICBpZiAoIWZpbGUudHlwZSB8fCBmaWxlLmlzUmVtb3RlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlVHlwZVNwZWNpZmljID0gZmlsZS50eXBlLnNwbGl0KCcvJylbMV1cblxuICAgIGlmICgvXihqcGU/Z3xnaWZ8cG5nfGJtcHx3ZWJwKSQvLnRlc3QoZmlsZVR5cGVTcGVjaWZpYykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBzYXZlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNhdmVCbG9iQ2FsbGJhY2sgPSAoYmxvYikgPT4ge1xuICAgICAgY29uc3QgeyBjdXJyZW50SW1hZ2UgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgICB0aGlzLnVwcHkuc2V0RmlsZVN0YXRlKGN1cnJlbnRJbWFnZS5pZCwge1xuICAgICAgICBkYXRhOiBibG9iLFxuICAgICAgICBzaXplOiBibG9iLnNpemUsXG4gICAgICAgIHByZXZpZXc6IG51bGwsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCB1cGRhdGVkRmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGN1cnJlbnRJbWFnZS5pZClcbiAgICAgIHRoaXMudXBweS5lbWl0KCd0aHVtYm5haWw6cmVxdWVzdCcsIHVwZGF0ZWRGaWxlKVxuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGN1cnJlbnRJbWFnZTogdXBkYXRlZEZpbGUsXG4gICAgICB9KVxuICAgICAgdGhpcy51cHB5LmVtaXQoJ2ZpbGUtZWRpdG9yOmNvbXBsZXRlJywgdXBkYXRlZEZpbGUpXG4gICAgfVxuXG4gICAgY29uc3QgeyBjdXJyZW50SW1hZ2UgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgdGhpcy5jcm9wcGVyLmdldENyb3BwZWRDYW52YXMoKS50b0Jsb2IoXG4gICAgICBzYXZlQmxvYkNhbGxiYWNrLFxuICAgICAgY3VycmVudEltYWdlLnR5cGUsXG4gICAgICB0aGlzLm9wdHMucXVhbGl0eVxuICAgIClcbiAgfVxuXG4gIHN0b3JlQ3JvcHBlckluc3RhbmNlID0gKGNyb3BwZXIpID0+IHtcbiAgICB0aGlzLmNyb3BwZXIgPSBjcm9wcGVyXG4gIH1cblxuICBzZWxlY3RGaWxlID0gKGZpbGUpID0+IHtcbiAgICB0aGlzLnVwcHkuZW1pdCgnZmlsZS1lZGl0b3I6c3RhcnQnLCBmaWxlKVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgY3VycmVudEltYWdlOiBmaWxlLFxuICAgIH0pXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGN1cnJlbnRJbWFnZTogbnVsbCxcbiAgICB9KVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3QgeyBjdXJyZW50SW1hZ2UgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGlmIChjdXJyZW50SW1hZ2UgPT09IG51bGwgfHwgY3VycmVudEltYWdlLmlzUmVtb3RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEVkaXRvclxuICAgICAgICBjdXJyZW50SW1hZ2U9e2N1cnJlbnRJbWFnZX1cbiAgICAgICAgc3RvcmVDcm9wcGVySW5zdGFuY2U9e3RoaXMuc3RvcmVDcm9wcGVySW5zdGFuY2V9XG4gICAgICAgIHNhdmU9e3RoaXMuc2F2ZX1cbiAgICAgICAgb3B0cz17dGhpcy5vcHRzfVxuICAgICAgICBpMThuPXt0aGlzLmkxOG59XG4gICAgICAvPlxuICAgIClcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9pbmZvcm1lclwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBub3RpZmljYXRpb24gYW5kIGVycm9yIHBvcC11cCBiYXIgZm9yIFVwcHkuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuNi42XCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJzdHlsZVwiOiBcImRpc3Qvc3R5bGUubWluLmNzc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJub3RpZmljYXRpb25cIixcbiAgICBcImJhclwiLFxuICAgIFwidWlcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuLyoqXG4gKiBJbmZvcm1lclxuICogU2hvd3MgcmFkIG1lc3NhZ2UgYnViYmxlc1xuICogdXNlZCBsaWtlIHRoaXM6IGB1cHB5LmluZm8oJ2hlbGxvIHdvcmxkJywgJ2luZm8nLCA1MDAwKWBcbiAqIG9yIGZvciBlcnJvcnM6IGB1cHB5LmluZm8oJ0Vycm9yIHVwbG9hZGluZyBpbWcuanBnJywgJ2Vycm9yJywgNTAwMClgXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEluZm9ybWVyIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMudHlwZSA9ICdwcm9ncmVzc2luZGljYXRvcidcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdJbmZvcm1lcidcbiAgICB0aGlzLnRpdGxlID0gJ0luZm9ybWVyJ1xuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge31cbiAgICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlclxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuICB9XG5cbiAgcmVuZGVyID0gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyBpc0hpZGRlbiwgbWVzc2FnZSwgZGV0YWlscyB9ID0gc3RhdGUuaW5mb1xuXG4gICAgZnVuY3Rpb24gZGlzcGxheUVycm9yQWxlcnQgKCkge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYCR7bWVzc2FnZX0gXFxuXFxuICR7ZGV0YWlsc31gXG4gICAgICBhbGVydChlcnJvck1lc3NhZ2UpXG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlTW91c2VPdmVyID0gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudXBweS5pbmZvVGltZW91dElEKVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZU1vdXNlTGVhdmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnVwcHkuaW5mb1RpbWVvdXRJRCA9IHNldFRpbWVvdXQodGhpcy51cHB5LmhpZGVJbmZvLCAyMDAwKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHkgdXBweS1JbmZvcm1lclwiXG4gICAgICAgIGFyaWEtaGlkZGVuPXtpc0hpZGRlbn1cbiAgICAgID5cbiAgICAgICAgPHAgcm9sZT1cImFsZXJ0XCI+XG4gICAgICAgICAge21lc3NhZ2V9XG4gICAgICAgICAgeycgJ31cbiAgICAgICAgICB7ZGV0YWlscyAmJiAoXG4gICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICBhcmlhLWxhYmVsPXtkZXRhaWxzfVxuICAgICAgICAgICAgICBkYXRhLW1pY3JvdGlwLXBvc2l0aW9uPVwidG9wLWxlZnRcIlxuICAgICAgICAgICAgICBkYXRhLW1pY3JvdGlwLXNpemU9XCJtZWRpdW1cIlxuICAgICAgICAgICAgICByb2xlPVwidG9vbHRpcFwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2Rpc3BsYXlFcnJvckFsZXJ0fVxuICAgICAgICAgICAgICBvbk1vdXNlT3Zlcj17aGFuZGxlTW91c2VPdmVyfVxuICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9e2hhbmRsZU1vdXNlTGVhdmV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgID9cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICApfVxuICAgICAgICA8L3A+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLm9wdHMudGFyZ2V0XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L2luc3RhZ3JhbVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiSW1wb3J0IHBob3RvcyBhbmQgdmlkZW9zIGZyb20gSW5zdGFncmFtLCBpbnRvIFVwcHkuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuNS4yXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwiaW5zdGFncmFtXCIsXG4gICAgXCJwcm92aWRlclwiLFxuICAgIFwicGhvdG9zXCIsXG4gICAgXCJ2aWRlb3NcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvbXBhbmlvbi1jbGllbnRcIjogXCJmaWxlOi4uL2NvbXBhbmlvbi1jbGllbnRcIixcbiAgICBcIkB1cHB5L3Byb3ZpZGVyLXZpZXdzXCI6IFwiZmlsZTouLi9wcm92aWRlci12aWV3c1wiLFxuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgeyBQcm92aWRlciB9ID0gcmVxdWlyZSgnQHVwcHkvY29tcGFuaW9uLWNsaWVudCcpXG5jb25zdCB7IFByb3ZpZGVyVmlld3MgfSA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBJbnN0YWdyYW0gZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnSW5zdGFncmFtJ1xuICAgIFByb3ZpZGVyLmluaXRQbHVnaW4odGhpcywgb3B0cylcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdJbnN0YWdyYW0nXG4gICAgdGhpcy5pY29uID0gKCkgPT4gKFxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIj5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgZmlsbD1cIiNFMTMwNkNcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiByeD1cIjE2XCIgLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTE2IDguNjIyYzIuNDAzIDAgMi42ODguMDA5IDMuNjM3LjA1Mi44NzcuMDQgMS4zNTQuMTg3IDEuNjcuMzEuMzkyLjE0NC43NDUuMzc0IDEuMDM2LjY3My4yOTkuMjkuNTI5LjY0NC42NzMgMS4wMzUuMTIzLjMxNy4yNy43OTQuMzEgMS42NzEuMDQzLjk1LjA1MiAxLjIzNC4wNTIgMy42MzdzLS4wMDkgMi42ODgtLjA1MiAzLjYzN2MtLjA0Ljg3Ny0uMTg3IDEuMzU0LS4zMSAxLjY3MWEyLjk4IDIuOTggMCAwIDEtMS43MDggMS43MDhjLS4zMTcuMTIzLS43OTQuMjctMS42NzEuMzEtLjk1LjA0My0xLjIzNC4wNTMtMy42MzcuMDUzcy0yLjY4OC0uMDEtMy42MzctLjA1M2MtLjg3Ny0uMDQtMS4zNTQtLjE4Ny0xLjY3MS0uMzFhMi43ODggMi43ODggMCAwIDEtMS4wMzUtLjY3MyAyLjc4OCAyLjc4OCAwIDAgMS0uNjczLTEuMDM1Yy0uMTIzLS4zMTctLjI3LS43OTQtLjMxLTEuNjcxLS4wNDMtLjk0OS0uMDUyLTEuMjM0LS4wNTItMy42MzdzLjAwOS0yLjY4OC4wNTItMy42MzdjLjA0LS44NzcuMTg3LTEuMzU0LjMxLTEuNjcuMTQ0LS4zOTIuMzc0LS43NDUuNjczLTEuMDM2LjI5LS4yOTkuNjQ0LS41MjkgMS4wMzUtLjY3My4zMTctLjEyMy43OTQtLjI3IDEuNjcxLS4zMS45NS0uMDQzIDEuMjM0LS4wNTIgMy42MzctLjA1MnpNMTYgN2MtMi40NDQgMC0yLjc1LjAxLTMuNzEuMDU0LS45NTkuMDQ0LTEuNjEzLjE5Ni0yLjE4NS40MTktLjYuMjI1LTEuMTQ1LjU4LTEuNTk0IDEuMDM4LS40NTguNDUtLjgxMy45OTMtMS4wMzkgMS41OTQtLjIyMi41NzItLjM3NCAxLjIyNi0uNDE4IDIuMTg0QzcuMDEgMTMuMjUgNyAxMy41NTYgNyAxNnMuMDEgMi43NS4wNTQgMy43MWMuMDQ0Ljk1OS4xOTYgMS42MTMuNDE5IDIuMTg1LjIyNi42LjU4IDEuMTQ1IDEuMDM4IDEuNTk0LjQ1LjQ1OC45OTMuODEzIDEuNTk0IDEuMDM4LjU3Mi4yMjMgMS4yMjcuMzc1IDIuMTg0LjQxOS45Ni4wNDQgMS4yNjcuMDU0IDMuNzExLjA1NHMyLjc1LS4wMSAzLjcxLS4wNTRjLjk1OS0uMDQ0IDEuNjEzLS4xOTYgMi4xODUtLjQxOWE0LjYwMiA0LjYwMiAwIDAgMCAyLjYzMi0yLjYzMmMuMjIzLS41NzIuMzc1LTEuMjI2LjQxOS0yLjE4NC4wNDQtLjk2LjA1NC0xLjI2Ny4wNTQtMy43MTFzLS4wMS0yLjc1LS4wNTQtMy43MWMtLjA0NC0uOTU5LS4xOTYtMS42MTMtLjQxOS0yLjE4NUE0LjQxMiA0LjQxMiAwIDAgMCAyMy40OSA4LjUxYTQuNDEyIDQuNDEyIDAgMCAwLTEuNTk0LTEuMDM5Yy0uNTcyLS4yMjItMS4yMjYtLjM3NC0yLjE4NC0uNDE4QzE4Ljc1IDcuMDEgMTguNDQ0IDcgMTYgN3ptMCA0LjVhNC41IDQuNSAwIDEgMCAwIDkgNC41IDQuNSAwIDAgMCAwLTl6bTAgNy40MjFhMi45MjEgMi45MjEgMCAxIDEgMC01Ljg0MiAyLjkyMSAyLjkyMSAwIDAgMSAwIDUuODQyem00Ljg3NS02LjY3MWExLjEyNSAxLjEyNSAwIDEgMSAwLTIuMjUgMS4xMjUgMS4xMjUgMCAwIDEgMCAyLjI1elwiIGZpbGw9XCIjRkZGXCIgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgKVxuXG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyBQcm92aWRlcih1cHB5LCB7XG4gICAgICBjb21wYW5pb25Vcmw6IHRoaXMub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICBjb21wYW5pb25IZWFkZXJzOiB0aGlzLm9wdHMuY29tcGFuaW9uSGVhZGVycyB8fCB0aGlzLm9wdHMuc2VydmVySGVhZGVycyxcbiAgICAgIGNvbXBhbmlvbktleXNQYXJhbXM6IHRoaXMub3B0cy5jb21wYW5pb25LZXlzUGFyYW1zLFxuICAgICAgY29tcGFuaW9uQ29va2llc1J1bGU6IHRoaXMub3B0cy5jb21wYW5pb25Db29raWVzUnVsZSxcbiAgICAgIHByb3ZpZGVyOiAnaW5zdGFncmFtJyxcbiAgICAgIHBsdWdpbklkOiB0aGlzLmlkLFxuICAgIH0pXG5cbiAgICB0aGlzLm9uRmlyc3RSZW5kZXIgPSB0aGlzLm9uRmlyc3RSZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3ID0gbmV3IFByb3ZpZGVyVmlld3ModGhpcywge1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICB2aWV3VHlwZTogJ2dyaWQnLFxuICAgICAgc2hvd1RpdGxlczogZmFsc2UsXG4gICAgICBzaG93RmlsdGVyOiBmYWxzZSxcbiAgICAgIHNob3dCcmVhZGNydW1iczogZmFsc2UsXG4gICAgfSlcblxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0cy50YXJnZXRcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1vdW50KHRhcmdldCwgdGhpcylcbiAgICB9XG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldy50ZWFyRG93bigpXG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxuXG4gIG9uRmlyc3RSZW5kZXIgKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnByb3ZpZGVyLmZldGNoUHJlQXV0aFRva2VuKCksXG4gICAgICB0aGlzLnZpZXcuZ2V0Rm9sZGVyKCdyZWNlbnQnKSxcbiAgICBdKVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyKHN0YXRlKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L29uZWRyaXZlXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJJbXBvcnQgZmlsZXMgZnJvbSBPbmVEcml2ZSwgaW50byBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIxLjIuMlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcIm9uZWRyaXZlXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgeyBQcm92aWRlclZpZXdzIH0gPSByZXF1aXJlKCdAdXBweS9wcm92aWRlci12aWV3cycpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgT25lRHJpdmUgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnT25lRHJpdmUnXG4gICAgUHJvdmlkZXIuaW5pdFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ09uZURyaXZlJ1xuICAgIHRoaXMuaWNvbiA9ICgpID0+IChcbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHJ4PVwiMTZcIiBmaWxsPVwiIzAyNjJDMFwiIC8+XG4gICAgICAgICAgPGcgZmlsbD1cIiNGRkZcIiBmaWxsUnVsZT1cIm5vbnplcm9cIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNMjQuMTU3IDIyczEuNDkyLS4yMDUgMS43OS0xLjY1NWEyLjYyNCAyLjYyNCAwIDAgMCAuMDMtLjg3OGMtLjIyLTEuNjQtMS45ODgtMi4wMS0xLjk4OC0yLjAxcy4zMDctMS43NjUtMS4zMTItMi42OWMtMS42Mi0uOTI1LTMuMSAwLTMuMSAwUzE4LjcxMSAxMyAxNi4zNjYgMTNjLTMuMDE2IDAtMy41MTkgMy40NDgtMy41MTkgMy40NDhTMTAgMTYuNjE4IDEwIDE5LjE0YzAgMi41MjMgMi41OTcgMi44NiAyLjU5NyAyLjg2aDExLjU2elwiIC8+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTkuNDIxIDE5LjI0NmMwLTIuMTk3IDEuNjA2LTMuMTU5IDIuODcxLTMuNDcyLjQ0LTEuNDc3IDEuNjU0LTMuNDM5IDQuMTM1LTMuNDM5SDE2LjQ0NWMxLjcyMSAwIDIuNzkuODIzIDMuMzY4IDEuNDc2YTMuOTkgMy45OSAwIDAgMSAxLjE0Ny0uMTcxaC4wMWwuMDMuMDAyQzIxLjAxNyAxMy41IDIwLjY5MSAxMCAxNi43NTcgMTBjLTIuNjkgMC0zLjYzOSAyLjM0NS0zLjYzOSAyLjM0NXMtMS45NS0xLjQ4Mi0zLjk1NS41NjdjLTEuMDI4IDEuMDUyLS43OSAyLjY2OS0uNzkgMi42NjlTNiAxNS44MjQgNiAxOC40MTJDNiAyMC43NTcgOC40NTIgMjEgOC40NTIgMjFoMS4zNzJhMy43NyAzLjc3IDAgMCAxLS40MDMtMS43NTR6XCIgLz5cbiAgICAgICAgICA8L2c+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMgfHwgdGhpcy5vcHRzLnNlcnZlckhlYWRlcnMsXG4gICAgICBjb21wYW5pb25Db29raWVzUnVsZTogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlLFxuICAgICAgcHJvdmlkZXI6ICdvbmVkcml2ZScsXG4gICAgICBwbHVnaW5JZDogdGhpcy5pZCxcbiAgICB9KVxuXG4gICAgdGhpcy5vbkZpcnN0UmVuZGVyID0gdGhpcy5vbkZpcnN0UmVuZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldyA9IG5ldyBQcm92aWRlclZpZXdzKHRoaXMsIHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgIH0pXG5cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLm9wdHMudGFyZ2V0XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcudGVhckRvd24oKVxuICAgIHRoaXMudW5tb3VudCgpXG4gIH1cblxuICBvbkZpcnN0UmVuZGVyICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5wcm92aWRlci5mZXRjaFByZUF1dGhUb2tlbigpLFxuICAgICAgdGhpcy52aWV3LmdldEZvbGRlcigpLFxuICAgIF0pXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5yZW5kZXIoc3RhdGUpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvcHJvdmlkZXItdmlld3NcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlZpZXcgbGlicmFyeSBmb3IgVXBweSByZW1vdGUgcHJvdmlkZXIgcGx1Z2lucy5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4xMi4zXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJzdHlsZVwiOiBcImRpc3Qvc3R5bGUubWluLmNzc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwiY2xhc3NuYW1lc1wiOiBcIl4yLjIuNlwiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuLy8gVE9ETyB1c2UgRnJhZ21lbnQgd2hlbiB1cGdyYWRpbmcgdG8gcHJlYWN0IFhcbmNvbnN0IEJyZWFkY3J1bWIgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3Bhbj5cbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldFwiXG4gICAgICAgIG9uQ2xpY2s9e3Byb3BzLmdldEZvbGRlcn1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLnRpdGxlfVxuICAgICAgPC9idXR0b24+XG4gICAgICB7IXByb3BzLmlzTGFzdCA/ICcgLyAnIDogJyd9XG4gICAgPC9zcGFuPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyLWJyZWFkY3J1bWJzXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItYnJlYWRjcnVtYnNJY29uXCI+e3Byb3BzLmJyZWFkY3J1bWJzSWNvbn08L2Rpdj5cbiAgICAgIHtcbiAgICAgICAgcHJvcHMuZGlyZWN0b3JpZXMubWFwKChkaXJlY3RvcnksIGkpID0+IChcbiAgICAgICAgICA8QnJlYWRjcnVtYlxuICAgICAgICAgICAga2V5PXtkaXJlY3RvcnkuaWR9XG4gICAgICAgICAgICBnZXRGb2xkZXI9eygpID0+IHByb3BzLmdldEZvbGRlcihkaXJlY3RvcnkuaWQpfVxuICAgICAgICAgICAgdGl0bGU9e2kgPT09IDAgPyBwcm9wcy50aXRsZSA6IGRpcmVjdG9yeS50aXRsZX1cbiAgICAgICAgICAgIGlzTGFzdD17aSArIDEgPT09IHByb3BzLmRpcmVjdG9yaWVzLmxlbmd0aH1cbiAgICAgICAgICAvPlxuICAgICAgICApKVxuICAgICAgfVxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBGaWx0ZXIgPSByZXF1aXJlKCcuL0ZpbHRlcicpXG5jb25zdCBJdGVtTGlzdCA9IHJlcXVpcmUoJy4vSXRlbUxpc3QnKVxuY29uc3QgRm9vdGVyQWN0aW9ucyA9IHJlcXVpcmUoJy4vRm9vdGVyQWN0aW9ucycpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNvbnN0IEJyb3dzZXIgPSAocHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIGN1cnJlbnRTZWxlY3Rpb24sXG4gICAgZm9sZGVycyxcbiAgICBmaWxlcyxcbiAgICB1cHB5RmlsZXMsXG4gICAgZmlsdGVySXRlbXMsXG4gICAgZmlsdGVySW5wdXQsXG4gIH0gPSBwcm9wc1xuXG4gIGxldCBmaWx0ZXJlZEZvbGRlcnMgPSBmb2xkZXJzXG4gIGxldCBmaWx0ZXJlZEZpbGVzID0gZmlsZXNcblxuICBpZiAoZmlsdGVySW5wdXQgIT09ICcnKSB7XG4gICAgZmlsdGVyZWRGb2xkZXJzID0gZmlsdGVySXRlbXMoZm9sZGVycylcbiAgICBmaWx0ZXJlZEZpbGVzID0gZmlsdGVySXRlbXMoZmlsZXMpXG4gIH1cblxuICBjb25zdCBzZWxlY3RlZCA9IGN1cnJlbnRTZWxlY3Rpb24ubGVuZ3RoXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lcygndXBweS1Qcm92aWRlckJyb3dzZXInLCBgdXBweS1Qcm92aWRlckJyb3dzZXItdmlld1R5cGUtLSR7cHJvcHMudmlld1R5cGV9YCl9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlci1oZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3VwcHktUHJvdmlkZXJCcm93c2VyLWhlYWRlckJhcicsICFwcm9wcy5zaG93QnJlYWRjcnVtYnMgJiYgJ3VwcHktUHJvdmlkZXJCcm93c2VyLWhlYWRlckJhci0tc2ltcGxlJyl9PlxuICAgICAgICAgIHtwcm9wcy5oZWFkZXJDb21wb25lbnR9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICB7cHJvcHMuc2hvd0ZpbHRlciAmJiA8RmlsdGVyIHsuLi5wcm9wc30gLz59XG4gICAgICA8SXRlbUxpc3RcbiAgICAgICAgY29sdW1ucz17W3tcbiAgICAgICAgICBuYW1lOiAnTmFtZScsXG4gICAgICAgICAga2V5OiAndGl0bGUnLFxuICAgICAgICB9XX1cbiAgICAgICAgZm9sZGVycz17ZmlsdGVyZWRGb2xkZXJzfVxuICAgICAgICBmaWxlcz17ZmlsdGVyZWRGaWxlc31cbiAgICAgICAgc29ydEJ5VGl0bGU9e3Byb3BzLnNvcnRCeVRpdGxlfVxuICAgICAgICBzb3J0QnlEYXRlPXtwcm9wcy5zb3J0QnlEYXRlfVxuICAgICAgICBpc0NoZWNrZWQ9e3Byb3BzLmlzQ2hlY2tlZH1cbiAgICAgICAgaGFuZGxlRm9sZGVyQ2xpY2s9e3Byb3BzLmdldE5leHRGb2xkZXJ9XG4gICAgICAgIHRvZ2dsZUNoZWNrYm94PXtwcm9wcy50b2dnbGVDaGVja2JveH1cbiAgICAgICAgaGFuZGxlU2Nyb2xsPXtwcm9wcy5oYW5kbGVTY3JvbGx9XG4gICAgICAgIHRpdGxlPXtwcm9wcy50aXRsZX1cbiAgICAgICAgc2hvd1RpdGxlcz17cHJvcHMuc2hvd1RpdGxlc31cbiAgICAgICAgaTE4bj17cHJvcHMuaTE4bn1cbiAgICAgICAgdmlld1R5cGU9e3Byb3BzLnZpZXdUeXBlfVxuICAgICAgICB2YWxpZGF0ZVJlc3RyaWN0aW9ucz17cHJvcHMudmFsaWRhdGVSZXN0cmljdGlvbnN9XG4gICAgICAgIHVwcHlGaWxlcz17dXBweUZpbGVzfVxuICAgICAgICBjdXJyZW50U2VsZWN0aW9uPXtjdXJyZW50U2VsZWN0aW9ufVxuICAgICAgLz5cbiAgICAgIHtzZWxlY3RlZCA+IDAgJiYgPEZvb3RlckFjdGlvbnMgc2VsZWN0ZWQ9e3NlbGVjdGVkfSB7Li4ucHJvcHN9IC8+fVxuICAgIDwvZGl2PlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnJvd3NlclxuIiwiY29uc3QgeyBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ2xvc2VXcmFwcGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIHRoaXMucHJvcHMub25Vbm1vdW50KClcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW5bMF1cbiAgfVxufVxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRmlsdGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5wcmV2ZW50RW50ZXJQcmVzcyA9IHRoaXMucHJldmVudEVudGVyUHJlc3MuYmluZCh0aGlzKVxuICB9XG5cbiAgcHJldmVudEVudGVyUHJlc3MgKGV2KSB7XG4gICAgaWYgKGV2LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgZXYucHJldmVudERlZmF1bHQoKVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXItc2VhcmNoXCI+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlci1zZWFyY2hJbnB1dFwiXG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPXt0aGlzLnByb3BzLmkxOG4oJ2ZpbHRlcicpfVxuICAgICAgICAgIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuaTE4bignZmlsdGVyJyl9XG4gICAgICAgICAgb25LZXlVcD17dGhpcy5wcmV2ZW50RW50ZXJQcmVzc31cbiAgICAgICAgICBvbktleURvd249e3RoaXMucHJldmVudEVudGVyUHJlc3N9XG4gICAgICAgICAgb25LZXlQcmVzcz17dGhpcy5wcmV2ZW50RW50ZXJQcmVzc31cbiAgICAgICAgICBvbklucHV0PXsoZSkgPT4gdGhpcy5wcm9wcy5maWx0ZXJRdWVyeShlKX1cbiAgICAgICAgICB2YWx1ZT17dGhpcy5wcm9wcy5maWx0ZXJJbnB1dH1cbiAgICAgICAgLz5cbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uIHVwcHktUHJvdmlkZXJCcm93c2VyLXNlYXJjaEljb25cIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiMTJcIiB2aWV3Qm94PVwiMCAwIDEyIDEyXCI+XG4gICAgICAgICAgPHBhdGggZD1cIk04LjYzOCA3Ljk5bDMuMTcyIDMuMTcyYS40OTIuNDkyIDAgMSAxLS42OTcuNjk3TDcuOTEgOC42NTZhNC45NzcgNC45NzcgMCAwIDEtMi45ODMuOTgzQzIuMjA2IDkuNjM5IDAgNy40ODEgMCA0LjgxOSAwIDIuMTU4IDIuMjA2IDAgNC45MjcgMGMyLjcyMSAwIDQuOTI3IDIuMTU4IDQuOTI3IDQuODJhNC43NCA0Ljc0IDAgMCAxLTEuMjE2IDMuMTd6bS0zLjcxLjY4NWMyLjE3NiAwIDMuOTQtMS43MjYgMy45NC0zLjg1NiAwLTIuMTI5LTEuNzY0LTMuODU1LTMuOTQtMy44NTVDMi43NS45NjQuOTg0IDIuNjkuOTg0IDQuODE5YzAgMi4xMyAxLjc2NSAzLjg1NiAzLjk0MiAzLjg1NnpcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAge3RoaXMucHJvcHMuZmlsdGVySW5wdXQgJiYgKFxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlci1zZWFyY2hDbG9zZVwiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuaTE4bigncmVzZXRGaWx0ZXInKX1cbiAgICAgICAgICAgIHRpdGxlPXt0aGlzLnByb3BzLmkxOG4oJ3Jlc2V0RmlsdGVyJyl9XG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLnByb3BzLmZpbHRlclF1ZXJ5fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHZpZXdCb3g9XCIwIDAgMTkgMTlcIj5cbiAgICAgICAgICAgICAgPHBhdGggZD1cIk0xNy4zMTggMTcuMjMyTDkuOTQgOS44NTQgOS41ODYgOS41bC0uMzU0LjM1NC03LjM3OCA3LjM3OGguNzA3bC0uNjItLjYydi43MDZMOS4zMTggOS45NGwuMzU0LS4zNTQtLjM1NC0uMzU0TDEuOTQgMS44NTR2LjcwN2wuNjItLjYyaC0uNzA2bDcuMzc4IDcuMzc4LjM1NC4zNTQuMzU0LS4zNTQgNy4zNzgtNy4zNzhoLS43MDdsLjYyMi42MnYtLjcwNkw5Ljg1NCA5LjIzMmwtLjM1NC4zNTQuMzU0LjM1NCA3LjM3OCA3LjM3OC43MDgtLjcwNy03LjM4LTcuMzc4di43MDhsNy4zOC03LjM4LjM1My0uMzUzLS4zNTMtLjM1My0uNjIyLS42MjItLjM1My0uMzUzLS4zNTQuMzUyLTcuMzc4IDcuMzhoLjcwOEwyLjU2IDEuMjMgMi4yMDguODhsLS4zNTMuMzUzLS42MjIuNjItLjM1My4zNTUuMzUyLjM1MyA3LjM4IDcuMzh2LS43MDhsLTcuMzggNy4zOC0uMzUzLjM1My4zNTIuMzUzLjYyMi42MjIuMzUzLjM1My4zNTQtLjM1MyA3LjM4LTcuMzhoLS43MDhsNy4zOCA3LjM4elwiIC8+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXItZm9vdGVyXCI+XG4gICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tcHJpbWFyeVwiIG9uQ2xpY2s9e3Byb3BzLmRvbmV9PlxuICAgICAgICB7cHJvcHMuaTE4bignc2VsZWN0WCcsIHtcbiAgICAgICAgICBzbWFydF9jb3VudDogcHJvcHMuc2VsZWN0ZWQsXG4gICAgICAgIH0pfVxuICAgICAgPC9idXR0b24+XG4gICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tbGlua1wiIG9uQ2xpY2s9e3Byb3BzLmNhbmNlbH0+XG4gICAgICAgIHtwcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbi8vIGl0IGNvdWxkIGJlIGEgPGxpPjxidXR0b24gY2xhc3M9XCJmYWtlLWNoZWNrYm94XCIvPiA8YnV0dG9uLz48L2xpPlxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8bGkgY2xhc3NOYW1lPXtwcm9wcy5jbGFzc05hbWV9IHRpdGxlPXtwcm9wcy5pc0Rpc2FibGVkID8gcHJvcHMucmVzdHJpY3Rpb25SZWFzb24gOiBudWxsfT5cbiAgICAgIDxkaXYgYXJpYS1oaWRkZW4gY2xhc3NOYW1lPXtgdXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWZha2VDaGVja2JveCAke3Byb3BzLmlzQ2hlY2tlZCA/ICd1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tZmFrZUNoZWNrYm94LS1pcy1jaGVja2VkJyA6ICcnfWB9IC8+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWlubmVyXCJcbiAgICAgICAgb25DbGljaz17cHJvcHMudG9nZ2xlQ2hlY2tib3h9XG4gICAgICAgIHJvbGU9XCJvcHRpb25cIlxuICAgICAgICBhcmlhLWxhYmVsPXtwcm9wcy5pc0NoZWNrZWQgPyBwcm9wcy5pMThuKCd1bnNlbGVjdEZpbGVOYW1lZCcsIHsgbmFtZTogcHJvcHMudGl0bGUgfSkgOiBwcm9wcy5pMThuKCdzZWxlY3RGaWxlTmFtZWQnLCB7IG5hbWU6IHByb3BzLnRpdGxlIH0pfVxuICAgICAgICBhcmlhLXNlbGVjdGVkPXtwcm9wcy5pc0NoZWNrZWR9XG4gICAgICAgIGFyaWEtZGlzYWJsZWQ9e3Byb3BzLmlzRGlzYWJsZWR9XG4gICAgICAgIGRpc2FibGVkPXtwcm9wcy5pc0Rpc2FibGVkfVxuICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICA+XG4gICAgICAgIHtwcm9wcy5pdGVtSWNvbkVsfVxuICAgICAgICB7cHJvcHMuc2hvd1RpdGxlcyAmJiBwcm9wcy50aXRsZX1cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvbGk+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuZnVuY3Rpb24gRmlsZUljb24gKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPXsxMX0gaGVpZ2h0PXsxNC41fSB2aWV3Qm94PVwiMCAwIDQ0IDU4XCI+XG4gICAgICA8cGF0aCBkPVwiTTI3LjQzNy41MTdhMSAxIDAgMCAwLS4wOTQuMDNINC4yNUMyLjAzNy41NDguMjE3IDIuMzY4LjIxNyA0LjU4djQ4LjQwNWMwIDIuMjEyIDEuODIgNC4wMyA0LjAzIDQuMDNIMzkuMDNjMi4yMSAwIDQuMDMtMS44MTggNC4wMy00LjAzVjE1LjYxYTEgMSAwIDAgMC0uMDMtLjI4IDEgMSAwIDAgMCAwLS4wOTMgMSAxIDAgMCAwLS4wMy0uMDMyIDEgMSAwIDAgMCAwLS4wMyAxIDEgMCAwIDAtLjAzMi0uMDYzIDEgMSAwIDAgMC0uMDMtLjA2MyAxIDEgMCAwIDAtLjAzMiAwIDEgMSAwIDAgMC0uMDMtLjA2MyAxIDEgMCAwIDAtLjAzMi0uMDMgMSAxIDAgMCAwLS4wMy0uMDYzIDEgMSAwIDAgMC0uMDYzLS4wNjJsLTE0LjU5My0xNGExIDEgMCAwIDAtLjA2Mi0uMDYyQTEgMSAwIDAgMCAyOCAuNzA4YTEgMSAwIDAgMC0uMzc0LS4xNTcgMSAxIDAgMCAwLS4xNTYgMCAxIDEgMCAwIDAtLjAzLS4wM2wtLjAwMy0uMDAzek00LjI1IDIuNTQ3aDIyLjIxOHY5Ljk3YzAgMi4yMSAxLjgyIDQuMDMgNC4wMyA0LjAzaDEwLjU2NHYzNi40MzhhMi4wMiAyLjAyIDAgMCAxLTIuMDMyIDIuMDMySDQuMjVjLTEuMTMgMC0yLjAzMi0uOS0yLjAzMi0yLjAzMlY0LjU4YzAtMS4xMy45MDItMi4wMzIgMi4wMy0yLjAzMnptMjQuMjE4IDEuMzQ1bDEwLjM3NSA5LjkzNy43NS43MThIMzAuNWMtMS4xMyAwLTIuMDMyLS45LTIuMDMyLTIuMDNWMy44OXpcIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIEZvbGRlckljb24gKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHN0eWxlPXt7IG1pbldpZHRoOiAxNiwgbWFyZ2luUmlnaHQ6IDMgfX0gdmlld0JveD1cIjAgMCAyNzYuMTU3IDI3Ni4xNTdcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMjczLjA4IDEwMS4zNzhjLTMuMy00LjY1LTguODYtNy4zMi0xNS4yNTQtNy4zMmgtMjQuMzRWNjcuNTljMC0xMC4yLTguMy0xOC41LTE4LjUtMTguNWgtODUuMzIyYy0zLjYzIDAtOS4yOTUtMi44NzUtMTEuNDM2LTUuODA1bC02LjM4Ni04LjczNWMtNC45ODItNi44MTQtMTUuMTA0LTExLjk1NC0yMy41NDYtMTEuOTU0SDU4LjczYy05LjI5MiAwLTE4LjYzOCA2LjYwOC0yMS43MzcgMTUuMzcybC0yLjAzMyA1Ljc1MmMtLjk1OCAyLjcxLTQuNzIgNS4zNy03LjU5NiA1LjM3SDE4LjVDOC4zIDQ5LjA5IDAgNTcuMzkgMCA2Ny41OXYxNjcuMDdjMCAuODg2LjE2IDEuNzMuNDQzIDIuNTIuMTUyIDMuMzA2IDEuMTggNi40MjQgMy4wNTMgOS4wNjQgMy4zIDQuNjUyIDguODYgNy4zMiAxNS4yNTUgNy4zMmgxODguNDg3YzExLjM5NSAwIDIzLjI3LTguNDI1IDI3LjAzNS0xOS4xOGw0MC42NzctMTE2LjE4OGMyLjExLTYuMDM1IDEuNDMtMTIuMTY0LTEuODctMTYuODE2ek0xOC41IDY0LjA4OGg4Ljg2NGM5LjI5NSAwIDE4LjY0LTYuNjA3IDIxLjczOC0xNS4zN2wyLjAzMi01Ljc1Yy45Ni0yLjcxMiA0LjcyMi01LjM3MyA3LjU5Ny01LjM3M2gyOS41NjVjMy42MyAwIDkuMjk1IDIuODc2IDExLjQzNyA1LjgwNmw2LjM4NiA4LjczNWM0Ljk4MiA2LjgxNSAxNS4xMDQgMTEuOTU0IDIzLjU0NiAxMS45NTRoODUuMzIyYzEuODk4IDAgMy41IDEuNjAyIDMuNSAzLjV2MjYuNDdINjkuMzRjLTExLjM5NSAwLTIzLjI3IDguNDIzLTI3LjAzNSAxOS4xNzhMMTUgMTkxLjIzVjY3LjU5YzAtMS44OTggMS42MDMtMy41IDMuNS0zLjV6bTI0Mi4yOSA0OS4xNWwtNDAuNjc2IDExNi4xODhjLTEuNjc0IDQuNzgtNy44MTIgOS4xMzUtMTIuODc3IDkuMTM1SDE4Ljc1Yy0xLjQ0NyAwLTIuNTc2LS4zNzItMy4wMi0uOTk3LS40NDItLjYyNS0uNDIyLTEuODE0LjA1Ny0zLjE4bDQwLjY3Ny0xMTYuMTljMS42NzQtNC43OCA3LjgxMi05LjEzNCAxMi44NzctOS4xMzRoMTg4LjQ4N2MxLjQ0OCAwIDIuNTc3LjM3MiAzLjAyLjk5Ny40NDMuNjI1LjQyMyAxLjgxNC0uMDU2IDMuMTh6XCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBWaWRlb0ljb24gKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBzdHlsZT17eyB3aWR0aDogMTYsIG1hcmdpblJpZ2h0OiA0IH19IHZpZXdCb3g9XCIwIDAgNTggNThcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMzYuNTM3IDI4LjE1NmwtMTEtN2ExLjAwNSAxLjAwNSAwIDAgMC0xLjAyLS4wMzNDMjQuMiAyMS4zIDI0IDIxLjYzNSAyNCAyMnYxNGExIDEgMCAwIDAgMS41MzcuODQ0bDExLTdhMS4wMDIgMS4wMDIgMCAwIDAgMC0xLjY4OHpNMjYgMzQuMThWMjMuODJMMzQuMTM3IDI5IDI2IDM0LjE4elwiIC8+XG4gICAgICA8cGF0aCBkPVwiTTU3IDZIMWExIDEgMCAwIDAtMSAxdjQ0YTEgMSAwIDAgMCAxIDFoNTZhMSAxIDAgMCAwIDEtMVY3YTEgMSAwIDAgMC0xLTF6TTEwIDI4SDJ2LTloOHY5em0tOCAyaDh2OUgydi05em0xMCAxMFY4aDM0djQySDEyVjQwem00NC0xMmgtOHYtOWg4djl6bS04IDJoOHY5aC04di05em04LTIydjloLThWOGg4ek0yIDhoOHY5SDJWOHptMCA0MnYtOWg4djlIMnptNTQgMGgtOHYtOWg4djl6XCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBpZiAocHJvcHMuaXRlbUljb25TdHJpbmcgPT09IG51bGwpIHJldHVyblxuXG4gIHN3aXRjaCAocHJvcHMuaXRlbUljb25TdHJpbmcpIHtcbiAgICBjYXNlICdmaWxlJzpcbiAgICAgIHJldHVybiA8RmlsZUljb24gLz5cbiAgICBjYXNlICdmb2xkZXInOlxuICAgICAgcmV0dXJuIDxGb2xkZXJJY29uIC8+XG4gICAgY2FzZSAndmlkZW8nOlxuICAgICAgcmV0dXJuIDxWaWRlb0ljb24gLz5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDxpbWcgc3JjPXtwcm9wcy5pdGVtSWNvblN0cmluZ30gLz5cbiAgfVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5jb25zdCBnZXRBcmlhTGFiZWxPZkNoZWNrYm94ID0gKHByb3BzKSA9PiB7XG4gIGlmIChwcm9wcy50eXBlID09PSAnZm9sZGVyJykge1xuICAgIGlmIChwcm9wcy5pc0NoZWNrZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcy5pMThuKCd1bnNlbGVjdEFsbEZpbGVzRnJvbUZvbGRlck5hbWVkJywgeyBuYW1lOiBwcm9wcy50aXRsZSB9KVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHMuaTE4bignc2VsZWN0QWxsRmlsZXNGcm9tRm9sZGVyTmFtZWQnLCB7IG5hbWU6IHByb3BzLnRpdGxlIH0pXG4gIH1cbiAgaWYgKHByb3BzLmlzQ2hlY2tlZCkge1xuICAgIHJldHVybiBwcm9wcy5pMThuKCd1bnNlbGVjdEZpbGVOYW1lZCcsIHsgbmFtZTogcHJvcHMudGl0bGUgfSlcbiAgfVxuICByZXR1cm4gcHJvcHMuaTE4bignc2VsZWN0RmlsZU5hbWVkJywgeyBuYW1lOiBwcm9wcy50aXRsZSB9KVxufVxuXG4vLyBpZiBmb2xkZXI6XG4vLyAgICsgY2hlY2tib3ggKHNlbGVjdHMgYWxsIGZpbGVzIGZyb20gZm9sZGVyKVxuLy8gICArIGZvbGRlciBuYW1lIChvcGVucyBmb2xkZXIpXG4vLyBpZiBmaWxlOlxuLy8gICArIGNoZWNrYm94IChzZWxlY3RzIGZpbGUpXG4vLyAgICsgZmlsZSBuYW1lIChzZWxlY3RzIGZpbGUpXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxsaSBjbGFzc05hbWU9e3Byb3BzLmNsYXNzTmFtZX0gdGl0bGU9e3Byb3BzLmlzRGlzYWJsZWQgPyBwcm9wcy5yZXN0cmljdGlvblJlYXNvbiA6IG51bGx9PlxuICAgICAgeyFwcm9wcy5pc0NoZWNrYm94RGlzYWJsZWQgPyAoXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzc05hbWU9e2B1cHB5LXUtcmVzZXQgdXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWZha2VDaGVja2JveCAke3Byb3BzLmlzQ2hlY2tlZCA/ICd1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tZmFrZUNoZWNrYm94LS1pcy1jaGVja2VkJyA6ICcnfWB9XG4gICAgICAgICAgb25DbGljaz17cHJvcHMudG9nZ2xlQ2hlY2tib3h9XG4gICAgICAgICAgLy8gZm9yIHRoZSA8bGFiZWwvPlxuICAgICAgICAgIGlkPXtwcm9wcy5pZH1cbiAgICAgICAgICByb2xlPVwib3B0aW9uXCJcbiAgICAgICAgICBhcmlhLWxhYmVsPXtnZXRBcmlhTGFiZWxPZkNoZWNrYm94KHByb3BzKX1cbiAgICAgICAgICBhcmlhLXNlbGVjdGVkPXtwcm9wcy5pc0NoZWNrZWR9XG4gICAgICAgICAgYXJpYS1kaXNhYmxlZD17cHJvcHMuaXNEaXNhYmxlZH1cbiAgICAgICAgICBkaXNhYmxlZD17cHJvcHMuaXNEaXNhYmxlZH1cbiAgICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICAgIC8+XG4gICAgICApIDogbnVsbH1cblxuICAgICAge3Byb3BzLnR5cGUgPT09ICdmaWxlJyA/IChcbiAgICAgICAgLy8gbGFiZWwgZm9yIGEgY2hlY2tib3hcbiAgICAgICAgPGxhYmVsIGh0bWxGb3I9e3Byb3BzLmlkfSBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWlubmVyXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0taWNvbldyYXBcIj5cbiAgICAgICAgICAgIHtwcm9wcy5pdGVtSWNvbkVsfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHtwcm9wcy5zaG93VGl0bGVzICYmIHByb3BzLnRpdGxlfVxuICAgICAgICA8L2xhYmVsPlxuICAgICAgKSA6IChcbiAgICAgICAgLy8gYnV0dG9uIHRvIG9wZW4gYSBmb2xkZXJcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0taW5uZXJcIlxuICAgICAgICAgIG9uQ2xpY2s9e3Byb3BzLmhhbmRsZUZvbGRlckNsaWNrfVxuICAgICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ29wZW5Gb2xkZXJOYW1lZCcsIHsgbmFtZTogcHJvcHMudGl0bGUgfSl9XG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXJCcm93c2VySXRlbS1pY29uV3JhcFwiPlxuICAgICAgICAgICAge3Byb3BzLml0ZW1JY29uRWx9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge3Byb3BzLnNob3dUaXRsZXMgJiYgPHNwYW4+e3Byb3BzLnRpdGxlfTwvc3Bhbj59XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgKX1cbiAgICA8L2xpPlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBJdGVtSWNvbiA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9JdGVtSWNvbicpXG5jb25zdCBHcmlkTGkgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvR3JpZExpJylcbmNvbnN0IExpc3RMaSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9MaXN0TGknKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBjb25zdCBpdGVtSWNvblN0cmluZyA9IHByb3BzLmdldEl0ZW1JY29uKClcblxuICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc05hbWVzKFxuICAgICd1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0nLFxuICAgIHsgJ3VwcHktUHJvdmlkZXJCcm93c2VySXRlbS0tc2VsZWN0ZWQnOiBwcm9wcy5pc0NoZWNrZWQgfSxcbiAgICB7ICd1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tLWRpc2FibGVkJzogcHJvcHMuaXNEaXNhYmxlZCB9LFxuICAgIHsgJ3VwcHktUHJvdmlkZXJCcm93c2VySXRlbS0tbm9QcmV2aWV3JzogaXRlbUljb25TdHJpbmcgPT09ICd2aWRlbycgfVxuICApXG5cbiAgY29uc3QgaXRlbUljb25FbCA9IDxJdGVtSWNvbiBpdGVtSWNvblN0cmluZz17aXRlbUljb25TdHJpbmd9IC8+XG5cbiAgc3dpdGNoIChwcm9wcy52aWV3VHlwZSkge1xuICAgIGNhc2UgJ2dyaWQnOlxuICAgICAgcmV0dXJuIDxHcmlkTGkgey4uLnByb3BzfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gaXRlbUljb25FbD17aXRlbUljb25FbH0gLz5cbiAgICBjYXNlICdsaXN0JzpcbiAgICAgIHJldHVybiA8TGlzdExpIHsuLi5wcm9wc30gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGl0ZW1JY29uRWw9e2l0ZW1JY29uRWx9IC8+XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gc3VjaCB0eXBlICR7cHJvcHMudmlld1R5cGV9YClcbiAgfVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgcmVtb3RlRmlsZU9ialRvTG9jYWwgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvcmVtb3RlRmlsZU9ialRvTG9jYWwnKVxuY29uc3QgSXRlbSA9IHJlcXVpcmUoJy4vSXRlbS9pbmRleCcpXG5cbi8vIEhvcGVmdWxseSB0aGlzIG5hbWUgd2lsbCBub3QgYmUgdXNlZCBieSBHb29nbGVcbmNvbnN0IFZJUlRVQUxfU0hBUkVEX0RJUiA9ICdzaGFyZWQtd2l0aC1tZSdcblxuY29uc3QgZ2V0U2hhcmVkUHJvcHMgPSAoZmlsZU9yRm9sZGVyLCBwcm9wcykgPT4gKHtcbiAgaWQ6IGZpbGVPckZvbGRlci5pZCxcbiAgdGl0bGU6IGZpbGVPckZvbGRlci5uYW1lLFxuICBnZXRJdGVtSWNvbjogKCkgPT4gZmlsZU9yRm9sZGVyLmljb24sXG4gIGlzQ2hlY2tlZDogcHJvcHMuaXNDaGVja2VkKGZpbGVPckZvbGRlciksXG4gIHRvZ2dsZUNoZWNrYm94OiAoZSkgPT4gcHJvcHMudG9nZ2xlQ2hlY2tib3goZSwgZmlsZU9yRm9sZGVyKSxcbiAgY29sdW1uczogcHJvcHMuY29sdW1ucyxcbiAgc2hvd1RpdGxlczogcHJvcHMuc2hvd1RpdGxlcyxcbiAgdmlld1R5cGU6IHByb3BzLnZpZXdUeXBlLFxuICBpMThuOiBwcm9wcy5pMThuLFxufSlcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBmb2xkZXJzLCBmaWxlcywgaGFuZGxlU2Nyb2xsLCBpc0NoZWNrZWQgfSA9IHByb3BzXG5cbiAgaWYgKCFmb2xkZXJzLmxlbmd0aCAmJiAhZmlsZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlci1lbXB0eVwiPntwcm9wcy5pMThuKCdub0ZpbGVzRm91bmQnKX08L2Rpdj5cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlci1ib2R5XCI+XG4gICAgICA8dWxcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXItbGlzdFwiXG4gICAgICAgIG9uU2Nyb2xsPXtoYW5kbGVTY3JvbGx9XG4gICAgICAgIHJvbGU9XCJsaXN0Ym94XCJcbiAgICAgICAgLy8gbWFraW5nIDx1bD4gbm90IGZvY3VzYWJsZSBmb3IgZmlyZWZveFxuICAgICAgICB0YWJJbmRleD1cIi0xXCJcbiAgICAgID5cbiAgICAgICAge2ZvbGRlcnMubWFwKGZvbGRlciA9PiB7XG4gICAgICAgICAgcmV0dXJuIEl0ZW0oe1xuICAgICAgICAgICAgLi4uZ2V0U2hhcmVkUHJvcHMoZm9sZGVyLCBwcm9wcyksXG4gICAgICAgICAgICB0eXBlOiAnZm9sZGVyJyxcbiAgICAgICAgICAgIGlzRGlzYWJsZWQ6IGlzQ2hlY2tlZChmb2xkZXIpID8gaXNDaGVja2VkKGZvbGRlcikubG9hZGluZyA6IGZhbHNlLFxuICAgICAgICAgICAgaXNDaGVja2JveERpc2FibGVkOiBmb2xkZXIuaWQgPT09IFZJUlRVQUxfU0hBUkVEX0RJUixcbiAgICAgICAgICAgIGhhbmRsZUZvbGRlckNsaWNrOiAoKSA9PiBwcm9wcy5oYW5kbGVGb2xkZXJDbGljayhmb2xkZXIpLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pfVxuICAgICAgICB7ZmlsZXMubWFwKGZpbGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRlUmVzdHJpY3Rpb25zID0gcHJvcHMudmFsaWRhdGVSZXN0cmljdGlvbnMoXG4gICAgICAgICAgICByZW1vdGVGaWxlT2JqVG9Mb2NhbChmaWxlKSxcbiAgICAgICAgICAgIFsuLi5wcm9wcy51cHB5RmlsZXMsIC4uLnByb3BzLmN1cnJlbnRTZWxlY3Rpb25dXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IHNoYXJlZFByb3BzID0gZ2V0U2hhcmVkUHJvcHMoZmlsZSwgcHJvcHMpXG4gICAgICAgICAgY29uc3QgcmVzdHJpY3Rpb25SZWFzb24gPSB2YWxpZGF0ZVJlc3RyaWN0aW9ucy5yZWFzb25cblxuICAgICAgICAgIHJldHVybiBJdGVtKHtcbiAgICAgICAgICAgIC4uLnNoYXJlZFByb3BzLFxuICAgICAgICAgICAgdHlwZTogJ2ZpbGUnLFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogIXZhbGlkYXRlUmVzdHJpY3Rpb25zLnJlc3VsdCAmJiAhc2hhcmVkUHJvcHMuaXNDaGVja2VkLFxuICAgICAgICAgICAgcmVzdHJpY3Rpb25SZWFzb24sXG4gICAgICAgICAgfSlcbiAgICAgICAgfSl9XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyLWxvYWRpbmdcIj5cbiAgICAgIDxzcGFuPntwcm9wcy5pMThuKCdsb2FkaW5nJyl9PC9zcGFuPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuY2xhc3MgQXV0aFZpZXcgZXh0ZW5kcyBDb21wb25lbnQge1xuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHBsdWdpbk5hbWVDb21wb25lbnQgPSAoXG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVyLWF1dGhUaXRsZU5hbWVcIj5cbiAgICAgICAge3RoaXMucHJvcHMucGx1Z2luTmFtZX1cbiAgICAgICAgPGJyIC8+XG4gICAgICA8L3NwYW4+XG4gICAgKVxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItYXV0aFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktUHJvdmlkZXItYXV0aEljb25cIj57dGhpcy5wcm9wcy5wbHVnaW5JY29uKCl9PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlci1hdXRoVGl0bGVcIj5cbiAgICAgICAgICB7dGhpcy5wcm9wcy5pMThuQXJyYXkoJ2F1dGhlbnRpY2F0ZVdpdGhUaXRsZScsIHsgcGx1Z2luTmFtZTogcGx1Z2luTmFtZUNvbXBvbmVudCB9KX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LWMtYnRuLXByaW1hcnkgdXBweS1Qcm92aWRlci1hdXRoQnRuXCJcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLnByb3BzLmhhbmRsZUF1dGh9XG4gICAgICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgICAgICA+XG4gICAgICAgICAge3RoaXMucHJvcHMuaTE4bkFycmF5KCdhdXRoZW50aWNhdGVXaXRoJywgeyBwbHVnaW5OYW1lOiB0aGlzLnByb3BzLnBsdWdpbk5hbWUgfSl9XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0aFZpZXdcbiIsImNvbnN0IFVzZXIgPSByZXF1aXJlKCcuL1VzZXInKVxuY29uc3QgQnJlYWRjcnVtYnMgPSByZXF1aXJlKCcuLi9CcmVhZGNydW1icycpXG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXVxuICBpZiAocHJvcHMuc2hvd0JyZWFkY3J1bWJzKSB7XG4gICAgY29tcG9uZW50cy5wdXNoKEJyZWFkY3J1bWJzKHtcbiAgICAgIGdldEZvbGRlcjogcHJvcHMuZ2V0Rm9sZGVyLFxuICAgICAgZGlyZWN0b3JpZXM6IHByb3BzLmRpcmVjdG9yaWVzLFxuICAgICAgYnJlYWRjcnVtYnNJY29uOiBwcm9wcy5wbHVnaW5JY29uICYmIHByb3BzLnBsdWdpbkljb24oKSxcbiAgICAgIHRpdGxlOiBwcm9wcy50aXRsZSxcbiAgICB9KSlcbiAgfVxuXG4gIGNvbXBvbmVudHMucHVzaChVc2VyKHtcbiAgICBsb2dvdXQ6IHByb3BzLmxvZ291dCxcbiAgICB1c2VybmFtZTogcHJvcHMudXNlcm5hbWUsXG4gICAgaTE4bjogcHJvcHMuaTE4bixcbiAgfSkpXG5cbiAgcmV0dXJuIGNvbXBvbmVudHNcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IEF1dGhWaWV3ID0gcmVxdWlyZSgnLi9BdXRoVmlldycpXG5jb25zdCBIZWFkZXIgPSByZXF1aXJlKCcuL0hlYWRlcicpXG5jb25zdCBCcm93c2VyID0gcmVxdWlyZSgnLi4vQnJvd3NlcicpXG5jb25zdCBMb2FkZXJWaWV3ID0gcmVxdWlyZSgnLi4vTG9hZGVyJylcbmNvbnN0IGdlbmVyYXRlRmlsZUlEID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dlbmVyYXRlRmlsZUlEJylcbmNvbnN0IGdldEZpbGVUeXBlID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldEZpbGVUeXBlJylcbmNvbnN0IGZpbmRJbmRleCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9maW5kSW5kZXgnKVxuY29uc3QgaXNQcmV2aWV3U3VwcG9ydGVkID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2lzUHJldmlld1N1cHBvcnRlZCcpXG5jb25zdCBTaGFyZWRIYW5kbGVyID0gcmVxdWlyZSgnLi4vU2hhcmVkSGFuZGxlcicpXG5jb25zdCBDbG9zZVdyYXBwZXIgPSByZXF1aXJlKCcuLi9DbG9zZVdyYXBwZXInKVxuXG4vLyBsb2NhdGlvbi5vcmlnaW4gZG9lcyBub3QgZXhpc3QgaW4gSUVcbmZ1bmN0aW9uIGdldE9yaWdpbiAoKSB7XG4gIGlmICgnb3JpZ2luJyBpbiBsb2NhdGlvbikge1xuICAgIHJldHVybiBsb2NhdGlvbi5vcmlnaW4gLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb21wYXQvY29tcGF0XG4gIH1cbiAgcmV0dXJuIGAke2xvY2F0aW9uLnByb3RvY29sfS8vJHtsb2NhdGlvbi5ob3N0bmFtZX0ke2xvY2F0aW9uLnBvcnQgPyBgOiR7bG9jYXRpb24ucG9ydH1gIDogJyd9YFxufVxuXG4vKipcbiAqIENsYXNzIHRvIGVhc2lseSBnZW5lcmF0ZSBnZW5lcmljIHZpZXdzIGZvciBQcm92aWRlciBwbHVnaW5zXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUHJvdmlkZXJWaWV3IHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwbHVnaW4gaW5zdGFuY2Ugb2YgdGhlIHBsdWdpblxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHBsdWdpbiwgb3B0cykge1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luXG4gICAgdGhpcy5wcm92aWRlciA9IG9wdHMucHJvdmlkZXJcbiAgICB0aGlzLl9zaGFyZWRIYW5kbGVyID0gbmV3IFNoYXJlZEhhbmRsZXIocGx1Z2luKVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdmlld1R5cGU6ICdsaXN0JyxcbiAgICAgIHNob3dUaXRsZXM6IHRydWUsXG4gICAgICBzaG93RmlsdGVyOiB0cnVlLFxuICAgICAgc2hvd0JyZWFkY3J1bWJzOiB0cnVlLFxuICAgIH1cblxuICAgIC8vIG1lcmdlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBvbmVzIHNldCBieSB1c2VyXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICAvLyBMb2dpY1xuICAgIHRoaXMuYWRkRmlsZSA9IHRoaXMuYWRkRmlsZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5maWx0ZXJRdWVyeSA9IHRoaXMuZmlsdGVyUXVlcnkuYmluZCh0aGlzKVxuICAgIHRoaXMuZ2V0Rm9sZGVyID0gdGhpcy5nZXRGb2xkZXIuYmluZCh0aGlzKVxuICAgIHRoaXMuZ2V0TmV4dEZvbGRlciA9IHRoaXMuZ2V0TmV4dEZvbGRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5sb2dvdXQgPSB0aGlzLmxvZ291dC5iaW5kKHRoaXMpXG4gICAgdGhpcy5wcmVGaXJzdFJlbmRlciA9IHRoaXMucHJlRmlyc3RSZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlQXV0aCA9IHRoaXMuaGFuZGxlQXV0aC5iaW5kKHRoaXMpXG4gICAgdGhpcy5zb3J0QnlUaXRsZSA9IHRoaXMuc29ydEJ5VGl0bGUuYmluZCh0aGlzKVxuICAgIHRoaXMuc29ydEJ5RGF0ZSA9IHRoaXMuc29ydEJ5RGF0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVFcnJvciA9IHRoaXMuaGFuZGxlRXJyb3IuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gdGhpcy5oYW5kbGVTY3JvbGwuYmluZCh0aGlzKVxuICAgIHRoaXMubGlzdEFsbEZpbGVzID0gdGhpcy5saXN0QWxsRmlsZXMuYmluZCh0aGlzKVxuICAgIHRoaXMuZG9uZVBpY2tpbmcgPSB0aGlzLmRvbmVQaWNraW5nLmJpbmQodGhpcylcbiAgICB0aGlzLmNhbmNlbFBpY2tpbmcgPSB0aGlzLmNhbmNlbFBpY2tpbmcuYmluZCh0aGlzKVxuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24gPSB0aGlzLmNsZWFyU2VsZWN0aW9uLmJpbmQodGhpcylcblxuICAgIC8vIFZpc3VhbFxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbigpXG5cbiAgICAvLyBTZXQgZGVmYXVsdCBzdGF0ZSBmb3IgdGhlIHBsdWdpblxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGF1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgZmlsZXM6IFtdLFxuICAgICAgZm9sZGVyczogW10sXG4gICAgICBkaXJlY3RvcmllczogW10sXG4gICAgICBmaWx0ZXJJbnB1dDogJycsXG4gICAgICBpc1NlYXJjaFZpc2libGU6IGZhbHNlLFxuICAgIH0pXG4gIH1cblxuICB0ZWFyRG93biAoKSB7XG4gICAgLy8gTm90aGluZy5cbiAgfVxuXG4gIF91cGRhdGVGaWxlc0FuZEZvbGRlcnMgKHJlcywgZmlsZXMsIGZvbGRlcnMpIHtcbiAgICB0aGlzLm5leHRQYWdlUGF0aCA9IHJlcy5uZXh0UGFnZVBhdGhcbiAgICByZXMuaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uaXNGb2xkZXIpIHtcbiAgICAgICAgZm9sZGVycy5wdXNoKGl0ZW0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWxlcy5wdXNoKGl0ZW0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgZm9sZGVycywgZmlsZXMgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgb25seSB0aGUgZmlyc3QgdGltZSB0aGUgcHJvdmlkZXIgdmlldyBpcyByZW5kZXJlZC5cbiAgICogS2luZCBvZiBsaWtlIGFuIGluaXQgZnVuY3Rpb24uXG4gICAqL1xuICBwcmVGaXJzdFJlbmRlciAoKSB7XG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBkaWRGaXJzdFJlbmRlcjogdHJ1ZSB9KVxuICAgIHRoaXMucGx1Z2luLm9uRmlyc3RSZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEJhc2VkIG9uIGZvbGRlciBJRCwgZmV0Y2ggYSBuZXcgZm9sZGVyIGFuZCB1cGRhdGUgaXQgdG8gc3RhdGVcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCBGb2xkZXIgaWRcbiAgICogQHJldHVybnMge1Byb21pc2V9ICAgRm9sZGVycy9maWxlcyBpbiBmb2xkZXJcbiAgICovXG4gIGdldEZvbGRlciAoaWQsIG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkSGFuZGxlci5sb2FkZXJXcmFwcGVyKFxuICAgICAgdGhpcy5wcm92aWRlci5saXN0KGlkKSxcbiAgICAgIChyZXMpID0+IHtcbiAgICAgICAgY29uc3QgZm9sZGVycyA9IFtdXG4gICAgICAgIGNvbnN0IGZpbGVzID0gW11cbiAgICAgICAgbGV0IHVwZGF0ZWREaXJlY3Rvcmllc1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgICBjb25zdCBpbmRleCA9IGZpbmRJbmRleChzdGF0ZS5kaXJlY3RvcmllcywgKGRpcikgPT4gaWQgPT09IGRpci5pZClcblxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgdXBkYXRlZERpcmVjdG9yaWVzID0gc3RhdGUuZGlyZWN0b3JpZXMuc2xpY2UoMCwgaW5kZXggKyAxKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwZGF0ZWREaXJlY3RvcmllcyA9IHN0YXRlLmRpcmVjdG9yaWVzLmNvbmNhdChbeyBpZCwgdGl0bGU6IG5hbWUgfV0pXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVzZXJuYW1lID0gcmVzLnVzZXJuYW1lIHx8IHRoaXMudXNlcm5hbWVcbiAgICAgICAgdGhpcy5fdXBkYXRlRmlsZXNBbmRGb2xkZXJzKHJlcywgZmlsZXMsIGZvbGRlcnMpXG4gICAgICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgZGlyZWN0b3JpZXM6IHVwZGF0ZWREaXJlY3RvcmllcyB9KVxuICAgICAgfSxcbiAgICAgIHRoaXMuaGFuZGxlRXJyb3JcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBuZXcgZm9sZGVyXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gZm9sZGVyXG4gICAqL1xuICBnZXROZXh0Rm9sZGVyIChmb2xkZXIpIHtcbiAgICB0aGlzLmdldEZvbGRlcihmb2xkZXIucmVxdWVzdFBhdGgsIGZvbGRlci5uYW1lKVxuICAgIHRoaXMubGFzdENoZWNrYm94ID0gdW5kZWZpbmVkXG4gIH1cblxuICBhZGRGaWxlIChmaWxlKSB7XG4gICAgY29uc3QgdGFnRmlsZSA9IHtcbiAgICAgIGlkOiB0aGlzLnByb3ZpZGVyRmlsZVRvSWQoZmlsZSksXG4gICAgICBzb3VyY2U6IHRoaXMucGx1Z2luLmlkLFxuICAgICAgZGF0YTogZmlsZSxcbiAgICAgIG5hbWU6IGZpbGUubmFtZSB8fCBmaWxlLmlkLFxuICAgICAgdHlwZTogZmlsZS5taW1lVHlwZSxcbiAgICAgIGlzUmVtb3RlOiB0cnVlLFxuICAgICAgYm9keToge1xuICAgICAgICBmaWxlSWQ6IGZpbGUuaWQsXG4gICAgICB9LFxuICAgICAgcmVtb3RlOiB7XG4gICAgICAgIGNvbXBhbmlvblVybDogdGhpcy5wbHVnaW4ub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICAgIHVybDogYCR7dGhpcy5wcm92aWRlci5maWxlVXJsKGZpbGUucmVxdWVzdFBhdGgpfWAsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBmaWxlSWQ6IGZpbGUuaWQsXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogdGhpcy5wcm92aWRlci5vcHRzLFxuICAgICAgfSxcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlVHlwZSA9IGdldEZpbGVUeXBlKHRhZ0ZpbGUpXG4gICAgLy8gVE9ETyBTaG91bGQgd2UganVzdCBhbHdheXMgdXNlIHRoZSB0aHVtYm5haWwgVVJMIGlmIGl0IGV4aXN0cz9cbiAgICBpZiAoZmlsZVR5cGUgJiYgaXNQcmV2aWV3U3VwcG9ydGVkKGZpbGVUeXBlKSkge1xuICAgICAgdGFnRmlsZS5wcmV2aWV3ID0gZmlsZS50aHVtYm5haWxcbiAgICB9XG4gICAgdGhpcy5wbHVnaW4udXBweS5sb2coJ0FkZGluZyByZW1vdGUgZmlsZScpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGx1Z2luLnVwcHkuYWRkRmlsZSh0YWdGaWxlKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghZXJyLmlzUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgdGhpcy5wbHVnaW4udXBweS5sb2coZXJyKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc2Vzc2lvbiB0b2tlbiBvbiBjbGllbnQgc2lkZS5cbiAgICovXG4gIGxvZ291dCAoKSB7XG4gICAgdGhpcy5wcm92aWRlci5sb2dvdXQoKVxuICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgICAgaWYgKCFyZXMucmV2b2tlZCkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMucGx1Z2luLnVwcHkuaTE4bignY29tcGFuaW9uVW5hdXRob3JpemVIaW50Jywge1xuICAgICAgICAgICAgICBwcm92aWRlcjogdGhpcy5wbHVnaW4udGl0bGUsXG4gICAgICAgICAgICAgIHVybDogcmVzLm1hbnVhbF9yZXZva2VfdXJsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnVwcHkuaW5mbyhtZXNzYWdlLCAnaW5mbycsIDcwMDApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICBhdXRoZW50aWNhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVzOiBbXSxcbiAgICAgICAgICAgIGZvbGRlcnM6IFtdLFxuICAgICAgICAgICAgZGlyZWN0b3JpZXM6IFtdLFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZShuZXdTdGF0ZSlcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2godGhpcy5oYW5kbGVFcnJvcilcbiAgfVxuXG4gIGZpbHRlclF1ZXJ5IChlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyAuLi5zdGF0ZSwgZmlsdGVySW5wdXQ6IGUgPyBlLnRhcmdldC52YWx1ZSA6ICcnIH0pXG4gIH1cblxuICBzb3J0QnlUaXRsZSAoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7IC4uLnRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKCkgfVxuICAgIGNvbnN0IHsgZmlsZXMsIGZvbGRlcnMsIHNvcnRpbmcgfSA9IHN0YXRlXG5cbiAgICBjb25zdCBzb3J0ZWRGaWxlcyA9IGZpbGVzLnNvcnQoKGZpbGVBLCBmaWxlQikgPT4ge1xuICAgICAgaWYgKHNvcnRpbmcgPT09ICd0aXRsZURlc2NlbmRpbmcnKSB7XG4gICAgICAgIHJldHVybiBmaWxlQi5uYW1lLmxvY2FsZUNvbXBhcmUoZmlsZUEubmFtZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWxlQS5uYW1lLmxvY2FsZUNvbXBhcmUoZmlsZUIubmFtZSlcbiAgICB9KVxuXG4gICAgY29uc3Qgc29ydGVkRm9sZGVycyA9IGZvbGRlcnMuc29ydCgoZm9sZGVyQSwgZm9sZGVyQikgPT4ge1xuICAgICAgaWYgKHNvcnRpbmcgPT09ICd0aXRsZURlc2NlbmRpbmcnKSB7XG4gICAgICAgIHJldHVybiBmb2xkZXJCLm5hbWUubG9jYWxlQ29tcGFyZShmb2xkZXJBLm5hbWUpXG4gICAgICB9XG4gICAgICByZXR1cm4gZm9sZGVyQS5uYW1lLmxvY2FsZUNvbXBhcmUoZm9sZGVyQi5uYW1lKVxuICAgIH0pXG5cbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGZpbGVzOiBzb3J0ZWRGaWxlcyxcbiAgICAgIGZvbGRlcnM6IHNvcnRlZEZvbGRlcnMsXG4gICAgICBzb3J0aW5nOiAoc29ydGluZyA9PT0gJ3RpdGxlRGVzY2VuZGluZycpID8gJ3RpdGxlQXNjZW5kaW5nJyA6ICd0aXRsZURlc2NlbmRpbmcnLFxuICAgIH0pXG4gIH1cblxuICBzb3J0QnlEYXRlICgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHsgLi4udGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKSB9XG4gICAgY29uc3QgeyBmaWxlcywgZm9sZGVycywgc29ydGluZyB9ID0gc3RhdGVcblxuICAgIGNvbnN0IHNvcnRlZEZpbGVzID0gZmlsZXMuc29ydCgoZmlsZUEsIGZpbGVCKSA9PiB7XG4gICAgICBjb25zdCBhID0gbmV3IERhdGUoZmlsZUEubW9kaWZpZWREYXRlKVxuICAgICAgY29uc3QgYiA9IG5ldyBEYXRlKGZpbGVCLm1vZGlmaWVkRGF0ZSlcblxuICAgICAgaWYgKHNvcnRpbmcgPT09ICdkYXRlRGVzY2VuZGluZycpIHtcbiAgICAgICAgcmV0dXJuIGEgPiBiID8gLTEgOiBhIDwgYiA/IDEgOiAwXG4gICAgICB9XG4gICAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDBcbiAgICB9KVxuXG4gICAgY29uc3Qgc29ydGVkRm9sZGVycyA9IGZvbGRlcnMuc29ydCgoZm9sZGVyQSwgZm9sZGVyQikgPT4ge1xuICAgICAgY29uc3QgYSA9IG5ldyBEYXRlKGZvbGRlckEubW9kaWZpZWREYXRlKVxuICAgICAgY29uc3QgYiA9IG5ldyBEYXRlKGZvbGRlckIubW9kaWZpZWREYXRlKVxuXG4gICAgICBpZiAoc29ydGluZyA9PT0gJ2RhdGVEZXNjZW5kaW5nJykge1xuICAgICAgICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPCBiID8gMSA6IDBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwXG4gICAgfSlcblxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZmlsZXM6IHNvcnRlZEZpbGVzLFxuICAgICAgZm9sZGVyczogc29ydGVkRm9sZGVycyxcbiAgICAgIHNvcnRpbmc6IChzb3J0aW5nID09PSAnZGF0ZURlc2NlbmRpbmcnKSA/ICdkYXRlQXNjZW5kaW5nJyA6ICdkYXRlRGVzY2VuZGluZycsXG4gICAgfSlcbiAgfVxuXG4gIHNvcnRCeVNpemUgKCkge1xuICAgIGNvbnN0IHN0YXRlID0geyAuLi50aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpIH1cbiAgICBjb25zdCB7IGZpbGVzLCBzb3J0aW5nIH0gPSBzdGF0ZVxuXG4gICAgLy8gY2hlY2sgdGhhdCBwbHVnaW4gc3VwcG9ydHMgZmlsZSBzaXplc1xuICAgIGlmICghZmlsZXMubGVuZ3RoIHx8ICF0aGlzLnBsdWdpbi5nZXRJdGVtRGF0YShmaWxlc1swXSkuc2l6ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc29ydGVkRmlsZXMgPSBmaWxlcy5zb3J0KChmaWxlQSwgZmlsZUIpID0+IHtcbiAgICAgIGNvbnN0IGEgPSBmaWxlQS5zaXplXG4gICAgICBjb25zdCBiID0gZmlsZUIuc2l6ZVxuXG4gICAgICBpZiAoc29ydGluZyA9PT0gJ3NpemVEZXNjZW5kaW5nJykge1xuICAgICAgICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPCBiID8gMSA6IDBcbiAgICAgIH1cbiAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMFxuICAgIH0pXG5cbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGZpbGVzOiBzb3J0ZWRGaWxlcyxcbiAgICAgIHNvcnRpbmc6IChzb3J0aW5nID09PSAnc2l6ZURlc2NlbmRpbmcnKSA/ICdzaXplQXNjZW5kaW5nJyA6ICdzaXplRGVzY2VuZGluZycsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFsbCBmaWxlcyBmb3VuZCBpbnNpZGUgb2Ygc3BlY2lmaWVkIGZvbGRlci5cbiAgICpcbiAgICogVXNlcyBzZXBhcmF0ZWQgc3RhdGUgd2hpbGUgZm9sZGVyIGNvbnRlbnRzIGFyZSBiZWluZyBmZXRjaGVkIGFuZFxuICAgKiBtYW50YWlucyBsaXN0IG9mIHNlbGVjdGVkIGZvbGRlcnMsIHdoaWNoIGFyZSBzZXBhcmF0ZWQgZnJvbSBmaWxlcy5cbiAgICovXG4gIGFkZEZvbGRlciAoZm9sZGVyKSB7XG4gICAgY29uc3QgZm9sZGVySWQgPSB0aGlzLnByb3ZpZGVyRmlsZVRvSWQoZm9sZGVyKVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IGZvbGRlcnMgPSB7IC4uLnN0YXRlLnNlbGVjdGVkRm9sZGVycyB9XG4gICAgaWYgKGZvbGRlcklkIGluIGZvbGRlcnMgJiYgZm9sZGVyc1tmb2xkZXJJZF0ubG9hZGluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvbGRlcnNbZm9sZGVySWRdID0geyBsb2FkaW5nOiB0cnVlLCBmaWxlczogW10gfVxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgc2VsZWN0ZWRGb2xkZXJzOiB7IC4uLmZvbGRlcnMgfSB9KVxuICAgIHJldHVybiB0aGlzLmxpc3RBbGxGaWxlcyhmb2xkZXIucmVxdWVzdFBhdGgpLnRoZW4oKGZpbGVzKSA9PiB7XG4gICAgICBsZXQgY291bnQgPSAwXG4gICAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSB0aGlzLmFkZEZpbGUoZmlsZSlcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIGNvdW50KytcbiAgICAgIH0pXG4gICAgICBjb25zdCBpZHMgPSBmaWxlcy5tYXAodGhpcy5wcm92aWRlckZpbGVUb0lkKVxuICAgICAgZm9sZGVyc1tmb2xkZXJJZF0gPSB7XG4gICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICBmaWxlczogaWRzLFxuICAgICAgfVxuICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBzZWxlY3RlZEZvbGRlcnM6IGZvbGRlcnMgfSlcblxuICAgICAgbGV0IG1lc3NhZ2VcbiAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMucGx1Z2luLnVwcHkuaTE4bignZm9sZGVyQWRkZWQnLCB7XG4gICAgICAgICAgc21hcnRfY291bnQ6IGNvdW50LCBmb2xkZXI6IGZvbGRlci5uYW1lLFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9IHRoaXMucGx1Z2luLnVwcHkuaTE4bignZW1wdHlGb2xkZXJBZGRlZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnBsdWdpbi51cHB5LmluZm8obWVzc2FnZSlcbiAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgICBjb25zdCBzZWxlY3RlZEZvbGRlcnMgPSB7IC4uLnN0YXRlLnNlbGVjdGVkRm9sZGVycyB9XG4gICAgICBkZWxldGUgc2VsZWN0ZWRGb2xkZXJzW2ZvbGRlcklkXVxuICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBzZWxlY3RlZEZvbGRlcnMgfSlcbiAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSlcbiAgICB9KVxuICB9XG5cbiAgcHJvdmlkZXJGaWxlVG9JZCAoZmlsZSkge1xuICAgIHJldHVybiBnZW5lcmF0ZUZpbGVJRCh7XG4gICAgICBkYXRhOiBmaWxlLFxuICAgICAgbmFtZTogZmlsZS5uYW1lIHx8IGZpbGUuaWQsXG4gICAgICB0eXBlOiBmaWxlLm1pbWVUeXBlLFxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVBdXRoICgpIHtcbiAgICBjb25zdCBhdXRoU3RhdGUgPSBidG9hKEpTT04uc3RyaW5naWZ5KHsgb3JpZ2luOiBnZXRPcmlnaW4oKSB9KSlcbiAgICBjb25zdCBjbGllbnRWZXJzaW9uID0gYEB1cHB5L3Byb3ZpZGVyLXZpZXdzPSR7UHJvdmlkZXJWaWV3LlZFUlNJT059YFxuICAgIGNvbnN0IGxpbmsgPSB0aGlzLnByb3ZpZGVyLmF1dGhVcmwoeyBzdGF0ZTogYXV0aFN0YXRlLCB1cHB5VmVyc2lvbnM6IGNsaWVudFZlcnNpb24gfSlcblxuICAgIGNvbnN0IGF1dGhXaW5kb3cgPSB3aW5kb3cub3BlbihsaW5rLCAnX2JsYW5rJylcbiAgICBjb25zdCBoYW5kbGVUb2tlbiA9IChlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2lzT3JpZ2luQWxsb3dlZChlLm9yaWdpbiwgdGhpcy5wbHVnaW4ub3B0cy5jb21wYW5pb25BbGxvd2VkSG9zdHMpIHx8IGUuc291cmNlICE9PSBhdXRoV2luZG93KSB7XG4gICAgICAgIHRoaXMucGx1Z2luLnVwcHkubG9nKGByZWplY3RpbmcgZXZlbnQgZnJvbSAke2Uub3JpZ2lufSB2cyBhbGxvd2VkIHBhdHRlcm4gJHt0aGlzLnBsdWdpbi5vcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0c31gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIHN0cmluZyBiZWZvcmUgZG9pbmcgdGhlIEpTT04ucGFyc2UgdG8gbWFpbnRhaW4gc3VwcG9ydFxuICAgICAgLy8gZm9yIG9sZGVyIENvbXBhbmlvbiB2ZXJzaW9ucyB0aGF0IHVzZWQgb2JqZWN0IHJlZmVyZW5jZXNcbiAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgZS5kYXRhID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoZS5kYXRhKSA6IGUuZGF0YVxuXG4gICAgICBpZiAoIWRhdGEudG9rZW4pIHtcbiAgICAgICAgdGhpcy5wbHVnaW4udXBweS5sb2coJ2RpZCBub3QgcmVjZWl2ZSB0b2tlbiBmcm9tIGF1dGggd2luZG93JylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGF1dGhXaW5kb3cuY2xvc2UoKVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVUb2tlbilcbiAgICAgIHRoaXMucHJvdmlkZXIuc2V0QXV0aFRva2VuKGRhdGEudG9rZW4pXG4gICAgICB0aGlzLnByZUZpcnN0UmVuZGVyKClcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVUb2tlbilcbiAgfVxuXG4gIF9pc09yaWdpbkFsbG93ZWQgKG9yaWdpbiwgYWxsb3dlZE9yaWdpbikge1xuICAgIGNvbnN0IGdldFJlZ2V4ID0gKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dmFsdWV9JGApXG4gICAgICB9IGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYXR0ZXJucyA9IEFycmF5LmlzQXJyYXkoYWxsb3dlZE9yaWdpbikgPyBhbGxvd2VkT3JpZ2luLm1hcChnZXRSZWdleCkgOiBbZ2V0UmVnZXgoYWxsb3dlZE9yaWdpbildXG4gICAgcmV0dXJuIHBhdHRlcm5zXG4gICAgICAuZmlsdGVyKChwYXR0ZXJuKSA9PiBwYXR0ZXJuICE9IG51bGwpIC8vIGxvb3NlIGNvbXBhcmlzb24gdG8gY2F0Y2ggdW5kZWZpbmVkXG4gICAgICAuc29tZSgocGF0dGVybikgPT4gcGF0dGVybi50ZXN0KG9yaWdpbikgfHwgcGF0dGVybi50ZXN0KGAke29yaWdpbn0vYCkpIC8vIGFsbG93aW5nIGZvciB0cmFpbGluZyAnLydcbiAgfVxuXG4gIGhhbmRsZUVycm9yIChlcnJvcikge1xuICAgIGNvbnN0IHVwcHkgPSB0aGlzLnBsdWdpbi51cHB5XG4gICAgdXBweS5sb2coZXJyb3IudG9TdHJpbmcoKSlcbiAgICBpZiAoZXJyb3IuaXNBdXRoRXJyb3IpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gdXBweS5pMThuKCdjb21wYW5pb25FcnJvcicpXG4gICAgdXBweS5pbmZvKHsgbWVzc2FnZSwgZGV0YWlsczogZXJyb3IudG9TdHJpbmcoKSB9LCAnZXJyb3InLCA1MDAwKVxuICB9XG5cbiAgaGFuZGxlU2Nyb2xsIChlKSB7XG4gICAgY29uc3Qgc2Nyb2xsUG9zID0gZS50YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gKGUudGFyZ2V0LnNjcm9sbFRvcCArIGUudGFyZ2V0Lm9mZnNldEhlaWdodClcbiAgICBjb25zdCBwYXRoID0gdGhpcy5uZXh0UGFnZVBhdGggfHwgbnVsbFxuXG4gICAgaWYgKHNjcm9sbFBvcyA8IDUwICYmIHBhdGggJiYgIXRoaXMuX2lzSGFuZGxpbmdTY3JvbGwpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIubGlzdChwYXRoKVxuICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBmaWxlcywgZm9sZGVycyB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUZpbGVzQW5kRm9sZGVycyhyZXMsIGZpbGVzLCBmb2xkZXJzKVxuICAgICAgICB9KS5jYXRjaCh0aGlzLmhhbmRsZUVycm9yKVxuICAgICAgICAudGhlbigoKSA9PiB7IHRoaXMuX2lzSGFuZGxpbmdTY3JvbGwgPSBmYWxzZSB9KSAvLyBhbHdheXMgY2FsbGVkXG5cbiAgICAgIHRoaXMuX2lzSGFuZGxpbmdTY3JvbGwgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgbGlzdEFsbEZpbGVzIChwYXRoLCBmaWxlcyA9IG51bGwpIHtcbiAgICBmaWxlcyA9IGZpbGVzIHx8IFtdXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucHJvdmlkZXIubGlzdChwYXRoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgcmVzLml0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoIWl0ZW0uaXNGb2xkZXIpIHtcbiAgICAgICAgICAgIGZpbGVzLnB1c2goaXRlbSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRGb2xkZXIoaXRlbSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IG1vcmVGaWxlcyA9IHJlcy5uZXh0UGFnZVBhdGggfHwgbnVsbFxuICAgICAgICBpZiAobW9yZUZpbGVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGlzdEFsbEZpbGVzKG1vcmVGaWxlcywgZmlsZXMpXG4gICAgICAgICAgICAudGhlbigoZmlsZXMpID0+IHJlc29sdmUoZmlsZXMpKVxuICAgICAgICAgICAgLmNhdGNoKGUgPT4gcmVqZWN0KGUpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKGZpbGVzKVxuICAgICAgfSkuY2F0Y2goZSA9PiByZWplY3QoZSkpXG4gICAgfSlcbiAgfVxuXG4gIGRvbmVQaWNraW5nICgpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRTZWxlY3Rpb24gfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBwcm9taXNlcyA9IGN1cnJlbnRTZWxlY3Rpb24ubWFwKChmaWxlKSA9PiB7XG4gICAgICBpZiAoZmlsZS5pc0ZvbGRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRGb2xkZXIoZmlsZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSlcbiAgICB9KVxuXG4gICAgdGhpcy5fc2hhcmVkSGFuZGxlci5sb2FkZXJXcmFwcGVyKFByb21pc2UuYWxsKHByb21pc2VzKSwgKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpXG4gICAgfSwgKCkgPT4ge30pXG4gIH1cblxuICBjYW5jZWxQaWNraW5nICgpIHtcbiAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKClcblxuICAgIGNvbnN0IGRhc2hib2FyZCA9IHRoaXMucGx1Z2luLnVwcHkuZ2V0UGx1Z2luKCdEYXNoYm9hcmQnKVxuICAgIGlmIChkYXNoYm9hcmQpIGRhc2hib2FyZC5oaWRlQWxsUGFuZWxzKClcbiAgfVxuXG4gIGNsZWFyU2VsZWN0aW9uICgpIHtcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGN1cnJlbnRTZWxlY3Rpb246IFtdIH0pXG4gIH1cblxuICByZW5kZXIgKHN0YXRlLCB2aWV3T3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhdXRoZW50aWNhdGVkLCBkaWRGaXJzdFJlbmRlciB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGlmICghZGlkRmlyc3RSZW5kZXIpIHtcbiAgICAgIHRoaXMucHJlRmlyc3RSZW5kZXIoKVxuICAgIH1cblxuICAgIC8vIHJlbG9hZCBwbHVnaW5TdGF0ZSBmb3IgXCJsb2FkaW5nXCIgYXR0cmlidXRlIGJlY2F1c2UgaXQgbWlnaHRcbiAgICAvLyBoYXZlIGNoYW5nZWQgYWJvdmUuXG4gICAgaWYgKHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKCkubG9hZGluZykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPENsb3NlV3JhcHBlciBvblVubW91bnQ9e3RoaXMuY2xlYXJTZWxlY3Rpb259PlxuICAgICAgICAgIDxMb2FkZXJWaWV3IGkxOG49e3RoaXMucGx1Z2luLnVwcHkuaTE4bn0gLz5cbiAgICAgICAgPC9DbG9zZVdyYXBwZXI+XG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKCFhdXRoZW50aWNhdGVkKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgICAgPEF1dGhWaWV3XG4gICAgICAgICAgICBwbHVnaW5OYW1lPXt0aGlzLnBsdWdpbi50aXRsZX1cbiAgICAgICAgICAgIHBsdWdpbkljb249e3RoaXMucGx1Z2luLmljb259XG4gICAgICAgICAgICBoYW5kbGVBdXRoPXt0aGlzLmhhbmRsZUF1dGh9XG4gICAgICAgICAgICBpMThuPXt0aGlzLnBsdWdpbi51cHB5LmkxOG59XG4gICAgICAgICAgICBpMThuQXJyYXk9e3RoaXMucGx1Z2luLnVwcHkuaTE4bkFycmF5fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvQ2xvc2VXcmFwcGVyPlxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldFZpZXdPcHRpb25zID0geyAuLi50aGlzLm9wdHMsIC4uLnZpZXdPcHRpb25zIH1cbiAgICBjb25zdCBoZWFkZXJQcm9wcyA9IHtcbiAgICAgIHNob3dCcmVhZGNydW1iczogdGFyZ2V0Vmlld09wdGlvbnMuc2hvd0JyZWFkY3J1bWJzLFxuICAgICAgZ2V0Rm9sZGVyOiB0aGlzLmdldEZvbGRlcixcbiAgICAgIGRpcmVjdG9yaWVzOiB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpLmRpcmVjdG9yaWVzLFxuICAgICAgcGx1Z2luSWNvbjogdGhpcy5wbHVnaW4uaWNvbixcbiAgICAgIHRpdGxlOiB0aGlzLnBsdWdpbi50aXRsZSxcbiAgICAgIGxvZ291dDogdGhpcy5sb2dvdXQsXG4gICAgICB1c2VybmFtZTogdGhpcy51c2VybmFtZSxcbiAgICAgIGkxOG46IHRoaXMucGx1Z2luLnVwcHkuaTE4bixcbiAgICB9XG5cbiAgICBjb25zdCBicm93c2VyUHJvcHMgPSB7XG4gICAgICAuLi50aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpLFxuICAgICAgdXNlcm5hbWU6IHRoaXMudXNlcm5hbWUsXG4gICAgICBnZXROZXh0Rm9sZGVyOiB0aGlzLmdldE5leHRGb2xkZXIsXG4gICAgICBnZXRGb2xkZXI6IHRoaXMuZ2V0Rm9sZGVyLFxuICAgICAgZmlsdGVySXRlbXM6IHRoaXMuX3NoYXJlZEhhbmRsZXIuZmlsdGVySXRlbXMsXG4gICAgICBmaWx0ZXJRdWVyeTogdGhpcy5maWx0ZXJRdWVyeSxcbiAgICAgIHNvcnRCeVRpdGxlOiB0aGlzLnNvcnRCeVRpdGxlLFxuICAgICAgc29ydEJ5RGF0ZTogdGhpcy5zb3J0QnlEYXRlLFxuICAgICAgbG9nb3V0OiB0aGlzLmxvZ291dCxcbiAgICAgIGlzQ2hlY2tlZDogdGhpcy5fc2hhcmVkSGFuZGxlci5pc0NoZWNrZWQsXG4gICAgICB0b2dnbGVDaGVja2JveDogdGhpcy5fc2hhcmVkSGFuZGxlci50b2dnbGVDaGVja2JveCxcbiAgICAgIGhhbmRsZVNjcm9sbDogdGhpcy5oYW5kbGVTY3JvbGwsXG4gICAgICBsaXN0QWxsRmlsZXM6IHRoaXMubGlzdEFsbEZpbGVzLFxuICAgICAgZG9uZTogdGhpcy5kb25lUGlja2luZyxcbiAgICAgIGNhbmNlbDogdGhpcy5jYW5jZWxQaWNraW5nLFxuICAgICAgaGVhZGVyQ29tcG9uZW50OiBIZWFkZXIoaGVhZGVyUHJvcHMpLFxuICAgICAgdGl0bGU6IHRoaXMucGx1Z2luLnRpdGxlLFxuICAgICAgdmlld1R5cGU6IHRhcmdldFZpZXdPcHRpb25zLnZpZXdUeXBlLFxuICAgICAgc2hvd1RpdGxlczogdGFyZ2V0Vmlld09wdGlvbnMuc2hvd1RpdGxlcyxcbiAgICAgIHNob3dGaWx0ZXI6IHRhcmdldFZpZXdPcHRpb25zLnNob3dGaWx0ZXIsXG4gICAgICBzaG93QnJlYWRjcnVtYnM6IHRhcmdldFZpZXdPcHRpb25zLnNob3dCcmVhZGNydW1icyxcbiAgICAgIHBsdWdpbkljb246IHRoaXMucGx1Z2luLmljb24sXG4gICAgICBpMThuOiB0aGlzLnBsdWdpbi51cHB5LmkxOG4sXG4gICAgICB1cHB5RmlsZXM6IHRoaXMucGx1Z2luLnVwcHkuZ2V0RmlsZXMoKSxcbiAgICAgIHZhbGlkYXRlUmVzdHJpY3Rpb25zOiB0aGlzLnBsdWdpbi51cHB5LnZhbGlkYXRlUmVzdHJpY3Rpb25zLFxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgIDxCcm93c2VyIHsuLi5icm93c2VyUHJvcHN9IC8+XG4gICAgICA8L0Nsb3NlV3JhcHBlcj5cbiAgICApXG4gIH1cbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChbXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckJyb3dzZXItdXNlclwiIGtleT1cInVzZXJuYW1lXCI+e3Byb3BzLnVzZXJuYW1lfTwvc3Bhbj4sXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17cHJvcHMubG9nb3V0fSBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1Qcm92aWRlckJyb3dzZXItdXNlckxvZ291dFwiIGtleT1cImxvZ291dFwiPlxuICAgICAge3Byb3BzLmkxOG4oJ2xvZ091dCcpfVxuICAgIDwvYnV0dG9uPixcbiAgXSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9Qcm92aWRlclZpZXcnKVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9e3Byb3BzLnRyaWdnZXJTZWFyY2hJbnB1dH0gY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktUHJvdmlkZXJCcm93c2VyLXVzZXJMb2dvdXRcIj5cbiAgICAgIHtwcm9wcy5pMThuKCdiYWNrVG9TZWFyY2gnKX1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBsZXQgaW5wdXRcbiAgY29uc3QgaGFuZGxlS2V5UHJlc3MgPSAoZXYpID0+IHtcbiAgICBpZiAoZXYua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIHZhbGlkYXRlQW5kU2VhcmNoKClcbiAgICB9XG4gIH1cblxuICBjb25zdCB2YWxpZGF0ZUFuZFNlYXJjaCA9ICgpID0+IHtcbiAgICBpZiAoaW5wdXQudmFsdWUpIHtcbiAgICAgIHByb3BzLnNlYXJjaChpbnB1dC52YWx1ZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TZWFyY2hQcm92aWRlclwiPlxuICAgICAgPGlucHV0XG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtdGV4dElucHV0IHVwcHktU2VhcmNoUHJvdmlkZXItaW5wdXRcIlxuICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ2VudGVyVGV4dFRvU2VhcmNoJyl9XG4gICAgICAgIHBsYWNlaG9sZGVyPXtwcm9wcy5pMThuKCdlbnRlclRleHRUb1NlYXJjaCcpfVxuICAgICAgICBvbktleVVwPXtoYW5kbGVLZXlQcmVzc31cbiAgICAgICAgcmVmPXsoaW5wdXRfKSA9PiB7IGlucHV0ID0gaW5wdXRfIH19XG4gICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgIC8+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tcHJpbWFyeSB1cHB5LVNlYXJjaFByb3ZpZGVyLXNlYXJjaEJ1dHRvblwiXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBvbkNsaWNrPXt2YWxpZGF0ZUFuZFNlYXJjaH1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmkxOG4oJ3NlYXJjaEltYWdlcycpfVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IFNlYXJjaElucHV0ID0gcmVxdWlyZSgnLi9JbnB1dFZpZXcnKVxuY29uc3QgQnJvd3NlciA9IHJlcXVpcmUoJy4uL0Jyb3dzZXInKVxuY29uc3QgTG9hZGVyVmlldyA9IHJlcXVpcmUoJy4uL0xvYWRlcicpXG5jb25zdCBnZW5lcmF0ZUZpbGVJRCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZW5lcmF0ZUZpbGVJRCcpXG5jb25zdCBnZXRGaWxlVHlwZSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRGaWxlVHlwZScpXG5jb25zdCBpc1ByZXZpZXdTdXBwb3J0ZWQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaXNQcmV2aWV3U3VwcG9ydGVkJylcbmNvbnN0IEhlYWRlciA9IHJlcXVpcmUoJy4vSGVhZGVyJylcbmNvbnN0IFNoYXJlZEhhbmRsZXIgPSByZXF1aXJlKCcuLi9TaGFyZWRIYW5kbGVyJylcbmNvbnN0IENsb3NlV3JhcHBlciA9IHJlcXVpcmUoJy4uL0Nsb3NlV3JhcHBlcicpXG5cbi8qKlxuICogQ2xhc3MgdG8gZWFzaWx5IGdlbmVyYXRlIGdlbmVyaWMgdmlld3MgZm9yIFByb3ZpZGVyIHBsdWdpbnNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQcm92aWRlclZpZXcge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IHBsdWdpbiBpbnN0YW5jZSBvZiB0aGUgcGx1Z2luXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAocGx1Z2luLCBvcHRzKSB7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW5cbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0cy5wcm92aWRlclxuICAgIHRoaXMuX3NoYXJlZEhhbmRsZXIgPSBuZXcgU2hhcmVkSGFuZGxlcihwbHVnaW4pXG5cbiAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB2aWV3VHlwZTogJ2dyaWQnLFxuICAgICAgc2hvd1RpdGxlczogZmFsc2UsXG4gICAgICBzaG93RmlsdGVyOiBmYWxzZSxcbiAgICAgIHNob3dCcmVhZGNydW1iczogZmFsc2UsXG4gICAgfVxuXG4gICAgLy8gbWVyZ2UgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIG9uZXMgc2V0IGJ5IHVzZXJcbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIC8vIExvZ2ljXG4gICAgdGhpcy5zZWFyY2ggPSB0aGlzLnNlYXJjaC5iaW5kKHRoaXMpXG4gICAgdGhpcy50cmlnZ2VyU2VhcmNoSW5wdXQgPSB0aGlzLnRyaWdnZXJTZWFyY2hJbnB1dC5iaW5kKHRoaXMpXG4gICAgdGhpcy5hZGRGaWxlID0gdGhpcy5hZGRGaWxlLmJpbmQodGhpcylcbiAgICB0aGlzLnByZUZpcnN0UmVuZGVyID0gdGhpcy5wcmVGaXJzdFJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVFcnJvciA9IHRoaXMuaGFuZGxlRXJyb3IuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gdGhpcy5oYW5kbGVTY3JvbGwuYmluZCh0aGlzKVxuICAgIHRoaXMuZG9uZVBpY2tpbmcgPSB0aGlzLmRvbmVQaWNraW5nLmJpbmQodGhpcylcbiAgICB0aGlzLmNhbmNlbFBpY2tpbmcgPSB0aGlzLmNhbmNlbFBpY2tpbmcuYmluZCh0aGlzKVxuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24gPSB0aGlzLmNsZWFyU2VsZWN0aW9uLmJpbmQodGhpcylcblxuICAgIC8vIFZpc3VhbFxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbigpXG5cbiAgICAvLyBTZXQgZGVmYXVsdCBzdGF0ZSBmb3IgdGhlIHBsdWdpblxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGlzSW5wdXRNb2RlOiB0cnVlLFxuICAgICAgZmlsZXM6IFtdLFxuICAgICAgZm9sZGVyczogW10sXG4gICAgICBkaXJlY3RvcmllczogW10sXG4gICAgICBmaWx0ZXJJbnB1dDogJycsXG4gICAgICBpc1NlYXJjaFZpc2libGU6IGZhbHNlLFxuICAgIH0pXG4gIH1cblxuICB0ZWFyRG93biAoKSB7XG4gICAgLy8gTm90aGluZy5cbiAgfVxuXG4gIF91cGRhdGVGaWxlc0FuZElucHV0TW9kZSAocmVzLCBmaWxlcykge1xuICAgIHRoaXMubmV4dFBhZ2VRdWVyeSA9IHJlcy5uZXh0UGFnZVF1ZXJ5XG4gICAgdGhpcy5fc2VhcmNoVGVybSA9IHJlcy5zZWFyY2hlZEZvclxuICAgIHJlcy5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7IGZpbGVzLnB1c2goaXRlbSkgfSlcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGlzSW5wdXRNb2RlOiBmYWxzZSwgZmlsZXMgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgb25seSB0aGUgZmlyc3QgdGltZSB0aGUgcHJvdmlkZXIgdmlldyBpcyByZW5kZXJlZC5cbiAgICogS2luZCBvZiBsaWtlIGFuIGluaXQgZnVuY3Rpb24uXG4gICAqL1xuICBwcmVGaXJzdFJlbmRlciAoKSB7XG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBkaWRGaXJzdFJlbmRlcjogdHJ1ZSB9KVxuICAgIHRoaXMucGx1Z2luLm9uRmlyc3RSZW5kZXIoKVxuICB9XG5cbiAgc2VhcmNoIChxdWVyeSkge1xuICAgIGlmIChxdWVyeSAmJiBxdWVyeSA9PT0gdGhpcy5fc2VhcmNoVGVybSkge1xuICAgICAgLy8gbm8gbmVlZCB0byBzZWFyY2ggYWdhaW4gYXMgdGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgc2VhcmNoXG4gICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGlzSW5wdXRNb2RlOiBmYWxzZSB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZEhhbmRsZXIubG9hZGVyV3JhcHBlcihcbiAgICAgIHRoaXMucHJvdmlkZXIuc2VhcmNoKHF1ZXJ5KSxcbiAgICAgIChyZXMpID0+IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlRmlsZXNBbmRJbnB1dE1vZGUocmVzLCBbXSlcbiAgICAgIH0sXG4gICAgICB0aGlzLmhhbmRsZUVycm9yXG4gICAgKVxuICB9XG5cbiAgdHJpZ2dlclNlYXJjaElucHV0ICgpIHtcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGlzSW5wdXRNb2RlOiB0cnVlIH0pXG4gIH1cblxuICAvLyBAdG9kbyB0aGlzIGZ1bmN0aW9uIHNob3VsZCByZWFsbHkgYmUgYSBmdW5jdGlvbiBvZiB0aGUgcGx1Z2luIGFuZCBub3QgdGhlIHZpZXcuXG4gIC8vIG1heWJlIHdlIHNob3VsZCBjb25zaWRlciBjcmVhdGluZyBhIGJhc2UgUHJvdmlkZXJQbHVnaW4gY2xhc3MgdGhhdCBoYXMgdGhpcyBtZXRob2RcbiAgYWRkRmlsZSAoZmlsZSkge1xuICAgIGNvbnN0IHRhZ0ZpbGUgPSB7XG4gICAgICBpZDogdGhpcy5wcm92aWRlckZpbGVUb0lkKGZpbGUpLFxuICAgICAgc291cmNlOiB0aGlzLnBsdWdpbi5pZCxcbiAgICAgIGRhdGE6IGZpbGUsXG4gICAgICBuYW1lOiBmaWxlLm5hbWUgfHwgZmlsZS5pZCxcbiAgICAgIHR5cGU6IGZpbGUubWltZVR5cGUsXG4gICAgICBpc1JlbW90ZTogdHJ1ZSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgZmlsZUlkOiBmaWxlLmlkLFxuICAgICAgfSxcbiAgICAgIHJlbW90ZToge1xuICAgICAgICBjb21wYW5pb25Vcmw6IHRoaXMucGx1Z2luLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgICB1cmw6IGAke3RoaXMucHJvdmlkZXIuZmlsZVVybChmaWxlLnJlcXVlc3RQYXRoKX1gLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZmlsZUlkOiBmaWxlLmlkLFxuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IHsgLi4udGhpcy5wcm92aWRlci5vcHRzLCBwcm92aWRlcjogbnVsbCB9LFxuICAgICAgfSxcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlVHlwZSA9IGdldEZpbGVUeXBlKHRhZ0ZpbGUpXG4gICAgLy8gVE9ETyBTaG91bGQgd2UganVzdCBhbHdheXMgdXNlIHRoZSB0aHVtYm5haWwgVVJMIGlmIGl0IGV4aXN0cz9cbiAgICBpZiAoZmlsZVR5cGUgJiYgaXNQcmV2aWV3U3VwcG9ydGVkKGZpbGVUeXBlKSkge1xuICAgICAgdGFnRmlsZS5wcmV2aWV3ID0gZmlsZS50aHVtYm5haWxcbiAgICB9XG4gICAgdGhpcy5wbHVnaW4udXBweS5sb2coJ0FkZGluZyByZW1vdGUgZmlsZScpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGx1Z2luLnVwcHkuYWRkRmlsZSh0YWdGaWxlKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICB0aGlzLnBsdWdpbi51cHB5LmxvZyhlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdmlkZXJGaWxlVG9JZCAoZmlsZSkge1xuICAgIHJldHVybiBnZW5lcmF0ZUZpbGVJRCh7XG4gICAgICBkYXRhOiBmaWxlLFxuICAgICAgbmFtZTogZmlsZS5uYW1lIHx8IGZpbGUuaWQsXG4gICAgICB0eXBlOiBmaWxlLm1pbWVUeXBlLFxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVFcnJvciAoZXJyb3IpIHtcbiAgICBjb25zdCB1cHB5ID0gdGhpcy5wbHVnaW4udXBweVxuICAgIHVwcHkubG9nKGVycm9yLnRvU3RyaW5nKCkpXG4gICAgY29uc3QgbWVzc2FnZSA9IHVwcHkuaTE4bignY29tcGFuaW9uRXJyb3InKVxuICAgIHVwcHkuaW5mbyh7IG1lc3NhZ2UsIGRldGFpbHM6IGVycm9yLnRvU3RyaW5nKCkgfSwgJ2Vycm9yJywgNTAwMClcbiAgfVxuXG4gIGhhbmRsZVNjcm9sbCAoZSkge1xuICAgIGNvbnN0IHNjcm9sbFBvcyA9IGUudGFyZ2V0LnNjcm9sbEhlaWdodCAtIChlLnRhcmdldC5zY3JvbGxUb3AgKyBlLnRhcmdldC5vZmZzZXRIZWlnaHQpXG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLm5leHRQYWdlUXVlcnkgfHwgbnVsbFxuXG4gICAgaWYgKHNjcm9sbFBvcyA8IDUwICYmIHF1ZXJ5ICYmICF0aGlzLl9pc0hhbmRsaW5nU2Nyb2xsKSB7XG4gICAgICB0aGlzLnByb3ZpZGVyLnNlYXJjaCh0aGlzLl9zZWFyY2hUZXJtLCBxdWVyeSlcbiAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZmlsZXMgfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICAgICAgICB0aGlzLl91cGRhdGVGaWxlc0FuZElucHV0TW9kZShyZXMsIGZpbGVzKVxuICAgICAgICB9KS5jYXRjaCh0aGlzLmhhbmRsZUVycm9yKVxuICAgICAgICAudGhlbigoKSA9PiB7IHRoaXMuX2lzSGFuZGxpbmdTY3JvbGwgPSBmYWxzZSB9KSAvLyBhbHdheXMgY2FsbGVkXG5cbiAgICAgIHRoaXMuX2lzSGFuZGxpbmdTY3JvbGwgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgZG9uZVBpY2tpbmcgKCkge1xuICAgIGNvbnN0IHsgY3VycmVudFNlbGVjdGlvbiB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGNvbnN0IHByb21pc2VzID0gY3VycmVudFNlbGVjdGlvbi5tYXAoKGZpbGUpID0+IHRoaXMuYWRkRmlsZShmaWxlKSlcblxuICAgIHRoaXMuX3NoYXJlZEhhbmRsZXIubG9hZGVyV3JhcHBlcihQcm9taXNlLmFsbChwcm9taXNlcyksICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKVxuICAgIH0sICgpID0+IHt9KVxuICB9XG5cbiAgY2FuY2VsUGlja2luZyAoKSB7XG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbigpXG5cbiAgICBjb25zdCBkYXNoYm9hcmQgPSB0aGlzLnBsdWdpbi51cHB5LmdldFBsdWdpbignRGFzaGJvYXJkJylcbiAgICBpZiAoZGFzaGJvYXJkKSBkYXNoYm9hcmQuaGlkZUFsbFBhbmVscygpXG4gIH1cblxuICBjbGVhclNlbGVjdGlvbiAoKSB7XG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBjdXJyZW50U2VsZWN0aW9uOiBbXSB9KVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSwgdmlld09wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlkRmlyc3RSZW5kZXIsIGlzSW5wdXRNb2RlIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgaWYgKCFkaWRGaXJzdFJlbmRlcikge1xuICAgICAgdGhpcy5wcmVGaXJzdFJlbmRlcigpXG4gICAgfVxuXG4gICAgLy8gcmVsb2FkIHBsdWdpblN0YXRlIGZvciBcImxvYWRpbmdcIiBhdHRyaWJ1dGUgYmVjYXVzZSBpdCBtaWdodFxuICAgIC8vIGhhdmUgY2hhbmdlZCBhYm92ZS5cbiAgICBpZiAodGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKS5sb2FkaW5nKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgICAgPExvYWRlclZpZXcgaTE4bj17dGhpcy5wbHVnaW4udXBweS5pMThufSAvPlxuICAgICAgICA8L0Nsb3NlV3JhcHBlcj5cbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoaXNJbnB1dE1vZGUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxDbG9zZVdyYXBwZXIgb25Vbm1vdW50PXt0aGlzLmNsZWFyU2VsZWN0aW9ufT5cbiAgICAgICAgICA8U2VhcmNoSW5wdXRcbiAgICAgICAgICAgIHNlYXJjaD17dGhpcy5zZWFyY2h9XG4gICAgICAgICAgICBpMThuPXt0aGlzLnBsdWdpbi51cHB5LmkxOG59XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9DbG9zZVdyYXBwZXI+XG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0Vmlld09wdGlvbnMgPSB7IC4uLnRoaXMub3B0cywgLi4udmlld09wdGlvbnMgfVxuICAgIGNvbnN0IGJyb3dzZXJQcm9wcyA9IHtcbiAgICAgIC4uLnRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKCksXG4gICAgICBpc0NoZWNrZWQ6IHRoaXMuX3NoYXJlZEhhbmRsZXIuaXNDaGVja2VkLFxuICAgICAgdG9nZ2xlQ2hlY2tib3g6IHRoaXMuX3NoYXJlZEhhbmRsZXIudG9nZ2xlQ2hlY2tib3gsXG4gICAgICBoYW5kbGVTY3JvbGw6IHRoaXMuaGFuZGxlU2Nyb2xsLFxuICAgICAgZG9uZTogdGhpcy5kb25lUGlja2luZyxcbiAgICAgIGNhbmNlbDogdGhpcy5jYW5jZWxQaWNraW5nLFxuICAgICAgaGVhZGVyQ29tcG9uZW50OiBIZWFkZXIoe1xuICAgICAgICB0cmlnZ2VyU2VhcmNoSW5wdXQ6IHRoaXMudHJpZ2dlclNlYXJjaElucHV0LFxuICAgICAgICBpMThuOiB0aGlzLnBsdWdpbi51cHB5LmkxOG4sXG4gICAgICB9KSxcbiAgICAgIHRpdGxlOiB0aGlzLnBsdWdpbi50aXRsZSxcbiAgICAgIHZpZXdUeXBlOiB0YXJnZXRWaWV3T3B0aW9ucy52aWV3VHlwZSxcbiAgICAgIHNob3dUaXRsZXM6IHRhcmdldFZpZXdPcHRpb25zLnNob3dUaXRsZXMsXG4gICAgICBzaG93RmlsdGVyOiB0YXJnZXRWaWV3T3B0aW9ucy5zaG93RmlsdGVyLFxuICAgICAgc2hvd0JyZWFkY3J1bWJzOiB0YXJnZXRWaWV3T3B0aW9ucy5zaG93QnJlYWRjcnVtYnMsXG4gICAgICBwbHVnaW5JY29uOiB0aGlzLnBsdWdpbi5pY29uLFxuICAgICAgaTE4bjogdGhpcy5wbHVnaW4udXBweS5pMThuLFxuICAgICAgdXBweUZpbGVzOiB0aGlzLnBsdWdpbi51cHB5LmdldEZpbGVzKCksXG4gICAgICB2YWxpZGF0ZVJlc3RyaWN0aW9uczogdGhpcy5wbHVnaW4udXBweS52YWxpZGF0ZVJlc3RyaWN0aW9ucyxcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPENsb3NlV3JhcHBlciBvblVubW91bnQ9e3RoaXMuY2xlYXJTZWxlY3Rpb259PlxuICAgICAgICA8QnJvd3NlciB7Li4uYnJvd3NlclByb3BzfSAvPlxuICAgICAgPC9DbG9zZVdyYXBwZXI+XG4gICAgKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vU2VhcmNoUHJvdmlkZXJWaWV3JylcbiIsImNvbnN0IHJlbW90ZUZpbGVPYmpUb0xvY2FsID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3JlbW90ZUZpbGVPYmpUb0xvY2FsJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTaGFyZWRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKHBsdWdpbikge1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luXG4gICAgdGhpcy5maWx0ZXJJdGVtcyA9IHRoaXMuZmlsdGVySXRlbXMuYmluZCh0aGlzKVxuICAgIHRoaXMudG9nZ2xlQ2hlY2tib3ggPSB0aGlzLnRvZ2dsZUNoZWNrYm94LmJpbmQodGhpcylcbiAgICB0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuaXNDaGVja2VkLmJpbmQodGhpcylcbiAgICB0aGlzLmxvYWRlcldyYXBwZXIgPSB0aGlzLmxvYWRlcldyYXBwZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgZmlsdGVySXRlbXMgKGl0ZW1zKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgaWYgKCFzdGF0ZS5maWx0ZXJJbnB1dCB8fCBzdGF0ZS5maWx0ZXJJbnB1dCA9PT0gJycpIHtcbiAgICAgIHJldHVybiBpdGVtc1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChmb2xkZXIpID0+IHtcbiAgICAgIHJldHVybiBmb2xkZXIubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RhdGUuZmlsdGVySW5wdXQudG9Mb3dlckNhc2UoKSkgIT09IC0xXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIGZpbGUvZm9sZGVyIGNoZWNrYm94IHRvIG9uL29mZiBzdGF0ZSB3aGlsZSB1cGRhdGluZyBmaWxlcyBsaXN0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgc29tZSBleHRyYSBjb21wbGV4aXR5IGNvbWVzIGZyb20gc3VwcG9ydGluZyBzaGlmdCtjbGljayB0b1xuICAgKiB0b2dnbGUgbXVsdGlwbGUgY2hlY2tib3hlcyBhdCBvbmNlLCB3aGljaCBpcyBkb25lIGJ5IGdldHRpbmcgYWxsIGZpbGVzXG4gICAqIGluIGJldHdlZW4gbGFzdCBjaGVja2VkIGZpbGUgYW5kIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgdG9nZ2xlQ2hlY2tib3ggKGUsIGZpbGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5jdXJyZW50VGFyZ2V0LmZvY3VzKClcbiAgICBjb25zdCB7IGZvbGRlcnMsIGZpbGVzIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLmZpbHRlckl0ZW1zKGZvbGRlcnMuY29uY2F0KGZpbGVzKSlcblxuICAgIC8vIFNoaWZ0LWNsaWNraW5nIHNlbGVjdHMgYSBzaW5nbGUgY29uc2VjdXRpdmUgbGlzdCBvZiBpdGVtc1xuICAgIC8vIHN0YXJ0aW5nIGF0IHRoZSBwcmV2aW91cyBjbGljayBhbmQgZGVzZWxlY3RzIGV2ZXJ5dGhpbmcgZWxzZS5cbiAgICBpZiAodGhpcy5sYXN0Q2hlY2tib3ggJiYgZS5zaGlmdEtleSkge1xuICAgICAgbGV0IGN1cnJlbnRTZWxlY3Rpb25cbiAgICAgIGNvbnN0IHByZXZJbmRleCA9IGl0ZW1zLmluZGV4T2YodGhpcy5sYXN0Q2hlY2tib3gpXG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBpdGVtcy5pbmRleE9mKGZpbGUpXG4gICAgICBpZiAocHJldkluZGV4IDwgY3VycmVudEluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSBpdGVtcy5zbGljZShwcmV2SW5kZXgsIGN1cnJlbnRJbmRleCArIDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50U2VsZWN0aW9uID0gaXRlbXMuc2xpY2UoY3VycmVudEluZGV4LCBwcmV2SW5kZXggKyAxKVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgcmVzdHJpY3Rpb25zIG9uIGVhY2ggZmlsZSBpbiBjdXJyZW50U2VsZWN0aW9uLFxuICAgICAgLy8gcmVkdWNlIGl0IHRvIG9ubHkgY29udGFpbiBmaWxlcyB0aGF0IHBhc3MgcmVzdHJpY3Rpb25zXG4gICAgICBjdXJyZW50U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbi5yZWR1Y2UoKHJlZHVjZWRDdXJyZW50U2VsZWN0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwcHkgPSB0aGlzLnBsdWdpbi51cHB5XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZFJlc3RyaWN0aW9ucyA9IHVwcHkudmFsaWRhdGVSZXN0cmljdGlvbnMoXG4gICAgICAgICAgcmVtb3RlRmlsZU9ialRvTG9jYWwoaXRlbSksXG4gICAgICAgICAgWy4uLnVwcHkuZ2V0RmlsZXMoKSwgLi4ucmVkdWNlZEN1cnJlbnRTZWxlY3Rpb25dXG4gICAgICAgIClcbiAgICAgICAgaWYgKCF2YWxpZGF0ZWRSZXN0cmljdGlvbnMucmVzdWx0KSB7XG4gICAgICAgICAgdXBweS5pbmZvKHsgbWVzc2FnZTogdmFsaWRhdGVkUmVzdHJpY3Rpb25zLnJlYXNvbiB9LCAnZXJyb3InLCB1cHB5Lm9wdHMuaW5mb1RpbWVvdXQpXG4gICAgICAgICAgcmV0dXJuIHJlZHVjZWRDdXJyZW50U2VsZWN0aW9uXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi5yZWR1Y2VkQ3VycmVudFNlbGVjdGlvbiwgaXRlbV1cbiAgICAgIH0pXG4gICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGN1cnJlbnRTZWxlY3Rpb24gfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMubGFzdENoZWNrYm94ID0gZmlsZVxuICAgIGNvbnN0IHsgY3VycmVudFNlbGVjdGlvbiB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGlmICh0aGlzLmlzQ2hlY2tlZChmaWxlKSkge1xuICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBjdXJyZW50U2VsZWN0aW9uOiBjdXJyZW50U2VsZWN0aW9uLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5pZCAhPT0gZmlsZS5pZCksXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGN1cnJlbnRTZWxlY3Rpb246IGN1cnJlbnRTZWxlY3Rpb24uY29uY2F0KFtmaWxlXSksXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlzQ2hlY2tlZCAoZmlsZSkge1xuICAgIGNvbnN0IHsgY3VycmVudFNlbGVjdGlvbiB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgIC8vIGNvbXBhcmluZyBpZCBpbnN0ZWFkIG9mIHRoZSBmaWxlIG9iamVjdCwgYmVjYXVzZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBvYmplY3RcbiAgICAvLyBjaGFuZ2VzIHdoZW4gd2Ugc3dpdGNoIGZvbGRlcnMsIGFuZCB0aGUgZmlsZSBsaXN0IGlzIHVwZGF0ZWRcbiAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbi5zb21lKChpdGVtKSA9PiBpdGVtLmlkID09PSBmaWxlLmlkKVxuICB9XG5cbiAgbG9hZGVyV3JhcHBlciAocHJvbWlzZSwgdGhlbiwgY2F0Y2hfKSB7XG4gICAgcHJvbWlzZVxuICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGxvYWRpbmc6IGZhbHNlIH0pXG4gICAgICAgIHRoZW4ocmVzdWx0KVxuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGxvYWRpbmc6IGZhbHNlIH0pXG4gICAgICAgIGNhdGNoXyhlcnIpXG4gICAgICB9KVxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgbG9hZGluZzogdHJ1ZSB9KVxuICB9XG59XG4iLCJjb25zdCBQcm92aWRlclZpZXdzID0gcmVxdWlyZSgnLi9Qcm92aWRlclZpZXcnKVxuY29uc3QgU2VhcmNoUHJvdmlkZXJWaWV3cyA9IHJlcXVpcmUoJy4vU2VhcmNoUHJvdmlkZXJWaWV3JylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFByb3ZpZGVyVmlld3MsXG4gIFNlYXJjaFByb3ZpZGVyVmlld3MsXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L3NjcmVlbi1jYXB0dXJlXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJVcHB5IHBsdWdpbiB0aGF0IGNhcHR1cmVzIHZpZGVvIGZyb20gZGlzcGxheSBvciBhcHBsaWNhdGlvbi5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4wLjIxXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJzdHlsZVwiOiBcImRpc3Qvc3R5bGUubWluLmNzc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJzY3JlZW4gY2FwdHVyZVwiLFxuICAgIFwidmlkZW9cIixcbiAgICBcInJlY29yZFwiLFxuICAgIFwibWVkaWFyZWNvcmRlclwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfSxcbiAgXCJwdWJsaXNoQ29uZmlnXCI6IHtcbiAgICBcImFjY2Vzc1wiOiBcInB1YmxpY1wiXG4gIH1cbn1cbiIsImNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgUmVjb3JkQnV0dG9uID0gcmVxdWlyZSgnLi9SZWNvcmRCdXR0b24nKVxuY29uc3QgU3VibWl0QnV0dG9uID0gcmVxdWlyZSgnLi9TdWJtaXRCdXR0b24nKVxuY29uc3QgU3RvcFdhdGNoID0gcmVxdWlyZSgnLi9TdG9wV2F0Y2gnKVxuY29uc3QgU3RyZWFtU3RhdHVzID0gcmVxdWlyZSgnLi9TdHJlYW1TdGF0dXMnKVxuXG5jbGFzcyBSZWNvcmRlclNjcmVlbiBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICB0aGlzLnByb3BzLm9uU3RvcCgpXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHsgcmVjb3JkaW5nLCBzdHJlYW06IHZpZGVvU3RyZWFtLCByZWNvcmRlZFZpZGVvIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCB2aWRlb1Byb3BzID0ge1xuICAgICAgcGxheXNpbmxpbmU6IHRydWUsXG4gICAgfVxuXG4gICAgLy8gc2hvdyBzdHJlYW1cbiAgICBpZiAocmVjb3JkaW5nIHx8ICghcmVjb3JkZWRWaWRlbyAmJiAhcmVjb3JkaW5nKSkge1xuICAgICAgdmlkZW9Qcm9wcy5tdXRlZCA9IHRydWVcbiAgICAgIHZpZGVvUHJvcHMuYXV0b3BsYXkgPSB0cnVlXG4gICAgICB2aWRlb1Byb3BzLnNyY09iamVjdCA9IHZpZGVvU3RyZWFtXG4gICAgfVxuXG4gICAgLy8gc2hvdyBwcmV2aWV3XG4gICAgaWYgKHJlY29yZGVkVmlkZW8gJiYgIXJlY29yZGluZykge1xuICAgICAgdmlkZW9Qcm9wcy5tdXRlZCA9IGZhbHNlXG4gICAgICB2aWRlb1Byb3BzLmNvbnRyb2xzID0gdHJ1ZVxuICAgICAgdmlkZW9Qcm9wcy5zcmMgPSByZWNvcmRlZFZpZGVvXG5cbiAgICAgIC8vIHJlc2V0IHNyY09iamVjdCBpbiBkb20uIElmIG5vdCByZXNldHRlZCwgc3RyZWFtIHN0aWNrcyBpbiBlbGVtZW50XG4gICAgICBpZiAodGhpcy52aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweSB1cHB5LVNjcmVlbkNhcHR1cmUtY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TY3JlZW5DYXB0dXJlLXZpZGVvQ29udGFpbmVyXCI+XG4gICAgICAgICAgPFN0cmVhbVN0YXR1cyB7Li4udGhpcy5wcm9wc30gLz5cbiAgICAgICAgICA8dmlkZW8gcmVmPXt2aWRlb0VsZW1lbnQgPT4gKHRoaXMudmlkZW9FbGVtZW50ID0gdmlkZW9FbGVtZW50KX0gY2xhc3NOYW1lPVwidXBweS1TY3JlZW5DYXB0dXJlLXZpZGVvXCIgey4uLnZpZGVvUHJvcHN9IC8+XG4gICAgICAgICAgPFN0b3BXYXRjaCB7Li4udGhpcy5wcm9wc30gLz5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVNjcmVlbkNhcHR1cmUtYnV0dG9uQ29udGFpbmVyXCI+XG4gICAgICAgICAgPFJlY29yZEJ1dHRvbiB7Li4udGhpcy5wcm9wc30gLz5cbiAgICAgICAgICA8U3VibWl0QnV0dG9uIHsuLi50aGlzLnByb3BzfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY29yZGVyU2NyZWVuXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbi8qKlxuICogQ29udHJvbCBzY3JlZW4gY2FwdHVyZSByZWNvcmRpbmcuIFdpbGwgc2hvdyByZWNvcmQgb3Igc3RvcCBidXR0b24uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUmVjb3JkQnV0dG9uICh7IHJlY29yZGluZywgb25TdGFydFJlY29yZGluZywgb25TdG9wUmVjb3JkaW5nLCBpMThuIH0pIHtcbiAgaWYgKHJlY29yZGluZykge1xuICAgIHJldHVybiAoXG4gICAgICA8YnV0dG9uXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktU2NyZWVuQ2FwdHVyZS1idXR0b24gdXBweS1TY3JlZW5DYXB0dXJlLWJ1dHRvbi0tdmlkZW8gdXBweS1TY3JlZW5DYXB0dXJlLWJ1dHRvbi0tc3RvcC1yZWNcIlxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgdGl0bGU9e2kxOG4oJ3N0b3BDYXB0dXJpbmcnKX1cbiAgICAgICAgYXJpYS1sYWJlbD17aTE4bignc3RvcENhcHR1cmluZycpfVxuICAgICAgICBvbkNsaWNrPXtvblN0b3BSZWNvcmRpbmd9XG4gICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgID5cbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIj5cbiAgICAgICAgICA8cmVjdCB4PVwiMTVcIiB5PVwiMTVcIiB3aWR0aD1cIjcwXCIgaGVpZ2h0PVwiNzBcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvYnV0dG9uPlxuICAgIClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1TY3JlZW5DYXB0dXJlLWJ1dHRvbiB1cHB5LVNjcmVlbkNhcHR1cmUtYnV0dG9uLS12aWRlb1wiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIHRpdGxlPXtpMThuKCdzdGFydENhcHR1cmluZycpfVxuICAgICAgYXJpYS1sYWJlbD17aTE4bignc3RhcnRDYXB0dXJpbmcnKX1cbiAgICAgIG9uQ2xpY2s9e29uU3RhcnRSZWNvcmRpbmd9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIj5cbiAgICAgICAgPGNpcmNsZSBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCI0MFwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiPlxuICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIGZpbGw9XCIjMkMzRTUwXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjQuMTgyIDlINy44MThDNi44MSA5IDYgOS43NDIgNiAxMC42Njd2MTBjMCAuOTE2LjgxIDEuNjY2IDEuODE4IDEuNjY2aDQuNTQ2VjI0aDcuMjcydi0xLjY2N2g0LjU0NmMxIDAgMS44MDktLjc1IDEuODA5LTEuNjY2bC4wMDktMTBDMjYgOS43NDIgMjUuMTgyIDkgMjQuMTgyIDl6TTI0IDIxSDhWMTFoMTZ2MTB6XCIgZmlsbD1cIiNGRkZcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiAvPlxuICAgICAgICA8Y2lyY2xlIGZpbGw9XCIjRkZGXCIgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMlwiIC8+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gIClcbn1cbiIsImNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5jbGFzcyBTdG9wd2F0Y2ggZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLnN0YXRlID0geyBlbGFwc2VkVGltZTogMCB9XG5cbiAgICB0aGlzLndyYXBwZXJTdHlsZSA9IHtcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICB9XG5cbiAgICB0aGlzLm92ZXJsYXlTdHlsZSA9IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgYmFja2dyb3VuZDogJ2JsYWNrJyxcbiAgICAgIG9wYWNpdHk6IDAuNyxcbiAgICB9XG5cbiAgICB0aGlzLmluZm9Db250YWluZXJTdHlsZSA9IHtcbiAgICAgIG1hcmdpbkxlZnQ6ICdhdXRvJyxcbiAgICAgIG1hcmdpblJpZ2h0OiAnYXV0bycsXG4gICAgICBtYXJnaW5Ub3A6ICdhdXRvJyxcbiAgICAgIG1hcmdpbkJvdHRvbTogJ2F1dG8nLFxuICAgICAgekluZGV4OiAxLFxuICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgfVxuXG4gICAgdGhpcy5pbmZvdGV4dFN0eWxlID0ge1xuICAgICAgbWFyZ2luTGVmdDogJ2F1dG8nLFxuICAgICAgbWFyZ2luUmlnaHQ6ICdhdXRvJyxcbiAgICAgIG1hcmdpbkJvdHRvbTogJzFyZW0nLFxuICAgICAgZm9udFNpemU6ICcxLjVyZW0nLFxuICAgIH1cblxuICAgIHRoaXMudGltZVN0eWxlID0ge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgIG1hcmdpbkxlZnQ6ICdhdXRvJyxcbiAgICAgIG1hcmdpblJpZ2h0OiAnYXV0bycsXG4gICAgICBmb250U2l6ZTogJzNyZW0nLFxuICAgICAgZm9udEZhbWlseTogJ0NvdXJpZXIgTmV3JyxcbiAgICB9XG4gIH1cblxuICBzdGFydFRpbWVyICgpIHtcbiAgICB0aGlzLnRpbWVyVGljaygpXG4gICAgdGhpcy50aW1lclJ1bm5pbmcgPSB0cnVlXG4gIH1cblxuICByZXNldFRpbWVyICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcbiAgICB0aGlzLnNldFN0YXRlKHsgZWxhcHNlZFRpbWU6IDAgfSlcbiAgICB0aGlzLnRpbWVyUnVubmluZyA9IGZhbHNlXG4gIH1cblxuICB0aW1lclRpY2sgKCkge1xuICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBlbGFwc2VkVGltZTogdGhpcy5zdGF0ZS5lbGFwc2VkVGltZSArIDEgfSlcbiAgICAgIHRoaXMudGltZXJUaWNrKClcbiAgICB9LCAxMDAwKVxuICB9XG5cbiAgZm10TVNTIChzKSB7XG4gICAgcmV0dXJuIChzIC0gKHMgJT0gNjApKSAvIDYwICsgKHMgPiA5ID8gJzonIDogJzowJykgKyBzXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHsgcmVjb3JkaW5nLCBpMThuIH0gPSB7IC4uLnRoaXMucHJvcHMgfVxuXG4gICAgLy8gc2Vjb25kIHRvIG1pbnV0ZXMgYW5kIHNlY29uZHNcbiAgICBjb25zdCBtaW5BbmRTZWMgPSB0aGlzLmZtdE1TUyh0aGlzLnN0YXRlLmVsYXBzZWRUaW1lKVxuXG4gICAgaWYgKHJlY29yZGluZyAmJiAhdGhpcy50aW1lclJ1bm5pbmcpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lcigpXG4gICAgfVxuXG4gICAgaWYgKCFyZWNvcmRpbmcgJiYgdGhpcy50aW1lclJ1bm5pbmcpIHtcbiAgICAgIHRoaXMucmVzZXRUaW1lcigpXG4gICAgfVxuXG4gICAgaWYgKHJlY29yZGluZykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBzdHlsZT17dGhpcy53cmFwcGVyU3R5bGV9PlxuICAgICAgICAgIDxkaXYgc3R5bGU9e3RoaXMub3ZlcmxheVN0eWxlfSAvPlxuICAgICAgICAgIDxkaXYgc3R5bGU9e3RoaXMuaW5mb0NvbnRhaW5lclN0eWxlfT5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3RoaXMuaW5mb3RleHRTdHlsZX0+XG4gICAgICAgICAgICAgIHtpMThuKCdyZWNvcmRpbmcnKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBzdHlsZT17dGhpcy50aW1lU3R5bGV9PlxuICAgICAgICAgICAgICB7bWluQW5kU2VjfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPC9kaXY+XG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdG9wd2F0Y2hcbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAoeyBzdHJlYW1BY3RpdmUsIGkxOG4gfSkgPT4ge1xuICBpZiAoc3RyZWFtQWN0aXZlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgdGl0bGU9e2kxOG4oJ3N0cmVhbUFjdGl2ZScpfSBhcmlhLWxhYmVsPXtpMThuKCdzdHJlYW1BY3RpdmUnKX0gY2xhc3NOYW1lPVwidXBweS1TY3JlZW5DYXB0dXJlLWljb24tLXN0cmVhbSB1cHB5LVNjcmVlbkNhcHR1cmUtaWNvbi0tc3RyZWFtQWN0aXZlXCI+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgICAgPHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBvcGFjaXR5PVwiLjFcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xIDE4djNoM2MwLTEuNjYtMS4zNC0zLTMtM3ptMC00djJjMi43NiAwIDUgMi4yNCA1IDVoMmMwLTMuODctMy4xMy03LTctN3ptMTgtN0g1djEuNjNjMy45NiAxLjI4IDcuMDkgNC40MSA4LjM3IDguMzdIMTlWN3pNMSAxMHYyYzQuOTcgMCA5IDQuMDMgOSA5aDJjMC02LjA4LTQuOTMtMTEtMTEtMTF6bTIwLTdIM2MtMS4xIDAtMiAuOS0yIDJ2M2gyVjVoMTh2MTRoLTd2Mmg3YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbiAgcmV0dXJuIChcbiAgICA8ZGl2IHRpdGxlPXtpMThuKCdzdHJlYW1QYXNzaXZlJyl9IGFyaWEtbGFiZWw9e2kxOG4oJ3N0cmVhbVBhc3NpdmUnKX0gY2xhc3NOYW1lPVwidXBweS1TY3JlZW5DYXB0dXJlLWljb24tLXN0cmVhbVwiPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgPHBhdGggZD1cIk0wIDBoMjR2MjRIMHpcIiBvcGFjaXR5PVwiLjFcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNMCAwaDI0djI0SDB6XCIgZmlsbD1cIm5vbmVcIiAvPlxuICAgICAgICA8cGF0aCBkPVwiTTIxIDNIM2MtMS4xIDAtMiAuOS0yIDJ2M2gyVjVoMTh2MTRoLTd2Mmg3YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6TTEgMTh2M2gzYzAtMS42Ni0xLjM0LTMtMy0zem0wLTR2MmMyLjc2IDAgNSAyLjI0IDUgNWgyYzAtMy44Ny0zLjEzLTctNy03em0wLTR2MmM0Ljk3IDAgOSA0LjAzIDkgOWgyYzAtNi4wOC00LjkzLTExLTExLTExelwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG4vKipcbiAqIFN1Ym1pdCByZWNvcmRlZCB2aWRlbyB0byB1cHB5LiBFbmFibGVkIHdoZW4gZmlsZSBpcyBhdmFpbGFibGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTdWJtaXRCdXR0b24gKHsgcmVjb3JkaW5nLCByZWNvcmRlZFZpZGVvLCBvblN1Ym1pdCwgaTE4biB9KSB7XG4gIGlmIChyZWNvcmRlZFZpZGVvICYmICFyZWNvcmRpbmcpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGJ1dHRvblxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LVNjcmVlbkNhcHR1cmUtYnV0dG9uIHVwcHktU2NyZWVuQ2FwdHVyZS1idXR0b24tLXN1Ym1pdFwiXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICB0aXRsZT17aTE4bignc3VibWl0UmVjb3JkZWRGaWxlJyl9XG4gICAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3N1Ym1pdFJlY29yZGVkRmlsZScpfVxuICAgICAgICBvbkNsaWNrPXtvblN1Ym1pdH1cbiAgICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgICAgPlxuICAgICAgICA8c3ZnXG4gICAgICAgICAgd2lkdGg9XCIxMlwiXG4gICAgICAgICAgaGVpZ2h0PVwiOVwiXG4gICAgICAgICAgdmlld0JveD1cIjAgMCAxMiA5XCJcbiAgICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiXG4gICAgICAgID5cbiAgICAgICAgICA8cGF0aCBmaWxsPVwiI2ZmZlwiIGZpbGxSdWxlPVwibm9uemVyb1wiIGQ9XCJNMTAuNjYgMEwxMiAxLjMxIDQuMTM2IDkgMCA0Ljk1NmwxLjM0LTEuMzFMNC4xMzYgNi4zOHpcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvYnV0dG9uPlxuICAgIClcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgeyBQbHVnaW4gfSA9IHJlcXVpcmUoJ0B1cHB5L2NvcmUnKVxuY29uc3QgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9UcmFuc2xhdG9yJylcbmNvbnN0IGdldEZpbGVUeXBlRXh0ZW5zaW9uID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldEZpbGVUeXBlRXh0ZW5zaW9uJylcbmNvbnN0IFNjcmVlblJlY0ljb24gPSByZXF1aXJlKCcuL1NjcmVlblJlY0ljb24nKVxuY29uc3QgQ2FwdHVyZVNjcmVlbiA9IHJlcXVpcmUoJy4vQ2FwdHVyZVNjcmVlbicpXG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhRGV2aWNlcy9nZXRVc2VyTWVkaWFcbmZ1bmN0aW9uIGdldE1lZGlhRGV2aWNlcyAoKSB7XG4gIC8vIGNoZWNrIGlmIHNjcmVlbiBjYXB0dXJpbmcgaXMgc3VwcG9ydGVkXG4gIC8qIGVzbGludC1kaXNhYmxlICovXG4gIGlmIChuYXZpZ2F0b3IgJiZcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmXG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgJiZcbiAgICB3aW5kb3cgJiZcbiAgICB3aW5kb3cuTWVkaWFSZWNvcmRlcikge1xuICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogU2NyZWVuIGNhcHR1cmVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTY3JlZW5DYXB0dXJlIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMubWVkaWFEZXZpY2VzID0gZ2V0TWVkaWFEZXZpY2VzKClcbiAgICB0aGlzLnByb3RvY29sID0gbG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL2h0dHBzL2kpID8gJ2h0dHBzJyA6ICdodHRwJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1NjcmVlbkNhcHR1cmUnXG4gICAgdGhpcy50aXRsZSA9IHRoaXMub3B0cy50aXRsZSB8fCAnU2NyZWVuY2FzdCdcbiAgICB0aGlzLnR5cGUgPSAnYWNxdWlyZXInXG4gICAgdGhpcy5pY29uID0gU2NyZWVuUmVjSWNvblxuXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0ge1xuICAgICAgc3RyaW5nczoge1xuICAgICAgICBzdGFydENhcHR1cmluZzogJ0JlZ2luIHNjcmVlbiBjYXB0dXJpbmcnLFxuICAgICAgICBzdG9wQ2FwdHVyaW5nOiAnU3RvcCBzY3JlZW4gY2FwdHVyaW5nJyxcbiAgICAgICAgc3VibWl0UmVjb3JkZWRGaWxlOiAnU3VibWl0IHJlY29yZGVkIGZpbGUnLFxuICAgICAgICBzdHJlYW1BY3RpdmU6ICdTdHJlYW0gYWN0aXZlJyxcbiAgICAgICAgc3RyZWFtUGFzc2l2ZTogJ1N0cmVhbSBwYXNzaXZlJyxcbiAgICAgICAgbWljRGlzYWJsZWQ6ICdNaWNyb3Bob25lIGFjY2VzcyBkZW5pZWQgYnkgdXNlcicsXG4gICAgICAgIHJlY29yZGluZzogJ1JlY29yZGluZycsXG4gICAgICB9LFxuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFTdHJlYW1Db25zdHJhaW50c1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhVHJhY2tDb25zdHJhaW50cyNQcm9wZXJ0aWVzX29mX3NoYXJlZF9zY3JlZW5fdHJhY2tzXG4gICAgICBkaXNwbGF5TWVkaWFDb25zdHJhaW50czoge1xuICAgICAgICB2aWRlbzoge1xuICAgICAgICAgIHdpZHRoOiAxMjgwLFxuICAgICAgICAgIGhlaWdodDogNzIwLFxuICAgICAgICAgIGZyYW1lUmF0ZToge1xuICAgICAgICAgICAgaWRlYWw6IDMsXG4gICAgICAgICAgICBtYXg6IDUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXJzb3I6ICdtb3Rpb24nLFxuICAgICAgICAgIGRpc3BsYXlTdXJmYWNlOiAnbW9uaXRvcicsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhU3RyZWFtQ29uc3RyYWludHMvYXVkaW9cbiAgICAgIHVzZXJNZWRpYUNvbnN0cmFpbnRzOiB7XG4gICAgICAgIGF1ZGlvOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHByZWZlcnJlZFZpZGVvTWltZVR5cGU6ICd2aWRlby93ZWJtJyxcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlclxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgLy8gaTE4blxuICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKFt0aGlzLmRlZmF1bHRMb2NhbGUsIHRoaXMudXBweS5sb2NhbGUsIHRoaXMub3B0cy5sb2NhbGVdKVxuICAgIHRoaXMuaTE4biA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5pMThuQXJyYXkgPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlQXJyYXkuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG5cbiAgICAvLyB1cHB5IHBsdWdpbiBjbGFzcyByZWxhdGVkXG4gICAgdGhpcy5pbnN0YWxsID0gdGhpcy5pbnN0YWxsLmJpbmQodGhpcylcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlID0gdGhpcy5zZXRQbHVnaW5TdGF0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG5cbiAgICAvLyBzY3JlZW4gY2FwdHVyZXIgcmVsYXRlZFxuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcylcbiAgICB0aGlzLnN0b3AgPSB0aGlzLnN0b3AuYmluZCh0aGlzKVxuICAgIHRoaXMuc3RhcnRSZWNvcmRpbmcgPSB0aGlzLnN0YXJ0UmVjb3JkaW5nLmJpbmQodGhpcylcbiAgICB0aGlzLnN0b3BSZWNvcmRpbmcgPSB0aGlzLnN0b3BSZWNvcmRpbmcuYmluZCh0aGlzKVxuICAgIHRoaXMuc3VibWl0ID0gdGhpcy5zdWJtaXQuYmluZCh0aGlzKVxuICAgIHRoaXMuc3RyZWFtSW50ZXJydXB0ZWQgPSB0aGlzLnN0cmVhbUluYWN0aXZhdGVkLmJpbmQodGhpcylcblxuICAgIC8vIGluaXRpYWxpemVcbiAgICB0aGlzLmNhcHR1cmVBY3RpdmUgPSBmYWxzZVxuICAgIHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUgPSBudWxsXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICAvLyBSZXR1cm4gaWYgYnJvd3NlciBkb2VzbuKAmXQgc3VwcG9ydCBnZXREaXNwbGF5TWVkaWEgYW5kXG4gICAgaWYgKCF0aGlzLm1lZGlhRGV2aWNlcykge1xuICAgICAgdGhpcy51cHB5LmxvZygnU2NyZWVuIHJlY29yZGVyIGFjY2VzcyBpcyBub3Qgc3VwcG9ydGVkJywgJ2Vycm9yJylcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBzdHJlYW1BY3RpdmU6IGZhbHNlLFxuICAgICAgYXVkaW9TdHJlYW1BY3RpdmU6IGZhbHNlLFxuICAgIH0pXG5cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLm9wdHMudGFyZ2V0XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICBpZiAodGhpcy52aWRlb1N0cmVhbSkge1xuICAgICAgdGhpcy5zdG9wKClcbiAgICB9XG5cbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgc3RhcnQgKCkge1xuICAgIGlmICghdGhpcy5tZWRpYURldmljZXMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1NjcmVlbiByZWNvcmRlciBhY2Nlc3Mgbm90IHN1cHBvcnRlZCcpKVxuICAgIH1cblxuICAgIHRoaXMuY2FwdHVyZUFjdGl2ZSA9IHRydWVcblxuICAgIHRoaXMuc2VsZWN0QXVkaW9TdHJlYW1Tb3VyY2UoKVxuXG4gICAgdGhpcy5zZWxlY3RWaWRlb1N0cmVhbVNvdXJjZSgpXG4gICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICAvLyBzb21ldGhpbmcgaGFwcGVuZWQgaW4gc3RhcnQgLT4gcmV0dXJuXG4gICAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gQ2xvc2UgdGhlIERhc2hib2FyZCBwYW5lbCBpZiBwbHVnaW4gaXMgaW5zdGFsbGVkXG4gICAgICAgICAgLy8gaW50byBEYXNoYm9hcmQgKGNvdWxkIGJlIG90aGVyIHBhcmVudCBVSSBwbHVnaW4pXG4gICAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmhpZGVBbGxQYW5lbHMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmhpZGVBbGxQYW5lbHMoKVxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlQWN0aXZlID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICBzZWxlY3RWaWRlb1N0cmVhbVNvdXJjZSAoKSB7XG4gICAgLy8gaWYgYWN0aXZlIHN0cmVhbSBhdmFpbGFibGUsIHJldHVybiBpdFxuICAgIGlmICh0aGlzLnZpZGVvU3RyZWFtKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiByZXNvbHZlKHRoaXMudmlkZW9TdHJlYW0pKVxuICAgIH1cblxuICAgIC8vIGFzayB1c2VyIHRvIHNlbGVjdCBzb3VyY2UgdG8gcmVjb3JkIGFuZCBnZXQgbWVkaWFzdHJlYW0gZnJvbSB0aGF0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICByZXR1cm4gdGhpcy5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKHRoaXMub3B0cy5kaXNwbGF5TWVkaWFDb25zdHJhaW50cylcbiAgICAgIC50aGVuKCh2aWRlb1N0cmVhbSkgPT4ge1xuICAgICAgICB0aGlzLnZpZGVvU3RyZWFtID0gdmlkZW9TdHJlYW1cblxuICAgICAgICAvLyBhZGQgZXZlbnQgbGlzdGVuZXIgdG8gc3RvcCByZWNvcmRpbmcgaWYgc3RyZWFtIGlzIGludGVycnVwdGVkXG4gICAgICAgIHRoaXMudmlkZW9TdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignaW5hY3RpdmUnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICB0aGlzLnN0cmVhbUluYWN0aXZhdGVkKClcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICBzdHJlYW1BY3RpdmU6IHRydWUsXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHZpZGVvU3RyZWFtXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgc2NyZWVuUmVjRXJyb3I6IGVycixcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLnVzZXJEZW5pZWQgPSB0cnVlXG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy51c2VyRGVuaWVkID0gZmFsc2VcbiAgICAgICAgfSwgMTAwMClcblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0pXG4gIH1cblxuICBzZWxlY3RBdWRpb1N0cmVhbVNvdXJjZSAoKSB7XG4gICAgLy8gaWYgYWN0aXZlIHN0cmVhbSBhdmFpbGFibGUsIHJldHVybiBpdFxuICAgIGlmICh0aGlzLmF1ZGlvU3RyZWFtKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiByZXNvbHZlKHRoaXMuYXVkaW9TdHJlYW0pKVxuICAgIH1cblxuICAgIC8vIGFzayB1c2VyIHRvIHNlbGVjdCBzb3VyY2UgdG8gcmVjb3JkIGFuZCBnZXQgbWVkaWFzdHJlYW0gZnJvbSB0aGF0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICByZXR1cm4gdGhpcy5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHRoaXMub3B0cy51c2VyTWVkaWFDb25zdHJhaW50cylcbiAgICAgIC50aGVuKChhdWRpb1N0cmVhbSkgPT4ge1xuICAgICAgICB0aGlzLmF1ZGlvU3RyZWFtID0gYXVkaW9TdHJlYW1cblxuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICBhdWRpb1N0cmVhbUFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gYXVkaW9TdHJlYW1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgICAgdGhpcy51cHB5LmluZm8odGhpcy5pMThuKCdtaWNEaXNhYmxlZCcpLCAnZXJyb3InLCA1MDAwKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9KVxuICB9XG5cbiAgc3RhcnRSZWNvcmRpbmcgKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7fVxuICAgIHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUgPSBudWxsXG4gICAgdGhpcy5yZWNvcmRpbmdDaHVua3MgPSBbXVxuICAgIGNvbnN0IHByZWZlcnJlZFZpZGVvTWltZVR5cGUgPSB0aGlzLm9wdHMucHJlZmVycmVkVmlkZW9NaW1lVHlwZVxuXG4gICAgdGhpcy5zZWxlY3RWaWRlb1N0cmVhbVNvdXJjZSgpXG4gICAgICAudGhlbigodmlkZW9TdHJlYW0pID0+IHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byB1c2UgdGhlIHBhc3NlZCBwcmVmZXJyZWRWaWRlb01pbWVUeXBlIChpZiBhbnkpIGR1cmluZyByZWNvcmRpbmcuXG4gICAgICAgIC8vIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBpdCwgd2UnbGwgZmFsbCBiYWNrIHRvIHRoZSBicm93c2VyIGRlZmF1bHQgaW5zdGVhZFxuICAgICAgICBpZiAocHJlZmVycmVkVmlkZW9NaW1lVHlwZSAmJiBNZWRpYVJlY29yZGVyLmlzVHlwZVN1cHBvcnRlZChwcmVmZXJyZWRWaWRlb01pbWVUeXBlKSAmJiBnZXRGaWxlVHlwZUV4dGVuc2lvbihwcmVmZXJyZWRWaWRlb01pbWVUeXBlKSkge1xuICAgICAgICAgIG9wdGlvbnMubWltZVR5cGUgPSBwcmVmZXJyZWRWaWRlb01pbWVUeXBlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmVwYXJlIHRyYWNrc1xuICAgICAgICBjb25zdCB0cmFja3MgPSBbdmlkZW9TdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXV1cblxuICAgICAgICAvLyBtZXJnZSBhdWRpbyBpZiBleGl0c1xuICAgICAgICBpZiAodGhpcy5hdWRpb1N0cmVhbSkge1xuICAgICAgICAgIHRyYWNrcy5wdXNoKHRoaXMuYXVkaW9TdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgc3RyZWFtIGZyb20gdmlkZW8gYW5kIGF1ZGlvXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgICAgIHRoaXMub3V0cHV0U3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKHRyYWNrcylcblxuICAgICAgICAvLyBpbml0aWFsaXplIG1lZGlhcmVjb3JkZXJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICAgICAgdGhpcy5yZWNvcmRlciA9IG5ldyBNZWRpYVJlY29yZGVyKHRoaXMub3V0cHV0U3RyZWFtLCBvcHRpb25zKVxuXG4gICAgICAgIC8vIHB1c2ggZGF0YSB0byBidWZmZXIgd2hlbiBkYXRhIGF2YWlsYWJsZVxuICAgICAgICB0aGlzLnJlY29yZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2RhdGFhdmFpbGFibGUnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICB0aGlzLnJlY29yZGluZ0NodW5rcy5wdXNoKGV2ZW50LmRhdGEpXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gc3RhcnQgcmVjb3JkaW5nXG4gICAgICAgIHRoaXMucmVjb3JkZXIuc3RhcnQoKVxuXG4gICAgICAgIC8vIHNldCBwbHVnaW4gc3RhdGUgdG8gcmVjb3JkaW5nXG4gICAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICAgIHJlY29yZGluZzogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKGVyciwgJ2Vycm9yJylcbiAgICAgIH0pXG4gIH1cblxuICBzdHJlYW1JbmFjdGl2YXRlZCAoKSB7XG4gICAgLy8gZ2V0IHNjcmVlbiByZWNvcmRlciBzdGF0ZVxuICAgIGNvbnN0IHsgcmVjb3JkZWRWaWRlbywgcmVjb3JkaW5nIH0gPSB7IC4uLnRoaXMuZ2V0UGx1Z2luU3RhdGUoKSB9XG5cbiAgICBpZiAoIXJlY29yZGVkVmlkZW8gJiYgIXJlY29yZGluZykge1xuICAgICAgLy8gQ2xvc2UgdGhlIERhc2hib2FyZCBwYW5lbCBpZiBwbHVnaW4gaXMgaW5zdGFsbGVkXG4gICAgICAvLyBpbnRvIERhc2hib2FyZCAoY291bGQgYmUgb3RoZXIgcGFyZW50IFVJIHBsdWdpbilcbiAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5oaWRlQWxsUGFuZWxzKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmhpZGVBbGxQYW5lbHMoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVjb3JkaW5nKSB7XG4gICAgICAvLyBzdG9wIHJlY29yZGVyIGlmIGl0IGlzIGFjdGl2ZVxuICAgICAgdGhpcy51cHB5LmxvZygnQ2FwdHVyZSBzdHJlYW0gaW5hY3RpdmUg4oCUIHN0b3AgcmVjb3JkaW5nJylcbiAgICAgIHRoaXMuc3RvcFJlY29yZGluZygpXG4gICAgfVxuXG4gICAgdGhpcy52aWRlb1N0cmVhbSA9IG51bGxcbiAgICB0aGlzLmF1ZGlvU3RyZWFtID0gbnVsbFxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBzdHJlYW1BY3RpdmU6IGZhbHNlLCBhdWRpb1N0cmVhbUFjdGl2ZTogZmFsc2UsXG4gICAgfSlcbiAgfVxuXG4gIHN0b3BSZWNvcmRpbmcgKCkge1xuICAgIGNvbnN0IHN0b3BwZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlY29yZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3AnLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcblxuICAgICAgdGhpcy5yZWNvcmRlci5zdG9wKClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHN0b3BwZWQudGhlbigoKSA9PiB7XG4gICAgICAvLyByZWNvcmRpbmcgc3RvcHBlZFxuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIHJlY29yZGluZzogZmFsc2UsXG4gICAgICB9KVxuICAgICAgLy8gZ2V0IHZpZGVvIGZpbGUgYWZ0ZXIgcmVjb3JkZXIgc3RvcHBlZFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmlkZW8oKVxuICAgIH0pLnRoZW4oKGZpbGUpID0+IHtcbiAgICAgIC8vIHN0b3JlIG1lZGlhIGZpbGVcbiAgICAgIHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUgPSBmaWxlXG5cbiAgICAgIC8vIGNyZWF0ZSBvYmplY3QgdXJsIGZvciBjYXB0dXJlIHJlc3VsdCBwcmV2aWV3XG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICAgICAgcmVjb3JkZWRWaWRlbzogVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlLmRhdGEpLFxuICAgICAgfSlcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMucmVjb3JkaW5nQ2h1bmtzID0gbnVsbFxuICAgICAgdGhpcy5yZWNvcmRlciA9IG51bGxcbiAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMucmVjb3JkaW5nQ2h1bmtzID0gbnVsbFxuICAgICAgdGhpcy5yZWNvcmRlciA9IG51bGxcbiAgICAgIHRocm93IGVycm9yXG4gICAgfSlcbiAgfVxuXG4gIHN1Ym1pdCAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGFkZCByZWNvcmRlZCBmaWxlIHRvIHVwcHlcbiAgICAgIGlmICh0aGlzLmNhcHR1cmVkTWVkaWFGaWxlKSB7XG4gICAgICAgIHRoaXMudXBweS5hZGRGaWxlKHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBMb2dnaW5nIHRoZSBlcnJvciwgZXhlcHQgcmVzdHJpY3Rpb25zLCB3aGljaCBpcyBoYW5kbGVkIGluIENvcmVcbiAgICAgIGlmICghZXJyLmlzUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgdGhpcy51cHB5LmxvZyhlcnIsICdlcnJvcicpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgLy8gZmx1c2ggdmlkZW8gc3RyZWFtXG4gICAgaWYgKHRoaXMudmlkZW9TdHJlYW0pIHtcbiAgICAgIHRoaXMudmlkZW9TdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5zdG9wKClcbiAgICAgIH0pXG4gICAgICB0aGlzLnZpZGVvU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgdHJhY2suc3RvcCgpXG4gICAgICB9KVxuICAgICAgdGhpcy52aWRlb1N0cmVhbSA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBmbHVzaCBhdWRpbyBzdHJlYW1cbiAgICBpZiAodGhpcy5hdWRpb1N0cmVhbSkge1xuICAgICAgdGhpcy5hdWRpb1N0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgIHRyYWNrLnN0b3AoKVxuICAgICAgfSlcbiAgICAgIHRoaXMuYXVkaW9TdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5zdG9wKClcbiAgICAgIH0pXG4gICAgICB0aGlzLmF1ZGlvU3RyZWFtID0gbnVsbFxuICAgIH1cblxuICAgIC8vIGZsdXNoIG91dHB1dCBzdHJlYW1cbiAgICBpZiAodGhpcy5vdXRwdXRTdHJlYW0pIHtcbiAgICAgIHRoaXMub3V0cHV0U3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgdHJhY2suc3RvcCgpXG4gICAgICB9KVxuICAgICAgdGhpcy5vdXRwdXRTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5zdG9wKClcbiAgICAgIH0pXG4gICAgICB0aGlzLm91dHB1dFN0cmVhbSA9IG51bGxcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgcHJldmlldyB2aWRlb1xuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgcmVjb3JkZWRWaWRlbzogbnVsbCxcbiAgICB9KVxuXG4gICAgdGhpcy5jYXB0dXJlQWN0aXZlID0gZmFsc2VcbiAgfVxuXG4gIGdldFZpZGVvICgpIHtcbiAgICBjb25zdCBtaW1lVHlwZSA9IHRoaXMucmVjb3JkaW5nQ2h1bmtzWzBdLnR5cGVcbiAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gZ2V0RmlsZVR5cGVFeHRlbnNpb24obWltZVR5cGUpXG5cbiAgICBpZiAoIWZpbGVFeHRlbnNpb24pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCByZXRyaWV2ZSByZWNvcmRpbmc6IFVuc3VwcG9ydGVkIG1lZGlhIHR5cGUgXCIke21pbWVUeXBlfVwiYCkpXG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IGBzY3JlZW5jYXAtJHtEYXRlLm5vdygpfS4ke2ZpbGVFeHRlbnNpb259YFxuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYih0aGlzLnJlY29yZGluZ0NodW5rcywgeyB0eXBlOiBtaW1lVHlwZSB9KVxuICAgIGNvbnN0IGZpbGUgPSB7XG4gICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICBuYW1lLFxuICAgICAgZGF0YTogbmV3IEJsb2IoW2Jsb2JdLCB7IHR5cGU6IG1pbWVUeXBlIH0pLFxuICAgICAgdHlwZTogbWltZVR5cGUsXG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmaWxlKVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIC8vIGdldCBzY3JlZW4gcmVjb3JkZXIgc3RhdGVcbiAgICBjb25zdCByZWNvcmRlclN0YXRlID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG5cbiAgICBpZiAoIXJlY29yZGVyU3RhdGUuc3RyZWFtQWN0aXZlICYmICF0aGlzLmNhcHR1cmVBY3RpdmUgJiYgIXRoaXMudXNlckRlbmllZCkge1xuICAgICAgdGhpcy5zdGFydCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxDYXB0dXJlU2NyZWVuXG4gICAgICAgIHsuLi5yZWNvcmRlclN0YXRlfVxuICAgICAgICBvblN0YXJ0UmVjb3JkaW5nPXt0aGlzLnN0YXJ0UmVjb3JkaW5nfVxuICAgICAgICBvblN0b3BSZWNvcmRpbmc9e3RoaXMuc3RvcFJlY29yZGluZ31cbiAgICAgICAgb25TdG9wPXt0aGlzLnN0b3B9XG4gICAgICAgIG9uU3VibWl0PXt0aGlzLnN1Ym1pdH1cbiAgICAgICAgaTE4bj17dGhpcy5pMThufVxuICAgICAgICBzdHJlYW09e3RoaXMudmlkZW9TdHJlYW19XG4gICAgICAvPlxuICAgIClcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9zdGF0dXMtYmFyXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIHByb2dyZXNzIGJhciBmb3IgVXBweSwgd2l0aCBtYW55IGJlbGxzIGFuZCB3aGlzdGxlcy5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS45LjZcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInN0eWxlXCI6IFwiZGlzdC9zdHlsZS5taW4uY3NzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcInByb2dyZXNzIGJhclwiLFxuICAgIFwic3RhdHVzIGJhclwiLFxuICAgIFwicHJvZ3Jlc3NcIixcbiAgICBcInVwbG9hZFwiLFxuICAgIFwiZXRhXCIsXG4gICAgXCJzcGVlZFwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHRyYW5zbG9hZGl0L3ByZXR0aWVyLWJ5dGVzXCI6IFwiMC4wLjdcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwiY2xhc3NuYW1lc1wiOiBcIl4yLjIuNlwiLFxuICAgIFwibG9kYXNoLnRocm90dGxlXCI6IFwiXjQuMS4xXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgdGhyb3R0bGUgPSByZXF1aXJlKCdsb2Rhc2gudGhyb3R0bGUnKVxuY29uc3QgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKVxuY29uc3Qgc3RhdHVzQmFyU3RhdGVzID0gcmVxdWlyZSgnLi9TdGF0dXNCYXJTdGF0ZXMnKVxuY29uc3QgcHJldHRpZXJCeXRlcyA9IHJlcXVpcmUoJ0B0cmFuc2xvYWRpdC9wcmV0dGllci1ieXRlcycpXG5jb25zdCBwcmV0dHlFVEEgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvcHJldHR5RVRBJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuZnVuY3Rpb24gY2FsY3VsYXRlUHJvY2Vzc2luZ1Byb2dyZXNzIChmaWxlcykge1xuICAvLyBDb2xsZWN0IHByZSBvciBwb3N0cHJvY2Vzc2luZyBwcm9ncmVzcyBzdGF0ZXMuXG4gIGNvbnN0IHByb2dyZXNzZXMgPSBbXVxuICBPYmplY3Qua2V5cyhmaWxlcykuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgY29uc3QgeyBwcm9ncmVzcyB9ID0gZmlsZXNbZmlsZUlEXVxuICAgIGlmIChwcm9ncmVzcy5wcmVwcm9jZXNzKSB7XG4gICAgICBwcm9ncmVzc2VzLnB1c2gocHJvZ3Jlc3MucHJlcHJvY2VzcylcbiAgICB9XG4gICAgaWYgKHByb2dyZXNzLnBvc3Rwcm9jZXNzKSB7XG4gICAgICBwcm9ncmVzc2VzLnB1c2gocHJvZ3Jlc3MucG9zdHByb2Nlc3MpXG4gICAgfVxuICB9KVxuXG4gIC8vIEluIHRoZSBmdXR1cmUgd2Ugc2hvdWxkIHByb2JhYmx5IGRvIHRoaXMgZGlmZmVyZW50bHkuIEZvciBub3cgd2UnbGwgdGFrZSB0aGVcbiAgLy8gbW9kZSBhbmQgbWVzc2FnZSBmcm9tIHRoZSBmaXJzdCBmaWxl4oCmXG4gIGNvbnN0IHsgbW9kZSwgbWVzc2FnZSB9ID0gcHJvZ3Jlc3Nlc1swXVxuICBjb25zdCB2YWx1ZSA9IHByb2dyZXNzZXMuZmlsdGVyKGlzRGV0ZXJtaW5hdGUpLnJlZHVjZSgodG90YWwsIHByb2dyZXNzLCBpbmRleCwgYWxsKSA9PiB7XG4gICAgcmV0dXJuIHRvdGFsICsgcHJvZ3Jlc3MudmFsdWUgLyBhbGwubGVuZ3RoXG4gIH0sIDApXG4gIGZ1bmN0aW9uIGlzRGV0ZXJtaW5hdGUgKHByb2dyZXNzKSB7XG4gICAgcmV0dXJuIHByb2dyZXNzLm1vZGUgPT09ICdkZXRlcm1pbmF0ZSdcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbW9kZSxcbiAgICBtZXNzYWdlLFxuICAgIHZhbHVlLFxuICB9XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZVBhdXNlUmVzdW1lIChwcm9wcykge1xuICBpZiAocHJvcHMuaXNBbGxDb21wbGV0ZSkgcmV0dXJuXG5cbiAgaWYgKCFwcm9wcy5yZXN1bWFibGVVcGxvYWRzKSB7XG4gICAgcmV0dXJuIHByb3BzLmNhbmNlbEFsbCgpXG4gIH1cblxuICBpZiAocHJvcHMuaXNBbGxQYXVzZWQpIHtcbiAgICByZXR1cm4gcHJvcHMucmVzdW1lQWxsKClcbiAgfVxuXG4gIHJldHVybiBwcm9wcy5wYXVzZUFsbCgpXG59XG5cbmZ1bmN0aW9uIFJlbmRlclJlU2VsZWN0R2hvc3RzICh7IGkxOG4gfSkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc2VydmljZU1zZ1wiPlxuICAgICAge2kxOG4oJ3JlU2VsZWN0R2hvc3RzJyl9XG4gICAgICA8c3ZnIGNsYXNzTmFtZT1cInVwcHktYy1pY29uIHVwcHktU3RhdHVzQmFyLXNlcnZpY2VNc2ctZ2hvc3RzSWNvblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHdpZHRoPVwiMTVcIiBoZWlnaHQ9XCIxOVwiIHZpZXdCb3g9XCIwIDAgMzUgMzlcIj5cbiAgICAgICAgPHBhdGggZD1cIk0xLjcwOCAzOC42NmMxLjcwOSAwIDMuNDE3LTMuNDE3IDYuODM0LTMuNDE3IDMuNDE2IDAgNS4xMjUgMy40MTcgOC42MSAzLjQxNyAzLjM0OCAwIDUuMDU2LTMuNDE3IDguNDczLTMuNDE3IDQuMzA1IDAgNS4xMjUgMy40MTcgNi44MzMgMy40MTcuODg5IDAgMS43MDktLjg4OSAxLjcwOS0xLjcwOXYtMTkuNjhDMzQuMTY3LTUuNzU3IDAtNS43NTcgMCAxNy4yNzF2MTkuNjhjMCAuODIuODg4IDEuNzA5IDEuNzA4IDEuNzA5em04LjU0Mi0xNy4wODRhMy4zODMgMy4zODMgMCAwMS0zLjQxNy0zLjQxNiAzLjM4MyAzLjM4MyAwIDAxMy40MTctMy40MTcgMy4zODMgMy4zODMgMCAwMTMuNDE3IDMuNDE3IDMuMzgzIDMuMzgzIDAgMDEtMy40MTcgMy40MTZ6bTEzLjY2NyAwQTMuMzgzIDMuMzgzIDAgMDEyMC41IDE4LjE2YTMuMzgzIDMuMzgzIDAgMDEzLjQxNy0zLjQxNyAzLjM4MyAzLjM4MyAwIDAxMy40MTYgMy40MTcgMy4zODMgMy4zODMgMCAwMS0zLjQxNiAzLjQxNnpcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiAvPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcHJvcHMgPSBwcm9wcyB8fCB7fVxuXG4gIGNvbnN0IHtcbiAgICBuZXdGaWxlcyxcbiAgICBhbGxvd05ld1VwbG9hZCxcbiAgICBpc1VwbG9hZEluUHJvZ3Jlc3MsXG4gICAgaXNBbGxQYXVzZWQsXG4gICAgcmVzdW1hYmxlVXBsb2FkcyxcbiAgICBlcnJvcixcbiAgICBoaWRlVXBsb2FkQnV0dG9uLFxuICAgIGhpZGVQYXVzZVJlc3VtZUJ1dHRvbixcbiAgICBoaWRlQ2FuY2VsQnV0dG9uLFxuICAgIGhpZGVSZXRyeUJ1dHRvbixcbiAgICByZWNvdmVyZWRTdGF0ZSxcbiAgfSA9IHByb3BzXG5cbiAgY29uc3QgdXBsb2FkU3RhdGUgPSBwcm9wcy51cGxvYWRTdGF0ZVxuXG4gIGxldCBwcm9ncmVzc1ZhbHVlID0gcHJvcHMudG90YWxQcm9ncmVzc1xuICBsZXQgcHJvZ3Jlc3NNb2RlXG4gIGxldCBwcm9ncmVzc0JhckNvbnRlbnRcblxuICBpZiAodXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9QUkVQUk9DRVNTSU5HIHx8IHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfUE9TVFBST0NFU1NJTkcpIHtcbiAgICBjb25zdCBwcm9ncmVzcyA9IGNhbGN1bGF0ZVByb2Nlc3NpbmdQcm9ncmVzcyhwcm9wcy5maWxlcylcbiAgICBwcm9ncmVzc01vZGUgPSBwcm9ncmVzcy5tb2RlXG4gICAgaWYgKHByb2dyZXNzTW9kZSA9PT0gJ2RldGVybWluYXRlJykge1xuICAgICAgcHJvZ3Jlc3NWYWx1ZSA9IHByb2dyZXNzLnZhbHVlICogMTAwXG4gICAgfVxuXG4gICAgcHJvZ3Jlc3NCYXJDb250ZW50ID0gUHJvZ3Jlc3NCYXJQcm9jZXNzaW5nKHByb2dyZXNzKVxuICB9IGVsc2UgaWYgKHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfQ09NUExFVEUpIHtcbiAgICBwcm9ncmVzc0JhckNvbnRlbnQgPSBQcm9ncmVzc0JhckNvbXBsZXRlKHByb3BzKVxuICB9IGVsc2UgaWYgKHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfVVBMT0FESU5HKSB7XG4gICAgaWYgKCFwcm9wcy5zdXBwb3J0c1VwbG9hZFByb2dyZXNzKSB7XG4gICAgICBwcm9ncmVzc01vZGUgPSAnaW5kZXRlcm1pbmF0ZSdcbiAgICAgIHByb2dyZXNzVmFsdWUgPSBudWxsXG4gICAgfVxuXG4gICAgcHJvZ3Jlc3NCYXJDb250ZW50ID0gUHJvZ3Jlc3NCYXJVcGxvYWRpbmcocHJvcHMpXG4gIH0gZWxzZSBpZiAodXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9FUlJPUikge1xuICAgIHByb2dyZXNzVmFsdWUgPSB1bmRlZmluZWRcbiAgICBwcm9ncmVzc0JhckNvbnRlbnQgPSBQcm9ncmVzc0JhckVycm9yKHByb3BzKVxuICB9XG5cbiAgY29uc3Qgd2lkdGggPSB0eXBlb2YgcHJvZ3Jlc3NWYWx1ZSA9PT0gJ251bWJlcicgPyBwcm9ncmVzc1ZhbHVlIDogMTAwXG4gIGxldCBpc0hpZGRlbiA9ICh1cGxvYWRTdGF0ZSA9PT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1dBSVRJTkcgJiYgcHJvcHMuaGlkZVVwbG9hZEJ1dHRvbilcbiAgICB8fCAodXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9XQUlUSU5HICYmICFwcm9wcy5uZXdGaWxlcyA+IDApXG4gICAgfHwgKHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfQ09NUExFVEUgJiYgcHJvcHMuaGlkZUFmdGVyRmluaXNoKVxuXG4gIGxldCBzaG93VXBsb2FkQnRuID0gIWVycm9yICYmIG5ld0ZpbGVzXG4gICAgJiYgIWlzVXBsb2FkSW5Qcm9ncmVzcyAmJiAhaXNBbGxQYXVzZWRcbiAgICAmJiBhbGxvd05ld1VwbG9hZCAmJiAhaGlkZVVwbG9hZEJ1dHRvblxuXG4gIGlmIChyZWNvdmVyZWRTdGF0ZSkge1xuICAgIGlzSGlkZGVuID0gZmFsc2VcbiAgICBzaG93VXBsb2FkQnRuID0gdHJ1ZVxuICB9XG5cbiAgY29uc3Qgc2hvd0NhbmNlbEJ0biA9ICFoaWRlQ2FuY2VsQnV0dG9uXG4gICAgJiYgdXBsb2FkU3RhdGUgIT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9XQUlUSU5HXG4gICAgJiYgdXBsb2FkU3RhdGUgIT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9DT01QTEVURVxuICBjb25zdCBzaG93UGF1c2VSZXN1bWVCdG4gPSByZXN1bWFibGVVcGxvYWRzICYmICFoaWRlUGF1c2VSZXN1bWVCdXR0b25cbiAgICAmJiB1cGxvYWRTdGF0ZSA9PT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1VQTE9BRElOR1xuXG4gIGNvbnN0IHNob3dSZXRyeUJ0biA9IGVycm9yICYmICFoaWRlUmV0cnlCdXR0b25cblxuICBjb25zdCBzaG93RG9uZUJ0biA9IHByb3BzLmRvbmVCdXR0b25IYW5kbGVyICYmIHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfQ09NUExFVEVcblxuICBjb25zdCBwcm9ncmVzc0NsYXNzTmFtZXMgPSBgdXBweS1TdGF0dXNCYXItcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICR7cHJvZ3Jlc3NNb2RlID8gYGlzLSR7cHJvZ3Jlc3NNb2RlfWAgOiAnJ31gXG5cbiAgY29uc3Qgc3RhdHVzQmFyQ2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMoXG4gICAgeyAndXBweS1Sb290JzogcHJvcHMuaXNUYXJnZXRET01FbCB9LFxuICAgICd1cHB5LVN0YXR1c0JhcicsXG4gICAgYGlzLSR7dXBsb2FkU3RhdGV9YCxcbiAgICB7ICdoYXMtZ2hvc3RzJzogcHJvcHMuaXNTb21lR2hvc3QgfVxuICApXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3RhdHVzQmFyQ2xhc3NOYW1lc30gYXJpYS1oaWRkZW49e2lzSGlkZGVufT5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtwcm9ncmVzc0NsYXNzTmFtZXN9XG4gICAgICAgIHN0eWxlPXt7IHdpZHRoOiBgJHt3aWR0aH0lYCB9fVxuICAgICAgICByb2xlPVwicHJvZ3Jlc3NiYXJcIlxuICAgICAgICBhcmlhLXZhbHVlbWluPVwiMFwiXG4gICAgICAgIGFyaWEtdmFsdWVtYXg9XCIxMDBcIlxuICAgICAgICBhcmlhLXZhbHVlbm93PXtwcm9ncmVzc1ZhbHVlfVxuICAgICAgLz5cbiAgICAgIHtwcm9ncmVzc0JhckNvbnRlbnR9XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLWFjdGlvbnNcIj5cbiAgICAgICAge3Nob3dVcGxvYWRCdG4gPyA8VXBsb2FkQnRuIHsuLi5wcm9wc30gdXBsb2FkU3RhdGU9e3VwbG9hZFN0YXRlfSAvPiA6IG51bGx9XG4gICAgICAgIHtzaG93UmV0cnlCdG4gPyA8UmV0cnlCdG4gey4uLnByb3BzfSAvPiA6IG51bGx9XG4gICAgICAgIHtzaG93UGF1c2VSZXN1bWVCdG4gPyA8UGF1c2VSZXN1bWVCdXR0b24gey4uLnByb3BzfSAvPiA6IG51bGx9XG4gICAgICAgIHtzaG93Q2FuY2VsQnRuID8gPENhbmNlbEJ0biB7Li4ucHJvcHN9IC8+IDogbnVsbH1cbiAgICAgICAge3Nob3dEb25lQnRuID8gPERvbmVCdG4gey4uLnByb3BzfSAvPiA6IG51bGx9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5jb25zdCBVcGxvYWRCdG4gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdXBsb2FkQnRuQ2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMoXG4gICAgJ3VwcHktdS1yZXNldCcsXG4gICAgJ3VwcHktYy1idG4nLFxuICAgICd1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4nLFxuICAgICd1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4tLXVwbG9hZCcsXG4gICAgeyAndXBweS1jLWJ0bi1wcmltYXJ5JzogcHJvcHMudXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9XQUlUSU5HIH0sXG4gICAgeyAndXBweS1TdGF0dXNCYXItYWN0aW9uQnRuLS1kaXNhYmxlZCc6IHByb3BzLmlzU29tZUdob3N0IH1cbiAgKVxuXG4gIGNvbnN0IHVwbG9hZEJ0blRleHQgPSBwcm9wcy5uZXdGaWxlcyAmJiBwcm9wcy5pc1VwbG9hZFN0YXJ0ZWQgJiYgIXByb3BzLnJlY292ZXJlZFN0YXRlXG4gICAgPyBwcm9wcy5pMThuKCd1cGxvYWRYTmV3RmlsZXMnLCB7IHNtYXJ0X2NvdW50OiBwcm9wcy5uZXdGaWxlcyB9KVxuICAgIDogcHJvcHMuaTE4bigndXBsb2FkWEZpbGVzJywgeyBzbWFydF9jb3VudDogcHJvcHMubmV3RmlsZXMgfSlcblxuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgY2xhc3NOYW1lPXt1cGxvYWRCdG5DbGFzc05hbWVzfVxuICAgICAgYXJpYS1sYWJlbD17cHJvcHMuaTE4bigndXBsb2FkWEZpbGVzJywgeyBzbWFydF9jb3VudDogcHJvcHMubmV3RmlsZXMgfSl9XG4gICAgICBvbkNsaWNrPXtwcm9wcy5zdGFydFVwbG9hZH1cbiAgICAgIGRpc2FibGVkPXtwcm9wcy5pc1NvbWVHaG9zdH1cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICB7dXBsb2FkQnRuVGV4dH1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5jb25zdCBSZXRyeUJ0biA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1TdGF0dXNCYXItYWN0aW9uQnRuIHVwcHktU3RhdHVzQmFyLWFjdGlvbkJ0bi0tcmV0cnlcIlxuICAgICAgYXJpYS1sYWJlbD17cHJvcHMuaTE4bigncmV0cnlVcGxvYWQnKX1cbiAgICAgIG9uQ2xpY2s9e3Byb3BzLnJldHJ5QWxsfVxuICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgID5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiOFwiIGhlaWdodD1cIjEwXCIgdmlld0JveD1cIjAgMCA4IDEwXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNNCAyLjQwOGEyLjc1IDIuNzUgMCAxIDAgMi43NSAyLjc1LjYyNi42MjYgMCAwIDEgMS4yNS4wMTh2LjAyM2E0IDQgMCAxIDEtNC00LjA0MVYuMjVhLjI1LjI1IDAgMCAxIC4zODktLjIwOGwyLjI5OSAxLjUzM2EuMjUuMjUgMCAwIDEgMCAuNDE2bC0yLjMgMS41MzNBLjI1LjI1IDAgMCAxIDQgMy4zMTZ2LS45MDh6XCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgICAge3Byb3BzLmkxOG4oJ3JldHJ5Jyl9XG4gICAgPC9idXR0b24+XG4gIClcbn1cblxuY29uc3QgQ2FuY2VsQnRuID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1TdGF0dXNCYXItYWN0aW9uQ2lyY2xlQnRuXCJcbiAgICAgIHRpdGxlPXtwcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ2NhbmNlbCcpfVxuICAgICAgb25DbGljaz17cHJvcHMuY2FuY2VsQWxsfVxuICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgID5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIj5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICA8Y2lyY2xlIGZpbGw9XCIjODg4XCIgY3g9XCI4XCIgY3k9XCI4XCIgcj1cIjhcIiAvPlxuICAgICAgICAgIDxwYXRoIGZpbGw9XCIjRkZGXCIgZD1cIk05LjI4MyA4bDIuNTY3IDIuNTY3LTEuMjgzIDEuMjgzTDggOS4yODMgNS40MzMgMTEuODUgNC4xNSAxMC41NjcgNi43MTcgOCA0LjE1IDUuNDMzIDUuNDMzIDQuMTUgOCA2LjcxN2wyLjU2Ny0yLjU2NyAxLjI4MyAxLjI4M3pcIiAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L3N2Zz5cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5jb25zdCBQYXVzZVJlc3VtZUJ1dHRvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGlzQWxsUGF1c2VkLCBpMThuIH0gPSBwcm9wc1xuICBjb25zdCB0aXRsZSA9IGlzQWxsUGF1c2VkID8gaTE4bigncmVzdW1lJykgOiBpMThuKCdwYXVzZScpXG5cbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICB0aXRsZT17dGl0bGV9XG4gICAgICBhcmlhLWxhYmVsPXt0aXRsZX1cbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LVN0YXR1c0Jhci1hY3Rpb25DaXJjbGVCdG5cIlxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBvbkNsaWNrPXsoKSA9PiB0b2dnbGVQYXVzZVJlc3VtZShwcm9wcyl9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAge2lzQWxsUGF1c2VkID8gKFxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1jLWljb25cIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+XG4gICAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICAgIDxjaXJjbGUgZmlsbD1cIiM4ODhcIiBjeD1cIjhcIiBjeT1cIjhcIiByPVwiOFwiIC8+XG4gICAgICAgICAgICA8cGF0aCBmaWxsPVwiI0ZGRlwiIGQ9XCJNNiA0LjI1TDExLjUgOCA2IDExLjc1elwiIC8+XG4gICAgICAgICAgPC9nPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICkgOiAoXG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIj5cbiAgICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgICAgPGNpcmNsZSBmaWxsPVwiIzg4OFwiIGN4PVwiOFwiIGN5PVwiOFwiIHI9XCI4XCIgLz5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNNSA0LjVoMnY3SDV2LTd6bTQgMGgydjdIOXYtN3pcIiBmaWxsPVwiI0ZGRlwiIC8+XG4gICAgICAgICAgPC9nPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICl9XG4gICAgPC9idXR0b24+XG4gIClcbn1cblxuY29uc3QgRG9uZUJ0biA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGkxOG4gfSA9IHByb3BzXG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4gdXBweS1TdGF0dXNCYXItYWN0aW9uQnRuLS1kb25lXCJcbiAgICAgIG9uQ2xpY2s9e3Byb3BzLmRvbmVCdXR0b25IYW5kbGVyfVxuICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgID5cbiAgICAgIHtpMThuKCdkb25lJyl9XG4gICAgPC9idXR0b24+XG4gIClcbn1cblxuY29uc3QgTG9hZGluZ1NwaW5uZXIgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zcGlubmVyXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMTMuOTgzIDYuNTQ3Yy0uMTItMi41MDktMS42NC00Ljg5My0zLjkzOS01LjkzNi0yLjQ4LTEuMTI3LTUuNDg4LS42NTYtNy41NTYgMS4wOTRDLjUyNCAzLjM2Ny0uMzk4IDYuMDQ4LjE2MiA4LjU2MmMuNTU2IDIuNDk1IDIuNDYgNC41MiA0Ljk0IDUuMTgzIDIuOTMyLjc4NCA1LjYxLS42MDIgNy4yNTYtMy4wMTUtMS40OTMgMS45OTMtMy43NDUgMy4zMDktNi4yOTggMi44NjgtMi41MTQtLjQzNC00LjU3OC0yLjM0OS01LjE1My00Ljg0YTYuMjI2IDYuMjI2IDAgMCAxIDIuOTgtNi43NzhDNi4zNC41ODYgOS43NCAxLjEgMTEuMzczIDMuNDkzYy40MDcuNTk2LjY5MyAxLjI4Mi44NDIgMS45ODguMTI3LjU5OC4wNzMgMS4xOTcuMTYxIDEuNzk0LjA3OC41MjUuNTQzIDEuMjU3IDEuMTUuODY0LjUyNS0uMzQxLjQ5LTEuMDUuNDU2LTEuNTkyLS4wMDctLjE1LjAyLjMgMCAwXCIgZmlsbFJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5jb25zdCBQcm9ncmVzc0JhclByb2Nlc3NpbmcgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdmFsdWUgPSBNYXRoLnJvdW5kKHByb3BzLnZhbHVlICogMTAwKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1jb250ZW50XCI+XG4gICAgICA8TG9hZGluZ1NwaW5uZXIgLz5cbiAgICAgIHtwcm9wcy5tb2RlID09PSAnZGV0ZXJtaW5hdGUnID8gYCR7dmFsdWV9JSBcXHUwMEI3IGAgOiAnJ31cbiAgICAgIHtwcm9wcy5tZXNzYWdlfVxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IHJlbmRlckRvdCA9ICgpID0+XG4gICcgXFx1MDBCNyAnXG5cbmNvbnN0IFByb2dyZXNzRGV0YWlscyA9IChwcm9wcykgPT4ge1xuICBjb25zdCBpZlNob3dGaWxlc1VwbG9hZGVkT2ZUb3RhbCA9IHByb3BzLm51bVVwbG9hZHMgPiAxXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1NlY29uZGFyeVwiPlxuICAgICAge1xuICAgICAgICBpZlNob3dGaWxlc1VwbG9hZGVkT2ZUb3RhbFxuICAgICAgICAmJiBwcm9wcy5pMThuKCdmaWxlc1VwbG9hZGVkT2ZUb3RhbCcsIHtcbiAgICAgICAgICBjb21wbGV0ZTogcHJvcHMuY29tcGxldGUsXG4gICAgICAgICAgc21hcnRfY291bnQ6IHByb3BzLm51bVVwbG9hZHMsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1hZGRpdGlvbmFsSW5mb1wiPlxuICAgICAgICB7LyogV2hlbiBzaG91bGQgd2UgcmVuZGVyIHRoaXMgZG90P1xuICAgICAgICAgIDEuIC4tYWRkaXRpb25hbEluZm8gaXMgc2hvd24gKGhhcHBlbnMgb25seSBvbiBkZXNrdG9wcylcbiAgICAgICAgICAyLiBBTkQgJ2ZpbGVzVXBsb2FkZWRPZlRvdGFsJyB3YXMgc2hvd25cbiAgICAgICAgKi99XG4gICAgICAgIHtpZlNob3dGaWxlc1VwbG9hZGVkT2ZUb3RhbCAmJiByZW5kZXJEb3QoKX1cblxuICAgICAgICB7XG4gICAgICAgICAgcHJvcHMuaTE4bignZGF0YVVwbG9hZGVkT2ZUb3RhbCcsIHtcbiAgICAgICAgICAgIGNvbXBsZXRlOiBwcmV0dGllckJ5dGVzKHByb3BzLnRvdGFsVXBsb2FkZWRTaXplKSxcbiAgICAgICAgICAgIHRvdGFsOiBwcmV0dGllckJ5dGVzKHByb3BzLnRvdGFsU2l6ZSksXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHtyZW5kZXJEb3QoKX1cblxuICAgICAgICB7XG4gICAgICAgICAgcHJvcHMuaTE4bigneFRpbWVMZWZ0Jywge1xuICAgICAgICAgICAgdGltZTogcHJldHR5RVRBKHByb3BzLnRvdGFsRVRBKSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICA8L3NwYW4+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuY29uc3QgVW5rbm93blByb2dyZXNzRGV0YWlscyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3RhdHVzU2Vjb25kYXJ5XCI+XG4gICAgICB7cHJvcHMuaTE4bignZmlsZXNVcGxvYWRlZE9mVG90YWwnLCB7IGNvbXBsZXRlOiBwcm9wcy5jb21wbGV0ZSwgc21hcnRfY291bnQ6IHByb3BzLm51bVVwbG9hZHMgfSl9XG4gICAgPC9kaXY+XG4gIClcbn1cblxuY29uc3QgVXBsb2FkTmV3bHlBZGRlZEZpbGVzID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHVwbG9hZEJ0bkNsYXNzTmFtZXMgPSBjbGFzc05hbWVzKFxuICAgICd1cHB5LXUtcmVzZXQnLFxuICAgICd1cHB5LWMtYnRuJyxcbiAgICAndXBweS1TdGF0dXNCYXItYWN0aW9uQnRuJyxcbiAgICAndXBweS1TdGF0dXNCYXItYWN0aW9uQnRuLS11cGxvYWROZXdseUFkZGVkJ1xuICApXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1NlY29uZGFyeVwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNTZWNvbmRhcnlIaW50XCI+XG4gICAgICAgIHtwcm9wcy5pMThuKCd4TW9yZUZpbGVzQWRkZWQnLCB7IHNtYXJ0X2NvdW50OiBwcm9wcy5uZXdGaWxlcyB9KX1cbiAgICAgIDwvZGl2PlxuICAgICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3NOYW1lPXt1cGxvYWRCdG5DbGFzc05hbWVzfVxuICAgICAgICBhcmlhLWxhYmVsPXtwcm9wcy5pMThuKCd1cGxvYWRYRmlsZXMnLCB7IHNtYXJ0X2NvdW50OiBwcm9wcy5uZXdGaWxlcyB9KX1cbiAgICAgICAgb25DbGljaz17cHJvcHMuc3RhcnRVcGxvYWR9XG4gICAgICA+XG4gICAgICAgIHtwcm9wcy5pMThuKCd1cGxvYWQnKX1cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IFRocm90dGxlZFByb2dyZXNzRGV0YWlscyA9IHRocm90dGxlKFByb2dyZXNzRGV0YWlscywgNTAwLCB7IGxlYWRpbmc6IHRydWUsIHRyYWlsaW5nOiB0cnVlIH0pXG5cbmNvbnN0IFByb2dyZXNzQmFyVXBsb2FkaW5nID0gKHByb3BzKSA9PiB7XG4gIGlmICghcHJvcHMuaXNVcGxvYWRTdGFydGVkIHx8IHByb3BzLmlzQWxsQ29tcGxldGUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgdGl0bGUgPSBwcm9wcy5pc0FsbFBhdXNlZCA/IHByb3BzLmkxOG4oJ3BhdXNlZCcpIDogcHJvcHMuaTE4bigndXBsb2FkaW5nJylcbiAgY29uc3Qgc2hvd1VwbG9hZE5ld2x5QWRkZWRGaWxlcyA9IHByb3BzLm5ld0ZpbGVzICYmIHByb3BzLmlzVXBsb2FkU3RhcnRlZFxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1jb250ZW50XCIgYXJpYS1sYWJlbD17dGl0bGV9IHRpdGxlPXt0aXRsZX0+XG4gICAgICB7IXByb3BzLmlzQWxsUGF1c2VkID8gPExvYWRpbmdTcGlubmVyIC8+IDogbnVsbH1cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3RhdHVzXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3RhdHVzUHJpbWFyeVwiPlxuICAgICAgICAgIHtwcm9wcy5zdXBwb3J0c1VwbG9hZFByb2dyZXNzID8gYCR7dGl0bGV9OiAke3Byb3BzLnRvdGFsUHJvZ3Jlc3N9JWAgOiB0aXRsZX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIHshcHJvcHMuaXNBbGxQYXVzZWQgJiYgIXNob3dVcGxvYWROZXdseUFkZGVkRmlsZXMgJiYgcHJvcHMuc2hvd1Byb2dyZXNzRGV0YWlsc1xuICAgICAgICAgID8gKHByb3BzLnN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MgPyA8VGhyb3R0bGVkUHJvZ3Jlc3NEZXRhaWxzIHsuLi5wcm9wc30gLz4gOiA8VW5rbm93blByb2dyZXNzRGV0YWlscyB7Li4ucHJvcHN9IC8+KVxuICAgICAgICAgIDogbnVsbH1cbiAgICAgICAge3Nob3dVcGxvYWROZXdseUFkZGVkRmlsZXMgPyA8VXBsb2FkTmV3bHlBZGRlZEZpbGVzIHsuLi5wcm9wc30gLz4gOiBudWxsfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuY29uc3QgUHJvZ3Jlc3NCYXJDb21wbGV0ZSA9ICh7IHRvdGFsUHJvZ3Jlc3MsIGkxOG4gfSkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItY29udGVudFwiIHJvbGU9XCJzdGF0dXNcIiB0aXRsZT17aTE4bignY29tcGxldGUnKX0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1wiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1ByaW1hcnlcIj5cbiAgICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3RhdHVzSW5kaWNhdG9yIHVwcHktYy1pY29uXCIgd2lkdGg9XCIxNVwiIGhlaWdodD1cIjExXCIgdmlld0JveD1cIjAgMCAxNSAxMVwiPlxuICAgICAgICAgICAgPHBhdGggZD1cIk0uNDE0IDUuODQzTDEuNjI3IDQuNjNsMy40NzIgMy40NzJMMTMuMjAyIDBsMS4yMTIgMS4yMTNMNS4xIDEwLjUyOHpcIiAvPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIHtpMThuKCdjb21wbGV0ZScpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IFByb2dyZXNzQmFyRXJyb3IgPSAoeyBlcnJvciwgcmV0cnlBbGwsIGhpZGVSZXRyeUJ1dHRvbiwgaTE4biB9KSA9PiB7XG4gIGZ1bmN0aW9uIGRpc3BsYXlFcnJvckFsZXJ0ICgpIHtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgJHtpMThuKCd1cGxvYWRGYWlsZWQnKX0gXFxuXFxuICR7ZXJyb3J9YFxuICAgIGFsZXJ0KGVycm9yTWVzc2FnZSlcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1jb250ZW50XCIgcm9sZT1cImFsZXJ0XCIgdGl0bGU9e2kxOG4oJ3VwbG9hZEZhaWxlZCcpfT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3RhdHVzXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItc3RhdHVzUHJpbWFyeVwiPlxuICAgICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNJbmRpY2F0b3IgdXBweS1jLWljb25cIiB3aWR0aD1cIjExXCIgaGVpZ2h0PVwiMTFcIiB2aWV3Qm94PVwiMCAwIDExIDExXCI+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTQuMjc4IDUuNUwwIDEuMjIyIDEuMjIyIDAgNS41IDQuMjc4IDkuNzc4IDAgMTEgMS4yMjIgNi43MjIgNS41IDExIDkuNzc4IDkuNzc4IDExIDUuNSA2LjcyMiAxLjIyMiAxMSAwIDkuNzc4elwiIC8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgICAge2kxOG4oJ3VwbG9hZEZhaWxlZCcpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPHNwYW5cbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS1TdGF0dXNCYXItZGV0YWlsc1wiXG4gICAgICAgIGFyaWEtbGFiZWw9e2Vycm9yfVxuICAgICAgICBkYXRhLW1pY3JvdGlwLXBvc2l0aW9uPVwidG9wLXJpZ2h0XCJcbiAgICAgICAgZGF0YS1taWNyb3RpcC1zaXplPVwibWVkaXVtXCJcbiAgICAgICAgcm9sZT1cInRvb2x0aXBcIlxuICAgICAgICBvbkNsaWNrPXtkaXNwbGF5RXJyb3JBbGVydH1cbiAgICAgID5cbiAgICAgICAgP1xuICAgICAgPC9zcGFuPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgU1RBVEVfRVJST1I6ICdlcnJvcicsXG4gIFNUQVRFX1dBSVRJTkc6ICd3YWl0aW5nJyxcbiAgU1RBVEVfUFJFUFJPQ0VTU0lORzogJ3ByZXByb2Nlc3NpbmcnLFxuICBTVEFURV9VUExPQURJTkc6ICd1cGxvYWRpbmcnLFxuICBTVEFURV9QT1NUUFJPQ0VTU0lORzogJ3Bvc3Rwcm9jZXNzaW5nJyxcbiAgU1RBVEVfQ09NUExFVEU6ICdjb21wbGV0ZScsXG59XG4iLCJjb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCBUcmFuc2xhdG9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL1RyYW5zbGF0b3InKVxuY29uc3QgU3RhdHVzQmFyVUkgPSByZXF1aXJlKCcuL1N0YXR1c0JhcicpXG5jb25zdCBzdGF0dXNCYXJTdGF0ZXMgPSByZXF1aXJlKCcuL1N0YXR1c0JhclN0YXRlcycpXG5jb25zdCBnZXRTcGVlZCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRTcGVlZCcpXG5jb25zdCBnZXRCeXRlc1JlbWFpbmluZyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRCeXRlc1JlbWFpbmluZycpXG5jb25zdCBnZXRUZXh0RGlyZWN0aW9uID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldFRleHREaXJlY3Rpb24nKVxuXG4vKipcbiAqIFN0YXR1c0JhcjogcmVuZGVycyBhIHN0YXR1cyBiYXIgd2l0aCB1cGxvYWQvcGF1c2UvcmVzdW1lL2NhbmNlbC9yZXRyeSBidXR0b25zLFxuICogcHJvZ3Jlc3MgcGVyY2VudGFnZSBhbmQgdGltZSByZW1haW5pbmcuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU3RhdHVzQmFyIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1N0YXR1c0JhcidcbiAgICB0aGlzLnRpdGxlID0gJ1N0YXR1c0JhcidcbiAgICB0aGlzLnR5cGUgPSAncHJvZ3Jlc3NpbmRpY2F0b3InXG5cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSB7XG4gICAgICBzdHJpbmdzOiB7XG4gICAgICAgIHVwbG9hZGluZzogJ1VwbG9hZGluZycsXG4gICAgICAgIHVwbG9hZDogJ1VwbG9hZCcsXG4gICAgICAgIGNvbXBsZXRlOiAnQ29tcGxldGUnLFxuICAgICAgICB1cGxvYWRGYWlsZWQ6ICdVcGxvYWQgZmFpbGVkJyxcbiAgICAgICAgcGF1c2VkOiAnUGF1c2VkJyxcbiAgICAgICAgcmV0cnk6ICdSZXRyeScsXG4gICAgICAgIHJldHJ5VXBsb2FkOiAnUmV0cnkgdXBsb2FkJyxcbiAgICAgICAgY2FuY2VsOiAnQ2FuY2VsJyxcbiAgICAgICAgcGF1c2U6ICdQYXVzZScsXG4gICAgICAgIHJlc3VtZTogJ1Jlc3VtZScsXG4gICAgICAgIGRvbmU6ICdEb25lJyxcbiAgICAgICAgZmlsZXNVcGxvYWRlZE9mVG90YWw6IHtcbiAgICAgICAgICAwOiAnJXtjb21wbGV0ZX0gb2YgJXtzbWFydF9jb3VudH0gZmlsZSB1cGxvYWRlZCcsXG4gICAgICAgICAgMTogJyV7Y29tcGxldGV9IG9mICV7c21hcnRfY291bnR9IGZpbGVzIHVwbG9hZGVkJyxcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YVVwbG9hZGVkT2ZUb3RhbDogJyV7Y29tcGxldGV9IG9mICV7dG90YWx9JyxcbiAgICAgICAgeFRpbWVMZWZ0OiAnJXt0aW1lfSBsZWZ0JyxcbiAgICAgICAgdXBsb2FkWEZpbGVzOiB7XG4gICAgICAgICAgMDogJ1VwbG9hZCAle3NtYXJ0X2NvdW50fSBmaWxlJyxcbiAgICAgICAgICAxOiAnVXBsb2FkICV7c21hcnRfY291bnR9IGZpbGVzJyxcbiAgICAgICAgfSxcbiAgICAgICAgdXBsb2FkWE5ld0ZpbGVzOiB7XG4gICAgICAgICAgMDogJ1VwbG9hZCArJXtzbWFydF9jb3VudH0gZmlsZScsXG4gICAgICAgICAgMTogJ1VwbG9hZCArJXtzbWFydF9jb3VudH0gZmlsZXMnLFxuICAgICAgICB9LFxuICAgICAgICB4TW9yZUZpbGVzQWRkZWQ6IHtcbiAgICAgICAgICAwOiAnJXtzbWFydF9jb3VudH0gbW9yZSBmaWxlIGFkZGVkJyxcbiAgICAgICAgICAxOiAnJXtzbWFydF9jb3VudH0gbW9yZSBmaWxlcyBhZGRlZCcsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHRhcmdldDogJ2JvZHknLFxuICAgICAgaGlkZVVwbG9hZEJ1dHRvbjogZmFsc2UsXG4gICAgICBoaWRlUmV0cnlCdXR0b246IGZhbHNlLFxuICAgICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uOiBmYWxzZSxcbiAgICAgIGhpZGVDYW5jZWxCdXR0b246IGZhbHNlLFxuICAgICAgc2hvd1Byb2dyZXNzRGV0YWlsczogZmFsc2UsXG4gICAgICBoaWRlQWZ0ZXJGaW5pc2g6IHRydWUsXG4gICAgICBkb25lQnV0dG9uSGFuZGxlcjogbnVsbCxcbiAgICB9XG5cbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5pbnN0YWxsID0gdGhpcy5pbnN0YWxsLmJpbmQodGhpcylcbiAgfVxuXG4gIHNldE9wdGlvbnMgKG5ld09wdHMpIHtcbiAgICBzdXBlci5zZXRPcHRpb25zKG5ld09wdHMpXG4gICAgdGhpcy5pMThuSW5pdCgpXG4gIH1cblxuICBpMThuSW5pdCAoKSB7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoW3RoaXMuZGVmYXVsdExvY2FsZSwgdGhpcy51cHB5LmxvY2FsZSwgdGhpcy5vcHRzLmxvY2FsZV0pXG4gICAgdGhpcy5pMThuID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKCkgLy8gc28gdGhhdCBVSSByZS1yZW5kZXJzIGFuZCB3ZSBzZWUgdGhlIHVwZGF0ZWQgbG9jYWxlXG4gIH1cblxuICBnZXRUb3RhbFNwZWVkIChmaWxlcykge1xuICAgIGxldCB0b3RhbFNwZWVkID0gMFxuICAgIGZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIHRvdGFsU3BlZWQgKz0gZ2V0U3BlZWQoZmlsZS5wcm9ncmVzcylcbiAgICB9KVxuICAgIHJldHVybiB0b3RhbFNwZWVkXG4gIH1cblxuICBnZXRUb3RhbEVUQSAoZmlsZXMpIHtcbiAgICBjb25zdCB0b3RhbFNwZWVkID0gdGhpcy5nZXRUb3RhbFNwZWVkKGZpbGVzKVxuICAgIGlmICh0b3RhbFNwZWVkID09PSAwKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGNvbnN0IHRvdGFsQnl0ZXNSZW1haW5pbmcgPSBmaWxlcy5yZWR1Y2UoKHRvdGFsLCBmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gdG90YWwgKyBnZXRCeXRlc1JlbWFpbmluZyhmaWxlLnByb2dyZXNzKVxuICAgIH0sIDApXG5cbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0b3RhbEJ5dGVzUmVtYWluaW5nIC8gdG90YWxTcGVlZCAqIDEwKSAvIDEwXG4gIH1cblxuICBzdGFydFVwbG9hZCA9ICgpID0+IHtcbiAgICBjb25zdCB7IHJlY292ZXJlZFN0YXRlIH0gPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuICAgIGlmIChyZWNvdmVyZWRTdGF0ZSkge1xuICAgICAgdGhpcy51cHB5LmVtaXQoJ3Jlc3RvcmUtY29uZmlybWVkJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICByZXR1cm4gdGhpcy51cHB5LnVwbG9hZCgpLmNhdGNoKCgpID0+IHtcbiAgICAgIC8vIEVycm9yIGxvZ2dlZCBpbiBDb3JlXG4gICAgfSlcbiAgfVxuXG4gIGdldFVwbG9hZGluZ1N0YXRlIChpc0FsbEVycm9yZWQsIGlzQWxsQ29tcGxldGUsIHJlY292ZXJlZFN0YXRlLCBmaWxlcykge1xuICAgIGlmIChpc0FsbEVycm9yZWQpIHtcbiAgICAgIHJldHVybiBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfRVJST1JcbiAgICB9XG5cbiAgICBpZiAoaXNBbGxDb21wbGV0ZSkge1xuICAgICAgcmV0dXJuIHN0YXR1c0JhclN0YXRlcy5TVEFURV9DT01QTEVURVxuICAgIH1cblxuICAgIGlmIChyZWNvdmVyZWRTdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXR1c0JhclN0YXRlcy5TVEFURV9XQUlUSU5HXG4gICAgfVxuXG4gICAgbGV0IHN0YXRlID0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1dBSVRJTkdcbiAgICBjb25zdCBmaWxlSURzID0gT2JqZWN0LmtleXMoZmlsZXMpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwcm9ncmVzcyA9IGZpbGVzW2ZpbGVJRHNbaV1dLnByb2dyZXNzXG4gICAgICAvLyBJZiBBTlkgZmlsZXMgYXJlIGJlaW5nIHVwbG9hZGVkIHJpZ2h0IG5vdywgc2hvdyB0aGUgdXBsb2FkaW5nIHN0YXRlLlxuICAgICAgaWYgKHByb2dyZXNzLnVwbG9hZFN0YXJ0ZWQgJiYgIXByb2dyZXNzLnVwbG9hZENvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfVVBMT0FESU5HXG4gICAgICB9XG4gICAgICAvLyBJZiBmaWxlcyBhcmUgYmVpbmcgcHJlcHJvY2Vzc2VkIEFORCBwb3N0cHJvY2Vzc2VkIGF0IHRoaXMgdGltZSwgd2Ugc2hvdyB0aGVcbiAgICAgIC8vIHByZXByb2Nlc3Mgc3RhdGUuIElmIGFueSBmaWxlcyBhcmUgYmVpbmcgdXBsb2FkZWQgd2Ugc2hvdyB1cGxvYWRpbmcuXG4gICAgICBpZiAocHJvZ3Jlc3MucHJlcHJvY2VzcyAmJiBzdGF0ZSAhPT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1VQTE9BRElORykge1xuICAgICAgICBzdGF0ZSA9IHN0YXR1c0JhclN0YXRlcy5TVEFURV9QUkVQUk9DRVNTSU5HXG4gICAgICB9XG4gICAgICAvLyBJZiBOTyBmaWxlcyBhcmUgYmVpbmcgcHJlcHJvY2Vzc2VkIG9yIHVwbG9hZGVkIHJpZ2h0IG5vdywgYnV0IHNvbWUgZmlsZXMgYXJlXG4gICAgICAvLyBiZWluZyBwb3N0cHJvY2Vzc2VkLCBzaG93IHRoZSBwb3N0cHJvY2VzcyBzdGF0ZS5cbiAgICAgIGlmIChwcm9ncmVzcy5wb3N0cHJvY2VzcyAmJiBzdGF0ZSAhPT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1VQTE9BRElORyAmJiBzdGF0ZSAhPT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1BSRVBST0NFU1NJTkcpIHtcbiAgICAgICAgc3RhdGUgPSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfUE9TVFBST0NFU1NJTkdcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2FwYWJpbGl0aWVzLFxuICAgICAgZmlsZXMsXG4gICAgICBhbGxvd05ld1VwbG9hZCxcbiAgICAgIHRvdGFsUHJvZ3Jlc3MsXG4gICAgICBlcnJvcixcbiAgICAgIHJlY292ZXJlZFN0YXRlLFxuICAgIH0gPSBzdGF0ZVxuXG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIHRvIENvcmUsIHRvIHNoYXJlIGJldHdlZW4gU3RhdHVzIEJhciBhbmQgRGFzaGJvYXJkXG4gICAgLy8gKGFuZCBhbnkgb3RoZXIgcGx1Z2luIHRoYXQgbWlnaHQgbmVlZCBpdCwgdG9vKVxuXG4gICAgY29uc3QgZmlsZXNBcnJheSA9IE9iamVjdC5rZXlzKGZpbGVzKS5tYXAoZmlsZSA9PiBmaWxlc1tmaWxlXSlcblxuICAgIGxldCBuZXdGaWxlcyA9IGZpbGVzQXJyYXkuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gIWZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZFxuICAgICAgICAmJiAhZmlsZS5wcm9ncmVzcy5wcmVwcm9jZXNzXG4gICAgICAgICYmICFmaWxlLnByb2dyZXNzLnBvc3Rwcm9jZXNzXG4gICAgfSlcblxuICAgIC8vIElmIHNvbWUgc3RhdGUgd2FzIHJlY292ZXJlZCwgd2Ugd2FudCB0byBzaG93IFVwbG9hZCBidXR0b24vY291bnRlclxuICAgIC8vIGZvciBhbGwgdGhlIGZpbGVzLCBiZWNhdXNlIGluIHRoaXMgY2FzZSBpdOKAmXMgbm90IGFuIFVwbG9hZCBidXR0b24sXG4gICAgLy8gYnV0IOKAnENvbmZpcm0gUmVzdG9yZSBCdXR0b27igJ1cbiAgICBpZiAocmVjb3ZlcmVkU3RhdGUpIHtcbiAgICAgIG5ld0ZpbGVzID0gZmlsZXNBcnJheVxuICAgIH1cblxuICAgIGNvbnN0IHVwbG9hZFN0YXJ0ZWRGaWxlcyA9IGZpbGVzQXJyYXkuZmlsdGVyKGZpbGUgPT4gZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkKVxuICAgIGNvbnN0IHBhdXNlZEZpbGVzID0gdXBsb2FkU3RhcnRlZEZpbGVzLmZpbHRlcihmaWxlID0+IGZpbGUuaXNQYXVzZWQpXG4gICAgY29uc3QgY29tcGxldGVGaWxlcyA9IGZpbGVzQXJyYXkuZmlsdGVyKGZpbGUgPT4gZmlsZS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZSlcbiAgICBjb25zdCBlcnJvcmVkRmlsZXMgPSBmaWxlc0FycmF5LmZpbHRlcihmaWxlID0+IGZpbGUuZXJyb3IpXG5cbiAgICBjb25zdCBpblByb2dyZXNzRmlsZXMgPSBmaWxlc0FycmF5LmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuICFmaWxlLnByb2dyZXNzLnVwbG9hZENvbXBsZXRlXG4gICAgICAgICAgICAgJiYgZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gICAgfSlcblxuICAgIGNvbnN0IGluUHJvZ3Jlc3NOb3RQYXVzZWRGaWxlcyA9IGluUHJvZ3Jlc3NGaWxlcy5maWx0ZXIoZmlsZSA9PiAhZmlsZS5pc1BhdXNlZClcblxuICAgIGNvbnN0IHN0YXJ0ZWRGaWxlcyA9IGZpbGVzQXJyYXkuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gICAgICAgIHx8IGZpbGUucHJvZ3Jlc3MucHJlcHJvY2Vzc1xuICAgICAgICB8fCBmaWxlLnByb2dyZXNzLnBvc3Rwcm9jZXNzXG4gICAgfSlcblxuICAgIGNvbnN0IHByb2Nlc3NpbmdGaWxlcyA9IGZpbGVzQXJyYXkuZmlsdGVyKGZpbGUgPT4gZmlsZS5wcm9ncmVzcy5wcmVwcm9jZXNzIHx8IGZpbGUucHJvZ3Jlc3MucG9zdHByb2Nlc3MpXG5cbiAgICBjb25zdCB0b3RhbEVUQSA9IHRoaXMuZ2V0VG90YWxFVEEoaW5Qcm9ncmVzc05vdFBhdXNlZEZpbGVzKVxuXG4gICAgbGV0IHRvdGFsU2l6ZSA9IDBcbiAgICBsZXQgdG90YWxVcGxvYWRlZFNpemUgPSAwXG4gICAgc3RhcnRlZEZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIHRvdGFsU2l6ZSArPSAoZmlsZS5wcm9ncmVzcy5ieXRlc1RvdGFsIHx8IDApXG4gICAgICB0b3RhbFVwbG9hZGVkU2l6ZSArPSAoZmlsZS5wcm9ncmVzcy5ieXRlc1VwbG9hZGVkIHx8IDApXG4gICAgfSlcblxuICAgIGNvbnN0IGlzVXBsb2FkU3RhcnRlZCA9IHN0YXJ0ZWRGaWxlcy5sZW5ndGggPiAwXG5cbiAgICBjb25zdCBpc0FsbENvbXBsZXRlID0gdG90YWxQcm9ncmVzcyA9PT0gMTAwXG4gICAgICAmJiBjb21wbGV0ZUZpbGVzLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMoZmlsZXMpLmxlbmd0aFxuICAgICAgJiYgcHJvY2Vzc2luZ0ZpbGVzLmxlbmd0aCA9PT0gMFxuXG4gICAgY29uc3QgaXNBbGxFcnJvcmVkID0gZXJyb3IgJiYgZXJyb3JlZEZpbGVzLmxlbmd0aCA9PT0gZmlsZXNBcnJheS5sZW5ndGhcblxuICAgIGNvbnN0IGlzQWxsUGF1c2VkID0gaW5Qcm9ncmVzc0ZpbGVzLmxlbmd0aCAhPT0gMFxuICAgICAgJiYgcGF1c2VkRmlsZXMubGVuZ3RoID09PSBpblByb2dyZXNzRmlsZXMubGVuZ3RoXG5cbiAgICBjb25zdCBpc1VwbG9hZEluUHJvZ3Jlc3MgPSBpblByb2dyZXNzRmlsZXMubGVuZ3RoID4gMFxuICAgIGNvbnN0IHJlc3VtYWJsZVVwbG9hZHMgPSBjYXBhYmlsaXRpZXMucmVzdW1hYmxlVXBsb2FkcyB8fCBmYWxzZVxuICAgIGNvbnN0IHN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MgPSBjYXBhYmlsaXRpZXMudXBsb2FkUHJvZ3Jlc3MgIT09IGZhbHNlXG4gICAgY29uc3QgaXNTb21lR2hvc3QgPSBmaWxlc0FycmF5LnNvbWUoKGZpbGUpID0+IGZpbGUuaXNHaG9zdClcblxuICAgIHJldHVybiBTdGF0dXNCYXJVSSh7XG4gICAgICBlcnJvcixcbiAgICAgIHVwbG9hZFN0YXRlOiB0aGlzLmdldFVwbG9hZGluZ1N0YXRlKGlzQWxsRXJyb3JlZCwgaXNBbGxDb21wbGV0ZSwgcmVjb3ZlcmVkU3RhdGUsIHN0YXRlLmZpbGVzIHx8IHt9KSxcbiAgICAgIGFsbG93TmV3VXBsb2FkLFxuICAgICAgdG90YWxQcm9ncmVzcyxcbiAgICAgIHRvdGFsU2l6ZSxcbiAgICAgIHRvdGFsVXBsb2FkZWRTaXplLFxuICAgICAgaXNBbGxDb21wbGV0ZSxcbiAgICAgIGlzQWxsUGF1c2VkLFxuICAgICAgaXNBbGxFcnJvcmVkLFxuICAgICAgaXNVcGxvYWRTdGFydGVkLFxuICAgICAgaXNVcGxvYWRJblByb2dyZXNzLFxuICAgICAgaXNTb21lR2hvc3QsXG4gICAgICByZWNvdmVyZWRTdGF0ZSxcbiAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZUZpbGVzLmxlbmd0aCxcbiAgICAgIG5ld0ZpbGVzOiBuZXdGaWxlcy5sZW5ndGgsXG4gICAgICBudW1VcGxvYWRzOiBzdGFydGVkRmlsZXMubGVuZ3RoLFxuICAgICAgdG90YWxFVEEsXG4gICAgICBmaWxlcyxcbiAgICAgIGkxOG46IHRoaXMuaTE4bixcbiAgICAgIHBhdXNlQWxsOiB0aGlzLnVwcHkucGF1c2VBbGwsXG4gICAgICByZXN1bWVBbGw6IHRoaXMudXBweS5yZXN1bWVBbGwsXG4gICAgICByZXRyeUFsbDogdGhpcy51cHB5LnJldHJ5QWxsLFxuICAgICAgY2FuY2VsQWxsOiB0aGlzLnVwcHkuY2FuY2VsQWxsLFxuICAgICAgc3RhcnRVcGxvYWQ6IHRoaXMuc3RhcnRVcGxvYWQsXG4gICAgICBkb25lQnV0dG9uSGFuZGxlcjogdGhpcy5vcHRzLmRvbmVCdXR0b25IYW5kbGVyLFxuICAgICAgcmVzdW1hYmxlVXBsb2FkcyxcbiAgICAgIHN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MsXG4gICAgICBzaG93UHJvZ3Jlc3NEZXRhaWxzOiB0aGlzLm9wdHMuc2hvd1Byb2dyZXNzRGV0YWlscyxcbiAgICAgIGhpZGVVcGxvYWRCdXR0b246IHRoaXMub3B0cy5oaWRlVXBsb2FkQnV0dG9uLFxuICAgICAgaGlkZVJldHJ5QnV0dG9uOiB0aGlzLm9wdHMuaGlkZVJldHJ5QnV0dG9uLFxuICAgICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uOiB0aGlzLm9wdHMuaGlkZVBhdXNlUmVzdW1lQnV0dG9uLFxuICAgICAgaGlkZUNhbmNlbEJ1dHRvbjogdGhpcy5vcHRzLmhpZGVDYW5jZWxCdXR0b24sXG4gICAgICBoaWRlQWZ0ZXJGaW5pc2g6IHRoaXMub3B0cy5oaWRlQWZ0ZXJGaW5pc2gsXG4gICAgICBpc1RhcmdldERPTUVsOiB0aGlzLmlzVGFyZ2V0RE9NRWwsXG4gICAgfSlcbiAgfVxuXG4gIG9uTW91bnQgKCkge1xuICAgIC8vIFNldCB0aGUgdGV4dCBkaXJlY3Rpb24gaWYgdGhlIHBhZ2UgaGFzIG5vdCBkZWZpbmVkIG9uZS5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbFxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGdldFRleHREaXJlY3Rpb24oZWxlbWVudClcbiAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgZWxlbWVudC5kaXIgPSAnbHRyJ1xuICAgIH1cbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0cy50YXJnZXRcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1vdW50KHRhcmdldCwgdGhpcylcbiAgICB9XG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIHRoaXMudW5tb3VudCgpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvc3RvcmUtZGVmYXVsdFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGRlZmF1bHQgc2ltcGxlIG9iamVjdC1iYXNlZCBzdG9yZSBmb3IgVXBweS5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4yLjdcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktc3RvcmVcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH1cbn1cbiIsIi8qKlxuICogRGVmYXVsdCBzdG9yZSB0aGF0IGtlZXBzIHN0YXRlIGluIGEgc2ltcGxlIG9iamVjdC5cbiAqL1xuY2xhc3MgRGVmYXVsdFN0b3JlIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuc3RhdGUgPSB7fVxuICAgIHRoaXMuY2FsbGJhY2tzID0gW11cbiAgfVxuXG4gIGdldFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVxuICB9XG5cbiAgc2V0U3RhdGUgKHBhdGNoKSB7XG4gICAgY29uc3QgcHJldlN0YXRlID0geyAuLi50aGlzLnN0YXRlIH1cbiAgICBjb25zdCBuZXh0U3RhdGUgPSB7IC4uLnRoaXMuc3RhdGUsIC4uLnBhdGNoIH1cblxuICAgIHRoaXMuc3RhdGUgPSBuZXh0U3RhdGVcbiAgICB0aGlzLl9wdWJsaXNoKHByZXZTdGF0ZSwgbmV4dFN0YXRlLCBwYXRjaClcbiAgfVxuXG4gIHN1YnNjcmliZSAobGlzdGVuZXIpIHtcbiAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGxpc3RlbmVyKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgICAgdGhpcy5jYWxsYmFja3Muc3BsaWNlKFxuICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbmRleE9mKGxpc3RlbmVyKSxcbiAgICAgICAgMVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIF9wdWJsaXNoICguLi5hcmdzKSB7XG4gICAgdGhpcy5jYWxsYmFja3MuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgIGxpc3RlbmVyKC4uLmFyZ3MpXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmF1bHRTdG9yZSAoKSB7XG4gIHJldHVybiBuZXcgRGVmYXVsdFN0b3JlKClcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvdGh1bWJuYWlsLWdlbmVyYXRvclwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVXBweSBwbHVnaW4gdGhhdCBnZW5lcmF0ZXMgc21hbGwgcHJldmlld3Mgb2YgaW1hZ2VzIHRvIHNob3cgb24geW91ciB1cGxvYWQgVUkuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuNy4xMVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcInRodW1ibmFpbFwiLFxuICAgIFwicHJldmlld1wiLFxuICAgIFwicmVzaXplXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIixcbiAgICBcImV4aWZyXCI6IFwiXjYuMC4wXCIsXG4gICAgXCJtYXRoLWxvZzJcIjogXCJeMS4wLjFcIlxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJuYW1lc3BhY2UtZW1pdHRlclwiOiBcIjIuMC4xXCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvcmVcIjogXCJeMS4wLjBcIlxuICB9XG59XG4iLCJjb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCBUcmFuc2xhdG9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL1RyYW5zbGF0b3InKVxuY29uc3QgZGF0YVVSSXRvQmxvYiA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9kYXRhVVJJdG9CbG9iJylcbmNvbnN0IGlzT2JqZWN0VVJMID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2lzT2JqZWN0VVJMJylcbmNvbnN0IGlzUHJldmlld1N1cHBvcnRlZCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9pc1ByZXZpZXdTdXBwb3J0ZWQnKVxuY29uc3QgTWF0aExvZzIgPSByZXF1aXJlKCdtYXRoLWxvZzInKSAvLyBQb2x5ZmlsbCBmb3IgSUUuXG5jb25zdCBleGlmciA9IHJlcXVpcmUoJ2V4aWZyL2Rpc3QvbWluaS5sZWdhY3kudW1kLmpzJylcblxuLyoqXG4gKiBUaGUgVGh1bWJuYWlsIEdlbmVyYXRvciBwbHVnaW5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFRodW1ibmFpbEdlbmVyYXRvciBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLnR5cGUgPSAnbW9kaWZpZXInXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnVGh1bWJuYWlsR2VuZXJhdG9yJ1xuICAgIHRoaXMudGl0bGUgPSAnVGh1bWJuYWlsIEdlbmVyYXRvcidcbiAgICB0aGlzLnF1ZXVlID0gW11cbiAgICB0aGlzLnF1ZXVlUHJvY2Vzc2luZyA9IGZhbHNlXG4gICAgdGhpcy5kZWZhdWx0VGh1bWJuYWlsRGltZW5zaW9uID0gMjAwXG4gICAgdGhpcy50aHVtYm5haWxUeXBlID0gdGhpcy5vcHRzLnRodW1ibmFpbFR5cGUgfHwgJ2ltYWdlL2pwZWcnXG5cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSB7XG4gICAgICBzdHJpbmdzOiB7XG4gICAgICAgIGdlbmVyYXRpbmdUaHVtYm5haWxzOiAnR2VuZXJhdGluZyB0aHVtYm5haWxzLi4uJyxcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB0aHVtYm5haWxXaWR0aDogbnVsbCxcbiAgICAgIHRodW1ibmFpbEhlaWdodDogbnVsbCxcbiAgICAgIHdhaXRGb3JUaHVtYm5haWxzQmVmb3JlVXBsb2FkOiBmYWxzZSxcbiAgICAgIGxhenk6IGZhbHNlLFxuICAgIH1cblxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgaWYgKHRoaXMub3B0cy5sYXp5ICYmIHRoaXMub3B0cy53YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaHVtYm5haWxHZW5lcmF0b3I6IFRoZSBgbGF6eWAgYW5kIGB3YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZGAgb3B0aW9ucyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLiBQbGVhc2UgZW5zdXJlIGF0IG1vc3Qgb25lIG9mIHRoZW0gaXMgc2V0IHRvIGB0cnVlYC4nKVxuICAgIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuICB9XG5cbiAgc2V0T3B0aW9ucyAobmV3T3B0cykge1xuICAgIHN1cGVyLnNldE9wdGlvbnMobmV3T3B0cylcbiAgICB0aGlzLmkxOG5Jbml0KClcbiAgfVxuXG4gIGkxOG5Jbml0ICgpIHtcbiAgICB0aGlzLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcihbdGhpcy5kZWZhdWx0TG9jYWxlLCB0aGlzLnVwcHkubG9jYWxlLCB0aGlzLm9wdHMubG9jYWxlXSlcbiAgICB0aGlzLmkxOG4gPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlLmJpbmQodGhpcy50cmFuc2xhdG9yKVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoKSAvLyBzbyB0aGF0IFVJIHJlLXJlbmRlcnMgYW5kIHdlIHNlZSB0aGUgdXBkYXRlZCBsb2NhbGVcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0aHVtYm5haWwgZm9yIHRoZSBnaXZlbiBVcHB5IGZpbGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3tkYXRhOiBCbG9ifX0gZmlsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0V2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldEhlaWdodFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGNyZWF0ZVRodW1ibmFpbCAoZmlsZSwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCkge1xuICAgIC8vIGJ1ZyBpbiB0aGUgY29tcGF0aWJpbGl0eSBkYXRhXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICBjb25zdCBvcmlnaW5hbFVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZS5kYXRhKVxuXG4gICAgY29uc3Qgb25sb2FkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKVxuICAgICAgaW1hZ2Uuc3JjID0gb3JpZ2luYWxVcmxcbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIC8vIGJ1ZyBpbiB0aGUgY29tcGF0aWJpbGl0eSBkYXRhXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob3JpZ2luYWxVcmwpXG4gICAgICAgIHJlc29sdmUoaW1hZ2UpXG4gICAgICB9KVxuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gYnVnIGluIHRoZSBjb21wYXRpYmlsaXR5IGRhdGFcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvcmlnaW5hbFVybClcbiAgICAgICAgcmVqZWN0KGV2ZW50LmVycm9yIHx8IG5ldyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSB0aHVtYm5haWwnKSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGNvbnN0IG9yaWVudGF0aW9uUHJvbWlzZSA9IGV4aWZyLnJvdGF0aW9uKGZpbGUuZGF0YSkuY2F0Y2goX2VyciA9PiAxKVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtvbmxvYWQsIG9yaWVudGF0aW9uUHJvbWlzZV0pXG4gICAgICAudGhlbigoW2ltYWdlLCBvcmllbnRhdGlvbl0pID0+IHtcbiAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IHRoaXMuZ2V0UHJvcG9ydGlvbmFsRGltZW5zaW9ucyhpbWFnZSwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgb3JpZW50YXRpb24uZGVnKVxuICAgICAgICBjb25zdCByb3RhdGVkSW1hZ2UgPSB0aGlzLnJvdGF0ZUltYWdlKGltYWdlLCBvcmllbnRhdGlvbilcbiAgICAgICAgY29uc3QgcmVzaXplZEltYWdlID0gdGhpcy5yZXNpemVJbWFnZShyb3RhdGVkSW1hZ2UsIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KVxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNUb0Jsb2IocmVzaXplZEltYWdlLCB0aGlzLnRodW1ibmFpbFR5cGUsIDgwKVxuICAgICAgfSlcbiAgICAgIC50aGVuKGJsb2IgPT4ge1xuICAgICAgICAvLyBidWcgaW4gdGhlIGNvbXBhdGliaWxpdHkgZGF0YVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICAgICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5ldyBjYWxjdWxhdGVkIGRpbWVuc2lvbnMgZm9yIHRoZSBnaXZlbiBpbWFnZSBhbmQgYSB0YXJnZXQgd2lkdGhcbiAgICogb3IgaGVpZ2h0LiBJZiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGdpdmVuLCBvbmx5IHdpZHRoIGlzIHRha2VuIGludG9cbiAgICogYWNjb3VudC4gSWYgbmVpdGhlciB3aWR0aCBub3IgaGVpZ2h0IGFyZSBnaXZlbiwgdGhlIGRlZmF1bHQgZGltZW5zaW9uXG4gICAqIGlzIHVzZWQuXG4gICAqL1xuICBnZXRQcm9wb3J0aW9uYWxEaW1lbnNpb25zIChpbWcsIHdpZHRoLCBoZWlnaHQsIHJvdGF0aW9uKSB7XG4gICAgdmFyIGFzcGVjdCA9IGltZy53aWR0aCAvIGltZy5oZWlnaHRcbiAgICBpZiAocm90YXRpb24gPT09IDkwIHx8IHJvdGF0aW9uID09PSAyNzApIHtcbiAgICAgIGFzcGVjdCA9IGltZy5oZWlnaHQgLyBpbWcud2lkdGhcbiAgICB9XG5cbiAgICBpZiAod2lkdGggIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodDogTWF0aC5yb3VuZCh3aWR0aCAvIGFzcGVjdCksXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChoZWlnaHQgKiBhc3BlY3QpLFxuICAgICAgICBoZWlnaHQsXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0aGlzLmRlZmF1bHRUaHVtYm5haWxEaW1lbnNpb24sXG4gICAgICBoZWlnaHQ6IE1hdGgucm91bmQodGhpcy5kZWZhdWx0VGh1bWJuYWlsRGltZW5zaW9uIC8gYXNwZWN0KSxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBzdXJlIHRoZSBpbWFnZSBkb2VzbuKAmXQgZXhjZWVkIGJyb3dzZXIvZGV2aWNlIGNhbnZhcyBsaW1pdHMuXG4gICAqIEZvciBpb3Mgd2l0aCAyNTYgUkFNIGFuZCBpZVxuICAgKi9cbiAgcHJvdGVjdCAoaW1hZ2UpIHtcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MDgxNDgzL21heGltdW0tc2l6ZS1vZi1hLWNhbnZhcy1lbGVtZW50XG5cbiAgICB2YXIgcmF0aW8gPSBpbWFnZS53aWR0aCAvIGltYWdlLmhlaWdodFxuXG4gICAgdmFyIG1heFNxdWFyZSA9IDUwMDAwMDAgLy8gaW9zIG1heCBjYW52YXMgc3F1YXJlXG4gICAgdmFyIG1heFNpemUgPSA0MDk2IC8vIGllIG1heCBjYW52YXMgZGltZW5zaW9uc1xuXG4gICAgdmFyIG1heFcgPSBNYXRoLmZsb29yKE1hdGguc3FydChtYXhTcXVhcmUgKiByYXRpbykpXG4gICAgdmFyIG1heEggPSBNYXRoLmZsb29yKG1heFNxdWFyZSAvIE1hdGguc3FydChtYXhTcXVhcmUgKiByYXRpbykpXG4gICAgaWYgKG1heFcgPiBtYXhTaXplKSB7XG4gICAgICBtYXhXID0gbWF4U2l6ZVxuICAgICAgbWF4SCA9IE1hdGgucm91bmQobWF4VyAvIHJhdGlvKVxuICAgIH1cbiAgICBpZiAobWF4SCA+IG1heFNpemUpIHtcbiAgICAgIG1heEggPSBtYXhTaXplXG4gICAgICBtYXhXID0gTWF0aC5yb3VuZChyYXRpbyAqIG1heEgpXG4gICAgfVxuICAgIGlmIChpbWFnZS53aWR0aCA+IG1heFcpIHtcbiAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgY2FudmFzLndpZHRoID0gbWF4V1xuICAgICAgY2FudmFzLmhlaWdodCA9IG1heEhcbiAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgbWF4VywgbWF4SClcbiAgICAgIGltYWdlID0gY2FudmFzXG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlXG4gIH1cblxuICAvKipcbiAgICogUmVzaXplIGFuIGltYWdlIHRvIHRoZSB0YXJnZXQgYHdpZHRoYCBhbmQgYGhlaWdodGAuXG4gICAqXG4gICAqIFJldHVybnMgYSBDYW52YXMgd2l0aCB0aGUgcmVzaXplZCBpbWFnZSBvbiBpdC5cbiAgICovXG4gIHJlc2l6ZUltYWdlIChpbWFnZSwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCkge1xuICAgIC8vIFJlc2l6aW5nIGluIHN0ZXBzIHJlZmFjdG9yZWQgdG8gdXNlIGEgc29sdXRpb24gZnJvbVxuICAgIC8vIGh0dHBzOi8vYmxvZy51cGxvYWRjYXJlLmNvbS9pbWFnZS1yZXNpemUtaW4tYnJvd3NlcnMtaXMtYnJva2VuLWUzOGVlZDA4ZGYwMVxuXG4gICAgaW1hZ2UgPSB0aGlzLnByb3RlY3QoaW1hZ2UpXG5cbiAgICB2YXIgc3RlcHMgPSBNYXRoLmNlaWwoTWF0aExvZzIoaW1hZ2Uud2lkdGggLyB0YXJnZXRXaWR0aCkpXG4gICAgaWYgKHN0ZXBzIDwgMSkge1xuICAgICAgc3RlcHMgPSAxXG4gICAgfVxuICAgIHZhciBzVyA9IHRhcmdldFdpZHRoICogTWF0aC5wb3coMiwgc3RlcHMgLSAxKVxuICAgIHZhciBzSCA9IHRhcmdldEhlaWdodCAqIE1hdGgucG93KDIsIHN0ZXBzIC0gMSlcbiAgICB2YXIgeCA9IDJcblxuICAgIHdoaWxlIChzdGVwcy0tKSB7XG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgIGNhbnZhcy53aWR0aCA9IHNXXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gc0hcbiAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgc1csIHNIKVxuICAgICAgaW1hZ2UgPSBjYW52YXNcblxuICAgICAgc1cgPSBNYXRoLnJvdW5kKHNXIC8geClcbiAgICAgIHNIID0gTWF0aC5yb3VuZChzSCAvIHgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlXG4gIH1cblxuICByb3RhdGVJbWFnZSAoaW1hZ2UsIHRyYW5zbGF0ZSkge1xuICAgIHZhciB3ID0gaW1hZ2Uud2lkdGhcbiAgICB2YXIgaCA9IGltYWdlLmhlaWdodFxuXG4gICAgaWYgKHRyYW5zbGF0ZS5kZWcgPT09IDkwIHx8IHRyYW5zbGF0ZS5kZWcgPT09IDI3MCkge1xuICAgICAgdyA9IGltYWdlLmhlaWdodFxuICAgICAgaCA9IGltYWdlLndpZHRoXG4gICAgfVxuXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgY2FudmFzLndpZHRoID0gd1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoXG5cbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgY29udGV4dC50cmFuc2xhdGUodyAvIDIsIGggLyAyKVxuICAgIGlmICh0cmFuc2xhdGUuY2FudmFzKSB7XG4gICAgICBjb250ZXh0LnJvdGF0ZSh0cmFuc2xhdGUucmFkKVxuICAgICAgY29udGV4dC5zY2FsZSh0cmFuc2xhdGUuc2NhbGVYLCB0cmFuc2xhdGUuc2NhbGVZKVxuICAgIH1cbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgLWltYWdlLndpZHRoIC8gMiwgLWltYWdlLmhlaWdodCAvIDIsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpXG5cbiAgICByZXR1cm4gY2FudmFzXG4gIH1cblxuICAvKipcbiAgICogU2F2ZSBhIDxjYW52YXM+IGVsZW1lbnQncyBjb250ZW50IHRvIGEgQmxvYiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGNhbnZhc1RvQmxvYiAoY2FudmFzLCB0eXBlLCBxdWFsaXR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAxOCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdjYW5ub3QgcmVhZCBpbWFnZSwgcHJvYmFibHkgYW4gc3ZnIHdpdGggZXh0ZXJuYWwgcmVzb3VyY2VzJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNhbnZhcy50b0Jsb2IpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY2FudmFzLnRvQmxvYihyZXNvbHZlLCB0eXBlLCBxdWFsaXR5KVxuICAgICAgfSkudGhlbigoYmxvYikgPT4ge1xuICAgICAgICBpZiAoYmxvYiA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlYWQgaW1hZ2UsIHByb2JhYmx5IGFuIHN2ZyB3aXRoIGV4dGVybmFsIHJlc291cmNlcycpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2JcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiBkYXRhVVJJdG9CbG9iKGNhbnZhcy50b0RhdGFVUkwodHlwZSwgcXVhbGl0eSksIHt9KVxuICAgIH0pLnRoZW4oKGJsb2IpID0+IHtcbiAgICAgIGlmIChibG9iID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IGV4dHJhY3QgYmxvYiwgcHJvYmFibHkgYW4gb2xkIGJyb3dzZXInKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJsb2JcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcHJldmlldyBVUkwgZm9yIGEgZmlsZS5cbiAgICovXG4gIHNldFByZXZpZXdVUkwgKGZpbGVJRCwgcHJldmlldykge1xuICAgIHRoaXMudXBweS5zZXRGaWxlU3RhdGUoZmlsZUlELCB7IHByZXZpZXcgfSlcbiAgfVxuXG4gIGFkZFRvUXVldWUgKGl0ZW0pIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2goaXRlbSlcbiAgICBpZiAodGhpcy5xdWV1ZVByb2Nlc3NpbmcgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnByb2Nlc3NRdWV1ZSgpXG4gICAgfVxuICB9XG5cbiAgcHJvY2Vzc1F1ZXVlICgpIHtcbiAgICB0aGlzLnF1ZXVlUHJvY2Vzc2luZyA9IHRydWVcbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy51cHB5LmdldEZpbGUodGhpcy5xdWV1ZS5zaGlmdCgpKVxuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHRoaXMudXBweS5sb2coJ1tUaHVtYm5haWxHZW5lcmF0b3JdIGZpbGUgd2FzIHJlbW92ZWQgYmVmb3JlIGEgdGh1bWJuYWlsIGNvdWxkIGJlIGdlbmVyYXRlZCwgYnV0IG5vdCByZW1vdmVkIGZyb20gdGhlIHF1ZXVlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnJywgJ2Vycm9yJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0VGh1bWJuYWlsKGN1cnJlbnQpXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge30pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaGFuZGxlLWNhbGxiYWNrLWVyclxuICAgICAgICAudGhlbigoKSA9PiB0aGlzLnByb2Nlc3NRdWV1ZSgpKVxuICAgIH1cbiAgICB0aGlzLnF1ZXVlUHJvY2Vzc2luZyA9IGZhbHNlXG4gICAgdGhpcy51cHB5LmxvZygnW1RodW1ibmFpbEdlbmVyYXRvcl0gRW1wdGllZCB0aHVtYm5haWwgcXVldWUnKVxuICAgIHRoaXMudXBweS5lbWl0KCd0aHVtYm5haWw6YWxsLWdlbmVyYXRlZCcpXG4gIH1cblxuICByZXF1ZXN0VGh1bWJuYWlsIChmaWxlKSB7XG4gICAgaWYgKGlzUHJldmlld1N1cHBvcnRlZChmaWxlLnR5cGUpICYmICFmaWxlLmlzUmVtb3RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVUaHVtYm5haWwoZmlsZSwgdGhpcy5vcHRzLnRodW1ibmFpbFdpZHRoLCB0aGlzLm9wdHMudGh1bWJuYWlsSGVpZ2h0KVxuICAgICAgICAudGhlbihwcmV2aWV3ID0+IHtcbiAgICAgICAgICB0aGlzLnNldFByZXZpZXdVUkwoZmlsZS5pZCwgcHJldmlldylcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKGBbVGh1bWJuYWlsR2VuZXJhdG9yXSBHZW5lcmF0ZWQgdGh1bWJuYWlsIGZvciAke2ZpbGUuaWR9YClcbiAgICAgICAgICB0aGlzLnVwcHkuZW1pdCgndGh1bWJuYWlsOmdlbmVyYXRlZCcsIHRoaXMudXBweS5nZXRGaWxlKGZpbGUuaWQpLCBwcmV2aWV3KVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKGBbVGh1bWJuYWlsR2VuZXJhdG9yXSBGYWlsZWQgdGh1bWJuYWlsIGZvciAke2ZpbGUuaWR9OmAsICd3YXJuaW5nJylcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKGVyciwgJ3dhcm5pbmcnKVxuICAgICAgICAgIHRoaXMudXBweS5lbWl0KCd0aHVtYm5haWw6ZXJyb3InLCB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlLmlkKSwgZXJyKVxuICAgICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIG9uRmlsZUFkZGVkID0gKGZpbGUpID0+IHtcbiAgICBpZiAoXG4gICAgICAhZmlsZS5wcmV2aWV3XG4gICAgICAmJiBmaWxlLmRhdGFcbiAgICAgICYmIGlzUHJldmlld1N1cHBvcnRlZChmaWxlLnR5cGUpXG4gICAgICAmJiAhZmlsZS5pc1JlbW90ZVxuICAgICkge1xuICAgICAgdGhpcy5hZGRUb1F1ZXVlKGZpbGUuaWQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBhIGxhenkgcmVxdWVzdCBmb3IgYSB0aHVtYm5haWwgaWYgdGhlIHRodW1ibmFpbCBoYXMgbm90IHlldCBiZWVuIGdlbmVyYXRlZC5cbiAgICovXG4gIG9uQ2FuY2VsUmVxdWVzdCA9IChmaWxlKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnF1ZXVlLmluZGV4T2YoZmlsZS5pZClcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnF1ZXVlLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgdGhlIHRodW1ibmFpbCBmb3IgYSBmaWxlLiBDYW5jZWwgbGF6eSByZXF1ZXN0cyBhbmQgZnJlZSB0aGUgdGh1bWJuYWlsIFVSTC5cbiAgICovXG4gIG9uRmlsZVJlbW92ZWQgPSAoZmlsZSkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5xdWV1ZS5pbmRleE9mKGZpbGUuaWQpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5xdWV1ZS5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgb2JqZWN0IFVSTHMuXG4gICAgaWYgKGZpbGUucHJldmlldyAmJiBpc09iamVjdFVSTChmaWxlLnByZXZpZXcpKSB7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGZpbGUucHJldmlldylcbiAgICB9XG4gIH1cblxuICBvblJlc3RvcmVkID0gKCkgPT4ge1xuICAgIGNvbnN0IHJlc3RvcmVkRmlsZXMgPSB0aGlzLnVwcHkuZ2V0RmlsZXMoKS5maWx0ZXIoZmlsZSA9PiBmaWxlLmlzUmVzdG9yZWQpXG4gICAgcmVzdG9yZWRGaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICAvLyBPbmx5IGFkZCBibG9iIFVSTHM7IHRoZXkgYXJlIGxpa2VseSBpbnZhbGlkIGFmdGVyIGJlaW5nIHJlc3RvcmVkLlxuICAgICAgaWYgKCFmaWxlLnByZXZpZXcgfHwgaXNPYmplY3RVUkwoZmlsZS5wcmV2aWV3KSkge1xuICAgICAgICB0aGlzLmFkZFRvUXVldWUoZmlsZS5pZClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgd2FpdFVudGlsQWxsUHJvY2Vzc2VkID0gKGZpbGVJRHMpID0+IHtcbiAgICBmaWxlSURzLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRClcbiAgICAgIHRoaXMudXBweS5lbWl0KCdwcmVwcm9jZXNzLXByb2dyZXNzJywgZmlsZSwge1xuICAgICAgICBtb2RlOiAnaW5kZXRlcm1pbmF0ZScsXG4gICAgICAgIG1lc3NhZ2U6IHRoaXMuaTE4bignZ2VuZXJhdGluZ1RodW1ibmFpbHMnKSxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGNvbnN0IGVtaXRQcmVwcm9jZXNzQ29tcGxldGVGb3JBbGwgPSAoKSA9PiB7XG4gICAgICBmaWxlSURzLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKVxuICAgICAgICB0aGlzLnVwcHkuZW1pdCgncHJlcHJvY2Vzcy1jb21wbGV0ZScsIGZpbGUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5xdWV1ZVByb2Nlc3NpbmcpIHtcbiAgICAgICAgdGhpcy51cHB5Lm9uY2UoJ3RodW1ibmFpbDphbGwtZ2VuZXJhdGVkJywgKCkgPT4ge1xuICAgICAgICAgIGVtaXRQcmVwcm9jZXNzQ29tcGxldGVGb3JBbGwoKVxuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW1pdFByZXByb2Nlc3NDb21wbGV0ZUZvckFsbCgpXG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnVwcHkub24oJ2ZpbGUtcmVtb3ZlZCcsIHRoaXMub25GaWxlUmVtb3ZlZClcbiAgICBpZiAodGhpcy5vcHRzLmxhenkpIHtcbiAgICAgIHRoaXMudXBweS5vbigndGh1bWJuYWlsOnJlcXVlc3QnLCB0aGlzLm9uRmlsZUFkZGVkKVxuICAgICAgdGhpcy51cHB5Lm9uKCd0aHVtYm5haWw6Y2FuY2VsJywgdGhpcy5vbkNhbmNlbFJlcXVlc3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBweS5vbignZmlsZS1hZGRlZCcsIHRoaXMub25GaWxlQWRkZWQpXG4gICAgICB0aGlzLnVwcHkub24oJ3Jlc3RvcmVkJywgdGhpcy5vblJlc3RvcmVkKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdHMud2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQpIHtcbiAgICAgIHRoaXMudXBweS5hZGRQcmVQcm9jZXNzb3IodGhpcy53YWl0VW50aWxBbGxQcm9jZXNzZWQpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnVwcHkub2ZmKCdmaWxlLXJlbW92ZWQnLCB0aGlzLm9uRmlsZVJlbW92ZWQpXG4gICAgaWYgKHRoaXMub3B0cy5sYXp5KSB7XG4gICAgICB0aGlzLnVwcHkub2ZmKCd0aHVtYm5haWw6cmVxdWVzdCcsIHRoaXMub25GaWxlQWRkZWQpXG4gICAgICB0aGlzLnVwcHkub2ZmKCd0aHVtYm5haWw6Y2FuY2VsJywgdGhpcy5vbkNhbmNlbFJlcXVlc3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBweS5vZmYoJ2ZpbGUtYWRkZWQnLCB0aGlzLm9uRmlsZUFkZGVkKVxuICAgICAgdGhpcy51cHB5Lm9mZigncmVzdG9yZWQnLCB0aGlzLm9uUmVzdG9yZWQpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy53YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZCkge1xuICAgICAgdGhpcy51cHB5LnJlbW92ZVByZVByb2Nlc3Nvcih0aGlzLndhaXRVbnRpbEFsbFByb2Nlc3NlZClcbiAgICB9XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvdHVzXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJSZXN1bWFibGUgdXBsb2FkcyBmb3IgVXBweSB1c2luZyBUdXMuaW9cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS45LjJcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJ1cGxvYWRcIixcbiAgICBcInJlc3VtYWJsZVwiLFxuICAgIFwidHVzXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIixcbiAgICBcInR1cy1qcy1jbGllbnRcIjogXCJeMi4xLjFcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHR1cyA9IHJlcXVpcmUoJ3R1cy1qcy1jbGllbnQnKVxuXG5mdW5jdGlvbiBpc0NvcmRvdmEgKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIHR5cGVvZiB3aW5kb3cuUGhvbmVHYXAgIT09ICd1bmRlZmluZWQnXG4gICAgfHwgdHlwZW9mIHdpbmRvdy5Db3Jkb3ZhICE9PSAndW5kZWZpbmVkJ1xuICAgIHx8IHR5cGVvZiB3aW5kb3cuY29yZG92YSAhPT0gJ3VuZGVmaW5lZCdcbiAgKVxufVxuXG5mdW5jdGlvbiBpc1JlYWN0TmF0aXZlICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgdHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnc3RyaW5nJ1xuICAgICYmIG5hdmlnYXRvci5wcm9kdWN0LnRvTG93ZXJDYXNlKCkgPT09ICdyZWFjdG5hdGl2ZSdcbn1cblxuLy8gV2Ugb3ZlcnJpZGUgdHVzIGZpbmdlcnByaW50IHRvIHVwcHnigJlzIGBmaWxlLmlkYCwgc2luY2UgdGhlIGBmaWxlLmlkYFxuLy8gbm93IGFsc28gaW5jbHVkZXMgYHJlbGF0aXZlUGF0aGAgZm9yIGZpbGVzIGFkZGVkIGZyb20gZm9sZGVycy5cbi8vIFRoaXMgbWVhbnMgeW91IGNhbiBhZGQgMiBpZGVudGljYWwgZmlsZXMsIGlmIG9uZSBpcyBpbiBmb2xkZXIgYSxcbi8vIHRoZSBvdGhlciBpbiBmb2xkZXIgYiDigJQgYGEvZmlsZS5qcGdgIGFuZCBgYi9maWxlLmpwZ2AsIHdoZW4gYWRkZWRcbi8vIHRvZ2V0aGVyIHdpdGggYSBmb2xkZXIsIHdpbGwgYmUgdHJlYXRlZCBhcyAyIHNlcGFyYXRlIGZpbGVzLlxuLy9cbi8vIEZvciBSZWFjdCBOYXRpdmUgYW5kIENvcmRvdmEsIHdlIGxldCB0dXMtanMtY2xpZW504oCZcyBkZWZhdWx0XG4vLyBmaW5nZXJwcmludCBoYW5kbGluZyB0YWtlIGNoYXJnZS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RmluZ2VycHJpbnQgKHVwcHlGaWxlT2JqKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZmlsZSwgb3B0aW9ucykge1xuICAgIGlmIChpc0NvcmRvdmEoKSB8fCBpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIHJldHVybiB0dXMuZGVmYXVsdE9wdGlvbnMuZmluZ2VycHJpbnQoZmlsZSwgb3B0aW9ucylcbiAgICB9XG5cbiAgICBjb25zdCB1cHB5RmluZ2VycHJpbnQgPSBbXG4gICAgICAndHVzJyxcbiAgICAgIHVwcHlGaWxlT2JqLmlkLFxuICAgICAgb3B0aW9ucy5lbmRwb2ludCxcbiAgICBdLmpvaW4oJy0nKVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1cHB5RmluZ2VycHJpbnQpXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHR1cyA9IHJlcXVpcmUoJ3R1cy1qcy1jbGllbnQnKVxuY29uc3QgeyBQcm92aWRlciwgUmVxdWVzdENsaWVudCwgU29ja2V0IH0gPSByZXF1aXJlKCdAdXBweS9jb21wYW5pb24tY2xpZW50JylcbmNvbnN0IGVtaXRTb2NrZXRQcm9ncmVzcyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9lbWl0U29ja2V0UHJvZ3Jlc3MnKVxuY29uc3QgZ2V0U29ja2V0SG9zdCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRTb2NrZXRIb3N0JylcbmNvbnN0IHNldHRsZSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9zZXR0bGUnKVxuY29uc3QgRXZlbnRUcmFja2VyID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL0V2ZW50VHJhY2tlcicpXG5jb25zdCBOZXR3b3JrRXJyb3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvTmV0d29ya0Vycm9yJylcbmNvbnN0IGlzTmV0d29ya0Vycm9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2lzTmV0d29ya0Vycm9yJylcbmNvbnN0IFJhdGVMaW1pdGVkUXVldWUgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvUmF0ZUxpbWl0ZWRRdWV1ZScpXG5jb25zdCBoYXNQcm9wZXJ0eSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9oYXNQcm9wZXJ0eScpXG5jb25zdCBnZXRGaW5nZXJwcmludCA9IHJlcXVpcmUoJy4vZ2V0RmluZ2VycHJpbnQnKVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5UdXNPcHRpb25zfSBUdXNPcHRpb25zICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgndHVzLWpzLWNsaWVudCcpLlVwbG9hZE9wdGlvbnN9IFJhd1R1c09wdGlvbnMgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCdAdXBweS9jb3JlJykuVXBweX0gVXBweSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ0B1cHB5L2NvcmUnKS5VcHB5RmlsZX0gVXBweUZpbGUgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCdAdXBweS9jb3JlJykuRmFpbGVkVXBweUZpbGU8e30+fSBGYWlsZWRVcHB5RmlsZSAqL1xuXG4vKipcbiAqIEV4dHJhY3RlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90dXMvdHVzLWpzLWNsaWVudC9ibG9iL21hc3Rlci9saWIvdXBsb2FkLmpzI0wxM1xuICogZXhjZXB0ZWQgd2UgcmVtb3ZlZCAnZmluZ2VycHJpbnQnIGtleSB0byBhdm9pZCBhZGRpbmcgbW9yZSBkZXBlbmRlbmNpZXNcbiAqXG4gKiBAdHlwZSB7UmF3VHVzT3B0aW9uc31cbiAqL1xuY29uc3QgdHVzRGVmYXVsdE9wdGlvbnMgPSB7XG4gIGVuZHBvaW50OiAnJyxcblxuICB1cGxvYWRVcmw6IG51bGwsXG4gIG1ldGFkYXRhOiB7fSxcbiAgdXBsb2FkU2l6ZTogbnVsbCxcblxuICBvblByb2dyZXNzOiBudWxsLFxuICBvbkNodW5rQ29tcGxldGU6IG51bGwsXG4gIG9uU3VjY2VzczogbnVsbCxcbiAgb25FcnJvcjogbnVsbCxcblxuICBvdmVycmlkZVBhdGNoTWV0aG9kOiBmYWxzZSxcbiAgaGVhZGVyczoge30sXG4gIGFkZFJlcXVlc3RJZDogZmFsc2UsXG5cbiAgY2h1bmtTaXplOiBJbmZpbml0eSxcbiAgcmV0cnlEZWxheXM6IFswLCAxMDAwLCAzMDAwLCA1MDAwXSxcbiAgcGFyYWxsZWxVcGxvYWRzOiAxLFxuICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IHRydWUsXG4gIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzOiBmYWxzZSxcbiAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IGZhbHNlLFxuICB1cGxvYWREYXRhRHVyaW5nQ3JlYXRpb246IGZhbHNlLFxufVxuXG4vKipcbiAqIFR1cyByZXN1bWFibGUgZmlsZSB1cGxvYWRlclxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFR1cyBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwcHl9IHVwcHlcbiAgICogQHBhcmFtIHtUdXNPcHRpb25zfSBvcHRzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy50eXBlID0gJ3VwbG9hZGVyJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1R1cydcbiAgICB0aGlzLnRpdGxlID0gJ1R1cydcblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGF1dG9SZXRyeTogdHJ1ZSxcbiAgICAgIHJlc3VtZTogdHJ1ZSxcbiAgICAgIHVzZUZhc3RSZW1vdGVSZXRyeTogdHJ1ZSxcbiAgICAgIGxpbWl0OiAwLFxuICAgICAgcmV0cnlEZWxheXM6IFswLCAxMDAwLCAzMDAwLCA1MDAwXSxcbiAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgfVxuXG4gICAgLy8gbWVyZ2UgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIG9uZXMgc2V0IGJ5IHVzZXJcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uXCIpLlR1c09wdGlvbnN9ICovXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICAvKipcbiAgICAgKiBTaW11bHRhbmVvdXMgdXBsb2FkIGxpbWl0aW5nIGlzIHNoYXJlZCBhY3Jvc3MgYWxsIHVwbG9hZHMgd2l0aCB0aGlzIHBsdWdpbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtSYXRlTGltaXRlZFF1ZXVlfVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdHMgPSBuZXcgUmF0ZUxpbWl0ZWRRdWV1ZSh0aGlzLm9wdHMubGltaXQpXG5cbiAgICB0aGlzLnVwbG9hZGVycyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB0aGlzLnVwbG9hZGVyRXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIHRoaXMudXBsb2FkZXJTb2NrZXRzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgdGhpcy5oYW5kbGVSZXNldFByb2dyZXNzID0gdGhpcy5oYW5kbGVSZXNldFByb2dyZXNzLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZVVwbG9hZCA9IHRoaXMuaGFuZGxlVXBsb2FkLmJpbmQodGhpcylcbiAgfVxuXG4gIGhhbmRsZVJlc2V0UHJvZ3Jlc3MgKCkge1xuICAgIGNvbnN0IGZpbGVzID0geyAuLi50aGlzLnVwcHkuZ2V0U3RhdGUoKS5maWxlcyB9XG4gICAgT2JqZWN0LmtleXMoZmlsZXMpLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgLy8gT25seSBjbG9uZSB0aGUgZmlsZSBvYmplY3QgaWYgaXQgaGFzIGEgVHVzIGB1cGxvYWRVcmxgIGF0dGFjaGVkLlxuICAgICAgaWYgKGZpbGVzW2ZpbGVJRF0udHVzICYmIGZpbGVzW2ZpbGVJRF0udHVzLnVwbG9hZFVybCkge1xuICAgICAgICBjb25zdCB0dXNTdGF0ZSA9IHsgLi4uZmlsZXNbZmlsZUlEXS50dXMgfVxuICAgICAgICBkZWxldGUgdHVzU3RhdGUudXBsb2FkVXJsXG4gICAgICAgIGZpbGVzW2ZpbGVJRF0gPSB7IC4uLmZpbGVzW2ZpbGVJRF0sIHR1czogdHVzU3RhdGUgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLnVwcHkuc2V0U3RhdGUoeyBmaWxlcyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFsbCByZWZlcmVuY2VzIGZvciBhIGZpbGUncyB1cGxvYWQ6IHRoZSB0dXMuVXBsb2FkIGluc3RhbmNlLFxuICAgKiBhbnkgZXZlbnRzIHJlbGF0ZWQgdG8gdGhlIGZpbGUsIGFuZCB0aGUgQ29tcGFuaW9uIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEXG4gICAqL1xuICByZXNldFVwbG9hZGVyUmVmZXJlbmNlcyAoZmlsZUlELCBvcHRzID0ge30pIHtcbiAgICBpZiAodGhpcy51cGxvYWRlcnNbZmlsZUlEXSkge1xuICAgICAgY29uc3QgdXBsb2FkZXIgPSB0aGlzLnVwbG9hZGVyc1tmaWxlSURdXG4gICAgICB1cGxvYWRlci5hYm9ydCgpXG4gICAgICBpZiAob3B0cy5hYm9ydCkge1xuICAgICAgICAvLyB0byBhdm9pZCA0MjMgZXJyb3IgZnJvbSB0dXMgc2VydmVyLCB3ZSB3YWl0XG4gICAgICAgIC8vIHRvIGJlIHN1cmUgdGhlIHByZXZpb3VzIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCBiZWZvcmUgdGVybWluYXRpbmcgdGhlIHVwbG9hZFxuICAgICAgICAvLyBAdG9kbyByZW1vdmUgdGhlIHRpbWVvdXQgd2hlbiB0aGlzIFwid2FpdFwiIGlzIGhhbmRsZWQgaW4gdHVzLWpzLWNsaWVudCBpbnRlcm5hbGx5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdXBsb2FkZXIuYWJvcnQodHJ1ZSksIDEwMDApXG4gICAgICB9XG4gICAgICB0aGlzLnVwbG9hZGVyc1tmaWxlSURdID0gbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdKSB7XG4gICAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0ucmVtb3ZlKClcbiAgICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXSA9IG51bGxcbiAgICB9XG4gICAgaWYgKHRoaXMudXBsb2FkZXJTb2NrZXRzW2ZpbGVJRF0pIHtcbiAgICAgIHRoaXMudXBsb2FkZXJTb2NrZXRzW2ZpbGVJRF0uY2xvc2UoKVxuICAgICAgdGhpcy51cGxvYWRlclNvY2tldHNbZmlsZUlEXSA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFR1cyB1cGxvYWQuXG4gICAqXG4gICAqIEEgbG90IGNhbiBoYXBwZW4gZHVyaW5nIGFuIHVwbG9hZCwgc28gdGhpcyBpcyBxdWl0ZSBoYXJkIHRvIGZvbGxvdyFcbiAgICogLSBGaXJzdCwgdGhlIHVwbG9hZCBpcyBzdGFydGVkLiBJZiB0aGUgZmlsZSB3YXMgYWxyZWFkeSBwYXVzZWQgYnkgdGhlIHRpbWUgdGhlIHVwbG9hZCBzdGFydHMsIG5vdGhpbmcgc2hvdWxkIGhhcHBlbi5cbiAgICogICBJZiB0aGUgYGxpbWl0YCBvcHRpb24gaXMgdXNlZCwgdGhlIHVwbG9hZCBtdXN0IGJlIHF1ZXVlZCBvbnRvIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUuXG4gICAqICAgV2hlbiBhbiB1cGxvYWQgc3RhcnRzLCB3ZSBzdG9yZSB0aGUgdHVzLlVwbG9hZCBpbnN0YW5jZSwgYW5kIGFuIEV2ZW50VHJhY2tlciBpbnN0YW5jZSB0aGF0IG1hbmFnZXMgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgKiAgIGZvciBwYXVzaW5nLCBjYW5jZWxsYXRpb24sIHJlbW92YWwsIGV0Yy5cbiAgICogLSBXaGlsZSB0aGUgdXBsb2FkIGlzIGluIHByb2dyZXNzLCBpdCBtYXkgYmUgcGF1c2VkIG9yIGNhbmNlbGxlZC5cbiAgICogICBQYXVzaW5nIGFib3J0cyB0aGUgdW5kZXJseWluZyB0dXMuVXBsb2FkLCBhbmQgcmVtb3ZlcyB0aGUgdXBsb2FkIGZyb20gdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZS4gQWxsIG90aGVyIHN0YXRlIGlzXG4gICAqICAgbWFpbnRhaW5lZC5cbiAgICogICBDYW5jZWxsaW5nIHJlbW92ZXMgdGhlIHVwbG9hZCBmcm9tIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUsIGFuZCBjb21wbGV0ZWx5IGFib3J0cyB0aGUgdXBsb2FkLS10aGUgdHVzLlVwbG9hZCBpbnN0YW5jZVxuICAgKiAgIGlzIGFib3J0ZWQgYW5kIGRpc2NhcmRlZCwgdGhlIEV2ZW50VHJhY2tlciBpbnN0YW5jZSBpcyBkZXN0cm95ZWQgKHJlbW92aW5nIGFsbCBsaXN0ZW5lcnMpLlxuICAgKiAgIFJlc3VtaW5nIHRoZSB1cGxvYWQgdXNlcyB0aGUgYHRoaXMucmVxdWVzdHNgIHF1ZXVlIGFzIHdlbGwsIHRvIHByZXZlbnQgc2VsZWN0aXZlbHkgcGF1c2luZyBhbmQgcmVzdW1pbmcgdXBsb2FkcyBmcm9tXG4gICAqICAgYnlwYXNzaW5nIHRoZSBsaW1pdC5cbiAgICogLSBBZnRlciBjb21wbGV0aW5nIGFuIHVwbG9hZCwgdGhlIHR1cy5VcGxvYWQgYW5kIEV2ZW50VHJhY2tlciBpbnN0YW5jZXMgYXJlIGNsZWFuZWQgdXAsIGFuZCB0aGUgdXBsb2FkIGlzIG1hcmtlZCBhcyBkb25lXG4gICAqICAgaW4gdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZS5cbiAgICogLSBXaGVuIGFuIHVwbG9hZCBjb21wbGV0ZWQgd2l0aCBhbiBlcnJvciwgdGhlIHNhbWUgaGFwcGVucyBhcyBvbiBzdWNjZXNzZnVsIGNvbXBsZXRpb24sIGJ1dCB0aGUgYHVwbG9hZCgpYCBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKlxuICAgKiBXaGVuIHdvcmtpbmcgb24gdGhpcyBmdW5jdGlvbiwga2VlcCBpbiBtaW5kOlxuICAgKiAgLSBXaGVuIGFuIHVwbG9hZCBpcyBjb21wbGV0ZWQgb3IgY2FuY2VsbGVkIGZvciBhbnkgcmVhc29uLCB0aGUgdHVzLlVwbG9hZCBhbmQgRXZlbnRUcmFja2VyIGluc3RhbmNlcyBuZWVkIHRvIGJlIGNsZWFuZWQgdXAgdXNpbmcgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcygpLlxuICAgKiAgLSBXaGVuIGFuIHVwbG9hZCBpcyBjYW5jZWxsZWQgb3IgcGF1c2VkLCBmb3IgYW55IHJlYXNvbiwgaXQgbmVlZHMgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUgdXNpbmcgYHF1ZXVlZFJlcXVlc3QuYWJvcnQoKWAuXG4gICAqICAtIFdoZW4gYW4gdXBsb2FkIGlzIGNvbXBsZXRlZCBmb3IgYW55IHJlYXNvbiwgaW5jbHVkaW5nIGVycm9ycywgaXQgbmVlZHMgdG8gYmUgbWFya2VkIGFzIHN1Y2ggdXNpbmcgYHF1ZXVlZFJlcXVlc3QuZG9uZSgpYC5cbiAgICogIC0gV2hlbiBhbiB1cGxvYWQgaXMgc3RhcnRlZCBvciByZXN1bWVkLCBpdCBuZWVkcyB0byBnbyB0aHJvdWdoIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUuIFRoZSBgcXVldWVkUmVxdWVzdGAgdmFyaWFibGUgbXVzdCBiZSB1cGRhdGVkIHNvIHRoZSBvdGhlciB1c2VzIG9mIGl0IGFyZSB2YWxpZC5cbiAgICogIC0gQmVmb3JlIHJlcGxhY2luZyB0aGUgYHF1ZXVlZFJlcXVlc3RgIHZhcmlhYmxlLCB0aGUgcHJldmlvdXMgYHF1ZXVlZFJlcXVlc3RgIG11c3QgYmUgYWJvcnRlZCwgZWxzZSBpdCB3aWxsIGtlZXAgdGFraW5nIHVwIGEgc3BvdCBpbiB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBweUZpbGV9IGZpbGUgZm9yIHVzZSB3aXRoIHVwbG9hZFxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudCBmaWxlIGluIGEgcXVldWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsIG51bWJlciBvZiBmaWxlcyBpbiBhIHF1ZXVlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgdXBsb2FkIChmaWxlLCBjdXJyZW50LCB0b3RhbCkge1xuICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcblxuICAgIC8vIENyZWF0ZSBhIG5ldyB0dXMgdXBsb2FkXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtc3RhcnRlZCcsIGZpbGUpXG5cbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgLi4uKGZpbGUudHVzIHx8IHt9KSxcbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBlIHtSYXdUdXNPcHRpb25zfSAqL1xuICAgICAgY29uc3QgdXBsb2FkT3B0aW9ucyA9IHtcbiAgICAgICAgLi4udHVzRGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIC8vIFRPRE8gb25seSBwdXQgdHVzLXNwZWNpZmljIG9wdGlvbnMgaW4/XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB1cGxvYWRPcHRpb25zLnJlc3VtZVxuXG4gICAgICAvLyBNYWtlIGByZXN1bWU6IHRydWVgIHdvcmsgbGlrZSBpdCBkaWQgaW4gdHVzLWpzLWNsaWVudCB2MS5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSBpbiBAdXBweS90dXMgdjJcbiAgICAgIGlmIChvcHRzLnJlc3VtZSkge1xuICAgICAgICB1cGxvYWRPcHRpb25zLnN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgLy8gV2Ugb3ZlcnJpZGUgdHVzIGZpbmdlcnByaW50IHRvIHVwcHnigJlzIGBmaWxlLmlkYCwgc2luY2UgdGhlIGBmaWxlLmlkYFxuICAgICAgLy8gbm93IGFsc28gaW5jbHVkZXMgYHJlbGF0aXZlUGF0aGAgZm9yIGZpbGVzIGFkZGVkIGZyb20gZm9sZGVycy5cbiAgICAgIC8vIFRoaXMgbWVhbnMgeW91IGNhbiBhZGQgMiBpZGVudGljYWwgZmlsZXMsIGlmIG9uZSBpcyBpbiBmb2xkZXIgYSxcbiAgICAgIC8vIHRoZSBvdGhlciBpbiBmb2xkZXIgYi5cbiAgICAgIHVwbG9hZE9wdGlvbnMuZmluZ2VycHJpbnQgPSBnZXRGaW5nZXJwcmludChmaWxlKVxuXG4gICAgICB1cGxvYWRPcHRpb25zLm9uQmVmb3JlUmVxdWVzdCA9IChyZXEpID0+IHtcbiAgICAgICAgY29uc3QgeGhyID0gcmVxLmdldFVuZGVybHlpbmdPYmplY3QoKVxuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRzLndpdGhDcmVkZW50aWFsc1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5vbkJlZm9yZVJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvcHRzLm9uQmVmb3JlUmVxdWVzdChyZXEpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXBsb2FkT3B0aW9ucy5vbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKGVycilcblxuICAgICAgICBjb25zdCB4aHIgPSBlcnIub3JpZ2luYWxSZXF1ZXN0ID8gZXJyLm9yaWdpbmFsUmVxdWVzdC5nZXRVbmRlcmx5aW5nT2JqZWN0KCkgOiBudWxsXG4gICAgICAgIGlmIChpc05ldHdvcmtFcnJvcih4aHIpKSB7XG4gICAgICAgICAgZXJyID0gbmV3IE5ldHdvcmtFcnJvcihlcnIsIHhocilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgcXVldWVkUmVxdWVzdC5kb25lKClcblxuICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLWVycm9yJywgZmlsZSwgZXJyKVxuXG4gICAgICAgIHJlamVjdChlcnIpXG4gICAgICB9XG5cbiAgICAgIHVwbG9hZE9wdGlvbnMub25Qcm9ncmVzcyA9IChieXRlc1VwbG9hZGVkLCBieXRlc1RvdGFsKSA9PiB7XG4gICAgICAgIHRoaXMub25SZWNlaXZlVXBsb2FkVXJsKGZpbGUsIHVwbG9hZC51cmwpXG4gICAgICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtcHJvZ3Jlc3MnLCBmaWxlLCB7XG4gICAgICAgICAgdXBsb2FkZXI6IHRoaXMsXG4gICAgICAgICAgYnl0ZXNVcGxvYWRlZCxcbiAgICAgICAgICBieXRlc1RvdGFsLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB1cGxvYWRPcHRpb25zLm9uU3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdXBsb2FkUmVzcCA9IHtcbiAgICAgICAgICB1cGxvYWRVUkw6IHVwbG9hZC51cmwsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKGZpbGUuaWQpXG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuZG9uZSgpXG5cbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1zdWNjZXNzJywgZmlsZSwgdXBsb2FkUmVzcClcblxuICAgICAgICBpZiAodXBsb2FkLnVybCkge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coYERvd25sb2FkICR7dXBsb2FkLmZpbGUubmFtZX0gZnJvbSAke3VwbG9hZC51cmx9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUodXBsb2FkKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjb3B5UHJvcCA9IChvYmosIHNyY1Byb3AsIGRlc3RQcm9wKSA9PiB7XG4gICAgICAgIGlmIChoYXNQcm9wZXJ0eShvYmosIHNyY1Byb3ApICYmICFoYXNQcm9wZXJ0eShvYmosIGRlc3RQcm9wKSkge1xuICAgICAgICAgIG9ialtkZXN0UHJvcF0gPSBvYmpbc3JjUHJvcF1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgICBjb25zdCBtZXRhID0ge31cbiAgICAgIGNvbnN0IG1ldGFGaWVsZHMgPSBBcnJheS5pc0FycmF5KG9wdHMubWV0YUZpZWxkcylcbiAgICAgICAgPyBvcHRzLm1ldGFGaWVsZHNcbiAgICAgICAgLy8gU2VuZCBhbG9uZyBhbGwgZmllbGRzIGJ5IGRlZmF1bHQuXG4gICAgICAgIDogT2JqZWN0LmtleXMoZmlsZS5tZXRhKVxuICAgICAgbWV0YUZpZWxkcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIG1ldGFbaXRlbV0gPSBmaWxlLm1ldGFbaXRlbV1cbiAgICAgIH0pXG5cbiAgICAgIC8vIHR1c2QgdXNlcyBtZXRhZGF0YSBmaWVsZHMgJ2ZpbGV0eXBlJyBhbmQgJ2ZpbGVuYW1lJ1xuICAgICAgY29weVByb3AobWV0YSwgJ3R5cGUnLCAnZmlsZXR5cGUnKVxuICAgICAgY29weVByb3AobWV0YSwgJ25hbWUnLCAnZmlsZW5hbWUnKVxuXG4gICAgICB1cGxvYWRPcHRpb25zLm1ldGFkYXRhID0gbWV0YVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLmRhdGEsIHVwbG9hZE9wdGlvbnMpXG4gICAgICB0aGlzLnVwbG9hZGVyc1tmaWxlLmlkXSA9IHVwbG9hZFxuICAgICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlLmlkXSA9IG5ldyBFdmVudFRyYWNrZXIodGhpcy51cHB5KVxuXG4gICAgICAvLyBNYWtlIGByZXN1bWU6IHRydWVgIHdvcmsgbGlrZSBpdCBkaWQgaW4gdHVzLWpzLWNsaWVudCB2MS5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSBpbiBAdXBweS90dXMgdjIuXG4gICAgICBpZiAob3B0cy5yZXN1bWUpIHtcbiAgICAgICAgdXBsb2FkLmZpbmRQcmV2aW91c1VwbG9hZHMoKS50aGVuKChwcmV2aW91c1VwbG9hZHMpID0+IHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91c1VwbG9hZCA9IHByZXZpb3VzVXBsb2Fkc1swXVxuICAgICAgICAgIGlmIChwcmV2aW91c1VwbG9hZCkge1xuICAgICAgICAgICAgdGhpcy51cHB5LmxvZyhgW1R1c10gUmVzdW1pbmcgdXBsb2FkIG9mICR7ZmlsZS5pZH0gc3RhcnRlZCBhdCAke3ByZXZpb3VzVXBsb2FkLmNyZWF0aW9uVGltZX1gKVxuICAgICAgICAgICAgdXBsb2FkLnJlc3VtZUZyb21QcmV2aW91c1VwbG9hZChwcmV2aW91c1VwbG9hZClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGxldCBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICBpZiAoIWZpbGUuaXNQYXVzZWQpIHtcbiAgICAgICAgICAvLyBFbnN1cmUgdGhpcyBnZXRzIHNjaGVkdWxlZCB0byBydW4gX2FmdGVyXyBgZmluZFByZXZpb3VzVXBsb2FkcygpYCByZXR1cm5zLlxuICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBpbiBAdXBweS90dXMgdjIuXG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB1cGxvYWQuc3RhcnQoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaGVyZSwgdGhlIGNhbGxlciB3aWxsIHRha2UgY2FyZSBvZiBjYW5jZWxsaW5nIHRoZSB1cGxvYWQgaXRzZWxmXG4gICAgICAgIC8vIHVzaW5nIHJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKCkuIFRoaXMgaXMgYmVjYXVzZSByZXNldFVwbG9hZGVyUmVmZXJlbmNlcygpIGhhcyB0byBiZVxuICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGlzIHJlcXVlc3QgaXMgc3RpbGwgaW4gdGhlIHF1ZXVlLCBhbmQgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgeWV0LCB0b28uIEF0XG4gICAgICAgIC8vIHRoYXQgcG9pbnQgdGhpcyBjYW5jZWxsYXRpb24gZnVuY3Rpb24gaXMgbm90IGdvaW5nIHRvIGJlIGNhbGxlZC5cbiAgICAgICAgLy8gQWxzbywgd2UgbmVlZCB0byByZW1vdmUgdGhlIHJlcXVlc3QgZnJvbSB0aGUgcXVldWUgX3dpdGhvdXRfIGRlc3Ryb3lpbmcgZXZlcnl0aGluZ1xuICAgICAgICAvLyByZWxhdGVkIHRvIHRoaXMgdXBsb2FkIHRvIGhhbmRsZSBwYXVzZXMuXG4gICAgICAgIHJldHVybiAoKSA9PiB7fVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vbkZpbGVSZW1vdmUoZmlsZS5pZCwgKHRhcmdldEZpbGVJRCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkLCB7IGFib3J0OiAhIXVwbG9hZC51cmwgfSlcbiAgICAgICAgcmVzb2x2ZShgdXBsb2FkICR7dGFyZ2V0RmlsZUlEfSB3YXMgcmVtb3ZlZGApXG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uUGF1c2UoZmlsZS5pZCwgKGlzUGF1c2VkKSA9PiB7XG4gICAgICAgIGlmIChpc1BhdXNlZCkge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGZpbGUgZnJvbSB0aGUgcXVldWUgc28gYW5vdGhlciBmaWxlIGNhbiBzdGFydCBpbiBpdHMgcGxhY2UuXG4gICAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgICAgdXBsb2FkLmFib3J0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZXN1bWluZyBhbiB1cGxvYWQgc2hvdWxkIGJlIHF1ZXVlZCwgZWxzZSB5b3UgY291bGQgcGF1c2UgYW5kIHRoZW4gcmVzdW1lIGEgcXVldWVkIHVwbG9hZCB0byBtYWtlIGl0IHNraXAgdGhlIHF1ZXVlLlxuICAgICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICAgIHF1ZXVlZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB1cGxvYWQuc3RhcnQoKVxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vblBhdXNlQWxsKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIHVwbG9hZC5hYm9ydCgpXG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uQ2FuY2VsQWxsKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZCwgeyBhYm9ydDogISF1cGxvYWQudXJsIH0pXG4gICAgICAgIHJlc29sdmUoYHVwbG9hZCAke2ZpbGUuaWR9IHdhcyBjYW5jZWxlZGApXG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uUmVzdW1lQWxsKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIGlmIChmaWxlLmVycm9yKSB7XG4gICAgICAgICAgdXBsb2FkLmFib3J0KClcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICAgIHVwbG9hZC5zdGFydCgpXG4gICAgICAgICAgcmV0dXJuICgpID0+IHt9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtZXJyb3InLCBmaWxlLCBlcnIpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBweUZpbGV9IGZpbGUgZm9yIHVzZSB3aXRoIHVwbG9hZFxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudCBmaWxlIGluIGEgcXVldWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsIG51bWJlciBvZiBmaWxlcyBpbiBhIHF1ZXVlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgdXBsb2FkUmVtb3RlIChmaWxlLCBjdXJyZW50LCB0b3RhbCkge1xuICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcblxuICAgIGNvbnN0IG9wdHMgPSB7IC4uLnRoaXMub3B0cyB9XG4gICAgaWYgKGZpbGUudHVzKSB7XG4gICAgICAvLyBJbnN0YWxsIGZpbGUtc3BlY2lmaWMgdXBsb2FkIG92ZXJyaWRlcy5cbiAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgZmlsZS50dXMpXG4gICAgfVxuXG4gICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1zdGFydGVkJywgZmlsZSlcbiAgICB0aGlzLnVwcHkubG9nKGZpbGUucmVtb3RlLnVybClcblxuICAgIGlmIChmaWxlLnNlcnZlclRva2VuKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0VG9TZXJ2ZXJTb2NrZXQoZmlsZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgQ2xpZW50ID0gZmlsZS5yZW1vdGUucHJvdmlkZXJPcHRpb25zLnByb3ZpZGVyID8gUHJvdmlkZXIgOiBSZXF1ZXN0Q2xpZW50XG4gICAgICBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KHRoaXMudXBweSwgZmlsZS5yZW1vdGUucHJvdmlkZXJPcHRpb25zKVxuXG4gICAgICAvLyAhISBjYW5jZWxsYXRpb24gaXMgTk9UIHN1cHBvcnRlZCBhdCB0aGlzIHN0YWdlIHlldFxuICAgICAgY2xpZW50LnBvc3QoZmlsZS5yZW1vdGUudXJsLCB7XG4gICAgICAgIC4uLmZpbGUucmVtb3RlLmJvZHksXG4gICAgICAgIGVuZHBvaW50OiBvcHRzLmVuZHBvaW50LFxuICAgICAgICB1cGxvYWRVcmw6IG9wdHMudXBsb2FkVXJsLFxuICAgICAgICBwcm90b2NvbDogJ3R1cycsXG4gICAgICAgIHNpemU6IGZpbGUuZGF0YS5zaXplLFxuICAgICAgICBoZWFkZXJzOiBvcHRzLmhlYWRlcnMsXG4gICAgICAgIG1ldGFkYXRhOiBmaWxlLm1ldGEsXG4gICAgICB9KS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgdGhpcy51cHB5LnNldEZpbGVTdGF0ZShmaWxlLmlkLCB7IHNlcnZlclRva2VuOiByZXMudG9rZW4gfSlcbiAgICAgICAgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGUuaWQpXG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RUb1NlcnZlclNvY2tldChmaWxlKVxuICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLWVycm9yJywgZmlsZSwgZXJyKVxuICAgICAgICByZWplY3QoZXJyKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNlZSB0aGUgY29tbWVudCBvbiB0aGUgdXBsb2FkKCkgbWV0aG9kLlxuICAgKlxuICAgKiBBZGRpdGlvbmFsbHksIHdoZW4gYW4gdXBsb2FkIGlzIHJlbW92ZWQsIGNvbXBsZXRlZCwgb3IgY2FuY2VsbGVkLCB3ZSBuZWVkIHRvIGNsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi4gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSByZXNldFVwbG9hZGVyUmVmZXJlbmNlcygpIGZ1bmN0aW9uLCBzbyB0aGUgc2FtZSBndWlkZWxpbmVzIGFwcGx5IGFzIGluIHVwbG9hZCgpLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwcHlGaWxlfSBmaWxlXG4gICAqL1xuICBjb25uZWN0VG9TZXJ2ZXJTb2NrZXQgKGZpbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW4gPSBmaWxlLnNlcnZlclRva2VuXG4gICAgICBjb25zdCBob3N0ID0gZ2V0U29ja2V0SG9zdChmaWxlLnJlbW90ZS5jb21wYW5pb25VcmwpXG4gICAgICBjb25zdCBzb2NrZXQgPSBuZXcgU29ja2V0KHsgdGFyZ2V0OiBgJHtob3N0fS9hcGkvJHt0b2tlbn1gLCBhdXRvT3BlbjogZmFsc2UgfSlcbiAgICAgIHRoaXMudXBsb2FkZXJTb2NrZXRzW2ZpbGUuaWRdID0gc29ja2V0XG4gICAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGUuaWRdID0gbmV3IEV2ZW50VHJhY2tlcih0aGlzLnVwcHkpXG5cbiAgICAgIHRoaXMub25GaWxlUmVtb3ZlKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIC8vIHN0aWxsIHNlbmQgcGF1c2UgZXZlbnQgaW4gY2FzZSB3ZSBhcmUgZGVhbGluZyB3aXRoIG9sZGVyIHZlcnNpb24gb2YgY29tcGFuaW9uXG4gICAgICAgIC8vIEB0b2RvIGRvbid0IHNlbmQgcGF1c2UgZXZlbnQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgc29ja2V0LnNlbmQoJ3BhdXNlJywge30pXG4gICAgICAgIHNvY2tldC5zZW5kKCdjYW5jZWwnLCB7fSlcbiAgICAgICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkKVxuICAgICAgICByZXNvbHZlKGB1cGxvYWQgJHtmaWxlLmlkfSB3YXMgcmVtb3ZlZGApXG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uUGF1c2UoZmlsZS5pZCwgKGlzUGF1c2VkKSA9PiB7XG4gICAgICAgIGlmIChpc1BhdXNlZCkge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGZpbGUgZnJvbSB0aGUgcXVldWUgc28gYW5vdGhlciBmaWxlIGNhbiBzdGFydCBpbiBpdHMgcGxhY2UuXG4gICAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgICAgc29ja2V0LnNlbmQoJ3BhdXNlJywge30pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVzdW1pbmcgYW4gdXBsb2FkIHNob3VsZCBiZSBxdWV1ZWQsIGVsc2UgeW91IGNvdWxkIHBhdXNlIGFuZCB0aGVuIHJlc3VtZSBhIHF1ZXVlZCB1cGxvYWQgdG8gbWFrZSBpdCBza2lwIHRoZSBxdWV1ZS5cbiAgICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgICBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LnNlbmQoJ3Jlc3VtZScsIHt9KVxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vblBhdXNlQWxsKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vbkNhbmNlbEFsbChmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICAvLyBzdGlsbCBzZW5kIHBhdXNlIGV2ZW50IGluIGNhc2Ugd2UgYXJlIGRlYWxpbmcgd2l0aCBvbGRlciB2ZXJzaW9uIG9mIGNvbXBhbmlvblxuICAgICAgICAvLyBAdG9kbyBkb24ndCBzZW5kIHBhdXNlIGV2ZW50IGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgICBzb2NrZXQuc2VuZCgnY2FuY2VsJywge30pXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgcmVzb2x2ZShgdXBsb2FkICR7ZmlsZS5pZH0gd2FzIGNhbmNlbGVkYClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXN1bWVBbGwoZmlsZS5pZCwgKCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgaWYgKGZpbGUuZXJyb3IpIHtcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICAgIHNvY2tldC5zZW5kKCdyZXN1bWUnLCB7fSlcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge31cbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXRyeShmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIC8vIE9ubHkgZG8gdGhlIHJldHJ5IGlmIHRoZSB1cGxvYWQgaXMgYWN0dWFsbHkgaW4gcHJvZ3Jlc3M7XG4gICAgICAgIC8vIGVsc2Ugd2UgY291bGQgdHJ5IHRvIHNlbmQgdGhlc2UgbWVzc2FnZXMgd2hlbiB0aGUgdXBsb2FkIGlzIHN0aWxsIHF1ZXVlZC5cbiAgICAgICAgLy8gV2UgbWF5IG5lZWQgYSBiZXR0ZXIgY2hlY2sgZm9yIHRoaXMgc2luY2UgdGhlIHNvY2tldCBtYXkgYWxzbyBiZSBjbG9zZWRcbiAgICAgICAgLy8gZm9yIG90aGVyIHJlYXNvbnMsIGxpa2UgbmV0d29yayBmYWlsdXJlcy5cbiAgICAgICAgaWYgKHNvY2tldC5pc09wZW4pIHtcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncmVzdW1lJywge30pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXRyeUFsbChmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgb25SZXRyeSgpIGNhbGxcbiAgICAgICAgaWYgKHNvY2tldC5pc09wZW4pIHtcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncmVzdW1lJywge30pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbigncHJvZ3Jlc3MnLCAocHJvZ3Jlc3NEYXRhKSA9PiBlbWl0U29ja2V0UHJvZ3Jlc3ModGhpcywgcHJvZ3Jlc3NEYXRhLCBmaWxlKSlcblxuICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIChlcnJEYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gZXJyRGF0YS5lcnJvclxuICAgICAgICBjb25zdCBlcnJvciA9IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKG1lc3NhZ2UpLCB7IGNhdXNlOiBlcnJEYXRhLmVycm9yIH0pXG5cbiAgICAgICAgLy8gSWYgdGhlIHJlbW90ZSByZXRyeSBvcHRpbWlzYXRpb24gc2hvdWxkIG5vdCBiZSB1c2VkLFxuICAgICAgICAvLyBjbG9zZSB0aGUgc29ja2V04oCUdGhpcyB3aWxsIHRlbGwgY29tcGFuaW9uIHRvIGNsZWFyIHN0YXRlIGFuZCBkZWxldGUgdGhlIGZpbGUuXG4gICAgICAgIGlmICghdGhpcy5vcHRzLnVzZUZhc3RSZW1vdGVSZXRyeSkge1xuICAgICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlcnZlclRva2VuIHNvIHRoYXQgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZCBmb3IgdGhlIHJldHJ5LlxuICAgICAgICAgIHRoaXMudXBweS5zZXRGaWxlU3RhdGUoZmlsZS5pZCwge1xuICAgICAgICAgICAgc2VydmVyVG9rZW46IG51bGwsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb2NrZXQuY2xvc2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1lcnJvcicsIGZpbGUsIGVycm9yKVxuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmRvbmUoKVxuICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXQub24oJ3N1Y2Nlc3MnLCAoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCB1cGxvYWRSZXNwID0ge1xuICAgICAgICAgIHVwbG9hZFVSTDogZGF0YS51cmwsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLXN1Y2Nlc3MnLCBmaWxlLCB1cGxvYWRSZXNwKVxuICAgICAgICB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKGZpbGUuaWQpXG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuZG9uZSgpXG5cbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuXG4gICAgICBsZXQgcXVldWVkUmVxdWVzdCA9IHRoaXMucmVxdWVzdHMucnVuKCgpID0+IHtcbiAgICAgICAgc29ja2V0Lm9wZW4oKVxuICAgICAgICBpZiAoZmlsZS5pc1BhdXNlZCkge1xuICAgICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaGVyZSwgdGhlIGNhbGxlciB3aWxsIHRha2UgY2FyZSBvZiBjYW5jZWxsaW5nIHRoZSB1cGxvYWQgaXRzZWxmXG4gICAgICAgIC8vIHVzaW5nIHJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKCkuIFRoaXMgaXMgYmVjYXVzZSByZXNldFVwbG9hZGVyUmVmZXJlbmNlcygpIGhhcyB0byBiZVxuICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGlzIHJlcXVlc3QgaXMgc3RpbGwgaW4gdGhlIHF1ZXVlLCBhbmQgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgeWV0LCB0b28uIEF0XG4gICAgICAgIC8vIHRoYXQgcG9pbnQgdGhpcyBjYW5jZWxsYXRpb24gZnVuY3Rpb24gaXMgbm90IGdvaW5nIHRvIGJlIGNhbGxlZC5cbiAgICAgICAgLy8gQWxzbywgd2UgbmVlZCB0byByZW1vdmUgdGhlIHJlcXVlc3QgZnJvbSB0aGUgcXVldWUgX3dpdGhvdXRfIGRlc3Ryb3lpbmcgZXZlcnl0aGluZ1xuICAgICAgICAvLyByZWxhdGVkIHRvIHRoaXMgdXBsb2FkIHRvIGhhbmRsZSBwYXVzZXMuXG4gICAgICAgIHJldHVybiAoKSA9PiB7fVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlIHRoZSB1cGxvYWRVcmwgb24gdGhlIGZpbGUgb3B0aW9ucywgc28gdGhhdCB3aGVuIEdvbGRlbiBSZXRyaWV2ZXJcbiAgICogcmVzdG9yZXMgc3RhdGUsIHdlIHdpbGwgY29udGludWUgdXBsb2FkaW5nIHRvIHRoZSBjb3JyZWN0IFVSTC5cbiAgICpcbiAgICogQHBhcmFtIHtVcHB5RmlsZX0gZmlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXBsb2FkVVJMXG4gICAqL1xuICBvblJlY2VpdmVVcGxvYWRVcmwgKGZpbGUsIHVwbG9hZFVSTCkge1xuICAgIGNvbnN0IGN1cnJlbnRGaWxlID0gdGhpcy51cHB5LmdldEZpbGUoZmlsZS5pZClcbiAgICBpZiAoIWN1cnJlbnRGaWxlKSByZXR1cm5cbiAgICAvLyBPbmx5IGRvIHRoZSB1cGRhdGUgaWYgd2UgZGlkbid0IGhhdmUgYW4gdXBsb2FkIFVSTCB5ZXQuXG4gICAgaWYgKCFjdXJyZW50RmlsZS50dXMgfHwgY3VycmVudEZpbGUudHVzLnVwbG9hZFVybCAhPT0gdXBsb2FkVVJMKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKCdbVHVzXSBTdG9yaW5nIHVwbG9hZCB1cmwnKVxuICAgICAgdGhpcy51cHB5LnNldEZpbGVTdGF0ZShjdXJyZW50RmlsZS5pZCwge1xuICAgICAgICB0dXM6IHsgLi4uY3VycmVudEZpbGUudHVzLCB1cGxvYWRVcmw6IHVwbG9hZFVSTCB9LFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk6IHZvaWR9IGNiXG4gICAqL1xuICBvbkZpbGVSZW1vdmUgKGZpbGVJRCwgY2IpIHtcbiAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0ub24oJ2ZpbGUtcmVtb3ZlZCcsIChmaWxlKSA9PiB7XG4gICAgICBpZiAoZmlsZUlEID09PSBmaWxlLmlkKSBjYihmaWxlLmlkKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGJvb2xlYW4pOiB2b2lkfSBjYlxuICAgKi9cbiAgb25QYXVzZSAoZmlsZUlELCBjYikge1xuICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXS5vbigndXBsb2FkLXBhdXNlJywgKHRhcmdldEZpbGVJRCwgaXNQYXVzZWQpID0+IHtcbiAgICAgIGlmIChmaWxlSUQgPT09IHRhcmdldEZpbGVJRCkge1xuICAgICAgICAvLyBjb25zdCBpc1BhdXNlZCA9IHRoaXMudXBweS5wYXVzZVJlc3VtZShmaWxlSUQpXG4gICAgICAgIGNiKGlzUGF1c2VkKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNiXG4gICAqL1xuICBvblJldHJ5IChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCd1cGxvYWQtcmV0cnknLCAodGFyZ2V0RmlsZUlEKSA9PiB7XG4gICAgICBpZiAoZmlsZUlEID09PSB0YXJnZXRGaWxlSUQpIHtcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNiXG4gICAqL1xuICBvblJldHJ5QWxsIChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCdyZXRyeS1hbGwnLCAoZmlsZXNUb1JldHJ5KSA9PiB7XG4gICAgICBpZiAoIXRoaXMudXBweS5nZXRGaWxlKGZpbGVJRCkpIHJldHVyblxuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNiXG4gICAqL1xuICBvblBhdXNlQWxsIChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCdwYXVzZS1hbGwnLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudXBweS5nZXRGaWxlKGZpbGVJRCkpIHJldHVyblxuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNiXG4gICAqL1xuICBvbkNhbmNlbEFsbCAoZmlsZUlELCBjYikge1xuICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXS5vbignY2FuY2VsLWFsbCcsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKSkgcmV0dXJuXG4gICAgICBjYigpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gY2JcbiAgICovXG4gIG9uUmVzdW1lQWxsIChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCdyZXN1bWUtYWxsJywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpKSByZXR1cm5cbiAgICAgIGNiKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KFVwcHlGaWxlIHwgRmFpbGVkVXBweUZpbGUpW119IGZpbGVzXG4gICAqL1xuICB1cGxvYWRGaWxlcyAoZmlsZXMpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IGZpbGVzLm1hcCgoZmlsZSwgaSkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGkgKyAxXG4gICAgICBjb25zdCB0b3RhbCA9IGZpbGVzLmxlbmd0aFxuXG4gICAgICBpZiAoJ2Vycm9yJyBpbiBmaWxlICYmIGZpbGUuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihmaWxlLmVycm9yKSlcbiAgICAgIH0gaWYgKGZpbGUuaXNSZW1vdGUpIHtcbiAgICAgICAgLy8gV2UgZW1pdCB1cGxvYWQtc3RhcnRlZCBoZXJlLCBzbyB0aGF0IGl0J3MgYWxzbyBlbWl0dGVkIGZvciBmaWxlc1xuICAgICAgICAvLyB0aGF0IGhhdmUgdG8gd2FpdCBkdWUgdG8gdGhlIGBsaW1pdGAgb3B0aW9uLlxuICAgICAgICAvLyBEb24ndCBkb3VibGUtZW1pdCB1cGxvYWQtc3RhcnRlZCBmb3IgR29sZGVuIFJldHJpZXZlci1yZXN0b3JlZCBmaWxlcyB0aGF0IHdlcmUgYWxyZWFkeSBzdGFydGVkXG4gICAgICAgIGlmICghZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkIHx8ICFmaWxlLmlzUmVzdG9yZWQpIHtcbiAgICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLXN0YXJ0ZWQnLCBmaWxlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVwbG9hZFJlbW90ZShmaWxlLCBjdXJyZW50LCB0b3RhbClcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IGRvdWJsZS1lbWl0IHVwbG9hZC1zdGFydGVkIGZvciBHb2xkZW4gUmV0cmlldmVyLXJlc3RvcmVkIGZpbGVzIHRoYXQgd2VyZSBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIGlmICghZmlsZS5wcm9ncmVzcy51cGxvYWRTdGFydGVkIHx8ICFmaWxlLmlzUmVzdG9yZWQpIHtcbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1zdGFydGVkJywgZmlsZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnVwbG9hZChmaWxlLCBjdXJyZW50LCB0b3RhbClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHNldHRsZShwcm9taXNlcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWxlSURzXG4gICAqL1xuICBoYW5kbGVVcGxvYWQgKGZpbGVJRHMpIHtcbiAgICBpZiAoZmlsZUlEcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tUdXNdIE5vIGZpbGVzIHRvIHVwbG9hZCcpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmxpbWl0ID09PSAwKSB7XG4gICAgICB0aGlzLnVwcHkubG9nKFxuICAgICAgICAnW1R1c10gV2hlbiB1cGxvYWRpbmcgbXVsdGlwbGUgZmlsZXMgYXQgb25jZSwgY29uc2lkZXIgc2V0dGluZyB0aGUgYGxpbWl0YCBvcHRpb24gKHRvIGAxMGAgZm9yIGV4YW1wbGUpLCB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgdXBsb2Fkcywgd2hpY2ggaGVscHMgcHJldmVudCBtZW1vcnkgYW5kIG5ldHdvcmsgaXNzdWVzOiBodHRwczovL3VwcHkuaW8vZG9jcy90dXMvI2xpbWl0LTAnLFxuICAgICAgICAnd2FybmluZydcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLnVwcHkubG9nKCdbVHVzXSBVcGxvYWRpbmcuLi4nKVxuICAgIGNvbnN0IGZpbGVzVG9VcGxvYWQgPSBmaWxlSURzLm1hcCgoZmlsZUlEKSA9PiB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpKVxuXG4gICAgcmV0dXJuIHRoaXMudXBsb2FkRmlsZXMoZmlsZXNUb1VwbG9hZClcbiAgICAgIC50aGVuKCgpID0+IG51bGwpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnVwcHkuc2V0U3RhdGUoe1xuICAgICAgY2FwYWJpbGl0aWVzOiB7IC4uLnRoaXMudXBweS5nZXRTdGF0ZSgpLmNhcGFiaWxpdGllcywgcmVzdW1hYmxlVXBsb2FkczogdHJ1ZSB9LFxuICAgIH0pXG4gICAgdGhpcy51cHB5LmFkZFVwbG9hZGVyKHRoaXMuaGFuZGxlVXBsb2FkKVxuXG4gICAgdGhpcy51cHB5Lm9uKCdyZXNldC1wcm9ncmVzcycsIHRoaXMuaGFuZGxlUmVzZXRQcm9ncmVzcylcblxuICAgIGlmICh0aGlzLm9wdHMuYXV0b1JldHJ5KSB7XG4gICAgICB0aGlzLnVwcHkub24oJ2JhY2stb25saW5lJywgdGhpcy51cHB5LnJldHJ5QWxsKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgIGNhcGFiaWxpdGllczogeyAuLi50aGlzLnVwcHkuZ2V0U3RhdGUoKS5jYXBhYmlsaXRpZXMsIHJlc3VtYWJsZVVwbG9hZHM6IGZhbHNlIH0sXG4gICAgfSlcbiAgICB0aGlzLnVwcHkucmVtb3ZlVXBsb2FkZXIodGhpcy5oYW5kbGVVcGxvYWQpXG5cbiAgICBpZiAodGhpcy5vcHRzLmF1dG9SZXRyeSkge1xuICAgICAgdGhpcy51cHB5Lm9mZignYmFjay1vbmxpbmUnLCB0aGlzLnVwcHkucmV0cnlBbGwpXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L3VybFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIFVybCBwbHVnaW4gbGV0cyB1c2VycyBpbXBvcnQgZmlsZXMgZnJvbSB0aGUgSW50ZXJuZXQuIFBhc3RlIGFueSBVUkwgYW5kIGl04oCZbGwgYmUgYWRkZWQhXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuNS4yM1wiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwic3R5bGVcIjogXCJkaXN0L3N0eWxlLm1pbi5jc3NcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cmxcIixcbiAgICBcImltcG9ydCBmcm9tIHVybFwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvbXBhbmlvbi1jbGllbnRcIjogXCJmaWxlOi4uL2NvbXBhbmlvbi1jbGllbnRcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5jbGFzcyBVcmxVSSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuaGFuZGxlS2V5UHJlc3MgPSB0aGlzLmhhbmRsZUtleVByZXNzLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZUNsaWNrID0gdGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMpXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgdGhpcy5pbnB1dC52YWx1ZSA9ICcnXG4gIH1cblxuICBoYW5kbGVLZXlQcmVzcyAoZXYpIHtcbiAgICBpZiAoZXYua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIHRoaXMucHJvcHMuYWRkRmlsZSh0aGlzLmlucHV0LnZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNsaWNrICgpIHtcbiAgICB0aGlzLnByb3BzLmFkZEZpbGUodGhpcy5pbnB1dC52YWx1ZSlcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1VcmxcIj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy10ZXh0SW5wdXQgdXBweS1VcmwtaW5wdXRcIlxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBhcmlhLWxhYmVsPXt0aGlzLnByb3BzLmkxOG4oJ2VudGVyVXJsVG9JbXBvcnQnKX1cbiAgICAgICAgICBwbGFjZWhvbGRlcj17dGhpcy5wcm9wcy5pMThuKCdlbnRlclVybFRvSW1wb3J0Jyl9XG4gICAgICAgICAgb25LZXlVcD17dGhpcy5oYW5kbGVLZXlQcmVzc31cbiAgICAgICAgICByZWY9eyhpbnB1dCkgPT4geyB0aGlzLmlucHV0ID0gaW5wdXQgfX1cbiAgICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICAgIC8+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LWMtYnRuLXByaW1hcnkgdXBweS1VcmwtaW1wb3J0QnV0dG9uXCJcbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfVxuICAgICAgICA+XG4gICAgICAgICAge3RoaXMucHJvcHMuaTE4bignaW1wb3J0Jyl9XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsVUlcbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IFRyYW5zbGF0b3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvVHJhbnNsYXRvcicpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCB7IFJlcXVlc3RDbGllbnQgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgVXJsVUkgPSByZXF1aXJlKCcuL1VybFVJLmpzJylcbmNvbnN0IGZvckVhY2hEcm9wcGVkT3JQYXN0ZWRVcmwgPSByZXF1aXJlKCcuL3V0aWxzL2ZvckVhY2hEcm9wcGVkT3JQYXN0ZWRVcmwnKVxuXG5mdW5jdGlvbiBVcmxJY29uICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiPlxuICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIGZpbGw9XCIjRkY3NTNFXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIC8+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjIuNzg4IDE1LjM4OWwtMi4xOTkgMi4xOWEzLjE4NCAzLjE4NCAwIDAgMS0uNTEzLjQzN2MtLjgwNi41ODQtMS42ODYuODc2LTIuNjM4Ljg3NmE0LjM3OCA0LjM3OCAwIDAgMS0zLjUxOS0xLjc1MmMtLjIyLS4yOTItLjE0Ni0uODAyLjE0Ny0xLjAyMS4yOTMtLjIyLjgwNi0uMTQ2IDEuMDI2LjE0Ni45NTMgMS4zMTMgMi43ODUgMS41MzIgNC4xMDUuNTgzYS41NzEuNTcxIDAgMCAwIC4yOTMtLjI5MmwyLjE5OS0yLjE4OWMxLjEtMS4xNjcgMS4xLTIuOTkyLS4wNzMtNC4wODZhMi45NzYgMi45NzYgMCAwIDAtNC4xMDUgMGwtMS4yNDYgMS4yNGEuNzEuNzEgMCAwIDEtMS4wMjYgMCAuNzAzLjcwMyAwIDAgMSAwLTEuMDIybDEuMjQ2LTEuMjRhNC4zMDUgNC4zMDUgMCAwIDEgNi4wODMgMGMxLjgzMyAxLjYwNSAxLjkwNiA0LjQ1MS4yMiA2LjEzem0tNy4xODMgNS4wMzVsLTEuMjQ2IDEuMjRhMi45NzYgMi45NzYgMCAwIDEtNC4xMDUgMGMtMS4xNzItMS4wOTQtMS4xNzItMi45OTEtLjA3My00LjA4NmwyLjItMi4xOS4yOTItLjI5MWMuNjYtLjQzOCAxLjM5My0uNjU3IDIuMi0uNTg0LjgwNS4xNDYgMS40NjUuNTEgMS45MDUgMS4xNjguMjIuMjkyLjczMy4zNjUgMS4wMjYuMTQ2LjI5My0uMjIuMzY3LS43My4xNDctMS4wMjItLjczMy0uOTQ5LTEuNzYtMS41MzItMi44NTktMS42NzgtMS4xLS4yMi0yLjI3Mi4wNzMtMy4yMjUuODAybC0uNDQuNDM4LTIuMTk5IDIuMTljLTEuNjg2IDEuNzUtMS42MTIgNC41MjQuMDc0IDYuMjAyLjg4LjgwMyAxLjk3OSAxLjI0MSAzLjA3OCAxLjI0MSAxLjEgMCAyLjE5OS0uNDM4IDMuMDc5LTEuMjRsMS4yNDYtMS4yNDFhLjcwMy43MDMgMCAwIDAgMC0xLjAyMmMtLjI5NC0uMjkyLS44MDctLjM2NS0xLjEtLjA3M3pcIiBmaWxsPVwiI0ZGRlwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuLyoqXG4gKiBVcmxcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVXJsIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1VybCdcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdMaW5rJ1xuICAgIHRoaXMudHlwZSA9ICdhY3F1aXJlcidcbiAgICB0aGlzLmljb24gPSAoKSA9PiA8VXJsSWNvbiAvPlxuXG4gICAgLy8gU2V0IGRlZmF1bHQgb3B0aW9ucyBhbmQgbG9jYWxlXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0ge1xuICAgICAgc3RyaW5nczoge1xuICAgICAgICBpbXBvcnQ6ICdJbXBvcnQnLFxuICAgICAgICBlbnRlclVybFRvSW1wb3J0OiAnRW50ZXIgVVJMIHRvIGltcG9ydCBhIGZpbGUnLFxuICAgICAgICBmYWlsZWRUb0ZldGNoOiAnQ29tcGFuaW9uIGZhaWxlZCB0byBmZXRjaCB0aGlzIFVSTCwgcGxlYXNlIG1ha2Ugc3VyZSBpdOKAmXMgY29ycmVjdCcsXG4gICAgICAgIGVudGVyQ29ycmVjdFVybDogJ0luY29ycmVjdCBVUkw6IFBsZWFzZSBtYWtlIHN1cmUgeW91IGFyZSBlbnRlcmluZyBhIGRpcmVjdCBsaW5rIHRvIGEgZmlsZScsXG4gICAgICB9LFxuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge31cblxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgdGhpcy5pMThuSW5pdCgpXG5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5vcHRzLmNvbXBhbmlvblVybFxuXG4gICAgaWYgKCF0aGlzLmhvc3RuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBhbmlvbiBob3N0bmFtZSBpcyByZXF1aXJlZCwgcGxlYXNlIGNvbnN1bHQgaHR0cHM6Ly91cHB5LmlvL2RvY3MvY29tcGFuaW9uJylcbiAgICB9XG5cbiAgICAvLyBCaW5kIGFsbCBldmVudCBoYW5kbGVycyBmb3IgcmVmZXJlbmNhYmlsaXR5XG4gICAgdGhpcy5nZXRNZXRhID0gdGhpcy5nZXRNZXRhLmJpbmQodGhpcylcbiAgICB0aGlzLmFkZEZpbGUgPSB0aGlzLmFkZEZpbGUuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlUm9vdERyb3AgPSB0aGlzLmhhbmRsZVJvb3REcm9wLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZVJvb3RQYXN0ZSA9IHRoaXMuaGFuZGxlUm9vdFBhc3RlLmJpbmQodGhpcylcblxuICAgIHRoaXMuY2xpZW50ID0gbmV3IFJlcXVlc3RDbGllbnQodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMgfHwgdGhpcy5vcHRzLnNlcnZlckhlYWRlcnMsXG4gICAgICBjb21wYW5pb25Db29raWVzUnVsZTogdGhpcy5vcHRzLmNvbXBhbmlvbkNvb2tpZXNSdWxlLFxuICAgIH0pXG4gIH1cblxuICBzZXRPcHRpb25zIChuZXdPcHRzKSB7XG4gICAgc3VwZXIuc2V0T3B0aW9ucyhuZXdPcHRzKVxuICAgIHRoaXMuaTE4bkluaXQoKVxuICB9XG5cbiAgaTE4bkluaXQgKCkge1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKFt0aGlzLmRlZmF1bHRMb2NhbGUsIHRoaXMudXBweS5sb2NhbGUsIHRoaXMub3B0cy5sb2NhbGVdKVxuICAgIHRoaXMuaTE4biA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5pMThuQXJyYXkgPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlQXJyYXkuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyBhbmQgd2Ugc2VlIHRoZSB1cGRhdGVkIGxvY2FsZVxuICB9XG5cbiAgZ2V0RmlsZU5hbWVGcm9tVXJsICh1cmwpIHtcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZyh1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpXG4gIH1cblxuICBjaGVja0lmQ29ycmVjdFVSTCAodXJsKSB7XG4gICAgaWYgKCF1cmwpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3QgcHJvdG9jb2wgPSB1cmwubWF0Y2goL14oW2EtejAtOV0rKTpcXC9cXC8vKVsxXVxuICAgIGlmIChwcm90b2NvbCAhPT0gJ2h0dHAnICYmIHByb3RvY29sICE9PSAnaHR0cHMnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgYWRkUHJvdG9jb2xUb1VSTCAodXJsKSB7XG4gICAgY29uc3QgcHJvdG9jb2xSZWdleCA9IC9eW2EtejAtOV0rOlxcL1xcLy9cbiAgICBjb25zdCBkZWZhdWx0UHJvdG9jb2wgPSAnaHR0cDovLydcbiAgICBpZiAocHJvdG9jb2xSZWdleC50ZXN0KHVybCkpIHtcbiAgICAgIHJldHVybiB1cmxcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdFByb3RvY29sICsgdXJsXG4gIH1cblxuICBnZXRNZXRhICh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucG9zdCgndXJsL21ldGEnLCB7IHVybCB9KVxuICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICAgICAgdGhpcy51cHB5LmxvZygnW1VSTF0gRXJyb3I6JylcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKHJlcy5lcnJvcilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCB0aGUgZmlsZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc1xuICAgICAgfSlcbiAgfVxuXG4gIGFkZEZpbGUgKHVybCkge1xuICAgIHVybCA9IHRoaXMuYWRkUHJvdG9jb2xUb1VSTCh1cmwpXG4gICAgaWYgKCF0aGlzLmNoZWNrSWZDb3JyZWN0VVJMKHVybCkpIHtcbiAgICAgIHRoaXMudXBweS5sb2coYFtVUkxdIEluY29ycmVjdCBVUkwgZW50ZXJlZDogJHt1cmx9YClcbiAgICAgIHRoaXMudXBweS5pbmZvKHRoaXMuaTE4bignZW50ZXJDb3JyZWN0VXJsJyksICdlcnJvcicsIDQwMDApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRNZXRhKHVybClcbiAgICAgIC50aGVuKChtZXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhZ0ZpbGUgPSB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0RmlsZU5hbWVGcm9tVXJsKHVybCksXG4gICAgICAgICAgdHlwZTogbWV0YS50eXBlLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHNpemU6IG1ldGEuc2l6ZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlzUmVtb3RlOiB0cnVlLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgICAgICAgdXJsOiBgJHt0aGlzLmhvc3RuYW1lfS91cmwvZ2V0YCxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgZmlsZUlkOiB1cmwsXG4gICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHRoaXMuY2xpZW50Lm9wdHMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnRmlsZVxuICAgICAgfSlcbiAgICAgIC50aGVuKCh0YWdGaWxlKSA9PiB7XG4gICAgICAgIHRoaXMudXBweS5sb2coJ1tVcmxdIEFkZGluZyByZW1vdGUgZmlsZScpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudXBweS5hZGRGaWxlKHRhZ0ZpbGUpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmICghZXJyLmlzUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZXJyXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKGVycilcbiAgICAgICAgdGhpcy51cHB5LmluZm8oe1xuICAgICAgICAgIG1lc3NhZ2U6IHRoaXMuaTE4bignZmFpbGVkVG9GZXRjaCcpLFxuICAgICAgICAgIGRldGFpbHM6IGVycixcbiAgICAgICAgfSwgJ2Vycm9yJywgNDAwMClcbiAgICAgICAgcmV0dXJuIGVyclxuICAgICAgfSlcbiAgfVxuXG4gIGhhbmRsZVJvb3REcm9wIChlKSB7XG4gICAgZm9yRWFjaERyb3BwZWRPclBhc3RlZFVybChlLmRhdGFUcmFuc2ZlciwgJ2Ryb3AnLCAodXJsKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKGBbVVJMXSBBZGRpbmcgZmlsZSBmcm9tIGRyb3BwZWQgdXJsOiAke3VybH1gKVxuICAgICAgdGhpcy5hZGRGaWxlKHVybClcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlUm9vdFBhc3RlIChlKSB7XG4gICAgZm9yRWFjaERyb3BwZWRPclBhc3RlZFVybChlLmNsaXBib2FyZERhdGEsICdwYXN0ZScsICh1cmwpID0+IHtcbiAgICAgIHRoaXMudXBweS5sb2coYFtVUkxdIEFkZGluZyBmaWxlIGZyb20gcGFzdGVkIHVybDogJHt1cmx9YClcbiAgICAgIHRoaXMuYWRkRmlsZSh1cmwpXG4gICAgfSlcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUpIHtcbiAgICByZXR1cm4gPFVybFVJIGkxOG49e3RoaXMuaTE4bn0gYWRkRmlsZT17dGhpcy5hZGRGaWxlfSAvPlxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxufVxuIiwiY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi90b0FycmF5JylcblxuLypcbiAgU0lUVUFUSU9OXG5cbiAgICAxLiBDcm9zcy1icm93c2VyIGRhdGFUcmFuc2Zlci5pdGVtc1xuXG4gICAgICBwYXN0ZSBpbiBjaHJvbWUgW0NvcHkgSW1hZ2VdOlxuICAgICAgMDoge2tpbmQ6IFwiZmlsZVwiLCB0eXBlOiBcImltYWdlL3BuZ1wifVxuICAgICAgMToge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC9odG1sXCJ9XG4gICAgICBwYXN0ZSBpbiBzYWZhcmkgW0NvcHkgSW1hZ2VdOlxuICAgICAgMDoge2tpbmQ6IFwiZmlsZVwiLCB0eXBlOiBcImltYWdlL3BuZ1wifVxuICAgICAgMToge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC9odG1sXCJ9XG4gICAgICAyOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG4gICAgICAzOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3VyaS1saXN0XCJ9XG4gICAgICBwYXN0ZSBpbiBmaXJlZm94IFtDb3B5IEltYWdlXTpcbiAgICAgIDA6IHtraW5kOiBcImZpbGVcIiwgdHlwZTogXCJpbWFnZS9wbmdcIn1cbiAgICAgIDE6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvaHRtbFwifVxuXG4gICAgICBwYXN0ZSBpbiBjaHJvbWUgW0NvcHkgSW1hZ2UgQWRkcmVzc106XG4gICAgICAwOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG4gICAgICBwYXN0ZSBpbiBzYWZhcmkgW0NvcHkgSW1hZ2UgQWRkcmVzc106XG4gICAgICAwOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG4gICAgICAxOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3VyaS1saXN0XCJ9XG4gICAgICBwYXN0ZSBpbiBmaXJlZm94IFtDb3B5IEltYWdlIEFkZHJlc3NdOlxuICAgICAgMDoge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC9wbGFpblwifVxuXG4gICAgICBkcm9wIGluIGNocm9tZSBbZnJvbSBicm93c2VyXTpcbiAgICAgIDA6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvdXJpLWxpc3RcIn1cbiAgICAgIDE6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvaHRtbFwifVxuICAgICAgZHJvcCBpbiBzYWZhcmkgW2Zyb20gYnJvd3Nlcl06XG4gICAgICAwOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3VyaS1saXN0XCJ9XG4gICAgICAxOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L2h0bWxcIn1cbiAgICAgIDI6IHtraW5kOiBcImZpbGVcIiwgdHlwZTogXCJpbWFnZS9wbmdcIn1cbiAgICAgIGRyb3AgaW4gZmlyZWZveCBbZnJvbSBicm93c2VyXTpcbiAgICAgIDA6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvdXJpLWxpc3RcIn1cbiAgICAgIDE6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQveC1tb3otdXJsXCJ9XG4gICAgICAyOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG5cbiAgICAyLiBXZSBjYW4gZGV0ZXJtaW5lIGlmIGl0J3MgYSAnY29weXBhc3RlJyBvciBhICdkcm9wJywgYnV0IHdlIGNhbid0IGRpc2Nlcm4gYmV0d2VlbiBbQ29weSBJbWFnZV0gYW5kIFtDb3B5IEltYWdlIEFkZHJlc3NdLlxuXG4gIENPTkNMVVNJT05cblxuICAgIDEuICdwYXN0ZScgKFtDb3B5IEltYWdlXSBvciBbQ29weSBJbWFnZSBBZGRyZXNzXSwgd2UgY2FuJ3QgZGlzY2VybiBiZXR3ZWVuIHRoZXNlIHR3bylcbiAgICAgIERvbid0IGRvIGFueXRoaW5nIGlmIHRoZXJlIGlzICdmaWxlJyBpdGVtLiAuaGFuZGxlUGFzdGUgaW4gdGhlIERhc2hib2FyZFBsdWdpbiB3aWxsIGRlYWwgd2l0aCBhbGwgJ2ZpbGUnIGl0ZW1zLlxuICAgICAgSWYgdGhlcmUgYXJlIG5vICdmaWxlJyBpdGVtcyAtIGhhbmRsZSAndGV4dC9wbGFpbicgaXRlbXMuXG5cbiAgICAyLiAnZHJvcCdcbiAgICAgIFRha2UgJ3RleHQvdXJpLWxpc3QnIGl0ZW1zLiBTYWZhcmkgaGFzIGFuIGFkZGl0aW9uYWwgaXRlbSBvZiAua2luZCA9PT0gJ2ZpbGUnLCBhbmQgeW91IG1heSB3b3JyeSBhYm91dCB0aGUgaXRlbSBiZWluZyBkdXBsaWNhdGVkIChmaXJzdCBieSBEYXNoYm9hcmRQbHVnaW4sIGFuZCB0aGVuIGJ5IFVybFBsdWdpbiwgbm93KSwgYnV0IGRvbid0LiBEaXJlY3RvcnkgaGFuZGxpbmcgY29kZSB3b24ndCBwYXkgYXR0ZW50aW9uIHRvIHRoaXMgcGFydGljdWxhciBpdGVtIG9mIGtpbmQgJ2ZpbGUnLlxuKi9cblxuLyoqXG4gKiBGaW5kcyBhbGwgbGlua3MgZHJvcHBlZC9wYXN0ZWQgZnJvbSBvbmUgYnJvd3NlciB3aW5kb3cgdG8gYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YVRyYW5zZmVyIC0gRGF0YVRyYW5zZmVyIGluc3RhbmNlLCBlLmcuIGUuY2xpcGJvYXJkRGF0YSwgb3IgZS5kYXRhVHJhbnNmZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpc0Ryb3BPclBhc3RlIC0gZWl0aGVyICdkcm9wJyBvciAncGFzdGUnXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtICh1cmxTdHJpbmcpID0+IHt9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9yRWFjaERyb3BwZWRPclBhc3RlZFVybCAoZGF0YVRyYW5zZmVyLCBpc0Ryb3BPclBhc3RlLCBjYWxsYmFjaykge1xuICBjb25zdCBpdGVtcyA9IHRvQXJyYXkoZGF0YVRyYW5zZmVyLml0ZW1zKVxuXG4gIGxldCB1cmxJdGVtc1xuXG4gIHN3aXRjaCAoaXNEcm9wT3JQYXN0ZSkge1xuICAgIGNhc2UgJ3Bhc3RlJzoge1xuICAgICAgY29uc3QgYXRMZWFzdE9uZUZpbGVJc0RyYWdnZWQgPSBpdGVtcy5zb21lKChpdGVtKSA9PiBpdGVtLmtpbmQgPT09ICdmaWxlJylcbiAgICAgIGlmIChhdExlYXN0T25lRmlsZUlzRHJhZ2dlZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVybEl0ZW1zID0gaXRlbXMuZmlsdGVyKChpdGVtKSA9PlxuICAgICAgICBpdGVtLmtpbmQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgJiYgaXRlbS50eXBlID09PSAndGV4dC9wbGFpbicpXG5cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJ2Ryb3AnOiB7XG4gICAgICB1cmxJdGVtcyA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT5cbiAgICAgICAgaXRlbS5raW5kID09PSAnc3RyaW5nJ1xuICAgICAgICAmJiBpdGVtLnR5cGUgPT09ICd0ZXh0L3VyaS1saXN0JylcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaXNEcm9wT3JQYXN0ZSBtdXN0IGJlIGVpdGhlciAnZHJvcCcgb3IgJ3Bhc3RlJywgYnV0IGl0J3MgJHtpc0Ryb3BPclBhc3RlfWApXG4gICAgfVxuICB9XG5cbiAgdXJsSXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGl0ZW0uZ2V0QXNTdHJpbmcoKHVybFN0cmluZykgPT5cbiAgICAgIGNhbGxiYWNrKHVybFN0cmluZykpXG4gIH0pXG59XG4iLCIvKipcbiAqIENyZWF0ZSBhIHdyYXBwZXIgYXJvdW5kIGFuIGV2ZW50IGVtaXR0ZXIgd2l0aCBhIGByZW1vdmVgIG1ldGhvZCB0byByZW1vdmVcbiAqIGFsbCBldmVudHMgdGhhdCB3ZXJlIGFkZGVkIHVzaW5nIHRoZSB3cmFwcGVkIGVtaXR0ZXIuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRXZlbnRUcmFja2VyIHtcbiAgY29uc3RydWN0b3IgKGVtaXR0ZXIpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBbXVxuICAgIHRoaXMuX2VtaXR0ZXIgPSBlbWl0dGVyXG4gIH1cblxuICBvbiAoZXZlbnQsIGZuKSB7XG4gICAgdGhpcy5fZXZlbnRzLnB1c2goW2V2ZW50LCBmbl0pXG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIub24oZXZlbnQsIGZuKVxuICB9XG5cbiAgcmVtb3ZlICgpIHtcbiAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgoW2V2ZW50LCBmbl0pID0+IHtcbiAgICAgIHRoaXMuX2VtaXR0ZXIub2ZmKGV2ZW50LCBmbilcbiAgICB9KVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2FbaHJlZl06bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ2FyZWFbaHJlZl06bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ2lucHV0Om5vdChbZGlzYWJsZWRdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICd0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICdidXR0b246bm90KFtkaXNhYmxlZF0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnaWZyYW1lOm5vdChbdGFiaW5kZXhePVwiLVwiXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICdvYmplY3Q6bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ2VtYmVkOm5vdChbdGFiaW5kZXhePVwiLVwiXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICdbY29udGVudGVkaXRhYmxlXTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnW3RhYmluZGV4XTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuXVxuIiwiY2xhc3MgTmV0d29ya0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAoZXJyb3IsIHhociA9IG51bGwpIHtcbiAgICBzdXBlcihgVGhpcyBsb29rcyBsaWtlIGEgbmV0d29yayBlcnJvciwgdGhlIGVuZHBvaW50IG1pZ2h0IGJlIGJsb2NrZWQgYnkgYW4gaW50ZXJuZXQgcHJvdmlkZXIgb3IgYSBmaXJld2FsbC5cXG5cXG5Tb3VyY2UgZXJyb3I6IFske2Vycm9yfV1gKVxuXG4gICAgdGhpcy5pc05ldHdvcmtFcnJvciA9IHRydWVcbiAgICB0aGlzLnJlcXVlc3QgPSB4aHJcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtFcnJvclxuIiwiY29uc3QgZmluZEluZGV4ID0gcmVxdWlyZSgnLi9maW5kSW5kZXgnKVxuXG5mdW5jdGlvbiBjcmVhdGVDYW5jZWxFcnJvciAoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0NhbmNlbGxlZCcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmF0ZUxpbWl0ZWRRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yIChsaW1pdCkge1xuICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8IGxpbWl0ID09PSAwKSB7XG4gICAgICB0aGlzLmxpbWl0ID0gSW5maW5pdHlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saW1pdCA9IGxpbWl0XG4gICAgfVxuXG4gICAgdGhpcy5hY3RpdmVSZXF1ZXN0cyA9IDBcbiAgICB0aGlzLnF1ZXVlZEhhbmRsZXJzID0gW11cbiAgfVxuXG4gIF9jYWxsIChmbikge1xuICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMgKz0gMVxuXG4gICAgbGV0IGRvbmUgPSBmYWxzZVxuXG4gICAgbGV0IGNhbmNlbEFjdGl2ZVxuICAgIHRyeSB7XG4gICAgICBjYW5jZWxBY3RpdmUgPSBmbigpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmFjdGl2ZVJlcXVlc3RzIC09IDFcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhYm9ydDogKCkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICAgIGRvbmUgPSB0cnVlXG4gICAgICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMgLT0gMVxuICAgICAgICBjYW5jZWxBY3RpdmUoKVxuICAgICAgICB0aGlzLl9xdWV1ZU5leHQoKVxuICAgICAgfSxcblxuICAgICAgZG9uZTogKCkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICAgIGRvbmUgPSB0cnVlXG4gICAgICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMgLT0gMVxuICAgICAgICB0aGlzLl9xdWV1ZU5leHQoKVxuICAgICAgfSxcbiAgICB9XG4gIH1cblxuICBfcXVldWVOZXh0ICgpIHtcbiAgICAvLyBEbyBpdCBzb29uIGJ1dCBub3QgaW1tZWRpYXRlbHksIHRoaXMgYWxsb3dzIGNsZWFyaW5nIG91dCB0aGUgZW50aXJlIHF1ZXVlIHN5bmNocm9ub3VzbHlcbiAgICAvLyBvbmUgYnkgb25lIHdpdGhvdXQgY29udGludW91c2x5IF9hZHZhbmNpbmdfIGl0IChhbmQgc3RhcnRpbmcgbmV3IHRhc2tzIGJlZm9yZSBpbW1lZGlhdGVseVxuICAgIC8vIGFib3J0aW5nIHRoZW0pXG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLl9uZXh0KClcbiAgICB9KVxuICB9XG5cbiAgX25leHQgKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZVJlcXVlc3RzID49IHRoaXMubGltaXQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodGhpcy5xdWV1ZWRIYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIERpc3BhdGNoIHRoZSBuZXh0IHJlcXVlc3QsIGFuZCB1cGRhdGUgdGhlIGFib3J0L2RvbmUgaGFuZGxlcnNcbiAgICAvLyBzbyB0aGF0IGNhbmNlbGxpbmcgaXQgZG9lcyB0aGUgUmlnaHQgVGhpbmcgKGFuZCBkb2Vzbid0IGp1c3QgdHJ5XG4gICAgLy8gdG8gZGVxdWV1ZSBhbiBhbHJlYWR5LXJ1bm5pbmcgcmVxdWVzdCkuXG4gICAgY29uc3QgbmV4dCA9IHRoaXMucXVldWVkSGFuZGxlcnMuc2hpZnQoKVxuICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9jYWxsKG5leHQuZm4pXG4gICAgbmV4dC5hYm9ydCA9IGhhbmRsZXIuYWJvcnRcbiAgICBuZXh0LmRvbmUgPSBoYW5kbGVyLmRvbmVcbiAgfVxuXG4gIF9xdWV1ZSAoZm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICBmbixcbiAgICAgIHByaW9yaXR5OiBvcHRpb25zLnByaW9yaXR5IHx8IDAsXG4gICAgICBhYm9ydDogKCkgPT4ge1xuICAgICAgICB0aGlzLl9kZXF1ZXVlKGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZG9uZTogKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtYXJrIGEgcXVldWVkIHJlcXVlc3QgYXMgZG9uZTogdGhpcyBpbmRpY2F0ZXMgYSBidWcnKVxuICAgICAgfSxcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IGZpbmRJbmRleCh0aGlzLnF1ZXVlZEhhbmRsZXJzLCAob3RoZXIpID0+IHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnByaW9yaXR5ID4gb3RoZXIucHJpb3JpdHlcbiAgICB9KVxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMucXVldWVkSGFuZGxlcnMucHVzaChoYW5kbGVyKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnF1ZXVlZEhhbmRsZXJzLnNwbGljZShpbmRleCwgMCwgaGFuZGxlcilcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXJcbiAgfVxuXG4gIF9kZXF1ZXVlIChoYW5kbGVyKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnF1ZXVlZEhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcilcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnF1ZXVlZEhhbmRsZXJzLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cblxuICBydW4gKGZuLCBxdWV1ZU9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVSZXF1ZXN0cyA8IHRoaXMubGltaXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxsKGZuKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcXVldWUoZm4sIHF1ZXVlT3B0aW9ucylcbiAgfVxuXG4gIHdyYXBQcm9taXNlRnVuY3Rpb24gKGZuLCBxdWV1ZU9wdGlvbnMpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGxldCBxdWV1ZWRSZXF1ZXN0XG4gICAgICBjb25zdCBvdXRlclByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QgPSB0aGlzLnJ1bigoKSA9PiB7XG4gICAgICAgICAgbGV0IGNhbmNlbEVycm9yXG4gICAgICAgICAgbGV0IGlubmVyUHJvbWlzZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbm5lclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZm4oLi4uYXJncykpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpbm5lclByb21pc2UgPSBQcm9taXNlLnJlamVjdChlcnIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5uZXJQcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbEVycm9yKSB7XG4gICAgICAgICAgICAgIHJlamVjdChjYW5jZWxFcnJvcilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHF1ZXVlZFJlcXVlc3QuZG9uZSgpXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxFcnJvcikge1xuICAgICAgICAgICAgICByZWplY3QoY2FuY2VsRXJyb3IpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBxdWV1ZWRSZXF1ZXN0LmRvbmUoKVxuICAgICAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2FuY2VsRXJyb3IgPSBjcmVhdGVDYW5jZWxFcnJvcigpXG4gICAgICAgICAgfVxuICAgICAgICB9LCBxdWV1ZU9wdGlvbnMpXG4gICAgICB9KVxuXG4gICAgICBvdXRlclByb21pc2UuYWJvcnQgPSAoKSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0ZXJQcm9taXNlXG4gICAgfVxuICB9XG59XG4iLCJjb25zdCBoYXMgPSByZXF1aXJlKCcuL2hhc1Byb3BlcnR5JylcblxuLyoqXG4gKiBUcmFuc2xhdGVzIHN0cmluZ3Mgd2l0aCBpbnRlcnBvbGF0aW9uICYgcGx1cmFsaXphdGlvbiBzdXBwb3J0LlxuICogRXh0ZW5zaWJsZSB3aXRoIGN1c3RvbSBkaWN0aW9uYXJpZXMgYW5kIHBsdXJhbGl6YXRpb24gZnVuY3Rpb25zLlxuICpcbiAqIEJvcnJvd3MgaGVhdmlseSBmcm9tIGFuZCBpbnNwaXJlZCBieSBQb2x5Z2xvdCBodHRwczovL2dpdGh1Yi5jb20vYWlyYm5iL3BvbHlnbG90LmpzLFxuICogYmFzaWNhbGx5IGEgc3RyaXBwZWQtZG93biB2ZXJzaW9uIG9mIGl0LiBEaWZmZXJlbmNlczogcGx1cmFsaXphdGlvbiBmdW5jdGlvbnMgYXJlIG5vdCBoYXJkY29kZWRcbiAqIGFuZCBjYW4gYmUgZWFzaWx5IGFkZGVkIGFtb25nIHdpdGggZGljdGlvbmFyaWVzLCBuZXN0ZWQgb2JqZWN0cyBhcmUgdXNlZCBmb3IgcGx1cmFsaXphdGlvblxuICogYXMgb3Bwb3NlZCB0byBgfHx8fGAgZGVsaW1ldGVyXG4gKlxuICogVXNhZ2UgZXhhbXBsZTogYHRyYW5zbGF0b3IudHJhbnNsYXRlKCdmaWxlc19jaG9zZW4nLCB7c21hcnRfY291bnQ6IDN9KWBcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUcmFuc2xhdG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fEFycmF5PG9iamVjdD59IGxvY2FsZXMgLSBsb2NhbGUgb3IgbGlzdCBvZiBsb2NhbGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKGxvY2FsZXMpIHtcbiAgICB0aGlzLmxvY2FsZSA9IHtcbiAgICAgIHN0cmluZ3M6IHt9LFxuICAgICAgcGx1cmFsaXplIChuKSB7XG4gICAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMVxuICAgICAgfSxcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShsb2NhbGVzKSkge1xuICAgICAgbG9jYWxlcy5mb3JFYWNoKChsb2NhbGUpID0+IHRoaXMuX2FwcGx5KGxvY2FsZSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FwcGx5KGxvY2FsZXMpXG4gICAgfVxuICB9XG5cbiAgX2FwcGx5IChsb2NhbGUpIHtcbiAgICBpZiAoIWxvY2FsZSB8fCAhbG9jYWxlLnN0cmluZ3MpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHByZXZMb2NhbGUgPSB0aGlzLmxvY2FsZVxuICAgIHRoaXMubG9jYWxlID0geyAuLi5wcmV2TG9jYWxlLCBzdHJpbmdzOiB7IC4uLnByZXZMb2NhbGUuc3RyaW5ncywgLi4ubG9jYWxlLnN0cmluZ3MgfSB9XG4gICAgdGhpcy5sb2NhbGUucGx1cmFsaXplID0gbG9jYWxlLnBsdXJhbGl6ZSB8fCBwcmV2TG9jYWxlLnBsdXJhbGl6ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgc3RyaW5nIHdpdGggcGxhY2Vob2xkZXIgdmFyaWFibGVzIGxpa2UgYCV7c21hcnRfY291bnR9IGZpbGUgc2VsZWN0ZWRgXG4gICAqIGFuZCByZXBsYWNlcyBpdCB3aXRoIHZhbHVlcyBmcm9tIG9wdGlvbnMgYHtzbWFydF9jb3VudDogNX1gXG4gICAqXG4gICAqIEBsaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS9haXJibmIvcG9seWdsb3QuanMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICAgKiB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9haXJibmIvcG9seWdsb3QuanMvYmxvYi9tYXN0ZXIvbGliL3BvbHlnbG90LmpzI0wyOTlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBocmFzZSB0aGF0IG5lZWRzIGludGVycG9sYXRpb24sIHdpdGggcGxhY2Vob2xkZXJzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHdpdGggdmFsdWVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlcGxhY2UgcGxhY2Vob2xkZXJzXG4gICAqIEByZXR1cm5zIHthbnlbXX0gaW50ZXJwb2xhdGVkXG4gICAqL1xuICBpbnRlcnBvbGF0ZSAocGhyYXNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBzcGxpdCwgcmVwbGFjZSB9ID0gU3RyaW5nLnByb3RvdHlwZVxuICAgIGNvbnN0IGRvbGxhclJlZ2V4ID0gL1xcJC9nXG4gICAgY29uc3QgZG9sbGFyQmlsbHNZYWxsID0gJyQkJCQnXG4gICAgbGV0IGludGVycG9sYXRlZCA9IFtwaHJhc2VdXG5cbiAgICBmb3IgKGNvbnN0IGFyZyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoYXJnICE9PSAnXycgJiYgaGFzKG9wdGlvbnMsIGFyZykpIHtcbiAgICAgICAgLy8gRW5zdXJlIHJlcGxhY2VtZW50IHZhbHVlIGlzIGVzY2FwZWQgdG8gcHJldmVudCBzcGVjaWFsICQtcHJlZml4ZWRcbiAgICAgICAgLy8gcmVnZXggcmVwbGFjZSB0b2tlbnMuIHRoZSBcIiQkJCRcIiBpcyBuZWVkZWQgYmVjYXVzZSBlYWNoIFwiJFwiIG5lZWRzIHRvXG4gICAgICAgIC8vIGJlIGVzY2FwZWQgd2l0aCBcIiRcIiBpdHNlbGYsIGFuZCB3ZSBuZWVkIHR3byBpbiB0aGUgcmVzdWx0aW5nIG91dHB1dC5cbiAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gb3B0aW9uc1thcmddXG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlLmNhbGwob3B0aW9uc1thcmddLCBkb2xsYXJSZWdleCwgZG9sbGFyQmlsbHNZYWxsKVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGNyZWF0ZSBhIG5ldyBgUmVnRXhwYCBlYWNoIHRpbWUgaW5zdGVhZCBvZiB1c2luZyBhIG1vcmUtZWZmaWNpZW50XG4gICAgICAgIC8vIHN0cmluZyByZXBsYWNlIHNvIHRoYXQgdGhlIHNhbWUgYXJndW1lbnQgY2FuIGJlIHJlcGxhY2VkIG11bHRpcGxlIHRpbWVzXG4gICAgICAgIC8vIGluIHRoZSBzYW1lIHBocmFzZS5cbiAgICAgICAgaW50ZXJwb2xhdGVkID0gaW5zZXJ0UmVwbGFjZW1lbnQoaW50ZXJwb2xhdGVkLCBuZXcgUmVnRXhwKGAlXFxcXHske2FyZ31cXFxcfWAsICdnJyksIHJlcGxhY2VtZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnBvbGF0ZWRcblxuICAgIGZ1bmN0aW9uIGluc2VydFJlcGxhY2VtZW50IChzb3VyY2UsIHJ4LCByZXBsYWNlbWVudCkge1xuICAgICAgY29uc3QgbmV3UGFydHMgPSBbXVxuICAgICAgc291cmNlLmZvckVhY2goKGNodW5rKSA9PiB7XG4gICAgICAgIC8vIFdoZW4gdGhlIHNvdXJjZSBjb250YWlucyBtdWx0aXBsZSBwbGFjZWhvbGRlcnMgZm9yIGludGVycG9sYXRpb24sXG4gICAgICAgIC8vIHdlIHNob3VsZCBpZ25vcmUgY2h1bmtzIHRoYXQgYXJlIG5vdCBzdHJpbmdzLCBiZWNhdXNlIHRob3NlXG4gICAgICAgIC8vIGNhbiBiZSBKU1ggb2JqZWN0cyBhbmQgd2lsbCBiZSBvdGhlcndpc2UgaW5jb3JyZWN0bHkgdHVybmVkIGludG8gc3RyaW5ncy5cbiAgICAgICAgLy8gV2l0aG91dCB0aGlzIGNvbmRpdGlvbiB3ZeKAmWQgZ2V0IHRoaXM6IFtvYmplY3QgT2JqZWN0XSBoZWxsbyBbb2JqZWN0IE9iamVjdF0gbXkgPGJ1dHRvbj5cbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gbmV3UGFydHMucHVzaChjaHVuaylcbiAgICAgICAgfVxuXG4gICAgICAgIHNwbGl0LmNhbGwoY2h1bmssIHJ4KS5mb3JFYWNoKChyYXcsIGksIGxpc3QpID0+IHtcbiAgICAgICAgICBpZiAocmF3ICE9PSAnJykge1xuICAgICAgICAgICAgbmV3UGFydHMucHVzaChyYXcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSW50ZXJsYWNlIHdpdGggdGhlIGByZXBsYWNlbWVudGAgdmFsdWVcbiAgICAgICAgICBpZiAoaSA8IGxpc3QubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgbmV3UGFydHMucHVzaChyZXBsYWNlbWVudClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgcmV0dXJuIG5ld1BhcnRzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyB0cmFuc2xhdGUgbWV0aG9kXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgd2l0aCB2YWx1ZXMgdGhhdCB3aWxsIGJlIHVzZWQgbGF0ZXIgdG8gcmVwbGFjZSBwbGFjZWhvbGRlcnMgaW4gc3RyaW5nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRyYW5zbGF0ZWQgKGFuZCBpbnRlcnBvbGF0ZWQpXG4gICAqL1xuICB0cmFuc2xhdGUgKGtleSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZUFycmF5KGtleSwgb3B0aW9ucykuam9pbignJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0cmFuc2xhdGlvbiBhbmQgcmV0dXJuIHRoZSB0cmFuc2xhdGVkIGFuZCBpbnRlcnBvbGF0ZWQgcGFydHMgYXMgYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgd2l0aCB2YWx1ZXMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVwbGFjZSBwbGFjZWhvbGRlcnNcbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgdHJhbnNsYXRlZCBhbmQgaW50ZXJwb2xhdGVkIHBhcnRzLCBpbiBvcmRlci5cbiAgICovXG4gIHRyYW5zbGF0ZUFycmF5IChrZXksIG9wdGlvbnMpIHtcbiAgICBpZiAoIWhhcyh0aGlzLmxvY2FsZS5zdHJpbmdzLCBrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgc3RyaW5nOiAke2tleX1gKVxuICAgIH1cblxuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMubG9jYWxlLnN0cmluZ3Nba2V5XVxuICAgIGNvbnN0IGhhc1BsdXJhbEZvcm1zID0gdHlwZW9mIHN0cmluZyA9PT0gJ29iamVjdCdcblxuICAgIGlmIChoYXNQbHVyYWxGb3Jtcykge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuc21hcnRfY291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IHBsdXJhbCA9IHRoaXMubG9jYWxlLnBsdXJhbGl6ZShvcHRpb25zLnNtYXJ0X2NvdW50KVxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZShzdHJpbmdbcGx1cmFsXSwgb3B0aW9ucylcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHVzZSBhIHN0cmluZyB3aXRoIHBsdXJhbCBmb3JtcywgYnV0IG5vIHZhbHVlIHdhcyBnaXZlbiBmb3IgJXtzbWFydF9jb3VudH0nKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmludGVycG9sYXRlKHN0cmluZywgb3B0aW9ucylcbiAgfVxufVxuIiwiY29uc3QgZGF0YVVSSXRvQmxvYiA9IHJlcXVpcmUoJy4vZGF0YVVSSXRvQmxvYicpXG5cbi8qKlxuICogU2F2ZSBhIDxjYW52YXM+IGVsZW1lbnQncyBjb250ZW50IHRvIGEgQmxvYiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYW52YXNUb0Jsb2IgKGNhbnZhcywgdHlwZSwgcXVhbGl0eSkge1xuICBpZiAoY2FudmFzLnRvQmxvYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY2FudmFzLnRvQmxvYihyZXNvbHZlLCB0eXBlLCBxdWFsaXR5KVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIHJldHVybiBkYXRhVVJJdG9CbG9iKGNhbnZhcy50b0RhdGFVUkwodHlwZSwgcXVhbGl0eSksIHt9KVxuICB9KVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkYXRhVVJJdG9CbG9iIChkYXRhVVJJLCBvcHRzLCB0b0ZpbGUpIHtcbiAgLy8gZ2V0IHRoZSBiYXNlNjQgZGF0YVxuICBjb25zdCBkYXRhID0gZGF0YVVSSS5zcGxpdCgnLCcpWzFdXG5cbiAgLy8gdXNlciBtYXkgcHJvdmlkZSBtaW1lIHR5cGUsIGlmIG5vdCBnZXQgaXQgZnJvbSBkYXRhIFVSSVxuICBsZXQgbWltZVR5cGUgPSBvcHRzLm1pbWVUeXBlIHx8IGRhdGFVUkkuc3BsaXQoJywnKVswXS5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF1cblxuICAvLyBkZWZhdWx0IHRvIHBsYWluL3RleHQgaWYgZGF0YSBVUkkgaGFzIG5vIG1pbWVUeXBlXG4gIGlmIChtaW1lVHlwZSA9PSBudWxsKSB7XG4gICAgbWltZVR5cGUgPSAncGxhaW4vdGV4dCdcbiAgfVxuXG4gIGNvbnN0IGJpbmFyeSA9IGF0b2IoZGF0YSlcbiAgY29uc3QgYXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeS5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5LnB1c2goYmluYXJ5LmNoYXJDb2RlQXQoaSkpXG4gIH1cblxuICBsZXQgYnl0ZXNcbiAgdHJ5IHtcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbXBhdC9jb21wYXRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIENvbnZlcnQgdG8gYSBGaWxlP1xuICBpZiAodG9GaWxlKSB7XG4gICAgcmV0dXJuIG5ldyBGaWxlKFtieXRlc10sIG9wdHMubmFtZSB8fCAnJywgeyB0eXBlOiBtaW1lVHlwZSB9KVxuICB9XG5cbiAgcmV0dXJuIG5ldyBCbG9iKFtieXRlc10sIHsgdHlwZTogbWltZVR5cGUgfSlcbn1cbiIsImNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgnbG9kYXNoLnRocm90dGxlJylcblxuZnVuY3Rpb24gX2VtaXRTb2NrZXRQcm9ncmVzcyAodXBsb2FkZXIsIHByb2dyZXNzRGF0YSwgZmlsZSkge1xuICBjb25zdCB7IHByb2dyZXNzLCBieXRlc1VwbG9hZGVkLCBieXRlc1RvdGFsIH0gPSBwcm9ncmVzc0RhdGFcbiAgaWYgKHByb2dyZXNzKSB7XG4gICAgdXBsb2FkZXIudXBweS5sb2coYFVwbG9hZCBwcm9ncmVzczogJHtwcm9ncmVzc31gKVxuICAgIHVwbG9hZGVyLnVwcHkuZW1pdCgndXBsb2FkLXByb2dyZXNzJywgZmlsZSwge1xuICAgICAgdXBsb2FkZXIsXG4gICAgICBieXRlc1VwbG9hZGVkLFxuICAgICAgYnl0ZXNUb3RhbCxcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGUoX2VtaXRTb2NrZXRQcm9ncmVzcywgMzAwLCB7XG4gIGxlYWRpbmc6IHRydWUsXG4gIHRyYWlsaW5nOiB0cnVlLFxufSlcbiIsImNvbnN0IE5ldHdvcmtFcnJvciA9IHJlcXVpcmUoJy4vTmV0d29ya0Vycm9yJylcblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCB3aW5kb3cuZmV0Y2ggdGhhdCB0aHJvd3MgYSBOZXR3b3JrRXJyb3Igd2hlbiBhcHByb3ByaWF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZldGNoV2l0aE5ldHdvcmtFcnJvciAoLi4ub3B0aW9ucykge1xuICByZXR1cm4gZmV0Y2goLi4ub3B0aW9ucylcbiAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKGVycilcbiAgICAgIH1cbiAgICB9KVxufVxuIiwiY29uc3QgaXNET01FbGVtZW50ID0gcmVxdWlyZSgnLi9pc0RPTUVsZW1lbnQnKVxuXG4vKipcbiAqIEZpbmQgb25lIG9yIG1vcmUgRE9NIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl8bnVsbH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaW5kQWxsRE9NRWxlbWVudHMgKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnQpKVxuICAgIHJldHVybiBlbGVtZW50cy5sZW5ndGggPiAwID8gZWxlbWVudHMgOiBudWxsXG4gIH1cblxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGlzRE9NRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiBbZWxlbWVudF1cbiAgfVxufVxuIiwiY29uc3QgaXNET01FbGVtZW50ID0gcmVxdWlyZSgnLi9pc0RPTUVsZW1lbnQnKVxuXG4vKipcbiAqIEZpbmQgYSBET00gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV8c3RyaW5nfSBlbGVtZW50XG4gKiBAcmV0dXJucyB7Tm9kZXxudWxsfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbmRET01FbGVtZW50IChlbGVtZW50LCBjb250ZXh0ID0gZG9jdW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudClcbiAgfVxuXG4gIGlmIChpc0RPTUVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZWxlbWVudFxuICB9XG59XG4iLCIvKipcbiAqIEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXggcG9ueWZpbGwgZm9yIG9sZCBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbmRJbmRleCAoYXJyYXksIHByZWRpY2F0ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpXSkpIHJldHVybiBpXG4gIH1cbiAgcmV0dXJuIC0xXG59XG4iLCIvKipcbiAqIFRha2VzIGEgZmlsZSBvYmplY3QgYW5kIHR1cm5zIGl0IGludG8gZmlsZUlELCBieSBjb252ZXJ0aW5nIGZpbGUubmFtZSB0byBsb3dlcmNhc2UsXG4gKiByZW1vdmluZyBleHRyYSBjaGFyYWN0ZXJzIGFuZCBhZGRpbmcgdHlwZSwgc2l6ZSBhbmQgbGFzdE1vZGlmaWVkXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGZpbGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBmaWxlSURcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZUZpbGVJRCAoZmlsZSkge1xuICAvLyBJdCdzIHRlbXB0aW5nIHRvIGRvIGBbaXRlbXNdLmZpbHRlcihCb29sZWFuKS5qb2luKCctJylgIGhlcmUsIGJ1dCB0aGF0XG4gIC8vIGlzIHNsb3dlciEgc2ltcGxlIHN0cmluZyBjb25jYXRlbmF0aW9uIGlzIGZhc3RcblxuICBsZXQgaWQgPSAndXBweSdcbiAgaWYgKHR5cGVvZiBmaWxlLm5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWQgKz0gYC0ke2VuY29kZUZpbGVuYW1lKGZpbGUubmFtZS50b0xvd2VyQ2FzZSgpKX1gXG4gIH1cblxuICBpZiAoZmlsZS50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZCArPSBgLSR7ZmlsZS50eXBlfWBcbiAgfVxuXG4gIGlmIChmaWxlLm1ldGEgJiYgdHlwZW9mIGZpbGUubWV0YS5yZWxhdGl2ZVBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgaWQgKz0gYC0ke2VuY29kZUZpbGVuYW1lKGZpbGUubWV0YS5yZWxhdGl2ZVBhdGgudG9Mb3dlckNhc2UoKSl9YFxuICB9XG5cbiAgaWYgKGZpbGUuZGF0YS5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZCArPSBgLSR7ZmlsZS5kYXRhLnNpemV9YFxuICB9XG4gIGlmIChmaWxlLmRhdGEubGFzdE1vZGlmaWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZCArPSBgLSR7ZmlsZS5kYXRhLmxhc3RNb2RpZmllZH1gXG4gIH1cblxuICByZXR1cm4gaWRcbn1cblxuZnVuY3Rpb24gZW5jb2RlRmlsZW5hbWUgKG5hbWUpIHtcbiAgbGV0IHN1ZmZpeCA9ICcnXG4gIHJldHVybiBuYW1lLnJlcGxhY2UoL1teQS1aMC05XS9pZywgKGNoYXJhY3RlcikgPT4ge1xuICAgIHN1ZmZpeCArPSBgLSR7ZW5jb2RlQ2hhcmFjdGVyKGNoYXJhY3Rlcil9YFxuICAgIHJldHVybiAnLydcbiAgfSkgKyBzdWZmaXhcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2hhcmFjdGVyIChjaGFyYWN0ZXIpIHtcbiAgcmV0dXJuIGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDMyKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRCeXRlc1JlbWFpbmluZyAoZmlsZVByb2dyZXNzKSB7XG4gIHJldHVybiBmaWxlUHJvZ3Jlc3MuYnl0ZXNUb3RhbCAtIGZpbGVQcm9ncmVzcy5ieXRlc1VwbG9hZGVkXG59XG4iLCJjb25zdCB3ZWJraXRHZXRBc0VudHJ5QXBpID0gcmVxdWlyZSgnLi91dGlscy93ZWJraXRHZXRBc0VudHJ5QXBpL2luZGV4JylcbmNvbnN0IGZhbGxiYWNrQXBpID0gcmVxdWlyZSgnLi91dGlscy9mYWxsYmFja0FwaScpXG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgYXJyYXkgb2YgZHJvcHBlZCBmaWxlcyAoaWYgYSBmb2xkZXIgaXMgZHJvcHBlZCwgYW5kIGJyb3dzZXIgc3VwcG9ydHMgZm9sZGVyIHBhcnNpbmcgLSBwcm9taXNlIHJlc29sdmVzIHRvIHRoZSBmbGF0IGFycmF5IG9mIGFsbCBmaWxlcyBpbiBhbGwgZGlyZWN0b3JpZXMpLlxuICogRWFjaCBmaWxlIGhhcyAucmVsYXRpdmVQYXRoIHByb3AgYXBwZW5kZWQgdG8gaXQgKGUuZy4gXCIvZG9jcy9QcmFndWUvdGlja2V0X2Zyb21fcHJhZ3VlX3RvX3VmYS5wZGZcIikgaWYgYnJvd3NlciBzdXBwb3J0cyBpdC4gT3RoZXJ3aXNlIGl0J3MgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7RGF0YVRyYW5zZmVyfSBkYXRhVHJhbnNmZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxvZ0Ryb3BFcnJvciAtIGEgZnVuY3Rpb24gdGhhdCdzIGNhbGxlZCBldmVyeSB0aW1lIHNvbWUgZm9sZGVyIG9yIHNvbWUgZmlsZSBlcnJvciBvdXQgKGUuZy4gYmVjYXVzZSBvZiB0aGUgZm9sZGVyIG5hbWUgYmVpbmcgdG9vIGxvbmcgb24gV2luZG93cykuIE5vdGljZSB0aGF0IHJlc3VsdGluZyBwcm9taXNlIHdpbGwgYWx3YXlzIGJlIHJlc29sdmVkIGFueXdheS5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBBcnJheTxGaWxlPlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldERyb3BwZWRGaWxlcyAoZGF0YVRyYW5zZmVyLCB7IGxvZ0Ryb3BFcnJvciA9ICgpID0+IHt9IH0gPSB7fSkge1xuICAvLyBHZXQgYWxsIGZpbGVzIGZyb20gYWxsIHN1YmRpcnMuIFdvcmtzIChhdCBsZWFzdCkgaW4gQ2hyb21lLCBNb3ppbGxhLCBhbmQgU2FmYXJpXG4gIGlmIChkYXRhVHJhbnNmZXIuaXRlbXMgJiYgZGF0YVRyYW5zZmVyLml0ZW1zWzBdICYmICd3ZWJraXRHZXRBc0VudHJ5JyBpbiBkYXRhVHJhbnNmZXIuaXRlbXNbMF0pIHtcbiAgICByZXR1cm4gd2Via2l0R2V0QXNFbnRyeUFwaShkYXRhVHJhbnNmZXIsIGxvZ0Ryb3BFcnJvcilcbiAgLy8gT3RoZXJ3aXNlIGp1c3QgcmV0dXJuIGFsbCBmaXJzdC1vcmRlciBmaWxlc1xuICB9XG4gIHJldHVybiBmYWxsYmFja0FwaShkYXRhVHJhbnNmZXIpXG59XG4iLCJjb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnLi4vLi4vdG9BcnJheScpXG5cbi8vIC5maWxlcyBmYWxsYmFjaywgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIGFueSBicm93c2VyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZhbGxiYWNrQXBpIChkYXRhVHJhbnNmZXIpIHtcbiAgY29uc3QgZmlsZXMgPSB0b0FycmF5KGRhdGFUcmFuc2Zlci5maWxlcylcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmaWxlcylcbn1cbiIsIi8qKlxuICogUmVjdXJzaXZlIGZ1bmN0aW9uLCBjYWxscyB0aGUgb3JpZ2luYWwgY2FsbGJhY2soKSB3aGVuIHRoZSBkaXJlY3RvcnkgaXMgZW50aXJlbHkgcGFyc2VkLlxuICpcbiAqIEBwYXJhbSB7RmlsZVN5c3RlbURpcmVjdG9yeVJlYWRlcn0gZGlyZWN0b3J5UmVhZGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvbGRFbnRyaWVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsb2dEcm9wRXJyb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gY2FsbGVkIHdpdGggKFsgYWxsIGZpbGVzIGFuZCBkaXJlY3RvcmllcyBpbiB0aGF0IGRpcmVjdG9yeVJlYWRlciBdKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEZpbGVzQW5kRGlyZWN0b3JpZXNGcm9tRGlyZWN0b3J5IChkaXJlY3RvcnlSZWFkZXIsIG9sZEVudHJpZXMsIGxvZ0Ryb3BFcnJvciwgeyBvblN1Y2Nlc3MgfSkge1xuICBkaXJlY3RvcnlSZWFkZXIucmVhZEVudHJpZXMoXG4gICAgKGVudHJpZXMpID0+IHtcbiAgICAgIGNvbnN0IG5ld0VudHJpZXMgPSBbLi4ub2xkRW50cmllcywgLi4uZW50cmllc11cbiAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgRmlsZVN5c3RlbSBBUEkgc3BlYywgZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnkoKSBtdXN0IGJlIGNhbGxlZCB1bnRpbCBpdCBjYWxscyB0aGUgb25TdWNjZXNzIHdpdGggYW4gZW1wdHkgYXJyYXkuXG4gICAgICBpZiAoZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnkoZGlyZWN0b3J5UmVhZGVyLCBuZXdFbnRyaWVzLCBsb2dEcm9wRXJyb3IsIHsgb25TdWNjZXNzIH0pXG4gICAgICAgIH0sIDApXG4gICAgICAvLyBEb25lIGl0ZXJhdGluZyB0aGlzIHBhcnRpY3VsYXIgZGlyZWN0b3J5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblN1Y2Nlc3MobmV3RW50cmllcylcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSByZXNvbHZlIG9uIGVycm9yIGFueXdheSwgaXQncyBmaW5lIGlmIG9ubHkgb25lIGRpcmVjdG9yeSBjb3VsZG4ndCBiZSBwYXJzZWQhXG4gICAgKGVycm9yKSA9PiB7XG4gICAgICBsb2dEcm9wRXJyb3IoZXJyb3IpXG4gICAgICBvblN1Y2Nlc3Mob2xkRW50cmllcylcbiAgICB9XG4gIClcbn1cbiIsIi8qKlxuICogR2V0IHRoZSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIEZpbGVFbnRyeSNmdWxsUGF0aCwgYmVjYXVzZSBGaWxlI3dlYmtpdFJlbGF0aXZlUGF0aCBpcyBhbHdheXMgJycsIGF0IGxlYXN0IG9uRHJvcC5cbiAqXG4gKiBAcGFyYW0ge0ZpbGVFbnRyeX0gZmlsZUVudHJ5XG4gKlxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSAtIGlmIGZpbGUgaXMgbm90IGluIGEgZm9sZGVyIC0gcmV0dXJuIG51bGwgKHRoaXMgaXMgdG8gYmUgY29uc2lzdGVudCB3aXRoIC5yZWxhdGl2ZVBhdGgtcyBvZiBmaWxlcyBzZWxlY3RlZCBmcm9tIE15IERldmljZSkuIElmIGZpbGUgaXMgaW4gYSBmb2xkZXIgLSByZXR1cm4gaXRzIGZ1bGxQYXRoLCBlLmcuICcvc2ltcHNvbnMvaGkuanBlZycuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UmVsYXRpdmVQYXRoIChmaWxlRW50cnkpIHtcbiAgLy8gZmlsZUVudHJ5LmZ1bGxQYXRoIC0gXCIvc2ltcHNvbnMvaGkuanBlZ1wiIG9yIHVuZGVmaW5lZCAoZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdClcbiAgLy8gZmlsZUVudHJ5Lm5hbWUgLSBcImhpLmpwZWdcIlxuICBpZiAoIWZpbGVFbnRyeS5mdWxsUGF0aCB8fCBmaWxlRW50cnkuZnVsbFBhdGggPT09IGAvJHtmaWxlRW50cnkubmFtZX1gKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICByZXR1cm4gZmlsZUVudHJ5LmZ1bGxQYXRoXG59XG4iLCJjb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnLi4vLi4vLi4vdG9BcnJheScpXG5jb25zdCBnZXRSZWxhdGl2ZVBhdGggPSByZXF1aXJlKCcuL2dldFJlbGF0aXZlUGF0aCcpXG5jb25zdCBnZXRGaWxlc0FuZERpcmVjdG9yaWVzRnJvbURpcmVjdG9yeSA9IHJlcXVpcmUoJy4vZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnknKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdlYmtpdEdldEFzRW50cnlBcGkgKGRhdGFUcmFuc2ZlciwgbG9nRHJvcEVycm9yKSB7XG4gIGNvbnN0IGZpbGVzID0gW11cblxuICBjb25zdCByb290UHJvbWlzZXMgPSBbXVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmVzb2x2ZWQgcHJvbWlzZSwgd2hlbiA6ZmlsZXMgYXJyYXkgaXMgZW5oYW5jZWRcbiAgICpcbiAgICogQHBhcmFtIHsoRmlsZVN5c3RlbUZpbGVFbnRyeXxGaWxlU3lzdGVtRGlyZWN0b3J5RW50cnkpfSBlbnRyeVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBlbXB0eSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiA6ZmlsZXMgaXMgZW5oYW5jZWQgd2l0aCBhIGZpbGVcbiAgICovXG4gIGNvbnN0IGNyZWF0ZVByb21pc2VUb0FkZEZpbGVPclBhcnNlRGlyZWN0b3J5ID0gKGVudHJ5KSA9PlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAvLyBUaGlzIGlzIGEgYmFzZSBjYWxsXG4gICAgICBpZiAoZW50cnkuaXNGaWxlKSB7XG4gICAgICAgIC8vIENyZWF0ZXMgYSBuZXcgRmlsZSBvYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVhZCB0aGUgZmlsZS5cbiAgICAgICAgZW50cnkuZmlsZShcbiAgICAgICAgICAoZmlsZSkgPT4ge1xuICAgICAgICAgICAgZmlsZS5yZWxhdGl2ZVBhdGggPSBnZXRSZWxhdGl2ZVBhdGgoZW50cnkpXG4gICAgICAgICAgICBmaWxlcy5wdXNoKGZpbGUpXG4gICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSByZXNvbHZlIG9uIGVycm9yIGFueXdheSwgaXQncyBmaW5lIGlmIG9ubHkgb25lIGZpbGUgY291bGRuJ3QgYmUgcmVhZCFcbiAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGxvZ0Ryb3BFcnJvcihlcnJvcilcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgLy8gVGhpcyBpcyBhIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICB9IGVsc2UgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdG9yeVJlYWRlciA9IGVudHJ5LmNyZWF0ZVJlYWRlcigpXG4gICAgICAgIGdldEZpbGVzQW5kRGlyZWN0b3JpZXNGcm9tRGlyZWN0b3J5KGRpcmVjdG9yeVJlYWRlciwgW10sIGxvZ0Ryb3BFcnJvciwge1xuICAgICAgICAgIG9uU3VjY2VzczogKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gZW50cmllcy5tYXAoKGVudHJ5KSA9PiBjcmVhdGVQcm9taXNlVG9BZGRGaWxlT3JQYXJzZURpcmVjdG9yeShlbnRyeSkpXG4gICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiByZXNvbHZlKCkpXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gIC8vIEZvciBlYWNoIGRyb3BwZWQgaXRlbSwgLSBtYWtlIHN1cmUgaXQncyBhIGZpbGUvZGlyZWN0b3J5LCBhbmQgc3RhcnQgZGVlcGVuaW5nIGluIVxuICB0b0FycmF5KGRhdGFUcmFuc2Zlci5pdGVtcylcbiAgICAuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBpdGVtLndlYmtpdEdldEFzRW50cnkoKVxuICAgICAgLy8gOmVudHJ5IGNhbiBiZSBudWxsIHdoZW4gd2UgZHJvcCB0aGUgdXJsIGUuZy5cbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICByb290UHJvbWlzZXMucHVzaChjcmVhdGVQcm9taXNlVG9BZGRGaWxlT3JQYXJzZURpcmVjdG9yeShlbnRyeSkpXG4gICAgICB9XG4gICAgfSlcblxuICByZXR1cm4gUHJvbWlzZS5hbGwocm9vdFByb21pc2VzKVxuICAgIC50aGVuKCgpID0+IGZpbGVzKVxufVxuIiwiLyoqXG4gKiBUYWtlcyBhIGZ1bGwgZmlsZW5hbWUgc3RyaW5nIGFuZCByZXR1cm5zIGFuIG9iamVjdCB7bmFtZSwgZXh0ZW5zaW9ufVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmdWxsRmlsZU5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9IHtuYW1lLCBleHRlbnNpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24gKGZ1bGxGaWxlTmFtZSkge1xuICBjb25zdCBsYXN0RG90ID0gZnVsbEZpbGVOYW1lLmxhc3RJbmRleE9mKCcuJylcbiAgLy8gdGhlc2UgY291bnQgYXMgbm8gZXh0ZW5zaW9uOiBcIm5vLWRvdFwiLCBcInRyYWlsaW5nLWRvdC5cIlxuICBpZiAobGFzdERvdCA9PT0gLTEgfHwgbGFzdERvdCA9PT0gZnVsbEZpbGVOYW1lLmxlbmd0aCAtIDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogZnVsbEZpbGVOYW1lLFxuICAgICAgZXh0ZW5zaW9uOiB1bmRlZmluZWQsXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogZnVsbEZpbGVOYW1lLnNsaWNlKDAsIGxhc3REb3QpLFxuICAgIGV4dGVuc2lvbjogZnVsbEZpbGVOYW1lLnNsaWNlKGxhc3REb3QgKyAxKSxcbiAgfVxufVxuIiwiY29uc3QgZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24gPSByZXF1aXJlKCcuL2dldEZpbGVOYW1lQW5kRXh0ZW5zaW9uJylcbmNvbnN0IG1pbWVUeXBlcyA9IHJlcXVpcmUoJy4vbWltZVR5cGVzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRGaWxlVHlwZSAoZmlsZSkge1xuICBsZXQgZmlsZUV4dGVuc2lvbiA9IGZpbGUubmFtZSA/IGdldEZpbGVOYW1lQW5kRXh0ZW5zaW9uKGZpbGUubmFtZSkuZXh0ZW5zaW9uIDogbnVsbFxuICBmaWxlRXh0ZW5zaW9uID0gZmlsZUV4dGVuc2lvbiA/IGZpbGVFeHRlbnNpb24udG9Mb3dlckNhc2UoKSA6IG51bGxcblxuICBpZiAoZmlsZS50eXBlKSB7XG4gICAgLy8gaWYgbWltZSB0eXBlIGlzIHNldCBpbiB0aGUgZmlsZSBvYmplY3QgYWxyZWFkeSwgdXNlIHRoYXRcbiAgICByZXR1cm4gZmlsZS50eXBlXG4gIH0gaWYgKGZpbGVFeHRlbnNpb24gJiYgbWltZVR5cGVzW2ZpbGVFeHRlbnNpb25dKSB7XG4gICAgLy8gZWxzZSwgc2VlIGlmIHdlIGNhbiBtYXAgZXh0ZW5zaW9uIHRvIGEgbWltZSB0eXBlXG4gICAgcmV0dXJuIG1pbWVUeXBlc1tmaWxlRXh0ZW5zaW9uXVxuICB9XG4gIC8vIGlmIGFsbCBmYWlscywgZmFsbCBiYWNrIHRvIGEgZ2VuZXJpYyBieXRlIHN0cmVhbSB0eXBlXG4gIHJldHVybiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xufVxuIiwiLy8gVE9ETyBDaGVjayB3aGljaCB0eXBlcyBhcmUgYWN0dWFsbHkgc3VwcG9ydGVkIGluIGJyb3dzZXJzLiBDaHJvbWUgbGlrZXMgd2VibVxuLy8gZnJvbSBteSB0ZXN0aW5nLCBidXQgd2UgbWF5IG5lZWQgbW9yZS5cbi8vIFdlIGNvdWxkIHVzZSBhIGxpYnJhcnkgYnV0IHRoZXkgdGVuZCB0byBjb250YWluIGRvemVucyBvZiBLQnMgb2YgbWFwcGluZ3MsXG4vLyBtb3N0IG9mIHdoaWNoIHdpbGwgZ28gdW51c2VkLCBzbyBub3Qgc3VyZSBpZiB0aGF0J3Mgd29ydGggaXQuXG5jb25zdCBtaW1lVG9FeHRlbnNpb25zID0ge1xuICAnYXVkaW8vbXAzJzogJ21wMycsXG4gICdhdWRpby9tcDQnOiAnbXA0JyxcbiAgJ2F1ZGlvL29nZyc6ICdvZ2cnLFxuICAnYXVkaW8vd2VibSc6ICd3ZWJtJyxcbiAgJ2ltYWdlL2dpZic6ICdnaWYnLFxuICAnaW1hZ2UvaGVpYyc6ICdoZWljJyxcbiAgJ2ltYWdlL2hlaWYnOiAnaGVpZicsXG4gICdpbWFnZS9qcGVnJzogJ2pwZycsXG4gICdpbWFnZS9wbmcnOiAncG5nJyxcbiAgJ2ltYWdlL3N2Zyt4bWwnOiAnc3ZnJyxcbiAgJ3ZpZGVvL21wNCc6ICdtcDQnLFxuICAndmlkZW8vb2dnJzogJ29ndicsXG4gICd2aWRlby9xdWlja3RpbWUnOiAnbW92JyxcbiAgJ3ZpZGVvL3dlYm0nOiAnd2VibScsXG4gICd2aWRlby94LW1hdHJvc2thJzogJ21rdicsXG4gICd2aWRlby94LW1zdmlkZW8nOiAnYXZpJyxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRGaWxlVHlwZUV4dGVuc2lvbiAobWltZVR5cGUpIHtcbiAgLy8gUmVtb3ZlIHRoZSA7IGJpdCBpbiAndmlkZW8veC1tYXRyb3NrYTtjb2RlY3M9YXZjMSdcbiAgbWltZVR5cGUgPSBtaW1lVHlwZS5yZXBsYWNlKC87LiokLywgJycpXG4gIHJldHVybiBtaW1lVG9FeHRlbnNpb25zW21pbWVUeXBlXSB8fCBudWxsXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNvY2tldEhvc3QgKHVybCkge1xuICAvLyBnZXQgdGhlIGhvc3QgZG9tYWluXG4gIHZhciByZWdleCA9IC9eKD86aHR0cHM/OlxcL1xcL3xcXC9cXC8pPyg/OlteQFxcbl0rQCk/KD86d3d3XFwuKT8oW15cXG5dKykvaVxuICB2YXIgaG9zdCA9IHJlZ2V4LmV4ZWModXJsKVsxXVxuICB2YXIgc29ja2V0UHJvdG9jb2wgPSAvXmh0dHA6XFwvXFwvL2kudGVzdCh1cmwpID8gJ3dzJyA6ICd3c3MnXG5cbiAgcmV0dXJuIGAke3NvY2tldFByb3RvY29sfTovLyR7aG9zdH1gXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNwZWVkIChmaWxlUHJvZ3Jlc3MpIHtcbiAgaWYgKCFmaWxlUHJvZ3Jlc3MuYnl0ZXNVcGxvYWRlZCkgcmV0dXJuIDBcblxuICBjb25zdCB0aW1lRWxhcHNlZCA9IChuZXcgRGF0ZSgpKSAtIGZpbGVQcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gIGNvbnN0IHVwbG9hZFNwZWVkID0gZmlsZVByb2dyZXNzLmJ5dGVzVXBsb2FkZWQgLyAodGltZUVsYXBzZWQgLyAxMDAwKVxuICByZXR1cm4gdXBsb2FkU3BlZWRcbn1cbiIsIi8qKlxuICogR2V0IHRoZSBkZWNsYXJlZCB0ZXh0IGRpcmVjdGlvbiBmb3IgYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGdldFRleHREaXJlY3Rpb24gKGVsZW1lbnQpIHtcbiAgLy8gVGhlcmUgaXMgYW5vdGhlciB3YXkgdG8gZGV0ZXJtaW5lIHRleHQgZGlyZWN0aW9uIHVzaW5nIGdldENvbXB1dGVkU3R5bGUoKSwgYXMgZG9uZSBoZXJlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGVuY2lsLWpzL3RleHQtZGlyZWN0aW9uL2Jsb2IvMmEyMzVjZTk1MDg5YjMxODVhY2VjM2I1MTMxM2NiYmE5MjFiMzgxMS90ZXh0LWRpcmVjdGlvbi5qc1xuICAvL1xuICAvLyBXZSBkbyBub3QgdXNlIHRoYXQgYXBwcm9hY2ggYmVjYXVzZSB3ZSBhcmUgaW50ZXJlc3RlZCBzcGVjaWZpY2FsbHkgaW4gdGhlIF9kZWNsYXJlZF8gdGV4dCBkaXJlY3Rpb24uXG4gIC8vIElmIG5vIHRleHQgZGlyZWN0aW9uIGlzIGRlY2xhcmVkLCB3ZSBoYXZlIHRvIHByb3ZpZGUgb3VyIG93biBleHBsaWNpdCB0ZXh0IGRpcmVjdGlvbiBzbyBvdXJcbiAgLy8gYmlkaXJlY3Rpb25hbCBDU1Mgc3R5bGUgc2hlZXRzIHdvcmsuXG4gIHdoaWxlIChlbGVtZW50ICYmICFlbGVtZW50LmRpcikge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGVcbiAgfVxuICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQuZGlyIDogdW5kZWZpbmVkXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGV4dERpcmVjdGlvblxuIiwiLyoqXG4gKiBSZXR1cm5zIGEgdGltZXN0YW1wIGluIHRoZSBmb3JtYXQgb2YgYGhvdXJzOm1pbnV0ZXM6c2Vjb25kc2BcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRUaW1lU3RhbXAgKCkge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKClcbiAgdmFyIGhvdXJzID0gcGFkKGRhdGUuZ2V0SG91cnMoKS50b1N0cmluZygpKVxuICB2YXIgbWludXRlcyA9IHBhZChkYXRlLmdldE1pbnV0ZXMoKS50b1N0cmluZygpKVxuICB2YXIgc2Vjb25kcyA9IHBhZChkYXRlLmdldFNlY29uZHMoKS50b1N0cmluZygpKVxuICByZXR1cm4gYCR7aG91cnN9OiR7bWludXRlc306JHtzZWNvbmRzfWBcbn1cblxuLyoqXG4gKiBBZGRzIHplcm8gdG8gc3RyaW5ncyBzaG9ydGVyIHRoYW4gdHdvIGNoYXJhY3RlcnNcbiAqL1xuZnVuY3Rpb24gcGFkIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5sZW5ndGggIT09IDIgPyAwICsgc3RyIDogc3RyXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhcyAob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSlcbn1cbiIsIi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgRE9NIGVsZW1lbnQuIER1Y2stdHlwaW5nIGJhc2VkIG9uIGBub2RlVHlwZWAuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RPTUVsZW1lbnQgKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREVcbn1cbiIsIi8qKlxuICogQ2hlY2tzIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIERyYWcgJiBEcm9wIChub3Qgc3VwcG9ydGVkIG9uIG1vYmlsZSBkZXZpY2VzLCBmb3IgZXhhbXBsZSkuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEcmFnRHJvcFN1cHBvcnRlZCAoKSB7XG4gIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgaWYgKCEoJ2RyYWdnYWJsZScgaW4gZGl2KSB8fCAhKCdvbmRyYWdzdGFydCcgaW4gZGl2ICYmICdvbmRyb3AnIGluIGRpdikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmICghKCdGb3JtRGF0YScgaW4gd2luZG93KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKCEoJ0ZpbGVSZWFkZXInIGluIHdpbmRvdykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCJmdW5jdGlvbiBpc05ldHdvcmtFcnJvciAoeGhyKSB7XG4gIGlmICgheGhyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuICh4aHIucmVhZHlTdGF0ZSAhPT0gMCAmJiB4aHIucmVhZHlTdGF0ZSAhPT0gNCkgfHwgeGhyLnN0YXR1cyA9PT0gMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTmV0d29ya0Vycm9yXG4iLCIvKipcbiAqIENoZWNrIGlmIGEgVVJMIHN0cmluZyBpcyBhbiBvYmplY3QgVVJMIGZyb20gYFVSTC5jcmVhdGVPYmplY3RVUkxgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT2JqZWN0VVJMICh1cmwpIHtcbiAgcmV0dXJuIHVybC5pbmRleE9mKCdibG9iOicpID09PSAwXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUHJldmlld1N1cHBvcnRlZCAoZmlsZVR5cGUpIHtcbiAgaWYgKCFmaWxlVHlwZSkgcmV0dXJuIGZhbHNlXG4gIGNvbnN0IGZpbGVUeXBlU3BlY2lmaWMgPSBmaWxlVHlwZS5zcGxpdCgnLycpWzFdXG4gIC8vIGxpc3Qgb2YgaW1hZ2VzIHRoYXQgYnJvd3NlcnMgY2FuIHByZXZpZXdcbiAgaWYgKC9eKGpwZT9nfGdpZnxwbmd8c3ZnfHN2Z1xcK3htbHxibXB8d2VicHxhdmlmKSQvLnRlc3QoZmlsZVR5cGVTcGVjaWZpYykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuIiwiLy8gX19fV2h5IG5vdCBhZGQgdGhlIG1pbWUtdHlwZXMgcGFja2FnZT9cbi8vICAgIEl0J3MgMTkuN2tCIGd6aXBwZWQsIGFuZCB3ZSBvbmx5IG5lZWQgbWltZSB0eXBlcyBmb3Igd2VsbC1rbm93biBleHRlbnNpb25zIChmb3IgZmlsZSBwcmV2aWV3cykuXG4vLyBfX19XaGVyZSB0byB0YWtlIG5ldyBleHRlbnNpb25zIGZyb20/XG4vLyAgICBodHRwczovL2dpdGh1Yi5jb20vanNodHRwL21pbWUtZGIvYmxvYi9tYXN0ZXIvZGIuanNvblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWQ6ICd0ZXh0L21hcmtkb3duJyxcbiAgbWFya2Rvd246ICd0ZXh0L21hcmtkb3duJyxcbiAgbXA0OiAndmlkZW8vbXA0JyxcbiAgbXAzOiAnYXVkaW8vbXAzJyxcbiAgc3ZnOiAnaW1hZ2Uvc3ZnK3htbCcsXG4gIGpwZzogJ2ltYWdlL2pwZWcnLFxuICBwbmc6ICdpbWFnZS9wbmcnLFxuICBnaWY6ICdpbWFnZS9naWYnLFxuICBoZWljOiAnaW1hZ2UvaGVpYycsXG4gIGhlaWY6ICdpbWFnZS9oZWlmJyxcbiAgeWFtbDogJ3RleHQveWFtbCcsXG4gIHltbDogJ3RleHQveWFtbCcsXG4gIGNzdjogJ3RleHQvY3N2JyxcbiAgdHN2OiAndGV4dC90YWItc2VwYXJhdGVkLXZhbHVlcycsXG4gIHRhYjogJ3RleHQvdGFiLXNlcGFyYXRlZC12YWx1ZXMnLFxuICBhdmk6ICd2aWRlby94LW1zdmlkZW8nLFxuICBta3M6ICd2aWRlby94LW1hdHJvc2thJyxcbiAgbWt2OiAndmlkZW8veC1tYXRyb3NrYScsXG4gIG1vdjogJ3ZpZGVvL3F1aWNrdGltZScsXG4gIGRvYzogJ2FwcGxpY2F0aW9uL21zd29yZCcsXG4gIGRvY206ICdhcHBsaWNhdGlvbi92bmQubXMtd29yZC5kb2N1bWVudC5tYWNyb2VuYWJsZWQuMTInLFxuICBkb2N4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICBkb3Q6ICdhcHBsaWNhdGlvbi9tc3dvcmQnLFxuICBkb3RtOiAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmQudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyJyxcbiAgZG90eDogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnRlbXBsYXRlJyxcbiAgeGxhOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgeGxhbTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5hZGRpbi5tYWNyb2VuYWJsZWQuMTInLFxuICB4bGM6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB4bGY6ICdhcHBsaWNhdGlvbi94LXhsaWZmK3htbCcsXG4gIHhsbTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsXG4gIHhsczogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsXG4gIHhsc2I6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQuYmluYXJ5Lm1hY3JvZW5hYmxlZC4xMicsXG4gIHhsc206ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQubWFjcm9lbmFibGVkLjEyJyxcbiAgeGxzeDogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0JyxcbiAgeGx0OiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgeGx0bTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTInLFxuICB4bHR4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwudGVtcGxhdGUnLFxuICB4bHc6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB0eHQ6ICd0ZXh0L3BsYWluJyxcbiAgdGV4dDogJ3RleHQvcGxhaW4nLFxuICBjb25mOiAndGV4dC9wbGFpbicsXG4gIGxvZzogJ3RleHQvcGxhaW4nLFxuICBwZGY6ICdhcHBsaWNhdGlvbi9wZGYnLFxuICB6aXA6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAnN3onOiAnYXBwbGljYXRpb24veC03ei1jb21wcmVzc2VkJyxcbiAgcmFyOiAnYXBwbGljYXRpb24veC1yYXItY29tcHJlc3NlZCcsXG4gIHRhcjogJ2FwcGxpY2F0aW9uL3gtdGFyJyxcbiAgZ3o6ICdhcHBsaWNhdGlvbi9nemlwJyxcbiAgZG1nOiAnYXBwbGljYXRpb24veC1hcHBsZS1kaXNraW1hZ2UnLFxufVxuIiwiY29uc3Qgc2Vjb25kc1RvVGltZSA9IHJlcXVpcmUoJy4vc2Vjb25kc1RvVGltZScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJldHR5RVRBIChzZWNvbmRzKSB7XG4gIGNvbnN0IHRpbWUgPSBzZWNvbmRzVG9UaW1lKHNlY29uZHMpXG5cbiAgLy8gT25seSBkaXNwbGF5IGhvdXJzIGFuZCBtaW51dGVzIGlmIHRoZXkgYXJlIGdyZWF0ZXIgdGhhbiAwIGJ1dCBhbHdheXNcbiAgLy8gZGlzcGxheSBtaW51dGVzIGlmIGhvdXJzIGlzIGJlaW5nIGRpc3BsYXllZFxuICAvLyBEaXNwbGF5IGEgbGVhZGluZyB6ZXJvIGlmIHRoZSB0aGVyZSBpcyBhIHByZWNlZGluZyB1bml0OiAxbSAwNXMsIGJ1dCA1c1xuICBjb25zdCBob3Vyc1N0ciA9IHRpbWUuaG91cnMgPyBgJHt0aW1lLmhvdXJzfWggYCA6ICcnXG4gIGNvbnN0IG1pbnV0ZXNWYWwgPSB0aW1lLmhvdXJzID8gKGAwJHt0aW1lLm1pbnV0ZXN9YCkuc3Vic3RyKC0yKSA6IHRpbWUubWludXRlc1xuICBjb25zdCBtaW51dGVzU3RyID0gbWludXRlc1ZhbCA/IGAke21pbnV0ZXNWYWx9bWAgOiAnJ1xuICBjb25zdCBzZWNvbmRzVmFsID0gbWludXRlc1ZhbCA/IChgMCR7dGltZS5zZWNvbmRzfWApLnN1YnN0cigtMikgOiB0aW1lLnNlY29uZHNcbiAgY29uc3Qgc2Vjb25kc1N0ciA9IHRpbWUuaG91cnMgPyAnJyA6IChtaW51dGVzVmFsID8gYCAke3NlY29uZHNWYWx9c2AgOiBgJHtzZWNvbmRzVmFsfXNgKVxuXG4gIHJldHVybiBgJHtob3Vyc1N0cn0ke21pbnV0ZXNTdHJ9JHtzZWNvbmRzU3RyfWBcbn1cbiIsImNvbnN0IGdldEZpbGVOYW1lQW5kRXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9nZXRGaWxlTmFtZUFuZEV4dGVuc2lvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVtb3RlRmlsZU9ialRvTG9jYWwgKGZpbGUpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5maWxlLFxuICAgIHR5cGU6IGZpbGUubWltZVR5cGUsXG4gICAgZXh0ZW5zaW9uOiBmaWxlLm5hbWUgPyBnZXRGaWxlTmFtZUFuZEV4dGVuc2lvbihmaWxlLm5hbWUpLmV4dGVuc2lvbiA6IG51bGwsXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2Vjb25kc1RvVGltZSAocmF3U2Vjb25kcykge1xuICBjb25zdCBob3VycyA9IE1hdGguZmxvb3IocmF3U2Vjb25kcyAvIDM2MDApICUgMjRcbiAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IocmF3U2Vjb25kcyAvIDYwKSAlIDYwXG4gIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKHJhd1NlY29uZHMgJSA2MClcblxuICByZXR1cm4geyBob3VycywgbWludXRlcywgc2Vjb25kcyB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZSAocHJvbWlzZXMpIHtcbiAgY29uc3QgcmVzb2x1dGlvbnMgPSBbXVxuICBjb25zdCByZWplY3Rpb25zID0gW11cbiAgZnVuY3Rpb24gcmVzb2x2ZWQgKHZhbHVlKSB7XG4gICAgcmVzb2x1dGlvbnMucHVzaCh2YWx1ZSlcbiAgfVxuICBmdW5jdGlvbiByZWplY3RlZCAoZXJyb3IpIHtcbiAgICByZWplY3Rpb25zLnB1c2goZXJyb3IpXG4gIH1cblxuICBjb25zdCB3YWl0ID0gUHJvbWlzZS5hbGwoXG4gICAgcHJvbWlzZXMubWFwKChwcm9taXNlKSA9PiBwcm9taXNlLnRoZW4ocmVzb2x2ZWQsIHJlamVjdGVkKSlcbiAgKVxuXG4gIHJldHVybiB3YWl0LnRoZW4oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzZnVsOiByZXNvbHV0aW9ucyxcbiAgICAgIGZhaWxlZDogcmVqZWN0aW9ucyxcbiAgICB9XG4gIH0pXG59XG4iLCIvKipcbiAqIENvbnZlcnRzIGxpc3QgaW50byBhcnJheVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QgfHwgW10sIDApXG59XG4iLCIvKipcbiAqIFRydW5jYXRlcyBhIHN0cmluZyB0byB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGNoYXJzIChtYXhMZW5ndGgpIGJ5IGluc2VydGluZyAnLi4uJyBpbiB0aGUgbWlkZGxlIG9mIHRoYXQgc3RyaW5nLlxuICogUGFydGlhbGx5IHRha2VuIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU3MjMyNzQvMzE5MjQ3MC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gc3RyaW5nIHRvIGJlIHRydW5jYXRlZFxuICogQHBhcmFtIHtudW1iZXJ9IG1heExlbmd0aCAtIG1heGltdW0gc2l6ZSBvZiB0aGUgcmVzdWx0aW5nIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cnVuY2F0ZVN0cmluZyAoc3RyaW5nLCBtYXhMZW5ndGgpIHtcbiAgY29uc3Qgc2VwYXJhdG9yID0gJy4uLidcblxuICAvLyBSZXR1cm4gb3JpZ2luYWwgc3RyaW5nIGlmIGl0J3MgYWxyZWFkeSBzaG9ydGVyIHRoYW4gbWF4TGVuZ3RoXG4gIGlmIChzdHJpbmcubGVuZ3RoIDw9IG1heExlbmd0aCkge1xuICAgIHJldHVybiBzdHJpbmdcbiAgLy8gUmV0dXJuIHRydW5jYXRlZCBzdWJzdHJpbmcgd2l0aG91dCAnLi4uJyBpZiBzdHJpbmcgY2FuJ3QgYmUgbWVhbmluZ2Z1bGx5IHRydW5jYXRlZFxuICB9IGlmIChtYXhMZW5ndGggPD0gc2VwYXJhdG9yLmxlbmd0aCkge1xuICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIG1heExlbmd0aClcbiAgLy8gUmV0dXJuIHRydW5jYXRlZCBzdHJpbmcgZGl2aWRlZCBpbiBoYWxmIGJ5ICcuLi4nXG4gIH1cbiAgY29uc3QgY2hhcnNUb1Nob3cgPSBtYXhMZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoXG4gIGNvbnN0IGZyb250Q2hhcnMgPSBNYXRoLmNlaWwoY2hhcnNUb1Nob3cgLyAyKVxuICBjb25zdCBiYWNrQ2hhcnMgPSBNYXRoLmZsb29yKGNoYXJzVG9TaG93IC8gMilcblxuICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCBmcm9udENoYXJzKSArIHNlcGFyYXRvciArIHN0cmluZy5zdWJzdHIoc3RyaW5nLmxlbmd0aCAtIGJhY2tDaGFycylcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvd2ViY2FtXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJVcHB5IHBsdWdpbiB0aGF0IHRha2VzIHBob3RvcyBvciByZWNvcmRzIHZpZGVvcyB1c2luZyB0aGUgZGV2aWNlJ3MgY2FtZXJhLlwiLFxuICBcInZlcnNpb25cIjogXCIxLjguMTJcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInN0eWxlXCI6IFwiZGlzdC9zdHlsZS5taW4uY3NzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcIndlYmNhbVwiLFxuICAgIFwicGljdHVyZVwiLFxuICAgIFwicGhvdG9cIixcbiAgICBcInZpZGVvXCIsXG4gICAgXCJyZWNvcmRcIixcbiAgICBcIm1lZGlhcmVjb3JkZXJcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgZmlsbD1cIiMwMDk3RENcIiB3aWR0aD1cIjY2XCIgaGVpZ2h0PVwiNTVcIiB2aWV3Qm94PVwiMCAwIDY2IDU1XCI+XG4gICAgICA8cGF0aCBkPVwiTTU3LjMgOC40MzNjNC41OSAwIDguMSAzLjUxIDguMSA4LjF2MjkuN2MwIDQuNTktMy41MSA4LjEtOC4xIDguMUg4LjdjLTQuNTkgMC04LjEtMy41MS04LjEtOC4xdi0yOS43YzAtNC41OSAzLjUxLTguMSA4LjEtOC4xaDkuNDVsNC41OS03LjAyYy41NC0uNTQgMS4zNS0xLjA4IDIuMTYtMS4wOGgxNi4yYy44MSAwIDEuNjIuNTQgMi4xNiAxLjA4bDQuNTkgNy4wMmg5LjQ1ek0zMyAxNC42NGMtOC42MiAwLTE1LjM5MyA2Ljc3My0xNS4zOTMgMTUuMzkzIDAgOC42MiA2Ljc3MyAxNS4zOTMgMTUuMzkzIDE1LjM5MyA4LjYyIDAgMTUuMzkzLTYuNzczIDE1LjM5My0xNS4zOTMgMC04LjYyLTYuNzczLTE1LjM5My0xNS4zOTMtMTUuMzkzek0zMyA0MGMtNS42NDggMC05Ljk2Ni00LjMxOS05Ljk2Ni05Ljk2NyAwLTUuNjQ3IDQuMzE4LTkuOTY2IDkuOTY2LTkuOTY2czkuOTY2IDQuMzE5IDkuOTY2IDkuOTY2QzQyLjk2NiAzNS42ODEgMzguNjQ4IDQwIDMzIDQwelwiIGZpbGxSdWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIGpzeC1hMTF5L21lZGlhLWhhcy1jYXB0aW9uICovXG5jb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IFNuYXBzaG90QnV0dG9uID0gcmVxdWlyZSgnLi9TbmFwc2hvdEJ1dHRvbicpXG5jb25zdCBSZWNvcmRCdXR0b24gPSByZXF1aXJlKCcuL1JlY29yZEJ1dHRvbicpXG5jb25zdCBSZWNvcmRpbmdMZW5ndGggPSByZXF1aXJlKCcuL1JlY29yZGluZ0xlbmd0aCcpXG5jb25zdCBWaWRlb1NvdXJjZVNlbGVjdCA9IHJlcXVpcmUoJy4vVmlkZW9Tb3VyY2VTZWxlY3QnKVxuY29uc3QgU3VibWl0QnV0dG9uID0gcmVxdWlyZSgnLi9TdWJtaXRCdXR0b24nKVxuY29uc3QgRGlzY2FyZEJ1dHRvbiA9IHJlcXVpcmUoJy4vRGlzY2FyZEJ1dHRvbicpXG5cbmZ1bmN0aW9uIGlzTW9kZUF2YWlsYWJsZSAobW9kZXMsIG1vZGUpIHtcbiAgcmV0dXJuIG1vZGVzLmluZGV4T2YobW9kZSkgIT09IC0xXG59XG5cbmNsYXNzIENhbWVyYVNjcmVlbiBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICBjb25zdCB7IG9uRm9jdXMgfSA9IHRoaXMucHJvcHNcbiAgICBvbkZvY3VzKClcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICBjb25zdCB7IG9uU3RvcCB9ID0gdGhpcy5wcm9wc1xuICAgIG9uU3RvcCgpXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNyYyxcbiAgICAgIHJlY29yZGVkVmlkZW8sXG4gICAgICByZWNvcmRpbmcsXG4gICAgICBtb2RlcyxcbiAgICAgIHN1cHBvcnRzUmVjb3JkaW5nLFxuICAgICAgdmlkZW9Tb3VyY2VzLFxuICAgICAgc2hvd1ZpZGVvU291cmNlRHJvcGRvd24sXG4gICAgICBzaG93UmVjb3JkaW5nTGVuZ3RoLFxuICAgICAgb25TdWJtaXQsXG4gICAgICBpMThuLFxuICAgICAgbWlycm9yLFxuICAgICAgb25TbmFwc2hvdCxcbiAgICAgIG9uU3RhcnRSZWNvcmRpbmcsXG4gICAgICBvblN0b3BSZWNvcmRpbmcsXG4gICAgICBvbkRpc2NhcmRSZWNvcmRlZFZpZGVvLFxuICAgICAgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kcyxcbiAgICB9ID0gdGhpcy5wcm9wc1xuXG4gICAgY29uc3QgaGFzUmVjb3JkZWRWaWRlbyA9ICEhcmVjb3JkZWRWaWRlb1xuICAgIGNvbnN0IHNob3VsZFNob3dSZWNvcmRCdXR0b24gPSAhaGFzUmVjb3JkZWRWaWRlbyAmJiBzdXBwb3J0c1JlY29yZGluZyAmJiAoXG4gICAgICBpc01vZGVBdmFpbGFibGUobW9kZXMsICd2aWRlby1vbmx5JylcbiAgICAgIHx8IGlzTW9kZUF2YWlsYWJsZShtb2RlcywgJ2F1ZGlvLW9ubHknKVxuICAgICAgfHwgaXNNb2RlQXZhaWxhYmxlKG1vZGVzLCAndmlkZW8tYXVkaW8nKVxuICAgIClcbiAgICBjb25zdCBzaG91bGRTaG93U25hcHNob3RCdXR0b24gPSAhaGFzUmVjb3JkZWRWaWRlbyAmJiBpc01vZGVBdmFpbGFibGUobW9kZXMsICdwaWN0dXJlJylcbiAgICBjb25zdCBzaG91bGRTaG93UmVjb3JkaW5nTGVuZ3RoID0gc3VwcG9ydHNSZWNvcmRpbmcgJiYgc2hvd1JlY29yZGluZ0xlbmd0aFxuICAgIGNvbnN0IHNob3VsZFNob3dWaWRlb1NvdXJjZURyb3Bkb3duID0gc2hvd1ZpZGVvU291cmNlRHJvcGRvd24gJiYgdmlkZW9Tb3VyY2VzICYmIHZpZGVvU291cmNlcy5sZW5ndGggPiAxXG5cbiAgICBjb25zdCB2aWRlb1Byb3BzID0ge1xuICAgICAgcGxheXNpbmxpbmU6IHRydWUsXG4gICAgfVxuXG4gICAgaWYgKHJlY29yZGVkVmlkZW8pIHtcbiAgICAgIHZpZGVvUHJvcHMubXV0ZWQgPSBmYWxzZVxuICAgICAgdmlkZW9Qcm9wcy5jb250cm9scyA9IHRydWVcbiAgICAgIHZpZGVvUHJvcHMuc3JjID0gcmVjb3JkZWRWaWRlb1xuXG4gICAgICAvLyByZXNldCBzcmNPYmplY3QgaW4gZG9tLiBJZiBub3QgcmVzZXR0ZWQsIHN0cmVhbSBzdGlja3MgaW4gZWxlbWVudFxuICAgICAgaWYgKHRoaXMudmlkZW9FbGVtZW50KSB7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnNyY09iamVjdCA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb1Byb3BzLm11dGVkID0gdHJ1ZVxuICAgICAgdmlkZW9Qcm9wcy5hdXRvcGxheSA9IHRydWVcbiAgICAgIHZpZGVvUHJvcHMuc3JjT2JqZWN0ID0gc3JjXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweSB1cHB5LVdlYmNhbS1jb250YWluZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVdlYmNhbS12aWRlb0NvbnRhaW5lclwiPlxuICAgICAgICAgIDx2aWRlb1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJldHVybi1hc3NpZ24gKi9cbiAgICAgICAgICAgIHJlZj17KHZpZGVvRWxlbWVudCkgPT4gKHRoaXMudmlkZW9FbGVtZW50ID0gdmlkZW9FbGVtZW50KX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17YHVwcHktV2ViY2FtLXZpZGVvICAke21pcnJvciA/ICd1cHB5LVdlYmNhbS12aWRlby0tbWlycm9yZWQnIDogJyd9YH1cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtcHJvcHMtbm8tc3ByZWFkaW5nICovXG4gICAgICAgICAgICB7Li4udmlkZW9Qcm9wc31cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVdlYmNhbS1mb290ZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLXZpZGVvU291cmNlQ29udGFpbmVyXCI+XG4gICAgICAgICAgICB7c2hvdWxkU2hvd1ZpZGVvU291cmNlRHJvcGRvd25cbiAgICAgICAgICAgICAgPyBWaWRlb1NvdXJjZVNlbGVjdCh0aGlzLnByb3BzKVxuICAgICAgICAgICAgICA6IG51bGx9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LVdlYmNhbS1idXR0b25Db250YWluZXJcIj5cbiAgICAgICAgICAgIHtzaG91bGRTaG93U25hcHNob3RCdXR0b24gJiYgPFNuYXBzaG90QnV0dG9uIG9uU25hcHNob3Q9e29uU25hcHNob3R9IGkxOG49e2kxOG59IC8+fVxuXG4gICAgICAgICAgICB7c2hvdWxkU2hvd1JlY29yZEJ1dHRvbiAmJiAoXG4gICAgICAgICAgICAgIDxSZWNvcmRCdXR0b25cbiAgICAgICAgICAgICAgICByZWNvcmRpbmc9e3JlY29yZGluZ31cbiAgICAgICAgICAgICAgICBvblN0YXJ0UmVjb3JkaW5nPXtvblN0YXJ0UmVjb3JkaW5nfVxuICAgICAgICAgICAgICAgIG9uU3RvcFJlY29yZGluZz17b25TdG9wUmVjb3JkaW5nfVxuICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApfVxuXG4gICAgICAgICAgICB7aGFzUmVjb3JkZWRWaWRlbyAmJiA8U3VibWl0QnV0dG9uIG9uU3VibWl0PXtvblN1Ym1pdH0gaTE4bj17aTE4bn0gLz59XG5cbiAgICAgICAgICAgIHtoYXNSZWNvcmRlZFZpZGVvICYmIDxEaXNjYXJkQnV0dG9uIG9uRGlzY2FyZD17b25EaXNjYXJkUmVjb3JkZWRWaWRlb30gaTE4bj17aTE4bn0gLz59XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICB7c2hvdWxkU2hvd1JlY29yZGluZ0xlbmd0aCAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLXJlY29yZGluZ0xlbmd0aFwiPlxuICAgICAgICAgICAgICA8UmVjb3JkaW5nTGVuZ3RoIHJlY29yZGluZ0xlbmd0aFNlY29uZHM9e3JlY29yZGluZ0xlbmd0aFNlY29uZHN9IGkxOG49e2kxOG59IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhbWVyYVNjcmVlblxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5mdW5jdGlvbiBEaXNjYXJkQnV0dG9uICh7IG9uRGlzY2FyZCwgaTE4biB9KSB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1XZWJjYW0tYnV0dG9uXCJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgdGl0bGU9e2kxOG4oJ2Rpc2NhcmRSZWNvcmRlZEZpbGUnKX1cbiAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ2Rpc2NhcmRSZWNvcmRlZEZpbGUnKX1cbiAgICAgIG9uQ2xpY2s9e29uRGlzY2FyZH1cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICA8c3ZnXG4gICAgICAgIHdpZHRoPVwiMTNcIlxuICAgICAgICBoZWlnaHQ9XCIxM1wiXG4gICAgICAgIHZpZXdCb3g9XCIwIDAgMTMgMTNcIlxuICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgICBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiXG4gICAgICA+XG4gICAgICAgIDxnIGZpbGw9XCIjRkZGXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHBhdGggZD1cIk0uNDk2IDExLjM2N0wxMS4xMDMuNzZsMS40MTQgMS40MTRMMS45MTEgMTIuNzgxelwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMS4xMDQgMTIuNzgyTC40OTcgMi4xNzUgMS45MTEuNzZsMTAuNjA3IDEwLjYwNnpcIiAvPlxuICAgICAgICA8L2c+XG4gICAgICA8L3N2Zz5cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc2NhcmRCdXR0b25cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLXBlcm1pc3NvbnNcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1XZWJjYW0tcGVybWlzc29uc0ljb25cIj57cHJvcHMuaWNvbigpfTwvZGl2PlxuICAgICAgPGgxIGNsYXNzTmFtZT1cInVwcHktV2ViY2FtLXRpdGxlXCI+e3Byb3BzLmhhc0NhbWVyYSA/IHByb3BzLmkxOG4oJ2FsbG93QWNjZXNzVGl0bGUnKSA6IHByb3BzLmkxOG4oJ25vQ2FtZXJhVGl0bGUnKX08L2gxPlxuICAgICAgPHA+e3Byb3BzLmhhc0NhbWVyYSA/IHByb3BzLmkxOG4oJ2FsbG93QWNjZXNzRGVzY3JpcHRpb24nKSA6IHByb3BzLmkxOG4oJ25vQ2FtZXJhRGVzY3JpcHRpb24nKX08L3A+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSZWNvcmRCdXR0b24gKHsgcmVjb3JkaW5nLCBvblN0YXJ0UmVjb3JkaW5nLCBvblN0b3BSZWNvcmRpbmcsIGkxOG4gfSkge1xuICBpZiAocmVjb3JkaW5nKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1XZWJjYW0tYnV0dG9uXCJcbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIHRpdGxlPXtpMThuKCdzdG9wUmVjb3JkaW5nJyl9XG4gICAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3N0b3BSZWNvcmRpbmcnKX1cbiAgICAgICAgb25DbGljaz17b25TdG9wUmVjb3JkaW5nfVxuICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICA+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzc05hbWU9XCJ1cHB5LWMtaWNvblwiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgdmlld0JveD1cIjAgMCAxMDAgMTAwXCI+XG4gICAgICAgICAgPHJlY3QgeD1cIjE1XCIgeT1cIjE1XCIgd2lkdGg9XCI3MFwiIGhlaWdodD1cIjcwXCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktV2ViY2FtLWJ1dHRvblwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIHRpdGxlPXtpMThuKCdzdGFydFJlY29yZGluZycpfVxuICAgICAgYXJpYS1sYWJlbD17aTE4bignc3RhcnRSZWNvcmRpbmcnKX1cbiAgICAgIG9uQ2xpY2s9e29uU3RhcnRSZWNvcmRpbmd9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIj5cbiAgICAgICAgPGNpcmNsZSBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCI0MFwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgZm9ybWF0U2Vjb25kcyA9IHJlcXVpcmUoJy4vZm9ybWF0U2Vjb25kcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUmVjb3JkaW5nTGVuZ3RoICh7IHJlY29yZGluZ0xlbmd0aFNlY29uZHMsIGkxOG4gfSkge1xuICBjb25zdCBmb3JtYXR0ZWRSZWNvcmRpbmdMZW5ndGhTZWNvbmRzID0gZm9ybWF0U2Vjb25kcyhyZWNvcmRpbmdMZW5ndGhTZWNvbmRzKVxuXG4gIHJldHVybiAoXG4gICAgPHNwYW4gYXJpYS1sYWJlbD17aTE4bigncmVjb3JkaW5nTGVuZ3RoJywgeyByZWNvcmRpbmdfbGVuZ3RoOiBmb3JtYXR0ZWRSZWNvcmRpbmdMZW5ndGhTZWNvbmRzIH0pfT5cbiAgICAgIHtmb3JtYXR0ZWRSZWNvcmRpbmdMZW5ndGhTZWNvbmRzfVxuICAgIDwvc3Bhbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgQ2FtZXJhSWNvbiA9IHJlcXVpcmUoJy4vQ2FtZXJhSWNvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gKHsgb25TbmFwc2hvdCwgaTE4biB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1XZWJjYW0tYnV0dG9uIHVwcHktV2ViY2FtLWJ1dHRvbi0tcGljdHVyZVwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIHRpdGxlPXtpMThuKCd0YWtlUGljdHVyZScpfVxuICAgICAgYXJpYS1sYWJlbD17aTE4bigndGFrZVBpY3R1cmUnKX1cbiAgICAgIG9uQ2xpY2s9e29uU25hcHNob3R9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAge0NhbWVyYUljb24oKX1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5mdW5jdGlvbiBTdWJtaXRCdXR0b24gKHsgb25TdWJtaXQsIGkxOG4gfSkge1xuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzTmFtZT1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktV2ViY2FtLWJ1dHRvbiB1cHB5LVdlYmNhbS1idXR0b24tLXN1Ym1pdFwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIHRpdGxlPXtpMThuKCdzdWJtaXRSZWNvcmRlZEZpbGUnKX1cbiAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3N1Ym1pdFJlY29yZGVkRmlsZScpfVxuICAgICAgb25DbGljaz17b25TdWJtaXR9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAgPHN2Z1xuICAgICAgICB3aWR0aD1cIjEyXCJcbiAgICAgICAgaGVpZ2h0PVwiOVwiXG4gICAgICAgIHZpZXdCb3g9XCIwIDAgMTIgOVwiXG4gICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgICAgIGNsYXNzTmFtZT1cInVwcHktYy1pY29uXCJcbiAgICAgID5cbiAgICAgICAgPHBhdGggZmlsbD1cIiNmZmZcIiBmaWxsUnVsZT1cIm5vbnplcm9cIiBkPVwiTTEwLjY2IDBMMTIgMS4zMSA0LjEzNiA5IDAgNC45NTZsMS4zNC0xLjMxTDQuMTM2IDYuMzh6XCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3VibWl0QnV0dG9uXG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gKHsgY3VycmVudERldmljZUlkLCB2aWRlb1NvdXJjZXMsIG9uQ2hhbmdlVmlkZW9Tb3VyY2UgfSkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXBweS1XZWJjYW0tdmlkZW9Tb3VyY2VcIj5cbiAgICAgIDxzZWxlY3RcbiAgICAgICAgY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktV2ViY2FtLXZpZGVvU291cmNlLXNlbGVjdFwiXG4gICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+IHsgb25DaGFuZ2VWaWRlb1NvdXJjZShldmVudC50YXJnZXQudmFsdWUpIH19XG4gICAgICA+XG4gICAgICAgIHt2aWRlb1NvdXJjZXMubWFwKCh2aWRlb1NvdXJjZSkgPT4gKFxuICAgICAgICAgIDxvcHRpb25cbiAgICAgICAgICAgIGtleT17dmlkZW9Tb3VyY2UuZGV2aWNlSWR9XG4gICAgICAgICAgICB2YWx1ZT17dmlkZW9Tb3VyY2UuZGV2aWNlSWR9XG4gICAgICAgICAgICBzZWxlY3RlZD17dmlkZW9Tb3VyY2UuZGV2aWNlSWQgPT09IGN1cnJlbnREZXZpY2VJZH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7dmlkZW9Tb3VyY2UubGFiZWx9XG4gICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgICkpfVxuICAgICAgPC9zZWxlY3Q+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsIi8qKlxuICogVGFrZXMgYW4gSW50ZWdlciB2YWx1ZSBvZiBzZWNvbmRzIChlLmcuIDgzKSBhbmQgY29udmVydHMgaXQgaW50byBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdHRlZCBzdHJpbmcgKGUuZy4gJzE6MjMnKS5cbiAqXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHNlY29uZHNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBmb3JtYXR0ZWQgc2Vjb25kcyAoZS5nLiAnMToyMycgZm9yIDEgbWludXRlIGFuZCAyMyBzZWNvbmRzKVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JtYXRTZWNvbmRzIChzZWNvbmRzKSB7XG4gIHJldHVybiBgJHtNYXRoLmZsb29yKFxuICAgIHNlY29uZHMgLyA2MFxuICApfToke1N0cmluZyhzZWNvbmRzICUgNjApLnBhZFN0YXJ0KDIsIDApfWBcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IFRyYW5zbGF0b3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvVHJhbnNsYXRvcicpXG5jb25zdCBnZXRGaWxlVHlwZUV4dGVuc2lvbiA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRGaWxlVHlwZUV4dGVuc2lvbicpXG5jb25zdCBtaW1lVHlwZXMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvbWltZVR5cGVzJylcbmNvbnN0IGNhbnZhc1RvQmxvYiA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9jYW52YXNUb0Jsb2InKVxuY29uc3Qgc3VwcG9ydHNNZWRpYVJlY29yZGVyID0gcmVxdWlyZSgnLi9zdXBwb3J0c01lZGlhUmVjb3JkZXInKVxuY29uc3QgQ2FtZXJhSWNvbiA9IHJlcXVpcmUoJy4vQ2FtZXJhSWNvbicpXG5jb25zdCBDYW1lcmFTY3JlZW4gPSByZXF1aXJlKCcuL0NhbWVyYVNjcmVlbicpXG5jb25zdCBQZXJtaXNzaW9uc1NjcmVlbiA9IHJlcXVpcmUoJy4vUGVybWlzc2lvbnNTY3JlZW4nKVxuY29uc3QgcGFja2FnZUpzb25WZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIE1JTUUgdHlwZSBvciBmaWxlIGV4dGVuc2lvbiBpbnRvIGEgTUlNRSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlVHlwZSAtIE1JTUUgdHlwZSBvciBhIGZpbGUgZXh0ZW5zaW9uIHByZWZpeGVkIHdpdGggYC5gLlxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFRoZSBNSU1FIHR5cGUgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIGZpbGVUeXBlIGlzIGFuIGV4dGVuc2lvbiBhbmQgaXMgbm90IGtub3duLlxuICovXG5mdW5jdGlvbiB0b01pbWVUeXBlIChmaWxlVHlwZSkge1xuICBpZiAoZmlsZVR5cGVbMF0gPT09ICcuJykge1xuICAgIHJldHVybiBtaW1lVHlwZXNbZmlsZVR5cGUuc2xpY2UoMSldXG4gIH1cbiAgcmV0dXJuIGZpbGVUeXBlXG59XG5cbi8qKlxuICogSXMgdGhpcyBNSU1FIHR5cGUgYSB2aWRlbz9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWltZVR5cGUgLSBNSU1FIHR5cGUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWaWRlb01pbWVUeXBlIChtaW1lVHlwZSkge1xuICByZXR1cm4gL152aWRlb1xcL1teKl0rJC8udGVzdChtaW1lVHlwZSlcbn1cblxuLyoqXG4gKiBJcyB0aGlzIE1JTUUgdHlwZSBhbiBpbWFnZT9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWltZVR5cGUgLSBNSU1FIHR5cGUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNJbWFnZU1pbWVUeXBlIChtaW1lVHlwZSkge1xuICByZXR1cm4gL15pbWFnZVxcL1teKl0rJC8udGVzdChtaW1lVHlwZSlcbn1cblxuLyoqXG4gKiBTZXR1cCBnZXRVc2VyTWVkaWEsIHdpdGggcG9seWZpbGwgZm9yIG9sZGVyIGJyb3dzZXJzXG4gKiBBZGFwdGVkIGZyb206IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYURldmljZXMvZ2V0VXNlck1lZGlhXG4gKi9cbmZ1bmN0aW9uIGdldE1lZGlhRGV2aWNlcyAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlc1xuICB9XG5cbiAgY29uc3QgZ2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhXG4gIGlmICghZ2V0VXNlck1lZGlhKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0VXNlck1lZGlhIChvcHRzKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBnZXRVc2VyTWVkaWEuY2FsbChuYXZpZ2F0b3IsIG9wdHMsIHJlc29sdmUsIHJlamVjdClcbiAgICAgIH0pXG4gICAgfSxcbiAgfVxufVxuLyoqXG4gKiBXZWJjYW1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBXZWJjYW0gZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHBhY2thZ2VKc29uVmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLm1lZGlhRGV2aWNlcyA9IGdldE1lZGlhRGV2aWNlcygpXG4gICAgdGhpcy5zdXBwb3J0c1VzZXJNZWRpYSA9ICEhdGhpcy5tZWRpYURldmljZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgdGhpcy5wcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sLm1hdGNoKC9odHRwcy9pKSA/ICdodHRwcycgOiAnaHR0cCdcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdXZWJjYW0nXG4gICAgdGhpcy50aXRsZSA9IHRoaXMub3B0cy50aXRsZSB8fCAnQ2FtZXJhJ1xuICAgIHRoaXMudHlwZSA9ICdhY3F1aXJlcidcbiAgICB0aGlzLmNhcHR1cmVkTWVkaWFGaWxlID0gbnVsbFxuICAgIHRoaXMuaWNvbiA9ICgpID0+IChcbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbFJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgPHJlY3QgY2xhc3NOYW1lPVwidXBweS1Qcm92aWRlckljb25CZ1wiIGZpbGw9XCIjMDNCRkVGXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIC8+XG4gICAgICAgICAgPHBhdGggZD1cIk0yMiAxMWMxLjEzMyAwIDIgLjg2NyAyIDJ2Ny4zMzNjMCAxLjEzNC0uODY3IDItMiAySDEwYy0xLjEzMyAwLTItLjg2Ni0yLTJWMTNjMC0xLjEzMy44NjctMiAyLTJoMi4zMzNsMS4xMzQtMS43MzNDMTMuNiA5LjEzMyAxMy44IDkgMTQgOWg0Yy4yIDAgLjQuMTMzLjUzMy4yNjdMMTkuNjY3IDExSDIyem0tNiAxLjUzM2EzLjc2NCAzLjc2NCAwIDAgMC0zLjggMy44YzAgMi4xMjkgMS42NzIgMy44MDEgMy44IDMuODAxczMuOC0xLjY3MiAzLjgtMy44YzAtMi4xMy0xLjY3Mi0zLjgwMS0zLjgtMy44MDF6bTAgNi4yNjFjLTEuMzk1IDAtMi40Ni0xLjA2Ni0yLjQ2LTIuNDYgMC0xLjM5NSAxLjA2NS0yLjQ2MSAyLjQ2LTIuNDYxczIuNDYgMS4wNjYgMi40NiAyLjQ2YzAgMS4zOTUtMS4wNjUgMi40NjEtMi40NiAyLjQ2MXpcIiBmaWxsPVwiI0ZGRlwiIGZpbGxSdWxlPVwibm9uemVyb1wiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IHtcbiAgICAgIHN0cmluZ3M6IHtcbiAgICAgICAgc21pbGU6ICdTbWlsZSEnLFxuICAgICAgICB0YWtlUGljdHVyZTogJ1Rha2UgYSBwaWN0dXJlJyxcbiAgICAgICAgc3RhcnRSZWNvcmRpbmc6ICdCZWdpbiB2aWRlbyByZWNvcmRpbmcnLFxuICAgICAgICBzdG9wUmVjb3JkaW5nOiAnU3RvcCB2aWRlbyByZWNvcmRpbmcnLFxuICAgICAgICBhbGxvd0FjY2Vzc1RpdGxlOiAnUGxlYXNlIGFsbG93IGFjY2VzcyB0byB5b3VyIGNhbWVyYScsXG4gICAgICAgIGFsbG93QWNjZXNzRGVzY3JpcHRpb246ICdJbiBvcmRlciB0byB0YWtlIHBpY3R1cmVzIG9yIHJlY29yZCB2aWRlbyB3aXRoIHlvdXIgY2FtZXJhLCBwbGVhc2UgYWxsb3cgY2FtZXJhIGFjY2VzcyBmb3IgdGhpcyBzaXRlLicsXG4gICAgICAgIG5vQ2FtZXJhVGl0bGU6ICdDYW1lcmEgTm90IEF2YWlsYWJsZScsXG4gICAgICAgIG5vQ2FtZXJhRGVzY3JpcHRpb246ICdJbiBvcmRlciB0byB0YWtlIHBpY3R1cmVzIG9yIHJlY29yZCB2aWRlbywgcGxlYXNlIGNvbm5lY3QgYSBjYW1lcmEgZGV2aWNlJyxcbiAgICAgICAgcmVjb3JkaW5nU3RvcHBlZE1heFNpemU6ICdSZWNvcmRpbmcgc3RvcHBlZCBiZWNhdXNlIHRoZSBmaWxlIHNpemUgaXMgYWJvdXQgdG8gZXhjZWVkIHRoZSBsaW1pdCcsXG4gICAgICAgIHJlY29yZGluZ0xlbmd0aDogJ1JlY29yZGluZyBsZW5ndGggJXtyZWNvcmRpbmdfbGVuZ3RofScsXG4gICAgICAgIHN1Ym1pdFJlY29yZGVkRmlsZTogJ1N1Ym1pdCByZWNvcmRlZCBmaWxlJyxcbiAgICAgICAgZGlzY2FyZFJlY29yZGVkRmlsZTogJ0Rpc2NhcmQgcmVjb3JkZWQgZmlsZScsXG4gICAgICB9LFxuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIG9uQmVmb3JlU25hcHNob3Q6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgY291bnRkb3duOiBmYWxzZSxcbiAgICAgIG1vZGVzOiBbXG4gICAgICAgICd2aWRlby1hdWRpbycsXG4gICAgICAgICd2aWRlby1vbmx5JyxcbiAgICAgICAgJ2F1ZGlvLW9ubHknLFxuICAgICAgICAncGljdHVyZScsXG4gICAgICBdLFxuICAgICAgbWlycm9yOiB0cnVlLFxuICAgICAgc2hvd1ZpZGVvU291cmNlRHJvcGRvd246IGZhbHNlLFxuICAgICAgZmFjaW5nTW9kZTogJ3VzZXInLFxuICAgICAgcHJlZmVycmVkSW1hZ2VNaW1lVHlwZTogbnVsbCxcbiAgICAgIHByZWZlcnJlZFZpZGVvTWltZVR5cGU6IG51bGwsXG4gICAgICBzaG93UmVjb3JkaW5nTGVuZ3RoOiBmYWxzZSxcbiAgICB9XG5cbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuXG4gICAgdGhpcy5pbnN0YWxsID0gdGhpcy5pbnN0YWxsLmJpbmQodGhpcylcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlID0gdGhpcy5zZXRQbHVnaW5TdGF0ZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcblxuICAgIC8vIENhbWVyYSBjb250cm9sc1xuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcylcbiAgICB0aGlzLnN0b3AgPSB0aGlzLnN0b3AuYmluZCh0aGlzKVxuICAgIHRoaXMudGFrZVNuYXBzaG90ID0gdGhpcy50YWtlU25hcHNob3QuYmluZCh0aGlzKVxuICAgIHRoaXMuc3RhcnRSZWNvcmRpbmcgPSB0aGlzLnN0YXJ0UmVjb3JkaW5nLmJpbmQodGhpcylcbiAgICB0aGlzLnN0b3BSZWNvcmRpbmcgPSB0aGlzLnN0b3BSZWNvcmRpbmcuYmluZCh0aGlzKVxuICAgIHRoaXMuZGlzY2FyZFJlY29yZGVkVmlkZW8gPSB0aGlzLmRpc2NhcmRSZWNvcmRlZFZpZGVvLmJpbmQodGhpcylcbiAgICB0aGlzLnN1Ym1pdCA9IHRoaXMuc3VibWl0LmJpbmQodGhpcylcbiAgICB0aGlzLm9uZVR3b1RocmVlU21pbGUgPSB0aGlzLm9uZVR3b1RocmVlU21pbGUuYmluZCh0aGlzKVxuICAgIHRoaXMuZm9jdXMgPSB0aGlzLmZvY3VzLmJpbmQodGhpcylcbiAgICB0aGlzLmNoYW5nZVZpZGVvU291cmNlID0gdGhpcy5jaGFuZ2VWaWRlb1NvdXJjZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLndlYmNhbUFjdGl2ZSA9IGZhbHNlXG5cbiAgICBpZiAodGhpcy5vcHRzLmNvdW50ZG93bikge1xuICAgICAgdGhpcy5vcHRzLm9uQmVmb3JlU25hcHNob3QgPSB0aGlzLm9uZVR3b1RocmVlU21pbGVcbiAgICB9XG5cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGhhc0NhbWVyYTogZmFsc2UsXG4gICAgICBjYW1lcmFSZWFkeTogZmFsc2UsXG4gICAgICBjYW1lcmFFcnJvcjogbnVsbCxcbiAgICAgIHJlY29yZGluZ0xlbmd0aFNlY29uZHM6IDAsXG4gICAgICB2aWRlb1NvdXJjZXM6IFtdLFxuICAgICAgY3VycmVudERldmljZUlkOiBudWxsLFxuICAgIH0pXG4gIH1cblxuICBzZXRPcHRpb25zIChuZXdPcHRzKSB7XG4gICAgc3VwZXIuc2V0T3B0aW9ucyh7XG4gICAgICAuLi5uZXdPcHRzLFxuICAgICAgdmlkZW9Db25zdHJhaW50czoge1xuICAgICAgICAvLyBNYXkgYmUgdW5kZWZpbmVkIGJ1dCAuLi4gaGFuZGxlcyB0aGF0XG4gICAgICAgIC4uLnRoaXMub3B0cy52aWRlb0NvbnN0cmFpbnRzLFxuICAgICAgICAuLi5uZXdPcHRzPy52aWRlb0NvbnN0cmFpbnRzLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgdGhpcy5pMThuSW5pdCgpXG4gIH1cblxuICBpMThuSW5pdCAoKSB7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoW3RoaXMuZGVmYXVsdExvY2FsZSwgdGhpcy51cHB5LmxvY2FsZSwgdGhpcy5vcHRzLmxvY2FsZV0pXG4gICAgdGhpcy5pMThuID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLmkxOG5BcnJheSA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGVBcnJheS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKCkgLy8gc28gdGhhdCBVSSByZS1yZW5kZXJzIGFuZCB3ZSBzZWUgdGhlIHVwZGF0ZWQgbG9jYWxlXG4gIH1cblxuICBoYXNDYW1lcmFDaGVjayAoKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhRGV2aWNlcykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpLnRoZW4oZGV2aWNlcyA9PiB7XG4gICAgICByZXR1cm4gZGV2aWNlcy5zb21lKGRldmljZSA9PiBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKVxuICAgIH0pXG4gIH1cblxuICBpc0F1ZGlvT25seSAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cy5tb2Rlcy5sZW5ndGggPT09IDEgJiYgdGhpcy5vcHRzLm1vZGVzWzBdID09PSAnYXVkaW8tb25seSdcbiAgfVxuXG4gIGdldENvbnN0cmFpbnRzIChkZXZpY2VJZCA9IG51bGwpIHtcbiAgICBjb25zdCBhY2NlcHRzQXVkaW8gPSB0aGlzLm9wdHMubW9kZXMuaW5kZXhPZigndmlkZW8tYXVkaW8nKSAhPT0gLTFcbiAgICAgIHx8IHRoaXMub3B0cy5tb2Rlcy5pbmRleE9mKCdhdWRpby1vbmx5JykgIT09IC0xXG4gICAgY29uc3QgYWNjZXB0c1ZpZGVvID0gIXRoaXMuaXNBdWRpb09ubHkoKVxuICAgICAgICAmJiAodGhpcy5vcHRzLm1vZGVzLmluZGV4T2YoJ3ZpZGVvLWF1ZGlvJykgIT09IC0xXG4gICAgICAgICAgfHwgdGhpcy5vcHRzLm1vZGVzLmluZGV4T2YoJ3ZpZGVvLW9ubHknKSAhPT0gLTFcbiAgICAgICAgICB8fCB0aGlzLm9wdHMubW9kZXMuaW5kZXhPZigncGljdHVyZScpICE9PSAtMSlcblxuICAgIGNvbnN0IHZpZGVvQ29uc3RyYWludHMgPSB7XG4gICAgICAuLi4odGhpcy5vcHRzLnZpZGVvQ29uc3RyYWludHMgPz8geyBmYWNpbmdNb2RlOiB0aGlzLm9wdHMuZmFjaW5nTW9kZSB9KSxcbiAgICAgIC8vIGZhY2luZ01vZGUgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGRldmljZUlkLCBhbmQgbm90IG5lZWRlZFxuICAgICAgLy8gd2hlbiBzcGVjaWZpYyBkZXZpY2UgaXMgc2VsZWN0ZWRcbiAgICAgIC4uLihkZXZpY2VJZCA/IHsgZGV2aWNlSWQsIGZhY2luZ01vZGU6IG51bGwgfSA6IHt9KSxcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW86IGFjY2VwdHNBdWRpbyxcbiAgICAgIHZpZGVvOiBhY2NlcHRzVmlkZW8gPyB2aWRlb0NvbnN0cmFpbnRzIDogZmFsc2UsXG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIHN0YXJ0IChvcHRpb25zID0gbnVsbCkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0c1VzZXJNZWRpYSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignV2ViY2FtIGFjY2VzcyBub3Qgc3VwcG9ydGVkJykpXG4gICAgfVxuXG4gICAgdGhpcy53ZWJjYW1BY3RpdmUgPSB0cnVlXG4gICAgdGhpcy5vcHRzLm1pcnJvciA9IHRydWVcblxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5nZXRDb25zdHJhaW50cyhvcHRpb25zICYmIG9wdGlvbnMuZGV2aWNlSWQgPyBvcHRpb25zLmRldmljZUlkIDogbnVsbClcblxuICAgIHRoaXMuaGFzQ2FtZXJhQ2hlY2soKS50aGVuKGhhc0NhbWVyYSA9PiB7XG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgaGFzQ2FtZXJhLFxuICAgICAgfSlcblxuICAgICAgLy8gYXNrIHVzZXIgZm9yIGFjY2VzcyB0byB0aGVpciBjYW1lcmFcbiAgICAgIHJldHVybiB0aGlzLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG4gICAgICAgIC50aGVuKChzdHJlYW0pID0+IHtcbiAgICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbVxuXG4gICAgICAgICAgbGV0IGN1cnJlbnREZXZpY2VJZCA9IG51bGxcbiAgICAgICAgICBjb25zdCB0cmFja3MgPSB0aGlzLmlzQXVkaW9Pbmx5KCkgPyBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKSA6IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpXG5cbiAgICAgICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuZGV2aWNlSWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnREZXZpY2VJZCA9IHRyYWNrc1swXS5nZXRTZXR0aW5ncygpLmRldmljZUlkXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgICBpZiAodHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZCA9PT0gb3B0aW9ucy5kZXZpY2VJZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2VJZCA9IHRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNvdXJjZXMgbm93LCBzbyB3ZSBjYW4gYWNjZXNzIHRoZSBuYW1lcy5cbiAgICAgICAgICB0aGlzLnVwZGF0ZVZpZGVvU291cmNlcygpXG5cbiAgICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICAgIGN1cnJlbnREZXZpY2VJZCxcbiAgICAgICAgICAgIGNhbWVyYVJlYWR5OiB0cnVlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgICBjYW1lcmFSZWFkeTogZmFsc2UsXG4gICAgICAgICAgICBjYW1lcmFFcnJvcjogZXJyLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy51cHB5LmluZm8oZXJyLm1lc3NhZ2UsICdlcnJvcicpXG4gICAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgZ2V0TWVkaWFSZWNvcmRlck9wdGlvbnMgKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7fVxuXG4gICAgLy8gVHJ5IHRvIHVzZSB0aGUgYG9wdHMucHJlZmVycmVkVmlkZW9NaW1lVHlwZWAgb3Igb25lIG9mIHRoZSBgYWxsb3dlZEZpbGVUeXBlc2AgZm9yIHRoZSByZWNvcmRpbmcuXG4gICAgLy8gSWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGl0LCB3ZSdsbCBmYWxsIGJhY2sgdG8gdGhlIGJyb3dzZXIgZGVmYXVsdCBpbnN0ZWFkLlxuICAgIC8vIFNhZmFyaSBkb2Vzbid0IGhhdmUgdGhlIGBpc1R5cGVTdXBwb3J0ZWRgIEFQSS5cbiAgICBpZiAoTWVkaWFSZWNvcmRlci5pc1R5cGVTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IHsgcmVzdHJpY3Rpb25zIH0gPSB0aGlzLnVwcHkub3B0c1xuICAgICAgbGV0IHByZWZlcnJlZFZpZGVvTWltZVR5cGVzID0gW11cbiAgICAgIGlmICh0aGlzLm9wdHMucHJlZmVycmVkVmlkZW9NaW1lVHlwZSkge1xuICAgICAgICBwcmVmZXJyZWRWaWRlb01pbWVUeXBlcyA9IFt0aGlzLm9wdHMucHJlZmVycmVkVmlkZW9NaW1lVHlwZV1cbiAgICAgIH0gZWxzZSBpZiAocmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXMpIHtcbiAgICAgICAgcHJlZmVycmVkVmlkZW9NaW1lVHlwZXMgPSByZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcy5tYXAodG9NaW1lVHlwZSkuZmlsdGVyKGlzVmlkZW9NaW1lVHlwZSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlsdGVyU3VwcG9ydGVkVHlwZXMgPSAoY2FuZGlkYXRlVHlwZSkgPT4gTWVkaWFSZWNvcmRlci5pc1R5cGVTdXBwb3J0ZWQoY2FuZGlkYXRlVHlwZSlcbiAgICAgICAgJiYgZ2V0RmlsZVR5cGVFeHRlbnNpb24oY2FuZGlkYXRlVHlwZSlcbiAgICAgIGNvbnN0IGFjY2VwdGFibGVNaW1lVHlwZXMgPSBwcmVmZXJyZWRWaWRlb01pbWVUeXBlcy5maWx0ZXIoZmlsdGVyU3VwcG9ydGVkVHlwZXMpXG5cbiAgICAgIGlmIChhY2NlcHRhYmxlTWltZVR5cGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIG9wdGlvbnMubWltZVR5cGUgPSBhY2NlcHRhYmxlTWltZVR5cGVzWzBdXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIHN0YXJ0UmVjb3JkaW5nICgpIHtcbiAgICAvLyBvbmx5IHVzZWQgaWYgc3VwcG9ydHNNZWRpYVJlY29yZGVyKCkgcmV0dXJuZWQgdHJ1ZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgdGhpcy5yZWNvcmRlciA9IG5ldyBNZWRpYVJlY29yZGVyKHRoaXMuc3RyZWFtLCB0aGlzLmdldE1lZGlhUmVjb3JkZXJPcHRpb25zKCkpXG4gICAgdGhpcy5yZWNvcmRpbmdDaHVua3MgPSBbXVxuICAgIGxldCBzdG9wcGluZ0JlY2F1c2VPZk1heFNpemUgPSBmYWxzZVxuICAgIHRoaXMucmVjb3JkZXIuYWRkRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy5yZWNvcmRpbmdDaHVua3MucHVzaChldmVudC5kYXRhKVxuXG4gICAgICBjb25zdCB7IHJlc3RyaWN0aW9ucyB9ID0gdGhpcy51cHB5Lm9wdHNcbiAgICAgIGlmICh0aGlzLnJlY29yZGluZ0NodW5rcy5sZW5ndGggPiAxXG4gICAgICAgICAgJiYgcmVzdHJpY3Rpb25zLm1heEZpbGVTaXplICE9IG51bGxcbiAgICAgICAgICAmJiAhc3RvcHBpbmdCZWNhdXNlT2ZNYXhTaXplKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IHRoaXMucmVjb3JkaW5nQ2h1bmtzLnJlZHVjZSgoYWNjLCBjaHVuaykgPT4gYWNjICsgY2h1bmsuc2l6ZSwgMClcbiAgICAgICAgLy8gRXhjbHVkZSB0aGUgaW5pdGlhbCBjaHVuayBmcm9tIHRoZSBhdmVyYWdlIHNpemUgY2FsY3VsYXRpb24gYmVjYXVzZSBpdCBpcyBsaWtlbHkgdG8gYmUgYSB2ZXJ5IHNtYWxsIG91dGxpZXJcbiAgICAgICAgY29uc3QgYXZlcmFnZUNodW5rU2l6ZSA9ICh0b3RhbFNpemUgLSB0aGlzLnJlY29yZGluZ0NodW5rc1swXS5zaXplKSAvICh0aGlzLnJlY29yZGluZ0NodW5rcy5sZW5ndGggLSAxKVxuICAgICAgICBjb25zdCBleHBlY3RlZEVuZENodW5rU2l6ZSA9IGF2ZXJhZ2VDaHVua1NpemUgKiAzXG4gICAgICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heCgwLCByZXN0cmljdGlvbnMubWF4RmlsZVNpemUgLSBleHBlY3RlZEVuZENodW5rU2l6ZSlcblxuICAgICAgICBpZiAodG90YWxTaXplID4gbWF4U2l6ZSkge1xuICAgICAgICAgIHN0b3BwaW5nQmVjYXVzZU9mTWF4U2l6ZSA9IHRydWVcbiAgICAgICAgICB0aGlzLnVwcHkuaW5mbyh0aGlzLmkxOG4oJ3JlY29yZGluZ1N0b3BwZWRNYXhTaXplJyksICd3YXJuaW5nJywgNDAwMClcbiAgICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIHVzZSBhIFwidGltZSBzbGljZVwiIG9mIDUwMG1zOiBvbmRhdGFhdmFpbGFibGUgd2lsbCBiZSBjYWxsZWQgZWFjaCA1MDBtc1xuICAgIC8vIHNtYWxsZXIgdGltZSBzbGljZXMgbWVhbiB3ZSBjYW4gbW9yZSBhY2N1cmF0ZWx5IGNoZWNrIHRoZSBtYXggZmlsZSBzaXplIHJlc3RyaWN0aW9uXG4gICAgdGhpcy5yZWNvcmRlci5zdGFydCg1MDApXG5cbiAgICBpZiAodGhpcy5vcHRzLnNob3dSZWNvcmRpbmdMZW5ndGgpIHtcbiAgICAgIC8vIFN0YXJ0IHRoZSByZWNvcmRpbmdMZW5ndGhUaW1lciBpZiB3ZSBhcmUgc2hvd2luZyB0aGUgcmVjb3JkaW5nIGxlbmd0aC5cbiAgICAgIHRoaXMucmVjb3JkaW5nTGVuZ3RoVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSZWNvcmRpbmdMZW5ndGggPSB0aGlzLmdldFBsdWdpblN0YXRlKCkucmVjb3JkaW5nTGVuZ3RoU2Vjb25kc1xuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kczogY3VycmVudFJlY29yZGluZ0xlbmd0aCArIDEgfSlcbiAgICAgIH0sIDEwMDApXG4gICAgfVxuXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBpc1JlY29yZGluZzogdHJ1ZSxcbiAgICB9KVxuICB9XG5cbiAgc3RvcFJlY29yZGluZyAoKSB7XG4gICAgY29uc3Qgc3RvcHBlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLnJlY29yZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3AnLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbiAgICAgIHRoaXMucmVjb3JkZXIuc3RvcCgpXG5cbiAgICAgIGlmICh0aGlzLm9wdHMuc2hvd1JlY29yZGluZ0xlbmd0aCkge1xuICAgICAgICAvLyBTdG9wIHRoZSByZWNvcmRpbmdMZW5ndGhUaW1lciBpZiB3ZSBhcmUgc2hvd2luZyB0aGUgcmVjb3JkaW5nIGxlbmd0aC5cbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlY29yZGluZ0xlbmd0aFRpbWVyKVxuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kczogMCB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gc3RvcHBlZC50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBpc1JlY29yZGluZzogZmFsc2UsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmlkZW8oKVxuICAgIH0pLnRoZW4oKGZpbGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUgPSBmaWxlXG4gICAgICAgIC8vIGNyZWF0ZSBvYmplY3QgdXJsIGZvciBjYXB0dXJlIHJlc3VsdCBwcmV2aWV3XG4gICAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgICAgICAgcmVjb3JkZWRWaWRlbzogVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlLmRhdGEpLFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLm9wdHMubWlycm9yID0gZmFsc2VcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBMb2dnaW5nIHRoZSBlcnJvciwgZXhlcHQgcmVzdHJpY3Rpb25zLCB3aGljaCBpcyBoYW5kbGVkIGluIENvcmVcbiAgICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnJlY29yZGluZ0NodW5rcyA9IG51bGxcbiAgICAgIHRoaXMucmVjb3JkZXIgPSBudWxsXG4gICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLnJlY29yZGluZ0NodW5rcyA9IG51bGxcbiAgICAgIHRoaXMucmVjb3JkZXIgPSBudWxsXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH0pXG4gIH1cblxuICBkaXNjYXJkUmVjb3JkZWRWaWRlbyAoKSB7XG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7IHJlY29yZGVkVmlkZW86IG51bGwgfSlcbiAgICB0aGlzLm9wdHMubWlycm9yID0gdHJ1ZVxuICAgIHRoaXMuY2FwdHVyZWRNZWRpYUZpbGUgPSBudWxsXG4gIH1cblxuICBzdWJtaXQgKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5jYXB0dXJlZE1lZGlhRmlsZSkge1xuICAgICAgICB0aGlzLnVwcHkuYWRkRmlsZSh0aGlzLmNhcHR1cmVkTWVkaWFGaWxlKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gTG9nZ2luZyB0aGUgZXJyb3IsIGV4ZXB0IHJlc3RyaWN0aW9ucywgd2hpY2ggaXMgaGFuZGxlZCBpbiBDb3JlXG4gICAgICBpZiAoIWVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICAgIHRoaXMudXBweS5sb2coZXJyLCAnZXJyb3InKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0b3AgKCkge1xuICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgdGhpcy5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5zdG9wKClcbiAgICAgIH0pXG4gICAgICB0aGlzLnN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgIHRyYWNrLnN0b3AoKVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy53ZWJjYW1BY3RpdmUgPSBmYWxzZVxuICAgIHRoaXMuc3RyZWFtID0gbnVsbFxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgcmVjb3JkZWRWaWRlbzogbnVsbCxcbiAgICB9KVxuICB9XG5cbiAgZ2V0VmlkZW9FbGVtZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcudXBweS1XZWJjYW0tdmlkZW8nKVxuICB9XG5cbiAgb25lVHdvVGhyZWVTbWlsZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBjb3VudCA9IHRoaXMub3B0cy5jb3VudGRvd25cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICBjb25zdCBjb3VudERvd24gPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy53ZWJjYW1BY3RpdmUpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGNvdW50RG93bilcbiAgICAgICAgICB0aGlzLmNhcHR1cmVJblByb2dyZXNzID0gZmFsc2VcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignV2ViY2FtIGlzIG5vdCBhY3RpdmUnKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICB0aGlzLnVwcHkuaW5mbyhgJHtjb3VudH0uLi5gLCAnd2FybmluZycsIDgwMClcbiAgICAgICAgICBjb3VudC0tXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChjb3VudERvd24pXG4gICAgICAgICAgdGhpcy51cHB5LmluZm8odGhpcy5pMThuKCdzbWlsZScpLCAnc3VjY2VzcycsIDE1MDApXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIDE1MDApXG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApXG4gICAgfSlcbiAgfVxuXG4gIHRha2VTbmFwc2hvdCAoKSB7XG4gICAgaWYgKHRoaXMuY2FwdHVyZUluUHJvZ3Jlc3MpIHJldHVyblxuXG4gICAgdGhpcy5jYXB0dXJlSW5Qcm9ncmVzcyA9IHRydWVcblxuICAgIHRoaXMub3B0cy5vbkJlZm9yZVNuYXBzaG90KCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHR5cGVvZiBlcnIgPT09ICdvYmplY3QnID8gZXJyLm1lc3NhZ2UgOiBlcnJcbiAgICAgIHRoaXMudXBweS5pbmZvKG1lc3NhZ2UsICdlcnJvcicsIDUwMDApXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBvbkJlZm9yZVNuYXBzaG90OiAke21lc3NhZ2V9YCkpXG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbWFnZSgpXG4gICAgfSkudGhlbigodGFnRmlsZSkgPT4ge1xuICAgICAgdGhpcy5jYXB0dXJlSW5Qcm9ncmVzcyA9IGZhbHNlXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnVwcHkuYWRkRmlsZSh0YWdGaWxlKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIExvZ2dpbmcgdGhlIGVycm9yLCBleGNlcHQgcmVzdHJpY3Rpb25zLCB3aGljaCBpcyBoYW5kbGVkIGluIENvcmVcbiAgICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLmNhcHR1cmVJblByb2dyZXNzID0gZmFsc2VcbiAgICAgIHRocm93IGVycm9yXG4gICAgfSlcbiAgfVxuXG4gIGdldEltYWdlICgpIHtcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMuZ2V0VmlkZW9FbGVtZW50KClcbiAgICBpZiAoIXZpZGVvKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdObyB2aWRlbyBlbGVtZW50IGZvdW5kLCBsaWtlbHkgZHVlIHRvIHRoZSBXZWJjYW0gdGFiIGJlaW5nIGNsb3NlZC4nKSlcbiAgICB9XG5cbiAgICBjb25zdCB3aWR0aCA9IHZpZGVvLnZpZGVvV2lkdGhcbiAgICBjb25zdCBoZWlnaHQgPSB2aWRlby52aWRlb0hlaWdodFxuXG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHRcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGN0eC5kcmF3SW1hZ2UodmlkZW8sIDAsIDApXG5cbiAgICBjb25zdCB7IHJlc3RyaWN0aW9ucyB9ID0gdGhpcy51cHB5Lm9wdHNcbiAgICBsZXQgcHJlZmVycmVkSW1hZ2VNaW1lVHlwZXMgPSBbXVxuICAgIGlmICh0aGlzLm9wdHMucHJlZmVycmVkSW1hZ2VNaW1lVHlwZSkge1xuICAgICAgcHJlZmVycmVkSW1hZ2VNaW1lVHlwZXMgPSBbdGhpcy5vcHRzLnByZWZlcnJlZEltYWdlTWltZVR5cGVdXG4gICAgfSBlbHNlIGlmIChyZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcykge1xuICAgICAgcHJlZmVycmVkSW1hZ2VNaW1lVHlwZXMgPSByZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcy5tYXAodG9NaW1lVHlwZSkuZmlsdGVyKGlzSW1hZ2VNaW1lVHlwZSlcbiAgICB9XG5cbiAgICBjb25zdCBtaW1lVHlwZSA9IHByZWZlcnJlZEltYWdlTWltZVR5cGVzWzBdIHx8ICdpbWFnZS9qcGVnJ1xuICAgIGNvbnN0IGV4dCA9IGdldEZpbGVUeXBlRXh0ZW5zaW9uKG1pbWVUeXBlKSB8fCAnanBnJ1xuICAgIGNvbnN0IG5hbWUgPSBgY2FtLSR7RGF0ZS5ub3coKX0uJHtleHR9YFxuXG4gICAgcmV0dXJuIGNhbnZhc1RvQmxvYihjYW52YXMsIG1pbWVUeXBlKS50aGVuKChibG9iKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRhdGE6IG5ldyBCbG9iKFtibG9iXSwgeyB0eXBlOiBtaW1lVHlwZSB9KSxcbiAgICAgICAgdHlwZTogbWltZVR5cGUsXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGdldFZpZGVvICgpIHtcbiAgICAvLyBTb21ldGltZXMgaW4gaU9TIFNhZmFyaSwgQmxvYnMgKGVzcGVjaWFsbHkgdGhlIGZpcnN0IEJsb2IgaW4gdGhlIHJlY29yZGluZ0NodW5rcyBBcnJheSlcbiAgICAvLyBoYXZlIGVtcHR5ICd0eXBlJyBhdHRyaWJ1dGVzIChlLmcuICcnKSBzbyB3ZSBuZWVkIHRvIGZpbmQgYSBCbG9iIHRoYXQgaGFzIGEgZGVmaW5lZCAndHlwZSdcbiAgICAvLyBhdHRyaWJ1dGUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IE1JTUUgdHlwZS5cbiAgICBjb25zdCBtaW1lVHlwZSA9IHRoaXMucmVjb3JkaW5nQ2h1bmtzLmZpbmQoYmxvYiA9PiBibG9iLnR5cGU/Lmxlbmd0aCA+IDApLnR5cGVcblxuICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBnZXRGaWxlVHlwZUV4dGVuc2lvbihtaW1lVHlwZSlcblxuICAgIGlmICghZmlsZUV4dGVuc2lvbikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgQ291bGQgbm90IHJldHJpZXZlIHJlY29yZGluZzogVW5zdXBwb3J0ZWQgbWVkaWEgdHlwZSBcIiR7bWltZVR5cGV9XCJgKSlcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gYHdlYmNhbS0ke0RhdGUubm93KCl9LiR7ZmlsZUV4dGVuc2lvbn1gXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKHRoaXMucmVjb3JkaW5nQ2h1bmtzLCB7IHR5cGU6IG1pbWVUeXBlIH0pXG4gICAgY29uc3QgZmlsZSA9IHtcbiAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgIG5hbWUsXG4gICAgICBkYXRhOiBuZXcgQmxvYihbYmxvYl0sIHsgdHlwZTogbWltZVR5cGUgfSksXG4gICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbGUpXG4gIH1cblxuICBmb2N1cyAoKSB7XG4gICAgaWYgKCF0aGlzLm9wdHMuY291bnRkb3duKSByZXR1cm5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBweS5pbmZvKHRoaXMuaTE4bignc21pbGUnKSwgJ3N1Y2Nlc3MnLCAxNTAwKVxuICAgIH0sIDEwMDApXG4gIH1cblxuICBjaGFuZ2VWaWRlb1NvdXJjZSAoZGV2aWNlSWQpIHtcbiAgICB0aGlzLnN0b3AoKVxuICAgIHRoaXMuc3RhcnQoeyBkZXZpY2VJZCB9KVxuICB9XG5cbiAgdXBkYXRlVmlkZW9Tb3VyY2VzICgpIHtcbiAgICB0aGlzLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbihkZXZpY2VzID0+IHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICB2aWRlb1NvdXJjZXM6IGRldmljZXMuZmlsdGVyKChkZXZpY2UpID0+IGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCcpLFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBpZiAoIXRoaXMud2ViY2FtQWN0aXZlKSB7XG4gICAgICB0aGlzLnN0YXJ0KClcbiAgICB9XG5cbiAgICBjb25zdCB3ZWJjYW1TdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuXG4gICAgaWYgKCF3ZWJjYW1TdGF0ZS5jYW1lcmFSZWFkeSB8fCAhd2ViY2FtU3RhdGUuaGFzQ2FtZXJhKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8UGVybWlzc2lvbnNTY3JlZW5cbiAgICAgICAgICBpY29uPXtDYW1lcmFJY29ufVxuICAgICAgICAgIGkxOG49e3RoaXMuaTE4bn1cbiAgICAgICAgICBoYXNDYW1lcmE9e3dlYmNhbVN0YXRlLmhhc0NhbWVyYX1cbiAgICAgICAgLz5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPENhbWVyYVNjcmVlblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvanN4LXByb3BzLW5vLXNwcmVhZGluZ1xuICAgICAgICB7Li4ud2ViY2FtU3RhdGV9XG4gICAgICAgIG9uQ2hhbmdlVmlkZW9Tb3VyY2U9e3RoaXMuY2hhbmdlVmlkZW9Tb3VyY2V9XG4gICAgICAgIG9uU25hcHNob3Q9e3RoaXMudGFrZVNuYXBzaG90fVxuICAgICAgICBvblN0YXJ0UmVjb3JkaW5nPXt0aGlzLnN0YXJ0UmVjb3JkaW5nfVxuICAgICAgICBvblN0b3BSZWNvcmRpbmc9e3RoaXMuc3RvcFJlY29yZGluZ31cbiAgICAgICAgb25EaXNjYXJkUmVjb3JkZWRWaWRlbz17dGhpcy5kaXNjYXJkUmVjb3JkZWRWaWRlb31cbiAgICAgICAgb25TdWJtaXQ9e3RoaXMuc3VibWl0fVxuICAgICAgICBvbkZvY3VzPXt0aGlzLmZvY3VzfVxuICAgICAgICBvblN0b3A9e3RoaXMuc3RvcH1cbiAgICAgICAgaTE4bj17dGhpcy5pMThufVxuICAgICAgICBtb2Rlcz17dGhpcy5vcHRzLm1vZGVzfVxuICAgICAgICBzaG93UmVjb3JkaW5nTGVuZ3RoPXt0aGlzLm9wdHMuc2hvd1JlY29yZGluZ0xlbmd0aH1cbiAgICAgICAgc2hvd1ZpZGVvU291cmNlRHJvcGRvd249e3RoaXMub3B0cy5zaG93VmlkZW9Tb3VyY2VEcm9wZG93bn1cbiAgICAgICAgc3VwcG9ydHNSZWNvcmRpbmc9e3N1cHBvcnRzTWVkaWFSZWNvcmRlcigpfVxuICAgICAgICByZWNvcmRpbmc9e3dlYmNhbVN0YXRlLmlzUmVjb3JkaW5nfVxuICAgICAgICBtaXJyb3I9e3RoaXMub3B0cy5taXJyb3J9XG4gICAgICAgIHNyYz17dGhpcy5zdHJlYW19XG4gICAgICAvPlxuICAgIClcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgY2FtZXJhUmVhZHk6IGZhbHNlLFxuICAgICAgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kczogMCxcbiAgICB9KVxuXG4gICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMub3B0c1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm1lZGlhRGV2aWNlcykge1xuICAgICAgdGhpcy51cGRhdGVWaWRlb1NvdXJjZXMoKVxuXG4gICAgICB0aGlzLm1lZGlhRGV2aWNlcy5vbmRldmljZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVWaWRlb1NvdXJjZXMoKVxuXG4gICAgICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgICAgIGxldCByZXN0YXJ0U3RyZWFtID0gdHJ1ZVxuXG4gICAgICAgICAgY29uc3QgeyB2aWRlb1NvdXJjZXMsIGN1cnJlbnREZXZpY2VJZCB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG5cbiAgICAgICAgICB2aWRlb1NvdXJjZXMuZm9yRWFjaCgodmlkZW9Tb3VyY2UpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RGV2aWNlSWQgPT09IHZpZGVvU291cmNlLmRldmljZUlkKSB7XG4gICAgICAgICAgICAgIHJlc3RhcnRTdHJlYW0gPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBpZiAocmVzdGFydFN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKClcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICB0aGlzLnN0b3AoKVxuICAgIH1cblxuICAgIHRoaXMudW5tb3VudCgpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3VwcG9ydHNNZWRpYVJlY29yZGVyICgpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgY29tcGF0L2NvbXBhdCAqL1xuICByZXR1cm4gdHlwZW9mIE1lZGlhUmVjb3JkZXIgPT09ICdmdW5jdGlvbicgJiYgISFNZWRpYVJlY29yZGVyLnByb3RvdHlwZVxuICAgICYmIHR5cGVvZiBNZWRpYVJlY29yZGVyLnByb3RvdHlwZS5zdGFydCA9PT0gJ2Z1bmN0aW9uJ1xuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBhdC9jb21wYXQgKi9cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvem9vbVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiSW1wb3J0IGZpbGVzIGZyb20gem9vbSwgaW50byBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIwLjEuMThcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJ6b29tXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH0sXG4gIFwicHVibGlzaENvbmZpZ1wiOiB7XG4gICAgXCJhY2Nlc3NcIjogXCJwdWJsaWNcIlxuICB9XG59XG4iLCJjb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCB7IFByb3ZpZGVyIH0gPSByZXF1aXJlKCdAdXBweS9jb21wYW5pb24tY2xpZW50JylcbmNvbnN0IHsgUHJvdmlkZXJWaWV3cyB9ID0gcmVxdWlyZSgnQHVwcHkvcHJvdmlkZXItdmlld3MnKVxuY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFpvb20gZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnWm9vbSdcbiAgICBQcm92aWRlci5pbml0UGx1Z2luKHRoaXMsIG9wdHMpXG4gICAgdGhpcy50aXRsZSA9IHRoaXMub3B0cy50aXRsZSB8fCAnWm9vbSdcbiAgICB0aGlzLmljb24gPSAoKSA9PiAoXG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiPlxuICAgICAgICA8cmVjdCBjbGFzc05hbWU9XCJ1cHB5LVByb3ZpZGVySWNvbkJnXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgcng9XCIxNlwiIGZpbGw9XCIjMEU3MUVCXCIgLz5cbiAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsUnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICA8cGF0aCBmaWxsPVwiI2ZmZlwiIGQ9XCJNMjksMzFIMTRjLTEuNjU3LDAtMy0xLjM0My0zLTNWMTdoMTVjMS42NTcsMCwzLDEuMzQzLDMsM1YzMXpcIiBzdHlsZT1cInRyYW5zZm9ybTogdHJhbnNsYXRlKC01cHgsIC01cHgpIHNjYWxlKDAuOSk7XCIgLz5cbiAgICAgICAgICA8cG9seWdvbiBmaWxsPVwiI2ZmZlwiIHBvaW50cz1cIjM3LDMxIDMxLDI3IDMxLDIxIDM3LDE3XCIgc3R5bGU9XCJ0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNXB4LCAtNXB4KSBzY2FsZSgwLjkpO1wiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMgfHwgdGhpcy5vcHRzLnNlcnZlckhlYWRlcnMsXG4gICAgICBjb21wYW5pb25LZXlzUGFyYW1zOiB0aGlzLm9wdHMuY29tcGFuaW9uS2V5c1BhcmFtcyxcbiAgICAgIGNvbXBhbmlvbkNvb2tpZXNSdWxlOiB0aGlzLm9wdHMuY29tcGFuaW9uQ29va2llc1J1bGUsXG4gICAgICBwcm92aWRlcjogJ3pvb20nLFxuICAgICAgcGx1Z2luSWQ6IHRoaXMuaWQsXG4gICAgfSlcblxuICAgIHRoaXMub25GaXJzdFJlbmRlciA9IHRoaXMub25GaXJzdFJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcgPSBuZXcgUHJvdmlkZXJWaWV3cyh0aGlzLCB7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICB9KVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3LnRlYXJEb3duKClcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgb25GaXJzdFJlbmRlciAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMucHJvdmlkZXIuZmV0Y2hQcmVBdXRoVG9rZW4oKSxcbiAgICAgIHRoaXMudmlldy5nZXRGb2xkZXIoKSxcbiAgICBdKVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyKHN0YXRlKVxuICB9XG59XG4iLCJyZXF1aXJlKCdlczYtcHJvbWlzZS9hdXRvJylcbnJlcXVpcmUoJ3doYXR3Zy1mZXRjaCcpXG5jb25zdCBVcHB5ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCBEYXNoYm9hcmQgPSByZXF1aXJlKCdAdXBweS9kYXNoYm9hcmQnKVxuY29uc3QgR29vZ2xlRHJpdmUgPSByZXF1aXJlKCdAdXBweS9nb29nbGUtZHJpdmUnKVxuY29uc3QgRHJvcGJveCA9IHJlcXVpcmUoJ0B1cHB5L2Ryb3Bib3gnKVxuY29uc3QgSW5zdGFncmFtID0gcmVxdWlyZSgnQHVwcHkvaW5zdGFncmFtJylcbmNvbnN0IEZhY2Vib29rID0gcmVxdWlyZSgnQHVwcHkvZmFjZWJvb2snKVxuY29uc3QgT25lRHJpdmUgPSByZXF1aXJlKCdAdXBweS9vbmVkcml2ZScpXG5jb25zdCBab29tID0gcmVxdWlyZSgnQHVwcHkvem9vbScpXG5jb25zdCBJbWFnZUVkaXRvciA9IHJlcXVpcmUoJ0B1cHB5L2ltYWdlLWVkaXRvcicpXG5jb25zdCBVcmwgPSByZXF1aXJlKCdAdXBweS91cmwnKVxuY29uc3QgV2ViY2FtID0gcmVxdWlyZSgnQHVwcHkvd2ViY2FtJylcbmNvbnN0IFNjcmVlbkNhcHR1cmUgPSByZXF1aXJlKCdAdXBweS9zY3JlZW4tY2FwdHVyZScpXG5jb25zdCBUdXMgPSByZXF1aXJlKCdAdXBweS90dXMnKVxuY29uc3QgRHJvcFRhcmdldCA9IHJlcXVpcmUoJ0B1cHB5L2Ryb3AtdGFyZ2V0JylcbmNvbnN0IEdvbGRlblJldHJpZXZlciA9IHJlcXVpcmUoJ0B1cHB5L2dvbGRlbi1yZXRyaWV2ZXInKVxuY29uc3QgbG9jYWxlTGlzdCA9IHJlcXVpcmUoJy4uL2xvY2FsZV9saXN0Lmpzb24nKVxuXG5jb25zdCBDT01QQU5JT04gPSByZXF1aXJlKCcuLi9lbnYnKVxuXG5jb25zdCBSVExfTE9DQUxFUyA9IFsnYXJfU0EnLCAnZmFfSVInLCAnaGVfSUwnXVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5VcHB5ID09PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cuVXBweSA9IHtcbiAgICBsb2NhbGVzOiB7fSxcbiAgfVxufVxuXG5mdW5jdGlvbiB1cHB5SW5pdCAoKSB7XG4gIGlmICh3aW5kb3cudXBweSkge1xuICAgIHdpbmRvdy51cHB5LmNsb3NlKClcbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSB3aW5kb3cudXBweU9wdGlvbnNcblxuICBjb25zdCB1cHB5ID0gbmV3IFVwcHkoe1xuICAgIGxvZ2dlcjogVXBweS5kZWJ1Z0xvZ2dlcixcbiAgfSlcblxuICB1cHB5LnVzZShUdXMsIHsgZW5kcG9pbnQ6ICdodHRwczovL3R1c2QudHVzZGVtby5uZXQvZmlsZXMvJywgcmVzdW1lOiB0cnVlIH0pXG5cbiAgdXBweS5vbignY29tcGxldGUnLCByZXN1bHQgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdzdWNjZXNzZnVsIGZpbGVzOicpXG4gICAgY29uc29sZS5sb2cocmVzdWx0LnN1Y2Nlc3NmdWwpXG4gICAgY29uc29sZS5sb2coJ2ZhaWxlZCBmaWxlczonKVxuICAgIGNvbnNvbGUubG9nKHJlc3VsdC5mYWlsZWQpXG4gIH0pXG5cbiAgdXBweS51c2UoRGFzaGJvYXJkLCB7XG4gICAgdHJpZ2dlcjogJy5VcHB5TW9kYWxPcGVuZXJCdG4nLFxuICAgIHRhcmdldDogb3B0cy5EYXNoYm9hcmRJbmxpbmUgPyAnLkRhc2hib2FyZENvbnRhaW5lcicgOiAnYm9keScsXG4gICAgaW5saW5lOiBvcHRzLkRhc2hib2FyZElubGluZSxcbiAgICByZXBsYWNlVGFyZ2V0Q29udGVudDogb3B0cy5EYXNoYm9hcmRJbmxpbmUsXG4gICAgaGVpZ2h0OiA0NzAsXG4gICAgc2hvd1Byb2dyZXNzRGV0YWlsczogdHJ1ZSxcbiAgICBtZXRhRmllbGRzOiBbXG4gICAgICB7IGlkOiAnbmFtZScsIG5hbWU6ICdOYW1lJywgcGxhY2Vob2xkZXI6ICdmaWxlIG5hbWUnIH0sXG4gICAgICB7IGlkOiAnY2FwdGlvbicsIG5hbWU6ICdDYXB0aW9uJywgcGxhY2Vob2xkZXI6ICdhZGQgZGVzY3JpcHRpb24nIH0sXG4gICAgXSxcbiAgfSlcblxuICB3aW5kb3cudXBweSA9IHVwcHlcbn1cblxuZnVuY3Rpb24gdXBweVNldE9wdGlvbnMgKCkge1xuICBjb25zdCBvcHRzID0gd2luZG93LnVwcHlPcHRpb25zXG5cbiAgY29uc3QgZGVmYXVsdE51bGxSZXN0cmljdGlvbnMgPSB7XG4gICAgbWF4RmlsZVNpemU6IG51bGwsXG4gICAgbWluRmlsZVNpemU6IG51bGwsXG4gICAgbWF4TnVtYmVyT2ZGaWxlczogbnVsbCxcbiAgICBtaW5OdW1iZXJPZkZpbGVzOiBudWxsLFxuICAgIGFsbG93ZWRGaWxlVHlwZXM6IG51bGwsXG4gIH1cblxuICBjb25zdCByZXN0cmljdGlvbnMgPSB7XG4gICAgbWF4RmlsZVNpemU6IDEwMDAwMDAsXG4gICAgbWF4TnVtYmVyT2ZGaWxlczogMyxcbiAgICBtaW5OdW1iZXJPZkZpbGVzOiAyLFxuICAgIGFsbG93ZWRGaWxlVHlwZXM6IFsnaW1hZ2UvKicsICd2aWRlby8qJ10sXG4gIH1cblxuICB3aW5kb3cudXBweS5zZXRPcHRpb25zKHtcbiAgICBhdXRvUHJvY2VlZDogb3B0cy5hdXRvUHJvY2VlZCxcbiAgICByZXN0cmljdGlvbnM6IG9wdHMucmVzdHJpY3Rpb25zID8gcmVzdHJpY3Rpb25zIDogZGVmYXVsdE51bGxSZXN0cmljdGlvbnMsXG4gIH0pXG5cbiAgd2luZG93LnVwcHkuZ2V0UGx1Z2luKCdEYXNoYm9hcmQnKS5zZXRPcHRpb25zKHtcbiAgICBub3RlOiBvcHRzLnJlc3RyaWN0aW9ucyA/ICdJbWFnZXMgYW5kIHZpZGVvIG9ubHksIDLigJMzIGZpbGVzLCB1cCB0byAxIE1CJyA6ICcnLFxuICAgIHRoZW1lOiBvcHRzLmRhcmtNb2RlID8gJ2RhcmsnIDogJ2xpZ2h0JyxcbiAgICBkaXNhYmxlZDogb3B0cy5kaXNhYmxlZCxcbiAgfSlcblxuICBjb25zdCBnb29nbGVEcml2ZUluc3RhbmNlID0gd2luZG93LnVwcHkuZ2V0UGx1Z2luKCdHb29nbGVEcml2ZScpXG4gIGlmIChvcHRzLkdvb2dsZURyaXZlICYmICFnb29nbGVEcml2ZUluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkudXNlKEdvb2dsZURyaXZlLCB7IHRhcmdldDogRGFzaGJvYXJkLCBjb21wYW5pb25Vcmw6IENPTVBBTklPTiB9KVxuICB9XG4gIGlmICghb3B0cy5Hb29nbGVEcml2ZSAmJiBnb29nbGVEcml2ZUluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkucmVtb3ZlUGx1Z2luKGdvb2dsZURyaXZlSW5zdGFuY2UpXG4gIH1cblxuICBjb25zdCBkcm9wYm94SW5zdGFuY2UgPSB3aW5kb3cudXBweS5nZXRQbHVnaW4oJ0Ryb3Bib3gnKVxuICBpZiAob3B0cy5Ecm9wYm94ICYmICFkcm9wYm94SW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS51c2UoRHJvcGJveCwgeyB0YXJnZXQ6IERhc2hib2FyZCwgY29tcGFuaW9uVXJsOiBDT01QQU5JT04gfSlcbiAgfVxuICBpZiAoIW9wdHMuRHJvcGJveCAmJiBkcm9wYm94SW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS5yZW1vdmVQbHVnaW4oZHJvcGJveEluc3RhbmNlKVxuICB9XG5cbiAgY29uc3QgaW5zdGFncmFtSW5zdGFuY2UgPSB3aW5kb3cudXBweS5nZXRQbHVnaW4oJ0luc3RhZ3JhbScpXG4gIGlmIChvcHRzLkluc3RhZ3JhbSAmJiAhaW5zdGFncmFtSW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS51c2UoSW5zdGFncmFtLCB7IHRhcmdldDogRGFzaGJvYXJkLCBjb21wYW5pb25Vcmw6IENPTVBBTklPTiB9KVxuICB9XG4gIGlmICghb3B0cy5JbnN0YWdyYW0gJiYgaW5zdGFncmFtSW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS5yZW1vdmVQbHVnaW4oaW5zdGFncmFtSW5zdGFuY2UpXG4gIH1cblxuICBjb25zdCB1cmxJbnN0YW5jZSA9IHdpbmRvdy51cHB5LmdldFBsdWdpbignVXJsJylcbiAgaWYgKG9wdHMuVXJsICYmICF1cmxJbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnVzZShVcmwsIHsgdGFyZ2V0OiBEYXNoYm9hcmQsIGNvbXBhbmlvblVybDogQ09NUEFOSU9OIH0pXG4gIH1cbiAgaWYgKCFvcHRzLlVybCAmJiB1cmxJbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnJlbW92ZVBsdWdpbih1cmxJbnN0YW5jZSlcbiAgfVxuXG4gIGNvbnN0IGZhY2Vib29rSW5zdGFuY2UgPSB3aW5kb3cudXBweS5nZXRQbHVnaW4oJ0ZhY2Vib29rJylcbiAgaWYgKG9wdHMuRmFjZWJvb2sgJiYgIWZhY2Vib29rSW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS51c2UoRmFjZWJvb2ssIHsgdGFyZ2V0OiBEYXNoYm9hcmQsIGNvbXBhbmlvblVybDogQ09NUEFOSU9OIH0pXG4gIH1cbiAgaWYgKCFvcHRzLkZhY2Vib29rICYmIGZhY2Vib29rSW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS5yZW1vdmVQbHVnaW4oZmFjZWJvb2tJbnN0YW5jZSlcbiAgfVxuXG4gIGNvbnN0IG9uZURyaXZlSW5zdGFuY2UgPSB3aW5kb3cudXBweS5nZXRQbHVnaW4oJ09uZURyaXZlJylcbiAgaWYgKG9wdHMuT25lRHJpdmUgJiYgIW9uZURyaXZlSW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS51c2UoT25lRHJpdmUsIHsgdGFyZ2V0OiBEYXNoYm9hcmQsIGNvbXBhbmlvblVybDogQ09NUEFOSU9OIH0pXG4gIH1cbiAgaWYgKCFvcHRzLk9uZURyaXZlICYmIG9uZURyaXZlSW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS5yZW1vdmVQbHVnaW4ob25lRHJpdmVJbnN0YW5jZSlcbiAgfVxuXG4gIGNvbnN0IHpvb21JbnN0YW5jZSA9IHdpbmRvdy51cHB5LmdldFBsdWdpbignWm9vbScpXG4gIGlmIChvcHRzLlpvb20gJiYgIXpvb21JbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnVzZShab29tLCB7IHRhcmdldDogRGFzaGJvYXJkLCBjb21wYW5pb25Vcmw6ICdodHRwczovL2ludGVuc2UtbWVhZG93LTYxODEzLmhlcm9rdWFwcC5jb20vJyB9KVxuICB9XG4gIGlmICghb3B0cy5ab29tICYmIHpvb21JbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnJlbW92ZVBsdWdpbih6b29tSW5zdGFuY2UpXG4gIH1cblxuICBjb25zdCB3ZWJjYW1JbnN0YW5jZSA9IHdpbmRvdy51cHB5LmdldFBsdWdpbignV2ViY2FtJylcbiAgaWYgKG9wdHMuV2ViY2FtICYmICF3ZWJjYW1JbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnVzZShXZWJjYW0sIHtcbiAgICAgIHRhcmdldDogRGFzaGJvYXJkLFxuICAgICAgc2hvd1ZpZGVvU291cmNlRHJvcGRvd246IHRydWUsXG4gICAgfSlcbiAgfVxuICBpZiAoIW9wdHMuV2ViY2FtICYmIHdlYmNhbUluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkucmVtb3ZlUGx1Z2luKHdlYmNhbUluc3RhbmNlKVxuICB9XG5cbiAgY29uc3Qgc2NyZWVuQ2FwdHVyZUluc3RhbmNlID0gd2luZG93LnVwcHkuZ2V0UGx1Z2luKCdTY3JlZW5DYXB0dXJlJylcbiAgaWYgKG9wdHMuU2NyZWVuQ2FwdHVyZSAmJiAhc2NyZWVuQ2FwdHVyZUluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkudXNlKFNjcmVlbkNhcHR1cmUsIHsgdGFyZ2V0OiBEYXNoYm9hcmQgfSlcbiAgfVxuICBpZiAoIW9wdHMuU2NyZWVuQ2FwdHVyZSAmJiBzY3JlZW5DYXB0dXJlSW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS5yZW1vdmVQbHVnaW4oc2NyZWVuQ2FwdHVyZUluc3RhbmNlKVxuICB9XG5cbiAgY29uc3QgaW1hZ2VFZGl0b3JJbnN0YW5jZSA9IHdpbmRvdy51cHB5LmdldFBsdWdpbignSW1hZ2VFZGl0b3InKVxuICBpZiAob3B0cy5pbWFnZUVkaXRvciAmJiAhaW1hZ2VFZGl0b3JJbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnVzZShJbWFnZUVkaXRvciwgeyB0YXJnZXQ6IERhc2hib2FyZCB9KVxuICB9XG4gIGlmICghb3B0cy5pbWFnZUVkaXRvciAmJiBpbWFnZUVkaXRvckluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkucmVtb3ZlUGx1Z2luKGltYWdlRWRpdG9ySW5zdGFuY2UpXG4gIH1cblxuICBjb25zdCBkcm9wVGFyZ2V0SW5zdGFuY2UgPSB3aW5kb3cudXBweS5nZXRQbHVnaW4oJ0Ryb3BUYXJnZXQnKVxuICBpZiAob3B0cy5Ecm9wVGFyZ2V0ICYmICFkcm9wVGFyZ2V0SW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS51c2UoRHJvcFRhcmdldCwgeyB0YXJnZXQ6IGRvY3VtZW50LmJvZHkgfSlcbiAgfVxuICBpZiAoIW9wdHMuRHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0SW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS5yZW1vdmVQbHVnaW4oZHJvcFRhcmdldEluc3RhbmNlKVxuICB9XG5cbiAgY29uc3QgZ29sZGVuUmV0cmlldmVySW5zdGFuY2UgPSB3aW5kb3cudXBweS5nZXRQbHVnaW4oJ0dvbGRlblJldHJpZXZlcicpXG4gIGlmIChvcHRzLkdvbGRlblJldHJpZXZlciAmJiAhZ29sZGVuUmV0cmlldmVySW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS51c2UoR29sZGVuUmV0cmlldmVyKVxuICB9XG4gIGlmICghb3B0cy5Hb2xkZW5SZXRyaWV2ZXIgJiYgZ29sZGVuUmV0cmlldmVySW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS5yZW1vdmVQbHVnaW4oZ29sZGVuUmV0cmlldmVySW5zdGFuY2UpXG4gIH1cbn1cblxuZnVuY3Rpb24gd2hlbkxvY2FsZUF2YWlsYWJsZSAobG9jYWxlTmFtZSwgY2FsbGJhY2spIHtcbiAgY29uc3QgaW50ZXJ2YWwgPSAxMDAgLy8gbXNcbiAgY29uc3QgbG9vcCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICBpZiAod2luZG93LlVwcHkgJiYgd2luZG93LlVwcHkubG9jYWxlcyAmJiB3aW5kb3cuVXBweS5sb2NhbGVzW2xvY2FsZU5hbWVdKSB7XG4gICAgICBjbGVhckludGVydmFsKGxvb3ApXG4gICAgICBjYWxsYmFjayh3aW5kb3cuVXBweS5sb2NhbGVzW2xvY2FsZU5hbWVdKVxuICAgIH1cbiAgfSwgaW50ZXJ2YWwpXG59XG5cbmZ1bmN0aW9uIGxvYWRMb2NhbGVGcm9tQ0ROIChsb2NhbGVOYW1lKSB7XG4gIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdXG4gIGNvbnN0IGpzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAganMudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnXG4gIGpzLnNyYyA9IGBodHRwczovL3JlbGVhc2VzLnRyYW5zbG9hZGl0LmNvbS91cHB5L2xvY2FsZXMvdjEuMjEuMC8ke2xvY2FsZU5hbWV9Lm1pbi5qc2BcblxuICBoZWFkLmFwcGVuZENoaWxkKGpzKVxufVxuXG5mdW5jdGlvbiBzZXRMb2NhbGUgKGxvY2FsZU5hbWUpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cuVXBweS5sb2NhbGVzW2xvY2FsZU5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgIGxvYWRMb2NhbGVGcm9tQ0ROKGxvY2FsZU5hbWUpXG4gIH1cbiAgd2hlbkxvY2FsZUF2YWlsYWJsZShsb2NhbGVOYW1lLCAobG9jYWxlT2JqKSA9PiB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gUlRMX0xPQ0FMRVMuaW5kZXhPZihsb2NhbGVOYW1lKSAhPT0gLTFcbiAgICAgID8gJ3J0bCdcbiAgICAgIDogJ2x0cidcblxuICAgIHdpbmRvdy51cHB5LnNldE9wdGlvbnMoe1xuICAgICAgbG9jYWxlOiBsb2NhbGVPYmosXG4gICAgfSlcblxuICAgIHdpbmRvdy51cHB5LmdldFBsdWdpbignRGFzaGJvYXJkJykuc2V0T3B0aW9ucyh7XG4gICAgICBkaXJlY3Rpb24sXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gcG9wdWxhdGVMb2NhbGVTZWxlY3QgKCkge1xuICBjb25zdCBsb2NhbGVTZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9jYWxlTGlzdCcpXG5cbiAgT2JqZWN0LmtleXMobG9jYWxlTGlzdCkuZm9yRWFjaChsb2NhbGVOYW1lID0+IHtcbiAgICBpZiAobG9jYWxlTmFtZSA9PT0gJ2VuX1VTJykgcmV0dXJuXG4gICAgbG9jYWxlU2VsZWN0LmlubmVySFRNTCArPSBgPG9wdGlvbiB2YWx1ZT1cIiR7bG9jYWxlTmFtZX1cIj4ke2xvY2FsZUxpc3RbbG9jYWxlTmFtZV19IOKAlCAoJHtsb2NhbGVOYW1lfSk8L29wdGlvbj5gXG4gIH0pXG5cbiAgbG9jYWxlU2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChldmVudCkgPT4ge1xuICAgIGNvbnN0IGxvY2FsZU5hbWUgPSBldmVudC50YXJnZXQudmFsdWVcbiAgICBzZXRMb2NhbGUobG9jYWxlTmFtZSlcbiAgfSlcbn1cblxud2luZG93LnVwcHlTZXRPcHRpb25zID0gdXBweVNldE9wdGlvbnNcbndpbmRvdy51cHB5SW5pdCA9IHVwcHlJbml0XG53aW5kb3cudXBweVNldExvY2FsZSA9IHNldExvY2FsZVxuXG5wb3B1bGF0ZUxvY2FsZVNlbGVjdCgpXG51cHB5SW5pdCgpXG51cHB5U2V0T3B0aW9ucygpXG4iLCJsZXQgY29tcGFuaW9uRW5kcG9pbnQgPSAnaHR0cDovL2xvY2FsaG9zdDozMDIwJ1xuXG5pZiAobG9jYXRpb24uaG9zdG5hbWUgPT09ICd1cHB5LmlvJyB8fCAvLS11cHB5XFwubmV0bGlmeVxcLmFwcCQvLnRlc3QobG9jYXRpb24uaG9zdG5hbWUpKSB7XG4gIGNvbXBhbmlvbkVuZHBvaW50ID0gJy8vY29tcGFuaW9uLnVwcHkuaW8nXG59XG5cbmNvbnN0IENPTVBBTklPTiA9IGNvbXBhbmlvbkVuZHBvaW50XG5tb2R1bGUuZXhwb3J0cyA9IENPTVBBTklPTlxuIiwibW9kdWxlLmV4cG9ydHM9e1wiYXJfU0FcIjpcIkFyYWJpYyAoU2F1ZGkgQXJhYmlhKVwiLFwiYmdfQkdcIjpcIkJ1bGdhcmlhbiAoQnVsZ2FyaWEpXCIsXCJjc19DWlwiOlwiQ3plY2ggKEN6ZWNoaWEpXCIsXCJkYV9ES1wiOlwiRGFuaXNoIChEZW5tYXJrKVwiLFwiZGVfREVcIjpcIkdlcm1hbiAoR2VybWFueSlcIixcImVsX0dSXCI6XCJHcmVlayAoR3JlZWNlKVwiLFwiZW5fVVNcIjpcIkVuZ2xpc2ggKFVuaXRlZCBTdGF0ZXMpXCIsXCJlc19FU1wiOlwiU3BhbmlzaCAoU3BhaW4pXCIsXCJmYV9JUlwiOlwiUGVyc2lhbiAoSXJhbilcIixcImZpX0ZJXCI6XCJGaW5uaXNoIChGaW5sYW5kKVwiLFwiZnJfRlJcIjpcIkZyZW5jaCAoRnJhbmNlKVwiLFwiZ2xfRVNcIjpcIkdhbGljaWFuIChTcGFpbilcIixcImhlX0lMXCI6XCJIZWJyZXcgKElzcmFlbClcIixcImhyX0hSXCI6XCJDcm9hdGlhbiAoQ3JvYXRpYSlcIixcImh1X0hVXCI6XCJIdW5nYXJpYW4gKEh1bmdhcnkpXCIsXCJpZF9JRFwiOlwiSW5kb25lc2lhbiAoSW5kb25lc2lhKVwiLFwiaXNfSVNcIjpcIkljZWxhbmRpYyAoSWNlbGFuZClcIixcIml0X0lUXCI6XCJJdGFsaWFuIChJdGFseSlcIixcImphX0pQXCI6XCJKYXBhbmVzZSAoSmFwYW4pXCIsXCJrb19LUlwiOlwiS29yZWFuIChTb3V0aCBLb3JlYSlcIixcIm5iX05PXCI6XCJOb3J3ZWdpYW4gQm9rbcOlbCAoTm9yd2F5KVwiLFwibmxfTkxcIjpcIkR1dGNoIChOZXRoZXJsYW5kcylcIixcInBsX1BMXCI6XCJQb2xpc2ggKFBvbGFuZClcIixcInB0X0JSXCI6XCJQb3J0dWd1ZXNlIChCcmF6aWwpXCIsXCJwdF9QVFwiOlwiUG9ydHVndWVzZSAoUG9ydHVnYWwpXCIsXCJyb19ST1wiOlwiUm9tYW5pYW4gKFJvbWFuaWEpXCIsXCJydV9SVVwiOlwiUnVzc2lhbiAoUnVzc2lhKVwiLFwic2tfU0tcIjpcIlNsb3ZhayAoU2xvdmFraWEpXCIsXCJzcl9SU19DeXJpbGxpY1wiOlwiU2VyYmlhbiAoU2VyYmlhLCBDeXJpbGxpYylcIixcInNyX1JTX0xhdGluXCI6XCJTZXJiaWFuIChTZXJiaWEsIExhdGluKVwiLFwic3ZfU0VcIjpcIlN3ZWRpc2ggKFN3ZWRlbilcIixcInRoX1RIXCI6XCJUaGFpIChUaGFpbGFuZClcIixcInRyX1RSXCI6XCJUdXJraXNoIChUdXJrZXkpXCIsXCJ1a19VQVwiOlwiVWtyYWluaWFuIChVa3JhaW5lKVwiLFwidmlfVk5cIjpcIlZpZXRuYW1lc2UgKFZpZXRuYW0pXCIsXCJ6aF9DTlwiOlwiQ2hpbmVzZSAoQ2hpbmEpXCIsXCJ6aF9UV1wiOlwiQ2hpbmVzZSAoVGFpd2FuKVwifSJdfQ==
